{"title": "Alloy*: A general-purpose higher-order relational constraint solver\n", "abstract": " The last decade has seen a dramatic growth in the use of constraint solvers as a computational mechanism, not only for analysis of software, but also at runtime. Solvers are available for a variety of logics but are generally restricted to first-order formulas. Some tasks, however, most notably those involving synthesis, are inherently higher order; these are typically handled by embedding a first-order solver (such as a SAT or SMT solver) in a domain-specific algorithm. Using strategies similar to those used in such algorithms, we show how to extend a first-order solver (in this case Kodkod, a model finder for relational logic used as the engine of the Alloy Analyzer) so that it can handle quantifications over higher-order structures. The resulting solver is sufficiently general that it can be applied to a range of problems; it is higher order, so that it can be applied directly, without embedding in another algorithm; and it performs\u00a0\u2026", "num_citations": "78\n", "authors": ["1121"]}
{"title": "Unifying execution of imperative and declarative code\n", "abstract": " We present a unified environment for running declarative specifications in the context of an imperative object-Oriented programming language. Specifications are Alloy-like, written in first-order relational logic with transitive closure, and the imperative language is Java. By being able to mix imperative code with executable declarative specifications, the user can easily express constraint problems in place, ie, in terms of the existing data structures and objects on the heap. After a solution is found, the heap is updated to reflect the solution, so the user can continue to manipulate the program heap in the usual imperative way. We show that this approach is not only convenient, but, for certain problems can also outperform a standard imperative implementation. We also present an optimization technique that allowed us to run our tool on heaps with almost 2000 objects.", "num_citations": "52\n", "authors": ["1121"]}
{"title": "Regression test selection across JVM boundaries\n", "abstract": " Modern software development processes recommend that changes be integrated into the main development line of a project multiple times a day. Before a new revision may be integrated, developers practice regression testing to ensure that the latest changes do not break any previously established functionality. The cost of regression testing is high, due to an increase in the number of revisions that are introduced per day, as well as the number of tests developers write per revision. Regression test selection (RTS) optimizes regression testing by skipping tests that are not affected by recent project changes. Existing dynamic RTS techniques support only projects written in a single programming language, which is unfortunate knowing that an open-source project is on average written in several programming languages.", "num_citations": "29\n", "authors": ["1121"]}
{"title": "Agile specifications\n", "abstract": " Traditional formal methods and modern agile methods are separated more by limitations of current technology than by fundamental intellectual differences. A mixed interpreter that executes mixed programs, comprising both declarative specification statements and regular imperative statements, might bridge the gap. This paper explores how such an interpreter might be used, showing by example how it might support a variety of development activities.", "num_citations": "26\n", "authors": ["1121"]}
{"title": "Program extrapolation with Jennisys\n", "abstract": " The desired behavior of a program can be described using an abstract model. Compiling such a model into executable code requires advanced compilation techniques known as synthesis. This paper presents an object-based language, called Jennisys, where programming is done by introducing an abstract model, defining a concrete data representation for the model, and then being aided by automatic synthesis to produce executable code. The paper also presents a synthesis technique for the language. The technique is built on an automatic program verifier that, via an underlying SMT solver, is capable of providing concrete models to failed verifications. The technique proceeds by obtaining sample input/output values from concrete models and then extrapolating programs from the sample points. The synthesis aims to produce code with assignments, branching structure, and possibly recursive calls. It is the\u00a0\u2026", "num_citations": "24\n", "authors": ["1121"]}
{"title": "Model checking using SMT and theory of lists\n", "abstract": " A main idea underlying bounded model checking is to limit the length of the potential counter-examples, and then prove properties for the bounded version of the problem. In software model checking, that means that only program traces up to a given length are considered. Additionally, the program\u2019s input space must be made finite by defining bounds for all input parameters. To ensure the finiteness of the program traces, these techniques typically require that all loops are explicitly unrolled some constant number of times. Here, we show how to avoid explicit loop unrolling by using the SMT Theory of Lists to model feasible, potentially unbounded program traces. We argue that this approach is easier to use, and, more importantly, increases the confidence in verification results over the typical bounded approach. To demonstrate the feasibility of this idea, we implemented a fully automated prototype software\u00a0\u2026", "num_citations": "22\n", "authors": ["1121"]}
{"title": "File-level vs. module-level regression test selection for. net\n", "abstract": " Regression testing is used to check the correctness of evolving software. With the adoption of Agile development methodology, the number of tests and software revisions has dramatically increased, and hence has the cost of regression testing. Researchers proposed regression test selection (RTS) techniques that optimize regression testing by skipping tests that are not impacted by recent program changes. Ekstazi is one such state-of-the art technique; Ekstazi is implemented for the Java programming language and has been adopted by several companies and open-source projects.", "num_citations": "21\n", "authors": ["1121"]}
{"title": "Multi-representational security analysis\n", "abstract": " Security attacks often exploit flaws that are not anticipated in an abstract design, but are introduced inadvertently when high-level interactions in the design are mapped to low-level behaviors in the supporting platform. This paper proposes a multi-representational approach to security analysis, where models capturing distinct (but possibly overlapping) views of a system are automatically composed in order to enable an end-to-end analysis. This approach allows the designer to incrementally explore the impact of design decisions on security, and discover attacks that span multiple layers of the system. This paper describes Poirot, a prototype implementation of the approach, and reports on our experience on applying Poirot to detect previously unknown security flaws in publicly deployed systems.", "num_citations": "21\n", "authors": ["1121"]}
{"title": "A lightweight code analysis and its role in evaluation of a dependability case\n", "abstract": " A dependability case is an explicit, end-to-end argument, based on concrete evidence, that a system satisfies a critical property. We report on a case study constructing a dependability case for the control software of a medical device. The key novelty of our approach is a lightweight code analysis that generates a list of side conditions that correspond to assumptions to be discharged about the code and the environment in which it executes. This represents an unconventional trade-off between, at one extreme, more ambitious analyses that attempt to discharge all conditions automatically (but which cannot even in principle handle environmental assumptions), and at the other, flow-or context-insensitive analyses that require more user involvement. The results of the analysis suggested a variety of ways in which the dependability of the system might be improved.", "num_citations": "21\n", "authors": ["1121"]}
{"title": "Build system with lazy retrieval for Java projects\n", "abstract": " In the modern-day development, projects use Continuous Integration Services (CISs) to execute the build for every change in the source code. To ensure that the project remains correct and deployable, a CIS performs a clean build each time. In a clean environment, a build system needs to retrieve the project's dependencies (eg, guava. jar). The retrieval, however, can be costly due to dependency bloat: despite a project using only a few files from each library, the existing build systems still eagerly retrieve all the libraries at the beginning of the build.", "num_citations": "20\n", "authors": ["1121"]}
{"title": "Preventing arithmetic overflows in Alloy\n", "abstract": " In a bounded analysis, arithmetic operators become partial, and a different semantics becomes necessary. One approach, mimicking programming languages, is for overflow to result in wrap-around. Although easy to implement, wrap-around produces unexpected counterexamples that do not correspond to cases that would arise in the unbounded setting. This paper describes a new approach, implemented in the latest version of the Alloy Analyzer, in which instances that would involve overflow are suppressed, and consequently, spurious counterexamples are eliminated. The key idea is to interpret quantifiers so that bound variables range only over values that do not cause overflow.", "num_citations": "14\n", "authors": ["1121"]}
{"title": "\u03b1Rby\u2014An embedding of Alloy in Ruby\n", "abstract": " We present \u03b1Rby\u2014an embedding of the Alloy language in Ruby\u2014and demonstrate the benefits of having a declarative modeling language (backed by an automated solver) embedded in a traditional object-oriented imperative programming language. This approach aims to bring these two distinct paradigms (imperative and declarative) together in a novel way. We argue that having the other paradigm available within the same language is beneficial to both the modeling community of Alloy users and the object-oriented community of Ruby programmers. In this paper, we primarily focus on the benefits for the Alloy community, namely, how \u03b1Rby provides elegant solutions to several well-known, outstanding problems: (1) mixed execution, (2) specifying partial instances, (3) staged model finding.", "num_citations": "14\n", "authors": ["1121"]}
{"title": "Debugging the performance of Maven\u2019s test isolation: Experience report\n", "abstract": " Testing is the most common approach used in industry for checking software correctness. Developers frequently practice reliable testing-executing individual tests in isolation from each other-to avoid test failures caused by test-order dependencies and shared state pollution (eg, when tests mutate static fields). A common way of doing this is by running each test as a separate process. Unfortunately, this is known to introduce substantial overhead. This experience report describes our efforts to better understand the sources of this overhead and to create a system to confirm the minimal overhead possible. We found that different build systems use different mechanisms for communicating between these multiple processes, and that because of this design decision, running tests with some build systems could be faster than with others. Through this inquiry we discovered a significant performance bug in Apache Maven\u2019s\u00a0\u2026", "num_citations": "6\n", "authors": ["1121"]}
{"title": "Alloy*: A higher-order relational constraint solver\n", "abstract": " The last decade has seen a dramatic growth in the use of constraint solvers as a computational mechanism, not only for analysis and synthesis of software, but also at runtime. Solvers are available for a variety of logics but are generally restricted to first-order formulas. Some tasks, however, most notably those involving synthesis, are inherently higher order; these are typically handled by embedding a first-order solver (such as a SAT or SMT solver) in a domain-specific algorithm. Using strategies similar to those used in such algorithms, we show how to extend a first-order solver (in this case Kodkod, a model finder for relational logic used as the engine of the Alloy Analyzer) so that it can handle quantifications over higher-order structures. The resulting solver is sufficiently general that it can be applied to a range of problems; it is higher order, so that it can be applied directly, without embedding in another algorithm; and it performs well enough to be competitive with specialized tools on standard benchmarks. Although the approach is demonstrated for a particular relational logic, the principles behind it could be applied to other first-order solvers. Just as the identification of first-order solvers as reusable backends advanced the performance of specialized tools and simplified their architecture, factoring out higher-ordersolvers may bring similar benefits to a new class of tools.", "num_citations": "6\n", "authors": ["1121"]}
{"title": "VeDebug: regression debugging tool for Java\n", "abstract": " Developers spend substantial time debugging their programs, yet debugging is still one of the most tedious activities. Interactive debuggers have been around for as long as computing, but the way they are used-set a breakpoint, reason about the state, step into/over-has not substantially changed. The last big discoveries, which happened decades ago, include visual debugging (e.g., DDD) and time-travel debugging. Although existing interactive debugging tools provide useful and powerful features, they are limited to a single program execution, e.g., a developer can only see data values and navigate the control flow of a single program execution at a time. We present VeDebug, the first video-based time-travel regression debugging tool to advance users' debugging experience. VeDebug introduces two unique features: (1) regression debugging, i.e., setting a \"divergence breakpoint\" (which \"breaks\" the execution\u00a0\u2026", "num_citations": "2\n", "authors": ["1121"]}
{"title": "Advancing declarative programming\n", "abstract": " This thesis attempts to unite and consolidate two large and often culturally disjoint programming paradigms: declarative (focusing on specifying what a program is supposed to do, e.g., shuffle an array so that its elements are ordered) and imperative (detailing how the program intention is to be implemented, e.g., by applying the QuickSort algorithm). The ultimate result of such an effort would be a unified programming environment in which both paradigms are seamlessly integrated, specifications are fully and efficiently executable, and programs are written by freely mixing imperative statements and declarative specifications. With the advent of automated constraint solving, executing declarative specifications as standalone programs has become feasible. A number of challenges still remain. To achieve full automation, constraint solvers often impose restrictions on specification languages and their expressiveness; compromises are also made when integrating a (typically logic-based) specification language with a traditional procedural programming language; and finally, applicability is usually limited to specialized algorithmic domains (for which constraint solving is particularly suitable) and programmers comfortable with writing formal logic. This thesis proposes several advances to address these issues. First, a novel constraint solving framework is presented, Alloy*, the first of its kind capable of automatically and reliably solving arbitrary higher-order formulas (written in standard predicate logic) over bounded domains. Second, a new approach to integrating a specification and an implementation language is proposed, where Alloy, a relational\u00a0\u2026", "num_citations": "2\n", "authors": ["1121"]}
{"title": "Executable specifications for Java programs\n", "abstract": " In this thesis, we present a unified environment for running declarative specifications in the context of an imperative object-oriented programming language. Specifications are Alloy-like, written in first-order relational logic with transitive closure, and the imperative language for this purpose is Java. By being able to mix imperative code with executable declarative specifications, the user can easily express constraint problems in-place, i.e. in terms of the existing data structures and objects on the heap. After a solution is found, our framework will automatically update the heap to reflect the solution, so the user can continue to manipulate the program heap in the usual imperative way, without ever having to manually translate the problem back and forth between the host programming environment and the solver language. We show that this approach is not only convenient, but, for certain problems, like puzzles or NP-complete graph algorithms, it can also outperform the manual implementation. We also present an optimization technique that allowed us to run our tool on heaps with almost 2000 objects.", "num_citations": "2\n", "authors": ["1121"]}