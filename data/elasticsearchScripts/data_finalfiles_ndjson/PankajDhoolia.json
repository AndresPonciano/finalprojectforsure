{"title": "Using a model-driven transformational approach and service-oriented architecture for service delivery management\n", "abstract": " IT (information technology) service providers often assume that efficient and effective service delivery can be achieved by migrating to a standard set of tools. This assumption is true only if the service provider has monolithic control over the scope and architecture of the customer environment. The trend, however, is toward selective outsourcing, customer control over the architecture of IT solutions, and retention of legacy tools. Target environments are extremely heterogeneous, and the ability of the service provider to control them is diminishing. Consequently, there is a need for a new approach to IT service workflow automation and a new generation of service-delivery management systems that support heterogeneity and collaboration. This paper introduces a new approach to automating complex and variable workflows, applies this approach to IT service delivery management (SDM), presents an SDM architecture\u00a0\u2026", "num_citations": "66\n", "authors": ["1841"]}
{"title": "Siena: From powerpoint to web app in 5 minutes\n", "abstract": " Siena lets users design web applications using commonly available PowerPoint as the modeling/development tool. From PowerPoint, users can model business artifacts and processes, transform applications to a standard representation and then immediately deploy and execute these composite applications on a model execution engine.", "num_citations": "63\n", "authors": ["1841"]}
{"title": "System and a method for cross-platform porting of business application and making them contextually-aware on target platforms\n", "abstract": " A method for cross-platform porting of applications includes extracting one or more platform independent models from an existing one or more composite applications running on a given source platform. These platform independent models are then transformed into implementation artifacts on another, target platform, thereby effectively porting the composite application from one platform to another. The generated implementation artifacts on the target platform leverage existing assets in the target environment, which makes these generated artifacts \u201ccontextually-aware\u201d.", "num_citations": "51\n", "authors": ["1841"]}
{"title": "System and method for generating implementation artifacts for contextually-aware business applications\n", "abstract": " A method for generating implementation artifacts for contextually-aware business applications includes utilizing a platform independent model (PIM) of a business application; generating a platform specific model (PSM) from the PIM, wherein the generating of a PSM includes one or more transformations between one or more meta-models of the PIM and one or more meta-models of the generated PSM; generating implementation artifacts; and binding the generated implementation artifacts with any existing services of the business application.", "num_citations": "47\n", "authors": ["1841"]}
{"title": "A restful architecture for service-oriented business process execution\n", "abstract": " This paper presents a new approach to designing business process management solutions leveraging the principles of service-oriented computing and representational state transfer. We discuss the IT artifacts that underpin this new design, illustrate the design using a real world example, and present an evaluation highlighting several desirable features of our approach.", "num_citations": "42\n", "authors": ["1841"]}
{"title": "Process management using representation state transfer architecture\n", "abstract": " Process management techniques using a representation state transfer architecture include, for example, a method of managing a given process in a data-centric manner in a client/server environment, comprising at least one client and at least one server. In an exemplary method, the server obtains from the client at least one request associated with the given process. In response to the request obtained from the client, the server generates an entity, wherein the generated entity is represented in terms of a data model and a lifecycle model associated therewith, wherein the lifecycle model comprises states and state transitions with each transition caused by one or more activities in the given process, and wherein the given process is represented as a collection of communicating entities. The server sends a response to the at least one request to the client, wherein the response is based at least in part on the\u00a0\u2026", "num_citations": "33\n", "authors": ["1841"]}
{"title": "System and computer program product for facilitating a real-time virtual interaction\n", "abstract": " Techniques for facilitating a real-time virtual interaction between two or more users are provided. The techniques include extracting a dynamically changing context from two or more users, wherein the context comprises at least one of user-provided information and one or more items related to at least one of current activity and past activity of the two or more users, analyzing the context from each user to create a classification for each user, comparing the classification for each user with a classification for each additional user, wherein comparing comprises ordering each user in terms of closeness to each additional user, and using the ordering of each user in terms of closeness to each additional user to facilitate a real-time virtual interaction between two or more users. Techniques are also provided for generating a database of one or more user classifications.", "num_citations": "27\n", "authors": ["1841"]}
{"title": "Method and apparatus for model driven service delivery management\n", "abstract": " Disclosed is an apparatus and method for organizing a service request processing system. The method includes receiving operational model data from domain knowledge, receiving business performance model data from said domain knowledge, developing a solution model based upon said domain knowledge and other data, and implementing a service delivery platform to execute a service request for processing said service request.", "num_citations": "21\n", "authors": ["1841"]}
{"title": "Automated recognition of process modeling semantics in flow diagrams\n", "abstract": " An example embodiment disclosed is a system for automated model extraction of documents containing flow diagrams. An extractor is configured to extract from the flow diagrams flow graphs. The extractor further extracts nodes and edges, and relational, geometric and textual features for the extracted nodes and edges. A classifier is configured to recognize process semantics based on the extracted nodes and edges, and the relational, geometric and textual features of the extracted nodes and edges. A process modeling language code is generated based on the recognized process semantics. Rules to recognize patterns in process diagrams may be determined using supervised learning and/or unsupervised learning. During supervised learning, an expert labels example flow diagrams so that a classifier can derive the classification rules. During unsupervised learning flow diagrams are clustered based on\u00a0\u2026", "num_citations": "16\n", "authors": ["1841"]}
{"title": "A cognitive system for business and technical support: A case study\n", "abstract": " Business and technical support has traditionally been labor based. In this paper, we introduce a cognitive system for business and technical support. This cognitive system is aimed at answering, for example, \u201chow to\u201d and \u201chow do I fix\u201d questions that represent more than half of support help-desk queries. The standard method to build cognitive systems involves collecting the user questions, collecting and curating the domain knowledge, creating ground truth for learning, training, and testing, and continuous learning from user interactions and feedback. However, the lack of actual user questions, quality, and coverage of available enterprise knowledge, ambiguity in user communication, and user expectations on coverage and accuracy pose a challenge in applying the standard method to the domain of technical support. We address this by extracting and modeling users\u2019 support intents and questions from sources\u00a0\u2026", "num_citations": "13\n", "authors": ["1841"]}
{"title": "Transformation of computer programs and eliminating errors\n", "abstract": " A method and system to transform a plurality of programs associated with a plurality of programming languages is provided. In the method, a request is received by a computer to transform a first program in a first programming language to a second program in a second programming language. The first program is then transformed, wherein the transformation includes eliminating errors using predefined criteria. Further, the method maps a statement of the first program with a corresponding statement of the second program.", "num_citations": "13\n", "authors": ["1841"]}
{"title": "System and method to validate and repair process flow drawings\n", "abstract": " Disclosed is a system and method for validating and repairing flow diagrams using a process modeling validation method in conjunction with a process modeling repair method. The process modeling validation method points out structural ambiguities in a flow diagram that can make its automatic interpretation difficult. It also proposes fix to resolve such ambiguities. The method discloses a process semantic annotation scheme that can interpret process semantics in a flow graph implicit in a flow diagram. Further, the validation process compares one or more components of one or more drawings to a set of rules determined by a business process modeling standards and provides a set of semantic errors describing faulty parts of the drawing that do not comply with the business process modeling standards. The process modeling repair method corrects the drawing to ease and enable its automatic interpretation of the\u00a0\u2026", "num_citations": "13\n", "authors": ["1841"]}
{"title": "Catalog based services delivery management\n", "abstract": " Disclosed is an apparatus and method for implementing a repository of services. One embodiment describes a method consisting of defining a plurality of atomic services, providing at least one service composition from the definition of the plurality of atomic services, and combining at least one atomic service associated with the at least one service composition with a service plan. The method further consists of providing a service plan that describes the control and data flow between the at least one of the plurality of atomic services and the at least one service composition.", "num_citations": "13\n", "authors": ["1841"]}
{"title": "Method, system and program storage device for automatic incremental learning of programming language grammar\n", "abstract": " The embodiments provide for automatic incremental learning of programming language grammar. A corpus (ie, a text file of software code written in a particular programming language) is parsed based on a set of grammar rules. An unparsed statement from the corpus is identified along with a section thereof, which did not match any of the grammar rules in the set. A subset of the set of grammar rules at fault for the parsing failure is identified. Groups of new grammar rules are developed such that each group comprises at least one new grammar rule, such that each group can parse the unparsed statement, and such that each new grammar rule is a modification of grammar rule (s) in the subset. One specific group can then be selected for possible incorporation into the set of grammar rules. Optionally, before a specific group is selected, the groups can be heuristically pruned and/or ranked.", "num_citations": "11\n", "authors": ["1841"]}
{"title": "Modifying a language conversation model\n", "abstract": " Provided herein is a system, method, and computer program product for modifying a language conversation model of the language learning system. Modifying the language conversation model includes receiving, using a conversational sub-system, voice inputs. The conversational sub-system converts the voice inputs to voice input data and processes the voice input data. The conversational sub-system detects an error in processing the voice input data and, based at least in part on the error, stores additional data comprising additional voice input data in a memory. The conversational sub-system applies machine learning to the additional data to derive a function that is not enabled within the language conversation model. The conversational sub-system develops an update that enables the language conversation model to implement the function. The update is applied to the language conversation model.", "num_citations": "6\n", "authors": ["1841"]}
{"title": "Method for facilitating a real-time virtual interaction\n", "abstract": " Techniques for facilitating a real-time virtual interaction between two or more users are provided. The techniques include extracting a dynamically changing context from two or more users, wherein the context comprises at least one of user-provided information and one or more items related to at least one of current activity and past activity of the two or more users, analyzing the context from each user to create a classification for each user, comparing the classification for each user with a classification for each additional user, wherein comparing comprises ordering each user in terms of closeness to each additional user, and using the ordering of each user in terms of closeness to each additional user to facilitate a real-time virtual interaction between two or more users. Techniques are also provided for generating a database of one or more user classifications.", "num_citations": "6\n", "authors": ["1841"]}
{"title": "Distributed program tracing\n", "abstract": " Dynamic program analysis techniques depend on accurate program traces. Program instrumentation is commonly used to collect these traces, which causes overhead to the program execution. Various techniques have addressed this problem by minimizing the number of probes/witnesses used to collect traces. In this paper, we present a novel distributed trace collection framework wherein, a program is executed multiple times with the same input for different sets of witnesses. The partial traces such obtained are then merged to create the whole program trace. Such divide-and-conquer strategy enables parallel collection of partial traces, thereby reducing the total time of collection. The problem is particularly challenging as arbitrary distribution of witnesses cannot guarantee correct formation of traces. We provide and prove a necessary and sufficient condition for distributing the witnesses which ensures correct\u00a0\u2026", "num_citations": "6\n", "authors": ["1841"]}
{"title": "Management of dynamic assembly and licensing of appliances\n", "abstract": " Methods and arrangements for assembly and licensing of appliances. A base image is created, the base image corresponding to a combination of an operating system and hardware. A purchasing medium client is embedded into the base image, and a provisioning request for a pay-per-use license is developed. A provisioned instance is started, and a product bundle plan is executed. The license is requested from a purchasing medium.", "num_citations": "6\n", "authors": ["1841"]}
{"title": "Modeling a composite application\n", "abstract": " Techniques for modeling a composite application are provided. The techniques include identifying one or more entities that are processed in a user enterprise, identifying one or more actions to be performed during a lifecycle of the one or more entities, and modeling a composite application based on the one or more actions to be performed during a lifecycle of the one or more entities.", "num_citations": "6\n", "authors": ["1841"]}
{"title": "WAV: Voice access to web information for masses\n", "abstract": " One of the main reasons for a large section of the world population to be left out of the internet revolution is, limited or no access to a computer due to economic, educational, cultural and age factors. Enabling masses to extract information from the web via voice will bring the Internet revolution to additional billions of people. In this paper, we describe a system called WAV (Web Access via Voice), that is a step in this direction. Departing from the traditional approaches of manually building a VoiceXML based site, the WAV system uses information from existing web sites to serve the user. Challenges to overcome include extracting contextually relevant information from the user and also from the pages returned by websites, reducing amount of information relayed to user over phone and maintaining the context of the conversation for easy refinement based on feedback from the user. Our prototype system not only shows successful integration of many different technologies such as automatic speech recognition, scripts for web navigation, text to speech conversion, but also introduces a novel way of extracting information from web via voice in a programmatic manner. We describe initial solutions developed to tackle above challenges and demonstrate the feasibility of the system by describing prototype implementations on two popular web sites in India.", "num_citations": "6\n", "authors": ["1841"]}
{"title": "Performance-aware enterprise components\n", "abstract": " Techniques for generating and executing a performance-aware enterprise component (PAEC) are provided. The techniques include creating a performance-aware enterprise component definition, wherein an enterprise component is a component with defined behavior and data models that represent an enterprise capability and provide a service to a client through a defined interface, and wherein the definition comprises an extensible markup language file comprising process component lifecycle information, one or more data items to be used in the component lifecycle, and one or more performance metrics, and executing the performance-aware enterprise component, wherein executing the performance-aware enterprise component comprises reading the performance-aware enterprise component definition and one or more relationships with the one or more data items, and operating the component lifecycle\u00a0\u2026", "num_citations": "4\n", "authors": ["1841"]}
{"title": "System and method for dynamic code analysis in presence of the table processing idiom\n", "abstract": " Systems and methods execute a computer program to produce a trace of the computer program and divide the trace into independent threads of execution. Each of the independent threads of execution comprises an execution sequence of the lines of programming code that ends with an identified write line of programming code that outputs an incorrect result. These systems and methods also identify key field within each of the independent threads of execution. In programming, which is processing records in a table one by one, key-fields are a subset of the fields of the table. The key fields impact the computations sequence leading up to the identified write line of the programming code. These systems and methods identify key-based dynamic slices from the independent threads of execution. Each of the key-based dynamic slices includes lines of programming code that are used in computations, processing the\u00a0\u2026", "num_citations": "4\n", "authors": ["1841"]}
{"title": "Method for detecting tracking short\n", "abstract": " The present invention relates to method for a detecting tracking short. In some embodiments, the method may include detecting current flowing on an electric circuit. In other embodiments, the method may include calculating the frequency distribution of the variation of the current detected in a predetermined period. In an embodiment, the method may include outputting a detecting signal in case the frequency of variations included in the predetermined range satisfies a judgement reference.", "num_citations": "4\n", "authors": ["1841"]}
{"title": "Toward the Development of Contextually Aware Business Applications via Model-Driven Transformations\n", "abstract": " While the traditional model driven development techniques are useful for building solutions in a reusable manner, they do not say much about how the existing assets in a client environment can be leveraged effectively and efficiently. In this work, we enhance model driven transformation techniques to generate implementation artifacts on a given platform from platform independent models while leveraging the existing assets in a client environment. We apply semantic Web service matching technology to achieve automatic binding of generated artifacts with available client assets. By generating implementation artifacts that are bound where appropriate with clientspsila existing functionality, our approach helps cut down the development time during project implementations and thereby resulting in reduced project durations and costs. We demonstrate the feasibility of the two platforms: IBM WebSphere and SAP\u00a0\u2026", "num_citations": "3\n", "authors": ["1841"]}
{"title": "The deep structure of service management\n", "abstract": " This paper presents a new approach for the management and engineering of IT-enabled services. Based on the analysis of several real world application scenarios, we propose a \"deep structure\" for IT- enabled service management. We introduce the concept of a business artifact in defining this deep structure. We leverage this deep structure in conjunction with representational state transfer (REST) to design and build a platform for service management. Our approach radically simplifies the management and engineering of IT-enabled services and provides a highly flexible and end-user configurable system for service management.", "num_citations": "3\n", "authors": ["1841"]}
{"title": "Conversational agent generation\n", "abstract": " One embodiment provides a method, including: obtaining a plurality of conversational logs; generating a human agent emulator and a user emulator; providing a workspace for a conversational agent, so that an agent designer generates a conversational specification for the conversational agent, wherein the generating a conversational specification comprises: receiving a selection, by the agent designer, of at least one intent for the conversational agent, wherein the receiving a selection is responsive to the conversational agent workspace providing suggestions for intents; providing at least one suggestion for a dialog node that corresponds to the selected at least one intent; and generating a dialog flow for the conversational agent, wherein the generating comprises iteratively receiving, from the agent designer, selection of at least one aspect and receiving at least one selection of the at least one suggestion for\u00a0\u2026", "num_citations": "2\n", "authors": ["1841"]}
{"title": "Collecting and attaching a bug trace to a problem information technology ticket\n", "abstract": " Methods and arrangements for enhancing a ticket relative to user interaction with a system. An information technology ticket related to user interaction with an information technology system is received, and a system trace is activated, wherein additional input related to the user interaction with the information technology system is accepted. Information derived from the trace of the information technology system is associated with the information technology ticket. Other variants and embodiments are broadly contemplated herein.", "num_citations": "2\n", "authors": ["1841"]}
{"title": "Program integration that accommodates restrictions on merge-locations\n", "abstract": " Methods, systems, and articles of manufacture for program integration are provided herein. A method includes identifying each varying portion of a customized version of a program as compared to a standard version of the program; identifying each common portion of the customized version as compared to the standard version; merging the customized version with the standard version to create a merged version of the program based on the identified common portions and the identified varying portions such that semantics of both the customized version and the standard version are preserved in the merged program; associating each change contributed by the customized version, represented by the varying portions in the merged version, to a defined extension point in the merged version; and generating a program extension for the standard version for each span of the program contained in a defined extension\u00a0\u2026", "num_citations": "2\n", "authors": ["1841"]}
{"title": "A model driven framework for it transformation\n", "abstract": " IT organizations are faring significant business and technical challenges today. On the business realm, companies are increasingly outsourcing their IT operations to specialized IT services firms. On the technical side, new architectural approaches such as Model Driven Architecture and Service Oriented Architecture are fundamentally changing IT management. In response to these challenges, Business-driven IT management (BDIM) has emerged as a new approach lo IT management that bridges Business IT gap, improves the quality of IT services, and optimizes IT operations. In this paper, we present a multi- layer modeling framework to support BDIM, introduce a versatile Service Delivery Management (SDM) platform for IT service delivery, and use the construction of the SDM platform to demonstrate the modeling framework in action.", "num_citations": "2\n", "authors": ["1841"]}
{"title": "Catalog driven interactive conversational platform\n", "abstract": " A computer receives a conversational input. The computer detects, based on the conversational input, relevant entities and relevant entity values, wherein the relevant entities and relevant entity values correspond to entities and entity values extracted from a catalog. The computer identifies, based on the relevant entities and relevant entity values, one or more matching products or services. The computer displays the one or more matching products or services. The computer assesses one or more attributes of the matching products or services for refinement. The computer provides one or more attribute refinement options based on the assessed one or more attributes. The computer receives user refinement in response to providing the one or more attribute refinement options. The computer receives a product or service selection.", "num_citations": "1\n", "authors": ["1841"]}
{"title": "Computing program equivalence based on a hierarchy of program semantics and related canonical representations\n", "abstract": " Methods, systems, and articles of manufacture for computing program equivalence based on a hierarchy of program semantics and related canonical representations are provided herein. A method includes defining a program semantic representation for a first program; generating a search query based on said semantic representation for the first program; executing said search query against an index of multiple programs to determine a set of candidate programs among the multiple programs, wherein said index comprises a program semantic representation defined for each of the multiple programs; and identifying one or more programs among the set of candidate programs that match the first program by performing one or more comparisons, across the set of candidate programs, of a canonical representation associated with each program in the identified set of candidate programs to a canonical representation\u00a0\u2026", "num_citations": "1\n", "authors": ["1841"]}
{"title": "A framework for analyzing programs written in proprietary languages\n", "abstract": " There are several commercial products that use proprietary languages, which typically look like a wrapper around (some proprietary extension of) the standard SQL language. Examples of these languages include ABAP, Informix, XBase++, SQR and so on. These application are difficult to analyze not only because it is hard to model the semantics of the underlying database systems but also because of the lack of standard tools for analysis. One naive way to analyse such programs is to collect dynamic trace using proprietary debuggers and run the analyses on the trace. However, this form of dynamic trace collection can be a severe performance bottleneck. In this paper, we present our experience with building a framework to help in efficient program analysis in the context of ticket resolution for ABAP programs.", "num_citations": "1\n", "authors": ["1841"]}