{"title": "A change-based approach to software evolution\n", "abstract": " Software evolution research is limited by the amount of information available to researchers: Current version control tools do not store all the information generated by developers. They do not record every intermediate version of the system issued, but only snapshots taken when a developer commits source code into the repository. Additionally, most software evolution analysis tools are not a part of the day-to-day programming activities, because analysis tools are resource intensive and not integrated in development environments. We propose to model development information as change operations that we retrieve directly from the programming environment the developers are using, while they are effecting changes to the system. This accurate and incremental information opens new ways for both developers and researchers to explore and evolve complex systems.", "num_citations": "165\n", "authors": ["179"]}
{"title": "How program history can improve code completion\n", "abstract": " Code completion is a widely used productivity tool. It takes away the burden of remembering and typing the exact names of methods or classes: As a developer starts typing a name, it provides a progressively refined list of candidates matching the name. However, the candidate list always comes in alphabetic order, i.e., the environment is only second-guessing the name based on pattern matching. Finding the correct candidate can be cumbersome or slower than typing the full name. We present an approach to improve code completion with program history. We define a benchmark measuring the accuracy and usefulness of a code completion engine. Further, we use the change history data to also improve the results offered by code completion tools. Finally, we propose an alternative interface for completion tools.", "num_citations": "151\n", "authors": ["179"]}
{"title": "Spyware: A change-aware development toolset\n", "abstract": " Our research is driven by the motivation that change must be put in the center, if one wants to understand the complex processes of software evolution. We built a toolset named SpyWare which, using a monitoring plug-in for integrated development environments (IDEs), tracks the changes that a developer performs on a program as they happen. SpyWare stores these first-class changes in a change repository and offers a plethora of productivity-enhancing IDE extensions to exploit the recorded information.", "num_citations": "124\n", "authors": ["179"]}
{"title": "How (and why) developers use the dynamic features of programming languages: the case of smalltalk\n", "abstract": " The dynamic and reflective features of programming languages are powerful constructs that programmers often mention as extremely useful. However, the ability to modify a program at runtime can be both a boon\u2014in terms of flexibility\u2014, and a curse\u2014in terms of tool support. For instance, usage of these features hampers the design of type systems, the accuracy of static analysis techniques, or the introduction of optimizations by compilers. In this paper, we perform an empirical study of a large Smalltalk codebase\u2014often regarded as the poster-child in terms of availability of these features\u2014, in order to assess how much these features are actually used in practice, whether some are used more than others, and in which kinds of projects. In addition, we performed a qualitative analysis of a representative sample of usages of dynamic features in order to uncover (1)\u00a0the principal reasons that drive people to use\u00a0\u2026", "num_citations": "96\n", "authors": ["179"]}
{"title": "How do API documentation and static typing affect API usability?\n", "abstract": " When developers use Application Programming Interfaces (APIs), they often rely on documentation to assist their tasks. In previous studies, we reported evidence indicating that static type systems acted as a form of implicit documentation, benefiting developer productivity. Such implicit documentation is easier to maintain, given it is enforced by the compiler, but previous experiments tested users without any explicit documentation. In this paper, we report on a controlled experiment and an exploratory study comparing the impact of using documentation and a static or dynamic type system on a development task. Results of our study both confirm previous findings and show that the benefits of static typing are strengthened with explicit documentation, but that this was not as strongly felt with dynamically typed languages.", "num_citations": "93\n", "authors": ["179"]}
{"title": "Mining a change-based software repository\n", "abstract": " Although state-of-the-art software repositories based on versioning system information are useful to assess the evolution of a software system, the information they contain is limited in several ways. Versioning systems such as CVS or subversion store only snapshots of text files, leading to a loss of information: The exact sequence of changes between two versions is hard to recover. In this paper we present an alternative information repository which stores incremental changes to the system under study, retrieved from the IDE used to build the software. We then use this change-based model of system evolution to assess when refactorings happen in two case studies, and compare our findings with refactoring detection approaches on classical versioning system repositories.", "num_citations": "93\n", "authors": ["179"]}
{"title": "Improving code completion with program history\n", "abstract": " Code completion is a widely used productivity tool. It takes away the burden of remembering and typing the exact names of methods or classes: As a developer starts typing a name, it provides a progressively refined list of candidates matching the name. However, the candidate list usually comes in alphabetic order, i.e., the environment is only second-guessing the name based on pattern matching, relying on human intervention to pick the correct one. Finding the correct candidate can thus be cumbersome or slower than typing the full name.               We present an approach to improve code completion based on recorded program histories. We define a benchmarking procedure measuring the accuracy of a code completion engine and apply it to several completion algorithms on a dataset consisting of the history of several systems. Further, we use the change history data to improve the results offered by\u00a0\u2026", "num_citations": "92\n", "authors": ["179"]}
{"title": "Versioning systems for evolution research\n", "abstract": " Research in evolution goes on par with the use of versioning systems by developers of the case studies. There is a great diversity of versioning systems with advantages and disadvantages both from the technical as well as from the conceptual point of view. In this paper we analyze the currently used versioning systems from the point of view of a software evolution researcher. Thus we do not focus on whether a certain versioning system is technically better than another one, but rather on what kind of information it offers for software evolution research. We present a non-exhaustive list of dimensions that are important for performing research in software evolution, do a survey on the current main-stream versioning systems and discuss what is actually needed for future versioning systems to support both software evolution and the related research field.", "num_citations": "80\n", "authors": ["179"]}
{"title": "An empirical study on the impact of static typing on software maintainability\n", "abstract": " Static type systems play an essential role in contemporary programming languages. Despite their importance, whether static type systems impact human software development capabilities remains open. One frequently mentioned argument in favor of static type systems is that they improve the maintainability of software systems\u2014an often-used claim for which there is little empirical evidence. This paper describes an experiment that tests whether static type systems improve the maintainability of software systems, in terms of understanding undocumented code, fixing type errors, and fixing semantic errors. The results show rigorous empirical evidence that static types are indeed beneficial to these activities, except when fixing semantic errors. We further conduct an exploratory analysis of the data in order to understand possible reasons for the effect of type systems on the three kinds of tasks used in this\u00a0\u2026", "num_citations": "78\n", "authors": ["179"]}
{"title": "Do static type systems improve the maintainability of software systems? An empirical study\n", "abstract": " Static type systems play an essential role in contemporary programming languages. Despite their importance, whether static type systems influence human software development capabilities remains an open question. One frequently mentioned argument for static type systems is that they improve the maintainability of software systems - an often used claim for which there is no empirical evidence. This paper describes an experiment which tests whether static type systems improve the maintainability of software systems. The results show rigorous empirical evidence that static type are indeed beneficial to these activities, except for fixing semantic errors.", "num_citations": "71\n", "authors": ["179"]}
{"title": "Language-independent clone detection applied to plagiarism detection\n", "abstract": " Clone detection is usually applied in the context of detecting small-to medium scale fragments of duplicated code in large software systems. In this paper, we address the problem of clone detection applied to plagiarism detection in the context of source code assignments done by computer science students. Plagiarism detection comes with a distinct set of constraints to usual clone detection approaches, which influenced the design of the approach we present in this paper. For instance, the source code can be heavily changed at a superficial level (in an attempt to look genuine), yet be functionally very similar. Since assignments turned in by computer science students can be in a variety of languages, we work at the syntactic level and do not consider the source-code semantics. Consequently, the approach we propose is endogenous and makes no assumption about the programming language being analysed. It is\u00a0\u2026", "num_citations": "71\n", "authors": ["179"]}
{"title": "An empirical study of the influence of static type systems on the usability of undocumented software\n", "abstract": " Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion\u00a0\u2026", "num_citations": "70\n", "authors": ["179"]}
{"title": "Characterizing and understanding development sessions\n", "abstract": " The understanding of development sessions, the phases during which a developer actively modifies a software system, is a valuable asset for program comprehension, since the sessions directly impact the current state and future evolution of a software system. Such information is usually lost by state-of-the-art versioning systems, because of the checkin/checkout model they rely on: a developer must explicitly commit his changes to the repository. Since this happens in arbitrary and sometimes long intervals, recovering the changes between two commits is difficult and inaccurate, and recovering the order of the changes is impossible. We have implemented an evolution monitoring prototype which records every semantic change performed on a system, and is able to completely reconstruct development sessions. In this paper we use this fine-grained information to understand and characterize the development\u00a0\u2026", "num_citations": "65\n", "authors": ["179"]}
{"title": "Of change and software\n", "abstract": " Software changes. Any long-lived software system has maintenance costs dominating its initial development costs as it is adapted to new or changing requirements. Systems on which such continuous changes are performed inevitably decay, making each maintenance task harder. This problem is not new: The software evolution research community has been tackling it for more than two decades. However, most approaches have been targeting individual tasks using an ad-hoc model of software evolution.Instead of only addressing individual maintenance tasks, we propose to take a step back and address the software evolution problem at its root by treating change as a first-class entity. We apply the strategy of reification, used with success in other branches of software engineering, to the changes software systems experience. Our thesis is that a reified change-based representation of software enables better evolution support for both reverse and forward engineering activities. To this aim, we present our approach, Change-based Software Evolution, in which first-class changes to programs are recorded as they happen.", "num_citations": "49\n", "authors": ["179"]}
{"title": "Using developer interaction data to compare expertise metrics\n", "abstract": " The expertise of a software developer is said to be a crucial factor for the development time required to complete a task. Even if this hypothesis is intuitive, research has not yet quantified the effect of developer expertise on development time. A related problem is that the design space for expertise metrics is large; out of the various automated expertise metrics proposed, we do not know which metric most reliably captures expertise. What prevents a proper evaluation of expertise metrics and their relation with development time is the lack of data on development tasks, such as their precise duration. Fortunately, this data is starting to become available in the form of growing developer interaction repositories. We show that applying MSR techniques to these developer interaction repositories gives us the necessary tools to perform such an evaluation.", "num_citations": "42\n", "authors": ["179"]}
{"title": "Example-based program transformation\n", "abstract": " Software changes. During their life cycle, software systems experience a wide spectrum of changes, from minor modifications to major architectural shifts. Small-scale changes are usually performed with text editing and refactorings, while large-scale transformations require dedicated program transformation languages. For medium-scale transformations, both approaches have disadvantages. Manual modifications may require a myriad of similar yet not identical edits, leading to errors and omissions, while program transformation languages have a steep learning curve, and thus only pay off for large-scale transformations.                 We present a system supporting example-based program transformation. To define a transformation, a programmer performs an example change manually, feeds it into our system, and generalizes it to other application contexts. With time, a developer can build a palette of\u00a0\u2026", "num_citations": "38\n", "authors": ["179"]}
{"title": "An empirical study of work fragmentation in software evolution tasks\n", "abstract": " Information workers and software developers are exposed to work fragmentation, an interleaving of activities and interruptions during their normal work day. Small-scale observational studies have shown that this can be detrimental to their work. In this paper, we perform a large-scale study of this phenomenon for the particular case of software developers performing software evolution tasks. Our study is based on several thousands interaction traces collected by Mylyn, for dozens of developers. We observe that work fragmentation is correlated to lower observed productivity at both the macro level (for entire sessions), and at the micro level (around markers of work fragmentation); further, longer activity switches seem to strengthen the effect. These observations are basis for subsequent studies investigating the phenomenon of work fragmentation.", "num_citations": "37\n", "authors": ["179"]}
{"title": "An empirical comparison of static and dynamic type systems on api usage in the presence of an ide: Java vs. groovy with eclipse\n", "abstract": " Several studies have concluded that static type systems offer an advantage over dynamic type systems for programming tasks involving the discovery of a new API. However, these studies did not take into account modern IDE features; the advanced navigation and code completion techniques available in modern IDEs could drastically alter their conclusions. This study describes an experiment that compares the usage of an unknown API using Java and Groovy using the IDE Eclipse. It turns out that the previous finding that static type systems improve the usability of an unknown API still holds, even in the presence of a modern IDE.", "num_citations": "32\n", "authors": ["179"]}
{"title": "Refining code ownership with synchronous changes\n", "abstract": " When mining software repositories, two distinct sources of information are usually explored: the history log and snapshots of the system. Results of analyses derived from these two sources are biased by the frequency with which developers commit their changes. We argue that the usage of mainstream SCM (software configuration management) systems influences the way that developers work. For example, since it is tedious to resolve conflicts due to parallel commits, developers tend to minimize conflicts by not contemporarily modifying the same file. This however defeats one of the purposes of such systems. We mine repositories created by our tool Syde, which records changes in a central repository whenever a file is compiled locally in the IDE (integrated development environment) by any developer in a multi-developer project. This new source of information can augment the accuracy of analyses and\u00a0\u2026", "num_citations": "32\n", "authors": ["179"]}
{"title": "Change-based software evolution\n", "abstract": " Software evolution research is limited by the amount of information available to researchers: Current version control tools do not store all the information generated by developers. They do not record every intermediate version of the system issued, but only snapshots taken when a developer commits source code into the repository. Additionally, most software evolution analysis tools are not a part of the day-to-day programming activities, because analysis tools are resource intensive and not integrated in development environments. We propose to model development information as change operations that we retrieve directly from the programming environment the developer is using, while he is effecting changes to the system. This accurate and incremental information opens new ways for both developers and researchers to explore and evolve complex systems.", "num_citations": "24\n", "authors": ["179"]}
{"title": "Are software analytics efforts worthwhile for small companies? The case of Amisoft\n", "abstract": " Amisoft, a Chilean software company with 43 employees, successfully uses software analytics in its projects. These support a variety of strategic and tactical decisions, resulting in less overwork of employees. However, the analytics done at Amisoft are very different from the ones used in larger companies.", "num_citations": "21\n", "authors": ["179"]}
{"title": "Modeling vocabulary for big code machine learning\n", "abstract": " When building machine learning models that operate on source code, several decisions have to be made to model source-code vocabulary. These decisions can have a large impact: some can lead to not being able to train models at all, others significantly affect performance, particularly for Neural Language Models. Yet, these decisions are not often fully described. This paper lists important modeling choices for source code vocabulary, and explores their impact on the resulting vocabulary on a large-scale corpus of 14,436 projects. We show that a subset of decisions have decisive characteristics, allowing to train accurate Neural Language Models quickly on a large corpus of 10,106 projects.", "num_citations": "18\n", "authors": ["179"]}
{"title": "Eclipseye-spying on eclipse\n", "abstract": " Software evolution analysis permits developers and researchers to analyze software sys-tems. It allows seeing the trends that the development of software has, with its present state and predict its future. Today, researchers use the repositories of versioning systems to extract the history of a software, by downloading several versions of a system and then analyzing it. The problem with this approach is that versioning systems do not store all the important details of the development process of software, such as the changes that occur between two successive versions. When developing software, programmers use an Integrated Development Environment (IDE). IDEs make the life of developers easier, by providing automated or semi-automated tools (eg refactoring actions). In order to gather accurate information about the de-velopment process of a software system, a change-based system can be built, which integrates within the IDE the developer is using. We can record relevant events gener-ated in the IDE and process them incrementally. The events we are mainly interested in are class addition, modification and removal, method addition, modification and re-moval, refactoring actions, etc. We implemented a plugin, called EclipsEye, for the Eclipse IDE, and more specifically for the Java programming language. By implementing it we were able to validate the applicability of the change-based approach and the plugin itself. For case studies we installed the plugin on our own Eclipse and we monitored the development of the visu-alization part. Furthermore we asked some of the second semester university students to install it as well, since they\u00a0\u2026", "num_citations": "17\n", "authors": ["179"]}
{"title": "Leveraging small software engineering data sets with pre-trained neural networks\n", "abstract": " Many software engineering data sets, particularly those that demand manual labelling for classification, are necessarily small. As a consequence, several recent software engineering papers have cast doubt on the effectiveness of deep neural networks for classification tasks, when applied to these data sets. We provide initial evidence that recent advances in Natural Language Processing, that allow neural networks to leverage large amount of unlabelled data in a pre-training phase, can significantly improve performance.", "num_citations": "14\n", "authors": ["179"]}
{"title": "Measuring concentration while programming with low-cost BCI devices: differences between debugging and creativity tasks\n", "abstract": " Computing devices have become a primary working tool for many professional roles, among them software programmers. In order to enable a more productive interaction between computers and humans for programming purposes it is important to acquire an awareness of human attention/concentration levels. In this work we report on a controlled experiment to determine if a low-cost BCI (Brain Computer Interface) device is capable of classifying whether a user is fully concentrated while programming, during three typical tasks: creativity (writing code), systematic (documenting the code) and debugging (improving or modifying the code to make it work). This study employs EEG (Electroencephalogram) signals, to measure an individual\u2019s concentration levels. The chosen BCI device is NeuroSky\u2019s Mindwave due to its availability in the market and low cost. The three tasks described are performed in a\u00a0\u2026", "num_citations": "12\n", "authors": ["179"]}
{"title": "Towards change-aware development tools\n", "abstract": " Software development practice still relies on the notion that programming is equivalent to editing text. This view is also supported by mainstream versioning systems, such as CVS and SubVersion, which are excellent at versioning text files. We argue that programming= text editing may have been true years ago, but nowadays we construct complex systems by changing them piecemeal. However, despite recent advances which explicitly support change, such as refactorings and agile development methodologies, most development tools in use are ill-suited to deal with software change: they see a system as a collection of text files. This vision leads to code which is harder to understand since its history is not easily accessible, and harder to change since such a representation of code is against the inherently incremental nature of software development. In this paper we argue that the existing symbiosis between languages and integrated development environments should be extended to support a first-class change-based representation of evolving systems. We analyze the shortcomings of current practice, and illustrate our proposal through a scenario describing what such a change-based model of software would accomplish. We then detail our change-aware development model, its ongoing implementation and the promising results we obtained.", "num_citations": "12\n", "authors": ["179"]}
{"title": "Extensions during software evolution: Do objects meet their promise?\n", "abstract": " As software evolves, data types have to be extended, possibly with new data variants or new operations. Object-oriented design is well-known to support data extensions well. In fact, most popular books showcase data extensions to illustrate how objects adequately support software evolution. Conversely, operation extensions are typically better supported by a functional design. A large body of programming language research has been devoted to the challenge of properly supporting both kinds of extensions.               While this challenge is well-known from a language design standpoint, it has not been studied empirically. We perform such a study on a large sample of Smalltalk projects (over half a billion lines of code) and their evolution over more than 100,000 committed changes.               Our study of extensions during software evolution finds that extensions are indeed prevalent evolution tasks, and that\u00a0\u2026", "num_citations": "11\n", "authors": ["179"]}
{"title": "The ACM SIGSOFT Paper and Peer Review Quality Initiative: Status Report\n", "abstract": " Scholarly peer review is crucial to science: it not only determines what is published where, but also, indirectly, who is hired, funded and promoted. Yet, virtually every academic has peer review horror stories. Empirical evidence suggests that \"peer review is prejudiced, capricious, inefficient, ineffective, and generally unscientific\" [1]. An experiment at a major machine learning conference found that peer review was unreliable highlighted that the outcome of peer review can be very noisy [2, 3]. In May 2019, ACM SIGSOFT launched an initiative to improve the quality of research papers and peer reviews at software engineering venues. It has two main components: empirical standards and recommendations for improving review processes.", "num_citations": "8\n", "authors": ["179"]}
{"title": "Work fragmentation in developer interaction data\n", "abstract": " Information workers and software developers are exposed to work fragmentation, an interleaving of activities and interruptions during their normal work day. Small\u2010scale observational studies have shown that this can be detrimental to their work. In this paper, we perform a large\u2010scale study of this phenomenon for the particular case of software developers performing software evolution tasks. Our study is based on several thousands interaction traces collected by Mylyn and the Eclipse Usage Data Collector. We observe that work fragmentation is correlated to lower observed productivity at both the macro level (for entire sessions) and at the micro level (around markers of work fragmentation); further, longer activity switches seem to strengthen the effect, and different activities seem to be affected differently. These observations give ground for subsequent studies investigating the phenomenon of work fragmentation.", "num_citations": "8\n", "authors": ["179"]}
{"title": "On the evaluation of recommender systems with recorded interactions\n", "abstract": " Recommender systems are Integrated Development Environment (IDE) extensions which assist developers in the task of coding. However, since they assist specific aspects of the general activity of programming, their impact is hard to assess. In previous work, we used with success an evaluation strategy using automated benchmarks to automatically and precisely evaluate several recommender systems, based on recording and replaying developer interactions. In this paper, we highlight the challenges we expect to encounter while applying this approach to other recommender systems.", "num_citations": "7\n", "authors": ["179"]}
{"title": "Object-oriented software extensions in practice\n", "abstract": " As software evolves, data types have to be extended, possibly with new data variants or new operations. Object-oriented design is well-known to support data extensions well. In fact, most popular books showcase data extensions to illustrate how objects adequately support software evolution. Conversely, operation extensions are typically better supported by a functional design. A large body of programming language research has been devoted to the challenge of properly supporting both kinds of extensions. While this challenge is well-known from a language design standpoint, it has not been studied empirically. We perform such a study on a large sample of Smalltalk projects (over half a billion lines of code) and their evolution over more than 130,000 committed changes. Our study of extensions during software evolution finds that extensions are indeed prevalent evolution tasks, and that both kinds of\u00a0\u2026", "num_citations": "6\n", "authors": ["179"]}
{"title": "Static type systems (sometimes) have a positive impact on the usability of undocumented software: An empirical evaluation\n", "abstract": " Static and dynamic type systems (as well as more recently gradual type systems) are an important research topic in programming language design. Although the study of such systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While positions such as these, both for and against static type systems, have been documented in the literature, there is little rigorous empirical evidence for or against either position. In this paper, we introduce a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (which required type annotations) as well as a dynamic type system (which does not). Our results show that for some types of tasks, programmers were afforded faster task completion times using a static type system, while for others, the opposite held. In this work, we document the empirical evidence that led us to this conclusion and conduct an exploratory study to try and theorize why.", "num_citations": "6\n", "authors": ["179"]}
{"title": "Characteristics of method extractions in Java: a large scale empirical study.\n", "abstract": " Extract method is the \u201cSwiss army knife\u201d of refactorings: developers perform method extraction to introduce alternative signatures, decompose long code, improve testability, among many other reasons. Although the rationales behind method extraction are well explored, we are not yet aware of its characteristics. Assessing this information can provide the basis to better understand this important refactoring operation as well as improve refactoring tools and techniques based on the actual behavior of developers. In this paper, we assess characteristics of the extract method refactoring. We rely on a state-of-the-art technique to detect method extraction, and analyze over 70K instances of this refactoring, mined from 124 software systems. We investigate five aspects of this operation: magnitude, content, transformation, size, and degree. We find that (i) the extract method is among the most popular refactorings;(ii) extracted methods are over represented on operations related to creation, validation, and setup;(iii) methods that are targets of the extractions are 2.2 x longer than the average, and they are reduced by one statement after the extraction; and (iv) single method extraction represents most, but not all, of the cases. We conclude by proposing improvements to refactoring detection, suggestion, and automation tools and techniques to support both practitioners and researchers.", "num_citations": "5\n", "authors": ["179"]}
{"title": "Code duplication in ROS launchfiles\n", "abstract": " The middleware for robotics ROS has become the de-facto standard for developing robot applications. Thanks to our experience using ROS we conjectured that the quality of code of ROS is low, yielding a poor user experience for ROS users and posing important barriers to robot software development. In this work we present a first quantification of code quality of the ROS ecosystem through an analysis of code duplication in launchfiles. Our experience led us to believe that these configuration files exhibit a significant amount of code duplication, and this study shows that it is indeed the case. We find that 25% of packages with multiple launchfiles have duplicated code, and that clones are highly similar.", "num_citations": "5\n", "authors": ["179"]}
{"title": "WEON: towards a software ecosystem ONtology\n", "abstract": " The natural distributed character of software ecosystems calls for a shared conceptualization and language to describe their architecture and their evolution. In this regards, ontologies play a central role. In this paper: we argue in favor of such an approach by showing that there is succesful experience applying ontologies to the fields of software engineering and software architecture; show the issues arising in ecosystem evolution and the needs for higher levels of formalization of the description of such processes; finally, we present a roadmap to develop an ontology for this area.", "num_citations": "5\n", "authors": ["179"]}
{"title": "An aspect-based multi-agent system\n", "abstract": " We present how we used Aspect-Oriented Programming (AOP) to ease the development of Multi-Agent Systems (MAS). Our study focuses on the Aalaadin MAS model. We make use of AOP at both the conceptual level of Aalaadin and the implementation level. On the conceptual level, we introduced in Aalaadin AOP concepts. It results in unifying the group concept of Aalaadin with the aspect concept. This unification relies on reflection to allow the definition of groups with intrusive processing. On the implementation level, we used AOP to ease the implementation of a MAS infrastructure. It\u2019s worth noting that the aspects we identified are not specific to the Aalaadin model. Indeed, aspects such as agent message building, messaging strategy or agent lookup are applicable in a variety of MAS.", "num_citations": "5\n", "authors": ["179"]}
{"title": "Lumi\u00e9re: A novel framework for rendering 3d graphics in smalltalk\n", "abstract": " To render 3D graphics there is a number of different frameworks written in Smalltalk. While most of them provide powerful facilities, many of them are outdated, abandoned, undocumented or heavyweight.", "num_citations": "4\n", "authors": ["179"]}
{"title": "Un mod\u00e8le multi-agent unifiant les notions de groupe et d'aspect.\n", "abstract": " Issue des travaux en g\u00e9nie logiciel, la programmation par aspects constitue une avanc\u00e9e significative dans la simplification du d\u00e9veloppement logiciel. En effet, elle introduit une nouvelle dimension pour d\u00e9couper les applications en modules, de sorte \u00e0 offrir de nouvelles opportunit\u00e9s de r\u00e9utilisation et faciliter la maintenance et l\u2019\u00e9volution du logiciel. Nous proposons dans cet article d\u2019exploiter ce m\u00e9canisme au niveau des syst\u00e8mes multi-agents. Nous nous focalisons plus particuli\u00e8rement sur le mod\u00e8le Aalaadin que nous proposons d\u2019\u00e9tendre afin d\u2019unifier son concept de groupe avec celui d\u2019aspect. Ceci permet de r\u00e9utiliser un groupe dans diff\u00e9rentes architectures de syst\u00e8mes multi-agents. D\u2019autre part, cette extension explicite des propri\u00e9t\u00e9s d\u2019infrastructure (persistance, distribution,...) sous forme de groupes. Ainsi les agents peuvent raisonner sur ces derniers. Enfin cette unification permet de s\u00e9parer les\u00a0\u2026", "num_citations": "3\n", "authors": ["179"]}
{"title": "Is functional programming better for modularity?\n", "abstract": " In 1989 John Hughes published an influential position paper entitled Why Functional Programming Matters. The article extolls the virtues of lazy functional programming by developing several examples: the Newton-Rhapson squares root method, numerical differentiation and integration, and an alpha-beta minimax search. A main conclusion of that work is that higher-order functions and lazy evaluation significantly contribute to modularity. We have found that recent articles from 2010 to 2014 cite Hughes' work as seminal work supporting that functional programming is, in general, good for modularity. We believe this reflects an unstated hypothesis in part of the research community: functional programming is inherently better at modularity than other paradigms such as typical procedural and object-oriented programming. To the best of our knowledge there are no (large-scale) empirical evaluations of this\u00a0\u2026", "num_citations": "2\n", "authors": ["179"]}
{"title": "DIE: A Domain Specific Aspect Language for IDE Events.\n", "abstract": " Integrated development environments (IDEs) have become the primary way to develop software. Besides just using the built-in features, it becomes more and more important to be able to extend the IDE with new features and extensions. Plugin architectures exist, but they show weaknesses related to unanticipated extensions and event handling. In this paper, we argue that a more general solution for extending IDEs is needed. We present and discuss a solution, motivated by a set of concrete examples: a domain specific aspect language for IDE events. In it, join points are events of interest that may trigger the advice in which the behavior of the IDE extension is called. We show how this allows for the development of IDE plugins and demonstrate the advantages over traditional publish/subscribe systems.", "num_citations": "2\n", "authors": ["179"]}
{"title": "Lumi\u00e8re: An Infrastructure for Producing 3D Applications in Smalltalk.\n", "abstract": " With the goal of developing 3D applications using Smalltalk, we decided to build a lightweight 3D framework named Lumiere from scratch, because after conducting a brief survey of the available frameworks, we found many of them to be either outdated, abandoned, undocumented or too heavyweight. In this paper we present the design and implementation of Lumiere, an object-oriented framework based on a stage metaphor to display interactive 3D micro-worlds.", "num_citations": "2\n", "authors": ["179"]}
{"title": "The\" Extract Refactoring\" Refactoring.\n", "abstract": " There is a gap between refactoring tools and generalpurpose program transformation tools that has yet to be filled. Refactoring tools are easy to use and wellestablished, but provide only a limited number of options. On the other hand, program transformation tools are powerful but are viable only for large transformation tasks. We propose an approach in which a developer specifies transformations to a program by example, using an IDE plugin recording the programmer\u2019s actions as changes. These changes could be generalized to specify a more abstract transformation, without the need of a dedicated syntax. Defining refactorings and transformations from concrete cases would enable more frequent uses of medium scale transformations.", "num_citations": "2\n", "authors": ["179"]}
{"title": "Open-vocabulary models for source code\n", "abstract": " Statistical language modeling techniques have successfully been applied to large source code corpora, yielding a variety of new software development tools, such as tools for code suggestion, improving readability, and API migration. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. Both large vocabularies and out-of-vocabulary issues severely affect Neural Language Models (NLMs) of source code, degrading their performance and rendering them unable to scale.", "num_citations": "1\n", "authors": ["179"]}