{"title": "Software maintenance and evolution: a roadmap\n", "abstract": " AIMS AND OBJECTIVESSoftware maintenance and evolution are characterised by their huge cost and slow speed of implementation. Yet they are inevitable activities-almost all software that is useful and successful stimulates user-generated requests for change and improvements. Our aim is to describe a landscape for research in software maintenance and evolution over the next ten years, in order to improve the speed and accuracy of change while reducing costs, by identifying key problems, promising solution strategies and topics of importance. The aims are met, by taking two approaches. Firstly current trends and practices are projected forward using a new model of software evolution called the staged model. Both strategic problems and research to solve particular tactical problems are described within this framework. Secondly, a longer term, and much more radical vision of software evolution is presented\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1027\n", "authors": ["61"]}
{"title": "A staged model for the software life cycle\n", "abstract": " Software engineers have traditionally considered any work after initial delivery as simply software maintenance. Some researchers have divided this work into various tasks, including making changes to functionality (perfective), changing the environment (adaptive), correcting errors (corrective), and making improvements to avoid future problems (preventive). However, many have considered maintenance basically uniform over time. Because software development has changed considerably since its early days, the authors believe this approach no longer suffices. They describe a new view of the software life cycle in which maintenance is actually a series of distinct stages, each with different activities, tools, and business consequences. While the industry still considers postdelivery work as simply software maintenance, the authors claim that the process actually falls into stages. They think both business and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "376\n", "authors": ["61"]}
{"title": "Case study of feature location using dependence graph\n", "abstract": " Software change requests are often formulated as requests to modify or to add a specific feature or concept. To implement these changes, the features or concepts must be located in the code. We describe the scenarios of the feature and concept location. The scenarios utilize a computer-assisted search of software dependence graph. Scenarios are demonstrated by a case study of NCSA Mosaic source code.", "num_citations": "357\n", "authors": ["61"]}
{"title": "The role of concepts in program comprehension\n", "abstract": " The paper presents an overview of the role of concepts in program comprehension. It discusses concept location, in which the implementation of a specific concept is located in the code. This process is very common and precedes a large proportion of code changes. The paper also discusses the process of learning about the domain from the code, which is a prerequisite of code reengineering. The paper notes the similarities and overlaps between program comprehension and human learning.", "num_citations": "317\n", "authors": ["61"]}
{"title": "Changing the paradigm of software engineering\n", "abstract": " Software evolution, iterative, and agile development represent a fundamental departure from the previous waterfall-based paradigm of software engineering.", "num_citations": "193\n", "authors": ["61"]}
{"title": "Incremental change in object-oriented programming\n", "abstract": " Incremental change adds new functionality and new properties to software. We concentrate on IC in the context of object-oriented Java programs and study selected IC activities. Because change requests are formulated in terms of program concepts - chunks of knowledge about the program and application domain - the resulting IC activities also focus on program concepts. Moreover, most change requests originate from the end user, so the end user's view of the program is the source of most concepts that govern IC. Additional concepts might originate from other programmers and deal with the program architecture or algorithms. Program dependencies also play a crucial role in IC; if a program component changes, other dependent components might also have to change. This is true even for well-designed object-oriented programs, as our example demonstrates.", "num_citations": "152\n", "authors": ["61"]}
{"title": "A model for change propagation based on graph rewriting\n", "abstract": " This paper presents a model of change propagation during software maintenance and evolution. Change propagation is modeled as a sequence of snapshots, where each snapshot represents one particular moment in the process, with some software dependencies being consistent and others being inconsistent. A snapshot is changed into the next one by a change in one software entity and the dependencies related to it. The formalism for this process is based on graph rewriting. The paper discusses two basic processes of change propagation: change-and-fix, and top-down propagation. It also describes a prototype tool \u0393\u00c7\u00a3Ripples 2\u0393\u00c7\u00a5 which supports both processes, and an example of the use of the tool", "num_citations": "148\n", "authors": ["61"]}
{"title": "JRipples: A tool for program comprehension during incremental change\n", "abstract": " Incremental software change adds new functionality to software. It is the foundation of software evolution, maintenance, iterative development, agile development, and other software processes. Highly interactive tool JRipples provides the programmer with the organizational support that makes the incremental change process easier and more systematic. JRipples supports impact analysis and change propagation, the two most difficult activities of the incremental change.", "num_citations": "133\n", "authors": ["61"]}
{"title": "A comparison of methods for locating features in legacy software\n", "abstract": " Software engineers frequently need to locate the code that implements a specific feature of a program in order to fix a problem or add an enhancement. Several methods have recently been proposed to aid in feature location, notably the software reconnaissance method, which uses dynamic analysis of traces of execution, and the dependency graph method which involves static tracing of calling and data flow relationships in the program\u0393\u00c7\u00d6s dependency graph. Most studies performed so far on these methods have used relatively modern C code. However there is a large body of existing legacy software in Fortran and similar languages which is often much more poorly structured. This paper describes a case study to locate two features in a sample of poorly structured legacy Fortran code. Both methods were applied to locate the features, along with the well known \u0393\u00c7\u00a3grep\u0393\u00c7\u00a5 text search method for comparison. Both the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "110\n", "authors": ["61"]}
{"title": "Variable granularity for improving precision of impact analysis\n", "abstract": " Impact analysis is a specialized process of program comprehension that investigates the nature and extent of a planned software change. Traditionally, impact analysis involves inspecting dependencies among the software components of a fixed granularity; these components constitute a dependency graph. In this paper, we argue that a single granularity is insufficient and leads to imprecise analysis. We explain how the precision can be improved by variable granularity, where the programmers choose among the granularity of classes, the granularity of class members, and the granularity of code fragments. We assess the resulting precision in a case study on open-source software.", "num_citations": "108\n", "authors": ["61"]}
{"title": "Hidden dependencies in program comprehension and change propagation\n", "abstract": " Large software systems are difficult to understand and maintain. Program dependency analysis plays a key role in both understanding and maintenance. This paper discusses hidden dependencies among software components that make both understanding and maintenance hard. A hidden dependency is a relationship between two seemingly independent components, and it is caused by the data flow in a third software component. The paper uses abstract system dependency graphs to define hidden dependencies. It discusses the impact of hidden dependencies on the process of change propagation and also discusses an algorithm that warns about the possible presence of hidden dependencies.", "num_citations": "103\n", "authors": ["61"]}
{"title": "Software evolution and maintenance\n", "abstract": " Successful software requires constant change that is triggered by evolving requirements, technologies, and stakeholder knowledge. This constant change constitutes software evolution. Software evolution has gained steadily in importance and recently moved into the center of attention of software developers. There is the new prominence of evolutionary software development that includes agile, iterative, open source, inner source, and other processes. As a consequence, the bulk of software development now happens in the stage of software evolution and this changed the face of software engineering. This paper discusses evolutionary software development and also discusses the software change, which is the fundamental software evolution task. It further discusses research methodologies, teaching software evolution in undergraduate curriculum, and difference between software evolution and software\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "99\n", "authors": ["61"]}
{"title": "RIPPLES: tool for change in legacy software\n", "abstract": " Key parts of software change are concept location and change propagation. We introduce a tool called RIPPLES that supports both. It uses the Abstract System Dependence Graph (ASDG) of the program, enriched by conceptual dependencies. A case study of NCSA Mosaic demonstrates the use of the tool. Precision and recall are used to evaluate the quality of support provided by RIPPLES.", "num_citations": "86\n", "authors": ["61"]}
{"title": "Removing clones from the code\n", "abstract": " This paper reports on a process for eliminating function clones and class clones from industrial object\u0393\u00c7\u00c9oriented code. Clone removal can decrease system code size and facilitate maintenance. We eliminate clones by re\u0393\u00c7\u00c9engineering scenarios that are based on using automated restructuring tools. The clone elimination process described includes function insertion, function expulsion, function encapsulation, function and variable renaming, and argument reordering. The paper presents examples of clones, re\u0393\u00c7\u00c9engineering scenarios and restructuring tools. The usefulness of the approach is demonstrated by experience from a case study. Copyright \u252c\u2310 1999 John Wiley & Sons, Ltd.", "num_citations": "85\n", "authors": ["61"]}
{"title": "Evolution and reuse of orthogonal architecture\n", "abstract": " We present a case study of evolution (or vertical reuse) in the domain of visual interactive software tools. We introduce an architecture suitable for this purpose, called orthogonal architecture. The paper describes the architecture itself, the reverse engineering process by which it was obtained, and the forward engineering process by which it was evolved.", "num_citations": "82\n", "authors": ["61"]}
{"title": "Partial domain comprehension in software evolution and maintenance\n", "abstract": " Partial comprehension is a necessity in the evolution and maintenance of very large software systems. The programmers form not only partial comprehension of the code, but also partial comprehension of the application domain. To describe the comprehension process, we introduce ontology fragments and investigate how programmers form, use and extend them before and during concept location; concept location is a prerequisite of code changes. We conducted case studies of concept location in two large systems, Eclipse and Mozilla, that both have more than 50,000 methods. Using grep search and ontology fragments, the programmers were able to locate the concepts after inspecting on average less than 10 methods and operating with ontology fragments of around 14 concepts, a very small fraction of the total.", "num_citations": "81\n", "authors": ["61"]}
{"title": "Software engineering: The current practice\n", "abstract": " Preface is book introduces the fundamental notions of contemporary software engineering. From the large body of knowledge and experience that software engineering has accumulated, it selects a very small subset. e purpose is to introduce the software engineering field to students who want to learn basic software engineering skills and to help practitioners who want to refresh their knowledge and learn about the recent developments in the field. e field of software engineering has accumulated a great deal of knowledge since the first appearance of software in the 1950s. ere have also been two revolutions in the field, each substantially changing the views and the emphasis within the field. In the 1970s, the first revolution established software engineering as an academic discipline, and in the 2000s, the second revolution identified the broadly understood software evolution as the central software engineering\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "78\n", "authors": ["61"]}
{"title": "Modeling software evolution by evolving interoperation graphs\n", "abstract": " Software evolution is the process of software change, most often change in software requirements. This paper presents a theoretical model for the evolution of component\u0393\u00c7\u00c9based software, based on evolving interoperation graphs. The model assumes that each change consists of smaller granularity steps of change propagation, each of them being a visit to one specific component. If the component is modified, it may no longer fit with the other components because it may no longer properly interact with them. In that case secondary changes must be made in neighboring components, which may trigger additional changes, etc. The paper contains an example of evolution of a calendar program, represented in UML.", "num_citations": "74\n", "authors": ["61"]}
{"title": "VIFOR: A tool for software maintenance\n", "abstract": " VIFOR is a software tool oriented towards maintenance of medium\u0393\u00c7\u00c9to\u0393\u00c7\u00c9large Fortran77 programs. With VIFOR, programs can be displayed and edited in two forms: as the code and as the graph. VIFOR also contains transformations in both directions, i.e. from code to graph and from graph to skeletons of code. Hence, it is suitable for re\u0393\u00c7\u00c9engineering and maintenance of existing code. Specially designed browsers implement the graphical interface. VIFOR contains a database that is based on a simple but effective data model of Fortran programs. The model contains only four entity classes and three relations, which makes the tool small, and easy to implement and use. A simple query language allows browsing through the database.", "num_citations": "72\n", "authors": ["61"]}
{"title": "Cognitive process during program debugging\n", "abstract": " Program debugging is a critical and complex activity in software engineering. Accurate and fast debugging leads to high quality software and a short time-to-market. Debugging involves a very demanding cognitive process. In a case study, we found all six levels of Bloom's taxonomy of cognitive learning, from \"knowledge\" through \"comprehension\", \"application\", \"analysis\", \"synthesis\", and \"evaluation\". The involvement of the higher levels of Bloom's taxonomy, such as synthesis and evaluation, indicates that program debugging is a difficult cognitive task. This fact may explain the difference between novices and experts in debugging effectiveness.", "num_citations": "68\n", "authors": ["61"]}
{"title": "Reengineering object-oriented code\n", "abstract": " In this paper, we describe the reengineering of a deteriorated object-oriented industrial program written in C++. The main problem of the program was misplaced code, most often functions that were members of the wrong class. In order to deal with this problem, we designed and implemented several restructuring tools and used them in specific reengineering scenarios. We also discuss how this set of tools could be enhanced in the future, and the importance of restructuring for object-oriented software maintenance.", "num_citations": "67\n", "authors": ["61"]}
{"title": "Empirical validation of test-driven pair programming in game development\n", "abstract": " This paper investigates the effects of some extreme programming practices in game development by conducting a case study with 12 students who were assigned to implement a simple game application either as pairs or as individuals. The pairs used some XP practices, such as pair programming, test-driven and refactoring, while the individuals applied the traditional waterfall-like approach. The results of the case study showed that paired students completed their tasks faster and with higher quality than individuals. The programs written by pairs pass more test cases than those developed by individuals. Paired programmers also wrote cleaner code with higher cohesion by creating more reasonable number of methods. Therefore, some XP practices, such as pair programming, test-driven and refactoring could be used in game development", "num_citations": "57\n", "authors": ["61"]}
{"title": "Static execute after/before as a replacement of traditional software dependencies\n", "abstract": " The paper explores Static Execute After (SEA) dependencies in the program and their dual Static Execute Before (SEB) dependencies. It empirically compares the SEA/SEB dependencies with the traditional dependencies that are computed by System Dependence Graph (SDG) and program slicers. In our case study we use about 30 subject programs that were previously used by other authors in empirical studies of program analysis. We report two main results. The computation of SEA/SEB is much less expensive and much more scalable than the computation of the SDG. At the same time, the precision declines only very slightly, by some 4% on average. In other words, the precision is comparable to that of the leading traditional algorithms, while intuitively a much larger difference would be expected. The paper then discusses whether based on these results the computation of the SDG should be replaced in\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "55\n", "authors": ["61"]}
{"title": "Layered explanations of software: A methodology for program comprehension\n", "abstract": " In dealing with the legacy systems, one often encounters poorly documented and heavily maintained software. Lack of understandability of these systems complicates the task of software maintenance, making it time consuming and limiting the possibilities of the evolution of the system. We present a methodology that helps the programmers to understand programs. Our approach is compatible with the \"top-down theory\" of software understanding, where the programmer creates a chain of hypotheses and subsidiary hypotheses, concerning the properties of the code. Then he/she looks for evidence (beacons) in the code. Our approach shortens the process of hypotheses creation and verification, and allows recording of successful hypotheses for the future maintenance. All information needed for understanding is recorded in layers of annotations. An experiment was conducted to investigate how the proposed\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "47\n", "authors": ["61"]}
{"title": "Absolutely parallel grammars and two-way finite-state transducers\n", "abstract": " Absolutely parallel grammars are defined, and it, is shown that the family of languages generated is equal to the family of languages generated by two-way deterministic finite-state transducers (abbreviated 2ft). Furthermore it is shown that this family forms a full AFL closed under substitution. It is shown that the family of languages generated by two-way nondeterministic finite-state transducers is equal to the family of checking automata languages and that it properly contains the family of languages generated by 2ft.", "num_citations": "47\n", "authors": ["61"]}
{"title": "A case study of feature location in unstructured legacy fortran code\n", "abstract": " Feature location is a major problem in supporting legacy code. Two methods, the Software Reconnaissance technique and the Dependency Graph search method, have been proposed to help software engineers locate features in a program that needs to be modified. Both methods have been developed and evaluated largely using relatively modern C code. The article describes preliminary experiences in adapting them to legacy Fortran code, typical of systems developed in the 1970s. A case study was performed to apply the two methods to the CONVERT3 program, which is part of the FASTGEN geometric modeling suite. CONVERT3 exhibits many characteristics typical of legacy Fortran programs such as poor modularity, prolific use of unstructured GOTOs, tight coupling through large common blocks, and confusing program plans introduced to provide efficiency on now-obsolete platforms. Both methods were\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "43\n", "authors": ["61"]}
{"title": "Teaching developer skills in the first software engineering course\n", "abstract": " Both employers and graduate schools expect computer science graduates to be able to work as developers on software projects. Software engineering courses present the opportunity in the curriculum to learn the relevant skills. This paper presents our experience from Wayne State University and reviews challenges and constraints that we faced while trying to teach these skills. In our first software engineering course, we teach the iterative software development that includes practices of software change, summarized in the phased model of software change. The required resources for our software engineering course are comparable to the other computer science courses. The students - while working in teams - are graded based on their individual contribution to the team effort rather than on the work of the other team members, which improves the fairness of the grading and considerably lessens the stress for the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "38\n", "authors": ["61"]}
{"title": "Dialog-based protocol: an empirical research method for cognitive activities in software engineering\n", "abstract": " This paper proposes dialog-based protocol for the study of the cognitive activities during software development and evolution. The dialog-based protocol, derived from the idea of pair programming, is a significant alternative to the common think-aloud protocol, because it lessens the Hawthorne and placebo effects. Using screen-capturing and voice recording instead of videotaping further reduces the Hawthorne effect. The self-directed learning theory provides an encoding scheme and can be used in analyzing the data. A case study illustrates this new approach.", "num_citations": "37\n", "authors": ["61"]}
{"title": "Software cultures and evolution\n", "abstract": " To work effectively with legacy code, software engineers need to understand a legacy computer program's culture - the combination of the programmer's background, the hardware environment and the programming techniques that guided its creation. Software systems typically pass through a series of stages. During the initial development stage, software developers create a first functioning version of the code. An evolution stage follows, during which developmental efforts focus on extending system capabilities to meet user needs. During the servicing stage, only minor repairs and simple functional changes are possible. In the phase-out stage, the system is essentially frozen, but it still produces value. Finally, during the close-down stage, the developers withdraw the system and possibly replace it. Most of the tasks in the evolution and servicing phases require program comprehension /sup n/derstanding how and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "37\n", "authors": ["61"]}
{"title": "A case study of unanticipated incremental change\n", "abstract": " Incremental changes add new functionality and properties to software. They are the core of software evolution, maintenance, iterative development, agile development, and similar software processes. This paper presents a technique for unanticipated incremental software change and a case study. The technique uses programming concepts as the foundation, and contains steps of concept location, actualization, incorporation, and change propagation. The case study presents an unanticipated change in the open source software \"Drawlets\".", "num_citations": "35\n", "authors": ["61"]}
{"title": "Intensions are a key to program comprehension\n", "abstract": " The classical comprehension theories study relations between extensions, intensions, and names. Originally developed in linguistics and mathematics, these theories are applicable to program comprehension as well. While extensions are present in the program, the intensions are usually missing, and evolution and maintenance programmers have to recover them as the program cannot be successfully comprehended and changed without them.", "num_citations": "34\n", "authors": ["61"]}
{"title": "Incremental redocumentation using the web\n", "abstract": " Too often, a company takes over someone else's software only to find that documentation is sadly lacking. This report shows how one small software company used the Web-based Partitioned Annotations to cost-effectively evolve a software application it had inherited.", "num_citations": "34\n", "authors": ["61"]}
{"title": "Software evolution and the staged model of the software lifecycle\n", "abstract": " Software maintenance is concerned with modifying software once it has been delivered and has entered user service. Many studies have shown that maintenance is the dominant lifecycle activity for most practical systems; thus maintenance is of enormous industrial and commercial importance. Over the past 25\u252c\u00e1years or so, a conventional view of software development and maintenance has been accepted in which software is produced, delivered to the user, and then enters a maintenance stage. A review of this approach and the state of the art in research and practice is given at the start of the chapter.In most lifecycle models, software maintenance is lumped together as one phase at the end. In the experience of the authors, based on how maintenance is really undertaken (rather than how it might or should be done), software maintenance actually consists of a number of stages, some of which can start during\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "32\n", "authors": ["61"]}
{"title": "Concept location using program dependencies and information retrieval (depir)\n", "abstract": " ContextThe functionality of a software system is most often expressed in terms of concepts from its problem or solution domains. The process of finding where these concepts are implemented in the source code is known as concept location and it is a prerequisite of software change.ObjectiveWe investigate a static approach to concept location named DepIR that combines program dependency search (DepS) with information retrieval-based search (IR). In this approach, programmers explore the static program dependencies of the source code components retrieved by the IR search engine.MethodThe paper presents an empirical study that compares DepIR with its constituent techniques. The evaluation is based on an empirical method of reenactment that emulates the steps of concept location for 50 past changes mined from software repositories of five software systems.ResultsThe results of the study indicate that\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "31\n", "authors": ["61"]}
{"title": "Restructuring legacy C code into C++\n", "abstract": " In this paper, we describe restructuring of C code into new C++ classes. Such restructuring is done to facilitate both software reuse and software evolution. The restructuring is accomplished by restructuring tools and scenarios. We discuss the transformation tool-set and the design of the individual tools. The approach is demonstrated on a case study We also discuss how this tool-set could be enhanced in the future.", "num_citations": "30\n", "authors": ["61"]}
{"title": "Paradigms for design and implementation in Ada\n", "abstract": " An examination of the respective advantages and disadvantages of three characteristic paradigms of design and implementation in Ada illustrates the importance of choosing the appropriate paradigm for a given set of circumstances.", "num_citations": "30\n", "authors": ["61"]}
{"title": "Extended firewall for regression testing: an experience report\n", "abstract": " Testing firewalls have proven to be a useful approach for regression testing in both functional and object\u0393\u00c7\u00c9oriented software. They involve only the modules that are closely related to the changed modules. They lead to substantially reduced regression tests but still are very effective in detecting regression faults. This paper investigates situations when data\u0393\u00c7\u00c9flow paths are longer, and the testing of modules and components only one level away from the changed elements may not detect certain regression faults; an extended firewall considers these longer data paths. We report empirical studies that show the degree to which an extended firewall detected more faults, and how much more testing was required to achieve this increased detection. Copyright \u252c\u2310 2008 John Wiley & Sons, Ltd.", "num_citations": "29\n", "authors": ["61"]}
{"title": "Towards standard for experiments in program comprehension\n", "abstract": " Program comprehension can make a unique contribution to the field of software engineering because it is feasible to validate its claims with inexpensive experiments. To fully realize this unique position, program comprehension researchers need to develop standards that will guide them in designing experiments and allow them to judge the strength of an experiment in supporting a claim. To begin the discussion leading to such standards, we propose that program comprehension experiments always measure and interpret the following dependent variables: accuracy, accurate response time, and inaccurate response time.", "num_citations": "27\n", "authors": ["61"]}
{"title": "Tracker-a tool for change propagation in java\n", "abstract": " During software evolution, programmers add new functionalities and release new versions of software. This is complicated work, particularly in large applications, and tools are needed to deal with it. In this paper we introduce a tool named JTracker that helps programmers implement change propagation in Java applications. We conducted a case study of a change in open source application JMeter, in which we used JTracker.", "num_citations": "25\n", "authors": ["61"]}
{"title": "The role of incremental change in agile software processes\n", "abstract": " This paper presents a model of incremental change that consists of concept location, impact analysis, actualization, change propagation, supporting refactorings, and testing. Repeated incremental change is the foundation of an agile process called Concept- based Incremental Development (CID). A case study of a Point of Sale system illustrates the usefulness of CID. The paper argues that CID complements those agile processes that concentrate on team and management issues, and therefore can be combined with them.", "num_citations": "23\n", "authors": ["61"]}
{"title": "Hidden dependencies in software systems\n", "abstract": " In this paper, we study the hidden dependencies that are a special kind of data flows. They play an important role in software maintenance and evolution because they propagate changes among the classes and they are hard to detect. We propose a technique that finds hidden dependencies through the computation of an \u0393\u00c7\u00a3execute completely after\u0393\u00c7\u00a5 relation that is filtered using dynamically generated preconditions and postconditions. We show that these hidden dependencies exist even in well-structured software, like the open source programs JUnit, Drawlets, and Apache FtpServer. We also discuss the precision of this technique.", "num_citations": "22\n", "authors": ["61"]}
{"title": "A methodology for incremental changes\n", "abstract": " Software evolution is a phase in the software life cycle in which major changes are made. It is based on iterative enhancements of the software [Rajlich+ 2000], called \u0393\u00c7\u00a3small releases\u0393\u00c7\u00a5 in [Beck2000]. Each small release adds new functionality previously not available, and results in a working program. The strategy of small releases is to provide valuable feedback to programmers, managers, and customers and give them the opportunity to adjust future direction, goals, schedule, and budget [Beck2000]. Software methodologies have been used for a long time in initial development, which starts from scratch and ends with the first working version of software. There are a great variety of methodologies for initial development, supporting diverse software engineering processes and resulting in diverse software architectures.", "num_citations": "21\n", "authors": ["61"]}
{"title": "Using the web for software annotations\n", "abstract": " The purpose of software redocumention is to recover comprehension of software and to record it for future use. This paper describes Partitioned Annotations of Software (PAS), where comprehension is recorded in hypertext and browsed by web browsers. The annotations for each code component are partitioned in order to keep different explanations separate, leverage the advantages of hypertext, and better support the processes of program comprehension. The paper describes a tool that parses code and generates PAS skeletons. The paper also describes a process of incremental redocumentation where comprehension of software is recorded incrementally during normal maintenance. The experience with PAS in an industrial project is summarized.", "num_citations": "21\n", "authors": ["61"]}
{"title": "Case study of feature location using dependence graph, after 10 years\n", "abstract": " This retrospective briefly recapitulates the original paper that was published at IWPC 2000, overviews selected papers that were published in its wake, presents recent clarifications and updates of the topic, and mentions the still unfinished agenda and future work.", "num_citations": "20\n", "authors": ["61"]}
{"title": "Pair programming in graduate software engineering course projects\n", "abstract": " Pair programming has been used in undergraduate classes in order to develop student skills and to enhance student learning. Experiments with such an approach have demonstrated positive effects. This paper investigates the effects of pair programming in the graduate software engineering class by conducting a case study with six students who were assigned to work on incremental changes on an open source application either as pairs or as individuals. The results of the case study showed that paired students completed their change request tasks faster and with higher quality than individuals. They also wrote less lines of code and used more meaningful variable names. Pair programming could be an effective and useful approach for graduate software engineering classes", "num_citations": "19\n", "authors": ["61"]}
{"title": "Incremental redocumentation with hypertext\n", "abstract": " Redocumentation is the recovery and recording of software comprehension. Since software comprehension is the most expensive part of software maintenance, redocumentation is the key to software maintainability. The paper describes the process and the tools of incremental redocumentation where the comprehension of the software is recorded in hypertext, in the style of the World Wide Web. The paper describes the tools which support redocumentation, and gives several examples.", "num_citations": "19\n", "authors": ["61"]}
{"title": "MSE: A methodology for software evolution\n", "abstract": " Every program must continuously evolve, or it will become obsolete. This paper explores a methodology for software evolution within the setting of object\u0393\u00c7\u00c9orientated programming. The methodology is based on the top\u0393\u00c7\u00f4down propagation of change, and it is remotely related to stepwise refinement. To present the methodology, this paper uses one small example (Gregorian calendar) and one medium\u0393\u00c7\u00c9sized example (calendar maintainer). This paper also explores an algorithm for scheduling object classes for update, and introduces a tool, \u0393\u00c7\u00ffRipples\u0393\u00c7\u00d6, which helps programmers work with the process of software evolution. \u252c\u2310\u0393\u00c7\u00eb1997 by John Wiley & Sons, Ltd. J. Software Maintenance 9: 103\u0393\u00c7\u00f4124, 1997.", "num_citations": "19\n", "authors": ["61"]}
{"title": "VIFOR 2: a tool for browsing and documentation.\n", "abstract": " During the maintenance of legacy systems, the structure and the documentation of the system usually deteriorates, and hence the maintenance becomes progressively harder and harder. In order to reverse this deterioration, it is essential to record the understanding of the system continually, before it is forgotten. It is also important to structure it in such a way that it can be easily accumulated and retrieved. The authors present a tool called VIFOR 2, which is oriented rewards this situation. The tool combines two technologies: browsing and hypertext documentation. The browser supports rapid navigation around the code. The layered hypertext supports the incremental recording and retrieval of the documentation on the desired level of abstraction (domain, algorithm, representation, etc.). They briefly discuss their own experience with the tool.", "num_citations": "18\n", "authors": ["61"]}
{"title": "Visual support for programming-in-the-large.\n", "abstract": " In this paper, a brief description of the VIFOR (Visual Interactive FORtran) environment is given. VIFOR is based on a simple, but effective data model of Fortran programs. The model contains three entity classes and three relation classes only. Programs can be displayed and edited in two forms: the traditional one (ie code) and in the visual form. VIFOR contains transformation tools for both directions, ie from code to visual form and from visual form to skeletons of code. Hence, it is suitable for reverse engineering and maintenance of existing code. Specially designed browsers implement the graphical interface.", "num_citations": "17\n", "authors": ["61"]}
{"title": "Dynamics of discrete systems and pattern reproduction\n", "abstract": " A notation for dynamics of discrete systems is presented. The notation is based on an idea of static objects and relations between them which from time to time undergo sudden changes. The objects together with relations and changes are described mathematically by relational structures and productions similar to productions of graph grammars, respectively. Pattern reproduction is defined and explored and several examples are given.", "num_citations": "17\n", "authors": ["61"]}
{"title": "Analogy of incremental program development and constructivist learning\n", "abstract": " During software evolution, programmers add new functionalities and release new versions of software. This complicated work involves not only program development but also learning new knowledge. This paper explores an analogy between incremental program development and constructivist learning, and presents a case study that investigates this analogy. Four types of cognitive processes have been identified. They parallel analogous software engineering activities.", "num_citations": "16\n", "authors": ["61"]}
{"title": "Software change and evolution\n", "abstract": " Changeability (also called evolvability) is an essential property of software. Software change is the foundation for both new software development and legacy software maintenance, therefore a better understanding of software change is an important software engineering issue. This paper covers selected topics related to software change, including minicycle of change, partitioned annotations, and change propagation, and gives a brief overview of the field.", "num_citations": "16\n", "authors": ["61"]}
{"title": "A model and a tool for change propagation in software\n", "abstract": " One of the proposed solutions is to anticipate changes and structure the software in such a way that the changes will be localized inside software components. However, more recent case studies reported that only about 70% of the requirements were predicted in advance and the remaining requirements were discovered during development. Massive changes triggered by company mergers, introduction of Euro, etc., could not be predicted even a few years ago. Therefore it is likely that all software will be exposed to many unanticipated changes during its lifetime, and the support for unanticipated changes is an important research goal.", "num_citations": "15\n", "authors": ["61"]}
{"title": "Refinement methodology for Ada\n", "abstract": " This paper presents Refinement Methodology (RM) for the design of Ada\u252c\u00ab programs. The methodology combines stepwise refinement and the information hiding principle. The steps of the methodology are explained and illustrated by an example. A part of the methodology is a collection of rules by which procedures acquire parameters (called first and second rules for parameters).", "num_citations": "15\n", "authors": ["61"]}
{"title": "Software change in the solo iterative process: An experience report\n", "abstract": " This paper reports an experience of a solo programmer who added a new feature into an open source program called muCommander. The process is observed on two granularities: Granularity of software change (SC) and granularity of Solo Iterative Process (SIP). The experience confirms that both SC and SIP process models can be successfully enacted, are able to implement the described feature, and produced a high quality code in reasonable time. The lessons learned, particularly the exit criteria for SC phases, are discussed in more detail in the paper and may be applicable to team iterative processes, including agile processes.", "num_citations": "14\n", "authors": ["61"]}
{"title": "Comprehension and evolution of legacy software (tutorial)\n", "abstract": " This tutorial presents an overview of legacy systems comprehension and evolution. Software comprehension typically consumes more than one-half of the programming effort with the legacy systems. Software evolution is a change in requirements and it is the most common type of change in legacy systems.", "num_citations": "14\n", "authors": ["61"]}
{"title": "Identifications of concepts, features, and concerns in source code\n", "abstract": " Software development process transforms requirements into source code. These requirements are formulated as concepts from the problem domain or the solution domain; among them, features are the concepts that describe user selectable behavior. During software evolution, existing concepts and features of the system are changed, deleted, or new ones are added. In order to solve any of these change tasks, the existing concepts need to be precisely identified in the source code. This identification process was initially defined as the concept assignment (location) problem [2]. It is of no surprise that searching and browsing the software artifacts with the goal to identify parts of the source code that implement a concept from the software domain is one of the most common activities during software evolution. The existing methods of concept and feature location fall into two broad categories, based on the information\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["61"]}
{"title": "Program comprehension as a learning process\n", "abstract": " The paper describes the process of program comprehension from the point of view of constructivist theory of learning. According to this view, program comprehension starts with existing knowledge and continues through processes of assimilation and adaptation. Assimilation means that the facts encountered in the program are either added to the knowledge or rejected. Adaptation means that the existing knowledge is reorganized in order to absorb new facts. These processes are illustrated by a case study where the knowledge of the program is represented by UML class diagrams.", "num_citations": "12\n", "authors": ["61"]}
{"title": "Role of concepts in software evolution\n", "abstract": " Software evolution is a phase in the software lifecycle where major changes in software are made. Incremental change adds new functionality to software and is one of the key principles of software evolution. This paper presents a methodology for incremental change and a case study of a small application written in Java. Domain concepts play a key role.", "num_citations": "12\n", "authors": ["61"]}
{"title": "Decomposition/generalization methodology for object-oriented programming\n", "abstract": " The object-oriented paradigm is often connected with bottom-up programming, which is characterized by steps of composition and specialization. The opposite of bottom up is the top-down paradigm, based on steps of decomposition and generalization. In most projects, a free exchange between top-down and bottom-up methods is the best mode of operation. This article presents a variant of the top-down paradigm called the decomposition/generalization methodology, which is based on stepwise refinement. Decomposition consists of selection, refinement, class membership for deferred functions, code update, and verification. Generalization consists of the establishment of inheritance relations and the sliding of member functions to the base class. Although the language used here is C + +, the same methodology can be easily adapted to object-oriented PASCAL, SMALLTALK, and other object-oriented languages.", "num_citations": "11\n", "authors": ["61"]}
{"title": "Layout heuristics for graphical representations of programs\n", "abstract": " A layout problem is formulated for two-column graphs, and a layout algorithm, referred to as an insertion algorithm, for the two-column graph problem is presented. In addition, two variants of the algorithm are presented: dynamic insertion and delta insertion algorithms. The layout algorithms are implemented and experiments performed in order to compared their performance to existing layout algorithms for hierarchical graphs (i.e., exchanging and averaging algorithms). The experimental results show that the insertion method produces significantly better layouts compared to the existing methods. The method has been implemented in two software tools for the development and maintenance of programs, VIC and VIFOR (Visual Interactive C and FORTRAN 77, respectively).< >", "num_citations": "11\n", "authors": ["61"]}
{"title": "Bounded-crossing transducers\n", "abstract": " In Rajlich (1972) and Ehrich and Yau (1971) it was shown that deterministic and nondeterministic finite-state transducers differ in their generative power. This led to a natural question: What particular property makes the two-way nondeterministic finite-state transducers more powerful than the deterministic ones?This paper shows that the substantial property in this respect is the ability of two-way nondeterministic finite-state transducers to cross from one input letter to another without any bound on the number of such crossings. On the other hand when we restrict the number of crossings from one input letter to another, even for a transducer which has the power of the nondeterministic Turing machine on the input, we cannot get a generative power greater than that of the deterministic two-way finite-state transducer (Theorem 2.1).", "num_citations": "11\n", "authors": ["61"]}
{"title": "Stepwise refinement revisited\n", "abstract": " In this paper, rigorous application of stepwise refinement is explored. The steps of definition, decomposition, and completion are described, where completion is a newly introduced step. This combination of steps extends the use of stepwise refinement to larger systems. The notions of range, active objects, and backlog interface are introduced. Verification of incomplete programs via interactive testing is described. The paradigm is demonstrated in an example. The relationship between the paradigm and the current programming languages is considered. It is argued that the WHILE-DO loop is a harmful construct from this point of view.", "num_citations": "10\n", "authors": ["61"]}
{"title": "Impact analysis based on a global hierarchical object graph\n", "abstract": " During impact analysis on object-oriented code, statically extracting dependencies is often complicated by subclassing, programming to interfaces, aliasing, and collections, among others. When a tool recommends a large number of types or does not rank its recommendations, it may lead developers to explore more irrelevant code. We propose to mine and rank dependencies based on a global, hierarchical points-to graph that is extracted using abstract interpretation. A previous whole-program static analysis interprets a program enriched with annotations that express hierarchy, and over-approximates all the objects that may be created at runtime and how they may communicate. In this paper, an analysis mines the hierarchy and the edges in the graph to extract and rank dependencies such as the most important classes related to a class, or the most important classes behind an interface. An evaluation using two\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["61"]}
{"title": "A survey of algorithms for register allocation in straight-line programs\n", "abstract": " A survey of algorithms for register allocation in straight-line programs Deep Blue Home Login Home / Research Collections / Engineering, College of - Technical Reports / View Item A survey of algorithms for register allocation in straight-line programs Rajlich, V\u251c\u00edclav; Moshier, M. Drew. 1984 Handle: http://hdl.handle.net/2027.42/7208 Other Identifiers: UMR3298 Subject(s): Algorithms., Computer architecture., Computer programming. Type(s): Technical Report Show full item record TXT file View/Open Name: bad1289.0001. ... Size: 28.8KB Format: Text file PDF file View/Open Name: bad1289.0001. ... Size: 1MB Format: PDF This item appears in the following Collection(s) Engineering, College of - Technical Reports Search Deep Blue Browse by Communities & Collections Titles Authors Subjects Date My Account Login Information About Deep Blue Help Contact Us Coming Soon About Deep Blue Data MLibrary logo \u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["61"]}
{"title": "Theory of data structures by relational and graph grammars\n", "abstract": " In the paper, a definition for relational and graph grammars is given. Data structures and expressions are defined as a special kind of relational structure and tree, respectively. Examples illustrate the unifying power of the definitions. Four data manipulating commands are defined : assignment, conditional command, node creation, and edge creation. A method for proof of data structure algorithms is given; the method is based on Floyd's method.", "num_citations": "9\n", "authors": ["61"]}
{"title": "Absolutely parallel grammars and two-way deterministic finite-state transducers\n", "abstract": " Absolutely parallel grammars are defined and it is shown that the family of languages generated is equal to the family of languages generated by two-way deterministic finite-state transducers. Furthermore it is shown that this family forms a full AFL [4], is properly contained in the family of languages generated by two-way nondeterministic finite-state transducers (which is equal to the family of checking automata languages [8]) and properly contains the family of nonexpansive context-free languages [7].", "num_citations": "9\n", "authors": ["61"]}
{"title": "Software evolution: a road map\n", "abstract": " The aim of the panel session is to clarify issues involved in software evolution, but more particularly, to identify and explore promising solutions and research directions, in order to identify strategic goals for the research community and solution visions for practitioners. By evolution, we mean a stage of software lifecycle where the software undergoes substantial changes and this also includes iterative software development and/or agile software processes.", "num_citations": "8\n", "authors": ["61"]}
{"title": "Software evolution: a road map\n", "abstract": " Senior executives in public sector organisations have been charged with delivering an e-Government agenda. A key emerging area of research is that of the evaluation of e-Government, given that economic factors have traditionally dominated any traditional ICT evaluation process. In this paper the authors report the findings from two interpretive in-depth case studies in the UK public sector, which explore e-Government organisational evaluation within a public sector setting. This paper seeks to offer insights to organisational and managerial aspects surrounding the improvement of knowledge and understanding of e-Government evaluation. The findings that are elicited from the case studies are analysed and presented in terms of a framework derived from organisational analysis to improve e-Government evaluation, with key lessons learnt being extrapolated from practice. The paper concludes that e-Government\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["61"]}
{"title": "Software evolution: a road map\n", "abstract": " Senior executives in public sector organisations have been charged with delivering an e-Government agenda. A key emerging area of research is that of the evaluation of e-Government, given that economic factors have traditionally dominated any traditional ICT evaluation process. In this paper the authors report the findings from two interpretive in-depth case studies in the UK public sector, which explore e-Government organisational evaluation within a public sector setting. This paper seeks to offer insights to organisational and managerial aspects surrounding the improvement of knowledge and understanding of e-Government evaluation. The findings that are elicited from the case studies are analysed and presented in terms of a framework derived from organisational analysis to improve e-Government evaluation, with key lessons learnt being extrapolated from practice. The paper concludes that e-Government\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["61"]}
{"title": "Constructivist learning during software development\n", "abstract": " This article explores the non-monotonic nature of the programmer learning that takes place during incremental program development. It uses a constructivist learning model that consists of four fundamental cognitive activities: absorption that adds new facts to the knowledge, denial that rejects facts that do not fit in, reorganization that reorganizes the knowledge, and expulsion that rejects obsolete knowledge. A case study of an incremental program development illustrates the application of the model and demonstrates that it can explain the learning process with episodes of both increase and decrease in the knowledge. Implications for the documentation systems are discussed in the conclusions.", "num_citations": "7\n", "authors": ["61"]}
{"title": "Two object oriented decomposition methods\n", "abstract": " Among the program design methodologies, the two groups which got most attention recently are the object oriented methods [i], and functional decomposition methods [2, 8, 12, 15, 16]. However both of them have substantial limitations. The object-oriented methodologies of [i] give the designer only a very incomplete guidance, relying mostly on intuition and a vague set of principles. As the outcome, they are difficult to use, and usually are suitable for small programs only.The functional decomposition methods are much more mature, and some of them represent a substantial accumulation of knowledge. They are suitable for larger programs and are reasonably easy to use. However, they produce a wrong architecture of programs, which is not suitable for Ada and other modular languages.", "num_citations": "7\n", "authors": ["61"]}
{"title": "Perceptions of contribution in software teams\n", "abstract": " In this paper, we report results of a survey of graduate students who worked in teams on software projects. The survey revealed that there is a statistically significant gap between how team members perceived their own contribution towards the goals of the project, and how that contribution was perceived by their teammates. The paper discusses this gap and its implication for the functioning of the teams.", "num_citations": "6\n", "authors": ["61"]}
{"title": "A case study of evolution in object oriented and heterogeneous architectures\n", "abstract": " In order to properly understand a technology, it is important to know not only its strengths but also its limits. In this paper, we investigate the limits of object oriented technology. We present a case study in which we compare two different architectures for the same program \u0393\u00c7\u00f4 a student registration system which belongs to the domain of reactive repositories. We started our case study with a model produced by Object Modeling Technique (OMT), and used it for two different implementations: a homogeneous one (HOA) and a heterogeneous one (HTA). The HOA results in an object oriented system consisting of classes and their dependencies, while the HTA combines traditional imperative programming with a relational database. We evaluated the evolvability of both resulting programs by adding new use cases. HTA proved to be easier to evolve than HOA. In the paper, we discuss possible reasons for this finding.", "num_citations": "5\n", "authors": ["61"]}
{"title": "Relational definition of computer languages\n", "abstract": " The semantics of computer languages is defined in terms of relational systems, where\" snapshots\" are relational structures describing static relationships of data, values, and a program, and productions represent changes from a snapshot to the next one. The whole approach is demonstrated on an ALGOL 60 subset, and a program for greatest common divisor is proved.", "num_citations": "5\n", "authors": ["61"]}
{"title": "Reflective feature location: knowledge in mind meets information in system\n", "abstract": " Locating code entities relevant to a feature (i.e., feature location) is an important task in software maintenance. Feature location is challenging due to the information gap between the developer\u0393\u00c7\u00d6s knowledge about a feature and the feature\u0393\u00c7\u00d6s implementation in the system. In this paper, we present a reflective feature location approach ReFLex to bridge this gap. ReFLex automatically computes a reflexion model between the developer\u0393\u00c7\u00d6s logical view of a feature and the feature\u0393\u00c7\u00d6s implemented view reverse-engineered from the code. It provides interactive reflection support for the developer to refine the logical view and the feature location results such that the logical view and the implemented view converge gradually in an iterative feature location process. We have implemented our approach as an Eclipse plugin and investigated the benefits and challenges in reflective feature location through a user study.", "num_citations": "4\n", "authors": ["61"]}
{"title": "Case studies of constructivist comprehension in software engineering\n", "abstract": " Program comprehension is an essential part of software engineering. The paper describes the constructivist theory of comprehension, a process based on assimilation and accommodation of knowledge. Assimilation means that the new facts are either added to the existing knowledge or rejected. Accommodation means that the existing knowledge is reorganized in order to absorb new facts. These processes are illustrated by case studies of knowledge-level reengineering of a legacy program and of incremental change. In both cases, we constructed preliminary knowledge from the program documentation, and then adjusted it by comprehending the actual code. The case studies supported constructivism as a suitable theory of program comprehension.", "num_citations": "4\n", "authors": ["61"]}
{"title": "Propagation of Change in Object Oriented Programs\n", "abstract": " This position statement presents a prototype tool\" Ripples 2\" which supports two processes of propagation of ripple effect in Object Oriented systems: change-and-fix, and top-down propagation (MSE). The paper also contains an example of the use of the tool.", "num_citations": "4\n", "authors": ["61"]}
{"title": "Five recommendations for software evolvability\n", "abstract": " Evolvability of software lies in intersection of 3 factors: evolving system properties, human factors present in the developer team, and evolution demands. The paper presents 5 recommendations that enhance software evolvability: defined processes of software change, distinction between evolving and stabilized part of the code, analyzable code segments, significant concept encapsulation, and avoidance of wrapping.", "num_citations": "3\n", "authors": ["61"]}
{"title": "Using concept maps to assist program comprehension and concept location: an empirical study\n", "abstract": " Program comprehension is an integral part of the evolution and maintenance of large software systems. As it is increasingly difficult to comprehend these systems completely, programmers have to rely on a partial and as-needed comprehension. We study partial comprehension and programmer learning with the use of concept maps as a tool for capturing programmer knowledge during concept location, which is one of the tasks of software evolution and maintenance, and it is a prerequisite of a software change. We conduct a user study to measure the performance of programmers using concept maps to assist with locating concepts. The results demonstrate that programmer learning occurs during concept location and that concept maps assisted programmers with capturing programmer learning and successful concept location.", "num_citations": "3\n", "authors": ["61"]}
{"title": "we must keep going i guess\n", "abstract": " Which Practices are Suitable for an Academic Software Project? This paper presents the practices observed in successful academic projects. It classifies them by the software lifecycle stage they belong to, most of the academic projects are in stage of evolution. It also classifies them by their purpose into the organizational and code development practices. The classification may help academic project managers and developers, who are often specialist in fields other than software engineering, to select the appropriate practices for their project.", "num_citations": "2\n", "authors": ["61"]}
{"title": "A retrospective view on: The role of concepts in program comprehension:(MIP award)\n", "abstract": " This retrospective briefly recapitulates highlights of the original paper that was published at IWPC 2002. Then it overviews research directions of the last 10 years: research in tools and techniques of concept location a that aim to support software developer, research of integrated model of software change, creation of software engineering course that emphasizes the role of software developer in iterative and agile software processes, and further basic research into the role and properties of concepts.", "num_citations": "2\n", "authors": ["61"]}
{"title": "Teaching undergraduate software engineering\n", "abstract": " During the last decade, software engineering changed rapidly, from the emphasis on waterfall lifecycle to the emphasis on software evolution and agile programming. This tutorial provides a brief introduction and overview of the results of this development. It presents agile programming, Personal and Team Software Process, software change, concept location, refactoring, and so forth. The organizing principle is an outline of an undergraduate software engineering course that is based on these results. The audience interested in this tutorial may be teachers of software engineering, and also software practitioners who want learn how these results fit together and how to apply them in software projects.", "num_citations": "2\n", "authors": ["61"]}
{"title": "Jonathan I., Maletic\n", "abstract": " Organizing Committee - IEEE Conference Publication Skip to Main Content IEEE.org IEEE Xplore IEEE-SA IEEE Spectrum More Sites Create Account Personal Sign In Personal Sign In For IEEE to continue sending you helpful information on our products and services, please consent to our updated Privacy Policy. I have read and accepted the IEEE Privacy Policy. Accept & Sign In Email Address Password Sign In Forgot Password? Organizing Committee Abstract: Provides a listing of current committee members. Published in: 3rd IEEE International Workshop on Visualizing Software for Understanding and Analysis Article #: Date of Conference: 25-25 Sept. 2005 Date Added to IEEE Xplore: 09 October 2006 ISBN Information: Print ISBN: 0-7803-9540-9 INSPEC Accession Number: Persistent Link: https://xplorestaging.ieee.org/servlet/opac?punumber=11099 More \u252c\u2557 Publisher: IEEE IEEE Account Change Username/? \u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["61"]}
{"title": "The staged model of the software lifecycle: A new perspective on software evolution\n", "abstract": " In the conventional view of the software life cycle, software is produced, delivered to the user, and then enters a maintenance stage. Maintenance is the more expensive and extensive activity, and many surveys exist that analyze it in terms of constituent activities such as corrective, perfective, adaptive maintenance, etc. In this paper, we suggest a different view that partitions the conventional maintenance phase in a more useful, relevant and constructive way.We retain initial development, but then propose an explicit evolution stage. Next is a service stage, consisting of simple tactical activities. Later still, the software moves to a phase-out stage and finally to a close-down. The key point is that software evolution is quite different and separate from servicing, from phase-out, and from close-down, and this distinction is crucial in clarifying both the technical and business consequences.", "num_citations": "2\n", "authors": ["61"]}
{"title": "Two object-based decomposition methodologies: a case study\n", "abstract": " An interesting and little documented problem is the influence of a design methodology on the program architecture. In this case study, we compared two design methodologies and their impact on both development process and the resulting program architecture. The methodologies are object-based variants of refinement methodology and structured design, respectively. Both methodologies were applied to the same problem (a library system of less than 1000 lines of Ada code), and the results were compared. Substantial differences between the two resulting architectures are analysed and discussed.", "num_citations": "2\n", "authors": ["61"]}
{"title": "SNAP-A language and environment for programming in-the-large\n", "abstract": " SNAP is a language for programming-in-the-large and a supporting programming environment. SNAP requires the users to specify the interfaces of the modules first, and then to implement the bodies. The module bodies can be implemented in several languages: PL/1, PL/S. FORTRAN, COBOL, Pascal, and Assembler IBM/370. The paper describes the language for programming-in-the-large, the library system, and interface change control algorithm. It also briefly discusses the experi-ence with SNAP.Another important aspect is the choice of two orthogonal hierarchies among the modules: the system tree and the seniority hierarchy. While the system tree imposes the tree structure on the whole system, the seniority hierarchy is a directed acyclic graph among the siblings. More details are found in Section 2. A simple and effective algorithm for interface change control was employed in SNAP. More details are found in Section 4, together with the description of the library system. Section 5 describes the implementation and experience with SNAP. The appendix contains an exam-ple of a module in LPL.", "num_citations": "2\n", "authors": ["61"]}
{"title": "Software maintenance and evolution\n", "abstract": " Aims and ObjectivesSoftware maintenance and evolution are characterised by their huge cost and slow speed of implementation. Yet they are inevitable activities\u0393\u00c7\u00f4almost all software which is useful and successful stimulates user-generated requests for change and improvements. Our aim is to describe a landscape for research in software maintenance and evolution over the next ten years, in order to improve the speed and accuracy of change while reducing costs, by identifying key problems, promising solution strategies and topics of importance. The aim is met by taking two approaches. Firstly current trends and practices are projected forward using a new model of software evolution called the staged model. Both strategic problems and research to solve particular tactical problems are described within this framework. Secondly, a longer term, and much more radical vision of software evolution is presented. Both general principles and specific research topics are provided, both within an overall strategy of engineering research and rationale.", "num_citations": "2\n", "authors": ["61"]}
{"title": "Empirical study of phased model of software change\n", "abstract": " Software change is the basic task of software evolution and maintenance. Phased Model for Software Change (PMSC) is a process model for software changes that localize in the code. It consists of several phases that cover both program comprehension and code modifications. This paper presents an empirical study of an enactment of PMSC, enhanced by the use of tool JRipples. The subjects are graduate students with varying degree of programming experience. The empirical findings demonstrate that programmers with knowledge of PMSC and supported by JRipples perform perfective software changes in unfamiliar software in significantly less time (about half time) than unaided programmers. Substantial time improvements were witnessed in both code comprehension and implementation efforts.", "num_citations": "1\n", "authors": ["61"]}
{"title": "Report on a workshop on software change and evolution\n", "abstract": " This paper provides a brief overview and report on the main out-comes of the software change and evolution (SCE99) workshop held in Los Angeles on May 17, 1999, as part of the International Conference on Software Engineering 1999.The purpose of the workshop was to gather the most active of researchers and practitioners in the field of software evolution and change. The overall conclusion of the workshop was that this is a topic of enormous importance to industry, and there is a growing community of both practitioners and researchers who are working in the field. It would therefore make sense to arrange further workshops to support this expanding community.", "num_citations": "1\n", "authors": ["61"]}
{"title": "Guest Editor's Introduction\n", "abstract": " For many years, software maintenance was ignored by researchers and avoided by programmers. It was seen as an activity lacking the glamor of the early phases of software life-cycle and not providing a sufficient outlet for human creativity. However, recent advances in software maintenance research put the above-mentioned myths to the rest. Nowadays, software maintenance has established techniques and exciting research agendas. This special issue will give a glimpse of the vigorous research in this area.All four papers in this special issue originally appeared in the Proceedings of the IEEE Conference on Software Maintenance, which was held in Sorrento, Italy, October 15-17, 1991. This conference was the seventh in a series of conferences with the same title. Previous conferences were held in 1983 and 1985, and have been held annually since 1987. These conferences attract an ever-growing\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["61"]}
{"title": "Algorithm for graphic layout in VIFOR\n", "abstract": " VIFOR is a software tool for maintenance of large Fortran programs. The distinguishing feature of VIFOR layouts is the placement of all nodes into two columns depending on their class, which is referred to as a two-column graph (2CG). The 2CG consists of two subgraphs, the call graph and the reference graph. The algorithm proposed first builds the call graph by determining the positions of the nodes in the process column, and then it appends the reference graph to the drawing. The part of the algorithm that builds the layout of the call graph is described. The algorithm tries to communicate as much information about the call graph as possible. The space optimization is considered to be secondary.< >", "num_citations": "1\n", "authors": ["61"]}
{"title": "Determinism in relational systems\n", "abstract": " Relational systems were investigated for example in [2, 3, 4]\u0393\u00c7\u00f3 Their philosophy could be summarized in the following way:The basic mathematical formalism used is that of relational structures, which intuitively represent a static arrangement of interrelated objects in the real world. The arrangement is static except for short moments of change, which are formalized as substitutions into relational structure. In [2 S, biologically motivated pattern reproduction was investigated and in [3], semantics for data structure was defined within this framework.", "num_citations": "1\n", "authors": ["61"]}
{"title": "On oriented hypergraphs and on dynamics of some discrete systems\n", "abstract": " In the early 60\u0393\u00c7\u00d6s there was a surge of papers dealing with growth, self-reproduction, self-repair, etc., of automata. These notions were often discussed in the framework of the \u0393\u00c7\u00a3classical\u0393\u00c7\u00a5 theory of automata, i.e. theory which deals with automata whose inputs and outputs are considered to be words over certain finite alphabet. In other cases, special frameworks for this purpose were created, namely tessalations, and many results were obtained in this way. However both these approaches had certain limitations and it is now apparent that a new, more general framework, is needed.", "num_citations": "1\n", "authors": ["61"]}