{"title": "Software process in the classroom: The capstone project experience\n", "abstract": " A process-oriented perspective on large student projects guides students in integrating end-to-end life-cycle skills and provides consistency of experience among projects. After conducting 49 Capstone projects, the authors learned that they must cultivate a process culture, that agile processes provide a bridge from ad hoc programming assignments to organized project work, and that process requires a suitable infrastructure of tools and process expertise.", "num_citations": "107\n", "authors": ["933"]}
{"title": "The effectiveness of control structure diagrams in source code comprehension activities\n", "abstract": " Recently, the first two in a series of planned comprehension experiments were performed to measure the effect of the control structure diagram (CSD) on program comprehensibility. Upper- and lower-division computer science and software engineering students were asked to respond to questions regarding the structure and execution of one source code module of a public domain graphics library. The time taken for each response and the correctness of each response was recorded. Statistical analysis of the data collected from these two experiments revealed that the CSD was highly significant in enhancing the subjects' performance in this program comprehension task. The results of these initial experiments promise to shed light on fundamental questions regarding the effect of software visualizations on program comprehensibility.", "num_citations": "77\n", "authors": ["933"]}
{"title": "An extensible framework for providing dynamic data structure visualizations in a lightweight IDE\n", "abstract": " A framework for producing dynamic data structure visualizations within the context of a lightweight IDE is described. Multiple synchronized visualizations of a data structure can be created with minimal coding through the use of an external viewer model. The framework supplies a customizable viewer template as well as high-level APIs to a graph drawing library and the Java Debugger Interface. Initial classroom use has demonstrated the framework's ease of use as well as its potential to as an aid to student learning.", "num_citations": "74\n", "authors": ["933"]}
{"title": "Dynamic object viewers for data structures\n", "abstract": " The jGRASP lightweight IDE has been extended to provide object viewers that automatically generate dynamic, state-based visualizations of data structures in Java. These viewers provide multiple synchronized visualizations of data structures as the user steps through the source code in either debug or workbench mode. This tight integration in a lightweight IDE provides a unique and promising environment for learning data structures. Initial classroom use has demonstrated the object viewers' potential as an aid to students who are learning to write and modify classes representing data structures. Recently completed controlled experiments with CS2 students indicate that these viewers can have a significant positive impact on student performance.", "num_citations": "61\n", "authors": ["933"]}
{"title": "Implementing studio-based learning in CS2\n", "abstract": " This paper presents an experience in designing, implementing, and evaluating a studio-based learning model for CS2. Adapted from architecture and art education, as well as from collaborative problem-solving pedagogies, studio-based learning has shown great promise for computing education. Key elements of studio-based learning include exploring multiple solutions to a problem, justifying the choice of one solution, and being subject to, as well as providing, peer reviews. We describe the design, implementation, and revision of a studio model for CS2, and then present the results of an evaluation of the model when compared to traditional instruction in CS2.", "num_citations": "58\n", "authors": ["933"]}
{"title": "The control structure diagram: An overview and initial evaluation\n", "abstract": " A new graphical representation, the Control Structure Diagram (CSD), has been created to visualize software at both the source code and program design language (PDL) level. The primary impetus for creation of the CSD was to improve the comprehension efficiency of software and, as a result, improve reliability and reduce costs. The CSD has the potential to replace traditional prettyprinted source code. As part of the GRASP (Graphical Representations of Algorithms, Structures, and Processes) research project at Auburn University, the GRASP software engineering tool has been successfully developed. GRASP automatically generates CSDs from source code written in Ada, C, C++, Java, and VHDL. The emphasis to this point has been on the automatic generation of the CSD to support development, maintenance, reverse engineering and reengineering through the use of GRASP. GRASP has been\u00a0\u2026", "num_citations": "48\n", "authors": ["933"]}
{"title": "Do visualizations improve program comprehensibility? Experiments with control structure diagrams for Java\n", "abstract": " Recently, the first in a series of planned comprehension experiments was performed to measure the effect of the control structure diagram (CSD) on program comprehensibility. Upper-division computer science students were asked to respond to questions regarding the structure and execution of a source code module written in Java. Statistical analysis of the data collected from this experiment revealed that the CSD was highly significant in enhancing the subjects' performance in this program comprehension task. The results of this initial experiment along with the planned follow-on experiments promise to shed light on fundamental questions regarding the effect of software visualizations on program comprehensibility.", "num_citations": "44\n", "authors": ["933"]}
{"title": "Experimental evaluation of animated-verifying object viewers for Java\n", "abstract": " Although many visualization techniques have been shown to be pedagogically effective, they are still not widely adopted. The reasons include: lack of suitable methods of automatic-generation of visualizations, lack of integration among visualizations, and lack of integration with basic integrated development environment (IDE) support. To effectively use visualizations when developing code, it is useful to automatically generate multiple synchronized views without leaving the IDE. The jGRASP IDE provides object viewers that automatically generate dynamic, state-based visualizations of objects and primitive variables in Java. Such seamless integration of a lightweight IDE with a set of pedagogically effective software visualizations is unique and is currently unavailable in any other environment. Multiple instructors have reported positive anecdotal evidence of their usefulness. We conducted formal, repeatable\u00a0\u2026", "num_citations": "37\n", "authors": ["933"]}
{"title": "Using the debugger as an integral part of teaching CS1\n", "abstract": " Traditionally, using a debugger has had the connotation of finding and removing defects. In this paper and presentation, we explore the use of a modern integrated debugger as a program understanding tool for novice programming students in CS1. With the move to Java in the first course, instructors and students are faced with either ignoring the details of object-oriented concept or with explaining the concepts in a way that novices can understand. We show how the debugger can be used to depict the initial construction of an object, the object's inherited members, and polymorphic calls to the object's methods. Although each of these concepts can be difficult for beginning programmers, using the debugger to explicitly illustrate these concepts provides students with an opportunity for a much deeper understanding of their programs.", "num_citations": "37\n", "authors": ["933"]}
{"title": "Robust generation of dynamic data structure visualizations with multiple interaction approaches\n", "abstract": " jGRASP has three integrated approaches for interacting with its dynamic viewers for data structures: debugger, workbench, and text-based interactions that allow individual Java statements and expressions to be executed/evaluated. These approaches can be used together to provide a complementary set of interactions with the dynamic viewers. Data structure identification and rendering were tested by examining examples from 20 data structure textbooks. Controlled experiments with CS2 students indicate that the viewers can have a significant positive impact on student performance. The overall result is a flexible environment for interacting with effective dynamic data structure visualizations generated by a robust structure identifier.", "num_citations": "32\n", "authors": ["933"]}
{"title": "The role of software measures and metrics in studies of program comprehension\n", "abstract": " Many studies have been conducted into how programmers comprehend software. Models based on these studies have pointed to top-down, bottom-up, and mixed models for describing the comprehension process. In most of these studies, however, a key element of the experiment is largely ignored: the underlying nature of the software being examined by the programmers. This paper discusses software measurements and metrics that must be considered as factors when conducting comprehension studies.", "num_citations": "28\n", "authors": ["933"]}
{"title": "Language independent generation of graphical representations of source code\n", "abstract": " There are many potential benefiti to be gained from the effective we of graphical representatiom of source code. To be of practical we, however, ruch graphical representations mwt be automatically generated and supported in aoftware. There are e&tiny tools that provide this functionality, but many are source language specific. That is, they can only be wed with source code written in, say, Ada.A source language independent tool that automatically generates control structure diagrams from source code is the authors\u2019 first step towarda a suite of language independent code visualization and software engineering tools. The graphical representation generator worb in two phases: the markup phase and the rendering phase. During the markup phase, a parser for a given source language is used to embed generic markup tags in the source tezt. In the rendering phase, the embedded tags provide all the needed\u00a0\u2026", "num_citations": "27\n", "authors": ["933"]}
{"title": "Transforming the CS classroom with studio-based learning\n", "abstract": " The studio-based learning (SBL) model aims to promote learning in a social and collaborative context by having learners construct, iteratively refine, and critically review design artifacts under the guidance of instructors and disciplinary experts. Recognizing the potential of SBL to foster the development of not only technical design skills, but also increasingly-coveted communication and collaboration skills, we have been adapting the approach for computing education, implementing it in various courses, and evaluating its impact over the past 5 years. This effort now involves 26 computing courses at 15 institutions in seven states. To our knowledge, this represents the most systematic implementation and evaluation of a pedagogy for computing education to date. This special session will introduce SBL to the SIGCSE community and facilitate a discussion and exchange of ideas. In addition to oral and poster\u00a0\u2026", "num_citations": "26\n", "authors": ["933"]}
{"title": "JGRASP: an integrated development environment with visualizations for teaching java in CS1, CS2, and beyond\n", "abstract": " The authors consider the problem of finding a shortest polygonal path from s to t within a simple polygon P, subject to the restriction that the path have at most k links (edges). They give an algorithm to compute a k-link path with length at most (1+ epsilon) times the length of a shortest k-link path, for any error tolerance epsilon> 0. The algorithm runs in time O (n/sup 3/k/sup 3/log (Hk/epsilon/sup 1/k/)), where N is the largest integer coordinate among the n vertices of P. They also study the more general problem of approximating shortest k-link paths in polygons with holes. In this case, they give an algorithm that returns a path with at most 2k links and length at most that of a shortest k-link path; the running time is O (kE/sup 2/), where E is the number of edges in the visibility graph. Finally, they study the bicriteria path problem in which the two criteria are link length and'total turn'(the integral of mod Delta theta mod along a\u00a0\u2026", "num_citations": "23\n", "authors": ["933"]}
{"title": "Using generalized markup and SGML for reverse engineering graphical representations of software\n", "abstract": " As part of the ongoing research of Auburn University's GRASP (Graphical Representations of Algorithms, Structures and Processes) project, a markup language has been designed and prototyped to facilitate the automatic generation of static program visualizations from source code. Specifically, the latest release of the GRASP/Ada tool uses a markup language called GRASP-ML as the basis for automatically generating control structure diagrams from Ada source code. This markup language is described, and its role in reverse engineering with GRASP/Ada is explained. Finally, promising future work is outlined and discussed.", "num_citations": "22\n", "authors": ["933"]}
{"title": "NASA's TReK project: a case study in using the spiral model of software development\n", "abstract": " Software development projects face numerous challenges that threaten their successful completion. Whether it is not enough money, too little time, or a case of \"requirements creep\" that turns into a full sprint, projects must meet these challenges or face possible disastrous consequences. The funds needed to purchase supporting software tools or computing hardware may not be available, or they may be available for so short a period that informed purchase decisions become infeasible. Personnel resources are often limited, and it is difficult to adjust to personnel fluctuations during the project. The composition of the team personnel also offers potential challenges. A new software development team may begin with some members unfamiliar with the software development environment and project tools, and their learning curve can affect early productivity.", "num_citations": "21\n", "authors": ["933"]}
{"title": "Software visualizations for improving and measuring the comprehensibility of source code\n", "abstract": " Experiments were performed to measure the relationship of two software visualizations to software comprehension. The Control Structure Diagram (CSD) was examined for its influence on aiding the comprehension of software source code, and the Complexity Profile Graph (CPG) was examined for its ability to measure source code comprehensibility. Test subjects were asked to respond to questions regarding a code specimen written in Java. Statistical analysis of the data collected from the first experiment revealed that the CSD was highly significant in enhancing the subject\u2019s performance in this program comprehension task. Similar analysis of data collected from the second experiment showed that the measure of complexity calculated by the CPG correlated with the amount of time required to correctly understand the source code. The CPG was found to cue the software developer to complex portions of the code\u00a0\u2026", "num_citations": "20\n", "authors": ["933"]}
{"title": "Studio-based learning in CS2: An experience report\n", "abstract": " Recently there has been a surge of interest in making computer science education attractive to potential students, motivating to current students, and relevant to graduating students. We are exploring a new pedagogical approach called studio-based learning as a means to reinvigorate computer science education. Adapted from architectural education, this instructional model emphasizes learning activities in which students (a) design computational solutions to problems that lend themselves to multiple solution strategies, and (b) present and justify their solutions to their instructors and peers for critical review and discussion. In this paper we describe the studio-based approach, discuss how it was implemented in CS2, and present preliminary evaluation results.", "num_citations": "19\n", "authors": ["933"]}
{"title": "jGRASP: an integrated development environment with visualizations for teaching java in CS1, CS2, and beyond\n", "abstract": " jGRASP is an integrated development environment that provides automatic generation of visualizations to improve the comprehensibility of software. These visualizations, which are particularly well suited for CS1 and CS2 using Java, include Control Structure Diagrams, UML Class Diagrams, and dynamic Object Views for data structures such as stacks, queues, linked lists, and binary trees. The workshop will provide an in-depth introduction to jGRASP and show how to use the visualizations to improve the learning experience. Participants are encouraged to bring programs from their own courses and experiment with the visualizations for these during the workshop. jGRASP is freely available (http://www.jgrasp.org/).", "num_citations": "17\n", "authors": ["933"]}
{"title": "Dynamic program visualizations: an experience report\n", "abstract": " In this paper, we describe our experiences using dynamic program visualizations in our Java-based CS1 and CS2 courses during the spring semester 2013. The visualizations were constructed by both faculty and students using the new viewer canvas in jGRASP. A public beta version was downloaded and installed in our computer labs and on student and faculty machines. Program visualizations were used in the classroom as well as in lab activities and programming projects. Since the viewers had already been evaluated in controlled experiments, our focus was on ease of use of the viewer canvas by the students and the utility of the program visualizations in helping students understand their programs. Direct observations in the lab and individual meetings with students to discuss their work indicated that students could indeed build dynamic visualizations that, in conjunction with the debugger, helped them\u00a0\u2026", "num_citations": "14\n", "authors": ["933"]}
{"title": "Combining dynamic program viewing and testing in early computing courses\n", "abstract": " Dynamic program viewing is a form of visual verification in which a student executes one or more statements in a program and interactively observes the behavior in basic viewers (e.g., an object with its fields) and/or conceptual viewers (e.g., the structural display of binary search tree). This activity can be extremely useful from a program understanding perspective as well as a debugging perspective. In contrast, testing (e.g., with JUnit) provides a way to create persistent test cases and then run and re-run them in an efficient way. We have observed that dynamic program viewing and testing are quite complementary. When test cases are written and executed, dynamic program viewing becomes a valuable aid in traditional debugging as well. Since most test cases are written at the functional level (e.g., did a method return the expected value?), dynamically viewing test methods as they execute can provide students\u00a0\u2026", "num_citations": "14\n", "authors": ["933"]}
{"title": "Scalable visualizations to support reverse engineering: A framework for evaluation\n", "abstract": " Visualizations of software can be utilized in varying degrees throughout the software development cycle as aids to comprehension, analysis, and measurement. This research focuses on the experimental evaluation and refinement of a set of scalable visualizations that show promise for improving the overall software process. The roles which visualizations may play during reverse engineering and maintenance are of particular interest. This research also investigates the manner in which software visualizations are used in practice by software professionals. Partners from government and industry have agreed to participate by providing access to appropriate production software. This paper will describe a framework for evaluating visual techniques and investigating their practical use and application.", "num_citations": "14\n", "authors": ["933"]}
{"title": "Visual support for incremental abstraction and refinement in Ada 95\n", "abstract": " 1. ABSTRACT GRASP is a software engineering tool which uniquely combines a source code diagramming technique, the control structure diagram (CSD), with other comprehension aids such as complexity visualization, syntax coloring and source code folding. The synergistic combination of these features in GRASP has the potential to be a powerful aid in any activity where source code is expected to be read. The primary focus of GRASP is to improve the comprehension efficiency of software and, as a result, improve reliability and reduce costs during design, implementation, testing, maintenance and reengineering.", "num_citations": "13\n", "authors": ["933"]}
{"title": "Tool support for reverse engineering multi-lingual software\n", "abstract": " Multi-lingual software systems are those in which the component modules are implemented in multiple languages. Reverse engineering such systems raises several issues, particularly with regard to providing automated tool support for the process. GRASP is a prototype software engineering tool designed to provide visualization of software control structure, complexity, and architecture. The paper describes GRASP and its use in reverse engineering multi-lingual software systems.", "num_citations": "13\n", "authors": ["933"]}
{"title": "Grasp/ada95: Visualization with control structure diagrams\n", "abstract": " The Graphical Representations of Algorithms, Structures, and Processes for Ada (GRASP/Ada) project has successfully created and prototyped a new algorithmic level graphical representation for Ada software, the Control Structure Diagram (CSD). The primary impetus to create and refine the CSD is to improve the comprehension efficiency of Ada software, and as a result, improve reliability and reduce costs. The emphasis is on the automatic generation of the CSD from Ada 95 source code to support design, implementation, testing, and maintenance. The CSD has the potential to replace traditional pretty-printed Ada source code. An important additional focus of the GRASP/Ada 95 project is on the generation of a new fine-grained complexity metric called the Complexity Profile Graph (CPG), which will be synchronized with the CSD to provide both visualization and measurement of Ada 95 source code. By synchronizing the CSD and the CPG, the CSD view of control structure, nesting, and source code will be directly linked to the corresponding visualization of statement level complexity in the CPG. In this article, an overview of the GRASP/Ada 95 project at Auburn University is presented with emphasis on the Control Structure Diagram and the current prototype.", "num_citations": "11\n", "authors": ["933"]}
{"title": "Integrating multiple approaches for interacting with dynamic data structure visualizations\n", "abstract": " jGRASP 1.8.7 has integrated three approaches for interacting with its dynamic viewers for data structures: the debugger, the workbench, and a new text-based interactions tab that allows individual Java statements to be executed and expressions to be evaluated. While each of these approaches is distinct and can be used independently of the others, they can also be used together to provide a complementary set of interactions with the dynamic viewers. In order to integrate these approaches, the jGRASP visual debugger, workbench, and viewers had to be significantly redesigned. During this process, the structure identifier, which provides for the identification and rendering of common data structures, was also greatly improved by examining the examples from 20 data structure textbooks. The overall result of this integration effort is a highly flexible approach for user interaction with the dynamic data structure\u00a0\u2026", "num_citations": "9\n", "authors": ["933"]}
{"title": "Software visualization and measurement in software engineering education: An experience report\n", "abstract": " By supporting well-defined cognitive processes employed during a comprehension task, graphical representations of software could have a beneficial effect on comprehension efficiency and effectiveness. Documented empirical evidence of measurable benefits of software visualization is, however, limited in scope and often contradictory. The GRASP research project is currently evaluating the effects of software visualizations in both software engineering education as well as in software production environments. This paper describes the experimental framework and design used for evaluation in an academic setting.", "num_citations": "9\n", "authors": ["933"]}
{"title": "Testing the jgrasp structure identifier with data structure examples from textbooks\n", "abstract": " The jGRASP IDE has been extended to provide object viewers that automatically generate dynamic, state-based visualizations of data structures in Java. These viewers provide multiple synchronized visualizations of data structures as the user steps through the source code in either debug or workbench mode. This tight integration in a lightweight IDE provides a unique and promising environment for learning data structures.", "num_citations": "8\n", "authors": ["933"]}
{"title": "Visualization and Measurement of Source Code\n", "abstract": " The GRASP (Graphical Representations of Algorithms, Structures, and Processes) project, which has successfully prototyped a new algorithmic-level graphical representation for software\u2014the control structure diagram (CSD)\u2014is currently focused on the generation of a new fine-grained complexity metric called the complexity profile graph (CPG). The primary impetus for creation and refinement of the CSD and the CPG is to improve the comprehension efficiency of software and, as a result, improve reliability and reduce costs. The current GRASP release provides automatic CSD generation for Ada 95, C, C++, Java, and Very High-Speed Integrated Circuit Hardware Description Language (VHDL) source code, and CPG generation for Ada 95 source code. The examples and discussion in this article are based on using GRASP with Ada 95. omputer professionals have long promoted the idea that graphical representations of software can be extremely useful as comprehension aids when used to supplement textual descriptions and specifications of software, especially for large complex systems. The general goal of the GRASP research project is the investigation, formulation, and generation of graphical representations of algorithms, structures, and processes for source code written in languages such as Ada 95, C, C++, Java, and VHDL.", "num_citations": "8\n", "authors": ["933"]}
{"title": "Providing data structure animations in a lightweight IDE\n", "abstract": " This paper presents the data structure animation tool jGRASP, which can automatically generate multiple synchronized views while the underlying code is being developed. The seamless integration of the the IDE with pedagogically effective software visualizations makes jGRASP an interesting tool for both educators and students.", "num_citations": "7\n", "authors": ["933"]}
{"title": "Qualitative comparison of systems facilitating data structure visualization\n", "abstract": " The development of pedagogically sound learning tools using software visualization (SV) techniques has been a very popular area of research. In this paper we will conduct a qualitative comparison of a few such tools with an emphasis on data structure visualization. There are numerous tools available in academia to aid in the instruction of introductory level data structures. In this paper, we will evaluate a representative sample of these tools using Price's SV taxonomy and suggest improvements that can be incorporated in future work.", "num_citations": "7\n", "authors": ["933"]}
{"title": "Language independent program visualisation\n", "abstract": " There are many potential benefits to be gained from the effective use of graphical representations of software. To support their use in software engineering, however, such graphical representations should be automatically generated and supported by automated tools. There are existing tools that provide this functionality, but many are source language specific. That is, they can only be used with source code written in a particular language. A language independent tool that automatically generates control structure diagrams from source code is the authors' first step towards a suite of language independent software visualization and software engineering tools. The software visualization tool works in two phases: the markup phase and the rendering phase. During the markup phase, a parser for a given source language is used to embed generic markup tags in the source text. In the rendering phase, the embedded\u00a0\u2026", "num_citations": "7\n", "authors": ["933"]}
{"title": "The pragmatist in context of a National Science Foundation supported grant program evaluation: Guidelines and paradigms\n", "abstract": " Background: The philosophical underpinnings of evaluation guidelines set forth by a funding agency can sometimes seem inconsistent with that of the intervention.Purpose: Our purpose is to introduce questions pertaining to the contrast between the instructional program\u2019s underlying philosophical beliefs and assumptions and those underlying our evaluation approach. Drawing heavily on Scriven, we discuss these from a pragmatist evaluation stance in light of issues defined by Lincoln and Guba (2000).", "num_citations": "6\n", "authors": ["933"]}
{"title": "Designing a first-year project course to engage freshman software engineers: An experience report\n", "abstract": " This paper describes a software engineering project course for freshman. The course has been designed to engage and motivate software engineering students at the beginning of their matriculation, while at the same time providing solid software engineering content. Student teams use a simple software process based on extreme programming to complete a semester-long project in computer animation. Course motivation, structure, and implementation are described", "num_citations": "6\n", "authors": ["933"]}
{"title": "An empirical validation of complexity profile graph\n", "abstract": " This paper presents the results of an empirical study carried out to investigate if the complexity profile graph (CPG) is related with one of the predicators of software complexity measures, such as response time and error rate, and thus could be used as a valid indicator of program comprehensibility. Lower and upper division computer science and software engineering students were asked to respond to questions regarding the execution of a source code module written in JAVA and understanding the fundamental goal of each part of the source code. The response time for each question and the correctness of each response were recorded. The statistical analysis of the experimental data reports that there is a positive linear correlation between the CPG and the time taken to respond correctly to each question. In addition, the paper discusses if there is any effect of the control structure diagram (CSD) on measuring\u00a0\u2026", "num_citations": "6\n", "authors": ["933"]}
{"title": "jGRASP: a lightweight IDE with dynamic object viewers for CS1 and CS2\n", "abstract": " The jGRASP IDE provides new object viewers that automatically generate dynamic, state-based visualizations of objects and primitive variables in Java. Multiple synchronized visualizations of an object, including complex data structures, are immediately available to users from the jGRASP debugger window or object workbench. Initial classroom use has demonstrated the object viewers' potential as an aid to student learning, while future research will explore their utility through controlled experiments.", "num_citations": "5\n", "authors": ["933"]}
{"title": "Control structure diagrams for Ada 95\n", "abstract": " ABSTRACT GRASP (Graphical Representations of Algorithms, Structures, and Processes) is a software engineering tool which provides for the automatic generation of Control Structure Diagrams (CSD's) from Ada 95 source code. The CSD is intended to increase the comprehensibility of Ada 95 source code. CSD's are useful both when designing and implementing new software, as well as when reading existing source code. GRASP also serves as a graphical interface to GNAT (GNU Ada Translator), an Ada 95 compiler used by many companies, universities and colleges. Programmers may create and edit source files, generate CSD's for source code, print source code and CSD's, and compile and run Ada programs, all from within the GRASP environment. From a research point of view, we are interested in seeing how the GRASP environment in general and the CSD features in particular are used by\u00a0\u2026", "num_citations": "5\n", "authors": ["933"]}
{"title": "Exploring accessibility and visibility relationships in java\n", "abstract": " Inheritance and polymorphism are important OOP topics in CS1 and CS2. While these concepts are generally straightforward, there are subtleties that may leave students confused. For example, accessibility of a field in an object is generally determined by the declaring type and access modifiers of the field, and the context in the executing program from which the field is referenced. The dynamic object viewers in jGRASP have been expanded to allow the user to: (1) change the declared type of the object reference to any compatible type and (2) change the accessibility context of the object reference. These options enable the user to explore accessibility and visibility relationships by experimenting with any object on the workbench or in the debugger. Symbols, color, and text are used in the viewer to indicate inheritance relationships, accessibility, and visibility of fields and methods. Initial classroom use has\u00a0\u2026", "num_citations": "4\n", "authors": ["933"]}
{"title": "Corrections to\" the effectiveness of control structure diagrams in source code comprehension activities\"\n", "abstract": " IN the article cited above, which appeard in the May 2002 (vol. 28, no. 5) issue of this journal, some information was erroneously omitted from the final publication. The symbols should have appeared at the end of the following paragraphs on pages 475 and 476, respectively:Exception handlers in Java are implemented with try-catchfinally statements. Statements in the try block are executed sequentially until an exception is raised, at which point control is immediately transferred to at most one of the associated catch blocks. If none of the catch blocks can handle the exception, control propagates back to the calling unit. After either 1) the try block exits normally, or 2) a local catch block is executed, control transfers to the finally block. Obviously, much of this exception handling semantics is dynamic and thus cannot be represented in a static visualization such as the CSD. However, the CSD does convey the static\u00a0\u2026", "num_citations": "4\n", "authors": ["933"]}
{"title": "Providing enhanced visual support for software development and maintenance\n", "abstract": " GRASP is a robust software engineering tool that has been enhanced and improved to production quality through several earlier prototypes. The primary emphasis of the tool is on providing automatic visualization of software control structure and complexity to support development, maintenance, reverse engineering, and reengineering. GRASP has the potential to be a valuable point tool in any environment where source code is expected to be either written or read. GRASP has been extended to multiple languages such as C, C++, Java, Ada 95, and VHDL.. This paper describes the unique features of GRASP, its intended uses, and discusses promising avenues offuture research.", "num_citations": "3\n", "authors": ["933"]}
{"title": "A visual development environment for multi-lingual curricula\n", "abstract": " Although a computer science curriculum may use a single language as its \"core\" language, many curricula require students to learn and use multiple languages for course or practicum work. Students benefit from the exposure to other languages and other language models. However, a problem arising from the multi-lingual nature of a curriculum is the necessity to learn and use different development environments and language front-ends. GRASP (Graphical Representations of Algorithms, Structures, and Processes) is a software engineering tool currently being successfully utilized as a common development environment for the multi-lingual computer science curriculum at Auburn University. Besides providing a common front-end for different languages, GRASP also provides automated visualization of source code in the form of the control structure diagram and the complexity profile graph. This paper describes\u00a0\u2026", "num_citations": "3\n", "authors": ["933"]}
{"title": "Dynamic program visualizations for Java\n", "abstract": " This workshop will focus on using the new jGRASP viewer canvas which provides an exciting new dimension to dynamic program visualization. The canvas allows students and instructors to organize dynamic viewers of multiple objects and primitives to quickly form coherent program visualizations. Students can quickly build and save visualizations of their own programs, and faculty can create visualizations and provide them to students with example programs.\" Playing\" a program in canvas mode brings the visualization to life as objects come into scope and the canvas is updated automatically. All educators who teach Java will benefit from this workshop. It will be especially suitable for instructors who teach CS1 (introduction to programming), CS2 (introduction to data structures), and CS3 (introduction to algorithms), as well as for instructors of AP courses in high schools. jGRASP is a freely available educational\u00a0\u2026", "num_citations": "2\n", "authors": ["933"]}
{"title": "Adapting a studio-based learning model for CS2\n", "abstract": " This paper presents an experience in designing, implementing, and evaluating a studio-based learning model for CS2. Adapted from architecture and art education, as well as from collaborative problem-solving processes such as urban planning, studio-based learning has shown great promise for computing education. Key elements of studio-based learning include exploring multiple solutions to a problem, justifying the choice of one solution, and being subject to, as well as providing, peer reviews. We describe our two-phase approach to implementing studio-based learning in a traditional CS2 course, as well as our initial evaluation results.", "num_citations": "2\n", "authors": ["933"]}
{"title": "jGRASP: An integrated development environment with visualizations for teaching java in CS1, CS2, and beyond\n", "abstract": " We develop a multi-channel model of separating equilibrium where a seller markets a durable good to high and low type consumers in two different channels\u2014an online Internet storefront and an offline brick-and-mortar store. We show how the digital divide, where high type consumers dominate the online channel and low type consumers dominate the offline channel, artificially segments the marketplace thereby mitigating the classic cannibalization problem. This allows the seller to more efficiently market its goods to each consumer segment. We show conditions under which low type consumers are initially served in the offline channel, but subsequently bridging the divide results in low type consumers not being served in either channel. We also examine the implications of bridging the digital divide when the seller uses delay by engaging in intertemporal price discrimination.", "num_citations": "2\n", "authors": ["933"]}
{"title": "Workshop jGRASP: An Integrated Development Environment with Visualizations for Teaching Java in CS1, CS2, and Beyond\n", "abstract": " The purpose of the workshop is to introduce faculty to the advanced pedagogical features provided by jGRASP for teaching and learning Java, especially for first year students. This includes the traditional CS1 (introduction to programming) and CS2 (introduction to data structures and algorithms). jGRASP is a freely available lightweight integrated development environment (http://jgrasp. org) that provides automatically generated visualizations for improving the comprehensibility of software. These visualizations, which are particularly well suited for CS1 and CS2 students learning Java, include Control Structure Diagrams, UML Class Diagrams, and dynamic Object Views (including arrays, ArrayList, LinkedList, HashMap, and TreeMap). The object workbench and integrated debugger facilitate a unique way for students to view objects created by their programs. The workshop will include hands-on activities and\u00a0\u2026", "num_citations": "2\n", "authors": ["933"]}
{"title": "Debugging [in] CS1\n", "abstract": " Although debuggers have been around for years, many CS1 instructors do not utilize them to explain example programs in class. The connotation of a debugger is that its purpose is to assist in finding bugs rather than helping with general understanding of the program. In the fall of 2000, we began making extensive use of a highly interactive debugger in our lecture presentations in an effort to improve our teaching effectiveness. We were somewhat surprised by the number of positive responses from students. As a result, we now use the debugger as an integral part of the course.Many colleges and universities are now teaching Java in CS1 in place of C or C++. While Java is considered to have a number of advantages over C/C++(eg, Java\u2019s use of pointers is relatively transparent), it does introduce the complexities of object-oriented programming (OOP) from the beginning. Our experience indicates that in order for\u00a0\u2026", "num_citations": "2\n", "authors": ["933"]}
{"title": "An experimental validation of control structure diagrams\n", "abstract": " Recently one of the first in a series of planned comprehension experiments was performed to measure the effect of the control structure diagram (CSD), reverse engineered from source code, on program comprehensibility. Computer science students in an object oriented programming course were asked to respond to questions regarding the structure and execution of a source code module written in Java. Statistical analysis of the data collected from this experiment revealed that the CSD was highly significant in enhancing the subjects' performance in this program comprehension task. The results of this initial experiment along with the planned follow-on experiments promise to shed light on fundamental questions regarding the effect of software visualizations on program comprehensibility.", "num_citations": "2\n", "authors": ["933"]}
{"title": "Dynamic object viewers for java\n", "abstract": " The jGRASP lightweight IDE provides object viewers that automatically generate dynamic, state-based visualizations of objects and primitive variables in Java. Multiple synchronized visualizations of an object, including complex data structures, are immediately available to users from the jGRASP debugger window or object workbench. Initial use has demonstrated the object viewers' potential as an aid to understanding and debugging", "num_citations": "1\n", "authors": ["933"]}
{"title": "Improving Comprehensibility of Software with Diagramming, Folding, and Coloring\n", "abstract": " Computer professionals have long promoted the idea that graphical representations of software can be extremely useful as comprehension aids when used to supplement textual descriptions and specifications of software, especially for large, complex systems. GRASP is a software engineering tool which uniquely combines a source code diagramming technique, the control structure diagram (CSD), with syntax coloring and source code folding. The synergistic combination of diagramming, coloring, and folding supported by GRASP has the potential to be a powerful aid in any activity where source code is expected to be read. The primary impetus for combining these three techniques is to improve the comprehension efficiency of software and, as a result, improve reliability and reduce costs during design, implementation, testing, maintenance and reengineering. GRASP, which has a Motif compliant user interface\u00a0\u2026", "num_citations": "1\n", "authors": ["933"]}
{"title": "A framework for language-independent generation of graphical representations of algorithms\n", "abstract": " There are many potential benefits to be gained from the effective use of graphical representations of source code. To be of practical use, however, such graphical representations must be automatically generated and supported in software. There are existing tools that provide this functionality, but many are source language specific and cannot be easily adapted to other languages.", "num_citations": "1\n", "authors": ["933"]}