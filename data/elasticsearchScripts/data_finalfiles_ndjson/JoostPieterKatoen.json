{"title": "A storm is coming: A modern probabilistic model checker\n", "abstract": " We launch the new probabilistic model checker Storm. It features the analysis of discrete- and continuous-time variants of both Markov chains and MDPs. It supports the Prism and JANI modeling languages, probabilistic programs, dynamic fault trees and generalized stochastic Petri nets. It has a modular set-up in which solvers and symbolic engines can easily be exchanged. It offers a Python API for rapid prototyping by encapsulating Storm\u2019s fast and scalable algorithms. Experiments on a variety of benchmarks show its competitive performance.", "num_citations": "360\n", "authors": ["1579"]}
{"title": "A Markov reward model checker\n", "abstract": " This short tool paper introduces MRMC, a model checker for discrete-time and continuous-time Markov reward models. It supports reward extensions of PCTL and CSL, and allows for the automated verification of properties concerning long-run and instantaneous rewards as well as cumulative rewards. In particular it supports to check the reachability of a set of goal states (by only visiting legal states before) under a time and an accumulated reward constraint. Several numerical algorithms and extensions thereof are included in MRMC.", "num_citations": "291\n", "authors": ["1579"]}
{"title": "Concepts, algorithms, and tools for model checking\n", "abstract": " In daily life we are more and more confronted with information technology, either explicitly (by using PCs, Internet, Personal Digital Assistants, etc.) or implicitly by using devices like TVs, electric razors, mobile phones, cars, public transportation and so forth. In 1995 it has been estimated that people are in contact with about 25\\information processing devices\" per day. Due to the high integration of information technology in all kinds of applications| it is estimated that 20% of the total development costs of transportation devices such as cars, trains and air-planes are for computer-based components| we increasingly rely on the reliability (or should we say unreliability?) of software and hardware components. Clearly, we do not accept that our mobile phone is malfunctioning or that our video recorder reacts unexpectedly and wrongly to commands we issue via the remote control unit. And these errors do in a sense still have little impact: however, errors in safety-critical systems such as nuclear power plants or ight control systems are unacceptable and have a huge impact. A major problem though is", "num_citations": "167\n", "authors": ["1579"]}
{"title": "Three-valued abstraction for probabilistic systems\n", "abstract": " This paper proposes a novel abstraction technique for fully probabilistic systems. The models of our study are classical discrete-time and continuous-time Markov chains (DTMCs and CTMCs, for short). A DTMC is a Kripke structure in which each transition is equipped with a discrete probability; in a CTMC, in addition, state residence times are governed by negative exponential distributions. Our abstraction technique fits within the realm of three-valued abstraction methods that have been used successfully for traditional model checking. The key ingredients of our technique are a partitioning of the state space combined with an abstraction of transition probabilities by intervals. It is shown that this provides a conservative abstraction for both negative and affirmative verification results for a three-valued semantics of PCTL (Probabilistic Computation Tree Logic). In the continuous-time setting, the key idea is to apply\u00a0\u2026", "num_citations": "159\n", "authors": ["1579"]}
{"title": "Quantitative and qualitative extensions of event structures\n", "abstract": " Degree: Ph. D.DegreeYear: 1996Institute: Universiteit Twente (The Netherlands)Due to their observational nature interleaving models are quite appropriate for the observational description of a system in early design phases (when considering the system''s behaviour as viewed from the outside), for conformance testing, and so on. In the final stages of the design trajectory, however, the global state assumption hampers the faithful modeling of the distribution aspects of a system, each part having its own local state. At this design phase the''local''causal dependencies between actions are important, while interleavings with actions of other (irrelevant) system parts seem to burden the design. Partial-order models are considered to be much more appropriate here.", "num_citations": "149\n", "authors": ["1579"]}
{"title": "Bisimulation minimisation mostly speeds up probabilistic model checking\n", "abstract": " This paper studies the effect of bisimulation minimisation in model checking of monolithic discrete-time and continuous-time Markov chains as well as variants thereof with rewards. Our results show that\u2014as for traditional model checking\u2014enormous state space reductions (up to logarithmic savings) may be obtained. In contrast to traditional model checking, in many cases, the verification time of the original Markov chain exceeds the quotienting time plus the verification time of the quotient. We consider probabilistic bisimulation as well as versions thereof that are tailored to the property to be checked.", "num_citations": "147\n", "authors": ["1579"]}
{"title": "Counterexample generation in probabilistic model checking\n", "abstract": " Providing evidence for the refutation of a property is an essential, if not the most important, feature of model checking. This paper considers algorithms for counterexample generation for probabilistic CTL formulae in discrete-time Markov chains. Finding the strongest evidence (i.e., the most probable path) violating a (bounded) until-formula is shown to be reducible to a single-source (hop-constrained) shortest path problem. Counterexamples of smallest size that deviate most from the required probability bound can be obtained by applying (small amendments to) k-shortest (hop-constrained) paths algorithms. These results can be extended to Markov chains with rewards, to LTL model checking, and are useful for Markov decision processes. Experimental results show that typically the size of a counterexample is excessive. To obtain much more compact representations, we present a simple algorithm to generate\u00a0\u2026", "num_citations": "144\n", "authors": ["1579"]}
{"title": "Weakest precondition reasoning for expected runtimes of randomized algorithms\n", "abstract": " This article presents a wp--style calculus for obtaining bounds on the expected runtime of randomized algorithms. Its application includes determining the (possibly infinite) expected termination time of a randomized algorithm and proving positive almost--sure termination\u2014does a program terminate with probability one in finite expected time? We provide several proof rules for bounding the runtime of loops, and prove the soundness of the approach with respect to a simple operational model. We show that our approach is a conservative extension of Nielson\u2019s approach for reasoning about the runtime of deterministic programs. We analyze the expected runtime of some example programs including the coupon collector\u2019s problem, a one--dimensional random walk and a randomized binary search.", "num_citations": "135\n", "authors": ["1579"]}
{"title": "Prophesy: A probabilistic parameter synthesis tool\n", "abstract": " We present PROPhESY, a tool for analyzing parametric Markov chains (MCs). It can compute a rational function (i.e., a fraction of two polynomials in the model parameters) for reachability and expected reward objectives. Our tool outperforms state-of-the-art tools and supports the novel feature of conditional probabilities.\u00a0PROPhESY supports incremental automatic parameter synthesis (using SMT techniques) to determine \u201csafe\u201d and \u201cunsafe\u201d regions of the parameter space. All values in these regions give rise to instantiated MCs satisfying or violating the (conditional) probability or expected reward objective. PROPhESY features a web front-end supporting visualization and user-guided parameter synthesis. Experimental results show that PROPhESY scales to MCs with millions of states and several parameters.", "num_citations": "131\n", "authors": ["1579"]}
{"title": "An algebraic approach to the specification of stochastic systems\n", "abstract": " We introduce a framework to study stochastic systems, i.e. systems in which the time of occurrence of activities is a general random variable. We introduce and discuss in depth a stochastic process algebra (named \u2664) adequate to specify and analyse those systems. In order to give semantics to \u2664, we also introduce a model that is an extension of traditional automata with clocks which are basically random variables: the stochastic automata model. We show that this model and \u2664 are equally expressive. Although stochastic automata are adequate to analyse systems since they are finite objects, they are still too coarse to serve as concrete semantic objects. Therefore, we introduce a type of probabilistic transition system that can deal with arbitrary probability spaces. In addition, we give a finite axiomatisation for \u2664 that is sound for the several semantic notions we deal with, and complete for the finest of them\u00a0\u2026", "num_citations": "131\n", "authors": ["1579"]}
{"title": "A tool for model-checking Markov chains\n", "abstract": " Markov chains are widely used in the context of the performance and reliability modeling of various systems. Model checking of such chains with respect to a given (branching) temporal logic formula has been proposed for both discrete [34, 10] and continuous time settings [7, 12]. In this paper, we describe a prototype model checker for discrete and continuous-time Markov chains, the Erlangen\u2013Twente Markov Chain Checker  E\u22a2MC2, where properties are expressed in appropriate extensions of CTL. We illustrate the general benefits of this approach and discuss the structure of the tool. Furthermore, we report on successful applications of the tool to some examples, highlighting lessons learned during the development and application of E\u22a2MC2.", "num_citations": "118\n", "authors": ["1579"]}
{"title": "Design and analysis of dynamic leader election protocols in broadcast networks\n", "abstract": " The well-known problem of leader election in distributed systems is considered in a dynamic context where processes may participate and crash spontaneously. Processes communicate by means of buffered broadcasting as opposed to usual point-to-point communication. In this paper we design a leader election protocol in such a dynamic context. As the problem at hand is considerably complex we develop the protocol in three steps. In the initial design processes are considered to be perfect and a leader is assumed to be present initially. In the second protocol, the assumption of an initial leader is dropped. This leads to a symmetric protocol which uses an (abstract) timeout mechanism to detect the absence of a leader. Finally, in the last step of the design processes may crash without giving any notification of other processes. The worst case message complexity of all protocols is addressed. A formal\u00a0\u2026", "num_citations": "117\n", "authors": ["1579"]}
{"title": "Counterexamples in probabilistic model checking\n", "abstract": " This paper considers algorithms for counterexample generation for (bounded) probabilistic reachability properties in fully probabilistic systems. Finding the strongest evidence (i.e, the most probable path) violating a (bounded) until-formula is shown to be reducible to a single-source (hop-constrained) shortest path problem. Counterexamples of smallest size that are mostly deviating from the required probability bound can be computed by adopting (partially new hop-constrained) k shortest paths algorithms that dynamically determine k.", "num_citations": "110\n", "authors": ["1579"]}
{"title": "The probabilistic model checking landscape\n", "abstract": " Randomization is a key element in sequential and distributed computing. Reasoning about randomized algorithms is highly non-trivial. In the 1980s, this initiated first proof methods, logics, and model-checking algorithms. The field of probabilistic verification has developed considerably since then. This paper surveys the algorithmic verification of probabilistic models, in particular probabilistic model checking. We provide an informal account of the main models, the underlying algorithms, applications from reliability and dependability analysis---and beyond---and describe recent developments towards automated parameter synthesis.", "num_citations": "108\n", "authors": ["1579"]}
{"title": "libalf: The automata learning framework\n", "abstract": " This paper presents libalf, a comprehensive, open-source library for learning formal languages. libalf covers various well-known learning techniques for finite automata (e.g. Angluin\u2019s L*, Biermann, RPNI etc.) as well as novel learning algorithms (such as for NFA and visibly one-counter automata). libalf is flexible and allows facilely interchanging learning algorithms and combining domain-specific features in a plug-and-play fashion. Its modular design and C++ implementation make it a suitable platform for adding and engineering further learning algorithms for new target models (e.g., B\u00fcchi automata).", "num_citations": "102\n", "authors": ["1579"]}
{"title": "A stochastic causality-based process algebra\n", "abstract": " This paper discusses stochastic extensions of a simple process algebra in a causality-based setting. Atomic actions are supposed to happen after a delay that is determined by a stochastic variable with a certain distribution. A simple stochastic type of event structures is discussed, restricting the distribution functions to be exponential. A corresponding operational semantics of this model is given and compared to existing (interleaved) approaches. Secondly, a stochastic variant of event structures is discussed where distributions are of a much more general nature, viz. of phase-type. This includes exponential, Erlang, Coxian and mixtures of exponential distributions.", "num_citations": "98\n", "authors": ["1579"]}
{"title": "How fast and fat is your probabilistic model checker? an experimental performance comparison\n", "abstract": " This paper studies the efficiency of several probabilistic model checkers by comparing verification times and peak memory usage for a set of standard case studies. The study considers the model checkers ETMCC, MRMC, PRISM (sparse and hybrid mode), YMER and VESTA, and focuses on fully probabilistic systems. Several of our experiments show significantly different run times and memory consumptions between the tools\u2014up to various orders of magnitude\u2014without, however, indicating a clearly dominating tool. For statistical model checking YMER clearly prevails whereas for the numerical tools MRMC and PRISM (sparse) are rather close.", "num_citations": "95\n", "authors": ["1579"]}
{"title": "The how and why of interactive Markov chains\n", "abstract": " This paper reviews the model of interactive Markov chains (IMCs, for short), an extension of labelled transition systems with exponentially delayed transitions. We show that IMCs are closed under parallel composition and hiding, and show how IMCs can be compositionally aggregated prior to analysis by e.g., bisimulation minimisation or aggressive abstraction based on simulation pre-congruences. We survey some recent analysis techniques for IMCs, i.e., explaining how measures such as reachability probabilities can be obtained. Finally, we demonstrate that IMCs are a natural (and simple) semantic model for stochastic process algebras and generalised stochastic Petri nets and can be used for engineering formalisms such as AADL and dynamic fault trees.", "num_citations": "88\n", "authors": ["1579"]}
{"title": "Formal correctness, safety, dependability, and performance analysis of a satellite\n", "abstract": " This paper reports on the usage of a broad palette of formal modeling and analysis techniques on a regular industrial-size design of an ultra-modern satellite platform. These efforts were carried out in parallel with the conventional software development of the satellite platform. The model itself is expressed in a formalized dialect of AADL. Its formal nature enables rigorous and automated analysis, for which the recently developed COMPASS toolset was used. The whole effort revealed numerous inconsistencies in the early design documents, and the use of formal analyses provided additional insight on discrete system behavior (comprising nearly 50 million states), on hybrid system behavior involving discrete and continuous variables, and enabled the automated generation of large fault trees (66 nodes) for safety analysis that typically are constructed by hand. The model's size pushed the computational tractability\u00a0\u2026", "num_citations": "87\n", "authors": ["1579"]}
{"title": "A theory of stochastic systems part I: Stochastic automata\n", "abstract": " This paper presents the theoretical underpinning of a model for symbolically representing probabilistic transition systems, an extension of labelled transition systems for the modelling of general (discrete as well as continuous or singular) probability spaces. These transition systems are particularly suited for modelling softly timed systems, real-time systems in which the time constraints are of random nature. For continuous probability spaces these transition systems are infinite by nature. Stochastic automata represent their behaviour in a finite way. This paper presents the model of stochastic automata, their semantics in terms of probabilistic transition systems, and studies several notions of bisimulation. Furthermore, the relationship of stochastic automata to generalised semi-Markov processes is established.", "num_citations": "87\n", "authors": ["1579"]}
{"title": "Fast dynamic fault tree analysis by model checking techniques\n", "abstract": " This paper presents a new state-space generation approach for dynamic fault trees (DFTs) that exploits several successful reduction techniques from the field of model checking. The key idea is to aggressively exploit the DFT structure-detecting symmetries, spurious nondeterminism, and don't cares. Benchmarks show a gain of more than two orders of magnitude in terms of state-space generation and analysis time. This fast, scalable approach is complemented by an approximative technique that determines bounds on DFT measures by a partial state-space generation. This is shown to yield another order of magnitude gain while guaranteeing tight error bounds.", "num_citations": "84\n", "authors": ["1579"]}
{"title": "Approximate parameter synthesis for probabilistic time-bounded reachability\n", "abstract": " This paper proposes a technique to synthesize parametric rate values in continuous-time Markov chains that ensure the validity of bounded reachability properties. Rate expressions over variables indicate the average speed of state changes and are expressed using the polynomials over reals. The key contribution is an algorithm that approximates the set of parameter values for which the stochastic real-time system guarantees the validity of bounded reachability properties. This algorithm is based on discretizing parameter ranges together with a refinement technique. This paper describes the algorithm, analyzes its time complexity, and shows its applicability by deriving parameter constraints for a real-time storage system with probabilistic error checking facilities.", "num_citations": "84\n", "authors": ["1579"]}
{"title": "Linear-invariant generation for probabilistic programs\n", "abstract": " We present a constraint-based method for automatically generating quantitative invariants for linear probabilistic programs, and we show how it can be used, in combination with proof-based methods, to verify properties of probabilistic programs that cannot be analysed using existing automated methods. To our knowledge, this is the first automated method proposed for quantitative-invariant generation.", "num_citations": "83\n", "authors": ["1579"]}
{"title": "Computing optimal schedules of battery usage in embedded systems\n", "abstract": " The use of mobile devices is often limited by the battery lifetime. Some devices have the option to connect an extra battery, or to use smart battery-packs with multiple cells to extend the lifetime. In these cases, scheduling the batteries or battery cells over the load to exploit the recovery properties of the batteries helps to extend the overall systems lifetime. Straightforward scheduling schemes, like round-robin or choosing the best battery available, already provide a big improvement compared to a sequential discharge of the batteries. In this paper, we compare these scheduling schemes with the optimal scheduling scheme produced with two different modeling approaches: an approach based on a priced-timed automaton model (implemented and evaluated in Uppaal Cora), as well as an analytical approach (partly formulated as nonlinear optimization problem) for a slightly adapted scheduling problem. We show\u00a0\u2026", "num_citations": "83\n", "authors": ["1579"]}
{"title": "Parameter synthesis for Markov models: Faster than ever\n", "abstract": " We propose a conceptually simple technique for verifying probabilistic models whose transition probabilities are parametric. The key is to replace parametric transitions by nondeterministic choices of extremal values. Analysing the resulting parameter-free model using off-the-shelf means yields (refinable) lower and upper bounds on probabilities of regions in the parameter space. The technique outperforms the existing analysis of parametric Markov chains by several orders of magnitude regarding both run-time and scalability. Its beauty is its applicability to various probabilistic models. It in particular provides the first sound and feasible method for performing parameter synthesis of Markov decision processes.", "num_citations": "82\n", "authors": ["1579"]}
{"title": "Automatic verification of a lip-synchronisation protocol using Uppaal\n", "abstract": " We present the formal specification and verification of a             lip-synchronisation protocol using the real-time model checker Uppaal. A number of specifications of this protocol can be found in the literature, but this is the first automatic verification. We take a published specification of the protocol, code it up in the Uppaal timed automata notation and then verify whether the protocol satisfies the key properties of jitter and skew. The verification reveals some aws in the protocol. In particular, it shows that for certain sound and video streams the protocol can time-lock before reaching a prescribed error state. We also discuss our experience with Uppaal, with particular reference to modelling timeouts and to deadlock analysis.", "num_citations": "82\n", "authors": ["1579"]}
{"title": "Reasoning about recursive probabilistic programs\n", "abstract": " This paper presents a wp-style calculus for obtaining expectations on the outcomes of (mutually) recursive probabilistic programs. We provide several proof rules to derive one- and two-sided bounds for such expectations, and show the soundness of our wp-calculus with respect to a probabilistic pushdown automaton semantics. We also give a wp-style calculus for obtaining bounds on the expected runtime of recursive programs that can be used to determine the (possibly infinite) time until termination of such programs.", "num_citations": "81\n", "authors": ["1579"]}
{"title": "Pomsets for message sequence charts\n", "abstract": " Message sequence charts (MSCs) are a standardised formalism for the specification of the system\u2019s communication behaviour that is widely used by industry. Various extensions to MSCs have recently been standardised by the ITU. This paper treats the extension of MSCs with structural operators that allow the hierarchical composition of MSCs. In particular, we propose a linear-time partial-order semantics for this extension that is based on the notion of partial-order multi-sets (pomsets, for short). We provide a compositional denotational semantics for hierarchical MSCs and show that well-known operations on pomsets correspond to the new composition operators in MSCs. The main benefit of our approach is that the semantics is conceptually rather straightforward, as opposed to the operational semantics for MSCs that is currently in the process of standardisation.", "num_citations": "80\n", "authors": ["1579"]}
{"title": "Safety-constrained reinforcement learning for MDPs\n", "abstract": " We consider controller synthesis for stochastic and partially unknown environments in which safety is essential. Specifically, we abstract the problem as a Markov decision process in which the expected performance is measured using a cost function that is unknown prior to run-time exploration of the state space. Standard learning approaches synthesize cost-optimal strategies without guaranteeing safety properties. To remedy this, we first compute safe, permissive strategies. Then, exploration is constrained to these strategies and thereby meets the imposed safety requirements. Exploiting an iterative learning procedure, the resulting strategy is safety-constrained and optimal. We show correctness and completeness of the method and discuss the use of several heuristics to increase its scalability. Finally, we demonstrate the applicability by means of a prototype implementation.", "num_citations": "79\n", "authors": ["1579"]}
{"title": "Operational versus weakest precondition semantics for the probabilistic guarded command language\n", "abstract": " This paper proposes a simple operational semantics of pGCL, Dijkstra\u2019s guarded command language extended with probabilistic choice, and relates this to pGCL\u2019s wp-semantics by McIver and Morgan. Parametric Markov decision processes whose state rewards depend on the post-expectation at hand are used as the operational model. We show that the weakest pre-expectation of a pGCL-program wrt a post-expectation corresponds to the expected cumulative reward to reach a terminal state in the parametric MDP associated to the program. In a similar way, we show a correspondence between weakest liberal pre-expectations and liberal expected cumulative rewards. The verification of probabilistic programs using wp-semantics and operational semantics is illustrated using a simple running example.", "num_citations": "74\n", "authors": ["1579"]}
{"title": "Model-checking large structured Markov chains\n", "abstract": " This paper presents algorithms and experimental results for model-checking continuous-time Markov chains (CTMCs) based on a structured analysis approach. In this approach, a CTMC is represented as a term in Kronecker algebra that reflects the component structure of the system model. Such representations can be obtained in a natural way from various high-level specification formalisms, such as stochastic extensions of Petri nets, process algebras or activity networks. Properties are expressed in continuous stochastic logic (CSL) which includes means to express transient, steady-state and path performance measures. This paper describes novel model-checking algorithms for CSL that fully exploit the compositional description of the CTMC. This yields an effective way to combat the state-space explosion problem and enables the model-checking of fairly large Markov chains. Furthermore, we show how state\u00a0\u2026", "num_citations": "74\n", "authors": ["1579"]}
{"title": "Delayed nondeterminism in continuous-time Markov decision processes\n", "abstract": " Schedulers in randomly timed games can be classified as to whether they use timing information or not. We consider continuous-time Markov decision processes (CTMDPs) and define a hierarchy of positional\u00a0(P) and history-dependent\u00a0(H) schedulers which induce strictly tighter bounds on quantitative properties on CTMDPs. This classification into time abstract\u00a0(TA), total time\u00a0(TT) and fully time-dependent\u00a0(T) schedulers is mainly based on the kind of timing details that the schedulers may exploit. We investigate when the resolution of nondeterminism may be deferred. In particular, we show that TTP and TAP schedulers allow for delaying nondeterminism for all measures, whereas this does neither hold for TP nor for any TAH scheduler. The core of our study is a transformation on CTMDPs which unifies the speed of outgoing transitions per state.", "num_citations": "70\n", "authors": ["1579"]}
{"title": "On the hardness of analyzing probabilistic programs\n", "abstract": " We study the hardness of deciding probabilistic termination as well as the hardness of approximating expected values (e.g. of program variables) and (co)variances for probabilistic programs.               Termination We distinguish two notions of probabilistic termination: Given a program P and an input ...                                        1.                                             ...does P terminate with probability 1 on input ? (almost-sure termination)                                                                                2.                                             ...is the expected time until P terminates on input  finite? (positive almost-sure termination)                                                          For both of these notions, we also consider their universal variant, i.e. given a program P, does P terminate on all inputs? We show that deciding almost-sure termination as well as deciding its universal variant is -complete in the arithmetical hierarchy. Deciding positive almost-sure termination is shown to be -complete, whereas its\u00a0\u2026", "num_citations": "66\n", "authors": ["1579"]}
{"title": "Learning communicating automata from MSCs\n", "abstract": " This paper is concerned with bridging the gap between requirements and distributed systems. Requirements are defined as basic message sequence charts (MSCs) specifying positive and negative scenarios. Communicating finite-state machines (CFMs), i.e., finite automata that communicate via FIFO buffers, act as system realizations. The key contribution is a generalization of Angluin's learning algorithm for synthesizing CFMs from MSCs. This approach is exact-the resulting CFM precisely accepts the set of positive scenarios and rejects all negative ones-and yields fully asynchronous implementations. The paper investigates for which classes of MSC languages CFMs can be learned, presents an optimization technique for learning partial orders, and provides substantial empirical evidence indicating the practical feasibility of the approach.", "num_citations": "65\n", "authors": ["1579"]}
{"title": "Conditioning in probabilistic programming\n", "abstract": " This article investigates the semantic intricacies of conditioning, a main feature in probabilistic programming. Our study is based on an extension of the imperative probabilistic guarded command language pGCL with conditioning. We provide a weakest precondition (wp) semantics and an operational semantics. To deal with possibly diverging program behavior, we consider liberal preconditions. We show that diverging program behavior plays a key role when defining conditioning. We establish that weakest preconditions coincide with conditional expected rewards in Markov chains\u2014the operational semantics\u2014and that the wp-semantics conservatively extends the existing semantics of pGCL (without conditioning). An extension of these results with nondeterminism turns out to be problematic: although an operational semantics using Markov decision processes is rather straightforward, we show that providing an\u00a0\u2026", "num_citations": "64\n", "authors": ["1579"]}
{"title": "Quantitative timed analysis of interactive Markov chains\n", "abstract": " This paper presents new algorithms and accompanying tool support for analyzing interactive Markov chains (IMCs), a stochastic timed -player game in which delays are exponentially distributed. IMCs are compositional and act as semantic model for engineering formalisms such as AADL and dynamic fault trees. We provide algorithms for determining the extremal expected time of reaching a set of states, and the long-run average of time spent in a set of states. The prototypical tool Imca supports these algorithms as well as the synthesis of \u03b5-optimal piecewise constant timed policies for timed reachability objectives. Two case studies show the feasibility and scalability of the algorithms.", "num_citations": "60\n", "authors": ["1579"]}
{"title": "A new proof rule for almost-sure termination\n", "abstract": " We present a new proof rule for proving almost-sure termination of probabilistic programs, including those that contain demonic non-determinism.   An important question for a probabilistic program is whether the probability mass of all its diverging runs is zero, that is that it terminates \"almost surely\". Proving that can be hard, and this paper presents a new method for doing so. It applies directly to the program's source code, even if the program contains demonic choice.   Like others, we use variant functions (a.k.a. \"super-martingales\") that are real-valued and decrease randomly on each loop iteration; but our key innovation is that the amount as well as the probability of the decrease are parametric. We prove the soundness of the new rule, indicate where its applicability goes beyond existing rules, and explain its connection to classical results on denumerable (non-demonic) Markov chains.", "num_citations": "57\n", "authors": ["1579"]}
{"title": "Model checking Markov reward models with impulse rewards\n", "abstract": " This paper considers model checking of Markov reward models (MRMs), continuous-time Markov chains with state rewards as well as impulse rewards. The reward extension of the logic CSL (continuous stochastic logic) is interpreted over such MRMs, and two numerical algorithms are provided to check the reachability of a set of goal states under a time and an accumulated reward constraint. This extends existing model-checking techniques for MRMs with just state rewards, and improves the applicability to thousands of states. Our approach is illustrated by using rewards for energy consumption in the setting of dynamic power management.", "num_citations": "57\n", "authors": ["1579"]}
{"title": "Metric semantics for true concurrent real time\n", "abstract": " This paper investigates the use of a complete metric space framework for providing denotational semantics to a real-time process algebra. The study is carried out in a non-interleaving setting and is based on a timed extension of Langerak's bundle event structures, a variant of Winskel's event structures. The distance function of the metric is based on the amount of time to which event structures do \u2018agree\u2019. We show that this intuitive notion of distance is a pseudo-metric (but not a metric) on the set of timed event structures. A generalisation to equivalence classes of timed event structures in which we abstract from event identities and non-executable events (events that can never occur) is shown to be a complete ultra-metric space. We present an operational semantics for the considered language and show that the metric semantics is an abstraction of it. The operational semantics is characterised by the absence of\u00a0\u2026", "num_citations": "56\n", "authors": ["1579"]}
{"title": "On specifying real-time systems in a causality-based setting\n", "abstract": " Event structures are a prominent noninterleaving model for concurrency. Real-time event structures associate a set of time instants to events, modelling absolute time constraints, and to causal dependencies, modelling relative delays between causally dependent events. We introduce this novel temporal model and show how it can be used to provide a denotational semantics to a real-time variant of a process algebra akin to LOTOS. This formalism includes a timed-action prefix which constrains the occurrence time of actions, a timeout and watchdog (i.e., timed interrupt) operator. An event-based operational semantics for this formalism is presented that is shown to be consistent with the denotational semantics. As an example we use an infinite buffer with time constraints on the message latency and the rates of accepting and producing data.", "num_citations": "54\n", "authors": ["1579"]}
{"title": "Code generation based on formal BURS theory and heuristic search\n", "abstract": " BURS theory provides a powerful mechanism to efficiently generate pattern matches in a given expression tree. BURS, which stands for bottom-up rewrite system, is based on term rewrite systems, to which costs are added. We formalise the underlying theory, and derive an algorithm that computes all pattern matches. This algorithm terminates if the term rewrite system is finite. We couple this algorithm with the well-known search algorithm A  that carries out pattern selection. The search algorithm is directed by a cost heuristic that estimates the minimum cost of code that has yet to be generated. The advantage of using a search algorithm is that we need to compute only those costs that may be part of an optimal rewrite sequence (and not the costs of all possible rewrite sequences as in dynamic programming). A system that implements the algorithms presented in this work has been built.", "num_citations": "52\n", "authors": ["1579"]}
{"title": "A greedy approach for the efficient repair of stochastic models\n", "abstract": " For discrete-time probabilistic models there are efficient methods to check whether they satisfy certain properties. If a property is refuted, available techniques can be used to explain the failure in form of a counterexample. However, there are no scalable approaches to repair a model, i.e., to modify it with respect to certain side conditions such that the property is satisfied. In this paper we propose such a method, which avoids expensive computations and is therefore applicable to large models. A prototype implementation is used to demonstrate the applicability and scalability of our technique.", "num_citations": "51\n", "authors": ["1579"]}
{"title": "Compositional abstraction for stochastic systems\n", "abstract": " We propose to exploit three-valued abstraction to stochastic systems in a compositional way. This combines the strengths of an aggressive state-based abstraction technique with compositional modeling. Applying this principle to interactive Markov chains yields abstract models that combine interval Markov chains and modal transition systems in a natural and orthogonal way. We prove the correctness of our technique for parallel and symmetric composition and show that it yields lower bounds for minimal and upper bounds for maximal timed reachability probabilities.", "num_citations": "51\n", "authors": ["1579"]}
{"title": "Efficient CTMC model checking of linear real-time objectives\n", "abstract": " This paper makes verifying continuous-time Markov chains (CTMCs) against deterministic timed automata (DTA) objectives practical. We show that verifying 1-clock DTA can be done by analyzing subgraphs of the product of CTMC  and the region graph of DTA . This improves upon earlier results and allows to only use standard analysis algorithms. Our graph decomposition approach naturally enables bisimulation minimization as well as parallelization. Experiments with various examples confirm that these optimizations lead to significant speed-ups. We also report on experiments with multiple-clock DTA objectives. The objectives and the size of the problem instances that can be checked with our prototypical tool go (far) beyond what could be checked so far.", "num_citations": "48\n", "authors": ["1579"]}
{"title": "Foundations of Probabilistic Programming\n", "abstract": " What does a probabilistic program actually compute? How can one formally reason about such probabilistic programs? This valuable guide covers such elementary questions and more. It provides a state-of-the-art overview of the theoretical underpinnings of modern probabilistic programming and their applications in machine learning, security, and other domains, at a level suitable for graduate students and non-experts in the field. In addition, the book treats the connection between probabilistic programs and mathematical logic, security (what is the probability that software leaks confidential information?), and presents three programming languages for different applications: Excel tables, program testing, and approximate computing. This title is also available as Open Access on Cambridge Core.", "num_citations": "47\n", "authors": ["1579"]}
{"title": "StoKlaim: A stochastic extension of Klaim\n", "abstract": " Global (or network-aware) computing entails large-scale networks of computers performing tasks in a cooperative and coordinated manner. Programming and modeling languages such as Klaim focus on key functional aspects of global computing such as distribution awareness,(code and agent) mobility, and privacy aspects. This paper instead concentrates on their performance and dependability aspects. It proposes StoKlaim, an extension of Klaim which permits the description of random phenomena such as spontaneous computer crashes and spurious network hick ups. The operational semantics of StoKlaim is based on continuoustime Markov chains. The approach is illustrated by modeling the spreading of a virus through a network.", "num_citations": "46\n", "authors": ["1579"]}
{"title": "A theory of stochastic systems. Part II: Process algebra\n", "abstract": " This paper introduces (pronounce spades), a stochastic process algebra for discrete event systems, that extends traditional process algebra with timed actions whose delay is governed by general (a.o. continuous) probability distributions. The operational semantics is defined in terms of stochastic automata, a model that uses clocks\u2014like in timed automata\u2014to symbolically represent randomly timed systems, cf. the accompanying paper [P.R. D\u2019Argenio, J.-P. Kateon, A theory of stochastic systems. Part I: Stochastic automata. Inf. Comput. (2005), to appear]. We show that stochastic automata and are equally expressive, and prove that the operational semantics of a term up to \u03b1-conversion of clocks, is unique (modulo symbolic bisimulation). (Open) probabilistic and structural bisimulation are proven to be congruences for, and are equipped with an equational theory. The equational theory is shown to be complete for\u00a0\u2026", "num_citations": "46\n", "authors": ["1579"]}
{"title": "Bisimulation and logical preservation for continuous-time Markov decision processes\n", "abstract": " This paper introduces strong bisimulation for continuous-time Markov decision processes (CTMDPs), a stochastic model which allows for a nondeterministic choice between exponential distributions, and shows that bisimulation preserves the validity of CSL . To that end, we interpret the semantics of CSL \u2014a stochastic variant of CSL for continuous-time Markov chains\u2014on CTMDPs and show its measure-theoretic soundness. The main challenge faced in this paper is the proof of logical preservation that is substantially based on measure theory.", "num_citations": "44\n", "authors": ["1579"]}