{"title": "JAC: A flexible solution for aspect-oriented programming in Java\n", "abstract": " This paper presents JAC (Java Aspect Components), a framework for aspect-oriented programming in Java.Unlike languages such as AspectJ which are mostly class-based,JAC is object-based and does not require any language extensions to Java.It uses the Javassist class load-time MOP.An aspect program in JAC is a set of aspect objects that can be dynamically deploted and undeployed on top on running application objects.Aspect objects may define three kinds of aspect methods: wrapping mwthods (that wrap application methods and provide the ability to run code before and after the wrapped methods), role methods (that add new funchtionalities to applications objects) and exception handlers.The aspects composition issue is handled through a well defined wrapping controller that specifies for each wrapped object at wrap-time, runtime or both, the execusion order of aspect objects.", "num_citations": "418\n", "authors": ["118"]}
{"title": "JAC: an aspect\u2010based distributed dynamic framework\n", "abstract": " In this paper, we present the Java Aspect Components (JAC) framework for building aspect\u2010oriented distributed applications in Java. This paper describes the aspect\u2010oriented programming model and the architectural details of the framework implementation. The framework enables extension of application semantics for handling well\u2010separated concerns. This is achieved with a software entity called an aspect component (AC). ACs provide distributed pointcuts, dynamic wrappers and metamodel annotations. Distributed pointcuts are a key feature of our framework. They enable the definition of crosscutting structures that do not need to be located on a single host. ACs are dynamic. They can be added, removed, and controlled at runtime. This enables our framework to be used in highly dynamic environments where adaptable software is needed. Copyright \u00a9 2004 John Wiley & Sons, Ltd.", "num_citations": "130\n", "authors": ["118"]}
{"title": "OCL for the specification of model transformation contracts\n", "abstract": " A major challenge of the OMG Model-Driven Architecture (MDA) initiative is to be able to define and execute transformations of models. Such transformations may be defined in several ways and with various motivations. Our motivation is to specify model transformations independently of any transformation technology. To achieve this goal, we propose to define transformation contracts. We argue that model transformation contracts are an essential basis for the MDA, they can be used for specification, validation and test of transformations. This paper focuses on the specification of model transformation contracts. We investigate the way to define them using standard UML and OCL features. In addition to presenting the approach and some experimental results, this paper discusses the relevance and limits of standard OCL to define transformation contracts.", "num_citations": "113\n", "authors": ["118"]}
{"title": "A UML notation for aspect-oriented software design\n", "abstract": " This position paper presents a UML notation for designing aspect-oriented applications. It is extracted from our experiences when building the JAC framework and from the concepts defined in the AspectJ language or in Aspectual Components. This notation is a proposal for a first step towards a high-level designing graphical language that can be used when building aspect-oriented applications. Moreover, it is also suited to design Aspect-Oriented applications in distributed environments. In short, it defines three main additional concepts to UML: groups (that provide classification means for heterogenous and distributed entities), pointcut relations (that allow the programmer to define crosscuts within the functional program), and aspect-classes (that actually implement the extension of the program on the crosscutting points denoted by the pointcut relations). In this paper, we give some concrete design examples of some aspects to illustrate how it can be used.", "num_citations": "111\n", "authors": ["118"]}
{"title": "Tracking the software quality of android applications along their evolution (t)\n", "abstract": " Mobile apps are becoming complex software systems that must be developed quickly and evolve continuously to fit new user requirements and execution contexts. However, addressing these requirements may result in poor design choices, also known as antipatterns, which may incidentally degrade software quality and performance. Thus, the automatic detection and tracking of antipatterns in this apps are important activities in order to ease both maintenance and evolution. Moreover, they guide developers to refactor their applications and thus, to improve their quality. While antipatterns are well-known in object-oriented applications, their study in mobile applications is still in its infancy. In this paper, we analyze the evolution of mobile apps quality on 3, 568 versions of 106 popular Android applications downloaded from the Google Play Store. For this purpose, we use a tooled approach, called PAPRIKA, to\u00a0\u2026", "num_citations": "103\n", "authors": ["118"]}
{"title": "A model for developing component-based and aspect-oriented systems\n", "abstract": " Aspect-Oriented Programming (AOP) and Component- Based Software Engineering (CBSE) offer solutions to improve the separation of concerns and to enhance a program structure. If the integration of AOP into CBSE has already been proposed, none of these solutions focus on the application of CBSE principles to AOP. In this paper we propose a twofold integration of AOP and CBSE. We introduce a general model for components and aspects, named Fractal Aspect Component (FAC). FAC decomposes a software system into regular components and aspect components (ACs), where an AC is a regular component that embodies a crosscutting concern. We reify the aspect domain of an AC and the relationship between an AC and a component, called an aspect binding, as first-class runtime entities. This clarifies the architecture of a system where components and aspects coexist. The system can evolve\u00a0\u2026", "num_citations": "100\n", "authors": ["118"]}
{"title": "Using complex event processing for dynamic business process adaptation\n", "abstract": " As the amount of data generated by today's pervasive environments increases exponentially, there is a stronger need to decipher the important information that is hidden among it. By using complex event processing, we can obtain the information that really matters to our organization and use it to improve our processes. However, even when this information is retrieved, business processes remain static and cannot be changed dynamically to adapt to the actual scenario, diminishing the advantages that can be achieved. In this paper we present CEVICHE, a framework that combines the strengths of complex event processing and dynamic business process adaptation, which allows to respond to the needs of today's rapidly changing environments. We use a simple car rental scenario to show how CEVICHE could be used to maintain the quality of service of a business process by adapting it according to the situation.", "num_citations": "99\n", "authors": ["118"]}
{"title": "A component model engineered with components and aspects\n", "abstract": " This paper presents AOKell, a framework for engineering component-based systems. This framework implements the Fractal model, a hierarchical and dynamic component model. The novelty of this paper lies in the presentation of AOKell, an implementation of the Fractal model with aspects. Two dimensions can be isolated with Fractal: the functional dimension, which is concerned with the definition of application components, and the control dimension, which is concerned with the technical services (e.g. lifecycle, binding, persistence, etc.) that manage components. The originality of AOKell is, first, to provide an aspect-oriented approach to integrate these two dimensions, and second, to apply a component-based approach for engineering the control dimension. Hence, AOKell is a reflective component framework where application components are managed by other, so-called, control components and\u00a0\u2026", "num_citations": "99\n", "authors": ["118"]}
{"title": "Towards multi-cloud configurations using feature models and ontologies\n", "abstract": " Configuration and customization choices arise due to the heterogeneous and scalable aspect of the cloud computing paradigm. To avoid being restricted to a given cloud and ensure application requirements, using several clouds to deploy a multi-cloud configuration is recommended but introduces several challenges due to the amount of providers and their intrinsic variability. In this paper, we present a model-driven approach based on Feature Models (FMs) originating from Software Product Lines (SPL) to handle cloud variability and then manage and create cloud configurations. We combine it with ontologies, used to model the various semantics of cloud systems. The approach takes into consideration application technical requirements as well as non-functional ones to provide a set of valid cloud or multi-cloud configurations and is implemented in a framework named SALOON.", "num_citations": "73\n", "authors": ["118"]}
{"title": "Detecting antipatterns in android apps\n", "abstract": " Mobile apps are becoming complex software systems that must be developed quickly and evolve continuously to fit new user requirements and execution contexts. However, addressing these constraints may result in poor design choices, known as antipatterns, which may incidentally degrade software quality and performance. Thus, the automatic detection of antipatterns is an important activity that eases both maintenance and evolution tasks. Moreover, it guides developers to refactor their applications and thus, to improve their quality. While antipatterns are well-known in object-oriented applications, their study in mobile applications is still in their infancy. In this paper, we propose a tooled approach, called Paprika, to analyze Android applications and to detect object-oriented and Android-specific antipatterns from binaries of mobile apps. We validate the effectiveness of our approach on a set of popular mobile\u00a0\u2026", "num_citations": "68\n", "authors": ["118"]}
{"title": "Software architecture evolution\n", "abstract": " Software architectures must frequently evolve to cope with changing requirements, and this evolution often implies integrating new concerns. Unfortunately, when the new concerns are crosscutting, existing architecture description languages provide little or no support for this kind of evolution. The software architect must modify multiple elements of the architecture manually, which risks introducing inconsistencies. This chapter provides an overview, comparison and detailed treatment of the various state-of-the-art approaches to describing and evolving software architectures. Furthermore, we discuss one particular framework named Tran SAT, which addresses the above problems of software architecture evolution. Tran SAT provides a new element in the software architecture descriptions language, called an architectural aspect, for describing new concerns and their integration into an existing architecture\u00a0\u2026", "num_citations": "60\n", "authors": ["118"]}
{"title": "Automated selection and configuration of cloud environments using software product lines principles\n", "abstract": " Deploying an application to a cloud environment has recently become very trendy, since it offers many advantages such as improving reliability or scalability. These cloud environments provide a wide range of resources at different levels of functionality, which must be appropriately configured by stakeholders for the application to run properly. Handling this variability during the configuration and deployment stages is a complex and error-prone process, usually made in an ad hoc manner in existing solutions. In this paper, we propose a software product lines based approach to face these issues. Combined with a domain model used to select among cloud environments a suitable one, our approach supports stakeholders while configuring the selected cloud environment in a consistent way, and automates the deployment of such configurations through the generation of executable deployment scripts. To evaluate\u00a0\u2026", "num_citations": "58\n", "authors": ["118"]}
{"title": "Cardinality-based feature models with constraints: a pragmatic approach\n", "abstract": " Feature models originating from Software Product Line Engineering are a well-known approach to variability modeling. In many situations, the variability does not apply only on features but also on the number of times these features can be cloned. In such a case, cardinality-based feature models are used to specify the number of clones for a given feature. Although previous works already investigated approaches for feature modeling with cardinality, there is still a lack of support for constraints in the presence of clones. To overcome this limitation, we present an abstract model to define constraints in cardinality-based feature models and propose a formal semantics for this kind of constraints. We illustrate the practical usage of our approach with examples from our recent experiences on cloud computing platform configuration.", "num_citations": "58\n", "authors": ["118"]}
{"title": "A component-based and aspect-oriented model for software evolution\n", "abstract": " Component-Based Software Development (CBSD) and Aspect Oriented Software Development (AOSD) are solutions to support software evolution by decomposing a software system into concerns. In this paper, we propose Fractal Aspect Component (FAC), a general and symmetrical model for components and aspects. FAC decomposes a software system into regular components and aspect components which embody crosscutting concerns. We reify the relationship between an aspect component and a component, called an aspect binding, as a first-class runtime entity. The evolution of the system can be expressed by adding or removing components (aspect or regular) and by setting bindings (regular or crosscutting).", "num_citations": "58\n", "authors": ["118"]}
{"title": "Improving context-awareness in self-adaptation using the DYNAMICO reference model\n", "abstract": " Self-adaptation mechanisms modify target systems dynamically to address adaptation goals, which may evolve continuously due to changes in system requirements. These changes affect values and thresholds of observed context variables and monitoring logic, or imply the addition and/or deletion of context variables, thus compromising self-adaptivity effectiveness under static monitoring infrastructures. Nevertheless, self-adaptation approaches often focus on adapting target systems only rather than monitoring infrastructures. Previously, we proposed DYNAMICO, a reference model for self-adaptive systems where adaptation goals and monitoring requirements change dynamically. This paper presents an implementation of DYNAMICO comprising our SMARTERCONTEXT monitoring infrastructure and QoS-CARE adaptation framework in a self-adaptation solution that maintains its context-awareness relevance\u00a0\u2026", "num_citations": "53\n", "authors": ["118"]}
{"title": "Components, ADL 85 AOP: Towards a common approach\n", "abstract": " Components, architecture description languages and aspectoriented programming are recognized as new trends in the software engineering of modern applications. They all try to bring solutions for building more easily complex applications. This paper reports on our position that aspect\u2014oriented programming can be used both at the component and the architecture description level to describe the evolution of software. This position is validated by a prototype implementation that extend the existing Fractal component model With some dynamic aspect\u2014oriented programming features.", "num_citations": "53\n", "authors": ["118"]}
{"title": "CompAr: Ensuring safe around advice composition\n", "abstract": " Advanced techniques in separation of concerns such as Aspect-Oriented Programming, help to develop more maintainable and more efficient applications by providing means for modularizing crosscutting concerns. However, conflicts may appear when several concerns need to be composed for the same application, especially when dealing with around advice. We call this problem the Aspect Composition Issue (ACI). Based on our experience in programming aspects, this paper presents a language called CompAr, which allows the programmer to abstractly define an execution domain, the advice codes, and their execution constraints. The CompAr compiler then evaluates the definitions in order to check if the execution constraints are fulfilled. Using a concrete AOP case study, we show how to use the CompAr language in order to detect and avoid ACIs.", "num_citations": "50\n", "authors": ["118"]}
{"title": "Creating context-adaptive business processes\n", "abstract": " As the dynamicity of today\u2019s business environments keeps increasing, there is a need to continuously adapt business processes to respond to the changes in those environments and keep a competitive level. By using complex event processing, we can discover information that is relevant to our organization, which is usually hidden among the data generated in the environment, and use it to adapt the processes accordingly to respond to the changing conditions in an optimal way. Unfortunately, the static nature of business process definitions makes it impossible to adapt them at runtime and the redeployment of a modified process is required. By using a component-based approach, we can transform the existing business processes into dynamically bound components, adding the flexibility needed to adapt the processes at runtime. In this paper we present CEVICHE, a framework that combines the\u00a0\u2026", "num_citations": "47\n", "authors": ["118"]}
{"title": "Transat: A framework for the specification of software architecture evolution\n", "abstract": " Everything changes in our everyday lives: New discoveries, paradigms, styles, and technologies. Frequently, software systems success depends on how they can quickly adapt to requirement or environment evolution. Software architectures are abstract models at the highest level. As such, they should assume conceptual guidance on what parts of the system changed. However, many software architectures often evolve from an uncoordinated build-and-fix attitude. The result is opaque and not analyzable. We present in this paper a practical experience of using aspect oriented programming principles for managing software architecture specification evolution. Our approach aims at clarifying software architecture evolution steps. It extends software architecture abstract models for the specification and the analysis of new concern integration.", "num_citations": "47\n", "authors": ["118"]}
{"title": "Dynamic wrappers: handling the composition issue with JAC\n", "abstract": " Modern applications, and especially distributed ones, need flexibility and dynamic evolution. These goals can be partially reached with separation of concerns. However, a static approach is not sufficient when trying to get dynamic adaptation during the application execution-time. We present the JAC (Java Aspect Components) framework that meets dynamic adaptation by using the notions of dynamic wrappers in order to achieve separation of concerns for non-functional programs, and of wrapping controllers to implement the composition of wrappers (maybe coming from different programmers) at wrap-time and at call-time.", "num_citations": "45\n", "authors": ["118"]}
{"title": "Leveraging feature models to configure virtual appliances\n", "abstract": " Cloud computing is a major trend in distributed computing environments. Software virtualization technologies allow cloud Infrastructure-as-a-Service (IaaS) providers to instantiate and run a large number of virtual appliances. However, one of the major challenges is to reduce the disk space footprint of such virtual appliances to improve their storage and transfer across cloud servers. In this paper, we propose to use a Software Product Line (SPL) approach and describe the virtual appliance as a set of common and variable elements modeled by means of Feature Model (FM). We describe a solution to reverse engineer a FM from a virtual appliance and we show how we take advantage of the SPL configuration mechanisms to significantly reduce the size of a virtual appliance.", "num_citations": "39\n", "authors": ["118"]}
{"title": "Automated setup of multi-cloud environments for microservices applications\n", "abstract": " Multi-cloud computing has been proposed as a way to reduce vendor dependence, comply with location regulations, and optimize reliability, performance and costs. Meanwhile, microservice architectures are becoming increasingly popular in cloud computing as they promote decomposing applications into small services that can be independently deployed and scaled, thus optimizing resources usage. However, setting up a multi-cloud environment to deploy a microservices-based application is still a very complex and time consuming task. Each microservice may require different functionality (e.g. software platforms, databases, monitoring and scalability tools) and have different location and redundancy requirements. Selection of cloud providers should take into account the individual requirements of each service, as well as the global requirements of reliability and scalability. Moreover, cloud providers can be\u00a0\u2026", "num_citations": "38\n", "authors": ["118"]}
{"title": "AProSec: An aspect for programming secure web applications\n", "abstract": " Adding security functions in existing Web application servers is now vital for the IS of companies and organizations. Writing crosscutting functions in complex software should take advantage of the modularity offered by new software development approaches. With aspect-oriented programming (AOP), separating concerns when designing an application fosters reuse, parameterization and maintenance. In this paper, we design a security aspect called AProSec for detecting SQL injection and Cross Scripting Site (XSS) that are common attacks in Web servers. We experiment this aspect with the AspectJ language and the JBoss AOP framework. With this experimentation, we show the advantage of runtime platforms such as JBoss AOP for changing security policies at runtime. Finally, we describe related work on security and AOP", "num_citations": "36\n", "authors": ["118"]}
{"title": "Using multiple feature models to design applications for mobile phones\n", "abstract": " The design of a mobile phone application is a tedious task according to its intrinsic variability. Software designers must take into account in their development process the versatility of available platforms (eg, Android, iPhone). In addition to this, the variety of existing devices and their divergences (eg., frontal camera, GPS) introduce another layer of complexity in the development process. These two dimensions can be formalized as Software Product Lines (SPL), independently defined. In this paper, we use a dedicated metamodel to bridge the gap between an application SPL and a mobile device one. This meta-model is also the support for the product derivation process. The approach is implemented in a framework named Applide, and is used to successfully derive customer relationship management software on different devices.", "num_citations": "34\n", "authors": ["118"]}
{"title": "SALOON: a platform for selecting and configuring cloud environments\n", "abstract": " Migrating legacy systems or deploying a new application to a cloud environment has recently become very trendy, because the number of cloud providers available is still increasing. These cloud environments provide a wide range of resources at different levels of functionality, which must be appropriately configured by stakeholders for the application to run properly. Handling this variability during the configuration and deployment stages is known as a complex and error\u2010prone process, usually made in an ad hoc manner. In this paper, we propose SALOON, a software product lines\u2010based platform to face these issues. We describe the architecture of the SALOON platform, which relies on feature models combined with a domain model used to select among cloud environments a well\u2010suited one. SALOON supports stakeholders while configuring the selected cloud environment in a consistent way and automates\u00a0\u2026", "num_citations": "32\n", "authors": ["118"]}
{"title": "Aspect-oriented software development with Java aspect components\n", "abstract": " In the last four years, our research project dealt with separation of concerns for distributed programming environments and applications. This research effort led to the implementation of the Java Aspect Component (JAC) framework for aspect-oriented programming (AOP) in Java. Among the many requirements for distribution, flexibility and adaptability play a stringent role. The high variability of executing conditions (in terms of resources, servers availability, faults, ...) also brings the need for powerful programming paradigms. This led us to develop a dynamic model of AOP which, unlike statically compiled approaches, allows to on-the-fly deploy and undeploy aspects on top of running applications. This model comes with an UML notation and an implementation. An IDE is provided with JAC to support all the development steps of an aspect oriented application, from its design, to its implementation, to its deployment.", "num_citations": "31\n", "authors": ["118"]}
{"title": "Safarchie studio: Argouml extensions to build safe architectures\n", "abstract": " Nowadays, no standard and universal definition of software architecture was accepted by all the community. Various points of view on different studies bring to several approaches. These approaches focus on only one or two concerns such as component interfaces specification, behavioral analysis or software reconfiguration. This paper argues that, in order to accrue the true benefits of software architecture approaches, one may need to use an architecture centric approach with a global reasoning: From software architecture design to software architecture management to software architecture building, deployment and refinement. However, these different concerns of a software architecture definition must be in consistency. For this reason, we based our approach on architecture types that are points of reference at each step of our reasoning. We offer with SafArchie Studio, a first architecture centric\u00a0\u2026", "num_citations": "31\n", "authors": ["118"]}
{"title": "An automatic aspect weaver with a reflective programming language\n", "abstract": " This short paper presents A-TOS (Aspect-TOS (TCL Object System)), an aspect-oriented framework that allows the programmer to define its own specialized aspects and to weave or remove them at runtime. Since A-TOS is based on a configurable and semantic-reliable object-wrapping technique, it is able to solve what we call the Aspect-Composition Issue (ACI), i.e., to detect and solve many semantic conflicts when weaving the different aspects together.", "num_citations": "30\n", "authors": ["118"]}
{"title": "Annotation framework validation using domain models\n", "abstract": " Frameworks and libraries that use annotations are becoming popular. However, there is not enough software engineering support for annotation development. In particular, the validation of constraints in the use of annotations requires further support. In this paper we postulate that annotation frameworks are a projection of the domain model into a programming language model. Using this idea, we have developed a tool that allows the annotation programmer to specify, and then validate the constraints of the annotation framework regarding a given annotated application using a domain model. To validate our approach to the validation of constraints using models, we apply it to the Fraclet annotation framework and compare it to the previous implementation.", "num_citations": "28\n", "authors": ["118"]}
{"title": "Behavioral similarity matching using concrete source code templates in logic queries\n", "abstract": " Program query languages and pattern-detection techniques are an essential part of program analysis and manipulation systems. Queries and patterns permit the identification of the parts of interest in a program's implementation through a representation dedicated to the intent of the system (eg call-graphs to detect behavioral flaws, abstract syntax trees for transformations, concrete source code to verify programming conventions, etc). This requires that developers understand and manage all the different representations and techniques in order to detect various patterns of interest. To alleviate this overhead, we present a logic-based language that allows the program's implementation to be queried using concrete source code templates. The queries are matched against a combination of structural and behavioral program representations, including call-graphs, points-to analysis results and abstract syntax trees. The\u00a0\u2026", "num_citations": "28\n", "authors": ["118"]}
{"title": "Using constraint-based optimization and variability to support continuous self-adaptation\n", "abstract": " Self-adaptation is one of the upcoming paradigms that accurately tackles nowadays systems complexity. In this context, Dynamic Software Product Lines model the intrinsic variability of a family of systems, and dynamically support their reconfiguration according to updated context. However, when several configurations are available for the same context, making a decision about the right one is a hard challenge: further dimensions such as QoS are needed to enrich the decision making process. In this paper, we propose to combine variability with Constraint-Satisfaction Problem techniques to face this challenge. The approach is illustrated and validated with a context-driven system used to support the control of a home through mobile devices.", "num_citations": "26\n", "authors": ["118"]}
{"title": "A framework to specify incremental software architecture transformations\n", "abstract": " A software architecture description facilitates the comprehension, analysis and prototyping of a piece of software. However, such a description is often monolithic and difficult to evolve. This paper proposes a framework, named TranSAT (transformations for software architecture), for incrementally integrating new concerns into a software architecture. The structural and behavioral properties of a new concern are represented by a self-sufficient component assembly description, called an architecture plan. TranSAT proposes a software architecture pattern as a means of integrating business and technical plans. Such a pattern includes not only the plan to integrate but also the preconditions that the target architecture must satisfy, and the modifications to perform on this architecture. Consequently, from a set of patterns, TranSAT allows a software architect to incrementally build complex architectures.", "num_citations": "26\n", "authors": ["118"]}
{"title": "Safe integration of new concerns in a software architecture\n", "abstract": " Software architectures must frequently evolve to cope with changing requirements, and this evolution often implies integrating new concerns. Unfortunately, existing architecture description languages provide little or no support for this kind of evolution. The software architect must modify the architecture manually, which risks introducing inconsistencies. In previous work, we have proposed the TranSATframework, which provides a pattern construct for describing new concerns and their integration into an existing architecture. As the interaction between the new concern and the existing architecture may be complex, it is essential that the framework ensure the coherence of the resulting architecture. In this paper, we introduce a language for specifying patterns and verifications that ensure that the concern represented by a pattern can be safely integrated into an existing architecture. The verifications comprise static\u00a0\u2026", "num_citations": "23\n", "authors": ["118"]}
{"title": "Distributed separation of concerns with aspect components\n", "abstract": " The paper presents A-TOS, an aspect oriented reflective middleware for distributed programming. It provides a very special kind of entity called aspect components that implement global and transversal properties of (distributed) applications like security, fault tolerance, transactions, and so on. Since the application code does not directly refer to the aspect components, A-TOS achieves clean and powerful separation of concerns based on a wrapping composition model. Its adaptability and aspect distribution capabilities make it well suited to aspect oriented programming in a distributed environment.", "num_citations": "22\n", "authors": ["118"]}
{"title": "A model-based framework for statically and dynamically checking component interactions\n", "abstract": " Building applications by assembling software components requires analyses of Architecture Description (AD) models for checking that component interactions respect the application and runtime context requirements. Most existing interaction model analyses are static: they do not take into account runtime information, e.g., parameter values.                 This paper presents a model-based framework that enables architects to both specify component interaction and perform dynamic validation. Our framework analyses AD models to identify partially compatible interactions, which require runtime checking. Then, it instruments the application to reify runtime information for error detection. By using this framework in iterative software design processes, architects can get design feedback, i.e., detected errors, and update the AD models accordingly. Moreover, our solution is generic regarding underlying platforms\u00a0\u2026", "num_citations": "16\n", "authors": ["118"]}
{"title": "A method for specifying and proving distributed cooperative algorithms\n", "abstract": " This paper outlines a new approach for specifying, proving, and implementing distributed cooperative algorithms associated with an object-oriented design. There are many examples of distributed algorithms that can be implemented in this way (ordered multicast, routing, spanning tree construction, election, distributed garbage collection). These algorithms present several peculiar aspects due to their parallel and distributed environment. We propose to build a method that gathers three kinds of tools to specify and to prove distributed cooperative algorithms [2].", "num_citations": "15\n", "authors": ["118"]}
{"title": "Model Transformation Contracts and their Definition in UML and OCL\n", "abstract": " A major challenge of the OMG Model-Driven Architecture (MDA) initiative is to be able to define and execute transformations of models. Such transformations may be defined in several ways and with various motivations. Our motivation is to specify model transformations independently of any transformation technology. To achieve this goal, we propose to define transformation contracts. We argue that model transformation contracts are an essential basis for the MDA, they can be used for specification, validation and test of transformations. This paper focuses on model transformation contract specification. We investigate the way to define them using standard UML and OCL features. In addition to presenting the approach and some experimental results, this paper discusses some limits of standard OCL to define transformation contracts as well as some hints to bypass these limitations.", "num_citations": "14\n", "authors": ["118"]}
{"title": "Extending dynamic software product lines with temporal constraints\n", "abstract": " Due to the number of cloud providers, as well as the extensive collection of services, cloud computing provides very flexible environments, where resources and services can be provisioned and released on demand. However, reconfiguration and adaptation mechanisms in cloud environments are very heterogeneous and often exhibit complex constraints. For example, when reconfiguring a cloud system, a set of available services may be dependent on previous choices, or there may be alternative ways of adapting the system, with different impacts on performance, costs or reconfiguration time. Cloud computing systems exhibit high levels of variability, making dynamic software product lines (DSPLs) a promising approach for managing them. However, in DSPL approaches, verification is often limited to verifying conformance to a variability model, but this is insufficient to verify complex reconfiguration constraints\u00a0\u2026", "num_citations": "13\n", "authors": ["118"]}
{"title": "Using aspect programming to secure web applications\n", "abstract": " As the Internet users increase, the need to protect web servers from malicious users has become a priority in many organizations and companies. Writing crosscutting functions in complex software should take advantage of the modularity offered by new software development approaches. With AspectOriented Programming (AOP), separating concerns when designing an application fosters reuse, parameterization and maintenance. In this paper, we design a security aspect called AProSec for detecting SQL injection and Cross Scripting Site (XSS), that are common attacks in web servers. We experimented this aspect with AspectJ language and JBoss AOP. By this experimentation, we show the advantage of runtime platforms such as JBoss AOP for changing security policies at runtime. Finally, we describe related work on security and AOP.", "num_citations": "11\n", "authors": ["118"]}
{"title": "A safe aspect-oriented programming support for component-oriented programming\n", "abstract": " AOP) can be safely supported by Component- Oriented Programming (COP) by providing a way to control the openness of a component with regards to AOP techniques. Our proposal reconciles the intrusive nature of AOP with the \u201dblack box property\u201d of components in COP. We build a compromise between modularity and openness applying the open modules approach to components. The experiment has been achieved on FAC, our model that unifies the notions of component and aspect.We show that most of open modules principles are directly available within our approach, we then study requirements for others. Once all these principles integrated, we are able to tune the accessibility of the content of a component to AOP during system runtime. Thus, components become grey boxes with dynamic variation points accessible to AOP techniques.", "num_citations": "11\n", "authors": ["118"]}
{"title": "Une extension de fractal pour l'AOP\n", "abstract": " Nous pr\u00e9sentons dans ce papier une mani\u00e8re originale de repr\u00e9senter les pr\u00e9occupations transverses au sein d'une architecture \u00e0 base de composants Fractal sous forme de liaison que nous nommons liaison transverse. Cette liaison permet de repr\u00e9senter de mani\u00e8re claire les int\u00e9ractions entre composants et composants d'aspect qui incarnent les pr\u00e9occupations transverses. Chaque pr\u00e9occupation tiss\u00e9e \u00e0 l'architecture logicielle modifie la structure en introduisant un nouveau composite contenant le composant d'aspect et l'ensemble des composants concern\u00e9 par la coupe qui sont alors partag\u00e9s dans ce nouveau composite. Notre repr\u00e9sentation par liaison du tissage nous permet d'offrir une API d'introspection de coupe suffisament riche pour donner diff\u00e9rentes vues sur l'ensemble des coupes s'appliquant sur une application.", "num_citations": "11\n", "authors": ["118"]}
{"title": "Design-driven development methodology for resilient computing\n", "abstract": " Resilient computing is defined as the ability of a system to stay dependable when facing changes. To mitigate faults at runtime, dependable systems are augmented with fault tolerance mechanisms such as replication techniques. These mechanisms have to be systematically and rigorously applied in order to guarantee the conformance between the application runtime behavior and its dependability requirements.", "num_citations": "10\n", "authors": ["118"]}
{"title": "A Three-Tier Approach for Composition of Real-Time Embedded Software Stacks\n", "abstract": " Many component models and frameworks have been proposed to abstract and capture concerns from Real-Time and Embedded application domains, based on high-level component-based approaches. However, these approaches tend to propose their own fixed-set abstractions and ad-hoc runtime platforms, whereas the current trend emphasizes more flexible solutions, as embedded systems must constantly integrate new functionalities, while preserving performance. In this paper, we present a two-fold contribution addressing this statement. First, we propose to express these concerns in a decoupled way from the commonly accepted structural abstractions inherent to CBSE, and provide a framework to implement them in open and extensible runtime containers. Second, we propose a three-tier approach to composition where application, containers and the underlying operating system are designed\u00a0\u2026", "num_citations": "10\n", "authors": ["118"]}
{"title": "A framework for bridging the gap between design and runtime debugging of component-based applications\n", "abstract": " One concern when building application by assembling software components is to validate component interactions, e.g., to ensure that components exchange compatible messages. This validation requires examining data values that are only known at runtime. In current practice, this validation is often performed manually at the code level, i.e., architects need to insert validation code into the application code. This situation makes the interaction validation costly. Moreover, few platforms provide sufficient tools for supporting this validation. As a solution, we propose CALICO, a model-based framework for runtime interaction validation. CALICO enables architects to specify validation concerns in the application model. It automatically propagates this specification to application code so that component interactions in the application can be checked at runtime. Based on the detected errors, CALICO allows architects to revisit the design to fix the detected errors, and then to repeat the runtime validation in an iterative process. This paper focuses on the integration of tools in CALICO, for linking between validation specification at design time and validation realization at runtime. Moreover, we show how to extend CALICO to support multiple platforms with small development effort.", "num_citations": "10\n", "authors": ["118"]}
{"title": "Model-driven adaptation of ubiquitous applications\n", "abstract": " In ubiquitous computing, applications are executed in powerful and mobile devices allowing users to enter and leave frequently from diverse locations. Mobility becomes the rule rather than the exception. Software should be able to change its behavior and react to changes on its environment. In this proposal paper we discuss several challenges for context-aware software development and present our proposal to achieve software adaptation based on context information. We use a model of context as a starting point for a process where components are generated, deployed, and loaded on mobile devices.", "num_citations": "10\n", "authors": ["118"]}
{"title": "Extending feature models with relative cardinalities\n", "abstract": " Feature modeling is widely used to capture and manage commonalities and variabilities in software product lines. Cardinality-based feature models are used when variability applies not only to the selection or exclusion of features but also to the number of times a feature can be included in a product. Feature cardinalities are usually considered to apply in either a local or global scope. However, we have identified that these interpretations are insufficient to capture the variability of cloud environments. In this paper, we redefine cardinality-based feature models to allow multiple relative cardinalities between features and we discuss the effects of relative cardinalities on feature modeling semantics, consistency and cross-tree constraints. To evaluate our approach we conducted an analysis of relative cardinalities in four cloud computing providers. In addition, we developed tools for reasoning on feature models with\u00a0\u2026", "num_citations": "9\n", "authors": ["118"]}
{"title": "SmartyCo: Managing cyber-physical systems for smart environments\n", "abstract": " Cyber-Physical Systems (CPS) are composed of heterogeneous devices, communicating with each other and interacting with the physical world. Fostered by the growing use of smart devices that are permanently connected to the Internet, these CPS can be found in smart environments such as smart buildings, pavilions or homes. CPS must cope with the complexity and heterogeneity of their connected devices while supporting end-users with limited technical background to configure and manage their system. To deal with these issues, in this paper we introduce SmartyCo, our approach based on Dynamic Software Product Line (DSPL) principles to configure and manage CPS for smart environments. We describe its underlying architecture and illustrate in the context of smart homes how end-users can use it to define their own CPS in an automated way. We then explain how such an approach\u00a0\u2026", "num_citations": "9\n", "authors": ["118"]}
{"title": "TranSAT: ma\u00eetriser l'\u00e9volution d'une architecture logicielle\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "9\n", "authors": ["118"]}
{"title": "Separation of concerns in software modeling: a framework for software architecture transformation.\n", "abstract": " This paper presents TranSAT (Transform Software Architecture Technologies), an abstract component model for designing software architectures. TranSAT proposes structural and behavioral analysis of an architecture. It extends the classical concepts of the software architecture models to define technical concerns independently from the design model and to integrate them step by step. These refinement steps are highly inspired by Aspect Oriented Design (AOD), where the designer defines separately all the facets of an application (business and technical) and then weaves them. Then, TranSAT is a new software architecture methodology that respects the concepts of separation of concerns.", "num_citations": "9\n", "authors": ["118"]}
{"title": "A framework for automated and composable testing of component-based services\n", "abstract": " The vision of service-oriented computing has been largely developed on the fundamental principle of building systems by composing and orchestrating services in their control flow. Nowadays, software development is notably influenced by service-oriented architectures (SOAs), in which the quality of software systems is determined by the quality of the involved services and their actual composition. Despite the efforts on improving their individual quality, adding or replacing services in an evolving system can introduce failures, thus compromising the satisfaction of the system's functional and extra-functional requirements. These failures erode the trust in the SOA vision. Thus, a key issue for the industrial adoption of SOA is providing service providers, integrators, and consumers the means to build confidence that services behave according to the contracted quality conditions. In this paper we present a first version of\u00a0\u2026", "num_citations": "8\n", "authors": ["118"]}
{"title": "A commutative model composition operator to support software adaptation\n", "abstract": " The adaptive software paradigm supports the definition of software systems that are continuously adapted at run-time. An adaptation activates multiple features in the system, according to the current execution context (e.g., CPU consumption, available bandwidth). However, the underlying approaches used to implement adaptation are ordered, e.g. the order in which a set of features are turned on or off matters. Assuming feature definition as etched in stone, the identification of the right sequence is a difficult and time\u2013consuming problem. We propose here a composition operator that intrinsically supports the commutativity of adaptations. Using this operator, one can minimize the number of ordered compositions in a system. It relies on an action\u2013based approach, as this representation can support preexisting composition operators as well as our contribution in an uniform way. This approach is validated on\u00a0\u2026", "num_citations": "8\n", "authors": ["118"]}
{"title": "Using domain features to handle feature interactions\n", "abstract": " Software Product Lines in general and feature diagrams in particular support the modeling of software variability. Unfortunately, features may interact with each other, leading to feature interaction issues. Even if detected at the implementation level, interaction resolution choices are part of the business variability. In this paper, we propose to use a stepwise process to deal with feature interactions at the domain level: the way an interaction is resolved is considered as a variation point in the configuration process. This method and the associated implementation are applied onto a concrete case study (the jSeduite information system).", "num_citations": "8\n", "authors": ["118"]}
{"title": "A model-based framework to design and debug safe component-based autonomic systems\n", "abstract": " Building autonomic applications, which are systems that must adapt to their execution context, requires architects to calibrate and validate the adaptation rules by executing their applications in a realistic execution context. Unfortunately, existing works do not allow architects to monitor and visualize the impact of their rules, nor that they let them adjust these rules easily.               This paper presents a model-based framework that enables architects to design and debug autonomic systems in an iterative and uniformed process. At design-time, architects can specify, using models, the application\u2019s structure and properties, as well as the desired adaptation rules. At debugging-time, the running application and the models coexist such that the models control the application dynamic adaptation, thanks to a control loop that reified runtime events. Each triggered adaptation is first tested at the model level to check\u00a0\u2026", "num_citations": "8\n", "authors": ["118"]}
{"title": "A Traceability Service to Facilitate RFID Adoption in the Retail Supply Chain\n", "abstract": " Nowadays, companies are suffering changes in the way they deal with their inventories and their whole supply chain management. New technologies are emerging to help them adapt to the changes and keep a competitive status, but the adoption of such technologies is not always easy. Even though a lot of research has been done for RFID, there are still some areas that are being left aside, like the traceability aspect, which is one of the most important concerns in the retail supply chain. We propose a service named TRASER (TRAceability SErvice for the Retail supply chain) that will help the companies adopt the new technologies into their existing environments, dealing with persistence and traceability, and allowing the users to manage their operation according to their business rules, workflows and historical data.", "num_citations": "8\n", "authors": ["118"]}
{"title": "From formal specifications to QoS monitors.\n", "abstract": " In the domain of soft real-time application design, the gap between componentspecification models and the implementations often implies that the implementations cannot fully take advantage of the specification models. To limit this gap, this paper proposes an approach to generate a QoS monitor from the timed behavior specification. To support this approach, we rely on two different component models: one focused on formal description and the other on practical implementation. Those models are interconnected by model transformation, using a Model-Driven Engineering style.", "num_citations": "8\n", "authors": ["118"]}
{"title": "Component-based modeling and observer-based verification for railway safety-critical applications\n", "abstract": " One of the challenges that engineers face, during the development process of safety-critical systems, is the verification of safety application models before implementation. Formalization is important in order to verify that the design meets the specified safety requirements. In this paper, we formally describe the set of transformation rules, which are defined for the automatic transformation of safety application source models to timed automata target models. The source models are based on our domain-specific component model, named SARA, dedicated to SAfety-critical RAilway control applications. The target models are then used for the observer-based verification of safety requirements. This method provides an intuitive way of expressing system properties without requiring a significant knowledge of higher order logic and theorem proving, as required in most of existing approaches. An experimentation\u00a0\u2026", "num_citations": "7\n", "authors": ["118"]}
{"title": "Safety component-based approach and its application to ERTMS/ETCS on-board train control system\n", "abstract": " Safety-critical software is becoming more and more complex and at the same time it operates in frequently changing environments on which it reacts by reconfiguring its architecture. Thus, an appropriate modelling approach is needed to reduce the complexity of designing and to enable the verification of dynamic reconfiguration behaviour before the deployment at runtime. The paradigm of software component-based engineering provides an essential support for this. However, composing software from many reconfigurable components can lead to a huge number of possible compositional configurations difficult to handle at design time. Moreover, analysing all possible sequences of reconfiguration, including failure situations, is far beyond feasibility without an appropriate abstraction and granularity levels. In this paper, we propose a hierarchical component-based design approach to reduce the complexity of designing and to analyse the dynamic reconfiguration behaviour. We illustrate our approach with a case study derived from ERTMS/ETCS level 2.", "num_citations": "7\n", "authors": ["118"]}
{"title": "CAPucine: Context-aware service-oriented product line for mobile apps\n", "abstract": " The design of a mobile application is a tedious task owing to its intrinsic variability. Software designers must take into account in their development process the versatility of available platforms (eg Android, iPhone, tablets). The variety of existing devices and their divergences (eg frontal camera, GPS) introduce a further layer of complexity to the development process. In addition, at runtime, many potential situations have to be considered (eg limited connectivity, hardware heterogeneity, changes of user preference, etc.). Such software systems are seen increasingly as evolutive systems.", "num_citations": "7\n", "authors": ["118"]}
{"title": "Architectural specification and static analyses of contractual application properties\n", "abstract": " Being able to specify and verify contractual application properties at the architecture level allows architects to build better architected and more reliable systems.               In this paper, we propose a model-based framework for designing contractualized architecture, independently of any paradigm (components or services). It enables a software architect to express the structural, behavioral, dataflow and QoS properties of his/her application. Our framework composes these properties in order to compute and check the properties of the assemblies incrementally. This allows architects to see the influence of their design decisions on the quality of his/her architecture and thus helps them to better design their systems architecture.", "num_citations": "7\n", "authors": ["118"]}
{"title": "A three level framework for adapting component-based systems\n", "abstract": " This paper deals with the issue of software adaptation. We focus on Component-Based Software Development including Architecture Description Languages, and clearly identify three levels of adaptation. We argue that capturing functional and non-functional changes in a system requires various types of adaptation tools working at different granularities and times in the system lifecycle, with various actors.", "num_citations": "7\n", "authors": ["118"]}
{"title": "Some Specification and Proof Steps of a Spanning Tree Algorithm with an Object-Oriented Method\n", "abstract": " This paper presents a way to specify, to prove, and to implement object-oriented distributed cooperative algorithms. These algorithms present several particular aspects due to their parallel and distributed environment. In order to specify and to prove distributed object-oriented algorithms our method gathers three kinds of tools or formal concepts [Bonnet 94]. It is derived from the B Method [Abrial 95]. We also use the Temporal Logic of Actions [Lamport 94] to express some properties. The third set of concepts comes from distributed artificial intelligence. A main aspect of parallel and distributed computation is the uncertainty on the knowledge of other site states. To express it, an epistemic logic is used to define knowledge of sites [Halpern 90]. The method is illustrated by the first specification and proof steps of a spanning tree distributed algorithm.", "num_citations": "7\n", "authors": ["118"]}
{"title": "Undoing event-driven adaptation of business processes\n", "abstract": " As business processes continue to gain relevance in different domains, dynamicity is becoming a great concern. Static processes no longer cover the actual needs of constantly changing environments, and process adaptation is a must in order to maintain competitive levels. While creating dynamically adaptable business processes can be a challenging task, undoing these adaptations is a natural functionality that has not been studied in depth. Straight forward approaches for unadaptation can easily end up with corrupted processes, bringing uncertainty to the whole business logic. In this paper we bring forward a solution for efficiently undoing a business process adaptation in event-driven environments, considering also the correlated adaptations that happened afterwards.", "num_citations": "6\n", "authors": ["118"]}
{"title": "Fiesta: A generic framework for integrating new functionalities into software architectures\n", "abstract": " When an application must evolve to cope with new context and user requirements, integrating new functionalities into its software architecture is necessary. The architect has thus to manually modify the architecture description, which is often tedious and error prone.               In this paper, we propose FIESTA, a generic framework for automatically integrating new functionalities into an architecture description. Our approach is inspired by TranSAT, an integration framework. However, TranSAT is dedicated to a specific architecture description language (ADL) while our approach is ADL-independent. We have performed a domain analysis, studying for many ADLs how to integrate new functionalities. Based on this analysis, we have defined a generic ADL model to manipulate and reason about architectural elements that are involved in integration. Furthermore, we have developed a generic integration engine.", "num_citations": "6\n", "authors": ["118"]}
{"title": "Using Model-Driven Engineering to generate QoS Monitors from a formal specification\n", "abstract": " In the domain of soft real-time application design, the gap between component-specification models and the implementations often implies that the implementations cannot fully take advantage of the specification models. To limit this gap, this paper proposes an approach to generate a QoS monitor from the timed behavior specification. To support this approach, we rely on two different component models: one focused on formal description and the other on practical implementation. Those models are interconnected by model transformation, using a Model-Driven Engineering style.", "num_citations": "6\n", "authors": ["118"]}
{"title": "Partial order relations in distributed object environments\n", "abstract": " We describe several order relations for group cooperative applications. Our goal is to define the main interleaving semantics existing in distributed object environments with group invocations and variable sharing. We generalize the Lamport's Happened-before relation defined for message passing applications to a causal relation between actions or methods in object world. Next, we precise a set of order properties for group method invocations. It includes the local, causal and total ordering deduced from the similar ordering in message broadcast protocols, and causally coherent and serializable transactions deduced from the concurrency control. Finally, we present two implementations of one of these order property on distributed object systems GUIDE and CORBA.", "num_citations": "6\n", "authors": ["118"]}
{"title": "Observation of CORBA/Java Applications\n", "abstract": " Archive ouverte HAL - Observation of CORBA/Java Applications Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01124558, version 1 Communication dans un congr\u00e8s Observation of CORBA/Java Applications Laurence Duchien 1 E. Jeury D\u00e9tails 1 CEDRIC - Centre d'\u00e9tudes et de recherche en informatique et communications Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Liste compl\u00e8te des m\u00e9tadonn\u00e9es Voir https://hal.archives-ouvertes.fr/hal-01124558 : Cedric <> :\u2026", "num_citations": "6\n", "authors": ["118"]}
{"title": "X. 400-based distributed application design methodology\n", "abstract": " The objective of this paper is to provide a distributed application design methodology using the X. 400 standards. This one can be applied to two distributed application models: the client/server model and the peer to peer model. The client/server model relies on a relationship between a server entity and a client entity. The use of X. 400 for this model is based on the defined relationship between the UA and the MS. The peer to peer model consists of a set of cooperating entities offering a service to the users. The use of X. 400 for this model requires the creation of new MTS users and of a P2 type protocol enabling them to communicate. We analyze the advantages and disadvantages of each proposed alternative.", "num_citations": "6\n", "authors": ["118"]}
{"title": "Towards integrating aspects and components\n", "abstract": " Integrating aspects and components can be important for both AOSD and CBSD. On the one hand CBSD suffers from crosscutting and tangling code [7]. On the other hand, actual AOSD technologies are not mature enough to enable aspect reuse [6, 4]. So, each paradigm can resolve other\u2019s paradigm limitations.", "num_citations": "5\n", "authors": ["118"]}
{"title": "Promoting component reuse by integrating aspects and contracts in an architecture model\n", "abstract": " ABSTRACT\u00a2\u00a4\u00a3\u00a6\u00a5 \u00a7 \u00a9\u00a5\u00a9!#\"% $'&)(10324 (\u00a3'\u00a9%\u00a3 5\u00a5 76\u00a4 89# 7\u00a9!@ B AC (DE\u00a5 GF H\"\u00a9 P IQ\u00a3'R1ST\u00a3\u00a9%\u00a9 U\" ST\u00a3'R V&98 AWI) X9 \u00a7 'Y\u00a9% 03\u00a9 U\" R\u00a9!@ST\u00a3 a#\u00a3 b#\u00a5 7\u00a5\u00a9 U032\u00a5\u00a5(c\u00a9%\u00a5 d# e'TST 7 \u00a7 b\u00a9%\u00a3 R1ST\u00a3'\u00a9%\u00a9 f\" 76 ST\u00a3'Rg 2W\" ST\u00a3'h% ST2'T\u00a9%\u00a6 Di (#\" B e p'ST@ ST\u00a3'Rg 7 (# Dq\u00a5\u00a4 F#\"\u00a9 r FYSs\u00a5 \u00a7 t\"\u00a9% p'# e'T\u00a9 r 2u H\" 7\u00a5% v &)(\u00a3\u00a5 7\" d hf\u00a5 76\u00a4 e'7\u00a9!@ w 2'2W\"(# hf \u00a7 \u00a9% 3\"\u00a9% 2\"\u00a9% 7\u00a9 U\u00a3 C\u00a5 xy R1 (5 (C@ F9!\u00a5(\u00a9 f W6\u00a5\u00a9%\u00a3'@ 724\u00a9% hUST'h!#\u00a5 ST (\u00a3'x (DP e4 (#\u00a5 \u00a7 wh%(0324 (1\u00a3'\u00a9 U\u00a3 C\u00a5\u00a6#\u00a3 u@ S\u00a3 5\u00a5\u00a9 U\" d# hU\u00a5 ST (1\u00a3# 03 (1\u00a3'R3 hU (10324 (1\u00a3\u00a9%\u00a3 5\u00a5% v ST\u00a9 UFYST 7\u00a9 1 $724\u00a9 UhU\u00a5 76G\" S\u00a9 U\u00a3 C\u00a5\u00a9%@ b Q\"(R\" d# 0c6 03ST\u00a3'RVX 2\"(03 (\u00a5\u00a9% 7 (DE\u00a5 GF9#\"\u00a9\"\u00a9 Up'7\u00a9\u00a6 e5# hf \u00a7 S\u00a9 U WST\u00a3 Ra 7\u00a9% 2u H6\" d H\u00a5 S (\u00a3 g (D9\u00a5 \u00a7 \u00a9\u00a6@ Ss\u00a9 U\"\u00a9%\u00a3 5\u00a5 h%(\u00a3'h%\u00a9 U\"\u00a3 P\u00a5 \u00a7 u#\u00a5 d# 2'24\u00a9! H\" d ST\u00a3 gb W\u00a5\u00a9% 0bv e (HF)\u00a9%\u00a9 U\"! $ W Di\u00a9 fFf\u00a9 U (#\" 7\u00a5 \u00a7 'H 1\u00a9 e4\u00a9%\u00a9%\u00a3 b 0\u00a6@\u00a9\u00a5(c 03\u00a9 f\" R1\u00a9 g FYSs\u00a5 \u00a7 &98 AWIg\u00a3'@ hh%(1\u00a3 5\u00a5 7\" d# hU\u00a5# 2'2\"(1 hd \u00a7 '\u00a9%% vQ\u00a2\u00a4\u00a3 h\u00a5 \u00a7 'ST i 2u# 24\u00a9 U\"! $ F9\u00a9 g 2\"(24 (1 7\u00a9\u00a5(x ST\u00a3 C\u00a5\u00a9 UR\" d#\u00a5\u00a9 hh%(1\u00a3 5\u00a5 7\" d hf\u00a5\u00a3 u@ j 724\u00a9 UhU\u00a5 FYSs\u00a5 \u00a7 'ST\u00a3#\u00a3 k H\" hf \u00a7 ST\u00a5\u00a9 UhU\u00a5 p\"\u00a9 03 (C@ W\u00a9% eu 7\u00a9%@ B (1\u00a3 B\u00a5 \u00a7 \u00a9\u00a5\u00a9 U\" 03ST\u00a3'(T (1Rp'7\u00a9%@ B ST\u00a3 a g\" hd \u00a7 'Ss\u00a5\u00a9% hU\u00a5 pW\"\u00a9 l\u00a9 U6 7hU\" ST2W\u00a5 S (\u00a3 am#\u00a3'R pu R\u00a9% V lP n dXfv", "num_citations": "5\n", "authors": ["118"]}
{"title": "Detection of anti-patterns in mobile applications\n", "abstract": " Detection of Anti-patterns in Mobile Applications Page 1 HAL Id: hal-01029994 https://hal.inria.fr/hal-01029994 Submitted on 22 Jul 2014 HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L\u2019archive ouverte pluridisciplinaire HAL, est destin\u00e9e au d\u00e9p\u00f4t et \u00e0 la diffusion de documents scientifiques de niveau recherche, publi\u00e9s ou non, \u00e9manant des \u00e9tablissements d\u2019enseignement et de recherche fran\u00e7ais ou \u00e9trangers, des laboratoires publics ou priv\u00e9s. Detection of Anti-patterns in Mobile Applications Geoffrey Hecht, Laurence Duchien, Naouel Moha, Romain Rouvoy To cite this version: Geoffrey Hecht, Laurence Duchien, Naouel Moha, Romain Rouvoy. Detection of Anti-patterns in Mobile . , , -\u2026", "num_citations": "4\n", "authors": ["118"]}
{"title": "Handling constraints in cardinality-based feature models: The cloud environment case study\n", "abstract": " Feature modeling is a well-known approach to describe variability in Software Product Lines. Cardinality-based Feature Models (FMs) is a type of FMs where features can be instantiated several times in the configuration, contrarily to boolean FMs where a feature is present or not. While boolean FMs configuration is easily handled by current approaches, there is still a lack of support regarding cardinality-based FMs. In particular, expressing constraints over the set of feature instances is not supported in current approaches, where cardinality involved in such constraints can not be specified. To face this limitation, we define in this paper cardinality-based expressions and provide the related formal syntax and semantics as well as the way to automate the underlying configuration. We study the need for such a support using cloud computing environment configurations as a motivating example. To evaluate the soundness of the proposed approach, we analyze a corpus of 10 cloud environments. Our empirical evaluation shows that constraints relying on our cardinality-based expressions are common and that our approach is effective and can provide an useful support to developers for modeling and reasoning about FMs with cardinalities.", "num_citations": "4\n", "authors": ["118"]}
{"title": "Energy-driven consolidation in digital home\n", "abstract": " As our society becomes more and more digital, the corresponding demand for electric energy is increasing. Despite the power efficient design of devices, this rising trend of energy consumption does not weaken because of more and more devices used in our daily life. Collaboration strategies between devices can reduce their overall electrical consumption. Consolidation--ie., migrating tasks among devices to place into low power state or to switch off a maximum of unused devices--is a mean of optimizing the consumption of a group of devices. So far, consolidation is mainly used in datacenters. Here, we propose a model to extend this approach to Digital Home. This model takes into account properties, such as the unforeseeable appearance of devices or restrictions due to task nature. Its implementation in a Digital Home environment saves around 25% of the energy consumption in a scenario based on the daily\u00a0\u2026", "num_citations": "4\n", "authors": ["118"]}
{"title": "AppliDE: mod\u00e9lisation et g\u00e9n\u00e9ration d'applications pour smartphones\n", "abstract": " Le d\u00e9veloppement d'applications pour t\u00e9l\u00e9phones intelligents s'est complexifi\u00e9 avec l'arriv\u00e9e de nouvelles plates-formes. Cet article explique comment r\u00e9aliser une application pour terminaux mobiles en utilisant des Lignes de Produits Logiciels (LPL). Les LPL permettent de concevoir et d\u00e9velopper une famille de produits logiciels qui prend en compte des facteurs de variation tout en minimisant les co\u00fbts et les temps de r\u00e9alisation. Nous introduisons le cadre logiciel APPLIDE, qui r\u00e9alise des LPL pour t\u00e9l\u00e9phones intelligents avant d'exposer son fonctionnement au cours d'une d\u00e9monstration.", "num_citations": "4\n", "authors": ["118"]}
{"title": "Discussion on the results of the detection of design defects\n", "abstract": " Software engineers often need to identify in their systems \u201cpoor\u201d design choices\u2014design defects\u2014that hinder the development and maintenance, as opportunities of improvements and as a measure of the quality of their systems. However, the detection of design defects is difficult because of the lack of specifications and tools. We propose DECOR, a method to specify design defects systematically and to generate automatically detection algorithms. With this method, software engineers analyse and specify design defects at a high-level of abstraction using a unified vocabulary and a dedicated language for generating detection algorithms. To illustrate our method, in this paper, we specify 4 well-known design defects, the antipatterns Blob, Functional Decomposition, Spaghetti Code, and Swiss Army Knife and their 15 underlying code smells and we generate automatically their detection algorithms. We apply and validate the detection algorithms in terms of precision and recall and discuss the precision of these algorithms on 11 open-source object-oriented systems.", "num_citations": "4\n", "authors": ["118"]}
{"title": "A meta-object protocol for distributed OO applications\n", "abstract": " The design of complex distributed object applications such as transactional systems (e.g. nested transactions, two or three phase commit protocols), network algorithms (e.g. routing, spanning tree construction, group causal delivery) or cooperative applications is a hard task. We present a meta-object protocol (MOP) called CAO-LAC, to assist developers in implementing these applications. A prototype was developed for the language of the GUIDE distributed object system. The MOP uses a state/transition approach to synchronize concurrent objects. We propose some extensions to manage intra-object parallelism. Then we report on a spanning tree construction algorithm that was implemented with this MOP.", "num_citations": "4\n", "authors": ["118"]}
{"title": "Group behavior patterns in an object-oriented methodology for distributed applications\n", "abstract": " In 3] and 4] we propose a design methodology and a semiformal proof system for distributed object-oriented applications. In this paper we propose some group behavior patterns to be used with this methodology. In the introduction we compare our approach with existing methodologies. In the second section we introduce three methodological levels and the notion of group behavior. Then we present three patterns frequently used in the design of distributed applications. In the fourth section we report some experiences lead with this methodology. Then we conclude and give some trends for future works.", "num_citations": "4\n", "authors": ["118"]}
{"title": "A temporal qos ontology for ertms/etcs\n", "abstract": " Ontologies offer a means for representing and sharing information in many domains, particularly in complex domains. For example, it can be used for representing and sharing information of System Requirement Specification (SRS) of complex systems like the SRS of ERTMS/ETCS written in natural language. Since this system is a real-time and critical system, generic ontologies, such as OWL and generic ERTMS ontologies provide minimal support for modeling temporal information omnipresent in these SRS documents. To support the modeling of temporal information, one of the challenges is to enable representation of dynamic features evolving in time within a generic ontology with a minimal redesign of it. The separation of temporal information from other information can help to predict system runtime operation and to properly design and implement them. In addition, it is helpful to provide a reasoning and querying techniques to reason and query temporal information represented in the ontology in order to detect potential temporal inconsistencies. To address this challenge, we propose a lightweight 3-layer temporal Quality of Service (QoS) ontology for representing, reasoning and querying over temporal and non-temporal information in a complex domain ontology. Representing QoS entities in separated layers can clarify the distinction between the non QoS entities and the QoS entities in an ontology. The upper generic layer of the proposed ontology provides an intuitive knowledge of domain components, specially ERTMS/ETCS components. The separation of the intermediate QoS layer from the lower QoS layer allows us to focus on\u00a0\u2026", "num_citations": "3\n", "authors": ["118"]}
{"title": "Components mobility for energy efficiency of digital home\n", "abstract": " The number of connected devices in the home is growing dramatically, increasing the part of the Digital Home in the electric power demand. Reducing the overall energy consumption of the Digital Home becomes a concern in everyday life. Moving applications to the smaller set of devices enables to increase the number of devices that can be put into low power state, and thus reduce energy consumption. However, the application deployment constraints and the Digital Home heterogeneity limit the choice in deployment solutions onto available devices. We propose to consider distributed component-based applications to overcome this limitation. The distribution of applications constraints over its components improves their mobility, ie, increasing the number of devices on which a component can be deployed. This approach is optimized to reduce the set of processed solutions. Moreover, the proposed architecture\u00a0\u2026", "num_citations": "3\n", "authors": ["118"]}
{"title": "OPAD: Outils pour architectures dynamiques\n", "abstract": " Nous pr\u00e9sentons dans ce papier un mod\u00e8le abstrait qui enrichit la description de l\u2019architecture d\u2019une application gr\u00e2ce \u00e0 l\u2019extension de la notion de composite. Nous proposons d\u2019y ajouter des connaissances globales de l\u2019application regroup\u00e9es sous le vocable de groupe. Il est la base d\u2019un ensemble d\u2019outils de gestion d\u2019architectures dynamiques. Ce mod\u00e8le a pour objectif d\u2019am\u00e9liorer la description de la communication, la hi\u00e9rarchisation et la configuration au sein d\u2019une application \u00e0 base de composants.ABSTRACT. We present in this paper an abstract model that expands the software architecture description thanks to the extension of the component composite concept. We add global knowledge of the software to the model. This model aims to improve the description of the communication, the hierarchisation and the configuration within components based softwares.", "num_citations": "3\n", "authors": ["118"]}
{"title": "Achieving technical architecture with architectural figures\n", "abstract": " Specifying a technical architecture is a very complex task, especially when non functional requirements such as performance, interoperability, Quality of Service (QoS), or efficiency have to be considered. There is a large gap between the theory and practice of software architecture, particularly due to the scarcity of methods helping to turn a functional architecture into a technical architecture. Moreover, architects need tools not only to describe the architecture but also to analyze and to verify qualities of architecture.This paper presents the first step of an experiment carried out with EDF-R&D (Electricit\u00e9 de France Group). The aim is to define an architectural reusable structure named \u201carchitectural figure\u201d. These kinds of tools are essential while constructing the specification of a technical architecture (Engineering viewpoint in RM-ODP) by refining the functional architecture (Computational viewpoint in RM-ODP). A description model for these figures and some examples are proposed in this paper.", "num_citations": "3\n", "authors": ["118"]}
{"title": "Jac milestone 2001\n", "abstract": " JAC (Java Aspect Components) is a framework for aspect-oriented programming in Java. It is developed as a joint research project between the CEDRIC-CNAM and LIP6 computer science laboratories. This report gives a snapshot of the project as of September 2001. Unlike languages such as AspectJ which are mostly class-based, JAC is object-based and does not require any language extensions to Java. It uses the Javassist class load-time MOP. An aspect program in JAC is a set of aspect objects that can be dynamically deployed and undeployed on top of running application objects. Aspect objects may define three kinds of aspect methods: wrapping methods (that wrap application methods and provide the ability to run code before and after the wrapped methods), role methods (that add new functionalities to application objects), and exception handlers. The aspects composition issue is handled through a well-defined wrapping controller that specifies for each wrapped object at wrap-time, runtime or both, the execution order of aspect objects.", "num_citations": "3\n", "authors": ["118"]}
{"title": "Observation of distributed computations: A reflective approach for cORBA\n", "abstract": " This paper describes some reflective programming techniques to observe a distributed computation in a CORBA environment. First, we propose a new order relation to translate causal dependencies in a distributed program. We generalize Lamport's Happened before relation defined for message passing applications, to an object causal relation between distributed events in an environment with synchronous and asynchronous method calls, method synchronizations and variable sharings. Second, we propose a reflective approach to observe this relation. Finally, a tool is provided to display the causal dependencies graph of a distributed run.", "num_citations": "3\n", "authors": ["118"]}
{"title": "Typage pour des composants coop\u00e9ratifs\n", "abstract": " Archive ouverte HAL - Typage pour des composants coop\u00e9ratifs Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01124562, version 1 Communication dans un congr\u00e8s Typage pour des composants coop\u00e9ratifs Pascale Champagnoux 1 Laurence Duchien 1 Daniel Enselme 1 G\u00e9rard Florin 1 D\u00e9tails 1 CEDRIC - Centre d'\u00e9tudes et de recherche en informatique et communications Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Informatique [cs] / Syst\u00e8mes embarqu\u00e9s ://.-./\u2026", "num_citations": "3\n", "authors": ["118"]}
{"title": "Reflection and debug for CORBA applications\n", "abstract": " This paper describes a reflective observation of CORBA applications. First, we define several order relations to observe distributed applications in a CORBA/Java environment. Our goal is to define formally the main interleaving semantics existing in a distributed object world with method invocations and variable sharings. We generalize Lamport Happened before relation defined for message passing applications, to an object causal relation between actions in a distributed object environment. Second, we propose a reflective approach to observe this order relation by reifing some elements of the application. Finally, a tool is provided to display some post-mortem graphs of the distributed run.", "num_citations": "3\n", "authors": ["118"]}
{"title": "Reflective observation of cORBA applications\n", "abstract": " Archive ouverte HAL - Reflective Observation of CORBA Applications Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01124557, version 1 Communication dans un congr\u00e8s Reflective Observation of CORBA Applications Laurence Duchien 1 L. Seinturier D\u00e9tails 1 CEDRIC - Centre d'\u00e9tudes et de recherche en informatique et communications Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Liste compl\u00e8te des m\u00e9tadonn\u00e9es Voir https://hal.archives-ouvertes.fr/hal-: Cedric :\u2026", "num_citations": "3\n", "authors": ["118"]}
{"title": "Reliable Broadcast and Multicast tolerant to partitions\n", "abstract": " Archive ouverte HAL - Reliable Broadcast and Multicast Tolerant to Partitions, Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01124556, version 1 Communication dans un congr\u00e8s Reliable Broadcast and Multicast Tolerant to Partitions, R. Boichat Laurence Duchien 1 D\u00e9tails 1 CEDRIC - Centre d'\u00e9tudes et de recherche en informatique et communications Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Liste compl\u00e8te des m\u00e9tadonn\u00e9es Voir https://hal.archives-ouvertes\u2026", "num_citations": "3\n", "authors": ["118"]}
{"title": "A design and an observational approach for group behavior design patterns\n", "abstract": " This paper deals with the formal de nition of design patterns for group behaviors. The existing studies on distributed object-oriented applications seem to follow two ways. First, people from the analysis and design domain start with some high level algorithmic properties and de ne some models of distributed behaviors. For instance the design patterns GHJV95] community follows this approach. Second, people from the operating system and network domains start with some low level primitives and de ne some observations of distributed runs. The de nition of a causality relation Lam78] for distributed applications belongs to this approach. We show how the design and the observational approaches complement one another and are related for four design patterns. These patterns provide solutions for some standard distributed problems and are de ned in the scope of a methodology and a semi-formal proof system for distributed objects applications that we proposed in Bon94, BDFS96].", "num_citations": "3\n", "authors": ["118"]}
{"title": "A spanning tree object-oriented distributed algorithm: specification and proof\n", "abstract": " This paper presents a way to specify, to prove, and to implement object-oriented distributed cooperative algorithms. Our method gathers together three kinds of tools or formal concepts. It is derived from the B Method. So it uses a refinement approach and a proof of each specification step. The second set of concepts comes from distributed artificial intelligence. One main aspect of parallel and distributed computation is the uncertainty of the knowledge state of other sites. To express it, an epistemic logic is used to define knowledge of sites. Finally we consider some interesting practical results of distributed algorithms research. The method defines an application from three points of view (group, object, and method levels). A particular state automata formalism is used for each specification step. Finally, a distributed spanning tree algorithm i s developed.", "num_citations": "3\n", "authors": ["118"]}
{"title": "Using Feature Models for Distributed Deployment in Extended Smart Home Architecture\n", "abstract": " Nowadays, smart home is extended beyond the house itself to encompass connected platforms on the Cloud as well as mobile personal devices. This Smart Home Extended Architecture (SHEA) helps customers to remain in touch with their home everywhere and any time. The endless increase of connected devices in the home and outside within the SHEA multiplies the deployment possibilities for any application. Therefore, SHEA should be taken from now as the actual target platform for smart home application deployment. Every home is different and applications offer different services according to customer preferences. To manage this variability, we extend the feature modeling from software product line domain with deployment constraints and we present an example of a model that could address this deployment challenge.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Challenges for Automatic Multi-Cloud Configuration\n", "abstract": " Multi-cloud computing enables customers to exploit benefits of different cloud provi-ders to optimize reliability, performance and costs. Meanwhile, using multiple cloud providers reduces the risk of vendor lock-in as customers reduce their reliance on provider specific fea-tures. However, the large number of available cloud provider offerings and the differences among them makes it very complex to choose the best combination of cloud providers to deploy an application. Feature models from Software Product Line Engineering have been used to describe variability in cloud provider offerings and automatically generate valid cloud config-urations. In this paper we explore the challenges that must be faced to extend the use of feature models to automatically configure multi-cloud environments.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Vers un Outil de Configuration et de D\u00e9ploiement pour les Nuages\n", "abstract": " L'informatique dans les nuages est une tendance actuelle majeure pour r\u00e9partir les traitements et les donn\u00e9es de fa\u00e7on virtuelle sur des environnements d'ex\u00e9cution param\u00e9trables. Le d\u00e9veloppement et le d\u00e9ploiement de logiciels pour les nuages proposent un nouveau chal- lenge scientifique en termes d'expression et de prise en compte de la variabilit\u00e9. En effet, l'informatique dans les nuages repose sur des principes d'h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 et d'\u00e9lasticit\u00e9, ce qui permet de nombreux choix de configuration et de dimensionnement. Les Mod\u00e8les de Caract\u00e9ristiques (MC) issus de l'approche Ligne de Produits Logiciels (LPL) sont une r\u00e9ponse possible pour g\u00e9rer cette variabilit\u00e9, pr\u00e9parer et dimensionner des configurations \u00e0 d\u00e9ployer dans les nuages. Dans cet article, nous introduisons SALOON, un cadre logiciel d'expression de la variabilit\u00e9 et d'aide \u00e0 la d\u00e9cision pour configurer et dimensionner des applications \u00e0 d\u00e9ployer dans les nuages. Bas\u00e9 sur des ontologies et des MCS \u00e9tendus, il prend en compte les aspects techniques et non-fonctionnels de l'application pour trouver un fournisseur de nuages qui correspond au mieux \u00e0 la configuration de l'application.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Connecting your mobile shopping cart to the internet-of-things\n", "abstract": " Online shopping has reached an unforeseen success during the last decade thanks to the explosion of the Internet and the development of dedicated websites. Nonetheless, the wide diversity of e-commerce websites does not really foster the sales, but rather leaves the customer in the middle of dense jungle. In particular, finding the best offer for a specific product might require to spend hours browsing the Internet without being sure of finding the best deal in the end. While some websites are providing comparators to help the customer in finding the best offer meeting her/his requirements, the objectivity of these websites remains questionable, the comparison criteria are statically defined, while the nature of products they support is restricted to specific categories (e.g., electronic devices). In this paper, we introduce Macchiato as a user-centered platform leveraging online shopping. Macchiato implements the\u00a0\u2026", "num_citations": "2\n", "authors": ["118"]}
{"title": "Complex Event Processing for Context-Adaptive Business Processes\n", "abstract": " As the amount of data created by today\u2019s pervasive environments increases exponentially, there is a stronger need to decipher the important information that is hidden among it. By using complex event processing, we can obtain the information that really matters to our organization and use it to improve our processes. However, even when this information is discovered, the processes remain static and cannot be changed to adapt to the actual scenario, diminishing the advantages that can be achieved. In this paper we present CEVICHE, a framework that combines the strengths of complex event processing and process adaption. CEVICHE deals with the different languages used to detect complex events while presenting a single interface to the user.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Figures de transformation pour des architectures logicielles\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "2\n", "authors": ["118"]}
{"title": "Toward structural and behavioral analysis for component models\n", "abstract": " Component use is becoming more and more prevalent every day. Indeed advantages such as greater productivity represent interesting qualities for the creation of industrial applications. Important efforts are made to help engineers through the improvement of the design and the description of components and through the specification of contracts. However most of the approaches that associate components and contracts propose only run-time checking. In software architecture design, it would be useful to consider contracts when we check the validity of the architecture. Our work takes place in the context of the RM-ODP (Reference Model for Open Distributed Processing) and more precisely the DASIBAO methodology. This paper presents a componentbased model associated with several contracts and it describes some verifications that can be performed on them.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Safarchie adl: Construire et d\u00e9ployer une architecture logicielle typ\u00e9e\n", "abstract": " L\u2019augmentation des capacit\u00e9s de traitement, de stockage et de communication \u00e0 des \u00e9chelles toujours plus vastes engendre une complexit\u00e9 des syst\u00e8mes d\u2019information en croissance exponentielle. En outre, la d\u00e9pendance de l\u2019homme et de nos soci\u00e9t\u00e9s vis-\u00e0-vis des syst\u00e8mes informatiques a atteint un point de non-retour. La ma\u00eetrise et l\u2019exploitation de ces syst\u00e8mes posent d\u00e8s lors le d\u00e9fi de la construction d\u2019infrastructures logicielles adapt\u00e9es et s\u00fbres. M\u00eame si la plupart des difficult\u00e9s li\u00e9es \u00e0 la construction de ce type d\u2019application ne sont pas encore compl\u00e8tement r\u00e9solues, de nombreuses avanc\u00e9es permettent actuellement de cr\u00e9er efficacement des applications r\u00e9parties \u00e0 grande \u00e9chelle. Dans ce sens, l\u2019arriv\u00e9e du paradigme de composant (Component Based Software Engineering [Szy98][HC01]) et sa prise en compte \u00e0 tous les niveaux du cycle de d\u00e9veloppement permettent une meilleure r\u00e9utilisation et\u00a0\u2026", "num_citations": "2\n", "authors": ["118"]}
{"title": "JAC: a framework for separation of concerns and distribution\n", "abstract": " Renaud Pawlak, Laurence Duchien, L. Seinturier, G\u00e9rard Florin, Fabrice Legond-Aubry, et al.. JAC: a framework for separation of concerns and distribution. JAC: a framework for separation of concerns and distribution, 2004.\u27e8 hal-01125007\u27e9", "num_citations": "2\n", "authors": ["118"]}
{"title": "JAC: un framework pour la programmation orient\u00e9e aspect en Java\n", "abstract": " Cet article pr\u00e9sente JAC (Java Aspect Components), un framework Java pour la programmation orient\u00e9e aspect. L'objectif de ce framework est d'introduire un ensemble de concepts et de m\u00e9canismes g\u00e9n\u00e9riques permettant aux programmeurs un plus grand contr\u00f4le de l'application orient\u00e9e aspect. Ainsi, un programme d'aspect JAC est un ensemble d'objets d'aspects qui peuvent \u00eatre d\u00e9ploy\u00e9s (tiss\u00e9s) et retir\u00e9s (d\u00e9tiss\u00e9s) dynamiquement en cours d'ex\u00e9cution. Trois types d'objets d'aspect sont propos\u00e9s : les encapsuleurs dynamiques, les objets de r\u00f4le, et les gestionnaires d'exceptions. La composition d'aspects est g\u00e9r\u00e9e \u00e0 l'aide d'un contr\u00f4leur d'encapsulation. C'est la concr\u00e9tisation de ces concepts, et en particulier la sp\u00e9cialisation de contr\u00f4leurs d'encapsulation qui permet au programmeur de r\u00e9soudre la plupart des probl\u00e8mes pos\u00e9s par la composition des aspects lors de la construction d'applications orient\u00e9es aspect.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Network Membership: How to solve R-broadcast efficiently\n", "abstract": " We give a formal specification of a new model called Network Membership for reliable mobile communication in asynchronous distributed systems. Our approach is new in the sense that the Network membership service does not have any join or leave procedures. We let the system flow, views are not forced and are installed with stability. The model is less restricitve than others since no consensus is required. The Network Membership allows multiple partitions to operate simultaneously and provides connectivity feedback. We have build on top of this Network Membership service an efficient reliable broadcast service that is resistant to network partitions. The protocol insures that all recipients eventually receive the message even if a receiver has been partitionned away at any time. We show how we use an unreliable channel detector in conjonction with data forwarding and stability to achieve this goal.", "num_citations": "2\n", "authors": ["118"]}
{"title": "The Wave Algorithms as a Self-Stabilizing Control Structure\n", "abstract": " Wave algorithms are presented in many papers as solution for distributed problems. On the other hand, there are numerous research teams working on self-stabilizing systems eg", "num_citations": "2\n", "authors": ["118"]}
{"title": "Debugging of distributed object-oriented applications\n", "abstract": " This paper presents a debugging tool to observe causality relationships in concurrent object oriented algorithms. We suggest to take into account four sources of order that convey dependencies introduced by concurrency, synchronization and transactional aspects. These new causal relations are illustrated by graphs related to particular views of a program execution.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Integration of a Multimedia Filestore with X. 400\n", "abstract": " Nowadays, the electronic mail is a well known means for communications. The success of X. 400 messaging systems allows to consider added services to the X. 400 standards.", "num_citations": "2\n", "authors": ["118"]}
{"title": "Software Product Lines for Multi-Cloud Microservices-Based Applications\n", "abstract": " Multi-cloud computing is the use of resources and services from multiple independent cloud providers. It is used to avoid vendor lock-in, comply with location regulations, and optimize reliability, performance and costs. Microservices is an architectural style becoming increasingly used in cloud computing as it allows for better resources usage. However, building multi-cloud systems is a very complex and time consuming task, which calls for automation and supporting tools. Here we present an automated approach to build a multi-cloud environment for a microservices-based application , considering the concerns of cloud heterogeneity and variability.", "num_citations": "1\n", "authors": ["118"]}
{"title": "Actes des Sixi\u00e8mes journ\u00e9es nationales du Groupement De Recherche CNRS du G\u00e9nie de la Programmation et du Logiciel\n", "abstract": " Ce document contient les actes des Sixi\u00e8mes journ\u00e9es nationales du Groupement De Recherche CNRS du G\u00e9nie de la Programmation et du Logiciel (GDR GPL) s'\u00e9tant d\u00e9roul\u00e9es au CNAM \u00e0 Paris du 11 au 13 juin 2014. Les contributions pr\u00e9sent\u00e9es dans ce document ont \u00e9t\u00e9 s\u00e9lectionn\u00e9es par les diff\u00e9rents groupes de travail du GDR. Il s'agit de r\u00e9sum\u00e9s, de nouvelles versions, de posters et de d\u00e9monstrations qui correspondent \u00e0 des travaux qui ont d\u00e9j\u00e0 \u00e9t\u00e9 valid\u00e9s par les comit\u00e9s de programmes d'autres conf\u00e9rences et revues et dont les droits appartiennent exclusivement \u00e0 leurs auteurs.", "num_citations": "1\n", "authors": ["118"]}
{"title": "A causal model to predict the effect of business process evolution on quality of service\n", "abstract": " Managing Quality of Service (QoS) of Service-based systems is a key challenge to produce systems that fulfill their requirements. Verifying the respect of a QoS contract in a system becomes more and more difficult as systems are more and more complex. Moreover, systems have to evolve in order to fulfil constantly changing requirements. As QoS properties are influenced by hidden factors such as connection rate or the system execution itself, determining the cause of a performance degradation is not mainstream. We propose in this paper to identify the causal relations to make explicit the hidden factors of influence. We more specifically focus on the consequences of system evolution with respect to QoS properties: using causal relations, we aim at predicting the possible overhead caused by an evolution. This paper shows through an example of Business Process how our evolution analysis helps to understand\u00a0\u2026", "num_citations": "1\n", "authors": ["118"]}
{"title": "D\u00e9fis pour le G\u00e9nie de la Programmation et du Logiciel GDR CNRS GPL\n", "abstract": " Ce document a \u00e9t\u00e9 \u00e9labor\u00e9 dans le cadre du groupement de recherche CNRS \" G\u00e9nie de la Programmation et du Logiciel \" (GDR GPL) sous la direction de Laurence Duchien et de Yves Ledru, avec la collaboration des groupes de travail du GDR. Apr\u00e8s un r\u00e9sum\u00e9 synth\u00e9tique des diff\u00e9rentes contributions, ce document pr\u00e9sente des probl\u00e9matiques qui ont \u00e9t\u00e9 identifi\u00e9es comme particuli\u00e8rement importantes dans les ann\u00e9es qui viennent dans les domaines du g\u00e9nie logiciel et de la programmation. Sans faire un recensement exhaustif, le rep\u00e9rage effectu\u00e9 par les groupes de travail du GDR GPL contribue \u00e0 une cartographie du positionnement fran\u00e7ais et sugg\u00e8re plusieurs th\u00e9matiques strat\u00e9giques dans ces domaines.", "num_citations": "1\n", "authors": ["118"]}
{"title": "Num\u00e9ro sp\u00e9cial TSI-Ing\u00e9nierie Dirig\u00e9e par les Mod\u00e8les\n", "abstract": " L'ing\u00e9nierie dirig\u00e9e par les mod\u00e8les est devenue en quelques ann\u00e9es une approche pour le d\u00e9veloppement logiciel de qualit\u00e9, pris\u00e9e \u00e0 la fois par les industriels et les acad\u00e9miques. Cette approche, plus abstraite que l'approche par programmation, permet de se concentrer sur les concepts ind\u00e9pendamment des plates-formes, de se focaliser sur une ou plusieurs pr\u00e9occupations, de les abstraire et de les \u00e9tudier en vue d'obtenir un syst\u00e8me complet par composition et par transformation. La notion de mod\u00e8le est au coeur du dispositif, il sert \u00e0 mieux comprendre et \u00e0 raisonner sur le syst\u00e8me que l'on construit, mais aussi \u00e0 \u00eatre en position de transformer des mod\u00e8les vers d'autres mod\u00e8les abstraits ou encore vers des mod\u00e8les d'ex\u00e9cution concrets. De nombreux outillages et propositions \u00e9mergent. L'ing\u00e9nierie du logiciel se voit alors proposer de nouvelles m\u00e9thodes, de nouveaux concepts et de nouveaux outils pour faciliter la production de logiciels. L'ing\u00e9nierie dirig\u00e9e par les mod\u00e8les se pr\u00e9sente ainsi comme un support au d\u00e9veloppement logiciel de la mod\u00e9lisation dans des domaines sp\u00e9cifiques \u00e0 la mise en oeuvre au niveau des plates-formes d'ex\u00e9cution par l'exploitation des m\u00e9canismes de transformation.", "num_citations": "1\n", "authors": ["118"]}
{"title": "Ing\u00e9nierie dirig\u00e9e par les mod\u00e8les\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "1\n", "authors": ["118"]}
{"title": "Une aide \u00e0 la r\u00e9alisation des \u00e9volutions logicielles gr\u00e2ce aux mod\u00e8les de tra\u00e7abilit\u00e9 des fonctionnalit\u00e9s\n", "abstract": " Les applications d\u00e9velopp\u00e9es en entreprise subissent des \u00e9volutions logicielles. La r\u00e9alisation efficace de ces \u00e9volutions logicielles est devenue un enjeu crucial. Pour cela, nous exploitons dans cet article la notion de la tra\u00e7abilit\u00e9 des fonctionnalit\u00e9s qui suit l'\u00e9laboration des fonctionnalit\u00e9s d'une application. Cette notion est captur\u00e9e par un mod\u00e8le. Ce papier stabilise la d\u00e9finition de la tra\u00e7abilit\u00e9 des fonctionnalit\u00e9s en proposant une extension UML pour sa mod\u00e9lisation ainsi qu'une m\u00e9thode de d\u00e9finition. De plus, nous pr\u00e9sentons son utilisation sur une application, les apports et les limitations lors de la r\u00e9alisation d'une \u00e9volution logicielle.", "num_citations": "1\n", "authors": ["118"]}
{"title": "A generic framework for integrating new functionnalities into software architectures\n", "abstract": " Integrating new functionalities into a software architecture is necessary when the application must evolve to cope with new context and user requirements. The architect has thus to manually modify the architecture description, which is often tedious and error prone. In this paper, we propose FIESTA, a generic framework for automatically integrating new functionalities into an architecture description. Our approach is inspired by TranSAT, an integration framework. However, TranSAT is dedicated to a specific architecture description language (ADL) while our approach is ADL-independent. To do so, we have performed a domain analysis, studying for many ADLs how to integrate new functionalities. Based on our domain analysis, we have defined a generic ADL model to manipulate and reason about architectural elements that are involved in integration. Furthermore, we have defined high-level abstractions to describe different kinds of integration. Finally, we have developed a generic integration engine.", "num_citations": "1\n", "authors": ["118"]}
{"title": "Concrete communication abstractions of the next 701 distributed object systems\n", "abstract": " As applications become increasingly distributed and networks provide more and more connection facilities, applications require more and more interconnections, thus communication takes a central part of modern systems. Hence, since large applications parts have been underlined like databases systems or graphical user interface, the goal is to wonder, if we can say the same for the communication part of applications.", "num_citations": "1\n", "authors": ["118"]}
{"title": "Network Membership: a partition model for reliable mobile communication\n", "abstract": " We give a formal specification of a new model called Network Membership for reliable mobile communication in asynchronous distributed systems. Our approach is new in the sense that the Network Membership service does not have any join or leave procedures. We let the system flow, views are not forced and are installed with stability. The model is less restrictive than others since no consensus is required. The Network Membership allows multiple partitions to operate simultaneously and provides connectivity feedback. We have built on top of this Network Membership service an efficient reliable broadcast service that is resistant to network partitions. The protocol ensures that all recipients eventually receive the message even if a receiver has been partitioned away at any time. We show how we use an unreliable channel detector in conjunction with data forwarding and stability to achieve this goal.", "num_citations": "1\n", "authors": ["118"]}
{"title": "Co-operative Abstract Data Type: A Stack Exemple\n", "abstract": " Archive ouverte HAL - Co-operative Abstract Data Type: A Stack Exemple Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01124561, version 1 Communication dans un congr\u00e8s Co-operative Abstract Data Type: A Stack Exemple Pascale Champagnoux 1 Laurence Duchien 1 Daniel Enselme 1 G\u00e9rard Florin 1 D\u00e9tails 1 CEDRIC - Centre d'\u00e9tudes et de recherche en informatique et communications Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Informatique [cs] / Liste ://.\u2026", "num_citations": "1\n", "authors": ["118"]}
{"title": "Cooperative abstract data types\n", "abstract": " Archive ouverte HAL - Cooperative Abstract Data Types Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01124564, version 1 Communication dans un congr\u00e8s Cooperative Abstract Data Types Pascale Champagnoux 1 Laurence Duchien 1 Daniel Enselme 1 G\u00e9rard Florin 1 D\u00e9tails 1 CEDRIC - Centre d'\u00e9tudes et de recherche en informatique et communications Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Informatique [cs] / Syst\u00e8mes embarqu\u00e9s Liste compl\u00e8te des :/\u2026", "num_citations": "1\n", "authors": ["118"]}
{"title": "From the specification to the debug: a distributed application trace construction and its use in a distributed oo environment\n", "abstract": " From the Specification to the Debug: a Distributed Application Trace Construction and its Use in a Distributed OO Environment - Inria Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support HAL-Inria Les publications, logiciels... des scientifiques Inria Accueil D\u00e9poser Consulter tout HAL par date de publication/r\u00e9daction par domaine par type de publication par collection arXiv les derniers d\u00e9p\u00f4ts Publications Inria Recherche Services HalTools : cr\u00e9er sa page web Haltools : export RAWEB X2Hal : import par lot Consulter les structures de recherche connues de HAL Documentation Aide en ligne de HAL V3 Derni\u00e8res \u00e9volutions de HAL V3 Documentation API HAL Ajouter des vignettes Aide en ligne Haltools -'[\u2026", "num_citations": "1\n", "authors": ["118"]}
{"title": "Design of an integrated X400 filestore\n", "abstract": " Design of an integrated X400 filestore | Proceedings of the IFIP TC6/WG6.5 international conference on Upper layer protocols, architectures and applications ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsULPAA '92Design of an integrated X400 filestore ARTICLE Design of an integrated X400 filestore Share on Authors: Laurence Duchien profile image Laurence Duchien View Profile , Val\u00e9rie Gay profile image Val\u00e9rie Gay View Profile , Eric Horlait profile image Eric Horlait View Profile Authors Info & Affiliations Publication: ULPAA '92: Proceedings of the IFIP TC6/WG6.international conference on Upper layer protocols, \u20130\u2026", "num_citations": "1\n", "authors": ["118"]}