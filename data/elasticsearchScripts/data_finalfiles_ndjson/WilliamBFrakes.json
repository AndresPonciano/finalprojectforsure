{"title": "Information retrieval: data structures and algorithms\n", "abstract": " The area of text analysis, search, and retrieval has taken on increasing importance in recent years, and the field is now of interest to large communities in science and in the humanities. The need for a volume covering the major information retrieval algorithms has been apparent for many years, and the authors and editors of this book ought to be congratulated for devoting much time and effort to this important area. This book consists of separate chapters by some 20 different well-qualified authors, and it covers many of the more important information retrieval algorithms, including methods of file organization, file search and access, and query processing. The book has a practical outlook, and it should be of substantial help to people interested in information retrieval applications. Some of the chapters provide a reasonable overview of the areas they cover as well as a decent bibliography. Unhappily, as is true of\u00a0\u2026", "num_citations": "3433\n", "authors": ["2181"]}
{"title": "Software reuse research: Status and future\n", "abstract": " This paper briefly summarizes software reuse research, discusses major research contributions and unsolved problems, provides pointers to key publications, and introduces four papers selected from The Eighth International Conference on Software Reuse (ICSR8).", "num_citations": "1000\n", "authors": ["2181"]}
{"title": "Software reuse: metrics and models\n", "abstract": " As organizations implement systematic software reuse programs to improve productivity and quality, they must be able to measure their progress and identify the most effective reuse strategies. This is done with reuse metrics and models. In this article we survey metrics and models of software reuse and reusability, and provide a classification structure that will help users select them. Six types of metrics and models are reviewed: cost-benefit models, maturity assessment models, amount of reuse metrics, failure modes models, reusability assessment models, and reuse library metrics.", "num_citations": "544\n", "authors": ["2181"]}
{"title": "Stemming Algorithms.\n", "abstract": " This chapter describes stemming algorithms-programs that relate morphologically similar indexing and search terms. Stemming is used to improve retrieval effectiveness and to reduce the size of indexing files. Several approaches to stemming are described\u2014table lookup, affix removal, successor variety, and n-gram. Empirical studies of stemming are summarized. The Porter stemmer is described in detail, and a full implementation in C is presented.", "num_citations": "507\n", "authors": ["2181"]}
{"title": "An empirical study of representation methods for reusable software components\n", "abstract": " An empirical study of methods for representing reusable software components is described. Thirty-five subjects searched for reusable components in a database of UNIX tools using four different representation methods: attribute-value, enumerated, faceted, and keyword. The study used Proteus, a reuse library system that supports multiple representation methods. Searching effectiveness was measured with recall, precision, and overlap. Search time for the four methods was also compared. Subjects rated the methods in terms of preference and helpfulness in understanding components. Some principles for constructing reuse libraries. Based on the results of this study, are discussed.< >", "num_citations": "399\n", "authors": ["2181"]}
{"title": "Success factors of systematic reuse\n", "abstract": " Systematic software reuse is a paradigm shift in software engineering from building single systems to building families of related systems. The goal of software reuse research is to discover systematic procedures for engineering new systems from existing assets. Implementing systematic reuse is risky. Not doing it is also risky. Trying systematic reuse unsuccessfully can cost precious time and resources and may make management sceptical of trying it again. But if your competitors do it successfully and you do not, you may lose market share and possibly an entire market. There is no cookbook solution-each organization must analyze its own needs, implement reuse measurements, define the key benefits it expects, identify and remove impediments, and manage risk. Reliable data on how much this costs and the benefits an organization will derive are insufficient. The article addresses issues from management\u00a0\u2026", "num_citations": "352\n", "authors": ["2181"]}
{"title": "Sixteen questions about software reuse\n", "abstract": " Software reuse is the use of existing software knowledge or artifacts to build new software artifacts. Reuse is sometimes confused with porting. The two are distinguished as follows: Reuse is using an asset in different systems; porting is moving a system across environments or platforms. For example, in Figure 1 a component in System A is shown used again in System B; this is an example of reuse. System A, developed for Environment 1, is shown moved into Environment 2; this is an example of porting.", "num_citations": "263\n", "authors": ["2181"]}
{"title": "DARE: Domain analysis and reuse environment\n", "abstract": " DARE (Domain Analysis and Reuse Environment) is a CASE tool that supports domain analysis \u2013 the activity of identifying and documenting the commonalities and variabilities in related software systems. DARE supports the capture of domain information from experts, documents, and code in a domain. Captured domain information is stored in a domain book that will typically contain a generic architecture for the domain and domain-;specific reusable components.", "num_citations": "229\n", "authors": ["2181"]}
{"title": "Software reuse through information retrieval\n", "abstract": " There is widespread need for safe, verifiable, efficient, and reliable software that can be delivered in a timely manner. Software reuse can make a valuable contrbution toward this goal by increasing programmer productivity and software quality. Unfortunately, the amount of software reuse currently done is quite small. DeMarco [1] estimates that in the average software development environment only about five percent of code is reused.", "num_citations": "196\n", "authors": ["2181"]}
{"title": "A study of the overlap among document representations\n", "abstract": " Most previous investigations comparing the performance of different representations have used recall and precision as performance measures. However, there is evidence to show that these measures are insensitive to an important difference between representations. To explain, two representations may perform similarly on these measures, while retrieving very different sets of documents. Equivalence of representations should be decided on the basis of similarity in performance and similarity in the documents retrieved. This study compared the performance of four representations in the PsycAbs database. In addition, overlap between retrieved sets was also computed where overlap is the proportion of retrieved documents that are the same for pairs of document representations. Results indicate that for any two representations considered, performance values differed slightly while overlap scores were also low\u00a0\u2026", "num_citations": "181\n", "authors": ["2181"]}
{"title": "Strength and similarity of affix removal stemming algorithms\n", "abstract": " This study evaluated the strength of, and similarity among, four affix removal stemming algorithms. Strength and similarity were evaluated in different ways, including new metrics based on the Hamming distance measure. Data was collected on stemmer outputs for a list of 49,656 English words derived from the UNIX spelling dictionary and the Moby corpus. Conclusions about the relative strength and similarity of the four stemming algorithms are reported.", "num_citations": "160\n", "authors": ["2181"]}
{"title": "Representing reusable software\n", "abstract": " Many methods for representing software components for reuse have been proposed. These include traditional library and information science methods, knowledge-based methods, and hypertext. The paper surveys and categorizes these methods, and discusses systems in which they have been used. A definition and conceptual framework of software reuse representations is proposed that relates these methods to each other and to the software life-cycle.", "num_citations": "151\n", "authors": ["2181"]}
{"title": "Quality improvement using a software reuse failure modes model\n", "abstract": " The paper presents a failure modes model of parts-based software reuse, and shows how this model can be used to evaluate and improve software reuse processes. The model and the technique are illustrated using survey data about software reuse gathered from 113 people from 29 organizations.", "num_citations": "121\n", "authors": ["2181"]}
{"title": "Introduction to information storage and retrieval systems\n", "abstract": " This chapter introduces and defines basic IR concepts, and presents a domain model of IR systems that describes their similarities and differences. The domain model is used to introduce and relate the chapters that follow. The relationship of IR systems to other information systems is dicussed, as is the evaluation of IR systems.", "num_citations": "106\n", "authors": ["2181"]}
{"title": "An information system for software reuse\n", "abstract": " An information system for software reuse | Software reuse: emerging technology ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware reuse: emerging technologyAn information system for software reuse chapter An information system for software reuse Share on Authors: William B Frakes profile image WB Frakes View Profile , Brian A. Nejmeh profile image BA Nejmeh View Profile Authors Info & Affiliations Publication: Software reuse: emerging technologyJanuary 1988 Pages 142\u2013151 11citation 0 Downloads Metrics Total Citations11 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert \u2026", "num_citations": "102\n", "authors": ["2181"]}
{"title": "An industrial study of reuse, quality, and productivity\n", "abstract": " The relationship between amount of reuse, quality, and productivity was studied using four sets of C and C++ modules collected from industrial organizations. The data domains are: text retrieval, user interface, distributed repository, medical records. Reuse in this paper is ad hoc, black box, compositional code reuse. The data generally show that more reuse results in higher quality, but are ambiguous regarding the relationship between amount of reuse and productivity.", "num_citations": "95\n", "authors": ["2181"]}
{"title": "The quality approach: is it delivering?\n", "abstract": " Some companies today are reporting increases in software productivity and quality as high as 1,000% using quality approaches pioneered in other indus-tries. The goals of this special section are to offer guidance to those interested in learning about these quality improvement approaches in software development, and to examine the payoff of software quality improvement efforts based on recent experiences. Although the concept of quality is fairly simple,(see sidebar \u201cElements of the Quality Paradigm\u201d), the complex of methods, tools, attitudes, and values involved in providing high-quality products and services is not. Many software professionals have found it difficult to understand and accept approaches like Total", "num_citations": "92\n", "authors": ["2181"]}
{"title": "Software process reuse in an industrial setting\n", "abstract": " The paper describes a method for creating reusable processes and the authors' experience using them in an industrial environment. A notation and process for creating and tailoring reusable processes is described and applied to the building of a 120 process library at PRC Inc. Initial data collected on use of the library indicates large potential payoffs from process reuse such as a 10 to 1 improvement in the time to develop a project specific process.", "num_citations": "64\n", "authors": ["2181"]}
{"title": "Software engineering in the UNIX/C environment\n", "abstract": " Software engineering in the UNIX/C environment | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware engineering in the UNIX/C environment Export Citation Select Citation format Download citation Copy citation Categories Journals Magazines Books Proceedings SIGs Conferences Collections People About About ACM Digital Library Subscription Information Author Guidelines Using ACM Digital Library All Holdings within the ACM Digital Library ACM Computing Classification System Join Join ACM Join SIGs Subscribe to Publications Institutions and Libraries Connect Contact Facebook Twitter Linkedin The \u2026", "num_citations": "64\n", "authors": ["2181"]}
{"title": "Term conflation for information retrieval\n", "abstract": " This paper describes two experiments concerned with term conflation for information retrieval, and the CATALOG retrieval system designed utilizing the results of the experiments. The experiments performed here has as their aim 1) finding a theoretical basis and method for maximizing the effect of conflation, and 2) determining if conflation can be automated with no loss of system performance. Experimental results indicate that, 1. Experienced searchers generally truncate terms at root morpheme boundaries. When searchers do not truncate at root boundaries, the deviations are small. 2. Small deviations from root boundaries do not significantly affect retrieval performance. 3. There is no significant performance difference between automatic conflation and manual conflation carried out by experienced searchers. 4. Based on 3, term conflation can be automated in a retrieval system with no average loss of\u00a0\u2026", "num_citations": "64\n", "authors": ["2181"]}
{"title": "Reuse level metrics\n", "abstract": " Reuse level is an abstract metric that can be applied to any reusable asset. This paper presents extensions to the reuse level metric, defines the metric formally, and discusses an implementation of the abstract metric for C in an enhanced version of the reuse level program.< >", "num_citations": "49\n", "authors": ["2181"]}
{"title": "Software reuse and reengineering\n", "abstract": " Software reuse and reengineering are receiving much attention as enterprises reclaim their tremendous software investment to support software evolution. Reusing assets may help a company evolve with less risk and cost than creating new systems from scratch. Part-based software reuse\u2014the use of parts from previous systems to build new ones\u2014is widely seen as a key technology for improving software flexibility, quality, and productivity. This article discusses approaches for recovering and reusing software assets.", "num_citations": "41\n", "authors": ["2181"]}
{"title": "Software reuse: is it delivering?\n", "abstract": " A panel discussion is presented to examine the evidence, pro and con, that software reuse is delivering. Verifiable and repeatable increases in software quality and productivity in field settings are used as criteria for the success of reuse. Reusability is defined as a technology that can be of significant value to software development and maintenance. A scale to evaluate whether reuse is delivering is outlined. The scale is ordinal, with five being the best possible rating. The three respondents, from Germany, Japan, and the US, discuss how reuse, as defined, is delivering in their parts of the world.<>", "num_citations": "40\n", "authors": ["2181"]}
{"title": "Systematic software reuse: a paradigm shift\n", "abstract": " Software engineering is undergoing a fundamental change, what philosophers of science call a paradigm shift. Such changes are rare. The author discusses a new paradigm, systematic reuse, which is domain focused, based on repeatable processes, and concerned primarily with the reuse of higher level lifecycle artifacts such as requirements, designs, subsystems etc. Systematic reuse shifts from viewing software engineering as a discipline concerned with the construction of single systems, to viewing it at as concerned primarily with constructing related systems that share common parts and vary in certain regular and identifiable ways.<>", "num_citations": "39\n", "authors": ["2181"]}
{"title": "Proteus: a software reuse library system\n", "abstract": " Many methods for representing software components for reuse have been proposed. These include traditional library and information science methods, knowledge based methods, and hypertext. There has been no empirical evaluation of these methods, and consequently there is no data about their relative costs and effectiveness. Proteus is an experimental reuse library system that will be used to help gather such data. Reuse library systems are usually tied to one method---Proteus supports multiple methods.", "num_citations": "39\n", "authors": ["2181"]}
{"title": "DARE-COTS. A domain analysis support tool\n", "abstract": " DARE-COTS (Domain Analysis Research Environment for Commercial Off-The-Shelf software) is a CASE tool that supports domain analysis-the activity of identifying and documenting the commonalities and variabilities in related software systems. DARE-COTS supports the capture of domain information from experts, documents and code in a domain. Captured domain information is stored in a domain book that typically contains a generic architecture for the domain and domain-specific reusable components.", "num_citations": "38\n", "authors": ["2181"]}
{"title": "An empirical framework for software reuse research\n", "abstract": " In this paper, the reuse problem is modeled in terms of independent and dependent variables. Reuse level is the primary dependent variable\u2014a way to measure it is described. Classes of independent variables are identified, and a failure mode model of reuse is proposed as a way of determining which independent variables are most promising for study. Experimental methods are briefly surveyed.", "num_citations": "26\n", "authors": ["2181"]}
{"title": "Modeling reuse across the software life cycle\n", "abstract": " This article reports strong correlations between reuse levels of software products across the life cycle and presents models of reuse levels across the life cycle. These models can be used to estimate reuse levels of one life cycle object given reuse levels of others, or to predict reuse levels of later life cycle objects given reuse levels of earlier ones. The models have been developed from survey data collected from 113 respondents from 29 organizations about their own and their organizations' levels of reuse of life cycle objects. Usage scenarios for the models are presented, as are methods for customizing and improving the models.", "num_citations": "22\n", "authors": ["2181"]}
{"title": "Visualization of reusable software assets\n", "abstract": " This paper presents methods for helping users understand reusable software assets. We present a model and software architecture for visualizing reusable software assets. We described visualizations techniques based on design principles for helping the user understand and compare reusable components.", "num_citations": "19\n", "authors": ["2181"]}
{"title": "A case study of a reusable component collection in the information retrieval domain\n", "abstract": " This paper reports on practical issues in the development, distribution, use, and evolution of a reusable component collection in the domain of information retrieval.", "num_citations": "18\n", "authors": ["2181"]}
{"title": "A study of reusability, complexity, and reuse design principles\n", "abstract": " A study is reported on the relationship of complexity and reuse design principles with the reusability of code components. Reusability of a component is measured as the ease of reuse as perceived by the subjects reusing the component. Thirty-four subjects participated in the study with each subject reusing 5 components, resulting in 170 cases of reuse. The components were randomly assigned to the subjects from a pool of 25 components which were designed and built for reuse. The relationship between the complexity of a component and the ease of reuse was analyzed by a regression analysis. It was observed that the higher the complexity the lower the ease of reuse, but the correlation is not significant. An analysis of the relationship between a set of reuse design principles, used in designing and building the components, and the ease of reuse is also reported. The reuse design principles: well-defined\u00a0\u2026", "num_citations": "17\n", "authors": ["2181"]}
{"title": "Software reuse and reusability metrics and models\n", "abstract": " As organizations implement systematic software reuse programs to improve productivity and quality, they must be able to measure their progress and identify the most effective reuse strategies. This is done with reuse metrics and models. In this paper, we survey metrics and models of software reuse and reusability, and provide a classification structure that will help users select them. Six types of metrics and models are reviewed: cost-benefit models, maturity assessment models, amount of reuse metrics, failure modes models, reusability assessment models, and reuse library metrics.", "num_citations": "17\n", "authors": ["2181"]}
{"title": "Representation methods for software reuse\n", "abstract": " Many methods for representing software components for reuse have been proposed. These include traditional library science methods, knowledge based methods, and hypertext. In this paper, we survey and categorize these methods, and discuss systems in which they have been used.", "num_citations": "15\n", "authors": ["2181"]}
{"title": "Software Reuse: Advances in Software Reusability: 6th International Conference, ICSR-6 Vienna, Austria, June 27-29, 2000 Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 6th International Conference on Software Reuse, ICSR-6, held in Vienna, Austria, in June 2000. The 26 revised full papers presented were carefully reviewed and selected from numerous submissions. The book is divided into topical sections on generative reuse and formal description languages, object-oriented methods, product line architectures, requirements reuse and business modeling, components and libraries, and design patterns.", "num_citations": "11\n", "authors": ["2181"]}
{"title": "A study of COTS integration projects: product characteristics, organization, and life cycle models\n", "abstract": " We present a descriptive and exploratory study of factors that can affect the success of COTS-based systems. Based on a review of the literature and industrial experience, the choice of life cycle model and the amount of glueware required were hypothesized as the main factors in predicting project success. In this study we examined the relationship between different life cycle models and COTS integration project success. Two life cycle models were studied: the sequential model and the iterative model. Seven subjects from six industrial organizations responded to a survey providing data on 23 COTS integration projects. While there was variability between iterative and sequential projects on a variety of organizational and product factors, little difference was found between the life cycle models on the success criteria of projects (ie being on time, meeting requirements and being within budget). We found that projects\u00a0\u2026", "num_citations": "9\n", "authors": ["2181"]}
{"title": "Teaching mineral-identification skills using an expert system computer program incorporating digitized video images\n", "abstract": " The similarity of mineral classification keys to decision trees prompted us to develop an expert system (MINID) for the purpose of teaching novices mineral identification skills. MINID represents an advance over other computer packages for mineral identification because: 1) its knowledge base is separate from the program that acts on it, making it easy for a non-programmer to modify and add to the knowledge base, 2) users can ask for additional information concerning the questions posed and the reasoning used by the program, and 3) explanations and answers appear as text and high quality video images. Physical geology students preferred MINID with pictures over two other mineral identification aids (classification key and MINID without pictures). This is probably because the images enhanced their ability to recognize minerals. Students also reported that both versions of the MINID program forced them to\u00a0\u2026", "num_citations": "9\n", "authors": ["2181"]}
{"title": "Term conflation for information retrieval\n", "abstract": " One of the fundamental assumptions underlying the design of information retrieval systems is that documents represented by the same terms that are used in a query will be relevant to the query. Simple matching of raw terms from queries and documents will, however, fail to relate variant forms of the same term such as singular and plural. In order to solve this problem, a number of conflation methods for reducing term variants to a common form have been proposed.", "num_citations": "8\n", "authors": ["2181"]}
{"title": "A case study of a reusable component collection\n", "abstract": " Software reuse is the use of existing software knowledge or artifacts to build new software. There are many types of software reuse (W. Frakes and C. Terry, 1996). The reuse described in the paper is ad-hoc, black box, compositional, code reuse. Ad hoc means that the reuse is not part of a repeatable mandated organizational process. The paper is concerned with code from a book on data structures and algorithms for information retrieval (IR) systems (W. Frakes and R. Baeza-Yates, 1992). Information retrieval systems retrieve textual documents from a database in response to queries submitted to the system by users.", "num_citations": "7\n", "authors": ["2181"]}
{"title": "An empirical comparison of methods for reengineering procedural software systems to object-oriented systems\n", "abstract": " This study empirically compared two methods for reengineering a procedural system to an object-oriented system. Our hypothesis was that it is possible to support this process with a repeatable method. The first method was manual and was used as a baseline for evaluating the second method, which was repeatable and based on analysis of procedure coupling. The repeatable method was found to be effective for identifying objects. It produced code that was much smaller, more efficient, and passed more regression tests than the manual method. Analysis of object-oriented metrics indicated both simpler code and less variability among classes. Particularly striking was the order of magnitude difference between the average cohesion metric (LCOM) for the manual and repeatable methods.", "num_citations": "6\n", "authors": ["2181"]}
{"title": "A computer implementation of the separate maintenance model for complex\u2010system reliability\n", "abstract": " Reliability modeling and quantitative reliability prediction for all but the simplest system architectures demands intensive computer support for the numerical computations required. Many commercial and academic reliability modeling software packages provide support for the Markov\u2010chain state diagram system reliability model. Other system reliability models, such as those offering non\u2010exponential life and/or repair time distributions, transient analysis, or other special handling, may sometimes be desirable. Users have fewer choices for software supporting these options. This paper describes SUPER, a software package developed at Bell Laboratories, which provides computational support for the separate maintenance model as well as for some other useful system reliability descriptions. SUPER is an acronym for System Used for Prediction and Evaluation of Reliability. The paper also includes a brief tutorial to\u00a0\u2026", "num_citations": "5\n", "authors": ["2181"]}
{"title": "Overview of Panel: Linking Domain Analysis and Domain Implementation\n", "abstract": " To achieve systematic, domain based, reuse, the outputs of domain analysis (DA) must be linked to the inputs of domain implementation (DI). The implementation can be parts based or generator based, the latter generally being a more powerful but more difficult technology. There is a need to specify the outputs of domain analysis, the inputs required to build a generator, and a clear mapping between them. This panel will discuss key issues of this topic, including the linking of domain analysis outputs to the specifications used by meta-generators. The panel will address the following questions:", "num_citations": "5\n", "authors": ["2181"]}
{"title": "Information and misinformation: An investigation of the notions of information, misinformation, informing, and misinforming\n", "abstract": " This text is divided into two parts; the first of which discusses the topic, online searching and its background. Here we find information that tells us the brief history of online, and a description of the search process. The reader is told about the producers and vendors as well as the management consideration involved in operating a search service. The second part gives details on basic searching procedures for the major vendors: DIALOG, SDC and BRS, as well as the most frequently searched producers of public-oriented systems of CompuServe, The Source, and Dow Jones Retrieval Service. In this section we are also given information about downloading onto a microcomputer. The section and the volume ends with a chapter comparing the various services and pointing out their similarities and differences.", "num_citations": "5\n", "authors": ["2181"]}
{"title": "Reuse design principles\n", "abstract": " Though many reuse design principles have been proposed, there is no generally accepted list which are independent of programming language and domain. This paper provides a generic list of reuse design principles for component based software development based on a preliminary analysis of the literature of software reuse and reuse design over the past few decades. Such a list is new because the reuse design principles presented in the past were specific to programming languages, domains, or programming paradigms. These principles can be a guideline for designing and building reusable components and are language and domain independent.", "num_citations": "4\n", "authors": ["2181"]}
{"title": "A comparison of database fault detection capabilities using mutation testing\n", "abstract": " Mutation testing involves systematically generating and introducing faults into an application to improve testing. A quasi-experimental study is reported comparing the fault-detection capabilities of real-world database application test suites to those of an SQL vendor test suite (NIST SQL) based on mutation scores. The higher the mutation score the more successful the test suite will be at detecting faults. The SQLMutation tool was used to generate query mutants from beginner-level sample schemas obtained from three popular real-world database test suite vendors--MySQL, SQL Server, and Oracle. Four SQLMutation operators were applied to both real-world and NIST SQL vendor compliance test suites-SQL Clause (SC), Operator Replacement (OR), NULL (NL) and Identifier Replacement (IR). Two mutation operators, SC and NL generated significantly lower mutation scores in real-world test suites than for those in\u00a0\u2026", "num_citations": "4\n", "authors": ["2181"]}
{"title": "Spillover-partitioning call admission control for revenue optimization with QoS guarantees for multiple service classes in mobile wireless networks\n", "abstract": " We propose and analyze spillover-partitioning call admission control (CAC) for servicing multiple service classes in mobile wireless networks for revenue optimization with quality of service (QoS) guarantees. We evaluate the performance of spillover-partitioning CAC in terms of execution speed and optimal revenue obtainable by comparing it with existing CAC algorithms, including partitioning, threshold, and partitioning-threshold hybrid admission control algorithms. We also investigate fast spillover-partitioning CAC which effectively trades off solution optimality for solution efficiency. We demonstrate through test cases that spillover-partitioning CAC outperforms existing CAC algorithms for revenue optimization with QoS guarantees in both solution optimality and solution efficiency for serving multiple QoS service classes in wireless networks.", "num_citations": "4\n", "authors": ["2181"]}
{"title": "Experimental evaluation of a test coverage analyzer for C and C++\n", "abstract": " Experiments tested the effectiveness of nvcc, a test coverage analyzer for C and C + +. Subjects were professional programmers and systems analysts at AT&T Bell Laboratories. Results indicate that using nvcc will result in a higher level of test coverage for a given testing time, allow testers to reach a given coverage level at least 40% faster, and reduce variability in level of coverage reached by different testers. Use of nvcc did not significantly increase the number of bugs found. All subjects surveyed said they found nvcc to be a useful tool. Results also suggest that the effectiveness of nvcc may be related to users' software engineering experience.", "num_citations": "4\n", "authors": ["2181"]}
{"title": "CEST: An Expert System Function Library and Workbench for Unix\u00ae System/C Language\n", "abstract": " Integrating expert system components into production software can be difficult, because environments for developing expert systems typically are not compatible with traditional software\u2010engineering technology. To deal with this problem, we are developing CEST, a C\u2010language expert system toolset. It is a library of inference engines\u2014implemented as C functions that can be called from C programs\u2014and a workbench of knowledge\u2010engineering support tools. CEST allows easy integration of expert system components into C\u2010based software systems, and provides knowledge\u2010engineering support tools analogous to traditional software\u2010engineering support tools. The first tool written for CEST is AVIEN, a backward\u2010chaining attribute\u2010value inference engine. It has been widely distributed within AT&T, and has been used to build both stand\u2010alone expert systems and C\u2010based hybrid systems. In particular, the Quality\u00a0\u2026", "num_citations": "4\n", "authors": ["2181"]}
{"title": "LATTIS: a corporate library and information system for the unix environment\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "4\n", "authors": ["2181"]}
{"title": "A Comparison of Methods for Automatic Term Extraction for Domain Analysis\n", "abstract": " Fourteen word frequency metrics were tested to evaluate their effectiveness in identifying vocabulary in a domain. Fifteen domain-engineering projects were examined to measure how closely the vocabularies selected by the fourteen word frequency metrics were to the vocabularies produced by domain engineers. Stemming and stopword removal were also evaluated to measure their impact on selecting proper vocabulary terms. The results of the experiment show that stemming and stopword removal do improve performance and that term frequency is a valuable contributor to performance. Most word frequency metrics gave similar results. A few of the metrics did poorly compared to the others.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "A case study of using domain engineering for the conflation algorithms domain\n", "abstract": " In this study we used domain engineering as a method for gaining deeper formal understanding of a class of algorithms. Specifically, we analyzed 6 stemming algorithms from 4 different sub-domains of the conflation algorithms domain and developed formal domain models and generators based on these models. The application generator produces source code for not only affix removal but also successor variety, table lookup, and n-gram stemmers. The performance of the generated stemmers was compared with the stemmers developed manually in terms of stem similarity, source, and executable sizes, and development and execution times. Five of the stemmers generated by the application generator produced more than 99.9% identical stems with the manually developed stemmers. Some of the generated stemmers were as efficient as their manual equivalents and some were not.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "SAM: Simple API for object-oriented code metrics\n", "abstract": " This paper introduces the Simple API for Object-Oriented Code Metrics or SAM. SAM has two distinct advantages over current application generators for metrics. First, SAM can collect a much larger set of metrics since it maintains context during metrics analysis. Second, SAM is completely language independent since it specifies the types of events a parser must generate, but not how to generate those events. Through examples, we will demonstrate how our API allows us to collect metrics not possible with application generators. We will also demonstrate how SAM can reduce the lines of code per metric by up to 90 percent when measured against some of today\u2019s most popular standalone tools.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "Foundational Issues in Software Reuse and Reliability\n", "abstract": " This paper examines the question of whether increased software reuse can improve software reliability. One conclusion is that the assumed positive relationship between them depends on three different hypotheses, which this paper clarifies and makes testable. The intuitive concept of reusable and equivalent one-use components is clarified through the identification of attributes for comparing them, and showing how these attributes affect reliability. By applying measurement theory and using simple programs, the paper shows how various reliability models can be applied to collect data for one-use and reusable programs.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "Case study of a method for reengineering procedural systems into OO systems\n", "abstract": " This study evaluates a method for reengineering a procedural system to an object-oriented system. Relationships between functions in the procedural system were identified using various coupling metrics. While the coupling metrics used for analysis were helpful in identifying candidate objects, domain expert analysis of the candidate objects was required. The time taken at each step in the process was captured to help determine the effectiveness of the method. Overall the process was found to be effective for identifying objects.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "DARE-Web: Domain Analysis in a Web Environment\n", "abstract": " DARE-Web is a Web-based environment that supports domain analysis-the activity of identifying and documenting the commonalities and variabilities in related software systems. DARE-Web supports the capture of domain information from experts, documents, and code in a domain.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "Report on Quasi-Experiment for Evaluating SEES\n", "abstract": " The purpose of this document is to describe the design and execution of the quasi-experiment conducted in the Department of Computer Science, Virginia Tech, in accordance with the procedures described in the document,\" An Experimental Design for Evaluating SEES\" prepared for NASA under contract NASI-19610, Task 17.(Hereafter that report is called the general design document.) The quasi-experiment serves three important purposes. First, the quasi-experiment is the proof of concept of the general experiment design. It shows that the procedures defined in the general experiment design can be implemented. Second, provides details for setting up a true experiment: identifying the research hypothesis, designing the investigation, selecting various variables, procedures, and controls, measuring the variables, and evaluating the results. Third, any insights revealed during the course of the quasi-experiment can be incorporated in the costly true experiment, thus providing a cost-effective experimental methodology. This report contains sufficient information so that the quasi-experiment can be replicated at an appropriate level of abstraction. We also document and interpret all the results of the quasi-experiment.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "Software process reuse\n", "abstract": " This paper describes an in-progress study of software process reuse and reusability--specifically how to pragmatically and systematically standardize and replicate project-specific processes in an industrial software environment. Our working hypothesis is that by using domain engineering techniques, software reuse principles, process architecture research, and process modeling mechanisms, project-specific processes can be abstracted into reusable components that can be used by process engineers.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "A Graduate Course on Software Reuse, Domain Analysis, and Re-engineering\n", "abstract": " Reuse education has long been recognized as important for the successful implementation of reuse. Yet reuse has traditionally not been taught in universities. In a recent survey, we found that only 13% of respondents said they had learned about reuse in school 1]. A recent workshop addressed this issue, and published preliminary suggestions for reuse education for various populations (upper managers, line managers, technical sta, etc.), in di erent areas (industry, government, academia) 2].I participated in this workshop by leading the group on education for domain analysis. One of the points made by the group was that because of the immaturity of the reuse area, seminar courses were probably most appropriate for university education in reuse. In the Spring semester of 1993, I taught a graduate level seminar course on software reuse, domain analysis, and reengineering at Virginia Tech. This position paper\u00a0\u2026", "num_citations": "3\n", "authors": ["2181"]}
{"title": "Using expert-system components to add intelligent help and guidance to software tools\n", "abstract": " The paper discusses the use of expert-system components to add intelligent help and guidance to software tools. The discussion focuses on the development of expert systems to enhance Star and Super, reliability analysis tools developed at AT&T Bell Laboratories. The expert components were developed using Avien, an expert-system development tool that allows easy integration of expert-system components into C-based software.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "An approach to integrating expert system components into production software\n", "abstract": " Expert systems techniques are a powerful technology with many potential applications such as the enhancement of software tools. It can, however, be difficult to incorporate expert systems techniques into production software. We are attempting to solve this problem using CEST (C expert systems tools). CEST will consist of (1) a library of inference engines implemented as C functions and callable from C programs, and (2) a workbench of knowledge engineering support tools for building, analyzing, and maintaining knowledge bases. The first tool in CEST is AVIEN a backwards chaining inference engine implemented a set of C functions.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "A Software Engineering Methodology for the Unix/C Environment\n", "abstract": " The need for good software engineering has grown increasingly important, because the largest part of system costs are now due to software development and maintenance rather than hardware!\". Unfortunately, as many computer scientists who study software quality have pointed out, the current state of the art is poor\" \u00ba.In response to this problem, a large amount of work has focused on the development of better principles, tools, and techniques for producing software. When such principles, tools, and techniques are specified, they are called a methodology. Software methodologies, such as the one discussed here, can go a long way towards alleviating the software quality problem.", "num_citations": "3\n", "authors": ["2181"]}
{"title": "Performance Analysis of Spillover-Partitioning Call Admission Control in Mobile Wireless Networks\n", "abstract": " We propose and analyze spillover-partitioning call admission control (CAC) for servicing multiple service classes in mobile wireless networks for revenue optimization with quality of service (QoS) guarantees. We evaluate the performance of spillover-partitioning CAC in terms of execution time and optimal revenue obtainable by comparing it with existing CAC algorithms, including partitioning, threshold, and partitioning-threshold hybrid admission control algorithms. We also investigate fast spillover-partitioning CAC that applies a greedy heuristic search method to find a near optimal solution fast to effectively trade off solution quality for solution efficiency. The solution found by spillover-partitioning CAC is evaluated by an analytical model developed in the paper. We demonstrate through test cases that spillover-partitioning CAC outperforms existing CAC algorithms for revenue optimization with QoS\u00a0\u2026", "num_citations": "2\n", "authors": ["2181"]}
{"title": "DAREonline: A Web-Based Domain Engineering Tool\n", "abstract": " DAREonline is a web-based tool for domain engineering. It supports the DARE framework in a centralized platform-independent environment. Our approach leverages concepts of Service-Oriented Architecture (SOA) to aggregate data and functionality from diverse sources that can be helpful in domain engineering. In this paper, we describe DAREonline\u2019s1 architecture and implementation, and its use in a graduate course on software design and quality.\u00a0 Initial results indicate that DAREonline can be a valuable resource for domain analysts and can achieve acceptance at similar levels to DARE COTS.", "num_citations": "2\n", "authors": ["2181"]}
{"title": "Reuse ratio metrics RL and RF\n", "abstract": " In this demo we will show various implementations of RL (reuse level) and RF (reuse frequency) tools for measuring the amount of reuse in software. We will also discuss how these metrics have been used in several studies.", "num_citations": "2\n", "authors": ["2181"]}
{"title": "A Case Study of Using Domain Analysis for the Conflation Algorithms Domain\n", "abstract": " This paper documents the domain engineering process for much of the conflation algorithms domain. Empirical data on the process and products of domain engineering were collected. Six conflation algorithms of four different types: three affix removal, one successor variety, one table lookup, and one n-gram were analyzed. Products of the analysis include a generic architecture, reusable components, a little language and an application generator that extends the scope of the domain analysis beyond previous generators. The application generator produces source code for not only affix removal type but also successor variety, table lookup, and n-gram stemmers. The performance of the stemmers generated automatically was compared with the stemmers developed manually in terms of stem similarity, source and executable sizes, and development and execution times. All five stemmers generated by the application generator produced more than 99.9% identical stems with the manually developed stemmers. Some of the generated stemmers were as efficient as their manual equivalents and some were not.", "num_citations": "2\n", "authors": ["2181"]}
{"title": "Practical software reuse\n", "abstract": " The article argues that software reuse is practical and ever evolving to accommodate programming with higher level assets and to allow more direct modeling of domains. It is concluded that there is a lot of industrial data that shows that reuse can significantly improve software quality and productivity (W. Lim, 1998). Reuse is part of the process by which programming is done with larger and larger units and with more domain specificity.", "num_citations": "2\n", "authors": ["2181"]}
{"title": "The future of systematic software reuse\n", "abstract": " Summary form only. Systematic reuse represents a paradigm shift for software engineering. Systematic reuse will have a major impact on software engineering as a discipline, and on the software business as a whole. We speculate on where software reuse is headed. Systematic reuse will play a key role in the software industry in the next ten years and beyond. Companies that do the best job of engineering a domain will have a tremendous advantage over their competition and will likely come to dominate markets based on the domain. Reusable assets for a domain may well, then, be treated as corporate trade secrets. If so, it is unlikely that companies will share them. At the same time, a reuse industry that crosses organizational boundaries is rapidly developing. There is already a large market for reusable components, application generators and generator support tools, consulting, books and reports, and other\u00a0\u2026", "num_citations": "2\n", "authors": ["2181"]}
{"title": "Information retrieval and software reuse\n", "abstract": " Software reuse is widely believed to be the most promising technology for improving software quality and productivity. There are many technical and non-technical problems to be solved, however, before widespread reuse of software lifecycle objects becomes a reality. One class of problem concerns the classification, storage, and retrieval of reusable components. Panel members will discuss these problems and some approaches to solving them.", "num_citations": "2\n", "authors": ["2181"]}
{"title": "Using Program Profilers for Reusable Component Optimization and Indexing\n", "abstract": " This paper describes an exploratory study of how software profilers can be used to help design, evaluate, and index reusable components. Testing of a program using a sampling profiler, gprof, showed that longer execution times are needed to obtain reliable measures of execution speed. We discuss how to use profiling data for indexing reusable components.", "num_citations": "1\n", "authors": ["2181"]}
{"title": "Computer Support for a Cross-discipline Research Consortium.\n", "abstract": " This paper describes the use of web based and freeware tools for a cross-discipline research consortium to support graduate education. The use of WordPress and Simple Machine Forums as the main environment to provide web support is discussed, as are the use of statistics tools such as R and SAS-JMP. Usage data for these tools are provided.", "num_citations": "1\n", "authors": ["2181"]}
{"title": "Re-engineering with reuse: a case study\n", "abstract": " This paper describes a case study in reuse and reengineering. A C based metrics system was re-engineered to C++ using standard reusable components and a design pattern.", "num_citations": "1\n", "authors": ["2181"]}
{"title": "Domain Engineering: An Empirical Study\n", "abstract": " This paper presents a summary and analysis of data gathered from thirteen domain engineering projects, participant surveys, and demographic information. Taking a failure modes approach, project data is compared to an ideal model of the DARE methodology, revealing valuable insights into points of failure in the domain engineering process. This study suggests that success is a function of the domain analyst\u2019s command of a specific set of domain engineering concepts and skills, the time invested in the process, and persistence in difficult areas. We conclude by presenting strategies to avoid points of failure in future domain engineering projects.", "num_citations": "1\n", "authors": ["2181"]}
{"title": "Software Proeess Reuse in an Industrial Setting\n", "abstract": " This paper describes a method for creating reusable processes and our experience using them in an industrial environment. A notation and process for creating and tailoring reusable processes is described and applied to the building of a 120 process library at PRC Inc. Initial data collected on use of the library indicates large potential payoffs from process reuse such as a 10 to 1 improvement in the time to develop a project specific process.", "num_citations": "1\n", "authors": ["2181"]}
{"title": "Tutorial on Software Reuse and Domain Analysis\n", "abstract": " CiNii \u8ad6\u6587 - Tutorial on Software Reuse and Domain Analysis CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831 \u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f \u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 [\u6a5f\u95a2\u8a8d\u8a3c] \u5229\u7528 \u7d99\u7d9a\u624b\u7d9a\u304d\u306e\u3054\u6848\u5185 Tutorial on Software Reuse and Domain Analysis FRAKES W. \u88ab\u5f15\u7528\u6587\u732e : 1\u4ef6 \u8457\u8005 FRAKES W. \u53ce\u9332\u520a\u884c\u7269 CASE 92 CASE 92, 1992 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u518d\u5229\u7528\u306e\u7ba1\u7406\u7684\u5074\u9762 \u78ef\u7530 \u5b9a\u5b8f \u60c5\u5831\u51e6\u7406\u5b66\u4f1a\u8ad6\u6587\u8a8c 34(5), 1117-1124, 1993-05-15 \u53c2\u8003\u6587\u732e11\u4ef6 \u88ab\u5f15\u7528\u6587\u732e5\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10007990108 \u8cc7\u6599\u7a2e\u5225 \u4f1a\u8b70\u8cc7\u6599 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u66f8\u304d\u51fa\u3057 Mendeley\u306b \u66f8\u304d\u51fa\u3057 Refer/BiblX\u3067\u8868\u793a RIS\u3067\u8868\u793a BibTeX\u3067\u8868\u793a TSV\u3067\u8868\u793a \u554f\u984c\u306e\u6307\u6458 \u30da\u30fc\u30b8\u30c8\u30c3\u30d7\u3078 \u2026", "num_citations": "1\n", "authors": ["2181"]}
{"title": "Software reuse: An empirical approach\n", "abstract": " Software reuse is widely believed to be the most promising technology for significantly improving software quality and productivity. In this paper, we discuss software reuse from an empirical perspective. We examine factors that affect reuse, reuse measurement, and techniques for tailoring a reuse program to a given organization via a failure modes model.", "num_citations": "1\n", "authors": ["2181"]}
{"title": "A Study of the Impact of Representations in Information Retrieval Systems\n", "abstract": " This paper describes first year results of an NSF study, currently in progress at Syracuse University's School of Information Studies, to determine if document representations have an effect on information system performance. It was discovered that overlaps among sets of documents retrieved on different representations were low. An attempt was made to develop stepwise models to identify which sequences of representations most efficiently retrieve relevant documents.84 queries were obtained from 69 individuals who were asked to make relevance judgments on the documents retrieved on his query or queries. A 4 point scale was used with\" l\" and\" 2\" indicating relevant, and\" 3\" and\" 4\" indicating non-relevant.", "num_citations": "1\n", "authors": ["2181"]}