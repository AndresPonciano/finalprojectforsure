{"title": "MDA en action: Ing\u00e9nierie logicielle guid\u00e9e par les mod\u00e8les\n", "abstract": " Les mod\u00e8les au service de la productivit\u00e9 et de la p\u00e9rennit\u00e9 des d\u00e9veloppements Nouvelle approche d'ing\u00e9nierie logicielle \u00e9labor\u00e9e par l'OMG, MDA (Model Driven Architecture) pr\u00f4ne l'utilisation syst\u00e9matique de mod\u00e8les dans toutes les phases du cycle de vie des applications informatiques, de l'analyse et conception \u00e0 la g\u00e9n\u00e9ration de code et au d\u00e9ploiement. Pour une meilleure productivit\u00e9 et une plus grande p\u00e9rennit\u00e9 des d\u00e9veloppements, la logique m\u00e9tier d'une application est mod\u00e9lis\u00e9e ind\u00e9pendamment de toute plate-forme d'ex\u00e9cution, un m\u00e9canisme de transformation de mod\u00e8les permettant ensuite de produire automatiquement les mod\u00e8les et le code sp\u00e9cifiques \u00e0 chaque plate-forme (J2EE,. NET, PHP...). Mise en oeuvre pratique de MDA, illustr\u00e9e par une \u00e9tude de cas Apr\u00e8s une description d\u00e9taill\u00e9e des standards sur lesquels repose MDA, tels que UML, MOF, OCL et XMI, l'ouvrage insiste sur les aspects pratiques de sa mise en oeuvre. Il montre comment construire des transformations de mod\u00e8les en Java \u00e0 l'aide de l'API JMI et du framework EMF, et pr\u00e9sente deux outils MDA du march\u00e9: IBM Rational Software Modeler et Objecteering/MDA Modeler. L'ouvrage d\u00e9crit enfin comment MDA prend en compte les plates-formes d'ex\u00e9cution, en d\u00e9taillant plus particuli\u00e8rement les environnements J2EE/EJB et PHP. Tous ces aspects de l'approche MDA sont illustr\u00e9s par une \u00e9tude de cas, une application de commerce \u00e9lectronique d\u00e9velopp\u00e9e simultan\u00e9ment en J2EE et en PHP. Offert en t\u00e9l\u00e9chargement gratuit avec ce livre IBM Rational Software Modeler 6.0 (version d'\u00e9valuation limit\u00e9e \u00e0 30 jours, en fran\u00e7ais) Objecteering/MDA Modeler\u00a0\u2026", "num_citations": "163\n", "authors": ["77"]}
{"title": "Model bus: Towards the interoperability of modelling tools\n", "abstract": " MDA software development requires the interoperability of a wide range of modelling services (operations taking models as inputs and outputs), such as model edition, model transformation, and code generation. In particular, software development life cycle requires the interoperability of different modelling services. In particular, this interoperability concerns how to \u201cconnect\u201d services (how to send an output model produced by one service as an input to another service). Today, the notion of modelling services is not yet well defined. Moreover, CASE tools, which implements different services, have heterogeneous interfaces. For this reason, the service connection is costly and cannot be automated. Currently, there are few works addressing this problem. Therefore, we propose an architecture and a prototype enabling the services of different tools to be connected.", "num_citations": "95\n", "authors": ["77"]}
{"title": "Impact of developer turnover on quality in open-source software\n", "abstract": " Turnover is the phenomenon of continuous influx and retreat of human resources in a team. Despite being well-studied in many settings, turnover has not been characterized for open-source software projects. We study the source code repositories of five open-source projects to characterize patterns of turnover and to determine the effects of turnover on software quality. We define the base concepts of both external and internal turnover, which are the mobility of developers in and out of a project, and the mobility of developers inside a project, respectively. We provide a qualitative analysis of turnover patterns. We also found, in a quantitative analysis, that the activity of external newcomers negatively impact software quality.", "num_citations": "84\n", "authors": ["77"]}
{"title": "UML4SPM: A UML2. 0-based metamodel for software process modelling\n", "abstract": " In the context of Model Driven Development, models play a central role. Since models can nowadays be executed, they are used not only for description but also for production [32][30][24]. In the field of software process modelling, the current version of the OMG SPEM standard (ver1.1) has not yet reached the level required for the specification of executable models. The purpose of SPEM1.1 was limited at providing process descriptions to be read by humans and to be supported by tools, but not to be executed. Therefore, the OMG issued a new RFP in order to improve SPEM1.1 [35]. Since we intend to participate in the next major revision of SPEM, namely SPEM2.0, in this work, we: 1) compare SPEM1.1 both with primary process model elements (i.e. Activity, Product, Role,...) and with basic requirements that any Process Modelling Language should support (i.e. expressiveness, understandability\u00a0\u2026", "num_citations": "80\n", "authors": ["77"]}
{"title": "Towards automated inconsistency handling in design models\n", "abstract": " The increasing adoption of MDE (Model Driven Engineering) favored the use of large models of different types. It turns out that when the modeled system gets larger, simply computing a list of inconsistencies (as provided by existing techniques for inconsistency handling) gets less and less effective when it comes to actually fixing them. In fact, the inconsistency handling task (i.e. deciding what needs to be done in order to restore consistency) remains largely manual. This work is a step towards its automatization. We propose a method for the generation of repair plans for an inconsistent model. In our approach, the depth of the explored search space is configurable in order to cope with the underlying combinatorial characteristic of this problem and to avoid overwhelming the designer with large plans that can not be fully checked before being applied.", "num_citations": "78\n", "authors": ["77"]}
{"title": "Uniform random generation of huge metamodel instances\n", "abstract": " The size and the number of models is drastically increasing, preventing organizations from fully exploiting Model Driven Engineering benefits. Regarding this problem of scalability, some approaches claim to provide mechanisms that are adapted to numerous and huge models. The problem is that those approaches cannot be validated as it is not possible to obtain numerous and huge models and then to stress test them.               In this paper, we face this problem by proposing a uniform generator of huge models. Our approach is based on the Boltzmann method, whose two main advantages are its linear complexity which makes it possible to generate huge models, and its uniformity, which guarantees that the generation has no bias.", "num_citations": "78\n", "authors": ["77"]}
{"title": "Mining library migration graphs\n", "abstract": " Software systems intensively depend on external libraries, chosen at conception time. However, relevance of any library irremediably changes during projects and/or library life cycle. As a consequence, projects developers must periodically reconsider the libraries they depend on, and must think about library migration. When they want to migrate their libraries, they then have to identify candidate libraries that offer similar facilities and thus can substitute to each other. They also have to compare candidates to choose the one that best fits their needs. Finding a relevant library replacement is a well known tedious and time-consuming task. In this paper, we propose an approach that identifies sets of similar libraries and that produces what we call library migration graphs that show how existing projects have performed migrations among them. These graphs, constructed from the observation of a large number of\u00a0\u2026", "num_citations": "75\n", "authors": ["77"]}
{"title": "A study of library migrations in java\n", "abstract": " Software intensively depends on external libraries whose relevance may change during its life cycle. As a consequence, software developers must periodically reconsider the libraries they depend on, and must think about replacing them for more relevant ones. We refer to this practice as library migration. To find the best replacement for their library, they can rely on information over the Web, but they get quickly overwhelmed by the amount of data they gather. Making the right choice in this context constitutes the topic of our work. The solution we propose is to exhibit and mine the library migrations trends computed by performing a study of a large set of software projects. To perform this analysis, we have defined an automatic approach to compute library dependencies and a semi\u2010automatic approach that identifies library migrations. Then, we propose a deep analysis of the library migration phenomena by\u00a0\u2026", "num_citations": "61\n", "authors": ["77"]}
{"title": "Automatic discovery of function mappings between similar libraries\n", "abstract": " Library migration is the process of replacing a third-party library in favor of a competing one during software maintenance. The process of transforming a software source code to become compliant with a new library is cumbersome and error-prone. Indeed, developers have to understand a new Application Programming Interface (API) and search for the right replacements for the functions they use from the old library. As the two libraries are independent, the functions may have totally different structures and names, making the search of mappings very difficult. To assist the developers in this difficult task, we introduce an approach that analyzes source code changes from software projects that already underwent a given library migration to extract mappings between functions. We demonstrate the applicability of our approach on several library migrations performed on the Java open source software projects.", "num_citations": "50\n", "authors": ["77"]}
{"title": "Software process modeling and execution: the UML4SPM to WS-BPEL approach\n", "abstract": " Over the two past decades, the software process modeling community is being confronted to the following dilemma: how a software process modeling language (SPML) can be sufficiently abstract to hide the increasing complexity of development processes while being precise enough to be executed? Since no SPML succeeded in satisfying these apparently conflicting requirements, in this paper we propose to combine two languages: UML4SPM, an UML2.0-based software process modeling language and WS-BPEL (web services business process execution language). While UML4SPM brings expressiveness, understandability and abstraction in modeling software development processes, BPEL provides a semantically rich set of concepts for process executions. The mapping between the two languages, how do they complement each other, some issues and the value of the approach are discussed.", "num_citations": "50\n", "authors": ["77"]}
{"title": "Who should comment on this pull request? analyzing attributes for more accurate commenter recommendation in pull-based development\n", "abstract": " Context: The pull-based software development helps developers make contributions flexibly and efficiently. Commenters freely discuss code changes and provide suggestions. Core members make decision of pull requests. Both commenters and core members are reviewers in the evaluation of pull requests. Since some popular projects receive many pull requests, commenters may not notice new pull requests in time, and even ignore appropriate pull requests.Objective: Our objective in this paper is to analyze attributes that affect the precision and recall of commenter prediction, and choose appropriate attributes to build commenter recommendation approach.Method: We collect 19,543 pull requests, 206,664 comments and 4817 commenters from 8 popular projects in GitHub. We build approaches based on different attributes, including activeness, text similarity, file similarity and social relation. We also build\u00a0\u2026", "num_citations": "45\n", "authors": ["77"]}
{"title": "UML4SPM: An executable software process modeling language providing high-level abstractions\n", "abstract": " Software processes and software process modeling approaches were and still are in the heart of enterprise preoccupations. This interest is essentially motivated by the increasing need to build reliable and complex software systems in a short time to market. During the three last decades, a variety of Process Modeling Languages were proposed in order to capture the expertise of enterprises. However no one succeeded in gaining the attention of the industry. Main reasons were because that most of them were either imprecise or not suitable to be executed or both. This paper presents UML4SPM, a UML2.0-based Language for software process modelling. Expressiveness, understandability, precision and executability were our main objectives while designing UML4SPM. Our contribution comes inform of MOF-compliant metamodel, a simple yet expressive graphical notation and diagrams and a precise semantics\u00a0\u2026", "num_citations": "41\n", "authors": ["77"]}
{"title": "Using the UML language to express the ODP enterprise concepts\n", "abstract": " Specification is not a gimmick; it is a real discipline that offers many advantages to software developers. It is helpful for building, managing and describing applications. Specification standards are now available, such as the OMG (Object Management Group) adoption of the UML (Unified Modelling Language) notation and the RM-ODP (Reference Model for Open Distributed Processing) standards developed by ISO (International Standardisation Organisation) and ITU-T (International Telecommunication Union-Telecommunication Sector). However, these standards are totally independent, even though they deal with the same topic. In order to conciliate these two approaches, we propose a way to use the UML notation to express RM-ODP enterprise concepts.", "num_citations": "40\n", "authors": ["77"]}
{"title": "D-praxis: A peer-to-peer collaborative model editing framework\n", "abstract": " Large-scale industrial systems involve nowadays hundreds of developers working on hundreds of models representing parts of the whole system specification. Unfortunately, few tool support is provided for managing this huge set of models. In such a context of collaborative work, the approach commonly adopted by the industry is to use a central repository and to make use of merge mechanisms and locks.               In this article we present a collaborative model editing framework, peer-to-peer oriented, that considers that every developer has his own partial replication of the system specification and that makes use of messages exchange for propagating changes made by developers. Our approach has the advantage not to be based on a single repository, which is more and more the case in large-scale industrial projects.", "num_citations": "39\n", "authors": ["77"]}
{"title": "Supporting collaborative development in an open MDA environment\n", "abstract": " The MDA approach aims to ease software maintenance faced with platform and business evolution. In this approach, main development artifacts, i.e. models, are defined with the meta object facility (MOF) standard. To support collaborative development in MDA, we propose a mechanism for merging concurrent changes to MOF models. Our approach has the following novel functionality. First, as MOF models can have ordered relations, our mechanism can identify the order changes in MOF models, detect the conflicts caused by concurrent order changes, and integrate those changes. Second, as MOF models must respect multiplicity constraints, our mechanism detects the concurrent modifications that result in multiplicity violations. Therefore, it ensures the consistency of the merge result. Third, we offer a framework for building conflict resolution programs dedicated to developers' particular requirements. This\u00a0\u2026", "num_citations": "36\n", "authors": ["77"]}
{"title": "Collaborative software engineering on large-scale models: requirements and experience in modelbus\n", "abstract": " This work presents an approach for realizing Model-Driven software engineering in the distributed and multi-developers context. It particularly focuses on the scalability problems in a complex software project involving a large set of inter-connected models:(1) how to manipulate large data volume with limited computing resources, and (2) how to maintain consistency of inter-model links in a large model set, facing to concurrent model updates. As a solution, we propose the scalable copy-modify-merge mechanism, which allows each developer to copy only a model subset from the entire model set, to manipulate this subset locally, and to merge it back to the repository. This mechanism ensures the global consistency of the model set, particularly against dangling links. Our approach is generic: it is applicable to all model types (UML and Domain-Specific Models). Also, it offers interoperability with existing\u00a0\u2026", "num_citations": "35\n", "authors": ["77"]}
{"title": "Code ownership in open-source software\n", "abstract": " Context: Ownership metrics measure how the workload of software modules is shared among their developers. They have been shown to be accurate indicators of software quality. Objective: Since ownership metrics studies were done only on industrial software projects, we replicated such a study on Java free/libre and open source software (FLOSS) projects. Our goal was to generalize an\" ownership law\" that stated that minor developers should be avoided. Method: We explored the relationship between ownership metrics and fault-proneness on seven FLOSS projects, using publicly available corpora to retrieve the fault-related information. Results: In our corpus, the relationship between ownership metrics and module faults is weak. At best, less than half of projects exhibit a significant correlation, and at worst, no projects at all. Moreover, fault-proneness seems to be much more influenced by module size than by\u00a0\u2026", "num_citations": "34\n", "authors": ["77"]}
{"title": "Computing contextual metric thresholds\n", "abstract": " Software metrics have been developed to measure the quality of software systems. A proper use of metrics requires thresholds to determine whether the value of a metric is acceptable or not. Many approaches propose to define thresholds based on large analyses of software systems. However it has been shown that thresholds depend greatly on the context of the project. Thus there is a need for an approach that computes thresholds by taking into account this context. In this paper we propose such approach with the objective to reach a trade-off between representativeness of the threshold and computation cost. Our approach is based on an unbiased selection of software entities and makes no assumptions on the statistical properties of the software metrics values. It can therefore be used by anyone, ranging from developer to manager, for computing a representative metric threshold tailored to their context.", "num_citations": "28\n", "authors": ["77"]}
{"title": "MDA: Vers un important changement de paradigme en g\u00e9nie logiciel\n", "abstract": " L\u2019OMG a d\u00e9fini sa nouvelle orientation pour r\u00e9soudre les probl\u00e8mes actuels de construction et d\u2019\u00e9volution de syst\u00e8mes d\u2019information auxquels font face les industriels. Cette orientation se nomme MDA (Model Driven Architecture) et se d\u00e9marque tr\u00e8s nettement de l\u2019ancienne (OMA: Object Management Architecture), en se positionnant clairement au niveau sup\u00e9rieur d\u2019abstraction et en mettant le projecteur non plus sur les approches \u00e0 objets mais sur les approches \u00e0 mod\u00e8les. Le but est de se concentrer sur l\u2019\u00e9laboration de mod\u00e8les de plus haut niveau d\u2019abstraction et de favoriser les approches transformationnelles param\u00e9triques vers les plates-formes techniques. Le MDA est un grand chantier qui s\u2019 ouvre. Plus de trente ans apr\u00e8s la premi\u00e8re crise du logiciel qui a eu lieu dans les ann\u00e9es 68, c\u2019est une nouvelle crise qui secoue aujourd\u2019hui le monde de la production de logiciel. Encore une fois la complexit\u00e9 grandissante des syst\u00e8mes informatiques, leur n\u00e9cessaire \u00e9volutivit\u00e9 et leur couplage de plus en plus fort sur les organisations dans lesquelles ils op\u00e8rent ont provoqu\u00e9 une r\u00e9action importante et rapide.Le principe de base du MDA est l\u2019\u00e9laboration de mod\u00e8les ind\u00e9pendants de plates-formes (PIM) et la transformation de ceux-ci en mod\u00e8les d\u00e9pendants de plates-formes (PSM). Les techniques employ\u00e9es sont donc principalement des techniques de mod\u00e9lisation et des techniques de transformation de mod\u00e8les. L\u2019OMG a d\u2019ailleurs d\u2019ores et d\u00e9j\u00e0 commenc\u00e9 \u00e0 d\u00e9finir des standards dans ce domaine. Les plus connus sont bien s\u00fbr UML et XMI mais les autres tels que MOF, CWM ou les profils EJB et CORBA ne sont pas moins indispensables\u00a0\u2026", "num_citations": "27\n", "authors": ["77"]}
{"title": "Automatic extraction of developer expertise\n", "abstract": " Context: Expert identification is becoming critical to ease the communication between developers in case of global software development or to better know members of large software communities. To quickly identify who are the experts that will best perform a given development task, both the assignment of skills to developers and the computation of their corresponding expertise level have to be automated. Since the real level of expertise is tedious to assess, our challenge is to identify developers having a significant level of experience with respect to a skill. Method: In this paper we propose XTic, an approach that takes up this challenge with the intent to be accurate and efficient. XTic provides a language to specify skills. It also provides an automatic process that extracts skills and experience levels from source code repositories. Our approach is based on the idea that an expert has a high level of experience with\u00a0\u2026", "num_citations": "24\n", "authors": ["77"]}
{"title": "Promesses et interrogations de l\u2019approche MDA\n", "abstract": " Dans le premier article de cette s\u00e9rie, nous avons pr\u00e9sent\u00e9 un changement important de paradigme qui s' annonce dans le domaine du g\u00e9nie logiciel et de la gestion des syst\u00e8mes d'information. En effet, depuis fin 2000, l'OMG m\u00e8ne un mouvement qui vise \u00e0 se d\u00e9marquer des extensions de plates-formes middleware pour promouvoir une approche diff\u00e9rente bas\u00e9e sur les mod\u00e8les. Cette approche (le MDA) est pleine de promesses et c\u2019est un grand chantier qui s\u2019 ouvre aujourd\u2019hui pour au moins une dizaine d\u2019ann\u00e9e.Dans ce deuxi\u00e8me article nous pr\u00e9cisons certains aspects du MDA et nous en montrons \u00e0 la fois la port\u00e9e et les limites en mettant en perspective les objectifs \u00e0 long terme et les retomb\u00e9es \u00e0 court terme. Nous pr\u00e9sentons dans un premier temps quelques bases th\u00e9oriques qui visent \u00e0 d\u00e9finir quels sont les types de mod\u00e8les utilis\u00e9s par le MDA et quelles sont les op\u00e9rations que l\u2019on pourra leur appliquer. Dans un second temps nous pr\u00e9sentons l\u2019\u00e9tat actuel des standards permettant de rendre ces mod\u00e8les productifs et dans un troisi\u00e8me et dernier temps nous d\u00e9crivons quelques travaux actuels sur les aspects m\u00e9thodologiques du MDA.", "num_citations": "24\n", "authors": ["77"]}
{"title": "FP-Crawlers: studying the resilience of browser fingerprinting to block crawlers\n", "abstract": " Data available on the Web, such as financial data or public reviews, provides a competitive advantage to companies able to exploit them. Web crawlers, a category of bot, aim at automating the collection of publicly available Web data. While some crawlers collect data with the agreement of the websites being crawled, most crawlers do not respect the terms of service. CAPTCHAs and approaches based on analyzing series of HTTP requests classify users as humans or bots. However, these approaches require either user interaction or a significant volume of data before they can classify the traffic.  In this paper, we study browser fingerprinting as a crawler detection mechanism. We crawled the Alexa top 10K and identified 291 websites that block crawlers. We show that fingerprinting is used by 93 (31.96%) of them and we report on the crawler detection techniques implemented by the major fingerprinters. Finally, we evaluate the resilience of fingerprinting against crawlers trying to conceal themselves. We show that although fingerprinting is good at detecting crawlers, it can be bypassed with little effort by an adversary with knowledge on the fingerprints collected.", "num_citations": "23\n", "authors": ["77"]}
{"title": "On the usefulness of ownership metrics in open-source software projects\n", "abstract": " ContextCode ownership metrics were recently defined in order to distinguish major and minor contributors of a software module, and to assess whether the ownership of such a module is strong or shared between developers.ObjectiveThe relationship between these metrics and software quality was initially validated on proprietary software projects. Our objective in this paper is to evaluate such relationship in open-source software projects, and to compare these metrics to other code and process metrics.MethodOn a newly crafted dataset of seven open-source software projects, we perform, using inferential statistics, an analysis of code ownership metrics and their relationship with software quality.ResultsWe confirm the existence of a relationship between code ownership and software quality, but the relative importance of ownership metrics in multiple linear regression models is low compared to metrics such as\u00a0\u2026", "num_citations": "23\n", "authors": ["77"]}
{"title": "Documentation reuse: Hot or not? An empirical study\n", "abstract": " Having available a high quality documentation is critical for software projects. This is why documentation tools such as Javadoc are so popular. As for code, documentation should be reused when possible to increase developer productivity and simplify maintenance. In this paper, we perform an empirical study of duplications in JavaDoc documentation on a corpus of seven famous Java APIs. Our results show that copy-pastes of JavaDoc documentation tags are abundant in our corpus. We also show that these copy-pastes are caused by four different kinds of relations in the underlying source code. In addition, we show that popular documentation tools do not provide any reuse mechanism to cope with these relations. Finally, we make a proposal for a simple but efficient automatic reuse mechanism.", "num_citations": "22\n", "authors": ["77"]}
{"title": "Early deviation detection in modeling activities of mde processes\n", "abstract": " Software Process Models (SPM) are used to communicate around the processes and analyze it. They represent the entry point to PSEEs (Process-centered Software Engineering Environments) which use them to coordinate process agents in their tasks. When the process execution doesn\u2019t match the model, the common option in PSEEs is ignoring the model. If the actions of the agents are not tracked during deviations it is impossible to evaluate the effect of these deviations on the success or failure of the process. In this paper we propose to deal with agent deviations during process execution. The originality of our approach comes from the fact that it is Process Modeling Language\u2019s (PML) independent and that it proposes early deviation detection. We validate our approach by implementing a prototype of a process definition and execution environment and evaluating its effectiveness to a group of\u00a0\u2026", "num_citations": "22\n", "authors": ["77"]}
{"title": "On adopting linters to deal with performance concerns in android apps\n", "abstract": " With millions of applications (apps) distributed through mobile markets, engaging and retaining end-users challenge Android developers to deliver a nearly perfect user experience. As mobile apps run in resource-limited devices, performance is a critical criterion for the quality of experience. Therefore, developers are expected to pay much attention to limit performance bad practices. On the one hand, many studies already identified such performance bad practices and showed that they can heavily impact app performance. Hence, many static analysers, a.k.a. linters, have been proposed to detect and fix these bad practices. On the other hand, other studies have shown that Android developers tend to deal with performance reactively and they rarely build on linters to detect and fix performance bad practices. In this paper, we therefore perform a qualitative study to investigate this gap between research and\u00a0\u2026", "num_citations": "21\n", "authors": ["77"]}
{"title": "Model Reuse in MDA.\n", "abstract": " The Model Driven Architecture (MDA) approach defined by OMG advocates, for the construction of distributed applicati", "num_citations": "21\n", "authors": ["77"]}
{"title": "Automated generation of REST API specification from plain HTML documentation\n", "abstract": " REST is nowadays highly popular and widely adopted by Web services providers. However, most of the Web services providers only provide the documentation of their REST API in plain HTML pages, even if many specification formats exist such as WADL or OpenAPI for example. This prevents the Web Services users to benefit from all the advantages of having a machine-readable specification, such as generating client or server code, generating web services composition, checking formal properties, testing, etc. To face this issue, we provide a fully automated approach that builds a REST API specification from its corresponding plain HTML documentation. By given the root URL of the plain HTML API documentation, our approach automatically extracts the four mandatory parts that compose a specification: the base URL, the path templates, the HTTP verbs and the associated formal parameters. Our\u00a0\u2026", "num_citations": "19\n", "authors": ["77"]}
{"title": "A semantically rich approach for collaborative model edition\n", "abstract": " We propose a novel approach and tool for collaborative software engineering and development. In model-based software engineering, the underlying data structure is a complex, directed and labeled graph. Collaborative engineering requires that developers be able to copy the graph, make independent changes, compare them, detect conflicts, and merge non-conflicting graphs. To support different collaboration and development styles requires a very flexible toolset. Worldwide, loosely-coupled development teams require the support of large-scale networks of users, possibly disconnected, in a decentralised fashion. No matter how the graph replicas evolve, they must eventually converge. We describe and evaluate C-Praxis, a tool that satisfies these requirements.", "num_citations": "19\n", "authors": ["77"]}
{"title": "Supporting transparent model update in distributed case tool integration\n", "abstract": " Model Driven Architecture (MDA) is a software development approach that focuses on models. In order to support MDA, a lot of CASE tools have emerged; each of them provides a different set of modeling services (operations for automating model manipulation). We have proposed an open environment called ModelBus, which enables the integration of heterogeneous and distributed CASE tools. ModelBus enables tools to invoke the modeling services provided by other tools. In this paper, we focus on supporting a particular kind of modeling services: services that update models (ie they have inout parameters). Our contribution is to enable a tool to update models owned by another tool. We propose a parameter passing mechanism that hides the complexity of model update from tools. First, it enables a tool to update models transparently to heterogeneous model representations. Second, it enables a tool to update\u00a0\u2026", "num_citations": "18\n", "authors": ["77"]}
{"title": "UML 2 pour les d\u00e9veloppeurs: Cours avec exercices corrig\u00e9s\n", "abstract": " Un cours d'initiation \u00e0 UML con\u00e7u pour les d\u00e9veloppeurs et les \u00e9tudiants en informatique La plupart des livres sur UML s' adressent avant tout aux concepteurs et architectes logiciels, selon une d\u00e9marche\" tout-mod\u00e8le\" dans laquelle la production de code est trait\u00e9e comme une activit\u00e9 subalterne. Cette approche suscite \u00e9videmment des r\u00e9ticences chez les d\u00e9veloppeurs et d\u00e9concerte les \u00e9tudiants, dont la formation reste ax\u00e9e principalement sur la programmation et qui mesurent mal les enjeux du formalisme UML. UML 2 pour les d\u00e9veloppeurs prend le contre-pied de ces approches classiques. L'ouvrage montre comment articuler harmonieusement mod\u00e9lisation et programmation, en insistant sur les gains de productivit\u00e9 que permettent ces allers-retours entre les mod\u00e8les UML et le code. Chaque notion UML importante est introduite par un exemple et chaque chapitre se cl\u00f4t par une s\u00e9rie d'exercices corrig\u00e9s (90 au total), qui permettront au lecteur de tester ses connaissances. Pour illustrer concr\u00e8tement les relations entre code et mod\u00e8les, les auteurs font le choix du langage Java, les principes pr\u00e9sent\u00e9s \u00e9tant naturellement transpos\u00e2mes \u00e0 d'autres langages. Sur le site www. editions-eyrolles. com Dialoguez avec les auteurs T\u00e9l\u00e9chargez les mod\u00e8les et le code source des exemples du livre", "num_citations": "17\n", "authors": ["77"]}
{"title": "The harmony platform\n", "abstract": " According to Wikipedia, The Mining Software Repositories (MSR) field analyzes the rich data available in software repositories, such as version control repositories, mailing list archives, bug tracking systems, issue tracking systems, etc. to uncover interesting and actionable information about software systems, projects and software engineering. The MSR field has received a great deal of attention and has now its own research conference : http://www.msrconf.org/. However performing MSR studies is still a technical challenge. Indeed, data sources (such as version control system or bug tracking systems) are highly heterogeneous. Moreover performing a study on a lot of data sources is very expensive in terms of execution time. Surprisingly, there are not so many tools able to help researchers in their MSR quests. This is why we created the Harmony platform, as a mean to assist researchers in performing MSR studies.", "num_citations": "16\n", "authors": ["77"]}
{"title": "Incremental inconsistency detection with low memory overhead\n", "abstract": " Ensuring models\u2019 consistency is a key concern when using a model\u2010based development approach. Therefore, model inconsistency detection has received significant attention over the last years. To be useful, inconsistency detection has to be sound, efficient, and scalable. Incremental detection is one way to achieve efficiency in the presence of large models. In most of the existing approaches, incrementalization is carried out at the expense of the memory consumption that becomes proportional to the model size and the number of consistency rules. In this paper, we propose a new incremental inconsistency detection approach that only consumes a small and model size\u2010independent amount of memory. It will therefore scale better to projects using large models and many consistency rules. Copyright \u00a9 2012 John Wiley & Sons, Ltd.", "num_citations": "15\n", "authors": ["77"]}
{"title": "MOF QVT final adopted specification: meta object facility (MOF) 2.0 query/view/transformation specification.\n", "abstract": " MOF QVT final adopted specification: meta object facility (MOF) 2.0 query/view/transformation specification. - Middlesex University Research Repository Skip to content Middlesex University Middlesex University Research Repository Research work by Middlesex University staff and alumni Home Latest additions Usage statistics Search: simple / advanced Browse by Year Research area Author Theses Help How do I add my work? Repository FAQs Repository policies Copyright Contact us Login (Middlesex University staff only) MOF QVT final adopted specification: meta object facility (MOF) 2.0 query/view/transformation specification. Bast, Wim, Murphree, Michael, Michael, Lawley, Duddy, Keith, Belaunde, Mariano, Griffin, Catherine, Sendall, Shane, Didier, Voitisiek, Steel, Jim, Sendall, Shane, Tratt, Laurence, Helsen, Simon, Venkatesh, R. and Blanc, Xavier (2005) MOF QVT final adopted specification: meta object () //\u2026", "num_citations": "15\n", "authors": ["77"]}
{"title": "Towards an integrated transformation environment (ITE) for model driven development (MDD)\n", "abstract": " It is now widely accepted that model transformations are at the heart of MDA. However, despite all the work done in the elaboration of a standard devoted to a model transformation language, it appears that few reflections are made on architectures of transformation engines from a user point of view. Engines that are currently available provide their own architectures. This heterogeneity is a real problem that must be solved in order to make MDA successful.Thus we propose a so called\" Integrated Transformation Environment\"(ITE) that provides users with facilities for executing model transformations. The ITE answers the questions\" what is a transformation engine?\" and\" how to execute a transformation?\". Thanks to this ITE, users can easily execute model transformations whatever the engine they choose. Moreover, we also consider that the ITE can be a good candidate for model transformation tests as it provides a\u00a0\u2026", "num_citations": "13\n", "authors": ["77"]}
{"title": "Find your library experts\n", "abstract": " Heavy usage of third-party libraries is almost mandatory in modern software systems. The knowledge of these libraries is generally scattered across the development team. When a development or a maintenance task involving specific libraries arises, finding the relevant experts would simplify its completion. However there is no automatic approach to identify these experts. In this article we propose Libtic, a search engine of library experts automatically populated by mining software repositories. We show that Libtic finds relevant experts of common Java libraries among the GitHub developers. We also illustrate its usefulness through a case study on the Apache HBase project where several maintenance and development use-cases are carried out.", "num_citations": "12\n", "authors": ["77"]}
{"title": "Modeling services and web services: Application of modelbus\n", "abstract": " Archive ouverte HAL - Modeling Services and Web Services: Application of ModelBus Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01486930, version 1 Communication dans un congr\u00e8s Modeling Services and Web Services: Application of ModelBus Xavier Blanc 1 Marie-Pierre Gervais 1 Prawee Sriplakich 1 D\u00e9tails 1 MoVe - Mod\u00e9lisation et V\u00e9rification LIP6 - Laboratoire d'Informatique de Paris 6 Type de document : Communication dans un congr\u00e8s Domaine : Informatique [cs] Liste compl\u00e8te des ://.-'\u2026", "num_citations": "12\n", "authors": ["77"]}
{"title": "Fostering good coding practices through individual feedback and gamification: an industrial case study\n", "abstract": " Code quality is a constant challenge faced by today\u2019s software industry. To ensure that developers follow good coding practices, a variety of program analysis and test coverage tools are routinely deployed. However, these tools often fail to engage and change the practices of developers when applied to legacy systems as they output a huge number of warnings, quickly overwhelming the developers. In this article, we explore how individual feedback and gamification can motivate developers to pay more attention to good coding practices. To that extent, we implemented these two concepts in a tool that we deployed at two large companies where we conducted a case study. We find out that individual feedback is essential for motivating developers. We also find that gamification can be useful but has to be used with caution as it can frustrate some developers. Finally, we reflect on some lessons learned during our\u00a0\u2026", "num_citations": "11\n", "authors": ["77"]}
{"title": "Deviation management during process execution\n", "abstract": " Software development companies have been putting a lot of effort in adopting process models, however two main issues remain. On the one hand, process models are inherently incomplete, since companies can not capture all possible situations in a single model. On the other hand, managers can not force process participants (agents) to strictly follow these models. The effect of both issues is that companies need to be able to handle deviations during process enactment. In order to make sure that process agents follow the process model and that their deviations get detected and handled, they adopt the so-called Process-centered Software Engineering Environments (PSEEs). Unfortunately, the options proposed by these tools, when it comes to handling a deviation, are rather limited to basically ignoring or forbidding it. In the present work, we face this limitation by presenting an approach for detecting, managing\u00a0\u2026", "num_citations": "11\n", "authors": ["77"]}
{"title": "A Critical Analysis of MDA Standards through an Implementation: the ModFact Tool\n", "abstract": " We present in this paper our experiment of implementing various MDA standards in a tool named ModFact. This implements MOF and XMI standards from OMG as well as JMI from Sun. Lessons learned from this experiment are described. In particular, we stress the limits we encountered when implementing the MOF standard. This leads us to wonder whether the MOF specification tackles the right level of standardization required in models manipulation in order to be really useful for software engineers adopting an MDA approach for their development.", "num_citations": "11\n", "authors": ["77"]}
{"title": "Transformations de mod\u00e8les: d'un mod\u00e8le abstrait aux mod\u00e8les EJB et CCM\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "10\n", "authors": ["77"]}
{"title": "Gamification: a game changer for managing technical debt? a design study\n", "abstract": " Context: Technical debt management is challenging for software engineers due to poor tool support and a lack of knowledge on how to prioritize technical debt repayment and prevention activities. Furthermore, when there is a large backlog of debt, developers often lack the motivation to address it. Objective: In this paper, we describe a design study to investigate how gamification can support Technical Debt Management in a large legacy software system of an industrial company. Our study leads to a novel tool (named Themis) that combines technical debt support, version control, and gamification features. In addition to gamification features, Themis provides suggestions for developers on where to focus their effort, and visualizations for managers to track technical debt activities. Method: We describe how Themis was refined and validated in an iterative deployment with the company, finally conducting a qualitative study to investigate how the features of Themis affect technical debt management behavior. We consider the impact on both developers and managers. Results: Our results show that it achieves increased developer motivation, and supports managers in monitoring and influencing developer behaviors. We show how our findings may be transferable to other contexts by proposing guidelines on how to apply gamification. Conclusions: With this case, gamification appears as a promising solution to help technical debt management, although it needs to be carefully designed and implemented to avoid its possible negative effects.", "num_citations": "8\n", "authors": ["77"]}
{"title": "Operation based model representation: experiences on inconsistency detection\n", "abstract": " Keeping the consistency between design models is paramount in complex contexts. It turns out that the underlying Model Representation Strategy has an impact on the inconsistency detection activity. The Operation Based strategy represents models as the sequence of atomic editing actions that lead to its current state. Claims have been made about gains in time and space complexity and in versatility by using this kind of representation when compared to the traditional object based one. However, this hypothesis has never been tested in an industrial context before. In this paper, we detail our experience evaluating an Operation Based consistency engine (Praxis) when compared with a legacy system based on EMF. We evaluated a set of industrial models under inconsistency rules written in both Java (for EMF) and PraxisRules (the DSL \u2013 Domain Specific Language \u2013 for describing inconsistency rules in\u00a0\u2026", "num_citations": "8\n", "authors": ["77"]}
{"title": "Finding a path to model consistency\n", "abstract": " A core problem in Model Driven Engineering is model consistency achievement: all models must satisfy relationships constraining them. Active consistency techniques monitor and control models edition for preventing inconsistencies, e.g., using automatic errors correction. The main problem of these approaches is that strict enforcement of consistency narrows the modeler\u2019s possibilities for exploring conflicting or tradeoff solutions; this is just what temporaries inconsistencies enable. In this article, we propose a hybrid approach capitalizing on active consistency characteristics while allowing the user to edit inconsistent models in a managed mode: at any moment we are able to propose a sequence of modelling operations that, when executed, make the model consistent. The solution consists in defining a set of automatons capturing a sufficient part of the model state space for managing any inconsistent\u00a0\u2026", "num_citations": "8\n", "authors": ["77"]}
{"title": "On Meta-Modeling Formalisms and Rule-Based Model Transforms\n", "abstract": " In this paper, we propose to investigate the equivalence between different meta-modeling formalisms, with the practical target of sharing experience on model engineering. Our experience, derived from the MtaGen project, is embodied by rule-based\" value-adding\" model transforms, written on a special form of the Entity/Relationship formalism as a meta-modeling framework. We propose a scheme by which those transforms could be experimented in the framework of standard MOF-based meta-modeling. In order to support our proposal, we first compare three meta-modeling facilities, by describing how the same simple example of a modeling language is meta-modeled with each facility. Keywords Meta-modeling, MOF, other formalisms, model engineering, rule-based value-adding model transformation, experience sharing. 1. Introduction Promoting Model Engineering requires some experimental apparatus for studying the algebra of models, which is mainly concerned with model transformations: some of them ar...", "num_citations": "8\n", "authors": ["77"]}
{"title": "Empirical study on rest apis usage in android mobile applications\n", "abstract": " A large set of mobile applications (apps) heavily rely on services accessible through the Web via REST APIs. However, the way mobile apps use services in practice has never been studied. In this paper, we perform an empirical study in the Android ecosystem in which we analyze 500 popular apps and 15 popular services. We also conducted an online survey to identify best practices for Android developers. Our results show that they generally favor invoking services by using official service libraries instead of invoking services with a generic HTTP client. We also present which good practices service libraries should implement.", "num_citations": "7\n", "authors": ["77"]}
{"title": "Real time streaming pattern detection for ecommerce\n", "abstract": " Pattern detection over streams of events is gaining more and more attention, especially in the field of eCommerce. Our industrial partner Cdiscount, which is one of the largest eCommerce companies in France, wants to use pattern detection for real-time customer behavior analysis. The main challenges to consider are efficiency and scalability, as the detection of customer behavior must be achieved within a few seconds, while millions of unique customers visit the website every day, each performing hundreds of actions. In this paper, we present our approach to large-scale and efficient pattern detection for eCommerce. It relies on a domain-specific language to define behavior patterns. Patterns are then compiled into deterministic finite automata, which are run on a Big Data streaming platform to carry out the detection work. Our evaluation shows that our approach is efficient and scalable, and fits the requirements\u00a0\u2026", "num_citations": "7\n", "authors": ["77"]}
{"title": "Support for Deviation Detections in the Context of Multi-Viewpoint-Based Development Processes.\n", "abstract": " One recurrent issue in software development processes are developer\u2019s deviations from the process model. This problem is amplified in the context of multi-viewpoint-based development of complex systems where the system\u2019s specification comes in form of different and intertwined viewpoints. Without a methodological support, these deviations become inevitable. They can be of different kinds: 1) behavioral deviations related to inappropriate actions performed by the developer when realizing process\u2019s activities or 2) structural deviations due to inconsistencies in deliverables, which can be in conflict with other viewpoint\u2019s outcomes. This paper proposes an approach to overcome these issues. To demonstrate the approach, a prototype was developed and the RM-ODP standard and a viewpoint-based development process were used.", "num_citations": "7\n", "authors": ["77"]}
{"title": "JSON Patch for Turning a Pull REST API into a Push\n", "abstract": " REST APIs together with JSON are commonly used by modern web applications to export their services. However, these services are usually reachable in a pull mode which is not suitable for accessing changing data. Turning a service from a pull to a push mode is therefore frequently asked by web developers that want to get notified of changes. Converting a pull API into a push one obviously requires to make periodical calls to the API but also to create a patch between each successive version of the data. The latter is the most difficult part and this is where existing solutions have some imperfections. To face this issue, we present a new patch algorithm supporting move and copy change operations. Our evaluation done with real industrial data shows that our algorithm creates small patches compared with other libraries, and creates them faster.", "num_citations": "6\n", "authors": ["77"]}
{"title": "The specifications exchange service of an RM-ODP framework\n", "abstract": " LIP6 and EDF have started to develop an RM-ODP framework for building open distributed systems. The first concern of this development was the construction of the Specification Exchange Service. This service, the so-called Backbone, enables to exchange RM-ODP specifications over any ORB or file system. This article presents the functionalities of the Backbone in the RM-ODP framework and its explains how meta-modeling standards such as MOF and XMI have been used to create it.", "num_citations": "6\n", "authors": ["77"]}
{"title": "A study of library migration in Java software\n", "abstract": " Software intensively depends on external libraries whose relevance may change during its life cycle. As a consequence, software developers must periodically reconsider the libraries they depend on, and must think about \\textit{library migration}. To our knowledge, no existing study has been done to understand library migration although it is known to be an expensive maintenance task. Are library migrations frequent? For which software are they performed and when? For which libraries? For what reasons? The purpose of this paper is to answer these questions with the intent to help software developers that have to replace their libraries. To that extent, we have performed a statistical analysis of a large set of open source software to mine their library migration. To perform this analysis we have defined an approach that identifies library migrations in a pseudo-automatic fashion by analyzing the source code of the software. We have implemented this approach for the Java programming language and applied it on Java Open Source Software stored in large hosting services. The main result of our study is that library migration is not a frequent practice but depends a lot on the nature of the software as well as the nature of the libraries.", "num_citations": "5\n", "authors": ["77"]}
{"title": "Echanges de sp\u00e9cifications h\u00e9t\u00e9rogenes et r\u00e9parties\n", "abstract": " theses.fr \u2013 Xavier Blanc , Echanges de sp\u00e9cifications h\u00e9t\u00e9rog\u00e8nes et r\u00e9parties Connexion Retour \u00e0 l'accueil Toutes les th\u00e8ses Th\u00e8ses en pr\u00e9paration Personnes Organismes D\u00e9sactiver l'autocompl\u00e9tion Recherche avanc\u00e9e Uniquement les th\u00e8ses soutenues Uniquement les th\u00e8ses soutenues accessibles en ligne SIGNALER une erreur EXPORTER les infos format RIS format BibTeX format XML th\u00e8se pr\u00e9c\u00e9dente th\u00e8se suivante Echanges de sp\u00e9cifications h\u00e9t\u00e9rog\u00e8nes et r\u00e9parties par Xavier Blanc Th\u00e8se de doctorat en Syst\u00e8mes informatiques Sous la direction de Marie-Pierre Gervais. Soutenue en 2001 \u00e0 Paris 6 . Description en fran\u00e7ais Description en anglais mots cl\u00e9s mots cl\u00e9s Sp\u00e9cification Mod\u00e9lisation M\u00e9ta-mod\u00e9lisation Transformation de mod\u00e8les Pas de r\u00e9sum\u00e9 disponible. Titre traduit Exchanges of heterogeneous and distributed specifications Pas de r\u00e9sum\u00e9 disponible. Consulter en biblioth\u00e8que Consulter : \u2026", "num_citations": "5\n", "authors": ["77"]}
{"title": "Automatic identification of client-side javascript libraries in web applications\n", "abstract": " Modern web applications often use JavaScript libraries, such as JQuey or Google Analytics for example, that make the development easier, cheaper and with a better quality. Choosing the right library to use is however very difficult as there are many competing libraries with many different versions. To help developers in this difficult choice, popularity indicators that pinpoint which applications use which libraries are very useful. Building such indicators is however challenging as popular web applications usually don't make their source code available. In this paper, we address this challenge with an approach that automatically browses web applications to retrieve the client-side JavaScript libraries they use. By applying this approach on the most famous websites, we then present the trends we observed, and the recommendations that can be provided.", "num_citations": "4\n", "authors": ["77"]}
{"title": "Applying model fragment copy-restore to build an open and distributed MDA environment\n", "abstract": " ModelBus is a middleware system that offers the interoperability between CASE tools for supporting software development according to MDA. This interoperability allows tools to share services and models, by using an RPC mechanism. ModelBus adopts the call-by-copy-restore semantic, as it is very close to local call semantic and is flexible as regards tools\u2019 heterogeneous model representations. In this work, we extend this semantic to enable only specific model fragments to be passed as parameters, instead of complete models. The advantages are 1) improving the performance because passing only model fragments requires less data processing and 2) enhancing access control to models because the service\u2019s modification can be restricted to the specific model fragment that is specified as parameters. The implementation of this work is available as the Eclipse project Model Driven Development\u00a0\u2026", "num_citations": "4\n", "authors": ["77"]}
{"title": "Improving Pattern Support in UML CASE Tools\n", "abstract": " In this paper we improve the UML2. 0 Collaboration Templates mechanism to better support patterns in UML CASE tools. Collaboration Templates are not versatile enough to support patterns correctly. First, they constrain their parameters inappropriately. Second, the instantiation of UML Collaboration Templates does not allow to modify or to suppress model elements which is sometimes necessary. Both problems make it difficult to maintain the UML models consistency when applying patterns and proves that the Collaboration Templates is a real source of possible inconsistencies. We thus propose to explicitly constrain Collaboration Template parameters using OCL and to allow the suppression or modification of model elements. We have prototyped this approach in the Objecteering UML CASE tool. Both these improvements proved quite useful in several applications, and will be included in a future version of the Objecteering CASE tool.", "num_citations": "4\n", "authors": ["77"]}
{"title": "Speculative reprogramming\n", "abstract": " Although software development involves making numerous decisions amongst alternatives, the design and implementation choices made typically become invisible; what a developer sees in the project's artifacts are the end result of all of the decisions. What if, instead, all of the choices made were tracked and it was easy for a developer to revisit a point where a decision was made and choose another alternative? What if the development environment could detect and suggest alternative choices? What if it was easy and low-cost to try another path? We explore the idea of speculative reprogramming that could support a what-if environment for the programming stages of software development.", "num_citations": "3\n", "authors": ["77"]}
{"title": "Experiments on the impact of deviations to process execution\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "3\n", "authors": ["77"]}
{"title": "V\u00e9rification de coh\u00e9rence entre mod\u00e8les de t\u00e2ches et de dialogue en conception centr\u00e9e-utilisateur.\n", "abstract": " Les approches \u00e0 base de mod\u00e8les se d\u00e9veloppent fortement pour la conception d\u2019applications interactives. Les mod\u00e8les sont alors utilis\u00e9s pour repr\u00e9senter les points de vue des diff\u00e9rents intervenants (dont l\u2019utilisateur). Cet article pr\u00e9sente une approche qui peut s\u2019 appliquer \u00e0 chaque it\u00e9ration de conception. Elle vise \u00e0 v\u00e9rifier la coh\u00e9rence de coconception des mod\u00e8les de t\u00e2ches (repr\u00e9sentant le point de vue de l\u2019utilisateur) et de dialogue (repr\u00e9sentant la dynamique de l\u2019application). Il inclut une application de l\u2019approche sur le mod\u00e8le de t\u00e2ches K-MAD, le mod\u00e8le de dialogue des interacteurs hi\u00e9rarchis\u00e9s et l\u2019utilisation de l\u2019approche Praxis (gr\u00e2ce \u00e0 laquelle des r\u00e8gles de coh\u00e9rence peuvent \u00eatre v\u00e9rifi\u00e9es).ABSTRACT. Model-based approach usage is increasing in interactive application design. Models are used to express the viewpoints of every design participant (particularly the user). This paper presents an approach for checking consistency between task models and dialog models during iterative application design. At the end, an example of the proposed approach is presented. It is based on the K-MAD task model, the IH dialog model (hierarchical interactors) and the use of Praxis (on witch rules are expressed).", "num_citations": "3\n", "authors": ["77"]}
{"title": "Inconsistency Detection in Distributed Model Driven Software Engineering Environments.\n", "abstract": " Model driven development uses more and more complementary models. Indeed, large-scale industrial systems are currently developed by hundreds of developers working on hundreds of models by different distributed teams. In such a context, model inconsistency detection is gaining a lot of attention as the overlap between all these models, which are often maintained by different persons, are a common source of inconsistencies. This paper proposes a method to detect inconsistencies when models are scattered on different editing sites using partial replication. The method provides a way to check the consistency of a single view against the ones that are related to it regarding consistency. It relies on Praxis, an operation based representation of models, to determine what information needs to be collected for consistency checking and the DPraxis protocol to find where it can be.", "num_citations": "3\n", "authors": ["77"]}
{"title": "Environnement de d\u00e9veloppement support \u00e0 l'ing\u00e9nierie logicielle guid\u00e9e par les mod\u00e8les\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "3\n", "authors": ["77"]}
{"title": "On the Construction of Distributed RM-ODP specifications\n", "abstract": " LIP6, is association with EDF R& D, proposes a framework that deals with the construction of heterogeneous and distributed specifications. This paper focuses on the part of work devoted to the distribution aspects of a specification, especially the distributed specifications consistency and management. It describes our approach to deal with these two aspects. Regarding the distributed specifications consistency, we advocate that the modeling language must enable the partitioning of the specification into several pieces and provide means to express the dependencies between them. For this reason, we make use of RM-ODP language as it includes some concepts that fit these requirements. However, RM-ODP is not prescriptive enough to be really helpful when elaborating distributed specifications. Thus we propose distributed specifications construction rules in identifying the needed concepts and in\u00a0\u2026", "num_citations": "3\n", "authors": ["77"]}
{"title": "Schedulability Analysis of Real-time Tasks with Precedence Constraints.\n", "abstract": " The timing requirements of real-time systems can be guaranteed by the well-designed scheduling. The analysis of such scheduling inputs an abstract task model of the system and outputs a diagnostic regarding the practicability of the timing requirements. Task models have evolved from periodic models to more sophisticated graph-based ones, among which the digraph real-time (DRT) task model is the most applicable because of its good expressiveness and analysis efficiency. However, the DRT model can\u2019t support the precedence constraints within or between tasks. In this paper, we propose a new task model, called the DRTPC model, that extends the DRT model to support the precedence constraint. Further, based on our model, we present a uniprocessor schedulability analysis algorithm for the static priority scheduling, and introduce an optimization technique to improve the analysis efficiency. Our experiments show that, despite the high computational complexity of the problem, our approach scales very well for large sets of tasks with precedence constraints.", "num_citations": "2\n", "authors": ["77"]}
{"title": "A Comparison of the Basic DO concepts in Standardization\n", "abstract": " The paper provides a comparison of the basic DO (distributed object) concepts, namely \"object\", \"instance\" and \"class\" used in various standards of the DO world. Two families of standards are identified: those related to the modelling aspects (MOF and UML) and those related to the architectural and implementation aspects (CORBA and Java). Moreover, the RM-ODP standard is considered as it includes both aspects. The objective is to help out with a common understanding of these concepts. For this, we compare these concepts as defined in these standards according to the four layer architecture proposed by the MOF standard. An example is provided to illustrate the comparison.", "num_citations": "2\n", "authors": ["77"]}
{"title": "Web Services\n", "abstract": " Dans le contexte du module SAR6 Internet et technologies Web nous avons \u00e9t\u00e9 amen\u00e9a proposer une sp\u00e9cification d\u2019un service web appliqu\u00e9a un projet concret relatifa l\u2019ESSI eta ses \u00e9tudiants. Les trois principaux buts de ce projet sont: tout d\u2019abord appr\u00e9hender l\u2019utlit\u00e9 et l\u2019utilisation d\u2019un modele conceptuel de sp\u00e9cifications de web services en WSDL sur XML. Le second, moins ax\u00e9 technologies de l\u2019Internet, permet de proposer des sp\u00e9cifications d\u2019un service tel qu\u2019un client pourrait le demander en fournissant un cahier des charges. Le troisieme permettra de r\u00e9alisera long terme une implantation du service.Ce document propose dans une premiere partie une description des web services au travers de cas d\u2019utilisateurs. Dans la seconde partie, nous pr\u00e9senterons une application Internet sujettea une description de services web. Le sujet porte sur les phases de notification de bugs souvent laiss\u00e9es de c\u00f4t\u00e9 faute de temps. La derniere partie est consacr\u00e9ea la d\u00e9finition en WSDL de quelques \u00e9l\u00e9ments significatifs de l\u2019application afin de proposer une architecture logicielle.", "num_citations": "2\n", "authors": ["77"]}
{"title": "Fostering the Diversity of Exploratory Testing in Web Applications\n", "abstract": " Exploratory testing (ET) is a software testing approach that complements automated testing by leveraging business expertise. It has gained momentum over the last decades as it appeals testers to exploit their business knowledge to stress the system under test (SUT). Exploratory tests, unlike automated tests, are defined and executed on-the-fly by testers. Testers who perform exploratory tests may be biased by their past experience and therefore may miss anomalies or unusual interactions proposed by the SUT. This is even more complex in the context of web applications, which typically expose a huge number of interaction paths to their users. As testers of these applications cannot remember all the sequences of interactions they performed, they may fail to deeply explore the application scope. This paper therefore introduces a new approach to assist testers in widely exploring any web application. In particular, our\u00a0\u2026", "num_citations": "1\n", "authors": ["77"]}
{"title": "Schedulability analysis of graph-based real-time task model with precedence constraints\n", "abstract": " The timing requirements of real-time systems can be guaranteed by well-designed scheduling policies. The analysis of such scheduling uses an abstract task model of the system to diagnose the practicability of timing requirements. The task models have evolved from periodic models to more sophisticated graph-based ones, among which digraph real-time (DRT) task model is the most applicable because of its good expressiveness and analysis efficiency. However, the DRT model cannot support the commonly used precedence constraints within or between tasks. In this paper, we propose a new task model that extends the DRT model to support precedence constraints. Based on our model, we present two methods of uniprocessor schedulability analysis for static priority scheduling policy and earliest deadline first (EDF) scheduling policy. We also introduce an optimization technique to improve the efficiency of\u00a0\u2026", "num_citations": "1\n", "authors": ["77"]}
{"title": "Towards a Full Specification and Use of Overlap Relationships between Work Products in MDE Software Processes\n", "abstract": " In this paper we address the problem of modelling and using overlap relationships between process workproducts. In fact, in the current MDE context, the nature of software processes has drastically changed; they involve workproducts which are essentially large-sized models with lots of relationships of different kinds. Particularly, we have focused on the overlap relationship which consists in sharing model elements between process workproducts. First, we show that if such relationship is completely specified during process modelling, then process engines are able to use it to ensure a more optimized workproducts management which is not supported by current process management approaches. Then we present our software process modelling and execution approach and describe the prototype of PSEE we have developed to show its feasibility.", "num_citations": "1\n", "authors": ["77"]}
{"title": "An experimental study of a design-driven, tool-based development approach\n", "abstract": " Design-driven software development approaches have long been praised for their many benefits on the development process and the resulting software system. This paper discusses a step towards assessing these benefits by proposing an experimental study that involves a design-driven, tool-based development approach. This study raises various questions including whether a design-driven approach improves software quality and whether the tool-based approach improves productivity. In examining these questions, we explore specific issues such as the approaches that should be involved in the comparison, the metrics that should be used, and the experimental framework that is required.", "num_citations": "1\n", "authors": ["77"]}
{"title": "Vide ModelBus: Environnement r\u00e9parti de d\u00e9veloppement\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "1\n", "authors": ["77"]}
{"title": "Transformations de mod\u00e8les UML outill\u00e9es: Retour d'exp\u00e9riences\n", "abstract": " Dans cet article nous montrons comment le m\u00e9canisme de la collaboration param\u00e9tr\u00e9e d'UML 2.0 peut \u00eatre utilis\u00e9 pour la sp\u00e9cification visuelle des transformations de mod\u00e8les UML. Nous pr\u00e9sentons les avantages de cette nouvelle technique d'\u00eatre visuelle et d\u00e9clarative par rapport aux techniques classiques de sp\u00e9cification de transformations bas\u00e9es sur les langages propri\u00e9taires, ainsi qu'au futur standard Q/V/T1. Une illustration est faite \u00e0 travers la r\u00e9alisation d'un exemple de transformation de models UML vers la plate-forme J2EE. Nous pr\u00e9sentons aussi les limitations de la nouvelle technique d'\u00eatre restreinte aux mod\u00e8les UML. Notre impl\u00e9mentation est r\u00e9alis\u00e9e dans le contexte de l'atelier UML Objecteering.", "num_citations": "1\n", "authors": ["77"]}
{"title": "Services de mod\u00e9lisation et Web Services Application sur le ModelBus\n", "abstract": " La publication par l'OMG (Object Management Group) de sa nouvelle ligne directrice Model Driven Architecture (MDA) a propuls\u00e9 les mod\u00e8les au coeur du processus de d\u00e9veloppement des applications r\u00e9parties. Un objectif majeur du MDA est de rendre les mod\u00e8les productifs via l'automatisation des \u00e9tapes du cycle de d\u00e9veloppement, assur\u00e9e par diff\u00e9rents services de mod\u00e9lisation (ex. \u00e9dition, transformation, v\u00e9rification). Appara\u00eet alors la n\u00e9cessit\u00e9 de disposer d'environnement de d\u00e9veloppement int\u00e9gr\u00e9 orient\u00e9 mod\u00e8le (iMDDE: integrated Model Driven Development Environment). Consid\u00e9rant la pr\u00e9existence d'outils de mod\u00e9lisation qu'il conviendrait de r\u00e9utiliser, nous pr\u00e9conisons une solution fond\u00e9e sur un ensemble ouvert d'outils offrant chacun des services de mod\u00e9lisation. Se pose alors un probl\u00e8me d'interop\u00e9rabilit\u00e9 entre les services de mod\u00e9lisation. Pour y r\u00e9pondre, nous avons propos\u00e9 ModelBus, une approche g\u00e9n\u00e9rique pour la construction d'iMDDE fond\u00e9e sur l'adaptation de plates-formes d'ex\u00e9cution existantes, pour assurer la prise en compte des mod\u00e8les. Nous pr\u00e9sentons dans ce papier les techniques d\u2019adaptation de la plate-forme Web Services. Un prototype a \u00e9t\u00e9 r\u00e9alis\u00e9 avec la plate-forme Axis d'Apache et Eclipse Modeling Framework (EMF).OMG\u2019s Model Driven Architecture (MDA) emphasizes on using models in the software development life cycle. The main objective is the productivity via the automation of development life cycle using modeling services (eg model edition, transformation, verification\u2026). This leads to the needs of an integrated Model Driven Environment (iMDDE) enabling various modeling services to\u00a0\u2026", "num_citations": "1\n", "authors": ["77"]}
{"title": "Information System architecture with RM-ODP: an on-the-field experience.\n", "abstract": " If companies want to be competitive they undoubtedly have to manage IS evolution. One of the key features is then IS architecture. EDF, the French state utility, has developed its own architecture driven method for IS evolution. It defines prescriptive processes, models and concepts. But EDF wants now to give a more thorough basis to its home-made method by using the concepts defined by the ISO RM-ODP standard. This article presents a work that is still ongoing aiming to elaborate a mapping between EDF concepts and RM-ODP ones. The goal is to translate EDF models into RM-ODP ones and gradually introduce RM-ODP at EDF.", "num_citations": "1\n", "authors": ["77"]}
{"title": "Traduction de m\u00e9ta-mod\u00e8les\n", "abstract": " Archive ouverte HAL - Traduction de m\u00e9ta-mod\u00e8les Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01570703, version 1 Communication dans un congr\u00e8s Traduction de m\u00e9ta-mod\u00e8les Nicolas Revault Xavier Blanc 1 Jean-Fran\u00e7ois Perrot 2 D\u00e9tails 1 SRC - Syst\u00e8mes r\u00e9partis et coop\u00e9ratifs LIP6 - Laboratoire d'Informatique de Paris 6 2 OASIS - Objets et Agents pour Syst\u00e8mes d'Information et Simulation LIP6 - Laboratoire d'Informatique de Paris 6 Type de document : Communication dans un congr\u00e8s : [cs] \u2026", "num_citations": "1\n", "authors": ["77"]}