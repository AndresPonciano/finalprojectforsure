{"title": "Selecting fault tolerant styles for third-party components with model checking support\n", "abstract": " To build highly available or reliable applications out of unreliable third-party components, some software-implemented fault-tolerant mechanisms are introduced to gracefully deal with failures in the components. In this paper, we address an important issue in the approach: how to select the most suitable fault-tolerant mechanisms for a given application in a specific context. To alleviate the difficulty in the selection, these mechanisms are abstracted as Fault-tolerant styles (FTSs) at first, which helps to achieve required high availability or reliability correctly because the complex interactions among functional parts of software and fault-tolerant mechanism are explicitly modeled. Then the required fault-tolerant capabilities are specified as fault-tolerant properties, and the satisfactions of the required properties for candidate FTSs are verified by model checking. Specifically, we take application-specific constraints\u00a0\u2026", "num_citations": "24\n", "authors": ["656"]}
{"title": "Composition of monitoring components for on-demand construction of runtime model based on model synthesis\n", "abstract": " Monitoring functionality is implemented and provided as infrastructure of most software platforms and applications. However, the construction of system model cannot be achieved by directly composing runtime model of different applications. First, models which conform to different meta-models cannot be directly composed. Second, the abstract of a system may be different from different viewpoint. Finally, the relationships between systems are different from different abstract viewpoint. In this paper, we propose a DSL (Domain Specific Language) for composition of monitoring components. The DSL distinguish component definition and instance clearly in order to enables reuse of monitoring component. Based on the component composition, the meta-model of target runtime model is generated. We developed an algorithm to generate model transformation for synthesizing runtime models of its applications. In the\u00a0\u2026", "num_citations": "11\n", "authors": ["656"]}
{"title": "Automatically detecting the scopes of source code comments\n", "abstract": " Comments convey useful information about the system functionalities and many methods for software engineering tasks take comments as an important source for many software engineering tasks such as code semantic analysis, code reuse and so on. However, unlike structural doc comments, it is challenging to identify the relationship between the functional semantics of the code and its corresponding textual descriptions nested inside the code and apply it to automatic analyzing and mining approaches in software engineering tasks efficiently.In this paper, we propose a general method for the detection of source code comment scopes. Based on machine learning, our method utilized features of code snippets and comments to detect the scopes of source code comments automatically in Java programs. On the dataset of comment-statement pairs from 4 popular open source projects, our method achieved a high\u00a0\u2026", "num_citations": "10\n", "authors": ["656"]}
{"title": "A probabilistic neural network-based approach for related software changes detection\n", "abstract": " Current softwares are continuously updating. The change between two versions usually involves multiple program entities (e.g., Class, method, attribute) with multiple purposes (e.g., Changed requirements, bug fixing). It's hard for developers to understand which changes are made for the same purpose. However, whether two changes are related is not decided by the relationship between this two entities in the program. In this paper, we summarize 4 coupling rules (16 instances) and 4 co-changed types at class, method and attribute levels for software change. We propose the Related Change Vector (RCV) to characterize the related changes, which is defined based on the coupling rules and co-changed types. Probabilistic neural network is used to detect related software changes with RCV as input. Our approach is evaluated with experiments on 3 software projects (14 versions) written in Java. The results\u00a0\u2026", "num_citations": "10\n", "authors": ["656"]}
{"title": "Automaticly Generating Web Page From A Mockup.\n", "abstract": " Considering the complexity of web UI, generating the web page from a mockup proposes requirements for rich experience of developer. Extracting visible elements and their relationship, selecting proper tags, generating source code are time-consuming and error-prone task. In this paper, we propose a method to automate the transforming of the mockup to the web page. Our approach starts from the mockup designed by the art designers, and extracts the elements based on the color features of the edges. Then a bottom-up tag generating method based on the Random Forest is proposed to select the tags for elements. Finally the web page is generated by the definition of the elements. The generating tags can achieve an average accuracy of more than 84%, which can meet the basic requirements of the developers.", "num_citations": "6\n", "authors": ["656"]}
{"title": "A platform for searching UI component of android application\n", "abstract": " Android applications are becoming increasingly popular in digital home nowadays. Building high quality application is still one of biggest changes for Android developer community. The search service in current Android application market can't meet the needs of developers when trying to find the user interface design in other applications. In this paper, we introduce a platform to query the runtime user interfaces of Android applications, which can help developers to reuse the design components to improve their applications. Based on the description information of 8,456 Android applications in Android market and the information of runtime 313,820 UI elements, we implement the platform providing search service for developers to find specified runtime user interfaces in our Android software repository. Our experiment for the quality of search result shows that 76.7% of top-10 search result contains the relevant UI\u00a0\u2026", "num_citations": "6\n", "authors": ["656"]}
{"title": "Does your code need comment?\n", "abstract": " Code comments convey information about the programmers' intention in a more explicit but less rigorous manner than source code. This information can assist programmers in various tasks, such as code comprehension, reuse, and maintenance. To better understand the properties of the comments existing in the source code, we analyzed more than 450\u2009000 comments across 136 popular open\u2010source software systems coming different domains. We found that the methods involving header comments and internal comments were shown low percentages in software systems, ie, 4.4% and 10.27%, respectively. As an application of our findings, we propose an automatic approach to determine whether a method needs a header comment, known as commenting necessity identification. Specifically, we identify the important factors for determining the commenting necessity of a method and extract them as structural\u00a0\u2026", "num_citations": "5\n", "authors": ["656"]}
{"title": "Automatic Color Modification for Web Page Based on Partitional Color Transfer\n", "abstract": " Designing or modifying the color of a website is a time-consuming and difficult task for most software engineers. The idea of this paper is inspired by the color transfer methods proposed for automatically alter an image\u2019s color during image processing. The color of a web page can be modified by reusing color characteristic of a reference page. However, a web page cannot be simply viewed as an image because it has structure and constraints for color modifying. In this paper, we propose an approach for automatic color modification of web page based on partitional color transfer. Our approach starts from the clustering of visible UI elements for page partition. And then, elements in the source page are color transferred with their matched elements in the reference page. Our approach automatically modifies the color of web pages based on the color transfer result. We generate 72 modified web pages to\u00a0\u2026", "num_citations": "5\n", "authors": ["656"]}
{"title": "Pattern-Discovery-Based Response Time Prediction\n", "abstract": " Response time is one of the most important metrics quality of service and response time prediction has always been the a hot topic. Based on random process, there are many common methods for predicting response. However, we find that there are also some features of response time data of service running. According to these features, we summarize the the patterns of response time and propose a novel algorithm for predicting response time. To evaluate our algorithm, we compare PIPA with other algorithms. Experimental results show that PIPA can efficiently improve the accuracy of the prediction.", "num_citations": "5\n", "authors": ["656"]}
{"title": "Using Touchable Tabletop as Unified Control Platform in Digital Home\n", "abstract": " Nowadays the popularity of the digital home concept and the types of household electronical appliances have significantly increased. But due to standalone interfaces bound to different manufactures, controlling in digital home becomes messy. So it is important to find a new way of controlling process in digital home. This paper puts forward the design and implementation of a unified control platform using touchable tabletop as a solution. The touchable controlling pattern provides friendly user experience. And the unified management makes the home appliances operate in an orderly manner. We aim at providing an effective option and reference to general design of controlling and managing household appliances in digital home.", "num_citations": "4\n", "authors": ["656"]}
{"title": "Using QoS-Contracts to Drive Architecture-Centric Self-adaptation\n", "abstract": " Self-adaptation is now a promising approach to maximize the satisfaction of requirements under changing environmental conditions. One of the key challenges for such self-adaptive systems is to automatically find a relevant architectural configuration. Existing approaches requires a set of adaptation strategies and the rough estimation of their side-effects. However, due to the lack of validation methods for such strategies and side-effects, existing approaches may lead to erroneous adaptations. Instead of side-effects, our solution leverages quality contracts whose accuracy can be separately established and which can be dynamically composed to get a quality prediction of any possible architectural configurations. To support self-adaptation, we propose a reactive planning algorithm which exploits quality contracts to dynamically discover unforeseen architectural configurations. We illustrate our approach\u00a0\u2026", "num_citations": "4\n", "authors": ["656"]}
{"title": "Towards automatic verification of web-based SOA applications\n", "abstract": " Nowadays, developing web applications in a Service-Oriented Architecture (SOA) style is emerging as a promising approach for delivering services to end users. Such web-based SOA applications are likely to suffer correctness and reliability problems mainly because their runtime environments (including web browsers and service platforms) are heterogeneous and their service interactions and flows are complex without explicit specifications. In this paper, we propose a model-checking based approach for verifying web-based SOA applications. At first, the application behavior will be automatically specified by analyzing the web-side source codes. And it will be combined with the pre-defined environment behavior so that a precise and complete enough behavior model of the application can be generated automatically. With user-defined constraint and refinement specifications, the behavior model is\u00a0\u2026", "num_citations": "4\n", "authors": ["656"]}
{"title": "A framework for the integration of MOF-compliant analysis methods\n", "abstract": " With the increasing maturity of model-driven tools and methods, new model-based analysis methods are developed to support specific stakeholder concerns during software lifecycle. This multiplication of models and their related analysis tools calls for solution addressing the integration of MOF-based analysis methods. Current research works on integration of analysis methods have already addressed the extraction of the needed input data as well as the control and the integration of the tools supporting the analysis execution. However, little attention has been paid to the integration of analysis results back into initial model. We propose a MOF-based framework enabling the integration of analysis results that a) defines a meta-model capturing the integration requirements, b) provides a MOF meta-model extension mechanism with support for upward compatibility; and c) automatically generates a model\u00a0\u2026", "num_citations": "3\n", "authors": ["656"]}
{"title": "Generating Summarized Preview for Education Resource based on Exploring and Comparing GUIs.\n", "abstract": " Interactive Education Resource (IER) includes dynamic content to interact with users in order to enhance comprehension. The contents of IERs are relatively complex because of its dynamic feature. Exploring IERs and understanding its content during resource search become time-consuming. In this paper, we propose a preview generation approach based on automated software testing and image processing. Our approach first analyzes IERs to collect interactive elements and the event list. Based on the interaction related information, our approach simulates user actions and record snapshots step by step. Our approach compares snapshots to generate an image including the basic content, interaction region and dynamic contents. The image is used as the overall preview and the animation of snapshots collected during simulation is used as detail preview of the IER. In the experiment, we evaluate the completeness, correctness, and comprehension of the preview. The experiment result shows that the preview can be used to provide most information in the resource correctly and easy to understand. Our approach can save time for users in understanding the IERs.", "num_citations": "2\n", "authors": ["656"]}
{"title": "Consistency assurance in flattening hierarchical architectural models\n", "abstract": " Composite components are components that have internal structures. Supported by almost all architecture description languages, composite components can organize architectural models in a hierarchical structure. However, most analysis and verification tools for SA model do not support composite components, neither do most component frameworks. Therefore, it is necessary to flatten the hierarchical SA model sothat SA can play a more important role in practice. The most challenging issue in the flattening is how to assure the consistency between architectural models with and without composite components. In this paper, a formal definition of the consistency of an SA model is presented. Based on that, principles and guidelines for consistency assurance in flattening a hierarchical SA model are provided. Their feasibilityis exemplified by a componentized email client.", "num_citations": "2\n", "authors": ["656"]}
{"title": "Would the Patch Be Quickly Merged?\n", "abstract": " Code review is one of the most time-consuming and costly activities in modern software development. For the code submissions that can not be accepted by reviewers, developers need to re-modify the code again. Developers desire to minimize the time-cost that spends in the code review process. In some cases, a submission might be submitted many times and still not be accepted. The number of review times has serious implications for defect repairs and the progress of development. Therefore, a few recent studies focused on discussing factors that effect submission acceptance, while these prior studies did not try to predict submission acceptance or the number of review times. In this paper, we propose a novel method to predict the time-cost in code review before a submission is accepted. Our approach uses a number of features, including review meta-features, code modifying features and code coupling\u00a0\u2026", "num_citations": "1\n", "authors": ["656"]}
{"title": "Example-based web page recoloring method\n", "abstract": " The user interface (UI) is very important for a software product, and a well-designed UI will attract users and make a good impression. It has been shown that color plays an important role in invoking emotional reactions [1], influencing usability [2], forming first impressions [3], and affecting the energy cost of the UI [4]. Generating satisfying color schemes has high requirements for experience, aesthetic, and creative inspiration of designers [5].Reusing real web page\u2019s colors to recolor a web page contains a serious of tedious processes [6]. First, some elements in a web page have semantical relations which should have the same recoloring strategy to keep the relations. Second, the developer needs to figure out what color the element should have in the recoloring result, which requires a mapping between the two web page\u2019s elements. After that, a set of elements should be recolored with the matching elements\u00a0\u2026", "num_citations": "1\n", "authors": ["656"]}
{"title": "User Interface Layout Recommendation Based on Pairing Model\n", "abstract": " In order to facilitate the generation of user interfaces from mockups, an approach was proposed to recommend User Interface (UI) layout based on Pairing Model. The absolute layout data of interfaces, including types, text, positions and sizes of components, are input into the model to generate layout. Paring Model is trained by machine-learning algorithms with features extracted from UI galleries. On the levels of functional and spatial relationship, the model decides pairing of input components and recommends a suitable layout. With use of component features, by machine-learning algorithms, the types of components are identified, which are the leaf nodes of the output layout hierarchy. The experiments on 3362 interface instances from 800 open source apps proved that the accuracy of the proposed approach, on average, exceeds 90%.", "num_citations": "1\n", "authors": ["656"]}
{"title": "Topic Matching Based Change Impact Analysis from Feature on User Interface of Mobile Apps.\n", "abstract": " The complexity of mobile applications often lies in the user interface (UI). To update function provided by UI or just fix bugs related to UI, software maintainers primarily need to obtain the location of source code implementation and detect change set. Since UI related feature is tightly related to the class containing the declaration of the UI component, this paper proposes a topic matching based change impact analysis method from feature on user interface of mobile apps. Our approach combines LDA model with program dependency to realize the change impact analysis. Considering app\u2032 s small scale and few comments, a novel preprocessing method combining tf-idf with term weight based on structural information is applied to LDA model. Experiments on 16 update records of 4 open source apps show the effectiveness of our proposed method.", "num_citations": "1\n", "authors": ["656"]}
{"title": "MOF based framework for integration of software architecture analysis results\n", "abstract": " In software adaptation, multiple analysis methods are used for analyzing system, planning adaptation strategy, and decision-making. Because the analysis results are interpreted and understood with SA(software architecture) model as context, synthesizing analysis results and the SA model become important. However, current researches on integration of analysis methods do not pay enough attention to the integrating analysis result with the SA model. Considering integration challenges existing in meta-model, model, and view levels, this study proposes an MOF(meta-object facility)-based framework for integration of analysis results. The framework provides the following: An ADL(architectural description language) extension mechanism with support for upward compatibility; automatic generation of model transformation for model synthesis, and code generation to extend modeling tool for view of synthesized\u00a0\u2026", "num_citations": "1\n", "authors": ["656"]}