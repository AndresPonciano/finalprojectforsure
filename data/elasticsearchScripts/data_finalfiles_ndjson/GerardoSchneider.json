{"title": "A formal language for electronic contracts\n", "abstract": " In this paper we propose a formal language for writing electronic contracts, based on the deontic notions of obligation, permission, and prohibition. We take an ought-to-do approach, where deontic operators are applied to actions instead of state-of-affairs. We propose an extension of the \u03bc-calculus in order to capture the intuitive meaning of the deontic notions and to express concurrent actions. We provide a translation of the contract language into the logic, the semantics of which faithfully captures the meaning of obligation, permission and prohibition. We also show how our language captures most of the intuitive desirable properties of electronic contracts, as well as how it avoids most of the classical paradoxes of deontic logic. We finally show its applicability on a contract example.", "num_citations": "122\n", "authors": ["1653"]}
{"title": "Differential privacy: Now it's getting personal\n", "abstract": " Differential privacy provides a way to get useful information about sensitive data without revealing much about any one individual. It enjoys many nice compositionality properties not shared by other approaches to privacy, including, in particular, robustness against side-knowledge. Designing differentially private mechanisms from scratch can be a challenging task. One way to make it easier to construct new differential private mechanisms is to design a system which allows more complex mechanisms (programs) to be built from differentially private building blocks in principled way, so that the resulting programs are guaranteed to be differentially private by construction. This paper is about a new accounting principle for building differentially private programs. It is based on a simple generalisation of classic differential privacy which we call Personalised Differential Privacy (PDP). In PDP each individual has its own\u00a0\u2026", "num_citations": "102\n", "authors": ["1653"]}
{"title": "A dynamic deontic logic for complex contracts\n", "abstract": " We present a dynamic deontic logic for specifying and reasoning about complex contracts. The concepts that our contract logic CL captures are drawn from legal contracts, as we consider that these are more general and expressive than what is usually found in computer science (like in software contracts, web services specifications, or communication protocols). CL is intended to be used in specifying complex contracts found in computer science. This influences many of the design decisions behind CL. We adopt an ought-to-do approach to deontic logic and apply the deontic modalities exclusively over complex actions. On top, we add the modalities of dynamic logic so to be able to reason about what happens after an action is performed. CL can reason about regular synchronous actions capturing the notion of actions done at the same time. CL incorporates the notions of contrary-to-duty and contrary-to\u00a0\u2026", "num_citations": "58\n", "authors": ["1653"]}
{"title": "Widening the Boundary between Decidable and Undecidable Hybrid Systems*\n", "abstract": " We revisited decidability of the reachability problem for low dimensional hybrid systems. Even though many attempts have been done to draw the boundary between decidable and undecidable hybrid systems there are still many open problems in between. In this paper we show that the reachability question for some two dimensional hybrid systems are undecidable and that for other 2-dim systems this question remains unanswered, showing that it is as hard as the reachability problem for Piecewise Affine Maps, that is a well known open problem.", "num_citations": "47\n", "authors": ["1653"]}
{"title": "Run-time monitoring of electronic contracts\n", "abstract": " Electronic inter-organizational relationships are governed by contracts regulating their interaction, therefore it is necessary to run-time monitor the contracts, as to guarantee their fulfillment. The present work shows how to obtain a run-time monitor for contracts written in , a formal specification language which allows to write conditional obligations, permissions, and prohibitions over actions. The trace semantics of  formalizes the notion of a trace fulfills a contract. We show how to obtain, for a given contract, an alternating B\u00fcchi automaton which accepts exactly the traces that fulfill the contract. This automaton is the basis for obtaining a finite state machine which acts as a run-time monitor for  contracts.", "num_citations": "46\n", "authors": ["1653"]}
{"title": ": An Action-Based Logic for Reasoning about Contracts\n", "abstract": " This paper presents a new version of the  contract specification language.  combines deontic logic with propositional dynamic logic but it applies the modalities exclusively over structured actions.  features synchronous actions, conflict relation, and an action negation operation. The  version that we present here is more expressive and has a cleaner semantics than its predecessor. We give a direct semantics for  in terms of normative structures. We show that  respects several desired properties from legal contracts and is decidable. We relate this semantics with a trace semantics of  which we used for run-time monitoring contracts.", "num_citations": "42\n", "authors": ["1653"]}
{"title": "On the expressiveness of infinite behavior and name scoping in process calculi\n", "abstract": " In the literature there are several CCS-like process calculi differing in the constructs for the specification of infinite behavior and in the scoping rules for channel names. In this paper we study various representatives of these calculi based upon both their relative expressiveness and the decidability of divergence. We regard any two calculi as being equally expressive iff for every process in each calculus, there exists a weakly bisimilar process in the other.               By providing weak bisimilarity preserving mappings among the various variants, we show that in the context of relabeling-free and finite summation calculi: (1) CCS with parameterless (or constant) definitions is equally expressive to the variant with parametric definitions. (2) The CCS variant with replication is equally expressive to that with recursive expressions and static scoping. We also state that the divergence problem is undecidable for the\u00a0\u2026", "num_citations": "40\n", "authors": ["1653"]}
{"title": "A formal privacy policy framework for social networks\n", "abstract": " Social networks (SN) provide a great opportunity to help people interact with each other in different ways depending on the kind of relationship that links them. One of the aims of SN is to be flexible in the way one shares information, being as permissive as possible in how people communicate and disseminate information. While preserving the spirit of SN, users would like to be sure that their privacy is not compromised. One way to do so is by providing users with means to define their own privacy policies and give guarantees that they will be respected. In this paper we present a privacy policy framework for SN, consisting of a formal model of SN, a knowledge-based logic, and a formal privacy policy language. The framework may be tailored by providing suitable instantiations of the different relationships, the events, the propositions representing what is to be known, and the additional facts or rules a\u00a0\u2026", "num_citations": "37\n", "authors": ["1653"]}
{"title": "A privacy-aware conceptual model for handling personal data\n", "abstract": " Handling personal data adequately is one of the biggest challenges of our era. Consequently, law and regulations are in the process of being released, like the European General Data Protection Regulation (GDPR), which attempt to deal with these challenging issue early on. The core question motivating this work is how software developers can validate their technical design vis-a-vis the prescriptions of the privacy legislation. In this paper, we outline the technical concepts related to privacy that need to be taken into consideration in a software design. Second, we extend a popular design notation in order to support the privacy concepts illustrated in the previous point. Third, we show how some of the prescriptions of the privacy legislation and standards may be related to a technical design that employs our enriched notation, which would facilitate reasoning about compliance.", "num_citations": "36\n", "authors": ["1653"]}
{"title": "Precise analysis of memory consumption using program logics\n", "abstract": " Memory consumption policies provide a means to control resource usage on constrained devices, and play an important role in ensuring the overall quality of software systems, and in particular resistance against resource exhaustion attacks. Such memory consumption policies have been previously enforced through static analysis, which yield automatic bounds at the cost of precision, or run-time analysis, which incur an overhead that is not acceptable for constrained devices. In this paper, we study the use of logical methods to specify and statically verify precise memory consumption policies for Java bytecode programs. First, we demonstrate how the bytecode specification language (a variant of the Java modelling language tailored to bytecode) can be used to specify precise memory consumption policies for (sequential) Java applets, and how verification tools can be used to enforce such memory consumption\u00a0\u2026", "num_citations": "35\n", "authors": ["1653"]}
{"title": "A model for visual specification of e-contracts\n", "abstract": " In a web service composition, an electronic contract (e-contract) regulates how the services participating in the composition should behave, including the restrictions that these services must fulfill, such as real-time constraints. In this work we present a visual model that allows us to specify e-contracts in a user friendly way, including conditional behavior and realtime constraints. A case study is presented to illustrate how this visual model defines e-contracts and a preliminary evaluation of the model is also done.", "num_citations": "34\n", "authors": ["1653"]}
{"title": "Monitoring hyperproperties by combining static analysis and runtime verification\n", "abstract": " Hyperproperties are properties whose reasoning involve sets of traces. Examples of hyperproperties include information-flow security properties, properties of coding/decoding systems, linearizability and other consistency criteria, as well as privacy properties like data minimality. We study the problem of runtime verification of hyperproperties expressed as HyperLTL formulas that involve quantifier alternation. We first show that even for a simple class of temporal formulas, virtually no  property can be monitored, independently of the observations performed. To manage this problem, we propose to use a combination of static analysis with runtime verification. By using static analysis/verification, one typically obtains a model of the system that allows to limit the source of \u201chypothetical\u201d traces to a sound over-approximation of the traces of the system. This idea allows to extend the effective monitorability of\u00a0\u2026", "num_citations": "30\n", "authors": ["1653"]}
{"title": "Low dimensional hybrid systems\u2013decidable, undecidable, don\u02bct know\n", "abstract": " Even though many attempts have been made to define the boundary between decidable and undecidable hybrid systems, the affair is far from being resolved. More and more low dimensional systems are being shown to be undecidable with respect to reachability, and many open problems in between are being discovered. In this paper, we present various two-dimensional hybrid systems for which the reachability problem is undecidable. We show their undecidability by simulating Minsky machines. Their proximity to the decidability frontier is understood by inspecting the most parsimonious constraints necessary to make reachability over these automata decidable. We also show that for other two-dimensional systems, the reachability question remains unanswered, by proving that it is as hard as the reachability problem for piecewise affine maps on the real line, which is a well known open problem.", "num_citations": "30\n", "authors": ["1653"]}
{"title": "Safe runtime verification of real-time properties\n", "abstract": " Introducing a monitor on a system typically changes the system\u2019s behaviour by slowing the system down and increasing memory consumption. This may possibly result in creating new bugs, or possibly even \u2018fixing\u2019 bugs, only to reappear as the monitor is removed. Properties written in a real-time logic, such as duration calculus, can be particularly sensitive to such changes induced through monitoring. The same problem occurs in other scenarios such as when a system is ported to a faster machine. In this paper, we identify a class of real-time properties, in duration calculus, which are monotonic under the slowing down (speeding up) of the underlying system. We apply this approach to the real-time runtime monitoring tool Larva, where we use duration calculus as a monitoring property specification language, so we automatically identify properties which can be shown to be monotonic with respect to system\u00a0\u2026", "num_citations": "27\n", "authors": ["1653"]}
{"title": "A framework for conflict analysis of normative texts written in controlled natural language\n", "abstract": " In this paper we are concerned with the analysis of normative conflicts, or the detection of conflicting obligations, permissions and prohibitions in normative texts written in a Controlled Natural Language (CNL). For this we present AnaCon, a proof-of-concept system where normative texts written in CNL are automatically translated into the formal language CL using the Grammatical Framework (GF). Such CL expressions are then analysed for normative conflicts by the CLAN tool, which gives counter-examples in cases where conflicts are found. The framework also uses GF to give a CNL version of the counter-example, helping the user to identify the conflicts in the original text. We detail the application of AnaCon to two case studies and discuss the effectiveness of our approach.", "num_citations": "26\n", "authors": ["1653"]}
{"title": "Gray-box monitoring of hyperproperties\n", "abstract": " Many important system properties, particularly in security and privacy, cannot be verified statically. Therefore, runtime verification is an appealing alternative. Logics for hyperproperties, such as HyperLTL, support a rich set of such properties. We first show that black-box monitoring of HyperLTL is in general unfeasible, and suggest a gray-box approach. Gray-box monitoring implies performing analysis of the system at run-time, which brings new limitations to monitorability (the feasibility of solving the monitoring problem). Thus, as another contribution of this paper, we refine the classic notions of monitorability, both for trace properties and hyperproperties, taking into account the computability of the monitor. We then apply our approach to monitor a privacy hyperproperty called distributed data minimality, expressed as a HyperLTL property, by using an SMT-based static verifier at runtime.", "num_citations": "25\n", "authors": ["1653"]}
{"title": "Towards a formal semantics of verilog using duration calculus\n", "abstract": " We formalise the semantics of V               \u2212, a simple version of Verilog hardware description language using an extension of Duration Calculus. The language is simple enough for experimenting formalisation, but contains sufficient features for being practically relevant. V               \u2212 programs can exhibit a rich variety of computations, and it is therefore necessary to extend Duration Calculus with several features, including Weakly Monotonic Time, infinite intervals and fixed point operators. The semantics is compositional and can be used as the formal basis of a formal theory of Verilog.", "num_citations": "24\n", "authors": ["1653"]}
{"title": "Specification and verification of normative texts using CO diagrams\n", "abstract": " C-O diagrams have been introduced as a means to have a more visual representation of normative texts and electronic contracts, where it is possible to represent the obligations, permissions and prohibitions of the different signatories, as well as the penalties resulting from non-fulfillment of their obligations and prohibitions. In such diagrams we are also able to represent absolute and relative timing constraints. In this paper we present a formal semantics for C-O diagrams based on timed automata extended with information regarding the satisfaction and violation of clauses in order to represent different deontic modalities. As a proof of concept, we apply our approach to two different case studies, where the method presented here has successfully identified problems in the specification.", "num_citations": "22\n", "authors": ["1653"]}
{"title": "A CNL for contract-oriented diagrams\n", "abstract": " We present a first step towards a framework for defining and manipulating normative documents or contracts described as Contract-Oriented (C-O) Diagrams. These diagrams provide a visual representation for such texts, giving the possibility to express a signatory\u2019s obligations, permissions and prohibitions, with or without timing constraints, as well as the penalties resulting from the non-fulfilment of a contract. This work presents a CNL for verbalising C-O Diagrams, a web-based tool allowing editing in this CNL, and another for visualising and manipulating the diagrams interactively. We then show how these proof-of-concept tools can be used by applying them to a small example.", "num_citations": "21\n", "authors": ["1653"]}
{"title": "Algorithmic analysis of polygonal hybrid systems\n", "abstract": " Algorithmic Analysis of Polygonal Hybrid Systems Page 1 Algorithmic Analysis of Polygonal Hybrid Systems GERARDO SCHNEIDER VERIMAG GRENOBLE Algorithmic Analysis of Polygonal Hybrid Systems \u2013 p.1/66 Page 2 Hybrid Systems \u2022 Hybrid Systems: interaction between discrete and continuous behaviors \u2022 Examples: thermostat, automated highway systems, air traffic management systems, robotic systems, chemical plants, etc. Algorithmic Analysis of Polygonal Hybrid Systems \u2013 p.2/66 Page 3 Hybrid Systems Model: Hybrid Automata label invariant dynamics guard reset x = M x \u2264 M x = 3 \u2212 x x \u2265 m x = \u2212x Off On x = m /\u03b3 Algorithmic Analysis of Polygonal Hybrid Systems \u2013 p.2/66 Page 4 Hybrid Systems Example: Swimmer in a whirlpool e10 e9 e12 e11 e2 e4 e5 e8 e1 x0 e6 e7 e3 Algorithmic Analysis of Polygonal Hybrid Systems \u2013 p.3/66 Page 5 Hybrid Systems Example: Swimmer in a whirlpool e10 e9 e12 \u2026", "num_citations": "20\n", "authors": ["1653"]}
{"title": "Privacy compliance via model transformations\n", "abstract": " Due to the upcoming, more restrictive regulations (like the European GDPR), designing privacy preserving architectures for information systems is becoming a pressing concern for practitioners. In particular, verifying that a design is compliant with the regulations might be a challenging task for engineers. This work presents an approach based on model transformations, which guarantee that an architectural design encompasses regulation-oriented principles such as purpose limitation, or accountability of the data controller. Our work improves the state of the art along two main dimensions. The approach we propose (i) embeds privacy principles coming from regulations, thus helping to bridge the gap between the technical and the legal worlds, (ii) systematize the embedding of the privacy principles coming from regulations, thus enabling a constructive approach to privacy by design.", "num_citations": "19\n", "authors": ["1653"]}
{"title": "On the definition and policies of confidentiality\n", "abstract": " In this paper we propose a more general definition of confidentiality, as an aspect of information security including information flow control. We discuss central aspects of confidentiality and their relation with norms and policies, and we introduce a language, with a deontic flavor, to express such norms and policies. Our language may be regarded as a first step towards a formal specification of security policies for confidentiality. We provide a number of examples of useful norms on confidentiality, and we discuss confidentiality policies from real scenarios.", "num_citations": "17\n", "authors": ["1653"]}
{"title": "Language-based support for service oriented architectures: Future directions.\n", "abstract": " The popularity of service-oriented architectures (SOA) lives on the promise of dynamic IT-supported interbusiness collaborations. Yet the programming models in use today are a poor match for the distributed, looselycoupled, document-based SOA; and the gap widens: interoperability across organizations needs contracts to reduce risks. Thus, high-level contract models are making their way into SOA, but application developers are still left to their own devices when it comes to writing code that will comply with a contract. This paper surveys existing and future directions regarding language-based solutions to the above problem.", "num_citations": "17\n", "authors": ["1653"]}
{"title": "On the specification of full contracts\n", "abstract": " Contracts specify properties of an interface to a software component. We consider the problem of defining a full contract that specifies not only the normal behaviour, but also special cases and tolerated exceptions. In this paper we focus on the behavioural properties of use cases taken from the Common Component Modelling Example (CoCoME), proposed as a benchmark to compare different component models. We first give the full specification of the use cases in the deontic-based specification language CL, and then we concentrate on three particular properties in order to compare deontic and operational specifications. We conjecture that operational specifications are well suited for normal cases, but are less easily extended for exceptional cases. This hypothesis is investigated by comparing specifications in CSP (operational) with specifications in CL. The outcome of the experiment supports the conjecture\u00a0\u2026", "num_citations": "16\n", "authors": ["1653"]}
{"title": "Components, objects, and contracts\n", "abstract": " Being a composite part of a larger system, a crucial feature of a component is its interface, as it describes the component's interaction with the rest of the system in an abstract manner. It is now commonly accepted that simple syntactic interfaces are not expressive enough for components, and the trend is towards behavioral interfaces.", "num_citations": "15\n", "authors": ["1653"]}
{"title": "Towards an operational semantics of Verilog\n", "abstract": " Modern hardware design typically uses hardware description languages to express designs at various levels of abstraction. A hardware description language is a high level programming language, with the usual programming constructs such as assignments, conditionals and iterations, and appropriate extensions for real-time, concurrency and data structures suitable for modelling hardware. The common approach is to rst build a high level design using programming constructs. The high level design is then recoded using a subset of the description language which is closer to implementation. This process may be repeated several times until the design is at a su ciently lower level such that the hardware can be synthesised from it.For ensuring correctness of the development, a precise understanding of the description language used is apparently. Verilog is a hardware description language widely used in industry, but its standard semantics 5] is informal. A formal semantics will also be the basis of further formal support for the language. This includes methods to prove that the highest level description satis es the overall requirements and that a lower level description correctly implements a higher level one.", "num_citations": "15\n", "authors": ["1653"]}
{"title": "Data minimisation: a language-based approach\n", "abstract": " Data minimisation is a privacy-enhancing principle considered as one of the pillars of personal data regulations. This principle dictates that personal data collected should be no more than necessary for the specific purpose consented by the user. In this paper we study data minimisation from a programming language perspective. We define a data minimiser as a pre-processor for the input which reduces the amount of information available to the program without compromising its functionality. We give its formal definition and provide a procedure to synthesise a correct data minimiser for a given program.", "num_citations": "14\n", "authors": ["1653"]}
{"title": "Model checking polygonal differential inclusions using invariance kernels\n", "abstract": " Polygonal hybrid systems are a subclass of planar hybrid automata which can be represented by piecewise constant differential inclusions. Here, we identify and compute an important object of such systems\u2019 phase portrait, namely invariance kernels. An invariant set is a set of initial points of trajectories which keep rotating in a cycle forever and the invariance kernel is the largest of such sets. We show that this kernel is a non-convex polygon and we give a non-iterative algorithm for computing the coordinates of its vertices and edges. Moreover, we present a breadth-first search algorithm for solving the reachability problem for such systems. Invariance kernels play an important role in the algorithm.", "num_citations": "13\n", "authors": ["1653"]}
{"title": "Formalising privacy policies in social networks\n", "abstract": " Social Network Services (SNS) have changed the way people communicate, bringing many benefits but also new concerns. Privacy is one of them. We present a framework to write privacy policies for SNSs and to reason about such policies in the presence of events making the network evolve. The framework includes a model of SNSs, a logic to specify properties and to reason about the knowledge of the users (agents) of the SNS, and a formal language to write privacy policies. Agents are enhanced with a reasoning engine allowing the inference of knowledge from previously acquired knowledge. To describe the way SNSs may evolve, we provide operational semantics rules which are classified into four categories: epistemic, topological, policy, and hybrid, depending on whether the events under consideration change the knowledge of the SNS' users, the structure of the social graph, the privacy policies, or a\u00a0\u2026", "num_citations": "12\n", "authors": ["1653"]}
{"title": "Memory consumption analysis of Java smart cards\n", "abstract": " Memory is a scarce resource in Java smart cards. Developers and card suppliers alike would want to make sure, at compile-or load-time, that a Java Card applet will not overflow memory when performing dynamic class instantiations. Although there are good solutions to the general problem, the challenge is still out to produce a static analyser that is certified and could execute on-card. We provide a constraint-based algorithm which determines potential loops and (mutually) recursive methods. The algorithm operates on the bytecode of an applet and is written as a set of rules associating one or more constraints to each bytecode instruction. The rules are designed so that a certified analyser could be extracted from their proof of correctness. By keeping a clear separation between the rules dealing with the inter-and intra-procedural aspects of the analysis we are able to reduce the space-complexity of a previous algorithm.", "num_citations": "12\n", "authors": ["1653"]}
{"title": "Is privacy by construction possible?\n", "abstract": " Finding suitable ways to handle personal data in conformance with the law is challenging. The European General Data Protection Regulation (GDPR), enforced since May 2018, makes it mandatory to citizens and companies to comply with the privacy requirements set in the regulation. For existing systems the challenge is to be able to show evidence that they are already complying with the GDPR, or otherwise to work towards compliance by modifying their systems and procedures, or alternatively reprogramming their systems in order to pass the eventual controls. For those starting new projects the advice is to take privacy into consideration since the very beginning, already at design time. This has been known as Privacy by Design (PbD). The main question is how much privacy can you effectively achieve by using PbD, and in particular whether it is possible to achieve Privacy by Construction. In this\u00a0\u2026", "num_citations": "11\n", "authors": ["1653"]}
{"title": "Migration of an on-premise application to the cloud: Experience report\n", "abstract": " As of today it is still not clear how and when cloud computing should be used. Developers very often write applications in a way that does not really fit a cloud environment, and in some cases without taking into account how quality attributes (like performance, security or portability) are affected. In this paper we share our experience and observations from adopting cloud computing for an on-premise enterprise application in a context of a small software company. We present experimental results concerning a comparative evaluation (w.r.t. performance and cost) of the behavior of the original system both on-premise and on the Cloud, considering different scenarios in the Cloud.", "num_citations": "11\n", "authors": ["1653"]}
{"title": "Participatory verification of railway infrastructure by representing regulations in railcnl\n", "abstract": " Designs of railway infrastructure (tracks, signalling and control systems, etc.) need to comply with comprehensive sets of regulations describing safety requirements, engineering conventions, and design heuristics. We have previously worked on automating the verification of railway designs against such regulations, and integrated a verification tool based on Datalog reasoning into the CAD tools of railway engineers. This was used in a pilot project at Norconsult\u00a0AS (formerly Anacon\u00a0AS). In order to allow railway engineers with limited logic programming experience to participate in the verification process, in this work we introduce a controlled natural language, RailCNL, which is designed as a middle ground between informal regulations and Datalog code. Phrases in RailCNL correspond closely to those in the regulation texts, and can be translated automatically into the input language of the verifier. We\u00a0\u2026", "num_citations": "10\n", "authors": ["1653"]}
{"title": "Relaxing goodness is still good\n", "abstract": " Polygonal hybrid systems (SPDIs) are planar hybrid systems, whose dynamics are defined in terms of constant differential inclusions, one for each of a number of polygonal regions partitioning the plane. The reachability problem for SPDIs is known to be decidable, but depends on the goodness assumption \u2014 which states that the dynamics do not allow a trajectory to both enter and leave a region through the same edge. In this paper we extend the decidability result to generalised SPDIs (GSPDI), SPDIs not satisfying the goodness assumption, and give an algorithmic solution to decide reachability of such systems.", "num_citations": "10\n", "authors": ["1653"]}
{"title": "CL-a logic for reasoning about legal contracts:-Semantics\n", "abstract": " The work reported here is concerned with the definition of a logic (which we call CL) for reasoning about legal contracts. The report presents the syntax of the logic and the associated semantics. There are two semantics presented: one is defined with respect to linear structures (i.e. traces of actions) and is intended for run-time moni- toring of executions of contracts; the second semantics is given over branching structures (i.e. Kripke-like structures) and is intended for reasoning about contracts in a static manner (i.e. model-checking and theorem proving). In the first part of the report we present the the- oretical results underlying the branching semantics. It presents an algebra of actions and restates some of previous results presented in another report, as well as new results useful for the definition of the branching semantics and for the proofs. The rest of the report is con- cerned with the definition of the two semantics. Moreover, several (non-standard) desired properties of the logic are proven.", "num_citations": "10\n", "authors": ["1653"]}
{"title": "Towards a formal definition of electronic contracts\n", "abstract": " \u0421\u0432 \u0438 \u0437 \u0434 \u0434 \u0436 \u043b \u0434\u0436\u0433\u0434\u0433\u0437 \u0433\u0436\u0431 \u0430 \u0430 \u0432 \u0439 \u0433\u0436 \u043b\u0436 \u0438 \u0432 \u0430 \u0438\u0436\u0433\u0432 \u0433\u0432\u0438\u0436 \u0438\u0437\u0418 \u0437 \u0433\u0432 \u0438 \u0432\u0433\u0436\u0431 \u0438 \u043a \u0433\u0432\u0438 \u0432\u0433\u0438 \u0433\u0432\u0437 \u0433 \u0433 \u0430 \u0438 \u0433\u0432\u0418 \u0434\u0436\u0433\u0419 \u0438 \u0433\u0432\u0418 \u0432 \u0434 \u0436\u0431 \u0437\u0437 \u0433\u0432\u041a \u042f \u0438 \u0432 \u0433\u0439 \u0438\u0419\u0438\u0433\u0419 \u0433 \u0434\u0434\u0436\u0433 \u0418 \u043b \u0436 \u0438 \u0433\u043a \u0432\u0433\u0438 \u0433\u0432\u0437 \u0436 \u0434\u0434\u0430 \u0438\u0433 \u0438 \u0433\u0432\u0437 \u0432\u0437\u0438 \u0433 \u0437\u0438 \u0438 \u0419\u0433 \u0419 \u0436\u0437\u041a \u042f \u0434\u0436\u0433\u0434\u0433\u0437 \u0432 \u043c\u0438 \u0432\u0437 \u0433\u0432 \u0433 \u0438 \u0415\u0419 \u0430 \u0439\u0430\u0439\u0437 \u0432 \u0433\u0436 \u0436 \u0438\u0433 \u0434\u0438\u0439\u0436 \u0438 \u0432\u0438\u0439\u0419 \u0438 \u043a \u0431 \u0432 \u0432 \u0433 \u0433 \u0430 \u0438 \u0433\u0432\u0418 \u0434\u0436\u0433 \u0438 \u0433\u0432 \u0432 \u0434 \u0436\u0431 \u0437\u0437 \u0433\u0432\u0418 \u0432 \u0438\u0433 \u043c\u0434\u0436 \u0437\u0437 \u0438 \u0436\u0431 \u0432 \u0437\u0438 \u0432 \u0433\u0432 \u0439\u0436\u0436 \u0432\u0438 \u0438 \u0433\u0432\u0437\u041a \u042f \u0434\u0436\u0433\u043a \u0438\u0436 \u0432\u0437\u0430 \u0438 \u0433\u0432 \u0433 \u0438 \u0433\u0432\u0438\u0436 \u0438 \u0430 \u0432 \u0439 \u0432\u0438\u0433 \u0438 \u0430\u0433 \u0418 \u0432 \u043b \u0437 \u0433\u043b \u0433\u043b \u0438 \u0437 \u0431 \u0432\u0438 \u0437 \u0438 \u0419 \u0439\u0430\u0430\u043d \u0434\u0438\u0439\u0436 \u0437 \u0438 \u0431 \u0432 \u0432 \u0433 \u0438 \u0433\u0432\u0438\u0436 \u0438 \u0430 \u0432 \u0439 \u041a \u042f \u0430\u0437\u0433 \u0437 \u0433\u043b \u0433\u043b \u0433\u0439\u0436 \u0430 \u0432 \u0439 \u0434\u0438\u0439\u0436 \u0437 \u0431\u0433\u0437\u0438 \u0433 \u0438 \u0432\u0438\u0439 \u0438 \u043a \u0437 \u0436 \u0430 \u0434\u0436\u0433\u0434 \u0436\u0438 \u0437 \u0433 \u0430 \u0438\u0436\u0433\u0432 \u0433\u0432\u0438\u0436 \u0438\u0437\u0418 \u0437 \u043b \u0430\u0430 \u0437 \u0433\u043b \u0438 \u043a\u0433 \u0437 \u0431\u0433\u0437\u0438 \u0433 \u0438 \u0430 \u0437\u0437 \u0430 \u0434 \u0436 \u0433\u043c \u0437 \u0433 \u0433\u0432\u0438 \u0430\u0433 \u041a \u042f \u0430\u0437\u0433 \u0437 \u0439\u0437\u0437 \u0432 \u0433\u0436\u0431 \u0430\u0430\u043d \u0438 \u0431 \u0432 \u0434\u0436\u0433 \u0419 \u0430 \u0431\u0437 \u0432 \u0433\u0436\u0431 \u0430 \u043e \u0432 \u0438 \u0433\u043a \u0432\u0433\u0436\u0431 \u0438 \u043a \u0433\u0432\u0438 \u0432\u0433\u0438 \u0433\u0432\u0437 \u0432 \u0434 \u0436\u0438 \u0439\u0430 \u0436 \u0432 \u0438 \u0433\u0432\u0438 \u043c\u0438 \u0433 \u0430 \u0438\u0436\u0433\u0432 \u0433\u0432\u0438\u0436 \u0438\u0437\u041a \u042f \u0432 \u0430\u0430\u043d \u0437 \u0433\u043b \u0438\u0437 \u0434\u0434\u0430 \u0430 \u0438\u043d \u0433\u0432 \u0433\u0432\u0438\u0436 \u0438 \u043c \u0431\u0434\u0430 \u041a", "num_citations": "10\n", "authors": ["1653"]}
{"title": "A compositional algorithm for parallel model checking of polygonal hybrid systems\n", "abstract": " The reachability problem as well as the computation of the phase portrait for the class of planar hybrid systems defined by constant differential inclusions (SPDI), has been shown to be decidable. The existing reachability algorithm is based on the exploitation of topological properties of the plane which are used to accelerate certain kind of cycles. The complexity of the algorithm makes the analysis of large systems generally unfeasible. In this paper we present a compositional parallel algorithm for reachability analysis of SPDIs. The parallelization is based on the qualitative information obtained from the phase portrait of an SPDI, in particular the controllability kernel.", "num_citations": "10\n", "authors": ["1653"]}
{"title": "An automata-based approach to evolving privacy policies for social networks\n", "abstract": " Online Social Networks (OSNs) are ubiquitous, with more than 70\u00a0% of Internet users being active users of such networking services. This widespread use of OSNs brings with it big threats and challenges, privacy being one of them. Most OSNs today offer a limited set of (static) privacy settings and do not allow for the definition, even less enforcement, of more dynamic privacy policies. In this paper we are concerned with the specification and enforcement of dynamic (and recurrent) privacy policies that are activated or deactivated by context (events). In particular, we present a novel formalism of policy automata, transition systems where privacy policies may be defined per state. We further propose an approach based on runtime verification techniques to define and enforce such policies. We provide a proof-of-concept implementation for the distributed social network Diaspora, using the runtime\u00a0\u2026", "num_citations": "9\n", "authors": ["1653"]}
{"title": "Gspeedi\u2013a verification tool for generalized polygonal hybrid systems\n", "abstract": " The GSPeeDI tool implements a decision procedure for the reachability analysis of GSPDIs, planar hybrid systems whose dynamics is given by differential inclusions, and that are not restricted by the goodness assumption from previous work on the so-called SPDIs.               Unlike SPeeDI (a tool for reachability analysis of SPDIs) the underlying analysis of GSPeeDI is based on a breadth-first search algorithm, and it can handle more general systems.", "num_citations": "9\n", "authors": ["1653"]}
{"title": "Conflict analysis of deontic contracts\n", "abstract": " Industry is currently pushing towards Service Oriented Architecture where code execution is not limited to the organisational borders but may extend outside of the organisation to which the sources are typically not accessible. In order to protect the interests of the organisation contracts are used which can be seen as a list of obligations, permissions and prohibitions. The composition of different services with different con- tracts, and the combination of service contracts with local contracts can give rise to conflicts, exposing the need for automatic techniques for contract analysis. In this paper we investigate how conflict analysis can be performed automatically for contracts specified in the contract language CL.", "num_citations": "9\n", "authors": ["1653"]}
{"title": "An algebraic structure for the Action-Based Contract language CL-Theoretical Results\n", "abstract": " \u042f \u0432\u0438\u0436\u0433 \u0439 \u0432 \u0438 \u0437 \u0434 \u0434 \u0436 \u0432 \u0430 \u0436 \u0433 \u0438 \u0433\u0432\u0437 \u0437\u0434 \u0430\u0430\u043d \u0438 \u0430\u0433\u0436 \u0438\u0433 \u0437 \u0436\u043a \u0437 \u0437 \u0437 \u0433 \u0432 \u0438 \u0433\u0432\u0419 \u0437 \u0433\u0436\u0431 \u0430 \u0437\u0431 \u0433\u0436 \u043b\u0436 \u0438 \u0432 \u0430 \u0438\u0436\u0433\u0432 \u0433\u0432\u0438\u0436 \u0438\u0437\u041a \u042c \u0434\u0436\u0433\u0434\u0433\u0437 \u0430 \u0436 \u0437 \u0437 \u0433\u0432 \u0438 \u043b\u0433\u0436 \u0433\u0432 \u0423\u0430 \u0432 \u0430\u0419 \u0436 \u0437 \u0439\u0438 \u0433 \u0437 \u0432\u0433\u0438 \u0433\u0432\u0437 \u0436 \u0438 \u0423\u0430 \u0432 \u0437\u0438 \u0436 \u0432 \u0432\u0438\u0436\u0433 \u0439 \u0437 \u0432 \u043b \u0433\u0432\u0437\u0438\u0436\u0439 \u0438\u0433\u0436 \u0433\u0436 \u0431\u0433 \u0430\u0430 \u0432 \u0433\u0432 \u0439\u0436\u0436 \u0432\u0438 \u0438 \u0433\u0432\u0437\u041a \u042c \u0430 \u0436 \u0437\u0438\u0436\u0439 \u0438\u0439\u0436 \u0437 \u0436 \u0437\u0433\u0439\u0436 \u0419 \u043b \u0436 \u0432 \u0432 \u0433\u0436\u0434\u0433\u0436 \u0438 \u0437 \u0437\u0434 \u0430 \u0438 \u0433\u0432\u0437 \u0430\u0430 \u0438 \u0437\u0438\u0437\u041a \u0421\u0432 \u0433\u0436 \u0436 \u0438\u0433 \u0432 \u0433\u0436 \u0432 \u043b \u0438 \u0438 \u0432\u0438\u0439 \u0438 \u0433\u0432 \u0432 \u0430 \u0438\u0436\u0433\u0432 \u0433\u0432\u0438\u0436 \u0438\u0437 \u043b \u0433\u0432\u0437 \u0436 \u0432 \u043b \u0434\u0436\u0433\u0434 \u0436\u0438 \u0437 \u0433 \u0438 \u0430 \u0436 \u0437\u0438\u0436\u0439 \u0438\u0439\u0436 \u0418 \u0432 \u0434 \u0436\u0438 \u0439\u0430 \u0436 \u0433\u0432\u0419 \u0438 \u0436 \u0430 \u0438 \u0433\u0432 \u0432 \u0431 \u0432 \u0432 \u0434 \u0436\u0438 \u0430 \u0433\u0436 \u0436\u041a \u042f \u0430\u0437\u0433 \u0437\u0438\u0439 \u043d \u0432\u0433\u0432 \u0430 \u0433\u0436\u0431 \u0433 \u0438 \u0438 \u0433\u0432\u0437 \u043b \u0418 \u0431\u0433\u0432 \u0433\u0438 \u0436 \u0438 \u0432 \u0437\u0418 \u0430\u0434\u0437 \u0438\u0433 \u0432 \u0438\u0439\u0436 \u0430\u0430\u043d \u0419 \u0432 \u0432\u0433\u0438 \u0433\u0432 \u0433 \u0438 \u0433\u0432 \u0432 \u0438 \u0433\u0432\u041a \u0427\u0439\u0436 \u0438 \u0433\u0432 \u0432 \u0438 \u0433\u0432 \u0437 \u0431\u0433\u0436 \u0432 \u0436 \u0430 \u0438 \u0432 \u0439\u0437\u0438 \u0432 \u0438 \u0433\u0432 \u0433 \u0438\u0433\u0431 \u0438 \u0433\u0432\u0437\u0418 \u0439\u0438 \u0431\u0433\u0436 \u0436 \u0437\u0438\u0436 \u0438 \u0438 \u0432 \u0438 \u0432 \u0438 \u0433\u0432 \u0432\u043a\u0433\u0430\u043a \u0432 \u0438 \u0439\u0432 \u043a \u0436\u0437 \u0430 \u0436 \u0430 \u0438 \u0433\u0432\u041a \u0437\u0438 \u0432 \u0436 \u0432\u0438 \u0436\u0434\u0436 \u0438 \u0438 \u0433\u0432 \u0433 \u0438 \u0430 \u0436 \u0437 \u043a \u0432 \u0432 \u0438 \u0436\u0431\u0437 \u0433 \u0439 \u0436 \u0436\u0433\u0433\u0438 \u0438\u0436 \u0437 \u043b \u0438 \u0437\u0434 \u0430\u0430\u043d \u0432 \u0433\u0434 \u0436 \u0438 \u0433\u0432\u0437 \u0433\u0432 \u0438 \u0431\u041a \u042c \u0430 \u0436 \u0437 \u0434\u0436\u0433\u043a \u0432 \u0438\u0433 \u0433\u0431\u0434\u0430 \u0438 \u0433\u043a \u0436 \u0438 \u0437\u0438 \u0432 \u0436 \u0432\u0438 \u0436\u0434\u0436 \u0438 \u0438 \u0433\u0432\u041a", "num_citations": "9\n", "authors": ["1653"]}
{"title": "Modelling and analysis of normative documents\n", "abstract": " We are interested in using formal methods to analyse normative documents or contracts such as terms of use, privacy policies, and service agreements. We begin by modelling such documents in terms of obligations, permissions and prohibitions of agents over actions, restricted by timing constraints and including potential penalties resulting from the non-fulfilment of clauses. This is done using the C-O Diagram formalism, which we have extended syntactically and for which we have defined a new trace semantics. Models in this formalism can then be translated into networks of timed automata, and we have a complete working implementation of this translation. The network of automata is used as a specification of a normative document, making it amenable to verification against given properties. By applying this approach to a case study from a real-world contract, we show the kinds of analysis possible through\u00a0\u2026", "num_citations": "8\n", "authors": ["1653"]}
{"title": "From contracts in structured english to CL specifications\n", "abstract": " In this paper we present a framework to analyze conflicts of contracts written in structured English. A contract that has manually been rewritten in a structured English is automatically translated into a formal language using the Grammatical Framework (GF). In particular we use the contract language CL as a target formal language for this translation. In our framework CL specifications could then be input into the tool CLAN to detect the presence of conflicts (whether there are contradictory obligations, permissions, and prohibitions. We also use GF to get a version in (restricted) English of CL formulae. We discuss the implementation of such a framework.", "num_citations": "8\n", "authors": ["1653"]}
{"title": "Static analysis for state-space reduction of polygonal hybrid systems\n", "abstract": " Polygonal hybrid systems (SPDI) are a subclass of planar hybrid automata which can be represented by piecewise constant differential inclusions. The reachability problem as well as the computation of certain objects of the phase portrait, namely the viability, controllability and invariance kernels, for such systems is decidable. In this paper we show how to compute another object of an SPDI phase portrait, namely semi-separatrix curves and show how the phase portrait can be used for reducing the state-space for optimizing the reachability analysis.", "num_citations": "8\n", "authors": ["1653"]}
{"title": "Computing invariance kernels of polygonal hybrid systems\n", "abstract": " Polygonal hybrid systems are a subclass of planar hybrid automata which can be represented by piecewise constant differential inclusions. One way of analysing such systems (and hybrid systems in general) is through the study of their phase portrait, which characterise the systems\u2019 qualitative behaviour. In this paper we identify and compute an important object of polygonal hybrid systems\u2019 phase portrait, namely invariance kernels. An invariant set is a set of points such that any trajectory starting in such point keep necessarily rotating in the set forever and the invariance kernel is the largest of such sets. We show that this kernel is a non-convex polygon and we give a non-iterative algorithm for computing the coordinates of its vertexes and edges. Moreover, we show some properties of such systems\u2019 simple cycles.", "num_citations": "8\n", "authors": ["1653"]}
{"title": "A web-based tool for analysing normative documents in English\n", "abstract": " Our goal is to use formal methods to analyse normative documents written in English, such as privacy policies and regulations. This requires the combination of a number of different elements, including information extraction from natural language, formal languages for model representation, and an interface for property specification and verification. A number of components for performing these tasks have separately been developed: a natural language extraction tool, a suitable formalism for representing such documents, an interface for building models in this formalism, and methods for answering queries asked of a given model. In this work, each of these concerns is brought together in a web-based tool, providing a single interface for analysing normative texts in English. Through the use of a running example, we describe each component and demonstrate the workflow established by our tool.", "num_citations": "7\n", "authors": ["1653"]}
{"title": "Formal Methods for Software Engineering: Languages, Methods, Application Domains\n", "abstract": " This is a graduate-level introduction to formal methods. The first part presents two formal languages: logic, in various forms, and Communicating Sequential Process (CSP) as a process algebra. The second part offers specification and testing methods for formal development of software. Building on the foundations from the first part, the reader is allowed to embrace methods for practical applications. The reader will find the examples cutting across chapters valuable for this purpose. The final section takes the reader further into application domains.", "num_citations": "6\n", "authors": ["1653"]}
{"title": "After you, please: browser extensions order attacks and countermeasures\n", "abstract": " Browser extensions are small applications executed in the browser context that provide additional capabilities and enrich the user experience while surfing the web. The acceptance of extensions in current browsers is unquestionable. For instance, Chrome\u2019s official extension repository has more than 63,000 extensions, with some of them having more than 10M users. When installed, extensions are pushed into an internal queue within the browser. The order in which each extension executes depends on a number of factors, including their relative installation times. In this paper, we demonstrate how this order can be exploited by an unprivileged malicious extension (i.e., one with no more permissions than those already assigned when accessing web content) to get access to any private information that other extensions have previously introduced. We propose a solution that does not require modifying the core\u00a0\u2026", "num_citations": "6\n", "authors": ["1653"]}
{"title": "Model checking social network models\n", "abstract": " A social network service is a platform to build social relations among people sharing similar interests and activities. The underlying structure of a social networks service is the social graph, where nodes represent users and the arcs represent the users' social links and other kind of connections. One important concern in social networks is privacy: what others are (not) allowed to know about us. The \"logic of knowledge\" (epistemic logic) is thus a good formalism to define, and reason about, privacy policies. In this paper we consider the problem of verifying knowledge properties over social network models (SNMs), that is social graphs enriched with knowledge bases containing the information that the users know. More concretely, our contributions are: i) We prove that the model checking problem for epistemic properties over SNMs is decidable; ii) We prove that a number of properties of knowledge that are sound w.r.t. Kripke models are also sound w.r.t. SNMs; iii) We give a satisfaction-preserving encoding of SNMs into canonical Kripke models, and we also characterise which Kripke models may be translated into SNMs; iv) We show that, for SNMs, the model checking problem is cheaper than the one based on standard Kripke models. Finally, we have developed a proof-of-concept implementation of the model-checking algorithm for SNMs.", "num_citations": "6\n", "authors": ["1653"]}
{"title": "Specification of evolving privacy policies for online social networks\n", "abstract": " Online Social Networks are ubiquitous, bringing not only numerous new possibilities but also big threats and challenges. Privacy is one of them. Most social networks today offer a limited set of (static) privacy settings, not being able to express dynamic policies. For instance, users might decide to protect their location during the night, or share information with difference audiences depending on their current position. In this paper we introduce TFPPF, a formal framework to express, and reason about, dynamic (and recurrent) privacy policies that are activated or deactivated by context (events) or time. Besides a formal policy language (TPPL), the framework includes a knowledge-based logic extended with (linear) temporal operators and a learning modality (TKBL). Policies, and formulae in the logic, are interpreted over (timed) traces representing the evolution of the social network. We prove that checking privacy\u00a0\u2026", "num_citations": "6\n", "authors": ["1653"]}
{"title": "Teaching formal methods for software engineering-ten principles\n", "abstract": " In this paper we report and reflect about the didactic principles underlying our endeavour to write a book on \u201cFormal Methods for Software Engineering\u2013Languages, Methods, Application Domains\u201d, and to teach its contents at international summer schools. Target audience for the book are taught master students, possibly striving for a career in industry, and doctoral students in their early years, possibly in search of a suitable topic for their dissertation. We outline ten principles underlying the design of the book, coin a recommendation from each principle, and give appropriate examples. We report about the feedback from participants to the schools and lectures, and relate our principles to other pedagogical suggestions for teaching Formal Methods.", "num_citations": "6\n", "authors": ["1653"]}
{"title": "Software Engineering and Formal Methods: 9th International Conference, SEFM 2011, Montevideo, Uruguay, November 14-18, 2011, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 9th International Conference on Software Engineering and Formal Methods, SEFM 2011, held in Montevideo, Uruguay, in November 2011. The 22 revised regular papers presented together with 1 short paper, 2 tool papers, and 4 keynote talks were carefully reviewed and selected from 105 initial abstracts and 85 full submissions. Besides the regular session the conference held a special track devoted to\" Modeling for Sustainable Development\" with 5 accepted papers-selected from 7 submissions-that are also part of this volume. The aim of SEFM is to advance the state of the art in formal methods, to scale up their application in software industry and to encourage their integration with practical engineering methods.", "num_citations": "6\n", "authors": ["1653"]}
{"title": "Feasibility analysis of inter-pulse intervals based solutions for cryptographic token generation by two electrocardiogram sensors\n", "abstract": " In this paper we address the problem of how two devices that are sensing the same heart signal can generate the same cryptographic token by extracting them from the Inter-Pulse Intervals (IPIs) of each cardiac signal. Our analysis is based on the use of a run-time monitor, which is extracted from a formal model and verified against predefined properties, combined with a fuzzy extractor to improve the final result. We first show that it is impossible, in general, to correct the differences between the IPIs derived from two captured electrocardiogram (ECG) signals when using only error correction techniques, thus being impossible to corroborate previous claims on the feasibility of this approach. Then, we provide a large-scale evaluation of the proposed method (run-time monitor and fuzzy extractor) over 19 public databases from the Physionet repository containing heart signals. The results clearly show the practicality of\u00a0\u2026", "num_citations": "5\n", "authors": ["1653"]}
{"title": "MoVEMo: a structured approach for engineering reward functions\n", "abstract": " Reinforcement learning (RL) is a machine learning technique that has been increasingly used in robotic systems. In reinforcement learning, instead of manually pre-program what action to take at each step, we convey the goal a software agent in terms of reward functions. The agent tries different actions in order to maximize a numerical value, i.e. the reward. A misspecified reward function can cause problems such as reward hacking, where the agent finds out ways that maximize the reward without achieving the intended goal. As RL agents become more general and autonomous, the design of reward functions that elicit the desired behaviour in the agent becomes more important and cumbersome. In this paper, we present a technique to formally express reward functions in a structured way; this stimulates a proper reward function design and as well enables the formal verification of it. We start by defining the\u00a0\u2026", "num_citations": "5\n", "authors": ["1653"]}
{"title": "Conditional Permissions in Contracts\n", "abstract": " Defining and characterising conditional permissions has never been easy. Part of the problem, we believe, comes from the fact that there is not one but a whole family of possible deontic operators, all of them distinct and reasonable, that can be labelled as conditional permissions. In this article, rather than disputing the correct interpretation, we revisit a number of different interpretations the term has received in the literature, and propose appropriate formalisations for these interpretations within the context of contract automata.", "num_citations": "5\n", "authors": ["1653"]}
{"title": "Reachability analysis of non-linear planar autonomous systems\n", "abstract": " Many complex continuous systems are modeled as non-linear autonomous systems, i.e., by a set of differential equations with one independent variable. Exact reachability, i.e., whether a given configuration can be reached by starting from an initial configuration of the system, is undecidable in general, as one needs to know the solution of the system of equations under consideration.             In this paper we address the reachability problem of planar autonomous systems approximatively.We use an approximation technique which \u201chybridizes\u201d the state space in the following way: the original system is partitioned into a finite set of polygonal regions where the dynamics on each region is approximated by constant differential inclusions. Besides proving soundness, completeness, and termination of our algorithm, we present an implementation, and its application into (classical) examples taken from the literature.", "num_citations": "5\n", "authors": ["1653"]}
{"title": "Resource-bounded runtime verification of java programs with real-time properties\n", "abstract": " Given the intractability of exhaustively verifying software, the use of runtime verification, to verify single execution paths  at runtime, is becoming increasingly popular. Undoubtedly, the overhead introduced by runtime verification is a concern for system developers planning to introduce this technique in their work. By using  Lustre to write security-critical properties, we exploit the language\u2019s guarantees on bounded resources. We translate these properties into the existing monitoring framework Larva, making monitoring of programs both easily applicable to Java programs and at the same  time guarantee to use bounded-resources. We use a subset of Quantified Discrete-time Duration Calculus (QDDC) as an alternative  specification notation for real-time properties because it is translatable into Lustre. Thus, QDDC also enjoys the same guarantees given  when using Lustre.", "num_citations": "5\n", "authors": ["1653"]}
{"title": "Assumption monitoring using runtime verification for UAV temporal task plan executions\n", "abstract": " Temporal task planning guarantees a robot will succeed in its task as long as certain explicit and implicit assumptions about the robot\u2019s operating environment, sensors, and capabilities hold. A robot executing a plan can silently fail to fulfill the task if the assumptions are violated at runtime. Monitoring assumption violations at runtime can flag silent failures and also provide mitigation and remediation opportunities. However, this requires means for describing assumptions combining temporal and quantitative data, automatic construction of correct monitors and ensuring a correct interplay between the planning execution and monitors. In this paper we propose combining temporal planning with stream runtime verification, which offers a high-level language to describe monitors together with guarantees on execution time and memory usage. We demonstrate our approach both in real and simulated flights for some\u00a0\u2026", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Secure photo sharing in social networks\n", "abstract": " Nowadays, in an ubiquitous world where everything is connected to the Internet and where social networks play an important role in our lives, security and privacy is a must. Billions of pictures are uploaded daily to social networks and, with them, parts of our private life are disclosed. In this work, we propose a practical solution for secure photo sharing on social network with independence of its architecture which can be either centralised or distributed. This solution solves the inconsistencies that appear in distributed social network as a consequence of treating photos and access policies separately. Specifically, we solve this open problem by attaching an access policy to the images and thus, each time a photo is re-shared, the access policy will travel together with the image.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "A runtime monitoring system to secure browser extensions\n", "abstract": " Web browsers are applications originally created to surf over the Internet in a friendly way. Nowadays these browsers have turned into a richer software where, apart from surfing the web, users are provided with a vast variety of small applications, called browsers extensions, that are not maintained by the web browsers. Those browser extensions are usually developed by external developers and directly interact either with the web content or with the users.Browser extensions considerably increase the functionality of the browser. For instance, using a well known translate browser extension, users can have any web page translated to their preferred language; telephone numbers can be remarked in the web page so that users can click on them and automatically open a desktop application to make that call or browser extensions that block the advertisement that some sites insert in the HTML.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Extracting formal models from normative texts\n", "abstract": " Normative texts are documents based on the deontic notions of obligation, permission, and prohibition. Our goal is model such texts using the C-O Diagram formalism, making them amenable to formal analysis, in particular verifying that a text satisfies properties concerning causality of actions and timing constraints. We present an experimental, semi-automatic aid to bridge the gap between a normative text and its formal representation. Our approach uses dependency trees combined with our own rules and heuristics for extracting the relevant components. The resulting tabular data can then be converted into a C-O Diagram.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Wrap your objects safely\n", "abstract": " Despite the effort of researchers on distributed systems, programming languages, and security, there is still no good solution offering basic constructs for guaranteeing minimal security at the programming language level. In particular, the notion of a wrapper around an object or component controlling its interaction with the environment has not properly been addressed. This kind of \u201clocal firewall\u201d may play two different roles: (1) The untrusted part is what is inside the wrapper; (2) The untrusted part is the environment. In this paper we propose the addition of a language primitive for creating wrapped objects and components, and sketch a formalization based on a minimal object-oriented language for distributed systems using asynchronous communication.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Abstract specification of legal contracts\n", "abstract": " The paper presents an action-based formal language called CL for abstract specification of legal contracts. The purpose of the language is to be used to reason about legal contracts (and electronic contracts on the long run). CL combines the legal notions obligation, permission, and prohibition from deontic logic with the action modality of propositional dynamic logic (PDL). The deontic modalities are applied only over actions, thus following the ought-to-do approach. The language includes a synchrony operator to model\" actions performed at the same time\", and a special complementation operation to encode the violation of obligations. The language has a formal semantics in terms of normative structures, specially defined to capture several natural properties of legal contracts. We focus on the informal presentation of the choices made when designing CL, and its semantics.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Detection of conflicts in electronic contracts\n", "abstract": " Today\u2019s trend towards service-oriented architectures, in which different decoupled services distributed not only on different machines within a single organisation but also outside of it, provides new challenges for reliability and  trust. Since an organisation may need to execute code provided by third parties, it requires mechanisms to protect  itself. One of such mechanisms is the use of contracts.  Since services are frequently composed of different subservices, each with its own contract, there is a need to  guarantee that each single contract is conflict-free. Moreover, one needs to ensure that the conjunction of all the  contracts is also conflict-free \u2014meaning that the contracts will never lead to conflicting or contradictory normative directives.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Static analysis of SPDIs for state-space reduction\n", "abstract": " \u0420\u043d \u0436 \u0437\u043d\u0437\u0438 \u0431\u0437 \u0433\u0431 \u0432 \u0432 \u0437 \u0436 \u0438 \u0432 \u0433\u0432\u0438 \u0432\u0439\u0433\u0439\u0437 \u043d\u0432 \u0431 \u0437 \u0436 \u0437 \u0437 \u0431 \u0438 \u0419 \u0431 \u0438 \u0430 \u0431\u0433 \u0430\u0437 \u0433 \u043a \u0436 \u0433\u0439\u0437 \u0436\u0438 \u0430 \u0432 \u0432 \u0438\u0439\u0436 \u0430 \u0437\u043d\u0437\u0438 \u0431\u0437\u0418 \u0432 \u0437 \u0434\u0434\u0436\u0433\u043c \u0431 \u0419 \u0438 \u0433\u0432\u0437 \u0438\u0433 \u0433\u0431\u0434\u0430 \u043c \u0433\u0432\u0438 \u0432\u0439\u0433\u0439\u0437 \u0437\u043d\u0437\u0438 \u0431\u0437\u041a \u042c \u043d \u043a \u0432 \u0439\u0437 \u0432 \u043a \u0436 \u0433\u0439\u0437 \u0433\u0419 \u0431 \u0432\u0437\u0418 \u0432 \u0430\u0439 \u0432 \u043a \u0433\u0432 \u0437\u0418 \u0436\u0433 \u0433\u0438 \u0437 \u0432 \u0433 \u0432 \u0433\u0436\u0431 \u0438 \u0437\u041a \u042a \u0430 \u0438\u043d \u0432 \u0430\u043d\u0437 \u0437 \u0437 \u0432 \u0438 \u0434\u0436 \u0432 \u0434 \u0430 \u0436 \u0437 \u0436 \u0435\u0439 \u0437\u0438 \u0433\u0432 \u0432 \u0438 \u043a \u0436 \u0438 \u0433\u0432 \u0433 \u043d \u0436 \u0437\u043d\u0437\u0438 \u0431\u0437\u0418 \u043a \u0432 \u0438 \u0437 \u043b \u0430\u0430\u0419 \u0432\u0433\u043b\u0432 \u0436 \u0437\u0439\u0430\u0438 \u0438 \u0438 \u0433\u0436 \u0431\u0433\u0437\u0438 \u0432\u0433\u0432\u0419\u0438\u0436 \u043a \u0430 \u0437\u0439 \u0430 \u0437\u0437 \u0437 \u0433 \u043d \u0436 \u0437\u043d\u0437\u0438 \u0431\u0437 \u0436 \u0430 \u0438\u043d \u0432 \u0431\u0433\u0437\u0438 \u043a \u0436 \u0438 \u0433\u0432 \u0435\u0439 \u0437\u0438 \u0433\u0432\u0437 \u0436 \u0439\u0432 \u0430 \u041a \u042e \u0436 \u0419 \u0433\u0439\u0437 \u0430 \u0437\u0439 \u0430 \u0437\u0437 \u0437 \u043a \u0418 \u0437\u0439 \u0437 \u0435\u0439 \u0432\u0438\u0430\u043d\u0418 \u0432 \u0432\u0438 \u0418 \u0432 \u0430\u0439 \u0432 \u0438 \u0431\u2104 \u0432 \u0436 \u0438 \u0432 \u0439\u0430 \u0436 \u0439\u0438\u0433\u0431 \u0438 \u0420\u0423\u0428\u042e\u2104 \u0418 \u043d \u0436 \u0439\u0438\u0433\u0431 \u0438 \u043b \u0438 \u0430 \u0432 \u0436\u2217 \u0434\u0438\u041a \u0433 \u0433\u0431\u0434\u0439\u0438 \u0436 \u042b \u0432 \u0432 \u0421\u0418 \u042d\u0432 \u043a \u0436\u0437 \u0438\u043d \u0433 \u0425 \u0430\u0438 \u0418 \u0425\u0437 \u0418 \u0425 \u0430\u0438 \u041a \u0419\u0431 \u0430 \u0433\u0436 \u0433\u0432\u041a\u0434 \u0439\u0431\u041a \u0439\u041a\u0431\u0438\u2020 \u0434\u0438\u041a \u0433 \u0421\u0432 \u0433\u0436\u0431 \u0438 \u0437 \u042d\u0432 \u043a\u041a \u0433 \u0427\u0437\u0430\u0433\u0418 \u0428\u041a\u0427\u041a \u0433\u043c \u041d\u041c \u041c \u0430 \u0432 \u0436\u0432\u0418 \u0426\u0419\u041c\u041f\u041d \u0427\u0437\u0430\u0433\u0418 \u0426\u0433\u0436\u043b \u043d\u041a \u0419\u0431 \u0430 \u0436 \u0436 \u0433 \u041a\u0439 \u0433\u041a\u0432\u0433", "num_citations": "4\n", "authors": ["1653"]}
{"title": "A constraint-based algorithm for analysing memory usage on Java cards\n", "abstract": " We address in this paper the problem of statically determining whether a JavaCard applet may produce a memory overflow because of the dynamic instantiation of classes inside cycles. We provide a constraint-based algorithm which determines potential loops and (mutually) recursive methods. The algorithm operates on the byte-code of an applet. It is written as a set of rules -one for each byte-code instruction- which allows a compositional reasoning and it comprises both inter- and intra-procedural analysis. We aimed at an algorithm suitable to be fed into the proof assistant Coq in order to extract a certified memory usage analyser. We prove termination of the algorithm as well as its soundness and completeness with respect to an abstraction of the operational semantics of the language.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "Invariance kernels of polygonal differential inclusions\n", "abstract": " Polygonal hybrid systems are a subclass of planar hybrid automata which can be represented by piecewise constant differential inclusions. Here, we identify and compute an important object of such systems\u2019 phase portrait, namely invariance kernels. An invariant set is a set of initial points of trajectories which keep rotating in a cycle forever and the invariance kernel is the largest of such sets. We show that this kernel is a non-convex polygon and we give a non-iterative algorithm for computing the coordinates of its vertexes and edges.", "num_citations": "4\n", "authors": ["1653"]}
{"title": "A runtime monitoring framework to enforce invariants on reinforcement learning agents exploring complex environments\n", "abstract": " Without prior knowledge of the environment, a software agent can learn to achieve a goal using machine learning. Model-free Reinforcement Learning (RL) can be used to make the agent explore the environment and learn to achieve its goal by trial and error. Discovering effective policies to achieve the goal in a complex environment is a major challenge for RL. Furthermore, in safety-critical applications, such as robotics, an unsafe action may cause catastrophic consequences in the agent or in the environment. In this paper, we present an approach that uses runtime monitoring to prevent the reinforcement learning agent to perform \"wrong\" actions and to exploit prior knowledge to smartly explore the environment. Each monitor is de?ned by a property that we want to enforce to the agent and a context. The monitors are orchestrated by a meta-monitor that activates and deactivates them dynamically according to the\u00a0\u2026", "num_citations": "3\n", "authors": ["1653"]}
{"title": "Timed epistemic knowledge bases for social networks\n", "abstract": " We present an epistemic logic equipped with time-stamps in atoms and epistemic operators, which enables reasoning about the moments at which events happen and knowledge is acquired or deduced. Our logic includes both an epistemic operator K and a belief operator B, to capture the disclosure of inaccurate information. Our main motivation is to describe rich privacy policies in online social networks (OSNs). Most of today\u2019s privacy policy mechanisms in existing OSNs allow only static policies. In our logic it is possible to express rich dynamic policies in terms of the knowledge available to the different users and the precise time of actions and deductions. Our framework can be instantiated for different OSNs by specifying the effect of the actions in the evolution of the social network and in the knowledge disclosed to each user. We present an algorithm for deducing knowledge and propagating beliefs\u00a0\u2026", "num_citations": "3\n", "authors": ["1653"]}
{"title": "Reachability analysis of complex planar hybrid systems\n", "abstract": " Hybrid systems are systems that exhibit both discrete and continuous behavior. Reachability, the question of whether a system in one state can reach some other state, is undecidable for hybrid systems in general. In this paper we are concerned with GSPDIs, 2-dimensional systems generalizing SPDIs (planar hybrid systems based on \u201csimple polygonal differential inclusions\u201d), for which reachability have been shown to be decidable. GSPDIs are useful to approximate 2-dimensional control systems, allowing the verification of safety properties of such systems.In this paper we present the following two contributions: (i) an optimized algorithm that answers reachability questions for GSPDIs, where all cycles in the reachability graph are accelerated. (ii) An algorithm by which more complex planar hybrid automata are over-approximated by GSPDIs subject to two measures of precision. We prove soundness\u00a0\u2026", "num_citations": "3\n", "authors": ["1653"]}
{"title": "Timed automata semantics for visual e-contracts\n", "abstract": " C-O Diagrams have been introduced as a means to have a more visual representation of electronic contracts, where it is possible to represent the obligations, permissions and prohibitions of the different signatories, as well as what are the penalties in case of not fulfillment of their obligations and prohibitions. In such diagrams we are also able to represent absolute and relative timing constraints. In this paper we present a formal semantics for C-O Diagrams based on timed automata extended with an ordering of states and edges in order to represent different deontic modalities.", "num_citations": "3\n", "authors": ["1653"]}
{"title": "Reachability analysis of GSPDIs: theory, optimization, and implementation\n", "abstract": " Analysis of systems containing both discrete and continuous dynamics, hybrid systems, is a difficult issue. Most problems have been shown to be undecidable in general, and decidability holds only for few classes where the dynamics are restricted and/or the dimension is low. In this paper we present some theoretical results concerning the decidability of the reachability problem for a class of planar hybrid systems called Generalized Polygonal Hybrid Systems (GSPDI). These new results provide means to optimize a previous reachability algorithm, making the implementation feasible. We also discuss the implementation of the algorithm into the tool GSPeeDI.", "num_citations": "3\n", "authors": ["1653"]}
{"title": "Run-time Monitoring of Electronic Contracts\u2013theoretical results\n", "abstract": " Electronic inter-organizational relationships are governed by contracts regulating their interaction. It is necessary to run-time monitor the contracts, as to guarantee their fulfillment as well as the enforcement of penalties in case of violations. The present work shows how to obtain a run-time monitor for contracts written in CL, a formal specification language which allows to write conditional obligations, permissions and prohibitions over actions. We first give a trace semantics for CL which formalizes the notion of a trace fulfills a contract. We show how to obtain, for a given contract, an alternating B\u00fcchi automaton which accepts exactly the traces that fulfill the contract. This automaton is the basis for obtaining a finite state machine which acts as a run-time monitor for CL contracts.", "num_citations": "3\n", "authors": ["1653"]}
{"title": "Towards integration of XML in the Creol object-oriented language\n", "abstract": " The integration of XML documents in object-oriented programming languages is becoming paramount with the advent of the use of Internet in new applications like web services. Such integration is not easy in general and demands a careful language design. In this paper we propose an extension to Creol, a high level object-oriented modeling language for distributed systems, for handling XML documents.", "num_citations": "3\n", "authors": ["1653"]}
{"title": "CROME: Contract-Based Robotic Mission Specification\n", "abstract": " We address the problem of automatically constructing a formal robotic mission specification in a logic language with precise semantics starting from an informal description of the mission requirements. We present CROME (Contract-based RObotic Mission spEcification), a framework that allows capturing mission requirements in terms of goals by using specification patterns, and automatically building linear temporal logic mission specifications conforming with the requirements. CROME leverages a new formal model, termed Contract-based Goal Graph (CGG), which enables organizing the requirements in a modular way with a rigorous compositional semantics. By relying on the CGG, it is then possible to automatically: i) check the feasibility of the overall mission, ii) further refine it from a library of pre-defined goals, and iii) synthesize multiple controllers that implement different parts of the mission at different\u00a0\u2026", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Transforming Data Flow Diagrams for Privacy Compliance (Long Version)\n", "abstract": " Recent regulations, such as the European General Data Protection Regulation (GDPR), put stringent constraints on the handling of personal data. Privacy, like security, is a non-functional property, yet most software design tools are focused on functional aspects, using for instance Data Flow Diagrams (DFDs). In previous work, a conceptual model was introduced where DFDs could be extended into so-called Privacy-Aware Data Flow Diagrams (PA-DFDs) with the aim of adding specific privacy checks to existing DFDs. In this paper, we provide an explicit algorithm and a proof-of-concept implementation to transform DFDs into PA-DFDs. Our tool assists software engineers in the critical but error-prone task of systematically inserting privacy checks during design (they are automatically added by our tool) while still allowing them to inspect and edit the. PA-DFD if necessary. We have also identified and addressed ambiguities and inaccuracies in the high-level transformation proposed in previous work. We apply our approach to two realistic applications from the construction and online retail sectors.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "A collaborative access control framework for online social networks\n", "abstract": " Most Online Social Networks allow users to set their privacy settings concerning posting information, but current implementations do not allow a fine grained enforcement in case the posted item concerns other users. In this paper we propose a new collaborative access control framework that takes into account the relation of multiple users for viewing as well as for sharing items, eventually solving conflicts in the privacy settings of the users involved. Our solution relies on two algorithms, one for viewing and another one for sharing items. We provide an evaluation of these algorithms where we demonstrate how varying some of the parameters directly influences the decision of viewing or sharing an item. Last but not least, we present a proof-of-concept implementation of our approach in an open source social network called Diaspora.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Migrating Monitors+ ABE: A Suitable Combination for Secure IoT?\n", "abstract": " The rise of the Internet of Things brings about various challenges concerning safety, reliability and dependability as well as security and privacy. Reliability and safety issues could be addressed by using different verification techniques, both statically and at runtime. In particular, migrating monitors could effectively be used not only for verification purposes, but also as a way to gather information and to enforce certain policies. The addition of monitors, however, might introduce additional security and privacy threats. In this extended abstract we briefly sketch ideas on how to combine migrating monitors with a public cryptographic scheme named Attribute-Based Encryption as a way to ensure monitors are run by the right devices in a secure and private manner.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Reliable smart contracts: State-of-the-art, applications, challenges and future directions\n", "abstract": " The popularization of blockchain technologies have brought a sudden interest in software that executes on top of blockchain, the so called smart contracts, with many potential applications, from financial contracts to unforgeable elections. Smart contracts are pieces of software that manipulate the shared data stored in the blockchain, with the promise that no central authority can forge or manipulate the execution or its results. This promise also involves an important risk, as well-intentioned users cannot easily roll-back undesired effects due to errors, or prevent other users from finding and exploiting loop-holes in deployed smart contracts. In this ISoLA track we seek to attract a variety of experts in the different aspects of smart contract reliability, discuss the state of the art and explore avenues for future research.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Timed Epistemic Knowledge Bases for Social Networks (Extended Version)\n", "abstract": " We present an epistemic logic equipped with time-stamps in the atoms and epistemic operators, which allows to reason not only about information available to the different agents, but also about the moments at which events happens and new knowledge is acquired or deduced. Our logic includes both an epistemic operator and a belief operator, which allows to model the disclosure of information that may not be accurate. Our main motivation is to model rich privacy policies in online social networks. Online Social Networks (OSNs) are increasingly used for social interactions in the modern digital era, which bring new challenges and concerns in terms of privacy. Most social networks today offer very limited mechanisms to express the desires of users in terms of how information that affects their privacy is shared. In particular, most current privacy policy formalisms allow only static policies, which are not rich enough to express timed properties like \"my location after work should not be disclosed to my boss\". The logic we present in this paper enables to express rich properties and policies in terms of the knowledge available to the different users and the precise time of actions and deductions. Our framework can be instantiated for different OSNs, by specifying the effect of the actions in the evolution of the social network and in the knowledge disclosed to each agent. We present an algorithm for deducing knowledge, which can also be instantiated with different variants of how the epistemic information is preserved through time. Our algorithm allows to model not only social networks with eternal information but also networks with ephemeral disclosures\u00a0\u2026", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Specification, design, and verification of an accountability-aware surveillance protocol\n", "abstract": " Though controversial, surveillance activities are more and more performed for security reasons. However, such activities are extremely privacy-intrusive. This is seen as a necessary side-effect to ensure the success of such operations. In this paper, we propose an accountability-aware protocol designed for surveillance purposes. It relies on a strong incentive for a surveillance organisation to register its activity to a data protection authority. We first elicit a list of account-ability requirements, we provide an architecture showing the interaction of the different involved parties, and we propose an accountability-aware protocol which is formally specified in the applied pi calculus. We use the ProVerif tool to automatically verify that the protocol respects confidentiality, integrity and authentication properties.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Participatory verification of railway infrastructure regulations using RailCNL (long version)\n", "abstract": " Previously, we have worked on verification of railway regulations against CAD designs, and integrated a verification engine into the tool chain of railway engineers. This tool was used successfully in a pilot project at RailCOMPLETE AS, (formerly Anacon AS). However, the engineers were reluctant to accept the verification results because they did not have control over the properties being verified. To allow engineers with limited logic programming experience to participate in defining and maintaining the verification properties, we design a controlled natural language (CNL) which contains constructs corresponding closely to the regulation texts. The CNL is translated automatically into the Datalog input language of the verification engine. We demonstrate a prototype system which, upon detecting regulation violations, traces back from errors in the design through the CNL to the marked-up original text, thus allowing domain experts to examine the correctness of each translation step. We describe a methodology based on CNL best practices and previous experience with creating verification front-end languages. By designing the CNL\u2019s structure specifically to support our use case, the language stays natural and readable for non-programmers, allowing railway engineers to better understand verification properties and to participate in improving the system.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "On the runtime enforcement of evolving privacy policies in online social networks\n", "abstract": " Online Social Networks have increased the need to understand well and extend the expressiveness of privacy policies. In particular, the need to be able to define and enforce dynamic (and recurrent) policies that are activated or deactivated by context (events) or timeouts. We propose an automaton-based approach to define and enforce such policies using runtime verification techniques. In this paper we discuss how our proposed solution addresses this problem without focussing on concrete technical details.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Automatic testing of real-time graphics systems\n", "abstract": " In this paper we deal with the general topic of verification of real-time graphics systems. In particular we present the Runtime Graphics Verification Framework (RUGVEF), where we combine techniques from runtime verification and image analysis to automate testing of graphics systems. We provide a proof of concept in the form of a case study, where RUGVEF is evaluated in an industrial setting to verify an on-air graphics playout system used by the Swedish Broadcasting Corporation. We report on experimental results from the evaluation, in particular the discovery of five previously unknown defects.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "The Glory of the Past and Geometrical Concurrency\u2013technicalities\n", "abstract": " This paper contributes to the general understanding of the geometrical model of concurrency that was named higher dimensional automata (HDAs) by Pratt and van Glabbeek. In particular we provide some understanding of the modal logics for such models and their expressive power in terms of the bisimulation that can be captured. The geometric model of concurrency is interesting from two main reasons: its generality and expressiveness, and the natural way in which autoconcurrency and action refinement are captured. Logics for this model, though, are not well investigated, where a simple, yet adequate, modal logic over HDAs was only recently introduced. As this modal logic, with two existential modalities, during and after, captures only split bisimulation, which is rather low in the spectrum of van Glabbeek and Vaandrager, the immediate question was what small extension of this logic could capture the more\u00a0\u2026", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Automated analysis of conflicts in software product lines\n", "abstract": " In this paper we propose a framework where the behaviour of features can be modelled using a visual model language for contracts (CO Diagrams). We present a partial translation from CO Diagrams into the deontic contract language CL allowing to detect whether there are contradicting features, using the tool CLAN. We aim at handling conflicts arising from software evolution and variability. As a proof of concept we apply our technique to a trading system case study.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "On the decidability of the reachability problem for GSPDIs\n", "abstract": " \u041d \u0438 \u0438 \u0438 \u042b\u0428 \u0421\u0437 \u043a \u0438 \u0433\u0433 \u0432 \u0437\u0437 \u0434\u0436\u0433\u0434 \u0436\u0438\u043d\u0418 \u041a \u041a \u0438 \u043d\u0432 \u0431 \u0437 \u0433 \u0432\u043d \u0436 \u0433\u0432 \u0433 \u0438 \u042b\u0428 \u0421 \u0414\u0430\u0433 \u0438 \u0433\u0432 \u0433 \u0438 \u0433\u0436\u0436 \u0437\u0434\u0433\u0432 \u0432 \u0439\u0438\u0433\u0431 \u0438\u0433\u0432\u0415 \u0433 \u0437 \u0432\u0433\u0438 \u0430\u0430\u0433\u043b \u0438\u0436 \u0419 \u0438\u0433\u0436\u043d \u0438\u0433 \u0438\u0436 \u043a \u0436\u0437 \u0432\u043d \u0433 \u0438 \u0434\u0433\u0430\u043d \u0433\u0432 \u0432 \u0432 \u0438 \u0436 \u0433\u0432 \u0432 \u0433\u0438 \u0436 \u0438 \u0433\u0432\u0437\u041a \u042c \u0432 \u0430\u0430\u043d \u0438 \u0437 \u0431 \u0432\u0437 \u0438 \u0438 \u0438 \u0436 \u0438\u0433\u0436 \u043a \u0438\u0433\u0436 \u0433 \u0432\u0432\u0433\u0438 \u0433 \u0419 \u0438 \u0432 \u0437 \u0434\u0433\u0437 \u0438 \u043a \u0430 \u0432 \u0436 \u0433\u0431 \u0432 \u0438 \u0433\u0432 \u0433 \u0438 \u043a \u0438\u0433\u0436\u0437 \u0432 \u0432 \u0438 \u043d\u0432 \u0431 \u0437\u041a \u0432 \u042b\u0428 \u0421 \u043b \u0438 \u0433\u0439\u0438 \u0438 \u0433\u0433 \u0432 \u0437\u0437 \u0434\u0436\u0433\u0434 \u0436\u0438\u043d \u0437 \u0430\u0430 \u0432 \u0436 \u0430 \u042b\u0428 \u0421 \u0433\u0436 \u042b\u0428 \u0421 \u0433\u0436 \u0437 \u0433\u0436\u0438\u041a \u042f \u043a \u043b\u0436\u0433\u0432 \u0430\u043d \u0430 \u0431 \u0432 \u042b \u041c\u041e\u0418 \u0434\u041a\u2104 \u0438 \u0438 \u0438 \u0436 \u0430 \u0438\u043d \u0434\u0436\u0433 \u0430 \u0431 \u0433\u0436 \u042b\u0428 \u0421 \u0437 \u0430 \u041a \u042c \u0434\u0436\u0433\u0433 \u0437 \u0438 \u043b \u0437 \u0433\u0432 \u0439 \u0438 \u043d \u0434\u0436\u0433\u043a \u0432 \u0438 \u0438 \u0432\u043d \u042b\u0428 \u0421 \u0432 \u0436 \u0439 \u0438\u0433 \u0437 \u0438 \u0433 \u042b\u0428 \u0421\u0437\u0418 \u0434\u0436 \u0437 \u0436\u043a \u0432 \u0436 \u0430\u0419 \u0438\u043d\u041a \u042c \u0434\u0436\u0433\u0433 \u0437 \u0438 \u0418 \u0437 \u0434\u0436 \u0437 \u0432\u0438 \u0418 \u0437 \u0432\u0433\u0438 \u0433\u0431\u0434\u0430 \u0438 \u0430\u043d \u043b\u0436\u0433\u0432 \u0439\u0438 \u0432 \u0433\u0431\u0434\u0430 \u0438 \u0418 \u0430 \u0438\u0438 \u0432 \u0438 \u0430 \u0438\u043d \u0433\u0432 \u0430\u0439\u0437 \u0433\u0432 \u0438\u0433 \u0437\u0438 \u0430\u0430 \u0432 \u0433\u0432 \u0430\u0439\u0437 \u043a \u041a \u042d\u0432 \u0433\u0436\u0438\u0439\u0432 \u0438 \u0430\u043d \u043b \u043a \u0437 \u0433\u043a \u0436 \u0437\u0439 \u0431 \u0437\u0438 \u0432 \u042b \u0434\u0438 \u0431 \u0436 \u041e\u041c\u041c\u041e\u0418 \u0439\u0437\u0438 \u043b \u0431\u0433\u0432\u0438 \u0437 \u0438 \u0436 \u0438 \u0432 \u0430 \u0434\u0436 \u0432\u0438 \u0433 \u0438 \u0438 \u0437 \u0437\u041a \u042f \u0433\u0432\u0437 \u0436 \u0438 \u043b \u0437 \u0432\u0433\u0438 \u043b\u0433\u0436\u0438 \u0434\u0439 \u0430 \u0437 \u0432 \u0436 \u0439\u0438 \u0438 \u0433\u0432 \u0433 \u0438 \u0436 \u0437\u0439\u0430\u0438 \u0438 \u0438 \u0438 \u0431\u0433\u0431 \u0432\u0438 \u0437 \u0432 \u0438 \u0436 \u043b \u0437 \u0432\u0433 \u0436 \u0437 \u0436 \u0432 \u0433\u0432 \u0439 \u0438 \u0432 \u0438 \u0438 \u0436 \u0438 \u0433\u0432 \u0438 \u0432\u041a \u042f \u0436 \u043a \u043a \u0433\u0439\u0436 \u0432\u0438 \u0436 \u0437\u0438 \u0433\u0432 \u0438 \u0437\u0439 \u0438 \u0432 \u0433\u0432\u0430\u043d \u0436 \u0432\u0438\u0430\u043d \u0439 \u0438\u0433 \u0438 \u0434\u0439 \u0430 \u0438 \u0433\u0432 \u0433 \u0438 \u0434 \u0434 \u0436 \u0425\u0428\u041c\u2104 \u0418 \u0432 \u043b \u0438 \u0436\u0433\u0432\u0438 \u0436 \u0438\u043b \u0432 \u0430 \u0432 \u0439\u0432 \u0430 \u043d \u0436 \u0437\u043d\u0437\u0438 \u0431\u0437 \u0437 \u0436 \u043a \u0437 \u0438 \u0418 \u0438\u0433 \u0436 \u0432 \u0434\u0436 \u043a \u0433\u0439\u0437 \u0436 \u0437\u0439\u0430\u0438 \u043a \u0432 \u0432 \u042b\u041c\u041e\u2104 \u041a \u042c \u0430 \u0438\u043d \u0433 \u0436 \u0430 \u0438\u043d \u0433 \u042b\u0428 \u0421\u0437 \u043b\u0433\u0439\u0430 \u043a \u0433\u0432\u0438\u0436 \u0439\u0438 \u0438\u0433 \u0432 \u0436\u0436\u0433\u043b \u0438 \u0439\u0432 \u0430 \u0438\u043d \u0436\u0433\u0432\u0438 \u0436 \u043b \u0438 \u0438 \u0436 \u0437\u0439\u0430\u0438 \u0434\u0436 \u0437 \u0432\u0438 \u0436 \u043b \u0430 \u0438 \u0438 \u0437\u0438 \u0430\u0430 \u0433\u0434 \u0432\u0418 \u0439\u0432 \u0433\u0436\u0438\u0439\u0432 \u0438 \u0430\u043d\u041a \u0421\u0432 \u0438 \u0437 \u0434 \u0434 \u0436 \u043b \u0434\u0436\u0433\u043a \u0433\u0439\u0432\u0438 \u0436\u0419 \u043c \u0431\u0434\u0430 \u0438\u0433 \u0438 \u0430 \u0431 \u0433 \u0438 \u0430 \u0438\u043d \u0433 \u0438 \u0436 \u0430 \u0438\u043d \u0434\u0436\u0433 \u0430 \u0431 \u0433\u0436 \u042b\u0428 \u0421\u0437 \u043a \u0432 \u0432 \u042b \u041c\u041e\u0418 \u0434\u041a\u2104 \u0418 \u043b \u0436 \u0431 \u0432 \u0438 \u0439\u0437 \u0432 \u0433\u0434 \u0432 \u0434\u0436\u0433 \u0430 \u0431\u041a \u042f \u0434\u0436\u0433\u043a \u0418 \u0432 \u0418 \u0438 \u0438 \u042b\u0428 \u0421 \u0436 \u0430 \u0438\u043d \u0432\u0432\u0433\u0438 \u0436 \u0439 \u0438\u0433 \u042b\u0428 \u0421 \u0436 \u0430 \u0438\u043d\u041a \u042f \u0436 \u0434 \u0436 \u0437 \u0438 \u0436 \u0437\u0439\u0430\u0438\u0437 \u043a \u0432 \u0432 \u042b \u041c\u041e\u2104 \u0438\u0433 \u043a \u0437 \u0431 \u0419 \u0430 \u0430 \u0433\u0436 \u0438 \u0431 \u0433\u0436 \u0437\u0433\u0430\u043a \u0432 \u0438 \u0436 \u0430 \u0438\u043d \u0434\u0436\u0433 \u0430 \u0431 \u0433\u0436 \u042b\u0428 \u0421\u0437\u041a\u042c \u0434 \u0434 \u0436 \u0437 \u0433\u0436 \u0432 \u043e \u0437 \u0433\u0430\u0430\u0433\u043b\u0437\u041a \u0421\u0432 \u0432 \u043c\u0438 \u0437 \u0438 \u0433\u0432 \u043b \u043c\u0434\u0430 \u0432 \u0432 \u0433\u0436\u0431 \u0430\u0430\u043d \u0438 \u0434\u0436\u0433 \u0430 \u0431\u0437 \u0436 \u0437 \u0432 \u043b \u0432 \u0436 \u0430 \u043c \u0432 \u0433\u0433 \u0432 \u0437\u0437 \u043b \u0430 \u0432 \u042b \u0438 \u0433\u0432 \u041f \u043b \u043a \u0437\u0433\u0431 \u0434\u0436 \u0430 \u0431 \u0432 \u0436 \u0437\u0418 \u0434\u0436\u0433\u043a \u0432 \u0439\u0437 \u0439\u0430 \u0432\u0433\u0438 \u0438 \u0433\u0432 \u0432 \u0432 \u0438 \u0433\u0432\u0437 \u0432 \u0436 \u0430\u0430 \u0432 \u0438 \u0419 \u0432 \u0438 \u0433\u0432 \u0433 \u042b\u0428 \u0421\u041a \u0421\u0432 \u042b \u0438 \u0433\u0432 \u043b \u0434\u0436 \u0437 \u0432\u0438 \u042b\u0428 \u0421\u0437\u041a \u042b \u0438 \u0433\u0432 \u0437 \u0433\u0432 \u0436\u0432 \u043b \u0438 \u0438 \u0432 \u0430\u043d\u0437 \u0437 \u0433 \u0438\u0436 \u0438\u0433\u0436 \u0437\u0418 \u0434\u0436\u0433\u043a \u0432 \u0437\u0433\u0431 \u0436 \u0437\u0439\u0430\u0438\u0437 \u0432 \u0438\u0433 \u0437\u0438 \u0430 \u0437 \u0438 \u0437 \u0431 \u0419 \u0437 \u0433\u0432 \u0430 \u0433\u0436 \u0438 \u0431 \u0433\u0436 \u0436 \u0430 \u0438\u043d \u0434\u0436 \u0437\u00a0\u2026", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Reachability analysis of generalized polygonal hybrid systems\n", "abstract": " A polygonal hybrid system (SPDIs) is a planar hybrid system, whose dynamics is defined by constant differential inclusions, for which the reachability problem is decidable. The decidability result is based, among other things, on the fact that a trajectory cannot enter and leave a given region through the same edge. SPDIs without such an assumption are called Generalized SPDIs (GSPDIs). In this paper we show that in general it is not possible to reduce GSPDI reachability to SPDI reachability. Furthermore, we provide a terminating algorithm implementing a semi-test for GSPDI reachability, based on that for SPDIs.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Towards Model-Checking Contracts\n", "abstract": " Expressing contrary-to-duty (CTDs) OC (\u03b1)= O (\u03b1)\u2227[\u03b1] C Expressing contrary-to-prohibition (CTPs) FC (\u03b1)= F (\u03b1)\u2227[\u03b1] C In case the client delays the payment, after notification he must immediately lower the Internet tra c to the low level, and pay later twice. If the client does not lower the Internet tra c immediately, then the client will have to pay three times. D ([d&n](OC (l)\u2227[l] 0 (O (p&p)) where C= 0O (p&p&p) There is a taste of resource-awareness in the actions.", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Software engineering and formal methods\n", "abstract": " This volume contains the proceedings of the 9th International Conference on Software Engineering and Formal Methods (SEFM 2011) held on November 14\u201318, 2011 in Montevideo, Uruguay, under the auspices of the Facultad de Ingenier\u0131a (InCo), Universidad de la Rep\u00fablica, Uruguay. The aim of SEFM is to bring together practitioners and researchers from academia, industry and government to advance the state of the art in formal methods, to scale up their application in software industry and to encourage their integration with practical engineering methods.The Program Committee of SEFM 2011 received 105 abstracts and 85 full submissions from all over the world. We would like to thank all authors for submitting their papers. Each paper was reviewed by at least three reviewers. Based on the review reports and intensive discussions conducted electronically, the Program Committee selected 22 regular\u00a0\u2026", "num_citations": "2\n", "authors": ["1653"]}
{"title": "Refining Privacy-Aware Data Flow Diagrams\n", "abstract": " Privacy, like security, is a non-functional property, yet most software design tools are focused on functional aspects, using for instance Data Flow Diagrams (DFDs). In previous work, a conceptual model was introduced where DFDs were extended into so-called Privacy-Aware Data Flow Diagrams (PA-DFDs) with the aim of adding specific privacy checks to existing DFDs. An implementation to add such automatic checks has also been developed. In this paper, we define the notion of refinement for both DFDs and PA-DFDs as a special type of structure-preserving map (or graph homomorphism). We also provide three algorithms to find, check and transform refinements, and we show that the standard diagram \u201ctransformrefine/refinetransform\u201d commutes. We have implemented our algorithms in a proof-of-concept tool called DFD Refinery, and have applied it to realistic scenarios.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Transforming Data Flow Diagrams for Privacy Compliance.\n", "abstract": " Most software design tools, as for instance Data Flow Diagrams (DFDs), are focused on functional aspects and cannot thus model non-functional aspects like privacy. In this paper, we provide an explicit algorithm and a proof-of-concept implementation to transform DFDs into so-called Privacy-Aware Data Flow Diagrams (PA-DFDs). Our tool systematically inserts privacy checks to a DFD, generating a PA-DFD. We apply our approach to two realistic applications from the construction and online retail sectors.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Privacy Labelling and the Story of Princess Privacy and the Seven Helpers\n", "abstract": " Privacy is currently in 'distress' and in need of 'rescue', much like princesses in the all-familiar fairytales. We employ storytelling and metaphors from fairytales to make reader-friendly and streamline our arguments about how a complex concept of Privacy Labeling (the 'knight in shining armour') can be a solution to the current state of Privacy (the 'princess in distress'). We give a precise definition of Privacy Labeling (PL), painting a panoptic portrait from seven different perspectives (the 'seven helpers'): Business, Legal, Regulatory, Usability and Human Factors, Educative, Technological, and Multidisciplinary. We describe a common vision, proposing several important 'traits of character' of PL as well as identifying 'undeveloped potentialities', i.e., open problems on which the community can focus. More specifically, this position paper identifies the stakeholders of the PL and their needs with regard to privacy, describing how PL should be and look like in order to address these needs. Throughout the paper, we highlight goals, characteristics, open problems, and starting points for creating, what we define as, the ideal PL. In the end we present three approaches to establish and manage PL, through: self-evaluations, certifications, or community endeavors. Based on these, we sketch a roadmap for future developments.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Reliable Smart Contracts\n", "abstract": " The rise of smart contracts executed on blockchain and other distributed ledger technologies enabled trustless yet decentralised computation. Various applications take advantage of this computational model, including enforced financial contracts, self-sovereign identity and voting. But smart contracts are nothing but software running on a blockchain, with risks of malfunction due to bugs in the code. Compared to traditional systems, there is an additional risk in that erroneous computation or transactions triggered by a smart contract cannot be easily rolled back due to the immutability of the underlying execution model. This ISoLA track brings together a number of experts in the field of smart contract reliability and verification to discuss the state-of-the-art in smart contract dependability and discuss research challenges and future directions.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "On the specification and enforcement of privacy-preserving contractual agreements\n", "abstract": " We are here concerned with the enforcement at runtime of contractual agreements (e.g., Terms of Service) that respect users\u2019 privacy policies. We do not provide a technical solution to the problem but rather give an overview of a framework for such an enforcement, and briefly discuss related work and ideas on how to address part of the framework.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Specification and Verification of Normative Specifications using CO Diagrams\n", "abstract": " CO Diagrams have been introduced as a means to have a more visual representation of normative texts and electronic contracts, where it is possible to represent the obligations, permissions and prohibitions of the different signatories, as well as what are the penalties in case of not fulfilment of their obligations and prohibitions. In such diagrams we are also able to represent absolute and relative timing constraints. In this paper we present a formal semantics for CO Diagrams based on timed automata extended with an ordering of states and edges in order to represent different deontic modalities. As a proof of concept we apply our approach to two different case studies.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Formal languages and analysis of contract-oriented software\n", "abstract": " Formal languages and analysis of contract-oriented software \u00d7 Close The Infona portal uses cookies, ie strings of text saved by a browser on the user's device. The portal can access those files and use them to remember the user's data, such as their chosen settings (screen view, interface language, etc.), or their login data. By using the Infona portal the user accepts automatic saving and using this information for portal operation purposes. More information on the subject can be found in the Privacy Policy and Terms of Service. By closing this window the user confirms that they have read the information on cookie usage, and they accept the privacy policy and the way cookies are used by the portal. You can change the cookie settings in your browser. I accept Polski English Login or register account remember me Password recovery INFONA - science communication portal INFONA Search advanced search Browse \u2026", "num_citations": "1\n", "authors": ["1653"]}
{"title": "A decidable logic for complex contracts\n", "abstract": " 2 ResultsThe syntax of CL is defined by the grammar in Table 1. We call a formula C a contract clause (or plainly contract). A contract is built up from propositional constants \u03c6, obligations OC (\u03b1) of actions \u03b1, permissions P (\u03b1), and prohibitions FC (\u03b1)(ie, the deontic modalities applied over actions \u03b1). CL includes directly in the definition of the obligation and prohibition the reparations C in case of violations (ie, whenever \u03b1 is not performed, in the case of an obligation). Contracts are combined using the standard Boolean operators\u2192 and\u22a5 from which all other can be derived. Moreover, contracts may be prefixed by the dynamic logic modality [\u03b2] C which is read as:\u201cafter performing action \u03b2 then the contract C must hold. The deontic actions \u03b1 are constructed from a finite set of basic actions AB using the operations of synchrony\u00d7, sequence\u00b7, and choice+. The dynamic actions have the extra operations of Kleene star\u2217 and tests \u03d5?. Tests are constructed with the Boolean operators from the propositional constants \u03c6. Therefore, we do not have the full power of PDL but only that of poor tests PDL.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Computation and visualisation of phase portraits for model checking SPDIs\n", "abstract": " Hybrid systems combining discrete and continuous dynamics arise as mathematical models of various artificial and natural systems, and as an approximation to complex continuous systems. Reachability analysis has been the principal research question in the verification of hybrid systems, even though it is a wellknown result that most non-trivial subclasses of hybrid systems reachability and most verification problems are undecidable [1]. Nonetheless, various decidable subclasses have been identified, including polygonal hybrid systems (SPDIs) [2]. SPDIs can be used, for instance, in the analysis of approximations of non-linear differential equations in two-dimensions.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Relaxing goodness is still good for SPDIs\n", "abstract": " Polygonal hybrid systems (SPDIs) are planar hybrid systems, whose dynamics are defined in terms of constant differential inclusions, one for each of a number of polygonal regions partitioning the plane. The reachability problem for SPDIs is known to be decidable, but depends on the goodness assumption \u2014 which states that the dynamics do not allow a trajectory to both enter and leave a region through the same edge. In this paper we extend the decidability result to generalised SPDIs (GSPDI), SPDIs not satisfying the goodness property, and give an algorithmic solution to decide reachability of such systems.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "A practical approach to runtime verification of real-time properties for Java programs\n", "abstract": " Given the intractability of exhaustively verifying soft-ware, the use of runtime-verification to verify single execution paths at runtime, is becoming increasingly popular in industrial settings. In this paper we present dynamic communicating automata with timers and events to describe properties of systems, implemented in LARVA, an event-based runtime verification tool for monitoring temporal and contextual properties of Java programs. We give the mathematical framework behind LARVAand show how real time logics can be trans-lated into LARVAproviding additional benefits to the runtime monitoring framework. These benefits include guarantees on the memory upperbound required for the monitoring system and guarantees on the effect of varying the execution speed of the system with regards to real-time properties. Index Terms runtime verification, real-time properties, duration cal-culus 1.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Contract-based internet service software development: A proposal\n", "abstract": " \u2217 \u042b\u0421 \u042b\u0418 \u0428\u041a\u0427\u041a \u0433\u043c \u041d\u041e \u041f\u0418 \u042b \u0419\u041d \u041e \u0423 \u0437\u0438 \u0418 \u042b\u043b \u0432\u041a \u0419\u0431 \u0430 \u0434 \u0430\u0433 \u0437 \u0437\u041a\u0437\u2020 \u0434\u0438\u041a \u0433 \u0421\u0432 \u0433\u0436\u0431 \u0438 \u0437 \u042d\u0432 \u043a\u041a \u0433 \u0427\u0437\u0430\u0433\u0418 \u0428\u041a\u0427\u041a \u0433\u043c \u041d\u041c \u041c \u0430 \u0432 \u0436\u0432\u0418 \u0426\u0419\u041c\u041f\u041d \u0427\u0437\u0430\u0433\u0418 \u0426\u0433\u0436\u043b \u043d\u041a \u0419\u0431 \u0430 \u0433\u0430 \u041a\u0439 \u0433\u041a\u0432\u0433\u2021 \u0434\u0438\u041a \u0433 \u0421\u0432 \u0433\u0436\u0431 \u0438 \u0437 \u042d\u0432 \u043a\u041a \u0433 \u0427\u0437\u0430\u0433\u0418 \u0428\u041a\u0427\u041a \u0433\u043c \u041d\u041c \u041c \u0430 \u0432 \u0436\u0432\u0418 \u0426\u0419\u041c\u041f\u041d \u0427\u0437\u0430\u0433\u0418 \u0426\u0433\u0436\u043b \u043d\u041a \u0419\u0431 \u0430 \u0436 \u0436 \u0433 \u041a\u0439 \u0433\u041a\u0432\u0433", "num_citations": "1\n", "authors": ["1653"]}
{"title": "A Backward/Forward Strategy for Verifying Safety Properties of Infinite\u2013State Systems\n", "abstract": " \u041d\u042d\u0434\u0434\u0437 \u0430 \u042d\u0432 \u043a \u0436\u0437 \u0438\u043d\u0418 \u0434 \u0436\u0438\u0431 \u0432\u0438 \u0433 \u0433\u0431\u0434\u0439\u0438 \u0436 \u042b\u043d\u0437\u0438 \u0431\u0437\u0418 \u0433\u043c \u041f\u041f \u0418 \u041d \u041c \u042d\u0434\u0434\u0437 \u0430 \u0418 \u042b\u043b \u0432 \u043f\u0425 \u0430 \u0425 \u0430\u041a \u0430 \u0431\u0439\u0437\u0418 \u0436 \u0436 \u0433\u041a\u042b \u0432 \u0436 \u0438\u041a\u0439\u0439\u041a\u0437 \u041f\u042d\u0432 \u043a \u0436\u0437 \u0438\u043d \u0433 \u0436 \u0439\u0436 \u0418 \u0434 \u0436\u0438\u0431 \u0432\u0438 \u0433 \u0433\u0431\u0434\u0439\u0438 \u0436 \u042b \u0432 \u0418 \u0433\u0436 \u0437\u043f\u0423 \u0433 \u0430 \u0436\u043f \u0430\u0430 \u041d\u0418 \u041d\u041d\u041c \u0436 \u0439\u0436 \u0418 \u0436\u0431 \u0432\u043d \u043f\u0425 \u0430 \u0431 \u043d\u0436\u0436 \u0432 \u0433\u0436\u0431 \u0438 \u041a\u0439\u0432 \u0419 \u0436 \u0439\u0436 \u041a \u0437\u0438\u0436 \u0438\u041a \u042c \u0437 \u0434 \u0434 \u0436 \u0437 \u0438\u043b\u0433 \u0431 \u0432 \u0433\u0432\u0438\u0436 \u0439\u0438 \u0433\u0432\u0437 \u0433\u0436 \u0433\u0432 \u0418 \u043b \u0437 \u0436 \u0432 \u0436 \u0430 \u0431 \u0438 \u0433 \u0433\u0436 \u043a \u0436 \u043d \u0432 \u0437 \u0438\u043d \u0434\u0436\u0433\u0434 \u0436\u0438 \u0437 \u0433 \u0432\u0433\u0432\u043f\u043b \u0430\u0430\u043f\u0435\u0439 \u0437 \u043f\u0433\u0436 \u0436 \u0432\u040c\u0432 \u0438 \u043f\u0437\u0438 \u0438 \u0437\u043d\u0437\u0438 \u0431\u0437 \u0433\u0436 \u043b \u0436 \u0430 \u0438\u043d \u0437 \u0439\u0432 \u0430 \u0432 \u0432 \u0436 \u0430\u0418 \u0438 \u0435\u0439 \u0437\u0438 \u0433\u0432 \u0432 \u043b \u0438 \u0436 \u0437 \u0438 \u042d \u0433 \u0433\u0432\u040c \u0439\u0436 \u0438 \u0433\u0432\u0437 \u0437 \u0436 \u0430 \u041a \u0421\u0432 \u0431 \u0432\u043d \u0437 \u0437 \u0438 \u0437 \u0434\u0436\u0433 \u0430 \u0431 \u0432 \u0437\u0433\u0430\u043a \u0437 \u0433\u0430\u0430\u0433\u043b\u0437 \u0436\u0437\u0438\u0418 \u0433\u0432 \u0433\u0432\u0437\u0438\u0436\u0439 \u0438\u0437 \u043b \u0430\u0430\u043f\u0435\u0439 \u0437 \u043f\u0433\u0436 \u0436 \u0433\u043a \u0436 \u0434\u0434\u0436\u0433\u043c \u0431 \u0438 \u0433\u0432 \u0433 \u0438 \u0437\u043d\u0437\u0438 \u0431 \u0432 \u0435\u0439 \u0437\u0438 \u0433\u0432\u041a \u042c \u0436 \u043d \u0433\u0432 \u0432 \u0433\u0431\u0434\u0439\u0438 \u0432 \u0433\u043a \u0436 \u0434\u0434\u0436\u0433\u043c \u0431 \u0438 \u0433\u0432 \u0433 \u0438 \u0437 \u0438 \u0428\u0436\u0403\u0414\u042d\u0415 \u0433 \u0430\u0430 \u0434\u0436 \u0437\u0437\u0433\u0436\u0437 \u0433 \u042d\u041a \u042b \u0433\u0432 \u0418 \u0433\u0432 \u0434 \u0436 \u0433\u0436\u0431\u0437 \u0432 \u043c \u0438 \u0433\u0439\u0432 \u0433\u0436\u043b \u0436 \u0437 \u0436 \u0433\u0436 \u042d \u0414\u0437\u0438 \u0436\u0438 \u0432 \u0438 \u0438 \u0432 \u0438 \u0430 \u0437\u0438 \u0438 \u0415 \u043b \u0430\u043b \u043d\u0437 \u0437\u0438 \u043d\u0437 \u0432\u0437 \u0438 \u0430\u0436 \u043d \u0433\u0431\u0434\u0439\u0438 \u0433\u043a \u0436 \u0434\u0434\u0436\u0433\u043c \u0431 \u0438 \u0433\u0432 \u0433 \u0428\u0436\u0403\u0414\u042d\u0415\u0418 \u0438 \u0439\u0437 \u0439\u0436 \u0432 \u0438 \u0437 \u0436 \u0437\u0434 \u041a \u042c \u0437 \u0436 \u0437\u0438\u0436 \u0438 \u0433\u0436\u043b \u0436 \u0437 \u0436 \u0437 \u0431\u0433\u0436 \u0426 \u0432\u0438 \u0438 \u0432 \u0432\u0433\u0436\u0431 \u0430 \u0433\u0436\u043b \u0436 \u0437 \u0436 \u0418 \u043d \u0430 \u0432 \u0432\u0437\u043b \u0436\u0437 \u0433 \u0438 \u0433\u0436\u0431 \u042b\u0418 \u0426\u0427\u0418 \u0433\u0436 \u042d\u0426\u0423\u0426\u0427\u042f\u0426\u0418 \u043b \u0436 \u0438 \u042b \u0432 \u0426\u0427 \u0432\u0437\u043b \u0436\u0437 \u0436 \u0430\u043b \u043d\u0437 \u0433\u0436\u0436 \u0438\u041a \u0437 \u0433\u0439\u0436 \u0437 \u0433\u0432 \u0431 \u0432 \u0433\u0432\u0438\u0436 \u0439\u0438 \u0433\u0432 \u0436 \u0432\u0418 \u043b \u0434\u0434\u0430\u043d \u0433\u0439\u0436 \u0431 \u0438 \u0433 \u0438\u0433 \u0436 \u0430 \u0430\u0430 \u0432 \u043f \u0436 \u042b \u043b \u0438 \u040c\u0432 \u0438 \u0437\u0439\u0431\u0437\u0418 \u043b \u0437 \u0430\u0436 \u043d \u0434\u0436\u0433 \u0437\u0437 \u0430 \u0439\u0430\u0439\u0437 \u0433\u0436 \u043b \u0436 \u0430 \u0438\u043d \u0437 \u0439\u0432 \u0430 \u041a \u042c\u0433 \u0433\u0439\u0436 \u0432\u0433\u043b\u0430 \u0418 \u0438 \u0437 \u0434 \u0436\u0438 \u0437 \u0438\u0439 \u0430\u0430\u043d \u0438 \u040c\u0436\u0437\u0438 \u0434\u0434\u0430 \u0438 \u0433\u0432 \u0433 \u043b \u0430\u0430\u043f\u0437\u0438\u0436\u0439 \u0438 \u0436 \u0437\u043d\u0437\u0438 \u0431\u0437 \u0438\u0433 \u043a \u0436 \u043d \u0432 \u0437 \u0438\u043d \u0434\u0436\u0433\u0434 \u0436\u0438 \u0437 \u0432 \u0434\u0436\u0433 \u0437\u0437 \u0430 \u0439\u0430 \u041a \u042c \u0434\u0434\u0430 \u0438 \u0433\u0432 \u0437 \u0433\u0432 \u043a \u0437\u0434 \u0430 \u0428 \u0438\u0436 \u0432 \u0438\u0437 \u0437 \u0431 \u0432\u0438 \u0437 \u0433\u0436 \u0438 \u0430 \u0439\u0430\u0439\u0437 \u0438 \u0438 \u043b \u0433\u0432\u0437 \u0436\u041a", "num_citations": "1\n", "authors": ["1653"]}
{"title": "A Verilog specification of STARI\n", "abstract": " Verilog is a Hardware Description Language used for the design and description of hardware in a behavioral and structural way. It has some interesting features like concurrency, synchronism, shared variables, non-blocking assignments (scheduled assignments), timing controls, in nite computations, zero-time computations, etc., that makes it an interesting language to study. This report explains some features of Verilog in an informal way through small examples and presents the Verilog code of STARI as a main application.", "num_citations": "1\n", "authors": ["1653"]}
{"title": "Model Checking: A Complement to Test and Simulation\n", "abstract": " Model checking has been around for more than 20 years now, and has migrated from the purely research to the industrial arena. Nowadays, it is widely accepted that its application will enhance and complement existing validation techniques as simulation and test. I try to explain here in a non-technical manner what is\" model checking\".* Notice that this is intended to be\" popular\" account of what is model checking (always under improvement) and thus the notions here are intensionally informal, and maybe not completely precise. If you want a more formal and precise account see for instance the wikipedia entry and references therein.", "num_citations": "1\n", "authors": ["1653"]}