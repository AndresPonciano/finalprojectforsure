{"title": "Total order broadcast and multicast algorithms: Taxonomy and survey\n", "abstract": " Total order broadcast and multicast (also called atomic broadcast/multicast) present an important problem in distributed systems, especially with respect to fault-tolerance. In short, the primitive ensures that messages sent to a set of processes are, in turn, delivered by all those processes in the same total order.", "num_citations": "779\n", "authors": ["494"]}
{"title": "Probabilistic broadcast for flooding in wireless mobile ad hoc networks\n", "abstract": " Although far from the optimal, flooding is an indispensable message dissemination technique for network-wide broadcast within mobile ad hoc networks (MANETs). As such, the plain flooding algorithm provokes a high number of unnecessary packet rebroadcasts, causing contention, packet collisions and ultimately wasting precious limited bandwidth. We explore the phase transition phenomenon observed in percolation theory and random graphs as a basis for defining probabilistic flooding algorithm. By considering ideal and realistic models, we acquire a better understanding of the factors that determine phase transition, the consequences of the passage to realistic MANET conditions and to what extent we may benefit from probabilistic flooding in real MANET networks.", "num_citations": "647\n", "authors": ["494"]}
{"title": "Understanding replication in databases and distributed systems\n", "abstract": " Replication is an area of interest to both distributed systems and databases. The solutions developed from these two perspectives are conceptually similar but differ in many aspects: model, assumptions, mechanisms, guarantees provided, and implementation. In this paper, we provide an abstract and \"neutral\" framework to compare replication techniques from both communities. The framework has been designed to emphasize the role played by different mechanisms and to facilitate comparisons. The paper describes the replication techniques used in both communities, compares them, and points out ways in which they can be integrated to arrive to better, more robust replication protocols.", "num_citations": "589\n", "authors": ["494"]}
{"title": "Software-based replication for fault tolerance\n", "abstract": " Replication handled by software on off-the-shelf hardware costs less than using specialized hardware. Although an intuitive concept, replication requires sophisticated techniques for successful implementation. Group communication provides an adequate framework. We present a survey of the techniques developed since the mid-1980s to implement replicated services, emphasizing the relationship between replication techniques and group communication.", "num_citations": "587\n", "authors": ["494"]}
{"title": "On the accuracy of MANET simulators\n", "abstract": " The deployment of wireless applications or protocols in the context of Mobile Ad-hoc NETworks (MANETs), often requires to step through a simulation phase. For the results of the simulation to be meaningful, it is important that the model on which is based the simulator matches as closely as possible the reality. In this paper we present the simulation results of a straightforward algorithm using several popular simulators (OPNET Modeler, NS-2, GloMoSim). The results tend to show that significant divergences exist between the simulators. This can be explained partly by the mismatching of the modelisation of each simulator and also by the different levels of detail provided to implement and configure the simulated scenarios.", "num_citations": "533\n", "authors": ["494"]}
{"title": "Database replication techniques: A three parameter classification\n", "abstract": " Data replication is an increasingly important topic as databases are more and more deployed over clusters of workstations. One of the challenges in database replication is to introduce replication without severely affecting performance. Because of this difficulty, current database products use lazy replication, which is very efficient but can compromise consistency. As an alternative, eager replication guarantees consistency but most existing protocols have a prohibitive cost. In order to clarify the current state of the art and open up new avenues for research, this paper analyses existing eager techniques using three key parameters (server architecture, server interaction and transaction termination). In our analysis, we distinguish eight classes of eager replication protocols and, for each category, discuss its requirements, capabilities and cost. The contribution lies in showing when eager replication is feasible and in\u00a0\u2026", "num_citations": "322\n", "authors": ["494"]}
{"title": "The database state machine approach\n", "abstract": " Database replication protocols have historically been built on top of distributed database systems, and have consequently been designed and implemented using distributed transactional mechanisms, such as atomic commitment. We present the Database State Machine approach, a new way to deal with database replication in a cluster of servers. This approach relies on a powerful atomic broadcast primitive to propagate transactions between database servers, and alleviates the need for atomic commitment. Transaction commit is based on a certification test, and abort rate is reduced by the reordering certification test. The approach is evaluated using a detailed simulation model that shows the scalability of the system and the benefits of the reordering certification test.", "num_citations": "296\n", "authors": ["494"]}
{"title": "Early consensus in an asynchronous system with a weak failure detector\n", "abstract": " Consensus is one of the most fundamental problems in the context of fault-tolerant distributed computing. The problem consists, given a set \u03a9 of processes having each an initial value v                    i                 , in deciding among \u03a9 on a common value v. In 1985, Fischer, Lynch and Paterson proved that the consensus problem is not solvable in an asynchronous system subject to a single process crash. In 1991, Chandra and Toueg showed that, by augmenting the asynchronous system model with a well defined unreliable failure detector, consensus becomes solvable. They also give an algorithm that solves consensus using the \u25ca? failure detector. In this paper we propose a new consensus algorithm, also using the \u25ca? failure detector, that is more efficient than the Chandra-Toueg consensus algorithm. We measure efficiency by introducing the notion of latency degree, which defines the minimal number of\u00a0\u2026", "num_citations": "291\n", "authors": ["494"]}
{"title": "The heard-of model: computing in distributed systems with benign faults\n", "abstract": " Problems in fault-tolerant distributed computing have been studied in a variety of models. These models are structured around two central ideas: (1) degree of synchrony and failure model are two independent parameters that determine a particular type of system, (2) the notion of faulty component is helpful and even necessary for the analysis of distributed computations when faults occur. In this work, we question these two basic principles of fault-tolerant distributed computing, and show that it is both possible and worthy to renounce them in the context of benign faults: we present a computational model based only on the notion of transmission faults. In this model, computations evolve in rounds, and messages missed in a round are lost. Only information transmission is represented: for each round r and each process p, our model provides the set of processes that p \u201chears of\u201d at round r (heard-of set\u00a0\u2026", "num_citations": "262\n", "authors": ["494"]}
{"title": "A new algorithm to implement causal ordering\n", "abstract": " This paper presents a new algorithm to implement causal ordering. Causal ordering was first proposed in the ISIS system developed at Cornell University. The interest of causal ordering in a distributed system is that it is cheaper to realize than total ordering. The implementation of causal ordering proposed in this paper uses logical clocks of Mattern-Fidge (which define a partial order between events in a distributed system) and presents two advantages over the implementation in ISIS: (1) the information added to messages to ensure causal ordering is bounded by the number of sites in the system, and (2) no special protocol is needed to dispose of this added information when it has become useless. The implementation of ISIS presents however advantages in the case of site failures.", "num_citations": "227\n", "authors": ["494"]}
{"title": "Comparison of database replication techniques based on total order broadcast\n", "abstract": " In this paper, we present a performance comparison of database replication techniques based on total order broadcast. While the performance of total order broadcast-based replication techniques has been studied in previous papers, this paper presents many new contributions. First, it compares with each other techniques that were presented and evaluated separately, usually by comparing them to a classical replication scheme like distributed locking. Second, the evaluation is done using a finer network model than previous studies. Third, the paper compares techniques that offer the same consistency criterion (one-copy serializability) in the same environment using the same settings. The paper shows that, while networking performance has little influence in a LAN setting, the cost of synchronizing replicas is quite high. Because of this, total order broadcast-based techniques are very promising as they minimize\u00a0\u2026", "num_citations": "211\n", "authors": ["494"]}
{"title": "Neko: A single environment to simulate and prototype distributed algorithms\n", "abstract": " Designing, tuning, and analyzing the performance of distributed algorithms and protocols are complex tasks. A major factor that contributes to this complexity is the fact that there is no single environment to support all phases of the development of a distributed algorithm. This paper presents Neko, an easy to use Java platform that provides a uniform and extensible environment for the various phases of algorithm design and performance evaluation: prototyping, tuning, simulation, deployment, etc.", "num_citations": "188\n", "authors": ["494"]}
{"title": "Fault-tolerance by replication in distributed systems\n", "abstract": " The paper is a tutorial on fault-tolerance by replication in distributed systems. We start by defining linearizability as the correctness criterion for replicated services (or objects), and present the two main classes of replication techniques: primary-backup replication and active replication. We introduce group communication as the infrastructure providing the adequate multicast primitives to implement either primary-backup replication, or active replication. Finally, we discuss the implementation of the two most fundamental group multicast primitives: total order multicast and view synchronous multicast.", "num_citations": "188\n", "authors": ["494"]}
{"title": "Semi-passive replication\n", "abstract": " This paper presents the semi-passive replication technique, a variant of passive replication, that can be implemented in the asynchronous system model without requiring a membership service to agree on a primary. Passive replication is a popular replication technique since it can tolerate non-deterministic servers (e.g., multi-threaded servers) and uses little processing power when compared to other replication techniques. However, passive replication suffers from a high reconfiguration cost in case of the failure of the primary. The semi-passive replication technique presented in the paper benefits from the same advantages as passive replication. However, since it does not require a group membership service, semi-passive replication has a considerably lower cost in case of failure. As explained in the paper, this technique can benefit from an aggressive time-out value significantly lower than what a group\u00a0\u2026", "num_citations": "177\n", "authors": ["494"]}
{"title": "The implementation of a CORBA object group service\n", "abstract": " The Object Group Service (OGS) extends CORBA with the ability to group objects and invoke them as a single entity. Through this abstraction, OGS provides an adequate support for the construction of highly available distributed applications with replicated critical components. OGS was designed and implemented in accordance with the Object Management Group guidelines. It does not rely on any Object Request Broker vendor\u2010specific feature and can transparently be used with any CORBA 2.0 Object Request Broker. It is itself made of several CORBA services such as a monitoring service and a consensus service which can themselves be used as stand\u2010alone CORBA services. \u00a9 1998 John Wiley & Sons, Inc.", "num_citations": "174\n", "authors": ["494"]}
{"title": "The generic consensus service\n", "abstract": " This paper describes a modular approach for the construction of fault-tolerant agreement protocols. The approach is based on a generic consensus service. Fault-tolerant agreement protocols are built using a client-server interaction, where the clients are the processes that must solve the agreement problem and the servers implement the consensus service. This service is accessed through a generic consensus filter, customized for each specific agreement problem. We illustrate our approach on the construction of various fault-tolerant agreement protocols, such as nonblocking atomic commitment, group membership, view synchronous communication, and total order multicast. Through a systematic reduction to consensus, we provide a simple way to solve agreement problems. In addition to its modularity, our approach enables efficient implementations of agreement protocols and precise characterization of the\u00a0\u2026", "num_citations": "154\n", "authors": ["494"]}
{"title": "Exploiting atomic broadcast in replicated databases\n", "abstract": " Database replication protocols have historically been built on top of distributed database systems, and have consequently been designed and implemented using distributed transactional mechanisms, such as atomic commitment. We argue in this paper that this approach is not always adequate to efficiently support database replication and that more suitable alternatives, such as atomic broadcast primitives, should be employed instead. More precisely, we show in this paper that fully replicated database systems, based on the deferred update replication model, have better throughput and response time if implemented with an atomic broadcast termination protocol than if implemented with atomic commitment.", "num_citations": "153\n", "authors": ["494"]}
{"title": "Using optimistic atomic broadcast in transaction processing systems\n", "abstract": " Atomic broadcast primitives are often proposed as a mechanism to allow fault-tolerant cooperation between sites in a distributed system. Unfortunately, the delay incurred before a message can be delivered makes it difficult to implement high performance, scalable applications on top of atomic broadcast primitives. Recently, a new approach has been proposed for atomic broadcast which, based on optimistic assumptions about the communication system, reduces the average delay for message delivery to the application. We develop this idea further and show how applications can take even more advantage of the optimistic assumption by overlapping the coordination phase of the atomic broadcast algorithm with the processing of delivered messages. In particular, we present a replicated database architecture that employs the new atomic broadcast primitive in such a way that communication and transaction\u00a0\u2026", "num_citations": "152\n", "authors": ["494"]}
{"title": "Uniform reliable multicast in a virtually synchronous environment\n", "abstract": " The authors present the definition of and solution to the uniform reliable multicast problem in the virtually synchronous environment defined by the Isis system. A uniform reliable multicast of a message m has the property that if m has been received by any destination process (faulty or not), then m is received by all processes that reach a decision. Uniform reliable multicast provides a solution to the distributed commit problem. Two multicast primitives are defined in the virtually synchronous model: reliable multicast (called view-atomic) and uniform reliable multicast (called uniform view-atomic). The view-atomic multicast is used to implement the uniform view-atomic primitive. As view-atomicity is based on the concept of process group membership, a connection is established between the process group membership and the distributed commit problems.< >", "num_citations": "144\n", "authors": ["494"]}
{"title": "Optimistic atomic broadcast\n", "abstract": " This paper presents an Optimistic Atomic Broadcast algorithm (OPT-ABcast) that exploits the spontaneous total order message reception property experienced in local area networks, in order to allow fast delivery of messages. The OPT-ABcast algorithm is based on the Optimistic Consensus problem (OPT-Consensus) that allows processes to decide optimistically or conservatively. A process optimistically decides if it knows that the spontaneous total order message reception property holds, otherwise it decides conservatively. We evaluate the efficiency of the OPT-ABcast and the OPT-Consensus algorithms using the notion of latency degree.", "num_citations": "130\n", "authors": ["494"]}
{"title": "Processing transactions over optimistic atomic broadcast protocols\n", "abstract": " Atomic broadcast primitives allow fault-tolerant cooperation between sites in a distributed system. Unfortunately, the delay incurred before a message can be delivered makes it difficult to implement high performance, scalable applications on top of atomic broadcast primitives. A new approach has been proposed which, based on optimistic assumptions about the communication system, reduces the average delay for message delivery. We develop this idea further and present a replicated database architecture that employs the new atomic broadcast primitive in such a way that the coordination phase of the atomic broadcast is fully overlapped with the execution of transactions, providing high performance without relaxing transaction correctness.", "num_citations": "123\n", "authors": ["494"]}
{"title": "Replication\n", "abstract": " This book is the result of the seminar \u201cA 30-Year Perspective on Replication,\u201d which took place at Monte Verita, Ascona, Switzerland, in November 2007. As suggested by the title, the goal of the seminar was not to speculate about the future of replication, but rather to understand the present, by analyzing past successes and past failures, and to make an assessment of about 30 years of research on replication. Replication is a topic addressed by several communities: the distributed computing community, the distributed system community, and the database community. Each of these communities has looked at replication from different points of view and with different goals, eg, performance vs. fault tolerance. Recently, these different goals have started to converge, and there has been work showing that efficiency and strong consistency can sometimes be reconciled. During the seminar the observation was made that\u00a0\u2026", "num_citations": "122\n", "authors": ["494"]}
{"title": "Muteness failure detectors: Specification and implementation\n", "abstract": " This paper extends the failures detector approach from crash-stop failures to muteness failures. Muteness failures are malicious failures in which a process stops sending algorithm messages, but might continue to send other messages, e.g., \u201cI-am-alive\u201d messages. The paper presents both the specification of a muteness failure detector, denoted by , and an implementation of   in a partial synchrony model (there are bounds on message latency and clock skew, but these bounds are unknown and hold only after some point that is itself unknown). We show that, modulo a simple modification, a consensus algorithm that has been designed in a crash-stop model with  , can be reused in the presence of muteness failures simply by replacing   with  .", "num_citations": "122\n", "authors": ["494"]}
{"title": "Handling message semantics with generic broadcast protocols\n", "abstract": " Message ordering is a fundamental abstraction in distributed systems. However, ordering guarantees are usually purely \u201csyntactic,\u201d that is, message \u201csemantics\u201d is not taken into consideration despite the fact that in several cases semantic information about messages could be exploited to avoid ordering messages unnecessarily. In this paper we define the Generic Broadcast problem, which orders messages only if needed, based on the semantics of the messages. The semantic information about messages is introduced by conflict relations. We show that Reliable Broadcast and Atomic Broadcast are special instances of Generic Broadcast. The paper also presents two algorithms that solve Generic Broadcast.", "num_citations": "119\n", "authors": ["494"]}
{"title": "Genuine atomic multicast in asynchronous distributed systems\n", "abstract": " This paper addresses the problem of atomic multicasting messages in asynchronous distributed systems. Firstly, we give a characterization of the notion of genuine atomic multicast. This characterization leads to a better understanding of the difference between atomic multicast and atomic broadcast, and to make a clear distinction between genuine atomic multicast algorithms and non-genuine atomic multicast algorithms. Secondly, we consider a system with at least two processes among which one can crash, and we show that, in contrast to atomic broadcast, genuine atomic multicast is impossible to solve with failure detectors that are unreliable, i.e., that cannot distinguish crashed processes from correct ones. Finally, we discuss a way to circumvent the impossibility result, by restricting the destinations of multicasts to sets of disjoint process groups, each group behaving like a logically correct entity.", "num_citations": "118\n", "authors": ["494"]}
{"title": "Modeling fault-tolerant mobile agent execution as a sequence of agreement problems\n", "abstract": " Fault tolerance is fundamental to the further development of mobile agent applications. In the context of mobile agents, fault tolerance prevents a partial or complete loss of the agent, i.e. ensures that the agent arrives at its destination. Simple approaches such as checkpointing are prone to blocking. Replication can in principle improve solutions based on checkpointing. However existing solutions in this context either assume a perfect failure detection mechanism (which is not realistic in an environment such as the Internet), or rely on complex solutions based on leader election and distributed transactions, where only a subset of solutions prevents blocking. The paper proposes a novel approach to fault tolerant mobile agent execution, which is based on modeling agent execution as a sequence of agreement problems. Each agreement problem is one instance of the well understood consensus problem. Our\u00a0\u2026", "num_citations": "117\n", "authors": ["494"]}
{"title": "Duplex: A distributed collaborative editing environment in large scale\n", "abstract": " DUPLEX is a distributed collaborative editor for users connected through a large-scale environment such as the Internet. Large-scale implies heterogeneity, unpredictable communication delays and failures, and inefficient implementations of techniques traditionally used for collaborative editing in local area networks. To cope with these unfavorable conditions, DUPLEX proposes a model based on splitting the document into independent parts, maintained individually and replicated by a kernel. Users act on document parts and interact with co-authors using a local environment providing a safe store and recovery mechanisms against failures or divergence with co-authors. Communication is reduced to a minimum, allowing disconnected operation. Atomicity, concurrency, and replica control are confined to a manageable small context.", "num_citations": "116\n", "authors": ["494"]}
{"title": "Fatomas-a fault-tolerant mobile agent system based on the agent-dependent approach\n", "abstract": " Fault tolerance is fundamental to the further development of mobile agent applications. In the context of mobile agents, fault-tolerance prevents a partial or complete loss of the agent, i.e., it ensures that the agent arrives at its destination. We present FATOMAS, a Java-based fault-tolerant mobile agent system based on an algorithm presented in an earlier paper (2000). Contrary to the standard \"place-dependent\" architectural approach, FATOMAS uses the novel \"agent-dependent\" approach. In this approach, the protocol that provides fault tolerance travels with the agent. This has the important advantage to allow fault-tolerant mobile agent execution without the need to modify the underlying mobile agent platform (in our case ObjectSpace's Voyager). In our performance evaluation, we show the costs of our approach relative to the single, non-replicated agent execution. Pipelined mode and optimized agent\u00a0\u2026", "num_citations": "115\n", "authors": ["494"]}
{"title": "Generic broadcast\n", "abstract": " Message ordering is a fundamental abstraction in distributed systems. However, usual ordering guarantees are purely \u201csyntactic\u201d, that is, message \u201csemantics\u201d is not taken into consideration, despite the fact that in several cases, semantic information about messages leads to more efficient message ordering protocols. In this paper we define the Generic                         Broadcast problem, which orders the delivery of messages only if needed, based on the semantics of the messages. Semantic information about the messages is introduced in the system by a conflict relation defined over message. We show that Reliable and Atomic Broadcast are spe- cial cases of Generic Broadcast, and propose an algorithm that solves Generic Broadcast efficiently. In order to assess efficiency, we introduce the concept of delivery latency.", "num_citations": "115\n", "authors": ["494"]}
{"title": "Virtually-synchronous communication based on a weak failure suspector\n", "abstract": " Failure detectors (or, more accurately, failure suspectors, or FS) appear to be a fundamental service upon which to build fault-tolerant, distributed applications. It is shown that an FS with very weak semantics (i.e. that delivers failure and recovery information in no specific order) suffices to implement virtually synchronous communication (VSC) in an asynchronous system subject to process crash failures and network partitions. The VSC paradigm is particularly useful in asynchronous systems and greatly simplifies building fault-tolerant applications that mask failures by replicating processes. The authors suggest a three-component architecture to implement virtually synchronous communication: (1) at the lowest level, the FS component; on top of it, (2a) a component that defines new views, and (2b) a component that reliably multicasts messages within a view.", "num_citations": "110\n", "authors": ["494"]}
{"title": "Consensus service: a modular approach for building agreement protocols in distributed systems\n", "abstract": " We describe a consensus service and suggest its use for the construction of fault-tolerant agreement protocols. We show how to build agreement protocols, using a classical client-server interaction, where: the clients are the processes that must solve the agreement problem; and the servers implement the consensus service. Using a generic notion, called consensus filter, we illustrate our approach on non-blocking atomic commitment and on view synchronous multicast. The approach can trivially be used for total order broadcast. In addition of its modularity, our approach enables efficient implementations of the protocols, and precise characterization of their liveness.", "num_citations": "104\n", "authors": ["494"]}
{"title": "Uniform consensus is harder than consensus\n", "abstract": " We compare the consensus and uniform consensus problems in synchronous systems. In contrast to consensus, uniform consensus is not solvable with byzantine failures. This still holds for the omission failure model if a majority of processes may be faulty. For the crash failure model, both consensus and uniform consensus are solvable, no matter how many processes are faulty. In this failure model, we examine the number of rounds required to reach a decision in the consensus and uniform consensus algorithms. We show that if uniform agreement is required, one additional round is needed to decide, and so uniform consensus is also harder than consensus for crash failures. This is based on a new lower bound result for the synchronous model that we state for the uniform consensus problem. Finally, an algorithm is presented that achieves this lower bound.", "num_citations": "103\n", "authors": ["494"]}
{"title": "Muteness detectors for consensus with Byzantine processes\n", "abstract": " This paper presents a new specification of Consensus that is adequate for solving agreement problems (eg, Atomic Broadcast) with Byzantine processes. We call this problem Vector Consensus. In order to solve the Vector Consensus problem in an asynchronous model with Byzantine processes, we extend the failure detectors paradigm defined by Chandra and Toueg. This leads us to the definition of muteness detectors. Malkhi and Reiter were the first to extend the failure detectors to the case of Byzantine failures and to use them to solve the Binary Consensus problem. However, their definition of the failure detector OS (bt) is based on a system model in which all processes communicate using only a Reliable Broadcast primitive that additionally satisfies causal order delivery. In contrast, our muteness detector OM is defined in a very general system model, where processes are not forced to communicate using\u00a0\u2026", "num_citations": "101\n", "authors": ["494"]}
{"title": "Fault-tolerant mobile agent execution\n", "abstract": " Mobile agents have attracted considerable interest in recent years. In the context of mobile agents, fault tolerance is crucial to enable the integration of mobile agent technology into today's business applications. This article identifies two important properties for fault-tolerant mobile agent execution: nonblocking and exactly-once. Nonblocking ensures that the agent execution can proceed despite a single failure of the agent or the machine, for instance. Replication is the generally adopted mechanism to prevent blocking, but may lead to multiple executions of the agent (i.e., a violation of the exactly-once property), which is undesirable with operations that have side effects. Hence, we propose that fault-tolerant mobile agent execution be modeled as a sequence of agreement problems. Our approach is nonblocking and ensures exactly-once execution. FATOMAS, our prototype fault-tolerant mobile agent system\u00a0\u2026", "num_citations": "99\n", "authors": ["494"]}
{"title": "Consensus with unknown participants or fundamental self-organization\n", "abstract": " We consider the problem of bootstrapping self-organized mobile ad hoc networks (MANET), i.e. reliably determining in a distributed and self-organized manner the services to be offered by each node when neither the identity nor the number of the nodes in the network is initially available. To this means we define a variant of the traditional consensus problem, by relaxing the requirement for the set of participating processes to be known by all at the beginning of the computation. This assumption captures the nature of self-organized networks, where there is no central authority that initializes each process with some context information. We consider asynchronous networks with reliable communication channels and no process crashes and provide necessary and sufficient conditions under which the problem admits a solution. These conditions are routing and mobility independent. Our results are relevant for\u00a0\u2026", "num_citations": "97\n", "authors": ["494"]}
{"title": "Consensus: the big misunderstanding [distributed fault tolerant systems]\n", "abstract": " The paper aims at clarifying some misunderstandings about the consensus problem. These misunderstandings prevent consensus from being considered as it should be, i.e., a fundamental paradigm in the context of fault-tolerant distributed systems, not only from a theoretical point of view, but also from a practical point of view. Six frequent misunderstandings are discussed.", "num_citations": "97\n", "authors": ["494"]}
{"title": "Phoenix--A Toolkit for Building Fault-Tolerant, Distributed Applications in Large Scale\n", "abstract": " Large scale systems are becoming more and more common today. There are many distributed applications emerging that use the capability of world-wide internetworking. Since a lot of applications need insurance of consistency even in the presence of failures, an adequate support for fault-tolerance is necessary. This can be provided by different paradigms and their implementations. Unfortunately, most of these implementations aim only local area networks, whereas our system, called Phoenix, will aim large scale where additional failure types have to be overcome. This paper shows the problems due to large scale, the limits of actual implementations, and our proposition to solve them.", "num_citations": "97\n", "authors": ["494"]}
{"title": "Optimistic atomic broadcast: a pragmatic viewpoint\n", "abstract": " This paper presents the Optimistic Atomic Broadcast algorithm (OPT-ABcast) which exploits the spontaneous total-order property experienced in local-area networks in order to allow fast delivery of messages. The OPT-ABcast algorithm is based on a sequence of stages, and messages can be delivered during a stage or at the end of a stage. During a stage, processes deliver messages fast. Whenever the spontaneous total-order property does not hold, processes terminate the current stage and start a new one by solving a Consensus problem which may lead to the delivery of some messages. We evaluate the efficiency of the OPT-ABcast algorithm using the notion of delivery latency.", "num_citations": "90\n", "authors": ["494"]}
{"title": "The database state machine and group communication issues\n", "abstract": " Distributed computing is reshaping the way people think about and do daily life activities. On-line ticket reservation, electronic commerce, and telebanking are examples of services that would be hardly imaginable without distributed computing. Nevertheless, widespread use of computers has some implications. As we become more depend on computers, computer malfunction increases in importance. Until recently, discussions about fault tolerant computer systems were restricted to very specific contexts, but this scenario starts to change, though.This thesis is about the design of fault tolerant computer systems. More specifically, this thesis focuses on how to develop database systems that behave correctly even in the event of failures. In order to achieve this objective, this work exploits the notions of data replication and group communication. Data replication is an intuitive way of dealing with failures: if one copy of the data is not available, access another one. However, guaranteeing the consistency of replicated data is not an easy task. Group communication is a high level abstraction that defines patterns on the communication of computer sites. The present work advocates the use of group communication in order to enforce data consistency.", "num_citations": "89\n", "authors": ["494"]}
{"title": "Transaction model vs virtual synchrony model: bridging the gap\n", "abstract": " Two important models for building fault-tolerant applications have been independently proposed in the literature, the transaction model (developed within the context of database applications) and the virtual synchrony model (proposed initially by the Isis system to handle replication). For a better understanding of the relations between these models, we address the following question: are the basic mechanisms needed to implement both models exactly the same? The paper answers this question by defining the Dynamic-Terminating-Multicast problem, and showing that it can be seen as a generic problem, closely related to the implementation of both the transaction model and the virtual synchrony model. It is thus possible to build a system offering, in an integrated way, both the transaction model and the virtual synchrony model. Such a system could offer powerful primitives that are currently cumbersome or\u00a0\u2026", "num_citations": "88\n", "authors": ["494"]}
{"title": "Stubborn communication channels\n", "abstract": " This paper aims at bridging the gap between the assumption of reliable channels by fault-tolerant distributed algorithms and the weak reliability of feasible communication channels. We define a new kind of communication channels which we call Stubborn channels. Stubborn channels are easily implementable over a connectionless network layer and, although weak, the reliability guarantees offered by Stubborn channels are sufficient to solve the fundamental Consensus problem in asynchronous systems with unreliable failure detectors. 1 Introduction Literature on fault-tolerant distributed algorithms in the asynchronous computation model often assumes that the communication between processes is reliable. A reliable communication channel can roughly be characterized as a channel where all messages that are sent are received, provided that the receiver process does not crash [2]. In practice, implementation of reliable channels poses two problems. The first problem is to guarantee the eventual...", "num_citations": "85\n", "authors": ["494"]}
{"title": "Dynamic group communication\n", "abstract": " Group communication is the basic infrastructure for implementing fault-tolerant replicated servers. While group communication is well understood in the context of static groups (in which the membership does not change), current specifications of dynamic group communication (in which processes can join and leave groups during the computation) have not yet reached the same level of maturity.               The paper proposes new specifications \u2013 in the primary partition model \u2013 for dynamic reliable broadcast (simply called \u201creliable multicast\u201d), dynamic atomic broadcast (simply called \u201catomic multicast\u201d) and group membership. In the special case of a static system, the new specifications are identical to the well known static specifications. Interestingly, not only are these new specifications \u201csyntactically\u201d close to the static specifications, but they are also \u201csemantically\u201d close to the dynamic specifications proposed\u00a0\u2026", "num_citations": "82\n", "authors": ["494"]}
{"title": "S-paxos: Offloading the leader for high throughput state machine replication\n", "abstract": " Implementations of state machine replication are prevalently using variants of Paxos or other leader-based protocols. Typically these protocols are also leader-centric, in the sense that the leader performs more work than the non-leader replicas. Such protocols scale poorly, because as the number of replicas or the load on the system increases, the leader replica quickly reaches the limits of one of its resources. In this paper we show that much of the work performed by the leader in a leader-centric protocol can in fact be evenly distributed among all the replicas, thereby leaving the leader only with minimal additional workload. This is done (i) by distributing the work of handling client communication among all replicas, (ii) by disseminating client requests among replicas in a distributed fashion, and (iii) by executing the ordering protocol on ids. We derive a variant of Paxos incorporating these ideas. Compared to\u00a0\u2026", "num_citations": "81\n", "authors": ["494"]}
{"title": "A step towards a new generation of group communication systems\n", "abstract": " In this paper, we propose a new architecture for group communication middleware. Current group communication systems share some common features, despite the big differences that exist among them. We first point out these common features by describing the most representative group communication architectures implemented over the last 15 years. Then we show the features of our new architecture, which provide several advantages over the existing architectures: (1) it is less complex, (2) it defines a set of group communication abstractions that is more consistent than the abstractions usually provided, and (3) it can be made more responsive in case of failures.", "num_citations": "80\n", "authors": ["494"]}
{"title": "Non blocking atomic commitment with an unreliable failure detector\n", "abstract": " In a transactional system, an atomic commitment protocol ensures that for any transaction, all data manager processes agree on the same outcome (commit or abort). A non-blocking atomic commitment protocol enables an outcome to be decided at every correct process despite the failure of others. In this paper we apply, for the first time, the fundamental result of T. Chandra and S. Toueg (1991) on solving the abstract consensus problem, to non-blocking atomic commitment. More precisely, we present a non-blocking atomic commitment protocol in an asynchronous system augmented with an unreliable failure detector that can make an infinity of false failure suspicions. If no process is suspected to have failed, then our protocol is similar to a three phase commit protocol. In the case where processes are suspected, our protocol does not require any additional termination protocol: failure scenarios are handled within\u00a0\u2026", "num_citations": "74\n", "authors": ["494"]}
{"title": "Tolerating corrupted communication\n", "abstract": " Consensus encalpsulates the inherent problems of building fault tolerant distributed systems. In this context, the classic model of Byzantine faulty processes can be restated such that messages from a subset of processes can be arbitrarily corrupted (including addition and omission of messages).", "num_citations": "72\n", "authors": ["494"]}
{"title": "Approaches to fault-tolerant and transactional mobile agent execution---an algorithmic view\n", "abstract": " Over the past years, mobile agent technology has attracted considerable attention, and a significant body of literature has been published. To further develop mobile agent technology, reliability mechanisms such as fault tolerance and transaction support are required. This article aims at structuring the field of fault-tolerant and transactional mobile agent execution and thus at guiding the reader to understand the basic strengths and weaknesses of existing approaches. It starts with a discussion on providing fault tolerance in a system in which processes simply fail. For this purpose, we first identify two basic requirements for fault-tolerant mobile agent execution: (1) non-blocking (i.e., a single failure does not prevent progress of the mobile agent execution) and (2) exactly-once (i.e., multiple executions of the agent are prevented). This leads us to introduce the notion of a local transaction as the basic building block for\u00a0\u2026", "num_citations": "71\n", "authors": ["494"]}
{"title": "Solving agreement problems with weak ordering oracles\n", "abstract": " Agreement problems, such as consensus, atomic broadcast, and group membership, are central to the implementation of fault-tolerant distributed systems. Despite the diversity of algorithms that have been proposed for solving agreement problems in the past years, almost all solutions are Crash-Detection Based (CDB). We say that an algorithm is CDB if it uses some information about the status crashed/not crashed of processes. In this paper, we revisit the issue of non-CDB algorithms considering ordering oracles. Ordering oracles have a theoretical interest as well as a practical interest. To illustrate their use, we present solutions to consensus and atomic broadcast, and evaluate the performance of the atomic broadcast algorithm in a cluster of workstations.", "num_citations": "70\n", "authors": ["494"]}
{"title": "From set membership to group membership: A separation of concerns\n", "abstract": " We revisit the well-known group membership problem and show how it can be considered a special case of a simple problem, the set membership problem. In the set membership problem, processes maintain a set whose elements are drawn from an arbitrary universe: They can request the addition or removal of elements to/from that set, and they agree on the current value of the set. Group membership corresponds to the special case where the elements of the set happen to be processes. We exploit this new way of looking at group membership to give a simple and succinct specification of this problem and to outline a simple implementation approach based on the state machine paradigm. This treatment of group membership separates several issues that are often mixed in existing specifications and/or implementations of group membership. We believe that this separation of concerns greatly simplifies the\u00a0\u2026", "num_citations": "68\n", "authors": ["494"]}
{"title": "Uniform consensus harder than consensus\n", "abstract": " We compare the consensus problem with the uniform consensus problem in synchronous systems. In contrast to consensus, uniform consensus is not solvable in synchronous systems with byzantine failures. This still holds for the omission failure model if a majority of processes may be faulty. For the crash failure model, both consensus and uniform consensus are solvable, no matter how many processes are faulty. We consider this failure model and we examine the number of rounds required to reach a decision in consensus and uniform consensus algorithms. We show that compared with the best consensus algorithm, any uniform consensus algorithm takes at least one additional round to take a decision. We thus prove that uniform consensus is also harder than consensus whatever the failure model is.", "num_citations": "67\n", "authors": ["494"]}
{"title": "Consensus in the crash-recover model\n", "abstract": " This paper presents a deterministic algorithm that solves consensus in asynchronous distributed systems where processes may crash and recover, messages may be lost, and failure detections may be inaccurate. Our algorithm has an early delivery property: in runs where no process crashes or is suspected to have crashed, consensus is reached only after two communication steps.", "num_citations": "66\n", "authors": ["494"]}
{"title": "Reducing the cost for non-blocking in atomic commitment\n", "abstract": " Non-blocking atomic commitment protocols enable a decision (commit or abort) to be reached at every correct participant, despite the failure of others. The cost for non-blocking implies however (1) a high number of messages and communication steps required to reach commit, and (2) a complicated termination protocol needed in the case of failure suspicions. In this paper, we present a non-blocking protocol, called MDSPC (Modular and Decentralized Three Phase Commit), which enables to trade resiliency against efficiency. As conveyed by our performance measures, MDSPC is faster than existing non-blocking protocols, and in the case of a broadcast network and a reasonable resiliency rate (e.g. 2 or 3) is almost as efficient as the classical (blocking) 2PC. The termination protocol of MDSPC is encapsulated inside a majority consensus protocol. This modularity leads to a simple structure of MDSPC and\u00a0\u2026", "num_citations": "66\n", "authors": ["494"]}
{"title": "Totally ordered broadcast and multicast algorithms: A comprehensive survey\n", "abstract": " Total order multicast algorithms constitute an important class of problems in distributed systems, especially in the context of fault-tolerance. In short, the problem of total order multicast consists in sending messages to a set of processes, in such a way that all messages are delivered by all correct destinations in the same order. However, the huge amount of literature on the subject and the plethora of solutions proposed so far make it difficult for practitioners to select a solution adapted to their specific problem. As a result, naive solutions are often used while better solutions are ignored. This paper proposes a classification of total order multicast algorithms based on the ordering mechanism of the algorithms, and describes a set of common characteristics (eg, assumptions, properties) with which to evaluate them. In this classification, more than fifty total order broadcast and multicast algorithms are surveyed. The presentation includes asynchronous algorithms as well as algorithms based on the more restrictive synchronous model. Fault-tolerance issues are also considered as the paper studies the properties and behavior of the different algorithms with respect to failures.", "num_citations": "65\n", "authors": ["494"]}
{"title": "Synchronous system and perfect failure detector: Solvability and efficiency issues\n", "abstract": " We compare, in terms of solvability and efficiency, the synchronous model, noted Ss, with the asynchronous model augmented with a perfect failure detector, noted S/sub P/. We first exhibit a problem that, although time-free, is solvable in S/sub S/ but not in S/sub P/. We then examine whether one of these two models allows more efficient solutions for designing fault-tolerant applications. In particular, we concentrate on the uniform consensus problem which is solvable in both models, and we design a uniform consensus algorithm for the S/sub S/ model that is more efficient than any algorithm solving uniform consensus in S/sub P/ with respect to some significant time complexity measure. From a practical viewpoint, the synchronous model thus seems better than the asynchronous model augmented with a perfect failure detector.", "num_citations": "64\n", "authors": ["494"]}
{"title": "Conception and implementation of a toolkit for building fault-tolerant distributed applications in large scale networks\n", "abstract": " Large scale systems are becoming more and more common today. Many distributed applications are emerging that use the capability of world-wide internetworking. Since many applications require availability and consistency in the presence of failures, an adequate support for faulttolerance is necessary. This can be provided by different paradigms and their implementations. Unfortunately, most of these implementations consider only local area networks, whereas this thesis describes a system, called Phoenix, which aims at large scale networks where additional types of failure have to be taken into account.This thesis gives a complete description of Phoenix, a toolkit for building fault-tolerant, distributed applications in large scale networks. Fault-tolerance in Phoenix is achieved using replicated process groups, and consistency within one process group is achieved by using view synchronous communication. The particularity of Phoenix is the provision of this fault-tolerance and consistency in a large scale environment, where large scale is two-fold:(1) the wide geographical distribution of the replicated processes, and (2) a high number of participating processes in the system.", "num_citations": "64\n", "authors": ["494"]}
{"title": "Contention-aware metrics for distributed algorithms: Comparison of atomic broadcast algorithms\n", "abstract": " Resource contention is widely recognized as having a major impact on the performance of distributed algorithms. Nevertheless, the metrics that are commonly used to predict their performance take little or no account of contention. We define two performance metrics for distributed algorithms that account for network contention as well as CPU contention. We then illustrate the use of these metrics by comparing four atomic broadcast algorithms, and show that our metrics allow for a deeper understanding of performance issues than conventional metrics.", "num_citations": "63\n", "authors": ["494"]}
{"title": "Transaction reordering in replicated databases\n", "abstract": " The paper presents a fault tolerant lazy replication protocol that ensures 1-copy serializability at a relatively low cost. Unlike eager replication approaches, our protocol enables local transaction execution and does not lead to any deadlock situation. Compared to previous lazy replication approaches, we significantly reduce the abort rate of transactions and we do not require any reconciliation procedure. Our protocol first executes transactions locally, then broadcasts a transaction certification message to all replica managers, and finally employs a certification procedure to ensure 1-copy serializability. Certification messages are broadcast using a non blocking atomic broadcast primitive, which alleviates the need for a more expensive non blocking atomic commitment algorithm. The certification procedure uses a reordering technique to reduce the probability of transaction aborts.", "num_citations": "63\n", "authors": ["494"]}
{"title": "Scalable atomic multicast\n", "abstract": " We present a new scalable fault-tolerant algorithm which ensures total order delivery of messages sent to multiple groups of processes. Our algorithm is particularly well suited for large scale systems because: (1) any process can multicast a message to one or more groups of processes without being forced to join those groups; (2) inter-group total order is ensured system-wide but, for each individual multicast, the number and size of messages exchanged depends only on the number of addressees; (3) process failure detection does not need to be reliable. Our algorithm also exhibits a modular design. It uses two companion protocols, namely a reliable multicast protocol and a consensus protocol, and these protocols are not required to use the same communication channels or to share common variables with the total order protocol. This approach follows a design methodology based on the composition of\u00a0\u2026", "num_citations": "61\n", "authors": ["494"]}
{"title": "Impact of a failure detection mechanism on the performance of consensus\n", "abstract": " The paper considers a consensus algorithm for an asynchronous system augmented with failure detectors, and analyzes the impact on its termination time of various implementations of failure detectors. The study shows that the design of fault-tolerant distributed algorithms in the asynchronous system model augmented with failure detectors is orthogonal to implementing the actual failure detectors. This nicely decouples logical issues (proof of correctness) from engineering issues (e.g., performance and timing constraints).", "num_citations": "58\n", "authors": ["494"]}
{"title": "\u201c\u0393-accurate\u201d failure detectors\n", "abstract": " The knowledge about failures needed to solve distributed agreement problems can be expressed in terms of completeness and accuracy properties of failure detectors introduced by Chandra and Toueg. The accuracy properties they have considered restrict the false suspicions that can be made by all the processes in the system. In this paper, we define \u201c\u0393-accurate\u201d failure detectors, whose accuracy properties (only) restrict the false suspicions that can be made by a subset \u0393 of the processes. We discuss the relations between the classes of \u0393-accurate failure detectors, and the classes of failure detectors defined by Chandra and Toueg. Then we point out the impact of these relations on the solvability of agreement problems.", "num_citations": "58\n", "authors": ["494"]}
{"title": "A hierarchy of totally ordered multicasts\n", "abstract": " The increased interest in protocols that provide a total order on message delivery has led to several different definitions of total order. In this paper we investigate these different definitions and propose a hierarchy that helps to better understand the implications of the different possibilities in terms of guarantees and communication cost. We identify two definitions: weak total order and strong total order, which are at the extremes of the proposed hierarchy, and incorporate them into a consistent design. Finally, we propose high-level algorithms based on a virtually synchronous communication environment that implement the given definitions.", "num_citations": "57\n", "authors": ["494"]}
{"title": "Performance analysis of a consensus algorithm combining stochastic activity networks and measurements\n", "abstract": " Protocols which solve agreement problems are essential building blocks for fault tolerant distributed applications. While many protocols have been published, little has been done to analyze their performance. This paper represents a starting point for such studies, by focusing on the consensus problem, a problem related to most other agreement problems. The paper analyzes the latency of a consensus algorithm designed for the asynchronous model with failure detectors, by combining experiments on a cluster of PCs and simulation using stochastic activity networks. We evaluated the latency in runs (1) with no failures nor failure suspicions, (2) with failures but no wrong suspicions and (3) with no failures but with (wrong) failure suspicions. We validated the adequacy and the usability of the stochastic activity network model by comparing experimental results with those obtained from the model. This has led us to\u00a0\u2026", "num_citations": "56\n", "authors": ["494"]}
{"title": "Tuning paxos for high-throughput with batching and pipelining\n", "abstract": " Paxos is probably the most popular state machine replication protocol. Two optimizations that can greatly improve its performance are batching and pipelining. Nevertheless, tuning these two optimizations to achieve high-throughput can be challenging, as their effectiveness depends on many parameters like the network latency and bandwidth, the speed of the nodes, and the properties of the application. We address this question, by first presenting an analytical model of the performance of Paxos that can be used to obtain values for tuning batching and pipelining. We then present results of experiments validating the model and investigating how these two optimizations interact in a WAN. Results for LAN are also mentioned. The results show that although batching by itself is usually sufficient to maximize the throughput in a LAN environment, in a WAN it must be complemented with pipelining.", "num_citations": "54\n", "authors": ["494"]}
{"title": "Comparison of failure detectors and group membership: Performance study of two atomic broadcast algorithms\n", "abstract": " Protocols that solve agreement problems are essential building blocks for fault tolerant distributed systems. While many protocols have been published, little has been done to analyze their performance, especially the performance of their fault tolerance mechanisms. In this paper, we present a performance evaluation methodology that can be generalized to analyze many kinds of fault-tolerant algorithms. We use the methodology to compare two atomic broadcast algorithms with different fault tolerance mechanisms: unreliable failure detectors and group membership. We evaluated the steady state latency in (1) runs with no crashes and no suspicions,(2) runs with crashes and (3) runs with no crashes in which correct processes are wrongly suspected to have crashed, as well as (4) the transient latency after a crash. We found that the two algorithms have the same performance in Scenario 1, and that the group membership based algorithm has an advantage in terms of performance and resiliency in Scenario 2, whereas the failure detector based algorithm offers better performance in the other scenarios. We discuss the implications of our results to the design of fault tolerant distributed systems.", "num_citations": "54\n", "authors": ["494"]}
{"title": "Optimistic active replication\n", "abstract": " Replication is a powerful technique for increasing availability of a distributed service. Algorithms for replicating distributed services do however face a dilemma: they should be: efficient (low latency); while ensuring consistency of the replicas, which are two contradictory goals. The paper concentrates on active replication, where all the replicas handle the clients' requests. Active replication is usually implemented using the atomic broadcast primitive. To be efficient, some atomic broadcast algorithms deliberately sacrifice consistency, if inconsistency is likely to occur with a low probability. We present an algorithm that handles replication efficiently in most scenarios, while preventing inconsistencies. The originality of the algorithm is to take the client-server interaction into account, while traditional solutions consider atomic broadcast as a black box.", "num_citations": "53\n", "authors": ["494"]}
{"title": "Token-based atomic broadcast using unreliable failure detectors\n", "abstract": " Many atomic broadcast algorithms have been published in the last twenty years. Token-based algorithms represent a large class of these algorithms. Interestingly, all the token-based atomic broadcast algorithms rely on a group membership service, i.e., none of them uses unreliable failure detectors directly. The paper presents the first token-based atomic broadcast algorithm that uses an unreliable failure detector - the new failure detector denoted by /spl Rscr/ - instead of a group membership service. The failure detector /spl Rscr/ is compared with <>V and <>S. In order to make it easier to understand the atomic broadcast algorithm, the paper derives the atomic broadcast algorithm from a token-based consensus algorithm that also uses the failure detector /spl Rscr/.", "num_citations": "51\n", "authors": ["494"]}
{"title": "Robust TCP connections for fault tolerant computing\n", "abstract": " When processes on two different machines communicate, they most often do so using the TCP protocol. While TCP is appropriate for a wide range of applications, it has shortcomings in other application areas. One of these areas is fault tolerant distributed computing. For some of those applications, TCP does not address link failures adequately: TCP breaks the connection if connectivity is lost for some duration (typically minutes). This is sometimes undesirable. The paper proposes robust TCP connections, a solution to the problem of broken TCP connections. The paper presents a session layer protocol on top of TCP that ensures reconnection, and provides exactly-once delivery for all transmitted data. A prototype has been implemented as a Java library. The prototype has less than 10% overhead on TCP sockets with respect to the most important performance figures.", "num_citations": "51\n", "authors": ["494"]}
{"title": "Achieving high-throughput state machine replication in multi-core systems\n", "abstract": " The traditional architecture used by implementations of Replicated State Machines (RSM) does not fully exploit modern multi-core CPUs. This is increasingly the limiting factor in their performance, because network speeds are increasing much faster than the single-thread performance of CPUs. Thus, when deployed on Gigabit-class networks and exposed to a workload of small to medium size client requests, RSMs are often CPU-bound, as they are only able to leverage a few cores, even though many more may be available. In this work, we revisit the traditional architecture of a RSM implementation, showing how it can be parallelized so that its performance scales with the number of cores in the nodes. We do so by applying several good practices of concurrent programming to the specific case of state machine replication, including staged execution, workload partitioning, actors, and non-blocking data structures\u00a0\u2026", "num_citations": "49\n", "authors": ["494"]}
{"title": "Primary partition \u201cvirtually-synchronous communication\u201d harder than consensus\n", "abstract": " The paper considers the problem of implementing \u201cVirtually Synchronous Communication\u201d in the primary partition of an asynchronous system. Virtually Synchronous Communication was first introduced by the Isis system as a powerful mechanism for building fault-tolerant processes that mask failures by replication: it can be understood as a rule for ordering message deliveries (reliable multicasts) with respect to view changes, defined by a membership service. Primary partition Virtually Synchronous Communication, noted PP-VSC, is the problem of implementing Virtually Synchronous Communication in the case of totally ordered views. The paper formally defines the problem, and shows that surprisingly this problem is harder than consensus: (1) consensus is solvable whenever the PP-VSC problem is solvable, however (2) there are environments where consensus is solvable, but not PP-VSC. The paper\u00a0\u2026", "num_citations": "49\n", "authors": ["494"]}
{"title": "Reaching agreement with unknown participants in mobile self-organized networks in spite of process crashes\n", "abstract": " We consider the consensus problem in self-organized networks such as MANETs. Consensus offers a means for reliably solving agreement related problems, which in a self-organized setting can help bring enhanced structure and reliability to the highly dynamic and disorganized environment of MANETs. We consider asynchronous networks with reliable communications channels. Neither the identity nor the number of nodes is initially known to the participants. This captures the self-organized nature of the network, where no central authority initializes each process with some context information. In [CSS04], the authors have identified the conditions for which the above problem admits a solution when the processes are correct. The contribution of this paper is to determine the necessary and sufficient conditions for the above problem when processes can crash. These conditions are routing and mobility independent.", "num_citations": "48\n", "authors": ["494"]}
{"title": "Reliable broadcast in wireless mobile ad hoc networks\n", "abstract": " We propose a single source reliable broadcasting algorithm for linear grid-based networks where a message is guaranteed to be delivered to all the nodes of the network. The nodes are mobile and can move from one grid point to another. The solution does not require the nodes to know the network size or its diameter. The only information a node has is its identity and its position. On average, only a subset of nodes transmit and they transmit only once to achieve reliable broadcast. The protocol is contention-free and energy-efficient. We show that reliable broadcast can be achieved in O(Dlog n) time-slots despite node mobility, where D is the diameter of the network and n the number of nodes.", "num_citations": "46\n", "authors": ["494"]}
{"title": "JPaxos: State machine replication based on the Paxos protocol\n", "abstract": " State machine replication is a technique for making services fault-tolerant by replicating them over a group of machines. Although the theory of state machine replication has been studied extensively, the engineering challenges of converting a theoretical description into a fully functional system is less understood. This creates difficulties to implementors, because in designing such a system they face many engineering challenges which are crucial to ensure good performance and stability of a replicated system. In this report, we address this problem by describing the design and implementation of JPaxos, a fully-functional implementation of state machine replication based on the MultiPaxos protocol. Our description includes the basic modules of a state machine replication implementation, like snapshotting of service state, state-transfer and keeping up-to-date all replicas, but focus mainly on three aspects: recovery mechanisms, batching and pipelining optimizations, and a scalable threading-architecture. We present several recovery algorithms that vary in the usage of stable storage and on the system assumptions, including some that use stable storage only once per-recovery. Batching and pipelining are well-known optimizations commonly used in state machine replication. With JPaxos we have studied their interaction in detail, and provide guidelines to tune these mechanisms for a variety of systems. Finally, the threading architecture of JPaxos was designed to scale with the number of cores, while at the same time minimizing complexity to reduce the risk of concurrency bugs.", "num_citations": "45\n", "authors": ["494"]}
{"title": "Appia vs. Cactus: Comparing protocol composition frameworks\n", "abstract": " The paper presents and compares Appia and Cactus, two frameworks for protocol composition. The comparison is based on the experience gained in implementing a fault-tolerant atomic broadcast service. The paper also gives preliminary performance results, and concludes with a discussion of the most interesting features of the two frameworks, and suggestions for an improved framework.", "num_citations": "45\n", "authors": ["494"]}
{"title": "Replication of CORBA objects\n", "abstract": " Distributed computing is one of the major trends in the computer industry. As systems become more distributed, they also become more complex and have to deal with new kinds of problems, such as partial crashes and link failures. While many middleware architectures have emerged to answer the growing demand in distributed technologies, most of them do not provide any kind of fault tolerance mechanisms. In this paper, we discuss the addition of object group support to CORBA. We describe three approaches: integration, interception, and service, and we argue is favor of the latter. We present the architecture of an Object Group Service (OGS) that provides for fault tolerance and high availability through object replication. This service enables the application developer to deal with invocations to replicated objects in a completely transparent way. We describe the major components of OGS: messaging\u00a0\u2026", "num_citations": "45\n", "authors": ["494"]}
{"title": "Semi-passive replication and lazy consensus\n", "abstract": " This paper presents two main contributions: semi-passive replication and Lazy Consensus. The former is a replication technique with parsimonious processing. It is based on the latter; a variant of Consensus allowing the lazy evaluation of proposed values. Semi-passive replication is a replication technique with parsimonious processing. This means that, in the normal case, each request is processed by only one single process. The most significant aspect of semi-passive replication is that it requires a weaker system model than existing techniques of the same family. For semi-passive replication, we give an algorithm based on the Lazy Consensus. Lazy Consensus is a variant of the Consensus problem that allows the lazy evaluation of proposed values, hence the name. The main difference with Consensus is the introduction of an additional property of laziness. This property requires that proposed values are\u00a0\u2026", "num_citations": "44\n", "authors": ["494"]}
{"title": "Broadcasting messages in fault-tolerant distributed systems: the benefit of handling input-triggered and output-triggered suspicions differently\n", "abstract": " This paper investigates the two main and seemingly antagonistic approaches to broadcasting messages reliably in fault-tolerant distributed systems: the approach based on reliable broadcast, and that based on view synchronous communication (or VSC for short). While VSC does more than reliable broadcast, this has a cost. We show that this cost can be reduced by exploiting the difference between input-triggered and output-triggered suspicions, and by replacing the standard VSC broadcast primitive by two broadcast primitives, one sensitive to input-triggered suspicions, and the other sensitive to output-triggered suspicions.", "num_citations": "44\n", "authors": ["494"]}
{"title": "The decentralized non-blocking atomic commitment protocol\n", "abstract": " In a transactional system, an atomic commitment protocol ensures that for any transaction, all data managers agree on the same outcome: commit or abort. A non-blocking atomic commitment protocol enables an outcome to be decided at every correct data manager despite the failure of others. It is well known that the famous Two Phase Commit protocol (2PC) is a blocking protocol, whereas the Three Phase Commit protocol (2PC) is a non-blocking protocol. Both protocols are centralized. We discuss a Decentralized Non-Blocking Atomic Commitment protocol, named DNB-AC. In the absence of failures, the DNB-AC protocol requires the same number of steps to commit than the 2PC protocol (three steps). Performance measures show that the DNB-AC protocol is significantly faster that the 3PC and in the case of a broadcast network, is almost as efficient as the 2PC. The DNB-AC protocol uses a uniform consensus\u00a0\u2026", "num_citations": "44\n", "authors": ["494"]}
{"title": "Total order multicast to multiple groups\n", "abstract": " We present a fault tolerant algorithm that ensures total order delivery of messages sent to multiple groups of processes. Our algorithm is a multiple group \"genuine\" multicast algorithm in the sense that: (1) any process can send a message to any set of process groups; and (2) only the sender and the receivers of a message take part in the algorithm needed to deliver the message. The correctness of our algorithm does not require reliable failure detectors, but requires causal order delivery of messages. This establishes a new and interesting link between causal order delivery and fault tolerance with unreliable failure detectors.", "num_citations": "43\n", "authors": ["494"]}
{"title": "Verification of consensus algorithms using satisfiability solving\n", "abstract": " Consensus is at the heart of fault-tolerant distributed computing systems. Much research has been devoted to developing algorithms for this particular problem. This paper presents a semi-automatic verification approach for asynchronous consensus algorithms, aiming at facilitating their development. Our approach uses model checking, a widely practiced verification method based on state traversal. The challenge here is that the state space of these algorithms is huge, often infinite, thus making model checking infeasible. The proposed approach addresses this difficulty by reducing the verification problem to small model checking problems that involve only single phases of algorithm execution. Because a phase consists of a small, finite number of rounds, bounded model checking, a technique using satisfiability solving, can be effectively used to solve these problems. The proposed approach allows us to\u00a0\u2026", "num_citations": "42\n", "authors": ["494"]}
{"title": "Performance comparison between the Paxos and Chandra-Toueg consensus algorithms\n", "abstract": " Protocols which solve agreement problems are essential building blocks for fault tolerant distributed applications. While many protocols have been published, little has been done to analyze their performance. This paper represents a starting point for such studies, by focusing on the consensus problem, a problem related to most other agreement problems. The paper compares the latency of two consensus algorithms designed for the asynchronous model with failure detectors: the Paxos algorithm and the Chandra-Toueg algorithm. We varied the number of processes which take part in the execution. Moreover, we evaluated the latency in different classes of runs:(1) runs with no failures nor failure suspicions,(2) runs with failures but no wrong suspicions. We determined the latency by measurements on a cluster of PCs interconnected with a 100 Mbps Ethernet network. We found that the Paxos algorithm is more efficient than the Chandra-Toueg algorithm when the process that coordinates the first round of the protocol crashes. The two algorithms have almost the same performance in all other cases.", "num_citations": "42\n", "authors": ["494"]}
{"title": "View synchronous communication in large scale networks\n", "abstract": " View synchronous communication (VSC) is a paradigm initially proposed by the Isis system, that is well suited to implement fault-tolerant services based on replication. VSC can be seen as an adequate low level semantics on which ordered multicasts and uniform multicasts can easily be implemented. This paper presents the speci c problems related to the implementation of VSC in a large scale network (eg Internet). The paper also shows how these problems are solved within Phoenix, a group oriented platform under development. Speci cally the Phoenix implementation of VSC allows progress in cases where traditional solutions would block forever.", "num_citations": "42\n", "authors": ["494"]}
{"title": "A leader-free byzantine consensus algorithm\n", "abstract": " The paper considers the consensus problem in a partially synchronous system with Byzantine faults. It turns out that, in the partially synchronous system, all deterministic algorithms that solve consensus with Byzantine faults are leader-based. This is not the case of benign faults, which raises the following fundamental question: is it possible to design a deterministic Byzantine consensus algorithm for a partially synchronous system that is not leader-based? The paper gives a positive answer to this question, and presents a leader-free algorithm that is resilient-optimal and signature-free.", "num_citations": "41\n", "authors": ["494"]}
{"title": "The CORBA object group service\n", "abstract": " Distributed computing is one of the major trends in the computer industry. As systems become more distributed, they also become more complex and have to deal with new kinds of problems, such as partial crashes and link failures. To answer the growing demand in distributed technologies, several middleware environments have emerged during the last few years. These environments however lack support for\\one-to-many\" communication primitives; such primitives greatly simplify the development of several types of applications that have requirements for high availability, fault tolerance, parallel processing, or collaborative work.One-to-many interactions can be provided by group communication. It manages groups of objects and provides primitives for sending messages to all members of a group, with various reliability and ordering guarantees. A group constitutes a logical addressing facility: messages can be issued to a group without having to know the number, identity, or location of individual members. The notion of group has proven to be very useful for providing high availability through replication: a set of replicas constitutes a group, but are viewed by clients as a single entity in the system.", "num_citations": "40\n", "authors": ["494"]}
{"title": "Bounded delay in Byzantine-tolerant state machine replication\n", "abstract": " The paper proposes a new state machine replication protocol for the partially synchronous system model with Byzantine faults. The algorithm, called BFT-Mencius, guarantees that the latency of updates initiated by correct processes is eventually upper-bounded, even in the presence of Byzantine processes. BFTMencius is based on a new communication primitive, Abortable Timely Announced Broadcast (ATAB), and does not use signatures. We evaluate the performance of BFT-Mencius in cluster settings, and show that it provides bounded latency and good throughput, being comparable to the state-of-the-art algorithms such as PBFT and Spinning in fault-free configurations and outperforming them under performance attacks by Byzantine processes.", "num_citations": "39\n", "authors": ["494"]}
{"title": "Using bounded model checking to verify consensus algorithms\n", "abstract": " This paper presents an approach to automatic verification of asynchronous round-based consensus algorithms. We use model checking, a widely practiced verification method; but its application to asynchronous distributed algorithms is difficult because the state space of these algorithms is often infinite. The proposed approach addresses this difficulty by reducing the verification problem to small model checking problems that involve only single phases of algorithm execution. Because a phase consists of a finite number of rounds, bounded model checking, a technique using satisfiability solving, can be effectively used to solve these problems. The proposed approach allows us to model check some consensus algorithms up to around 10 processes.", "num_citations": "39\n", "authors": ["494"]}
{"title": "Communication predicates: A high-level abstraction for coping with transient and dynamic faults\n", "abstract": " Consensus is one of the key problems in fault tolerant distributed computing. A very popular model for solving consensus is the failure detector model defined by Chandra and Toueg. However, the failure detector model has limitations. The paper points out these limitations, and suggests instead a model based on communication predicates, called HO model. The advantage of the HO model over failure detectors is shown, and the implementation of the HO model is discussed in the context of a system that alternates between good periods and bad periods. Two definitions of a good period are considered. For both definitions, the HO model allows us to compute the duration of a good period for solving consensus. Specifically, the model allows us to quantify the difference between the required length of an initial good period and the length of a non initial good period.", "num_citations": "39\n", "authors": ["494"]}
{"title": "A border-aware broadcast scheme for wireless ad hoc network\n", "abstract": " Under many circumstances, broadcasting is the only way of service discovery, device paging, and even data transfer in wireless ad hoc networks. However, broadcasting may lead to \"broadcast storm\" problems if it is done by simple flooding in a single common channel. The problems include redundant rebroadcast (overlaying), contention and collision. When the network density is high or the network is getting congested, the problems become severe and may directly lead to degraded performance of the network. We propose a novel broadcast scheme that is simple, highly efficient and scalable. Most importantly, it is a fully distributed scheme which introduces no control overheads (in terms of control traffic), and can adapt to network movement at no extra cost. We evaluate our scheme by OPNET simulation and compare it with existing methods.", "num_citations": "39\n", "authors": ["494"]}
{"title": "Failure detectors: Implementation issues and impact on consensus performance\n", "abstract": " Due to their nature, distributed systems are vulnerable to failures of some of their parts. Conversely, distribution also provides a way to increase the fault tolerance of the overall system. However, achieving fault tolerance is not a simple problem and requires complex techniques.An agreement problem known as the problem of consensus is at the heart of most problems encountered during the design of a fault tolerant system. This problem is however not solvable in the asynchronous system model, unless the model is augmented with adequate failure detectors. The resulting system model is a timefree model since all timing issues are abstracted by the characteristics of the failure detectors.", "num_citations": "39\n", "authors": ["494"]}
{"title": "Total order broadcast and multicast algorithms: Taxonomy and survey\n", "abstract": " Total order broadcast and multicast (also called atomic broadcast or atomic multicast) is an important problem in distributed systems, especially with respect to fault-tolerance. In short, the primitive ensures that messages sent to a set of processes are delivered by all these processes in the same total order. The problem has inspired an abundant literature, with a plethora of proposed algorithms. This paper proposes a classification of total order broadcast and multicast algorithms based on their ordering mechanisms, and addresses a number of other important issues. The paper surveys about sixty algorithms, thus providing by far the most extensive study of the problem so far. The paper discusses algorithms for both the synchronous and the asynchronous system models, and studies the respective properties and behavior of the different algorithms.", "num_citations": "38\n", "authors": ["494"]}
{"title": "Performance comparison of a rotating coordinator and a leader based consensus algorithm\n", "abstract": " Protocols that solve agreement problems are essential building blocks for fault tolerant distributed systems. While many protocols have been published, little has been done to analyze their performance, especially the performance of their fault tolerance mechanisms. In this paper, we compare two well-known asynchronous consensus algorithms. In both algorithms, a leader process tries to impose a decision, and another leader retries if the leader fails doing so. The algorithms elect leaders differently: the Chandra-Toueg algorithm has a rotating leader, whereas processes in the Paxos algorithm elect leaders directly. We investigate the performance implications of this difference. In the system under study, processes send atomic broadcasts to each other. Consensus is used to decide the delivery order of messages. We evaluate the steady state latency in (1) runs with neither crashes nor suspicions, (2) runs with\u00a0\u2026", "num_citations": "37\n", "authors": ["494"]}
{"title": "Structural and algorithmic issues of dynamic protocol update\n", "abstract": " In this paper, we study dynamic protocol update (DPU). Contrary to local code updates on-the-fly, DPU requires global coordination of local code replacements. We propose a novel solution to DPU. The key idea is to add a level of indirection between the service callers and the service provider. This indirection level facilitates an implementation of simple and efficient algorithms for DPU. For example, we describe an experimental implementation of adaptive group communication middleware. It can switch between different atomic broadcast protocols on-the-fly. All middleware protocols, including those that depend on the updated protocols, provide service correctly and with negligible delay while the global update takes places. The switching algorithm introduces very low overhead that we illustrate by showing example measurement results.", "num_citations": "36\n", "authors": ["494"]}
{"title": "Improving fast paxos: being optimistic with no overhead\n", "abstract": " The paper addresses the cost of consensus algorithms. It has been shown that in the best case, consensus can be solved in two communication steps with f< n/2, and in one communication step with f< n/3 (f is the maximum number of faulty processes). This leads to a dilemma when choosing a consensus algorithm: greater efficiency or higher resiliency degree. Recently Lamport has proposed a solution called Fast Paxos, for partly escaping from this dilemma. The idea is to combine two types of rounds in a single consensus algorithm: fast rounds and rounds of the ordinary Paxos algorithm. In the best case, Fast Paxos solves consensus in one fast round, that is it requires only one communication step. Unfortunately, the combination induces some time overhead, and so Fast Paxos becomes more expensive than ordinary Paxos when fast rounds do not succeed. In this paper we go one step further: we show that it is possible to tentatively execute a fast round before a classical round without any time overhead if the fast round does not succeed.", "num_citations": "36\n", "authors": ["494"]}
{"title": "Efficient execution replay technique for distributed memory architectures\n", "abstract": " Debugging parallel programs on MIMD machines is a difficult task because successive executions of the same program can lead to different behaviors. To solve this problem, a method called execution replay has been introduced, which guarantees the reexecution of a program to be equivalent to the initial execution. In this paper we present an execution replay technique in the context of distributed memory architectures. In contrary to all other proposed approaches, our technique can treat non-blocking message passing primitives, and can be adapted to any form of message passing communication. Since the technique is based on an events numbering, we show how to bound these numbers, and then analyse the influence of this bound on the amount of recorded information. The prototype implemented on an Intel iPSC/2 shows that the overhead due to the recording of control information is extremely low\u00a0\u2026", "num_citations": "36\n", "authors": ["494"]}
{"title": "Execution replay on distributed memory architectures\n", "abstract": " Debugging parallel programs on MIMD machines is a difficult task because successive executions of the same program can lead to different behaviors. To solve this problem, a method called execution replay has been introduced, which guarantees the reexecution of a program to be equivalent to the initial execution. Most of execution replay techniques proposed until now may be named 'data driven techniques'. Such techniques are relatively easy to implement in the case of the most common communication primitives. However, the time needed to record the large amount of required information is significant, which might modify the initial execution. Execution replay becomes in this case meaningless. Another class of execution replay named control driven execution replay allows one to limit the amount of recorded information. The paper presents a solution of the class control driven which realizes execution\u00a0\u2026", "num_citations": "36\n", "authors": ["494"]}
{"title": "Model Checking of Consensus Algorit\n", "abstract": " We show for the first time that standard model checking allows one to completely verify asynchronous algorithms for solving consensus, a fundamental problem in fault-tolerant distributed computing. Model checking is a powerful verification methodology based on state exploration. However it has rarely been applied to consensus algorithms, because these algorithms induce huge, often infinite state spaces. Here we focus on consensus algorithms based on the Heard-Of model, a new computation model for distributed computing. By making use of the high abstraction level provided by this computation model and by devising a finite representation of unbounded timestamps, we develop a methodology for verifying consensus algorithms in every possible state by model checking.", "num_citations": "34\n", "authors": ["494"]}
{"title": "SAMOA: framework for synchronisation augmented microprotocol approach\n", "abstract": " Summary form only given. We address programming abstractions for building protocols from smaller, reusable microprotocols. The existing protocol frameworks, such as Appia and Cactus, either restrict the amount of concurrency between microprotocols, or depend on the programmer, who should implement all the necessary synchronisation using standard language facilities. We develop J-SAMOA: a framework for a synchronisation augmented microprotocol approach in Java. It has been designed to allow concurrent protocols to be expressed without explicit low-level synchronisation, thus making programming easier and less error-prone. We describe versioning concurrency control algorithms. They are used by the runtime system of our framework to guarantee that the concurrent execution of a protocol is equivalent to a serial execution of its microprotocols. This guarantee, called the isolation property, ensures\u00a0\u2026", "num_citations": "34\n", "authors": ["494"]}
{"title": "Chasing the FLP impossibility result in a LAN: or, How robust can a fault tolerant server be?\n", "abstract": " Fault tolerance can be achieved in distributed systems by replication. However Fischer, Lynch and Paterson (1985) have proven an impossibility result about consensus in the asynchronous system model, and similar impossibility results exist for atomic broadcast and group membership. We investigate, with the aid of an experiment conducted in a LAN, whether these impossibility results set limits to the robustness of a replicated server exposed to extremely high loads. The experiment consists of client processes that send requests to a replicated server (three replicas) using an atomic broadcast primitive. It has parameters that allow us to control the load on the hosts and the network, as well as the timeout value used by our heartbeat failure detection mechanism. Our main observation is that the atomic broadcast algorithm never stops delivering messages, not even under arbitrarily high load and very small timeout\u00a0\u2026", "num_citations": "34\n", "authors": ["494"]}
{"title": "Comparative performance analysis of ordering strategies in atomic broadcast algorithms\n", "abstract": " In this paper, we present the results of a comparative analysis of Atomic Broadcast algorithms. The analysis was done by using an analytical method to compare the performance of five different classes of Atomic Broadcast algorithms. The five classes of Atomic Broadcast algorithms are determined by the mechanisms used by the algorithms to define the delivery order. To evaluate the performance of algorithms, the analysis relies on contention-aware metrics to provide a measure for both their latency and their throughput. The results thus obtained yield interesting insight into the performance tradeoffs of different Atomic Broadcast algorithms, thus providing helpful information to algorithms and systems designers.", "num_citations": "32\n", "authors": ["494"]}
{"title": "Replicating CORBA objects: a marriage between active and passive replication\n", "abstract": " Replication is a key mechanism for developing fault-tolerant and highly available applications. In this paper, we present a replication framework for replicating CORBA objects that combines the active and passive replication techniques. We show how we have used axiomatic properties of a consensus protocol together with a generic architectural framework to bridge the gap between active and passive replication. Our framework makes it possible to dynamically associate replication techniques to individual operations of a replicated object, without requiring the client to even know that the object is replicated. Augmenting CORBA with a replication service is a big step towards reliable and interoperable distributed systems.", "num_citations": "32\n", "authors": ["494"]}
{"title": "Replicating objects using the CORBA event service?\n", "abstract": " The Common Object Request Broker Architecture (CORBA) is becoming a standard for distributed application middleware, but no support is currently provided to handle object replication. In this paper, we discuss the relevance of using the Object Management Group's Event Service for replicating objects in a CORBA environment and compare it to other approaches.", "num_citations": "32\n", "authors": ["494"]}
{"title": "Execution replay: A mechanism for integrating a visualization tool with a symbolic debugger\n", "abstract": " Graphical representations of a program execution (also called visualization) have been shown to be useful to understand the behavior of parallel programs. Visualization of an execution is generally done off-line, using an adequate trace generated during execution. However, during the debugging phase, such representations may turn out to be insufficient: use of a symbolic debugger may also be required. The goal of this paper is to show that execution replay is the basic component that must be used to integrate a symbolic debugger with a visualization tool. Such an integration allows a simultaneous use of both tools during an execution, leading to an ideal observation of the execution: low level observation thanks to the debugger, and high level observation thanks to the visualization. This new approach has been implemented for parallel programs running on an iPSC/2.", "num_citations": "32\n", "authors": ["494"]}
{"title": "Leveraging hardware message passing for efficient thread synchronization\n", "abstract": " As the level of parallelism in manycore processors keeps increasing, providing efficient mechanisms for thread synchronization in concurrent programs is becoming a major concern. On cache-coherent shared-memory processors, synchronization efficiency is ultimately limited by the performance of the underlying cache coherence protocol. This paper studies how hardware support for message passing can improve synchronization performance. Considering the ubiquitous problem of mutual exclusion, we adapt two state-of-the-art solutions used on shared-memory processors, namely the server approach and the combining approach, to leverage the potential of hardware message passing. We propose HybComb, a novel combining algorithm that uses both message passing and shared memory features of emerging hybrid processors. We also introduce MP-Server, a straightforward adaptation of the server\u00a0\u2026", "num_citations": "31\n", "authors": ["494"]}
{"title": "Extending paxos/lastvoting with an adequate communication layer for wireless ad hoc networks\n", "abstract": " Most papers addressing consensus in wireless ad hoc networks adopt system models similar to those developed for wired networks. These models are focused towards node failures while ignoring link failures, and thus are poorly suited for wireless ad hoc networks. The recently proposed HO model does not have this drawback. The paper shows that an existing algorithm and the HO model can be used for multi-hop wireless ad hoc networks, if extended with an adequate communication layer. The description of the communication layer is augmented with simulation results that validate the feasibility of our approach and provide better understanding of the behavior of wireless environments.", "num_citations": "28\n", "authors": ["494"]}
{"title": "A systematic classification of replicated database protocols based on atomic broadcast\n", "abstract": " Database replication protocols based on group communication primitives have recently emerged as a promising technology to improve database faulttolerance and performance. Roughly speaking, this approach consists in exploiting the order and atomicity properties provided by group communication primitives or, more specifically Atomic Broadcast, to guarantee transaction properties. This paper proposes a systematic classification of non voting database replication algorithms based on Atomic Broadcast. 1.", "num_citations": "27\n", "authors": ["494"]}
{"title": "Implementing virtual machine replication: A case study using xen and kvm\n", "abstract": " Virtual machine (VM) replication has been recognized as an inexpensive way of providing high availability on commodity hardware. Unfortunately, its impact on system performance is far from negligible and strategies have been proposed to mitigate this problem. In this paper we take a look at VM replication from a different perspective: the choice of a hyper visor. Namely, the differences between hyper visors in terms of architecture and performance are well known and studied in the literature, but no analysis has been performed so far in the context of replication. Taking open-source hyper visors Xen and KVM as examples, we show what hyper visor services are necessary to implement a primary-backup replication scheme and how hyper visor design affects the development steps and the performance. Interestingly, our user space implementation on top of KVM achieves roughly the same performance as an\u00a0\u2026", "num_citations": "26\n", "authors": ["494"]}
{"title": "Unifying Byzantine consensus algorithms with weak interactive consistency\n", "abstract": " The paper considers the consensus problem in a partially synchronous system with Byzantine processes. In this context, the literature distinguishes authenticated Byzantine faults, where messages can be signed by the sending process (with the assumption that the signature cannot be forged by any other process), and Byzantine faults, where there is no mechanism for signatures (but the receiver of a message knows the identity of the sender). The paper proposes an abstraction called weak interactive consistency (WIC) that unifies consensus algorithms with and without signed messages. WIC can be implemented with and without signatures.               The power of WIC is illustrated on two seminal Byzantine consensus algorithms: the Castro-Liskov PBFT algorithm (no signatures) and the Martin-Alvisi FaB Paxos algorithms (signatures). WIC allows a very concise expression of these two algorithms.", "num_citations": "26\n", "authors": ["494"]}
{"title": "Beyond 1-safety and 2-safety for replicated databases: Group-safety\n", "abstract": " In this paper, we study the safety guarantees of group communication-based database replication techniques. We show that there is a model mismatch between group communication and database, and because of this, classical group communication systems cannot be used to build 2-safe database replication. We propose a new group communication primitive called end-to-end atomic broadcast that solves the problem, i.e., can be used to implement 2-safe database replication. We also introduce a new safety criterion, called group-safety, that has advantages both over 1-safety and 2-safety. Experimental results show the gain of efficiency of group-safety over lazy replication, which ensures only 1-safety.", "num_citations": "26\n", "authors": ["494"]}
{"title": "Specification of replication techniques, semi-passive replication and lazyt consensus\n", "abstract": " This paper brings the following three main contributions: a hierarchy of specifications for replication techniques, semi-passive replication, and Lazy Consensus. Based on the definition of the Generic Replication problem, we define two families of replication techniques: replication with parsimonious processing (eg, passive replication), and replication with redundant processing (eg, active replication). This helps relate replication techniques to each other. We define a novel replication technique with parsimonious processing, called semi-passive replication, for which we also give an algorithm. The most significant aspect of semi-passive replication is that it requires a weaker system model than existing techniques of the same family. We define a variant of the Consensus problem, called Lazy Consensus, upon which our semi-passive replication algorithm is based. The main difference between Consensus and Lazy Consensus is a property of laziness which requires that initial values are computed only when they are actually needed.", "num_citations": "26\n", "authors": ["494"]}
{"title": "Optimizing Paxos with batching and pipelining\n", "abstract": " Paxos is probably the most popular state machine replication protocol. Two optimizations that can greatly improve its performance are batching and pipelining. However, tuning these two optimizations to achieve high-throughput can be challenging, as their effectiveness depends on many parameters like the network latency and bandwidth, the speed of the nodes, and the properties of the application. We address this question by presenting an analytical model of the performance of Paxos, and showing how it can be used to determine configuration values for the batching and pipelining optimizations that result in high-throughput. We then validate the model, by presenting the results of experiments where we investigate the interaction of these two optimizations both in LAN and WAN environments, and comparing these results with the prediction from the model. The results confirm the accuracy of the model, with the\u00a0\u2026", "num_citations": "25\n", "authors": ["494"]}
{"title": "Optimization techniques for replicating CORBA objects\n", "abstract": " The CORBA Object Group Service (OGS) is a new CORBA service that provides support for fault-tolerance through the replication of CORBA objects. In this paper, we present several optimization techniques that are used to improve the performance of OGS. For each optimization, we analyse the impact on the throughput and the response time of OGS. The optimization techniques presented in this paper are quite generic and can be applied to many faulttolerant distributed algorithms based on consensus.", "num_citations": "25\n", "authors": ["494"]}
{"title": "On the reduction of atomic broadcast to consensus with Byzantine faults\n", "abstract": " We investigate the reduction of atomic broadcast to consensus in systems with Byzantine faults. Among the several definitions of Byzantine consensus that differ only by their validity property, we identify those equivalent to atomic broadcast. Finally, we give the first deterministic atomic broadcast reduction with a constant time complexity with respect to consensus.", "num_citations": "24\n", "authors": ["494"]}
{"title": "Solving atomic broadcast with indirect consensus\n", "abstract": " In previous work, it has been shown how to solve atomic broadcast by reduction to consensus on messages. While this solution is theoretically correct, it has its limitations in practice, since executing consensus on large messages can quickly saturate the system. The problem can be addressed by executing consensus on message identifiers instead of the full messages, in order to decouple the size of the messages from the size of the data sent by the consensus algorithm. In this paper, we study the impact of executing consensus on message identifiers instead of on the full messages, in the context of solving atomic broadcast. We also discuss the implications of executing consensus on message identifiers on the consensus and atomic broadcast algorithms", "num_citations": "24\n", "authors": ["494"]}
{"title": "Failure detection vs group membership in fault-tolerant distributed systems: Hidden trade-offs\n", "abstract": " Failure detection and group membership are two important components of fault-tolerant distributed systems. Understanding their role is essential when developing efficient solutions, not only in failure-free runs, but also in runs in which processes do crash. While group membership provides consistent information about the status of processes in the system, failure detectors provide inconsistent information. This paper discusses the trade-offs related to the use of these two components, and clarifies their roles using three examples. The first example shows a case where group membership may favourably be replaced by a failure detection mechanism. The second example illustrates a case where group membership is mandatory. Finally, the third example shows a case where neither group membership nor failure detectors are needed (they may be replaced by weak ordering oracles).", "num_citations": "24\n", "authors": ["494"]}
{"title": "Understanding concurrent programming through program animation\n", "abstract": " Program animation has mainly been developed for sequential programs. Animation of concurrent programs is much more uncommon, mainly because of the important technical problems. This paper presents a project whose objective is to animate any concurrent program written in the language Portal, a real time language close to Modula. The usefulness of animation in the context of teaching is shown by a few examples.", "num_citations": "24\n", "authors": ["494"]}
{"title": "Distal: A framework for implementing fault-tolerant distributed algorithms\n", "abstract": " We introduce Distal, a new framework that simplifies turning pseudocode of fault tolerant distributed algorithms into efficient executable code. Without proper tool support, even small amounts of pseudocode normally ends up in several thousands of non-trivial lines of Java or C++. Distal is implemented as a library in Scala and consists of two main parts: a domain specific language (DSL) in which algorithms are expressed and an efficient messaging layer that deals with low level issues such as connection management, threading and (de)serialization. The DSL is designed such that implementations of distributed algorithms highly resemble the pseudocode found in research papers. By writing code that is close to the protocol description, one can be more convinced that the implemented system really reflects the protocol specification on paper. Distal does not only make it simple and intuitive to implement distributed\u00a0\u2026", "num_citations": "23\n", "authors": ["494"]}
{"title": "Strong stable properties in distributed systems\n", "abstract": " A stable property in a distributed system is a global property which once true, remains true forever. This paper refines this notion by formally introducing the concept ofstrong stable properties. A strong stable property has the nice property that it can be correctly evaluated on the consistent part of uncoordinated snapshots. Termination and deadlock are shown to be strong stable properties, whereas distributed garbage is not. We also show how to derive a simple generic algorithm for the detection of a strong stable property. The generic algorithm is illustrated by two examples: termination detection and deadlock detection. Incidentally the paper presents a very simple algorithm for termination detection.", "num_citations": "23\n", "authors": ["494"]}
{"title": "Generic construction of consensus algorithms for benign and byzantine faults\n", "abstract": " The paper proposes a generic consensus algorithm that highlights the basic and common features of known consensus algorithms. The parameters of the generic algorithm encapsulate the core differences between various consensus algorithms, including leader-based and leader-free algorithms, addressing benign faults, authenticated Byzantine faults and Byzantine faults. This leads to the identification of three classes of consensus algorithms. With the proposed classification, Paxos and PBFT indeed belong to the same class, while FaB Paxos belongs to a different class. Interestingly, the classification allowed us to identify a new Byzantine consensus algorithm that requires n > 4b, where b is the maximum number of Byzantine processes.", "num_citations": "22\n", "authors": ["494"]}
{"title": "A lower bound for broadcasting in mobile ad hoc networks\n", "abstract": " We give a lower bound of \u2126 (n) rounds for broadcasting in mobile ad hoc networks, where n is the number of nodes in the network. A round is the time taken by a node to successfully transmit a message to all its neighbors. It has been shown by Bruschi et al. and Chlebus et al. that a minimum of \u2126 (log n) time-slots are required in a round to propagate the broadcast message by one hop. In static networks, this gives us the lower bound for network-wide broadcast to be \u2126 (D log n) time-slots, where D is its diameter. Although this lower bound is valid for a mobile network, we obtain a tighter lower bound of \u2126 (n log n) time-slots by considering explicit node mobility. This result is valid even when D\u226a n and the network diameter never exceeds D. This shows that the dominating factor in the complexity of broadcasting in a mobile network is the number of nodes in the network and not its diameter.", "num_citations": "22\n", "authors": ["494"]}
{"title": "Preventing orphan requests in the context of replicated invocation\n", "abstract": " In today's systems, applications are composed from various components that may be located on different machines. The components (acting as servers) may have to collaborate in order to service a client request. More specifically, a client request to one component may trigger a request to another component. To ensure fault-tolerance, components are generally replicated. Replicated components lead to the problem of a replicated server invoking another replicated server. We call this the problem of replicated invocation. Replicated invocation has been considered in the context of deterministic servers. However, the problem is more difficult to address when servers are non-deterministic. In this context, work has been done to enforce deterministic execution. In this paper, we consider a different approach: instead of preventing non-deterministic execution of servers we discuss how to handle it. We present the\u00a0\u2026", "num_citations": "22\n", "authors": ["494"]}
{"title": "View synchronous communication in large scale distributed systems\n", "abstract": " View synchronous communication (VSC) is a paradigm initially proposed by the Isis system, that is well suited to implement fault-tolerant services based on replication. VSC can be seen as an adequate low level semantics on which ordered multicasts and uniform multicasts can easily be implemented. This paper presents the specific problems related to the implementation of VSC in a large scale network (eg Internet). The paper also shows how these problems are solved within Phoenix, a group oriented platform under development. Specifically the Phoenix implementation of VSC allows progress in cases where traditional solutions would block forever.", "num_citations": "22\n", "authors": ["494"]}
{"title": "Modeling and validating the performance of atomic broadcast algorithms in high latency networks\n", "abstract": " The performance of consensus and atomic broadcast algorithms using failure detectors is often affected by a trade-off between the number of communication steps and the number of messages needed to reach a decision.               In this paper, we model the performance of three consensus and atomic broadcast algorithms using failure detectors in the oft-neglected setting of wide area networks and validate this model by experimentally evaluating the algorithms in several different setups.", "num_citations": "21\n", "authors": ["494"]}
{"title": "Protocol objects and patterns for structuring reliable distributed systems\n", "abstract": " This thesis is at the crossing of object-orientation and reliable distributed systems, and contributes to integrate those two research fields. Existing distributed programming environments can be characterised according to whether they rely on object concepts and to whether they deal with reliability issues. Most of such environments combine objects and distribution, although they follow different approaches in doing so. However, only a minority is concerned with reliability. This is not surprising, since the design of reliable distributed software requires to deal with many non-trivial issues, such as reliable communication, failure detection, consensus, etc. In this context, the research presented here focuses on fundamental programming abstractions for structuring reliability issues at the system level. Three questions are at the heart of that concern:(1) what abstractions are most adequate to model reliability,(2) how to represent them to promote flexible design, and (3) how to implement them to promote code reuse. These questions enable to further categorise existing distributed environments as reliability-based or protocol-based. The former answer question 1, by proposing either group communication or transactions, whereas the latter answer questions 2 and 3 by providing protocols as basic structuring abstractions. Because transactions and group communication are primarily aimed at application programmers, reliability-based environments are of limited help for system programmers. As for protocol-based environments, none integrates recent advances in object-orientation, such as design patterns, and in the theory of asynchronous distributed\u00a0\u2026", "num_citations": "21\n", "authors": ["494"]}
{"title": "Genuine atomic multicast\n", "abstract": " This paper addresses the problem of atomic multicasting messages in asynchronous systems with unreliable failure detection. First, we give a characterisation of the notion of algorithms tolerating unreliable failure detection. Second, we give a characterisation of the notion of genuine atomic multicast. This characterisation leads to a better understanding of the difference between atomic multicast and atomic broadcast, and to a clear distinction between genuine atomic multicast algorithms and non-genuine atomic multicast algorithms. Third, we show that in a system with at least three processes, the genuine atomic multicast problem cannot be solved with unreliable failure detection, if at least one process may crash. We mention however two ways of circumventing this impossibility result.", "num_citations": "21\n", "authors": ["494"]}
{"title": "The heard-of model: Unifying all benign failures\n", "abstract": " Problems in fault-tolerant distributed computing have been studied in a variety of models. These models are structured around two central ideas:", "num_citations": "20\n", "authors": ["494"]}
{"title": "High-performance RMA-based Broadcast on the Intel SCC\n", "abstract": " Many-core chips with more than 1000 cores are expected by the end of the decade. To overcome scalability issues related to cache coherence at such a scale, one of the main research directions is to leverage the message-passing programming model. The Intel Single-Chip Cloud Computer (SCC) is a prototype of a message-passing many-core chip. It offers the ability to move data between on-chip Message Passing Buffers (MPB) using Remote Memory Access (RMA). Performance of message-passing applications is directly affected by efficiency of collective operations, such as broadcast. In this paper, we study how to make use of the MPBs to implement an efficient broadcast algorithm for the SCC. We propose OC-Bcast (On-Chip Broadcast), a pipelined k-ary tree algorithm tailored to exploit the parallelism provided by on-chip RMA. Using a LogP-based model, we present an analytical evaluation that compares\u00a0\u2026", "num_citations": "18\n", "authors": ["494"]}
{"title": "A new look at atomic broadcast in the asynchronous crash-recovery model\n", "abstract": " Atomic broadcast in particular, and group communication in general, have mainly been specified and implemented in a system model where processes do not recover after a crash. The model is called crash-stop. The drawback of this model is its inability to express algorithms that tolerate the crash of a majority of processes. This has led to extend the crash-stop model to the so-called crash-recovery model, in which processes have access to stable storage, to log their state periodically. This allows them to recover a previous state after a crash. However, the existing specifications of atomic broadcast in the crash-recovery model are not satisfactory, and the paper explains why. The paper also proposes a new specification of atomic broadcast in the crash-recovery model that addresses these issues. Specifically, our new specification allows to distinguish between a uniform and a non-uniform version of atomic\u00a0\u2026", "num_citations": "18\n", "authors": ["494"]}
{"title": "Group communication based on standard interfaces\n", "abstract": " While group communication systems have been proposed for some time, they are still not used much in actual systems. We believe that one reason for this is the lack of standardisation of group communication system interfaces. The paper proposes an architecture, using the standard decomposition into services, where services are based on standard interfaces: both interactions between services and interactions with the application use existing, open standards. A decomposition of the group communication into services is presented, along with a description of applicable standards. As an example, a group membership service based on the LDAP standard is discussed.", "num_citations": "18\n", "authors": ["494"]}
{"title": "Replication: Understanding the advantage of atomic broadcast over quorum systems\n", "abstract": " Quorum systems (introduced in the late seventies) and atomic broadcast (introduced later) are two techniques to manage replicated data. Despite of the fact that these two techniques are now well known, the advantage of atomic broadcast over quorum systems is not clearly understood. The paper explains exactly in what cases atomic broadcast is a better technique than quorum systems to handle replication.", "num_citations": "17\n", "authors": ["494"]}
{"title": "Solving consensus: From fair-lossy channels to crash-recovery of processes\n", "abstract": " Distributed systems are the basis of widespread computing facilities enabling many of our daily life activities. Telebanking, electronic commerce, online booking-reservation, and telecommunication are examples of common services that rely on distributed systems in order to achieve their desirable ubiquity. The success of these services increasingly depends on fault-tolerant systems to preserve their availability and reliability despite partial failures. Fault tolerance can be achieved by introducing redundancy into the system. This leads to the need of coordinating replicated components which has been one of the biggest trends in software technologies.This thesis is about process coordination in fault-tolerant distributed systems. In particular, it focuses on the problem of reaching agreement among processes considering the well-known Consensus problem. Consensus is regarded as an abstract problem whose solutions embody the complexity inherent to most agreement problems.", "num_citations": "17\n", "authors": ["494"]}
{"title": "Quantitative analysis of consensus algorithms\n", "abstract": " Consensus is one of the key problems in fault-tolerant distributed computing. Although the solvability of consensus is now a well-understood problem, comparing different algorithms in terms of efficiency is still an open problem. In this paper, we address this question for round-based consensus algorithms using communication predicates, on top of a partial synchronous system that alternates between good and bad periods (synchronous and nonsynchronous periods). Communication predicates together with the detailed timing information of the underlying partially synchronous system provide a convenient and powerful framework for comparing different consensus algorithms and their implementations. This approach allows us to quantify the required length of a good period to solve a given number of consensus instances. With our results, we can observe several interesting issues, such as the number of rounds of\u00a0\u2026", "num_citations": "16\n", "authors": ["494"]}
{"title": "A formal approach to fault tolerant distributed consensus\n", "abstract": " Our world is more and more dominated by technology. Computers, mobile phones, communication networks have with no doubt become man\u2019s best helpers. It is quite common to confide them important or delicate information, trusting that we will be able to retrieve and modify our data at any time. Moreover, with the advent of globalization, it is more and more frequent to have companies showing their main siege in Europe, the Research & Development group in the USA and the production site in Asia, all confidently sharing and manipulating some common information. However, well hidden behind the availability and reliability that appear to the final users, there are a great number of technologies and engineering solutions built to mask the problems related to information storage, data synchronization, transmission of information and so on. Let us take the example of storage. We all agree on the fact that in this world there is no infallible electronic equipment. Thus, if we store our data only on one machine, in case we run into technical problems we are very likely to lose all our information. In this case, the freedom from faults is achieved through the use of replication. The more the stored data is important, the more replicas containing the data are usually created. In this scenario, as well as in the case of globalized companies, if a user wants to make a simple change in the stored data, many repositories are in reality affected by the operation and many messages have to be exchanged between the repositories in order to ensure information consistency. This necessary communication introduces additional elements of failure: the possible delay and\u00a0\u2026", "num_citations": "16\n", "authors": ["494"]}
{"title": "Harmful dogmas in fault tolerant distributed computing\n", "abstract": " Consensus is a central problem in fault tolerant distributed computing. A vast number of (positive and negative) results for consensus in various system models have been established. In this paper we isolate three features that all these system models share, and we show that inappropriate modelling choices have led to overcomplicate the approaches to studying the consensus problem, thus yielding too restrictive solutions for real systems. It is hard to question these modelling choices, as they have gained the status of dogmas. Nevertheless, we propose a simpler and more natural approach that allows us to get rid of these dogmas, and to handle all types of benign fault, be it static or dynamic, permanent or transient, in a unified framework.", "num_citations": "16\n", "authors": ["494"]}
{"title": "Reliable multicast in mobile networks\n", "abstract": " This paper describes a distributed algorithm for reliable multicast in mobile cellular networks. In the proposed solution the multicast message is flooded to all the base stations over reliable channels. The base stations then collectively ensure that all mobile nodes belonging to the multicast group get the message. The originality of our solution is that it is fully decentralized. Each base station can independently decide when to flush a message from its buffer. Even if a node moves from one cell to another while a multicast is in progress, delivery of the message to the node is guaranteed. Simulation experiments show that using the proposed solution, memory requirements at the base stations are significantly smaller than by using centralized solutions.", "num_citations": "16\n", "authors": ["494"]}
{"title": "Towards JMS-Compliant Group Communication\n", "abstract": " Group communication provides communica-tion primitives with various semantics and their use greatly simplifies the development of highly available services. However, despite tremendous advances in research and numerous prototypes, group communication stays confined to small niches and academic prototypes. In contrast, message-oriented middleware such as the Java Messaging Service (JMS) is widely used, and has become a defacto standard. We believe that the lack of standard interfaces is the reason that hinders the deployment of group communication systems. Since JMS is well-established, an interesting solution is to map group communication primitives onto the JMS API. This requires to adapt the traditional specifications of group communication in order to take into account the features of JMS. The resulting group communication API, together with corresponding specifications, defines group communication primitives compatible with the JMS syntax and semantics.", "num_citations": "16\n", "authors": ["494"]}
{"title": "Soft real-time analysis of asynchronous agreement algorithms using Petri nets\n", "abstract": " A distributed algorithm comprises a collection of sequential-code entities, which are spread over different computers connected to a network. The process of designing a distributed algorithm is influenced by the assumptions we make on the computational environment. The model which makes no assumptions (and therefore can fit any real distributed system) is the asynchronous system model. In the asynchronous model there is no bound on message delays, clock drift or the time needed by a process to execute a step. The advantage of using the asynchronous model is that any algorithm designed under its assumptions preserves its correctness (safety) in any other system model. It has been argued that asynchronous algorithms cannot be used for time critical applications. One of the goals of this thesis is to clarify this point, by proving that designing algorithms under the asynchronous system model does not lead to loss of efficiency. The performance of distributed algorithms may be roughly approximated in terms of the number of messages exchanged during the execution or the number of communication steps, but the most precise performance metric is the termination time (ie, the time needed for the algorithm to finish). The termination time of a distributed algorithm cannot be precisely measured if computation begins and ends on different processors because the clocks are not synchronized. Another difficulty with the performance measures approach is that results are usually biased by unpredictable network and stations loads, or by scheduling delays, not related to the studied algorithm. The approach taken in this thesis for evaluating the\u00a0\u2026", "num_citations": "16\n", "authors": ["494"]}
{"title": "Atomic updates of replicated data\n", "abstract": " Although several replication strategies have been described and compared in the literature, very few work has been published on the underlying protocols needed to support these strategies. In fact, the classical transactional protocols that are usually assumed are not fault-tolerant, and thus create a window of vulnerability for the \u201cfaulttolerant\u201d strategies they intend to support. In this paper, we point out this issue for \u201cquorum voting\u201d replication strategies. We describe a faulttolerant protocol that enables to adequately support these strategies. We present some performance figures showing that, in addition to its higher resilience, our protocol provides better performance than the other possible alternatives.", "num_citations": "16\n", "authors": ["494"]}
{"title": "Replication for send-deterministic MPI HPC applications\n", "abstract": " Replication has recently gained attention in the context of fault tolerance for large scale MPI HPC applications. Existing implementations try to cover all MPI codes and to be independent from the underlying library. In this paper, we evaluate the advantages of adopting a different approach. First, we try to take advantage of a communication property common to many MPI HPC application, namely send-determinism. Second, we choose to implement replication inside the MPI library. The main advantage of our approach is simplicity. While being only a small patch to the Open MPI library, our solution called SDR-MPI supports most main features of the MPI standard including all collectives and group operations. SDR-MPI additionally achieves good performance: Experiments run with HPC benchmarks and applications show that its overhead remains below 5%.", "num_citations": "15\n", "authors": ["494"]}
{"title": "Asynchronous broadcast on the intel scc using interrupts\n", "abstract": " This paper focuses on the design of an asynchronous broadcast primitive on the Intel SCC. Our solution is based on OC-Bcast, a state-of-the-art k-ary tree synchronous broadcast algorithm that leverages the parallelism provided by on-chip Remote Memory Accesses to Message Passing Buffers. In the paper, we study the use of parallel inter-core interrupts as a means to implement an efficient asynchronous group communication primitive, and present the userspace library we designed to be able to use interrupts in OC-Bcast and make it work asynchronously. Our experimental evaluation shows that our algorithm allows parallel broadcast operations to efficiently progress concurrently and provides low latency for a single broadcast operation. It highlights that parallel interrupts can help implementing efficient group communication primitives on many-core systems.", "num_citations": "15\n", "authors": ["494"]}
{"title": "Service interface: a new abstraction for implementing and composing protocols\n", "abstract": " In this paper we compare two approaches to the design of protocol frameworks--tools for implementing modular network protocols. The most common approach uses events as the main abstraction for a local interaction between protocol modules. We argue that an alternative approach, that is based on service abstraction, is more suitable for expressing modular protocols. It also facilitates advanced features in the design of protocols, such as dynamic update of distributed protocols. We then describe an experimental implementation of a service-based protocol framework in Java.", "num_citations": "15\n", "authors": ["494"]}
{"title": "A location service mechanism for position-based multicasting in wireless mobile ad hoc networks\n", "abstract": " In this paper we propose a novel location management scheme tailored for multicasting in Mobile Ad-hoc Networks (MANETs). We furthermore propose AMDLM, a location-based multicast algorithm relying on the location management service. Such an approach avoids fragile data structures such as trees or DAGs to manage multicast groups, without reverting to more reliable, yet overhead-prone mesh-based algorithms. AMDLM additionally enables us to derive analytical bounds due to its location-based nature.", "num_citations": "15\n", "authors": ["494"]}
{"title": "Evaluating CORBA portability: The case of an object group service\n", "abstract": " One of the most attractive aspects of the Common Object Request Broker Architecture (CORBA) lies in its open standard nature. Code that is based only on constructs described in the CORBA specification is portable between object request brokers (ORBs) without depending on any single ORB implementation. However, this portability feature is not completely achieved in real-world applications. This paper discusses CORBA portability issues through our experience in implementing a CORBA object group service (OGS) and porting it on different ORBs. In particular, we discuss some implementation choices we made with Orbix and VisiBroker, and we point out the impact of these choices on the service portability and interoperability. This sheds some light on whether the current CORBA specification is mature enough to be deployed in industrial systems that have requirements regarding portability and\u00a0\u2026", "num_citations": "15\n", "authors": ["494"]}
{"title": "A generic multicast primitive to support transactions on replicated objects in distributed systems\n", "abstract": " Locking and atomic commitment are two fundamental problems underlying transaction management in fault-tolerant distributed systems. In this paper we discuss these problems in the context of an asynchronous system with replicated objects. We present a generic primitive, named dynamic-terminating-multicast (or DTM) of which instances enable to implement a locking protocol and an atomic commitment protocol. By unifying the mechanisms needed to implement these protocols, we believe that the DTM primitive can be considered as a basic building block of distributed transactional systems. We show that this primitive can be implemented in an asynchronous system based on an unreliable failure detector.", "num_citations": "15\n", "authors": ["494"]}
{"title": "Understanding the power of the virtually-synchronous model\n", "abstract": " Dependability in a distributed system is achievable only by introducing redundancy of key system components, and in particular, replication of system services which require to be faulttolerant 9]. The speci cation of functionality, performance requirements and failure semantics for replicated components implies the choice of a replication policy for the given services. However, and in general, the set of replicas implementing a system service can be viewed as a group of active entities collaborating towards a common objective. Hence the importance of group oriented models of communication in a dependable distributed system.These considerations have lead to various models and implementations of group-oriented communication, based either on the synchronous model 4](bounded communication delays and synchronized clocks), or on the asynchronous model 1, 16, 8](no bound on communication delays and no synchronized clocks). One of the most interesting asynchronous models is the so-called", "num_citations": "15\n", "authors": ["494"]}
{"title": "Towards flexible finite-state-machine-based protocol composition\n", "abstract": " We propose a novel approach to the composition of group communication protocols. In this approach, components are modelled as finite state machines communicating via signals. We introduce two building blocks, called adaptor and adaplexor, that ease the development and the composition of group communication protocol stacks, and we discuss how isolation can be achieved in this setting. To validate our architectural concepts, we have implemented the proposed group communication architecture in SDL.", "num_citations": "14\n", "authors": ["494"]}
{"title": "Comparing distributed consensus algorithms\n", "abstract": " Protocols that solve agreement problems are essential building blocks for fault tolerant distributed systems. While many protocols have been published, little has been done to analyze their performance, especially the performance of their fault tolerance mechanisms. In this paper, we compare two consensus algorithms with different communication schemes: one is centralized and the other decentralized. The elements of the simulation study form a generic methodology for evaluating consensus algorithms. The results show that the centralized algorithm performs better in some environments, in spite of the fact that the decentralized algorithm finishes in fewer communication steps. The reason is that it generates less contention.", "num_citations": "14\n", "authors": ["494"]}
{"title": "Approaches to fault-tolerant mobile agent execution\n", "abstract": " Fault tolerance is fundamental to the further development of mobile agent applications. It ensures that the agent arrives at its destination and thus prevents a partial or complete loss of the agent. This paper surveys the current approaches to fault-tolerant mobile agent execution. Most of these approaches are based on replication. We propose a classification into temporal-replication-based and spatial-replication-based approaches and discuss the advantages and disadvantages of these approaches.", "num_citations": "14\n", "authors": ["494"]}
{"title": "Group communication: From practice to theory\n", "abstract": " Improving the dependability of computer systems is a critical and essential task. In this context, the paper surveys techniques that allow to achieve fault tolerance in distributed systems by replication. The main replication techniques are first explained. Then group communication is introduced as the communication infrastructure that allows the implementation of the different replication techniques. Finally the difficulty of implementing group communication is discussed, and the most important algorithms are presented.", "num_citations": "13\n", "authors": ["494"]}
{"title": "Semantics of protocol modules composition and interaction\n", "abstract": " This paper studies the semantics of protocol modules composition and interaction in configurable communication systems. We present a semantic model describingCactus and Appia \u2014 two frameworks that are used for implementingmo dular systems. The model covers protocol graph, session and channel creation, and inter-module communication of events and messages. To build the model, we defined a source-code-validated specification of a large fragment of the programmingin terface provided by the frameworks; we developed an operational semantics describingthe behaviour of the operations through state transitions, makingexplicit interactions between modules. Developingthe model and a small example implementinga configurable multicast helped us to better understand the design choices in these frameworks. The work reported in this paper is our first step towards reasoningab out systems\u00a0\u2026", "num_citations": "13\n", "authors": ["494"]}
{"title": "Primary-backup replication: From a time-free protocol to a time-based implementation\n", "abstract": " Fault-tolerant control systems can be built by replicating critical components. However replication raises the issue of inconsistency. Multiple protocols for ensuring consistency have been described in the literature. PADRE (Protocol for Asymmetric Duplex REdundancy) is such a protocol, and an interesting case study of a complex and sensitive problem: the management of replicated traffic controllers in a railway system. However, the low level at which the protocol has been developed embodies system details, namely timeliness assumptions, that make it difficult to understand and may narrow its applicability. We argue that, when designing a protocol, it is preferable to consider first a general solution that does not include any timeliness assumptions; then, by taking into account an additional hypothesis, one can easily design a time-based solution tailored to a specific environment. This paper illustrates the benefit of\u00a0\u2026", "num_citations": "13\n", "authors": ["494"]}
{"title": "Time vs. space in fault-tolerant distributed systems\n", "abstract": " Algorithms for solving agreement problems can be classified in two categories: (1) those relying on failure detectors (FDs), which we call FD-based, and (2) those that rely on a group membership service (GMS), which we call GMS-based. This paper discusses the advantages and limitations of these two approaches and proposes an extension to the GMS approach that combines the advantages of both approaches, without their drawbacks. This extension leads us to distinguish between time-triggered suspicions of processes and space-triggered exclusions.", "num_citations": "13\n", "authors": ["494"]}
{"title": "Addressing the ZooKeeper synchronization inefficiency\n", "abstract": " ZooKeeper provides an event like synchronization mechanism, which notifies the clients upon state change on the server. This mechanism leads to very inefficient implementation of synchronization objects. We propose a new solution to this problem. The solution is to handle a sequence of client operations completely on the server through a generic API. We have developed a prototype that allows very efficient implementation of synchronization objects. The solution requires a deterministic multi-threaded server. Experiments show the significant gain in efficiency of our solution on producer-consumer queues and synchronization barriers.", "num_citations": "12\n", "authors": ["494"]}
{"title": "A fault-tolerant token-based atomic broadcast algorithm\n", "abstract": " Many atomic broadcast algorithms have been published in the last 20 years. Token-based algorithms represent a large class of these algorithms. Interestingly, all the token-based atomic broadcast algorithms rely on a group membership service and none of them uses unreliable failure detectors directly. This paper presents the first token-based atomic broadcast algorithm that uses an unreliable failure detector instead of a group membership service. It requires a system size that is quadratic in the number of supported failures. The special case of a single supported failure (f=1) requires n=3 processes. We experimentally evaluate the performance of this algorithm in local and wide area networks, in order to emphasize that atomic broadcast is efficiently implemented by combining a failure detector and a token-based mechanism. The evaluation shows that the new token-based algorithm surpasses the performance of\u00a0\u2026", "num_citations": "12\n", "authors": ["494"]}
{"title": "On the specification of partitionable group membership\n", "abstract": " Group communication in partitionable systems has been the focus of many research activities over the last decade. Fault-tolerant applications in a partitionable system model generally rely on two basic services: a group membership service and a reliable multicast service. The paper considers two of the most prominent specifications for such services that appear in the literature. Based on these specifications, the paper shows that one specification can be satisfied by a trivial implementation and the other, which basically extends the first one, requires additional system assumptions, which are discussed in the paper. The paper shows that the specifications of group communication in partitionable systems has not yet reached the level of maturity of the so called primary partition specifications.", "num_citations": "12\n", "authors": ["494"]}
{"title": "Programmation concurrente: illustr\u00e9e par des exemples en Portal, Modula-2 et Ada\n", "abstract": " Le catalogue des publications des Presses polytechniques et universitaires romandes peut \u00eatre obtenu par courrier \u00e0 l'adresse suivante, EPFL\u2013Centre Midi, CH-1015 Lausanne, par E-Mail \u00e0 ppur@ epfl. ch, par t\u00e9l\u00e9phone au (0) 21 693 41 40, ou par fax au (0) 21 693 40 27.", "num_citations": "12\n", "authors": ["494"]}
{"title": "Group Communication: Where are we today and future challenges\n", "abstract": " Group communication is a topic studied since more than twenty years. During this period significant results have been obtained. Nevertheless there are issues that have not been addressed adequately. The paper presents both the important results related to group communication that have been obtained, but also points out what remains to be done to make group communication widely used, and as successful as some of the existing middleware technologies.", "num_citations": "11\n", "authors": ["494"]}
{"title": "Future directions in distributed computing: research and position papers\n", "abstract": " Every year we witness acceleration in the availability, deployment, and use of distributed applications. However building increasingly sophisticated applications for extant and emerging networked systems continues to be challenging for several reasons:\u2013Abstract models of computation used in distributed systems research often do not fully capture the limitations and the unpredictable nature of realistic distributed computing platforms;\u2013Fault-tolerance and ef? ciency of computation are dif? cult to combine when the c-puting medium is subject to changes, asynchrony, and failures;\u2013Middleware used for constructing distributed software does not provide services most suitable for sophisticated distributed applications;\u2013Middleware services are speci? ed informally and without precise guarantees of e-ciency, fault-tolerance, scalability, and compositionality;\u2013Speci? cation of distributed deployment of software systems is often left out of the development process;\u2013Finally, there persists an organizational and cultural gap between engineering groups developing systems in a commercial enterprise, and research groups advancing the scienti? c state-of-the-art in academic and industrial settings. The objectives of this book are:(1) to serve as a motivation for de? ning future research programs in distributed computing,(2) to help identify areas where practitioners and engineers on the one hand and scientists and researchers on the other can improve the state of distributed computing through synergistic efforts, and (3) to motivate graduate students interested in entering the exciting research? eld of distributed computing.", "num_citations": "11\n", "authors": ["494"]}
{"title": "Dependable systems: software, computing, networks: research results of the DICS program\n", "abstract": " Modern civilization relies on a functioning information infrastructure. As a result, dependability has become a central issue in all disciplines of systems engineering and software architecture. Theories, methods and tools that help to master the problems encountered in the design process and the management of operations are therefore of utmost importance for the future of information and communication technology. The present volume documents the results of a research program on Dependable Information and Communication Systems (DICS). The members of the project met in two workshops organized by the Hasler Foundation. This state-of-the-art survey contains 3 overview articles identifying major issues of dependability and presenting the latest solutions, as well as 10 carefully selected and revised papers depicting the research results originating from those workshops. The first workshop took place in M\u00fcnchenwiler, Switzerland, in March 2004, and the second workshop, which marked the conclusion of the projects, in L\u00f6wenberg, Switzerland, in October 2005. The papers are organized in topical sections on surveys, dependable software, dependable computing, and dependable networks.", "num_citations": "10\n", "authors": ["494"]}
{"title": "Non-blocking transactional mobile agent execution\n", "abstract": " Mobile agents are computer programs that act autonomously on behalf of a user and travel through a network of heterogeneous machines. To enable mobile agent technology for e-business, transaction support needs to be provided, in particular execution atomicity. Execution atomicity ensures that either all operations of the agent succeed, or none at all, and needs to be ensured also in the face of infrastructure failures. We distinguish between blocking and non-blocking solutions for transactional mobile agents, i.e., mobile agents, that execute as a transaction. The approach presented in the paper is non-blocking. A non-blocking transactional mobile agent execution has the important advantage, that it can make progress despite failures.", "num_citations": "10\n", "authors": ["494"]}
{"title": "Service SNMP de d\u00e9tection de faute pour des systemes r\u00e9partis\n", "abstract": " Ce chapitre expose les d\u00e9tails d\u2019impl\u00e9mentation du service de d\u00e9tection de faute bas\u00e9 sur le protocole SNMP. Avec les commentaires javadoc, cette documentation devrait servir de r\u00e9f\u00e9rence pour permettre la continuation du projet. Une vue globale du syst\u00e8me est d\u2019abord pr\u00e9sent\u00e9e puis des diagrammes exposent la structure composant par composant. Ce design est orient\u00e9 composant. En effet, une totale s\u00e9paration existe entre les composants qui impl\u00e9mentent l\u2019envoi et la r\u00e9ception de messages SNMP ou \u201cstack SNMP1\u201d et les composants qui impl\u00e9mentent l\u2019algorithme de d\u00e9tection de faute. Il est donc facile d\u2019utiliser un toolkit de stack snmp d\u00e9j\u00e0 impl\u00e9ment\u00e9 et de le remplacer selon les besoins. Afin de ne pas r\u00e9inventer la roue, une \u00e9tude comparative est effectu\u00e9e sur les diff\u00e9rentes stack snmp disponibles afin d\u2019en r\u00e9utiliser une.", "num_citations": "10\n", "authors": ["494"]}
{"title": "Highly available trading system: Experiments with CORBA\n", "abstract": " The Swiss Exchange system (SWX system) was the first stock exchange system in service to be fully computerised. For high availability, the trading system is built as a replicated service based on Isis. For portability reasons, the SWX team has considered basing the next version of the trading system on CORBA. Despite the numerous advantages of a CORBA based solution, it was necessary not only to meet the functionality requirements of the system, but also to evaluate the performance of the chosen middleware.             This paper describes a model that simulates the communication behavior of the trading system on Iona\u2019s Orbix and OrbixTalk. We have evaluated this model in order to illustrate some of the performance limitations of this communication infrastructure. We have also studied the fault-tolerance of the system and found that a key aspect in such a system is the state transfer. We have extended\u00a0\u2026", "num_citations": "10\n", "authors": ["494"]}
{"title": "Dagstuhl seminar review: Consistency in distributed systems\n", "abstract": " In distributed systems, there exists a fundamental trade-off between data consistency, availability, and the ability to tolerate failures. This trade-off has significant implications on the design of the entire distributed computing infrastructure such as storage systems, compilers and runtimes, application development frameworks and programming languages. Unfortunately, it also has significant, and poorly understood, implications for the designers and developers of end applications. As distributed computing become mainstream, we need to enable programmers who are not experts to build and understand distributed applications.", "num_citations": "9\n", "authors": ["494"]}
{"title": "FRANC: A lightweight java framework for wireless multihop communication\n", "abstract": " Simulation and emulation are popular means for evaluating wireless Mobile Ad hoc Networks (MANETs) protocols. Since MANETs are highly dependant on their physical environment, these techniques offer only a partial understanding of factors that may influence performance. Deploying real-life MANETs is therefore an indispensable complementary step for the advancement of MANETs. This paper presents FRANC 1, a dedicated extensible Java framework for the development, deployment and evaluation of applications and algorithms for wireless mobile ad hoc networks.", "num_citations": "9\n", "authors": ["494"]}
{"title": "Fault-tolerant and transactional mobile agent execution\n", "abstract": " Mobile agents constitute a computing paradigm of a more general nature than the widely used client/server computing paradigm. A mobile agent is essentially a computer program that acts autonomously on behalf of a user and travels through a network of heterogeneous machines. However, the greater flexibility of the mobile agent paradigm compared to the client/server computing paradigm comes at additional costs. These costs include, among others, the additional complexity of developing and managing mobile agent-based applications. This additional complexity comprises such issues as reliability. Before mobile agent technology can appear at the core of tomorrow\u2019s business applications, reliability mechanisms for mobile agents must be established. In this context, fault tolerance and transaction support are mechanisms of considerable importance. Various approaches to fault tolerance and transaction support exist. They have different strengths and weaknesses, and address different environments. Because of this variety, it is often difficult for the application programmer to choose the approach best suited to an application. This thesis introduces a classification of current approaches to fault-tolerant and transactional mobile agent execution. The classification, which focuses on algorithmic aspects, aims at structuring the field of fault-tolerant and transactional mobile agent execution and facilitates an understanding of the properties and weaknesses of particular approaches. In a distributed system, any software or hardware component may be subject to failures. A single failing component (eg, agent or machine) may prevent the agent from\u00a0\u2026", "num_citations": "9\n", "authors": ["494"]}
{"title": "Security in the Telecommunications Information Networking Architecture-the CrySTINA Approach\n", "abstract": " We present the first results of the CrySTINA project. We analyze and structure the security problem domain in the TINA-C architecture and present our approach to provide the necessary security functionality in the form of self-contained application-independent security services and security mechanisms as part of the DPE functionality. The DPE is assumed to be basically provided by CORBA products. Therefore, we introduce the CORBA security specification and investigate if and how the identified TINA security services can be implemented using the CORBA security functionality.", "num_citations": "9\n", "authors": ["494"]}
{"title": "ParaRex: a programming environment integrating execution replay and visualization\n", "abstract": " ParaRex | Environments and tools for parallel scientific computing ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksEnvironments and tools for parallel scientific computingParaRex: a programming environment integrating execution replay and visualization chapter ParaRex: a programming environment integrating execution replay and visualization Share on Authors: Eric Leu profile image Eric Leu View Profile , Andr\u00e9 Schiper profile image Andr\u00e9 Schiper View Profile Authors Info & Affiliations Publication: Environments and tools for parallel scientific computingJanuary 1993 Pages 155\u2013169 2citation 0 Downloads Metrics Total 2 0 ! \u2026", "num_citations": "8\n", "authors": ["494"]}
{"title": "Efficient process replication for MPI applications: sharing work between replicas\n", "abstract": " With the increased failure rate expected in future extreme scale supercomputers, process replication might become a viable alternative to check pointing. By default, the workload efficiency of replication is limited to 50% because of the additional resources that have to be used to execute the replicas of the application's processes. In this paper, we introduce intra-parallelization, a solution that avoids replicating all computation by introducing work-sharing between replicas. We show on a representative set of benchmarks that intra-parallelization allows achieving more than 50% efficiency without compromising fault tolerance.", "num_citations": "7\n", "authors": ["494"]}
{"title": "Advances in the design and implementation of group communication middleware\n", "abstract": " Group communication is a programming abstraction that allows a distributed group of processes to provide a reliable service in spite of the possibility of failures within the group. The goal of the project was to improve the state of the art of group communication in several directions: protocol frameworks, group communication stacks, specification, verification and robustness. The paper discusses the results obtained.", "num_citations": "7\n", "authors": ["494"]}
{"title": "A paged-operating-system project\n", "abstract": " This paper describes a student project which is a major part of a senior level Operating Systems course at the Federal Institute of Technology in Lausanne. The project consists in conceiving and implementing an entire Operating System, where user jobs benefit from a simulated paged virtual memory on a DEC-LSI/11 based microprocessor. Students program in Portal, a modular high level language similar to Modula. The positive reactions we have obtained from our students center on satisfaction in having participated in defining specifications and having implemented an entire system themselves.", "num_citations": "7\n", "authors": ["494"]}
{"title": "Recovery algorithms for paxos-based state machine replication\n", "abstract": " In this article, we propose and evaluate three different state recovery algorithms aimed for Paxos---one of the most popular distributed agreement protocols. Paxos is commonly used to maintain consistency among state machine replicas despite of failures of processes. The first algorithm, that we call FullSS, originates from the original Paxos and requires that the system frequently uses stable storage during regular (non-faulty) execution. The other two state recovery algorithms, ViewSS and EpochSS, scarcely requite access to stable storage, and the recovering process must do much less work to restore its lost state, and to catch up on the current state of the system. We thoroughly analyze and compare the behavior of the three algorithms during state recovery and also during regular, non-faulty system execution, under various workloads (e.g., causing the network or CPU saturation). The experimental results show\u00a0\u2026", "num_citations": "6\n", "authors": ["494"]}
{"title": "On the performance of delegation over cache-coherent shared memory\n", "abstract": " Delegation is a thread synchronization technique where access to shared data is performed through a dedicated server thread. When a client thread requires shared data access, it makes a request to a server and waits for a response. This paper studies delegation implementation over cache-coherent shared memory, with the goal of optimizing it for high throughput. Whereas client-server communication naturally fits message-passing systems, efficient implementation over cache-coherent shared memory requires careful optimization. We demonstrate optimizations that significantly improve delegation performance on two modern x86 processors (the Intel Xeon Westmere and the AMD Opteron Magny-Cours), enabling us to come up with counter, stack and queue implementations that outperform the best known alternatives in a large number of cases. Our optimized delegation solution achieves 1.4 x (resp. 2x\u00a0\u2026", "num_citations": "6\n", "authors": ["494"]}
{"title": "High-throughput maps on message-passing manycore architectures: Partitioning versus replication\n", "abstract": " The advent of manycore architectures raises new scalability challenges for concurrent applications. Implementing scalable data structures is one of them. Several manycore architectures provide hardware message passing as a means to efficiently exchange data between cores. In this paper, we study the implementation of high-throughput concurrent maps in message-passing manycores. Partitioning and replication are the two approaches to achieve high throughput in a message-passing system. Our paper presents and compares different strongly-consistent map algorithms based on partitioning and replication. To assess the performance of these algorithms independently of architecture-specific features, we propose a communication model of message-passing manycores to express the throughput of each algorithm. The model is validated through experiments on a 36-core TILE-Gx8036 processor\u00a0\u2026", "num_citations": "6\n", "authors": ["494"]}
{"title": "Consistency in Distributed Systems (Dagstuhl Seminar 13081)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 13081\" Consistency in Distributed Systems.\"", "num_citations": "6\n", "authors": ["494"]}
{"title": "Structured derivation of semi-synchronous algorithms\n", "abstract": " The semi-synchronous model is an important middle ground between the synchronous and the asynchronous models of distributed computing. In this model, processes can detect (timeout) when other processes fail. However, since detection is done by timing out, it incurs a cost much higher than the typical delay of messages.               The paper presents a new communication primitive, Timely Announced Broadcast (TAB), and uses it in algorithms for consensus and set consensus in the semi-synchronous model. Separate implementations of TAB, withstanding different types of failures, allow to derive algorithms for consensus and set consensus under crash and omission failures.               The time bounds obtained by our algorithms asymptotically match, or improve, the previously known bounds.", "num_citations": "6\n", "authors": ["494"]}
{"title": "Timing analysis of leader-based and decentralized Byzantine consensus algorithms\n", "abstract": " We compare in an analytical way two leader-based and decentralized algorithms (that is, algorithms that do not use a leader) for Byzantine consensus with strong validity. We show that for the algorithms we analyzed, in most cases, the decentralized variant of the algorithm shows a better worstcase execution time. Moreover, for the practically relevant case t \u2264 2 (t is the maximum number of Byzantine processes), this worst-case execution time is even at least as good as the execution time of the leader-based algorithms in fault-free runs.", "num_citations": "6\n", "authors": ["494"]}
{"title": "Brief announcement: a leader-free byzantine consensus algorithm\n", "abstract": " We consider the consensus problem in a partially synchronous system with Byzantine faults. In a distributed system of n processes, where each process has an initial value, Byzantine consensus is the problem of agreeing on a common value, even though some of the processes may fail in arbitrary, even malicious, ways. It is shown in\u00a0[11] that \u2014 in a synchronous system \u2014 3t\u2009+\u20091 processes are needed to solve the Byzantine consensus problem without signatures, where t is the maximum number of Byzantine processes. In an asynchronous system, Fischer, Lynch and Peterson\u00a0[7] proved that no deterministic asynchronous consensus protocol can tolerate even a single non-Byzantine (= crash) failure. The problem can however be solved using randomization for benign and Byzantine faults. For Byzantine faults, Ben-Or\u00a0[2] and Rabin\u00a0[12] showed that this requires 5t\u2009+\u20091 processes. Later, Bracha\u00a0[3\u00a0\u2026", "num_citations": "6\n", "authors": ["494"]}
{"title": "Latency-aware leader election\n", "abstract": " Experimental studies have shown that electing a leader based on measurements of the underlying communication network can be beneficial. We use this approach to study the problem of electing a leader that is eventually not only correct (as captured by the \u03a9 failure detector abstraction), but also optimal with respect to the transmission delays to its peers. We give the definitions of this problem and a suitable model, thus allowing us to make an analytical analysis of the problem, which is in contrast to previous work on that topic.", "num_citations": "6\n", "authors": ["494"]}
{"title": "A predicate-based approach to dynamic protocol update in group communication\n", "abstract": " In this paper we study dynamic protocol updates (DPU), which consist in replacing, without interruption, a given protocol during execution. We focus especially on group communication protocols. The paper proposes a methodology to conveniently describe which protocols are correctly replaced by a given DPU algorithm. More precisely, our methodology characterizes DPU algorithms by a set of inference rules. To validate our approach, we illustrate our methodology with a new DPU algorithm.", "num_citations": "6\n", "authors": ["494"]}
{"title": "Comparing atomic broadcast algorithms in high latency networks\n", "abstract": " Since the introduction of the concept of failure detectors, several consensus and atomic broadcast algorithms based on these detectors have been published. The performance of these algorithms is often affected by a trade-off between the number of communication steps and the number of messages needed to reach a decision. Some algorithms reach decisions in few communication steps but require more messages to do so. Others save messages at the expense of an additional communication step to diffuse the decision to all processes in the system. This trade-off is heavily influenced by the network latency and the message processing times and therefore yields fundamentally different results in wide and local area networks.Performance evaluations of these algorithms, both in simulated or in real environments, have been published. These evaluations often consider a symmetrical setup: all processes are on the same network and have identical peer-to-peer latencies. In this paper, we model and evaluate the performance of three consensus and atomic broadcast algorithms using failure detectors in several wide area networks. We specifically focus on the case of a system with three processes, located in two or three different locations.", "num_citations": "6\n", "authors": ["494"]}
{"title": "On the inherent cost of Generic Broadcast\n", "abstract": " This short paper establishes lower bounds on the time complexity of algorithms solving the generic broadcast problem. The paper shows that (a) to deliver messages in one round, no failures can be tolerated,(b) to deliver messages in two rounds, at most f< n/3 failures can be tolerated, where n is the number of processes in the system, and (c) to deliver messages in three rounds, at most f< n/2 failures can be tolerated. The lower bounds are tight: a simple algorithm capable of delivering messages in one round if f= 0 is presented, and algorithms solving generic broadcast in two rounds when f< n/3 and in three rounds when f< n/2 are known in the literature. The paper also shows that even in runs in which messages do not conflict, generic broadcast cannot achieve the same performance of reliable broadcast algorithms.", "num_citations": "6\n", "authors": ["494"]}
{"title": "Practical impact of group communication theory\n", "abstract": " Group communication is nowadays a well established topic in distributed computing. It emerged over the years as a topic with a strong synergy between theory and practice: group communication is highly relevant for building distributed systems, and is also of theoretical importance, because of the difficult problems it addresses. The paper presents an - inevitably subjective - retrospective of the main milestones that led to our current understanding of group communication, with the focus on theoretical contributions of practical relevance. Some open issues are discussed at the end of the paper.", "num_citations": "6\n", "authors": ["494"]}
{"title": "Assessing the crash-failure assumption of group communication protocols\n", "abstract": " Designing and correctly implementing group communication systems (GCSs) is notoriously difficult. Assuming that processes fail only by crashing provides a powerful means to simplify the theoretical development of these systems. When making this assumption, however, one should not forget that clean crash failures provide only a coarse approximation of the effects that errors can have in distributed systems. Ignoring such a discrepancy can lead to complex GCS-based applications that pay a large price in terms of performance overhead yet fail to deliver the promised level of dependability. This paper provides a thorough study of error effects in real systems by demonstrating an error-injection-driven design methodology, where error injection is integrated in the core steps of the design process of a robust fault-tolerant system. The methodology is demonstrated for the Fortika toolkit, a Java-based GCS. Error\u00a0\u2026", "num_citations": "5\n", "authors": ["494"]}
{"title": "Dynamic update of distributed agreement protocols\n", "abstract": " In this paper, we address the problem of dynamic protocol update (DPU) that requires global coordination of local code replacements. We propose a novel approach to DPU. The key idea is the use of synchronization facilities of the services that get updated. This solution makes global update simple and efficient. We describe an experimental implementation of adaptable group communication middleware. It can switch between different distributed agreement protocols on-the-fly. All middleware services, including those that depend on the updated protocols, provide service correctly and with negligible delay while the global update takes places. The switching algorithm introduces very low overhead, that we illustrate by showing example measurement results.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Comparing the performance of two consensus algorithms with centralized and decentralized communication schemes\n", "abstract": " Protocols that solve agreement problems are essential building blocks for fault tolerant distributed systems. While many protocols have been published, little has been done to analyze their performance, especially the performance of their fault tolerance mechanisms. In this paper, we compare two consensus algorithms with different communication schemes: one is centralized and the other decentralized. The elements of the simulation study form a generic methodology for evaluating consensus algorithms. The results show that the centralized algorithm performs better in some environments, in spite of the fact that the decentralized algorithm finishes in fewer communication steps. The reason is that it generates less contention.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Halftoning through optimization of restored images: a new approach with hardware acceleration\n", "abstract": " We present a new approach to find a binary image reproducing a given continuous-tone image so that the picture printed out on a paper by a printer with limited number of ink colors looks as similar to the given one as possible. This process is called digital halftoning. The main contribution of this paper is to present a new approach for digital halftoning to generate binary images of best quality. Our basic strategy is well characterized as halftoning through optimization of restored image, that is, we minimize the difference between an input image and the image restored from an output binary image by applying a usual Gaussian filter. Algorithmically, our approach uses iterative exhaustive search on huge neighborhood combined with several acceleration techniques. The experimental results are fairly satisfactory: the resulting binary images are quite sharp and have no artifact. Since a simple iterative exhaustive search needs a lot of computing time, we have developed the FPGA-based co-processor for acceleration. Using the co-processor, artifact-free sharp binary images can be obtained in practical computing time.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Execution atomicity for non-blocking transactional mobile agents\n", "abstract": " In the context of e-commerce, execution atomicity is an important property for mobile agents. A mobile agent executes atomically, if either all its operations succeed, or none at all. This requires to solve an instance of the atomic commitment problem. However, it is important that failures (eg, of machines or agents) do not lead to blocking of transactional mobile agents, ie, agents that execute as a transaction. In this paper, we give a novel specification of non-blocking atomic commitment in the context of mobile agent execution. We then show how transactional mobile agent execution can be built on top of earlier work on faulttolerant mobile agent execution and give preliminary performance results.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Replicated Invocation\n", "abstract": " In today\u2019s systems, application are composed from various components that may be located on different machines. The components may have to collaborate in order to service a client request. More specifically, a client request to one component may trigger a request to another component. Moreover, to ensure fault-tolerance, components are generally replicated. This poses the problem of a replicated server invoking another replicated server. We call it the problem of replicated invocation.Replicated invocation has been considered in the context of deterministic servers. However, the problem is more difficult to address when servers are non-deterministic. In this context, work has been done to enforce deterministic execution. In the paper we consider a different approach. Instead of preventing non-deterministic execution of servers, we discuss how to handle it. The paper first discusses the problem of non-deterministic replicated invocation. Then the paper proposes a different solution to solve these problems.", "num_citations": "5\n", "authors": ["494"]}
{"title": "TranSuMA: Non-blocking transaction support for mobile agent execution\n", "abstract": " In the context of e-commerce, execution atomicity is an important property for mobile agents. A mobile agent executes atomically, if either all its operations succeed, or none at all. Assume, for instance, a mobile agent that books a flight and rents a hotel room at the destination. The hotel room is of no use if no flight is available. Consequently, either both operations need to succeed or none at all. Transactional mobile agents ensure execution atomicity on their entire execution. This requires to solve an instance of the atomic commitment problem. However, in the context of transactional mobile agent execution it is important that failures (eg, of machines or agents) do not lead to blocking of the mobile agent execution. Blocking occurs, if the mobile agent execution cannot proceed because of a single failure. In this paper, we specify non-blocking atomic commitment in the context of mobile agent execution. We then show how transactional mobile agent execution can be built on top of earlier work on fault-tolerant mobile agent execution. Our implementation is the first implementation of nonblocking transactional mobile agents. Its performance evaluation shows that the overhead introduced by the transaction mechanisms is reasonable.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Contention-aware metrics: Analysis of distributed algorithms\n", "abstract": " Resource contention is widely recognized as having a major impact on the performance of distributed algorithms. Nevertheless, the metrics that are commonly used to predict their performance take little or no account of contention. In this paper, we define two performance metrics for distributed algorithms that account for network contention as well as CPU contention. We then illustrate the use of these metrics by comparing four Atomic Broadcast algorithms, and show that our metrics allow for a deeper understanding of performance issues than conventional metrics.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Total order multicast to multiple groups\n", "abstract": " We present a fault-tolerant algorithm which ensures global total order delivery of messages sent to multiple groups of processes. Our algorithm is a multiple group\\genuine\" multicast algorithm in the sense that (1) any process can send a message to any set of process groups, and (2) only the sender and the receivers of a message take part in the algorithm needed to deliver the message. The correctness of our algorithm does not require reliable failure detectors, but requires causal order delivery of messages. This establishes an interesting link between causal order delivery and fault-tolerance with unreliable failure detectors.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Efficient implementation of rendezvous\n", "abstract": " In this paper we present a simple and efficient implementation of the rendezvous developed for a small multiprocessor system (6\u201310 processors). At first, we present the communication primitives with their traditional implementation. Secondly, we discuss in details our implementation and the communication architecture needed. We conclude with an evaluation showing that our implementation needs a maximum of four context switches to realize a rendezvous, which can be considered as an ideal result.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Concurrent programming\n", "abstract": " Concurrent programming solves problems of the sort where several simultaneous activities compete for limited resources. This book is an accessible introduction to the theory and practice of concurrent programming. Exposition is supported by realistic examples. Techniques developed include locks, semaphores, monitors, and rendezvous. Three languages especially adapted to concurrent programming-Portal, Modula-2, Ada-are used throughout, and their relative advantages and disadvantages discussed. It contains a program for a substantial problem, the control of a digital clock and chronometer, which is developed in full detail in each of the three languages.", "num_citations": "5\n", "authors": ["494"]}
{"title": "Tolerating permanent and transient value faults\n", "abstract": " Transmission faults allow us to reason about permanent and transient value faults in a uniform way. However, all existing solutions to consensus in this model are either in the synchronous system, or require strong conditions for termination, that exclude the case where all messages of a process can be corrupted. In this paper we introduce eventual consistency in order to overcome this limitation. Eventual consistency denotes the existence of rounds in which processes receive the same set of messages. We show how eventually consistent rounds can be simulated from eventually synchronous rounds, and how eventually consistent rounds can be used to solve consensus. Depending on the nature and number of permanent and transient transmission faults, we obtain different conditions on , the number of processes, in order to solve consensus in our weak model.", "num_citations": "4\n", "authors": ["494"]}
{"title": "Relaxed atomic broadcast: State-machine replication using bounded memory\n", "abstract": " Atomic broadcast is a useful abstraction for implementing fault-tolerant distributed applications such as state-machine replication. Although a number of algorithms solving atomic broadcast have been published, the problem of bounding the memory used by these algorithms has not been given the attention it deserves. It is indeed impossible to solve repeated atomic broadcast with bounded memory in a system (non-synchronous or not equipped with a perfect failure detector) in which consensus is solvable with bounded memory. The intuition behind this impossibility is the inability to safely garbage-collect unacknowledged messages, since a sender process cannot tell whether the destination process has crashed or is just slow.The usual technique to cope with this problem is to introduce a membership service, allowing the exclusion of a slow or silent process from the group and safely discarding unacknowledged\u00a0\u2026", "num_citations": "4\n", "authors": ["494"]}
{"title": "Atomic broadcast: a fault-tolerant token based algorithm and performance evaluations\n", "abstract": " Within only a couple of generations, the so-called digital revolution has taken the world by storm: today, almost all human beings interact, directly or indirectly, at some point in their life, with a computer system. Computers are present on our desks, computer systems control the antilock braking system and the stability control in cars, they collect usage statistics in elevators in order to anticipate maintenance and repair operations. Computer systems also operate critical systems, such as nuclear power plants, airplane control systems or space rockets. Furthermore, computer systems are not only omnipresent, but also increasingly networked. As the use of computer systems has increased dramatically over the past decades, the needs and expectations associated with these systems have also increased. In particular, one of the critical points of a system is its availability (the fraction of the time during which the system\u00a0\u2026", "num_citations": "4\n", "authors": ["494"]}
{"title": "Brief announcement: dynamic group communication\n", "abstract": " Fault-tolerance in distributed systems is traditionally ensured by replication, which can be implemented on top of a group communication infrastructure. Group communication is well understood in the context of a static system, in which all processes are created at the start of the computation [2]. A static system has. practical limitations, which has led to consider dynamic systems. However, despite the recent good review by Chockler et aL [1], dynamic group communication has not yet reached the level of maturity of static group communication. For example, view synchrony (in a dynamic system) provides guarantees somehow similar to reliable broadcast (in a static system). However, the specifications are very different: we have on one hand side a simple specification for reliable broadcast, and on the other side a complex specification for view synchrony. The same comment applies to the specification of atomic\u00a0\u2026", "num_citations": "4\n", "authors": ["494"]}
{"title": "Comparison of failure detectors and group membership: Performance study of two atomic broadcast algorithms (extended version)\n", "abstract": " Protocols that solve agreement problems are essential building blocks for fault tolerant distributed systems. While many protocols have been published, little has been done to analyze their performance, especially the performance of their fault tolerance mechanisms. In this paper, we present a performance evaluation methodology that can be generalized to analyze many kinds of fault-tolerant algorithms. We use the methodology to compare two atomic broadcast algorithms with different fault tolerance mechanisms: unreliable failure detectors and group membership. We evaluated the steady state latency in (1) runs with neither crashes nor suspicions,(2) runs with crashes and (3) runs with no crashes in which correct processes are wrongly suspected to have crashed, as well as (4) the transient latency after a crash. We found that the two algorithms have the same performance in Scenario 1, and that the group membership based algorithm has an advantage in terms of performance and resiliency in Scenario 2, whereas the failure detector based algorithm offers better performance in the other scenarios. We discuss the implications of our results to the design of fault tolerant distributed systems.", "num_citations": "4\n", "authors": ["494"]}
{"title": "Using Optimistic Atomic Broadcast in Transaction Processing Systems\u2217\n", "abstract": " Atomic broadcast primitives are often proposed as a mechanism to allow fault-tolerant cooperation between sites in a distributed system. Unfortunately, the delay incurred before a message can be delivered makes it difficult to implement high performance, scalable applications on top of atomic broadcast primitives. Recently, a new approach has been proposed for atomic broadcast which, based on optimistic assumptions about the communication system, reduces the average delay for message delivery to the application. In this paper, we develop this idea further and show how applications can take even more advantage of the optimistic assumption by overlapping the coordination phase of the atomic broadcast algorithm with the processing of delivered messages. In particular, we present a replicated database architecture that employs the new atomic broadcast primitive in such a way that communication and transaction processing are fully overlapped, providing high performance without relaxing transaction correctness.\u2217 A preliminary version of this paper appeared in [16]. In this paper we provide a more comprehensive protocol and study the performance through simulation. 1 1", "num_citations": "4\n", "authors": ["494"]}
{"title": "Genuine atomic multicast in asynchronous systems\n", "abstract": " Genuine Atomic Multicast in Asynchronous Systems - Infoscience English Fran\u00e7ais login Home > Genuine Atomic Multicast in Asynchronous Systems Infoscience Information Usage statistics Files Genuine Atomic Multicast in Asynchronous Systems Guerraoui, R. ; Schiper, A. Year: 1998 Laboratories: LSR Record appears in: Scientific production and competences > Archives > I&C - School of Computer and Communication Sciences > LSR - Distributed Systems Laboratory Work produced at EPFL Technical Reports Published Note: The status of this file is: Anyone n/a: GS98b - PS; Export as: BibTeX | MARC | MARCXML | DC | EndNote | NLM | RefWorks | RIS View as: MARC | MARCXML | DC Add to your basket: Back to search Record created 2005-05-20, last modified 2020-01-23 n/a: Download fulltext PS Rate this document: 1 2 3 4 5 (Not yet reviewed) Add to personal basket Export as BibTeX, MARC, MARCXML, , -\u2026", "num_citations": "4\n", "authors": ["494"]}
{"title": "Atomic Multicast harder than Atomic Broadcast\n", "abstract": " Atomic broadcast and atomic multicast are communication primitives which ensure that processes agree on the sequence of messages they deliver. Whereas atomic broadcast is used to send messages to the set of all the processes in the system, atomic multicast sends messages to speci c subsets of processes. We say that an atomic multicast algorithm is\\genuine\", if only the sender and the destination processes of a message take part in the protocol needed to deliver the message. We formally de ne the genuine atomic multicast problem, and we show that this problem turns out to be harder than the atomic broadcast problem. Whereas atomic broadcast can be solved with unreliable failure detectors that can make false failure suspicions, we show that atomic multicast cannot.", "num_citations": "4\n", "authors": ["494"]}
{"title": "View synchronous communication in the internet\n", "abstract": " View synchronoxs communication (\\JSC) is a raradism iritially poPosed by the Isis sr-stern, lhat is* ell sxit. d to implenerl faulr-t\u00f4I.. a\u00f9t serrices b\u00c0sed or replication VSC can be seen as an adequare loq level scm\u00e2ntics on\\t, ih orde. ed mullicalls \u00e2Dd \u00f9niforn m\u00f9llrc\u00e2sls can. \u00e6ill be irnplemented. This paper presents rhe sPecific problems related to the impienrertation of VSC in awidca. ea ner $ ork (.. g. I\u00f9ternet) lhe paper also shons how these problems arc solred wjrhi! Phoerir. a gro\u00f9! orielied rlarfo. n under delclopmenr Specilicalll the Phocnix implelnenrari\u00f4\u00f9 of| SC allo $ s rrogr. ss in. a-\" es wh. rc t. aditional solution! wo! ld not", "num_citations": "4\n", "authors": ["494"]}
{"title": "Causal approaches to concurrency control in distributed and replicated database systems\n", "abstract": " Causal approaches to concurrency control in distributed and replicated database systems - Infoscience English Fran\u00e7ais login Home > Causal approaches to concurrency control in distributed and replicated database systems Infoscience Information Usage statistics Files Causal approaches to concurrency control in distributed and replicated database systems Sandoz, Alain ; Schiper, Andr\u00e9 Advisor(s): Schiper, Andr\u00e9 Year: 1992 Publisher: Lausanne, EPFL DOI: 10.5075/epfl-thesis-1036 Laboratories: LSR Record appears in: Scientific production and competences > Archives > I&C - School of Computer and Communication Sciences > LSR - Distributed Systems Laboratory Scientific production and competences > EPFL Theses Work produced at EPFL Published Theses Note: The status of this file is: EPFL only Texte int\u00e9gral / Full text: EPFL_TH1036 - PDF; Export as: BibTeX | MARC | MARCXML | DC | EndNote | | | as\u2026", "num_citations": "4\n", "authors": ["494"]}
{"title": "Techniques de d\u00e9verminage pour programmes parall\u00e8les\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "4\n", "authors": ["494"]}
{"title": "Modular approach to replication for availability\n", "abstract": " In this chapter, we show a modular, layered way to implement replication. This will lead us to introduce notions such as group communication primitives (atomic broadcast, generic broadcast), the consensus problem, failure detectors, and the round based model, and will allow us to better understand the challenges that underly the implementation of replication techniques. The chapter considers only benign faults.", "num_citations": "3\n", "authors": ["494"]}
{"title": "Consensus in Wireless Ad hoc Networks\n", "abstract": " Solving consensus in wireless ad hoc networks has started to be addressed in several papers. Most of these papers adopt system models similar to those developed for wired networks. These models are focused towards node failures while ignoring link failures, and thus are poorly suited for wireless ad hoc networks. The HO model, which was proposed recently, does not have this drawback. The paper shows that an existing algorithm and the HO model can be used for multi-hop wireless ad hoc networks, if extended with an adequate communication layer. The description of the communication layer is augmented with simulation results that validate the feasibility of our approach and provide better understanding of the behavior of realistic wireless environments.", "num_citations": "3\n", "authors": ["494"]}
{"title": "Brief announcement: on the inherent cost of generic broadcast\n", "abstract": " The paper establishes lower bounds on the time complexity of algorithms solving the generic broadcast problem. Generic broadcast assumes a symmetric, non-reflexive conflict relation on the set of messages, and requires ordered delivery only for conflicting messages [2]. If messages m and m conflict, processes are required to deliver them in the same order; if they do not conflict, some process may deliver m and then m, and some other process may deliver m and then m. The conflict relation is defined by the application. For example, in a system in which read and write messages are broadcast to replicated processes, read messages do not conflict with each other, and so, do not have to be delivered in the same order. Formally, generic broadcast satisfies the following properties:(a) if a correct process p broadcasts a message m, then p eventually delivers m (validity);(b) if a correct process p delivers a message m\u00a0\u2026", "num_citations": "3\n", "authors": ["494"]}
{"title": "Weak ordering oracles for failure detection-free systems\n", "abstract": " Agreement abstractions, such as consensus, atomic broadcast, and generic broadcast [2], are important building blocks in distributed systems subject to processor failures. Atomic broadcast, for example, has been used to build many fault-tolerant systems, such as highly-available databases. Atomic broadcast guarantees that if a message is broadcast to a group of processors and one of these processors delivers the message, then all processors also deliver the message\u2014a property known as agreement; and if two processors deliver the same two messages, they do so in the same order\u2014a property known as total order.Asynchronous systems. A protocol implementation is as general as the underlying assumptions about its system model. In this sense, the asynchronous model of computation is a very general way to formalize distributed systems. It basically makes no assumptions about the time it takes to transmit messages over network links and for processors to perform their computations. The asynchronous model is very appealing as any solution that can be applied in it can also be applied in a stronger model (eg, the synchronous model, where processors can estimate the time it takes for other processors to execute their programs). Nevertheless, one fundamental result about distributed systems subject to processor failures states that atomic broadcast cannot be solved in a pure asynchronous model. The basic reason stems from the fact that in pure asynchronous systems, proces-", "num_citations": "3\n", "authors": ["494"]}
{"title": "Duplex: A Distributed Collaborative Editing Environment in Large Scale\n", "abstract": " Duplex: A Distributed Collaborative Editing Environment in Large Scale - Infoscience English Fran\u00e7ais login Home > Duplex: A Distributed Collaborative Editing Environment in Large Scale Infoscience Information Usage statistics Files Duplex: A Distributed Collaborative Editing Environment in Large Scale Sandoz, A. ; Pacull, F. ; Schiper, A. Year: 1994 Laboratories: LSR Record appears in: Scientific production and competences > Archives > I&C - School of Computer and Communication Sciences > LSR - Distributed Systems Laboratory Work produced at EPFL Technical Reports Published Export as: BibTeX | MARC | MARCXML | DC | EndNote | NLM | RefWorks | RIS View as: MARC | MARCXML | DC Add to your basket: Back to search Record created 2005-05-20, last modified 2020-01-23 Rate this document: 1 2 3 4 5 (Not yet reviewed) Add to personal basket Export as BibTeX, MARC, MARCXML, DC, EndNote, , -\u2026", "num_citations": "3\n", "authors": ["494"]}
{"title": "On the granularity of events when modeling program executions\n", "abstract": " In the context of parallel and distributed programming, program execution models are required to obtain a better understanding of the behavior, properties, and characteristics of parallel and distributed applications. One commonly adopted approach consists of representing an execution as a set of events and relations that capture the ordering of the events. The main disadvantages of most existing models are (1) the gap between the user's view of the execution and the program execution model, and (2) their inability to uniquely characterize an execution in terms of program behavior. The goal of this paper is to solve these two problems by first defining a new program execution model that enables more coarse-grained events to be considered, and then determining sufficient conditions for the model to uniquely identify the sequence of local states each process goes through.< >", "num_citations": "3\n", "authors": ["494"]}
{"title": "The impact of mobility on the time complexity for deterministic broadcasting in radio networks\n", "abstract": " We study the time complexity for deterministic broadcasting algorithms in mobile radio networks. The broadcast operation consists of a source node successfully communicating its message to every other node. In multi-hop radio networks such as MANETs, the message may traverse multiple other nodes. Nodes have no prior knowledge besides the number n of nodes in the network and its diameter D. The problem we address has been extensively studied for static networks. Our work quantifies the impact of mobility. We consider three families of graphs: undirected graphs of constant contention degree, undirected graphs of non-constant contention degree and directed graphs of non-constant contention degree. We prove the lower bounds of \u03a9(n log n) time slots for the first family, \u03a9(n\u00b2/D\u00b2 log D + D) time slots for the second and \u03a9(n\u00b2/D\u00b2 log D + n log D) for the third. At the time of writing, the corresponding tightest\u00a0\u2026", "num_citations": "2\n", "authors": ["494"]}
{"title": "From object replication to database replication\n", "abstract": " This chapter reviews past research on database replication based on group communication. It initially recalls consistency criteria for object replication, compares them to serializability, a typical consistency criterion for databases, and presents a functional model to reason about replication protocols in general. Within this framework, deferred update replication is explained. We consider two instances of deferred update replication, one relying on atomic commit and the other relying on atomic broadcast. In this context, we show how group communication can simplify the design of database replication protocols and improve their availability and performance by reducing the abort rate.", "num_citations": "2\n", "authors": ["494"]}
{"title": "An automatic real-time analysis of the time to reach consensus\n", "abstract": " Consensus is one of the most fundamental problems in fault-tolerant distributed computing. This paper proposes a mechanical method for analyzing the condition that allows one to solve consensus. Specifically, we model check a distributed algorithm that implements a communication predicate, which is an alternative system abstraction to failure detectors. This model checking problem is challenging because it involves both continuous time and unbounded integers. We solve the problem by reducing it to the satisfiability problem of linear arithmetic constraints over real and integer variables. The proposed method can be used to determine the length of a synchronous period required for implementing a communication predicate for solving consensus.", "num_citations": "2\n", "authors": ["494"]}
{"title": "On properties of the group membership problem\n", "abstract": " We study fault tolerance properties of the group membership problem (GMP) in asynchronous systems. This problem requires each process to determine the processes with which it can communicate. We compare the properties of the GMP and consensus. We define failure sensitivity as the necessary property of a failure detector to enable a solution to the GMP. We demonstrate that the known consensus failure detectors\u2014\u2126, \u03a3, \u03a3\u03bd are fault insensitive and thus insufficient to solve the GMP. In contrast we define a new reachability failure detector R and show it to be the weakest failure detector to solve the GMP. Furthermore, we demonstrate that R implements the consensus failure detectors. This shows that the GMP is a strictly stronger problem than consensus with respect to the failure detectors that it requires. We present our findings using the primary partition variant of the GMP. We extend them to the partitionable GMP as well as eventual GMP: a weaker variant of the GMP where a process is allowed to make finitely many mistakes in its group membership output.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Consensus problem in wireless ad hoc networks: Addressing the right issues\n", "abstract": " Solving consensus in wireless ad hoc networks has started to be addressed in several papers. Most of these papers adopt system models developed for wired networks. These models are focused towards node failures while ignoring link failures, and thus are poorly suited for wireless ad hoc networks. The HO model, which was proposed recently, does not have this drawback. The paper shows that an existing algorithm and the HO model can be used for multi-hop wireless ad hoc networks, if extended with an adequate \u201cimplementation\u201d. The meaning of \u201cimplementation\u201d will become clear from the paper. The description of the \u201cimplementation\u201d is augmented with simulation results that validate the feasibility of our approach and provide better understanding of the behavior of realistic wireless environments.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Towards Reliable Communication and Agreement in Mobile Ad-hoc Networks: Algorithms, Simulation and Testbed\n", "abstract": " During the last decade, the number of wireless devices like digital organizers, mobile phones and laptop computers has drastically increased. At the same time, several technologies, like Bluetooth, GPRS, or WiFi have become mature and offer a high-performance wireless infrastructure to mobile users. However, there exist still many non-equipped areas where no infrastructure is available. For example, during emergency operations, rescuers may want to deploy temporarily an autonomous (or ad-hoc) network. Under these settings, mobile devices (or nodes) operate in a self-organized manner and can only communicate with their immediate wireless neighbors. To send a packet to a remote destination, a node relies on the routing capabilities of the other nodes. In a mobile ad-hoc network (MANET), problems are inherently more complicated to solve than in a regular wired network because of the dynamic topology\u00a0\u2026", "num_citations": "2\n", "authors": ["494"]}
{"title": "Drift: Efficient message ordering in ad hoc networks using virtual flooding\n", "abstract": " We present DRIFT - a total order multicast algorithm for ad hoc networks with mobile or static nodes. Due to the ad hoc nature of the network, DRIFT uses flooding for message propagation. The key idea of DRIFT is virtual flooding - a way of using unrelated message streams to propagate message causality information in order to accelerate message delivery. We describe DRIFT in detail. We evaluate its performance in a simulator and in a wireless sensor network. In both cases our results demonstrate that the performance of DRIFT exceeds that of the simple total order multicast algorithm designed for wired networks, on which it is based. In simulation at scale, for certain experiment settings, DRIFT achieved speedup of several orders of magnitude", "num_citations": "2\n", "authors": ["494"]}
{"title": "Physikalische Phanomene von Abloseblasen an einer abgerundeten zuruckspringenden Stufe\n", "abstract": " Reported are some results of a study on the local separated flows around a rounded backward facing step. Experiments were carried out in a water tunnel (WSG) with outstanding inflow qualities. Flow visualizations using hydrogen bubble along with laser sheet lighted particles were applied. The Reynolds numbers for the present results are from 8x10     3     to 1x10     5     based on the length L     p     of the front flat plate and incoming flow velocity. Velocity measurements were performed with video-based particle image velocimetry (PIV) at sampling frequency of 25 Hz. Evaluation on both flow visualization and PIV data reveal that the local separated region is dominated by dynamic vortex systems with strong periodic features. The separation exhibits an open bubble type in topology with intense interaction with outer flow. Also discussed are the wave like development of vortices in the sense of deformation as well as the resulted \u039b-formed coherent structures.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Lower bounds on generic broadcast algorithms\n", "abstract": " This short paper establishes lower bounds on the time complexity of algorithms solving the generic broadcast problem. The paper shows that (a) to deliver messages in one round, no failures can be tolerated,(b) to deliver messages in two rounds, at most f< n/3 failures can be tolerated, where n is the number of processes in the system, and (c) to deliver messages in three rounds, at most f< n/2 failures can be tolerated. The lower bounds are tight: a simple algorithm capable of delivering messages in one round if f= 0 is presented, and algorithms solving generic broadcast in two rounds when f< n/3 and in three rounds when f< n/2 are known in the literature. The paper also shows that even in runs in which messages do not conflict, generic broadcast cannot achieve the same performance of reliable broadcast algorithms.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Revisiting token-based atomic broadcast algorithms\n", "abstract": " Many atomic broadcast algorithms have been published in the last twenty years. Token-based algorithms represent a large class of these algorithms. Interestingly all the token-based atomic broadcast algorithms rely on a group membership service, ie, none of them uses failure detectors. The paper presents the first token-based atomic broadcast algorithm that uses an unreliable failure detector\u2013the new failure detector denoted by R\u2013instead of a group membership service. The failure detector R is compared with\u2666 P and\u2666 S. In order to make it easier to understand the atomic broadcast algorithm, the paper derives the atomic broadcast algorithm from a token-based consensus algorithm that also uses the failure detector R.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Comparaison de machines virtuelles Java pour PDA\n", "abstract": " Comparaison de machines virtuelles Java pour PDA - Infoscience English Fran\u00e7ais login Home > Comparaison de machines virtuelles Java pour PDA Infoscience Information Usage statistics Files Comparaison de machines virtuelles Java pour PDA Mayor, David Year: 2002 Note: \u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne Laboratories: LSR Record appears in: Scientific production and competences > Archives > I&C - School of Computer and Communication Sciences > LSR - Distributed Systems Laboratory Work produced at EPFL Technical Reports Export as: BibTeX | MARC | MARCXML | DC | EndNote | NLM | RefWorks | RIS View as: MARC | MARCXML | DC Add to your basket: Back to search Record created 2005-05-20, last modified 2020-07-30 Rate this document: 1 2 3 4 5 (Not yet reviewed) Add to personal basket Export as BibTeX, MARC, MARCXML, DC, EndNote, NLM, RefWorks About Infoscience | | | -\u2026", "num_citations": "2\n", "authors": ["494"]}
{"title": "Agreement-related problems\n", "abstract": " Agreement problems constitute a fundamental class of problems in the context of distributed systems. All agreement problems follow a common pattern: all processes must agree on some common decision, the nature of which depends on the specific problem. This dissertation mainly focuses on three important agreements problems: Replication, Total Order Broadcast, and Consensus.Replication is a common means to introduce redundancy in a system, in order to improve its availability. A replicated server is a server that is composed of multiple copies so that, if one copy fails, the other copies can still provide the service. Each copy of the server is called a replica. The replicas must all evolve in manner that is consistent with the other replicas. Hence, updating the replicated server requires that every replica agrees on the set of modifications to carry over. There are two principal replication schemes to ensure this consistency: active replication and passive replication.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Stubborn Communication Channels\n", "abstract": " This paper aims at bridging the gap between the assumption of reliable channels by fault-tolerant distributed algorithms and the weak reliability of feasible communication channels. We de ne a new kind of communication channels which we call Stubborn channels. Stubborn channels are easily implementable over a connectionless network layer and, although weak, the reliability guarantees o ered by Stubborn channels are su cient to solve the fundamental Consensus problem in asynchronous systems with unreliable failure detectors.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Concepts et m\u00e9canismes pour la mise en oeuvre d'un environnement d'\u00e9dition coop\u00e9rative sur un r\u00e9seau \u00e0 grande \u00e9chelle\n", "abstract": " Dans ce travail de th ese nous abordons un aspect de l'edition coop erative peu explor e jusqu'a pr esent: la consid eration des limitations impos ees par un r eseau a grande echelle (typiquement Internet). Ce mod ele de syst eme implique l'h et erog en eit e des machines, des d elais de communication non born es et des pannes. Dans ce contexte, les techniques traditionnelles utilis ees pour l'edition coop erative dans un r eseau local sont inadapt ees.Le mod ele propos e dans cette th ese est bas e sur une d ecomposition dynamique du document en parties ind ependantes, maintenues individuellement par un noyau dupliqu e. La d ecomposition est contr^ ol ee par les utilisateurs eux-m^ emes, qui peuvent ainsi agir sur la concurrence autoris ee au niveau du document. Plus un document est fragment e, plus la concurrence potentielle est grande. La duplication des parties ind ependantes au sein d'un noyau partag e permet d'assurer la disponibilit e du document aux utilisateurs, et ce ind ependamment des performances des sites utilisateurs. Les communications sont r eduites au minimum, autorisant une utilisation a large echelle. Les utilisateurs interagissent avec le noyau soit en r ecup erant une copie locale d'un objet du noyau qu'ils peuvent modi er a loisir dans leur environnement local, soit au contraire en transmettant au niveau du noyau une copie locale. La gestion de la coh erence se faisant a ce moment la suivant plusieurs politiques que l'utilisateur peut choisir en fonction de la maturit e du document ou encore des autres utilisateurs.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Weak consistency and pessimistic replica control\n", "abstract": " In distributed systems replication is used to enhance availability and performance. Concurrent access to copies on different sites must be synchronized so transactions remain serializable. The main difficulty is the possibility of a partition of the network due to site or communication failures. Several protocols have been designed to synchronize transactions running in different components. Most pessimistic algorithms restrict access to a unique component per object and impose mutual consistency of copies. In this paper we show that this is not necessary for pessimistic control. We present a forwarding strategy for missing updates and a method to globally order conflicting transactions in a partitioned system. This enables consistent views of objects in minority components, logical conflicts in different components and one-copy serializability. We present an algorithm based on these ideas which achieves higher\u00a0\u2026", "num_citations": "2\n", "authors": ["494"]}
{"title": "Traps using the COUNT attribute in the readers-writers problem\n", "abstract": " The solutions to the different variants of the readers-writers problem s (readers priority, writers priority,...) have been widely published and commented in the Ada literature. So it is quite surprising to observe that all the solutions to the writers priority problem are flawed. This is illustrated in section 2. Note that solutions to the readers priority problem escaped the flaw du e to the asymmetrical role of the readers and writers.Independently of above, the Ada literature generally points out the danger of using the COUNT attribute. One should be very careful using the COUNT attribute in a guard of a select statement, since a cancelled rendezvous will not be detected. So deeper analysis is needed to produce solutions robust to possible cancellation of rendezvous. The solutions published unnecessarily dismiss the COUNT attribute, although correct use of it leads to simpler soludons. This point is developed in section 3.", "num_citations": "2\n", "authors": ["494"]}
{"title": "Two-level control structure for parallel heuristic programming\n", "abstract": " The nondeterministic analysis of a problem consists of reducing its solution to the solution of any one of a group of subproblems. It therefore differs from other forms of analysis which require that all subproblems introduced to be solved. The implementation of these two forms of analysis produces an and/or tree of processes, each of which solves a subproblem. Many linguistic expressions for this type of tree have been proposed, such as those which use operators expressing parallelism and choice. This article deals with the implementation of a process tree of this kind: for a given number of processors, process allocation strategies which satisfy certain optimising properties are defined. The technique proposed, which consists of defining and evaluating priorities dynamically, is based on methods for computing the form of tree attributes. 13 references.", "num_citations": "2\n", "authors": ["494"]}
{"title": "S-Paxos: Offloading the leader for high throughput state machine replication\n", "abstract": " Implementations of state machine replication are prevalently using variants of Paxos or other leader-based protocols. Typically these protocols are also leader-centric, in the sense that the leader performs more work than the non-leader replicas. Such protocols scale poorly, because as the number of replicas or the load on the system increases, the leader replica quickly reaches the limits of one of its resources. In this paper we show that much of the work performed by the leader in a leadercentric protocol can in fact be evenly distributed among all the replicas, thereby leaving the leader only with minimal additional workload. This is done (i) by distributing the work of handling client communication among all replicas,(ii) by disseminating client requests among replicas in a distributed fashion, and (iii) by executing the ordering protocol on ids. We derive a variant of Paxos incorporating these ideas. Compared to leader-centric protocols, our protocol not only achieves significantly higher throughput for any given number of replicas, but also increases its throughput with the number of replicas.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Swift Algorithms for Repeated Consensus\n", "abstract": " We introduce the notion of a swift algorithm. Informally, an algorithm that solves the repeated consensus is swift if, in a partial synchronous run of this algorithm, eventually no timeout expires, i.e., the algorithm execution proceeds with the actual speed of the system. This definition differs from other efficiency criteria for partial synchronous systems. Furthermore, we show that the notion of swiftness explains why failure detector based algorithms are typically more efficient than round-based algorithms, since the former are naturally swift while the latter are naturally non-swift. We show that this is not an inherent difference between the models, and provide a round implementation that is swift, therefore performing similarly to failure detector algorithms while maintaining the advantages of the round model.", "num_citations": "1\n", "authors": ["494"]}
{"title": "On the cost of modularity in atomic broadcast\n", "abstract": " Modularity is a desirable property of complex software systems, since it simplifies code reuse, verification, maintenance, etc. However, the use of loosely coupled modules introduces a performance overhead. This overhead is often considered negligible, but this is not always the case. This paper aims at casting some light on the cost, in terms of performance, that is incurred when designing a relevant group communication protocol with modularity in mind: atomic broadcast. We conduct our experiments using two versions of atomic broadcast: a modular version and a monolithic one. We then measure the performance of both implementations under different system loads. Our results show that the overhead introduced by modularity is strongly related to the level of stress to which the system is subjected, and in the worst cases, reaches approximately 50%.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Experimental evaluation of DRIFT: Total message ordering in ad hoc networks\n", "abstract": " We present DRIFT1, a total ordering multicast algorithm optimized for ad hoc networks. DRIFT combines virtual flooding with a communication history ordering algorithm. Virtual flooding is a way of using unrelated message streams to propagate message causality information in order to accelerate message delivery. We review the total order multicast problem and the unique challenges posed in ad hoc networks. We describe DRIFT and its use of virtual flooding in detail. We provide optimizations for implementation. We implement DRIFT on a wireless sensor network. For comparison, we implement the communication history ordering algorithm, TOF, on which DRIFT is based. Both require that all messages be received by all nodes, we implement a reliable local broadcast scheme to achieve reliable message transmission. We evaluate DRIFT\u2019s performance through experimentation and simulation. We employ wireless channel emulation as well as radio transmission in our experimental approach. We study the effects of varying the relative rate at which messages are multicast using both physically flooded messages and nonflooded messages as carriers of the virtual flood. We examine the impact of varying the period of non-flooded messages. From our wireless transmission experiments we find DRIFT delivers multicast messages twice as fast as TOF using only physically flooded messages as carriers. DRIFT achieves a sixfold speedup when periodic non-flooded messages act as carriers in addition to the physically flooded messages.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Protocol composition frameworks and modular group communication\n", "abstract": " It is noticeable that our society is increasingly relying on computer systems. Nowadays, computer networks can be found at places where it would have been unthinkable a few decades ago, supporting in some cases critical applications on which human lives may depend. Although this growing reliance on networked systems is generally perceived as technological progress, one should bear in mind that such systems are constantly growing in size and complexity, to such an extent that assuring their correct operation is sometimes a challenging task. Hence, dependability of distributed systems has become a crucial issue, and is responsible for an important body of research over the last years.No matter how much effort we put on ensuring our distributed system\u2019s correctness, we will be unable to prevent crashes. Therefore, designing distributed systems to tolerate rather than prevent such crashes is a reasonable approach. This is the purpose of fault-tolerance. Among all techniques that provide fault tolerance, replication is the only one that allows the system to mask process crashes. The intuition behind replication is simple: instead of having one instance of a service, we run several of them. If one of the replicas crashes, the rest can take over so that the crash does not prevent the system from delivering the expected service. A replicated service needs to keep all its replicas consistent, and group communication protocols provide abstractions to preserve such consistency. Group communication toolkits have been present since the late 80s. At the beginning, they were monolithic and later on they became modular. Modular group communication\u00a0\u2026", "num_citations": "1\n", "authors": ["494"]}
{"title": "Dependable systems\n", "abstract": " Improving the dependability of computer systems is a critical and essential task. In this context, the paper surveys techniques that allow to achieve fault tolerance in distributed systems by replication. The main replication techniques are first explained. Then group communication is introduced as the communication infrastructure that allows the implementation of the different replication techniques. Finally the difficulty of implementing group communication is discussed, and the most important algorithms are presented.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Performance comparison of a rotating coordinator and a leader based consensus algorithm (extended version)\n", "abstract": " Protocols that solve agreement problems are essential building blocks for fault tolerant distributed systems. While many protocols have been published, little has been done to analyze their performance, especially the performance of their fault tolerance mechanisms. In this paper, we compare two well-known asynchronous consensus algorithms. In both algorithms, a leader process tries to impose a decision, and another leader retries if the leader fails doing so. The algorithms elect leaders differently: the Chandra-Toueg algorithm has a rotating leader, whereas processes in the Paxos algorithm elect leaders directly. We investigate the performance implications of this difference. In the system under study, processes send atomic broadcasts to each other. Consensus is used to decide the delivery order of messages. We evaluate the steady state latency in (1) runs with neither crashes nor suspicions,(2) runs with crashes and (3) runs with no crashes in which correct processes are wrongly suspected to have crashed, as well as the transient latency after (4) one crash,(5) multiple simultaneous crashes and (6) multiple sequenced crashes. The results show that the Paxos algorithm tolerates frequent wrong suspicions (3) and correlated crashes that occur within a short time (5) better, while the performance is comparable in all other scenarios.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Evaluating the performance of distributed agreement algorithms\n", "abstract": " Nowadays, networked computers are present in most aspects of everyday life. Moreover, essential parts of society come to depend on distributed systems formed of networked computers, thus making such systems secure and fault tolerant is a top priority. If the particular fault tolerance requirement is high availability, replication of components is a natural choice. Replication is a difficult problem as the state of the replicas must be kept consistent even if some replicas fail, and because in distributed systems, relying on centralized control or a certain timing behavior is often not feasible.Replication in distributed systems is often implemented using group communication. Group communication is concerned with providing high-level multipoint communication primitives and the associated tools. Most often, an emphasis is put on tolerating crash failures of processes. At the heart of most communication primitives lies an agreement problem: the members of a group must agree on things like the set of messages to be delivered to the application, the delivery order of messages, or the set of processes that crashed. A lot of algorithms to solve agreement problems have been proposed and their correctness proven. However, performance aspects of agreement algorithms have been somewhat neglected, for a variety of reasons: the lack of theoretical and practical tools to help performance evaluation, and the lack of well-defined benchmarks for agreement algorithms. Also, most performance studies focus on analyzing failure free runs only. In our view, the limited understanding of performance aspects, in both failure free scenarios and scenarios with failure\u00a0\u2026", "num_citations": "1\n", "authors": ["494"]}
{"title": "AODV routing algorithm for multihop Ad Hoc Networks\n", "abstract": " \u00abLe standard IEEE 802.11 qui d\u00e9crit le fonctionnement des r\u00e9seaux sans fil ne consid\u00e8re que des environnements single-hop dans lesquels chaque station n'est capable de communiquer directement qu'avec son entourage. Si on consid\u00e8re des r\u00e9seaux de plus grande taille sans infrastructure cabl\u00e9e, il est n\u00e9cessaire d'envisager un algorithme qui permette de propager un message en passant par plusieurs stations relais (sortes de router). Pour r\u00e9soudre ce probl\u00e8me, il existe d\u00e9j\u00e0 plusieurs algorithmes de routage bien adapt\u00e9s au contexte des r\u00e9seaux ad hoc: AODV (Ad hoc On-demand Distance Vector). Le premier but de ce projet consiste \u00e0 porter une impl\u00e9mentation JAVA ou C de l'algorithme MAODV Multicast Ad hoc On-demand Distance Vector), d\u00e9riv\u00e9 de AODV qui permet de faire du multicast. Dans un deuxi\u00e8me temps, une simple application illustrant son fonctionnement sera cod\u00e9e et d\u00e9ploy\u00e9e sur les iPaq du r\u00e9seau mobile du LSR.\u00bb Translation: The IEEE 802.11 standard which describes wireless functioning takes only in account single-hop environments in which each station is able to communicate directly only with its neighbors. If we consider bigger networks without wired infrastructure, it is necessary to consider an algorithm which permits the propagation of a message through several relay stations (kind of routers). In order to solve this problem, several routing algorithms adapted to Ad Hoc networks already exist: AODV (Ad hoc On-demand Distance Vector). The first goal of this project consists in porting a JAVA or C implementation of the MAODV algorithm (Multicast Ad hoc On-demand Distance Vector), derived from AODV which\u00a0\u2026", "num_citations": "1\n", "authors": ["494"]}
{"title": "Fault-tolerant mobile agent for a computer network\n", "abstract": " The invention is directed to a method of operating a mobile agent that travels through a network of a number of computers. The mobile agent is executed in a sequence of stages wherein each stage comprises a set of places. The method comprises the steps of executing the mobile agent in at least one of the set of places of a respective one of the stages, evaluating in which place of the respective stage the mobile agent has been executed successfully, agreeing on this place among the set of places, aborting and/or undoing any operation in connection with the mobile agent in any other place of the respective stage, and moving the modified mobile agent resulting from the successful execution to the next stage.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Optimistic atomic broadcast: A pragmatic viewpoint\n", "abstract": " This paper presents the Optimistic Atomic Broadcast algorithm (OPT-ABcast) which exploits the spontaneous total order message reception property experienced in local area networks in order to allow fast delivery of messages. The OPT-ABcast algorithm is based on a sequence of stages, and messages can be delivered during a stage or at the end of a stage. During a stage, processes deliver messages fast. Whenever the spontaneous total order message reception property does not hold, processes terminate the current stage and start a new one by solving a Consensus problem leading to the delivery of some messages. We evaluate the efficiency of the OPT-ABcast algorithms using the notion of deliver latency.", "num_citations": "1\n", "authors": ["494"]}
{"title": "Virtually Synchronous Communication based on a weak failure suspector\n", "abstract": " There have recently been several papers about membership services in asynchronous systems [2, 12, 16, 17, 18]. A membership service is responsible for giving each process (consistent) information about the operational processes in the system. A process calls this information its view of the system processes. A membership service typically reacts to process crashes or recoveries, leading it to define a set of views. The membership services mentioned vary according to the underlying failure model considered, as well as the properties they provide with respect to the set of views delivered to each process:(eg whether another view may exist simultaneously, the degree of agreement among members):[16, 17] consider processes with crash failure semantics, excluding networkpartitions.[18] considers systems in which processes may crash and the network may partition. However, despite network partitions, this\u00a0\u2026", "num_citations": "1\n", "authors": ["494"]}
{"title": "Database Replication Techniques: A Three Parameter Classification\n", "abstract": " \u274f Results:\u274d Understanding the other community.\u274d New Replication algorithms & techniques.\u274d Exploring Replication Techniques\u2192 this paper.", "num_citations": "1\n", "authors": ["494"]}