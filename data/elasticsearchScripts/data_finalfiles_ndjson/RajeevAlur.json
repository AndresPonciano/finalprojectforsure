{"title": "Discrete abstractions of hybrid systems\n", "abstract": " A hybrid system is a dynamical system with both discrete and continuous state changes. For analysis purposes, it is often useful to abstract a system in a way that preserves the properties being analysed while hiding the details that are of no interest. We show that interesting classes of hybrid systems can be abstracted to purely discrete systems while preserving all properties that are definable in temporal logic. The classes that permit discrete abstractions fall into two categories. Either the continuous dynamics must be restricted, as is the case for timed and rectangular hybrid systems, or the discrete dynamics must be restricted, as is the case for o-minimal hybrid systems. In this paper, we survey and unify results from both areas.", "num_citations": "1013\n", "authors": ["1573"]}
{"title": "A really temporal logic\n", "abstract": " We introduce a temporal logic for the specification of real-time systems. Our logic, TPTL, employs a novel quantifier construct for referencing time: the freeze quantifier binds a variable to the time of the local temporal context. TPTL is both a natural language for specification and a suitable formalism for verification. We present a tableau-based decision procedure and a model-checking algorithm for TPTL. Several generalizations of TPTL are shown to be highly undecidable.", "num_citations": "940\n", "authors": ["1573"]}
{"title": "Reactive modules\n", "abstract": " We present a formal model for concurrent systems. The model represents synchronous and asynchronous components in a uniform framework that supports compositional (assume-guarantee) and hierarchical (stepwise-refinement) design and verification. While synchronous models are based on a notion of atomic computation step, and asynchronous models remove that notion by introducing stuttering, our model is based on a flexible notion of what constitutes a computation step: by applying an abstraction operator to a system, arbitrarily many consecutive steps can be collapsed into a single step. The abstraction operator, which may turn an asynchronous system into a synchronous one, allows us to describe systems at various levels of temporal detail. For describing systems at various levels of spatial detail, we use a hiding operator that may turn a synchronous system into an asynchronous one. We\u00a0\u2026", "num_citations": "938\n", "authors": ["1573"]}
{"title": "Logics and models of real time: A survey\n", "abstract": " We survey logic-based and automata-based languages and techniques for the specification and verification of real-time systems. In particular, we discuss three syntactic extensions of temporal logic: time-bounded operators, freeze quantification, and time variables. We also discuss the extension of finite-state machines with clocks and the extension of transition systems with time bounds on the transitions. All of the resulting notations can be interpreted over a variety of different models of time and computation, including linear and branching time, interleaving and true concurrency, discrete and continuous time. For each choice of syntax and semantics, we summarize the results that are known about expressive power, algorithmic finite-state verification, and deductive verification.", "num_citations": "867\n", "authors": ["1573"]}
{"title": "The benefits of relaxing punctuality\n", "abstract": " The most natural, compositional, way of modeling real-time systems uses a dense domain for time. The satistiability of timing constraints that are capable of expressing punctuality in this model, however, is known to be undecidable. We introduce a temporal language that can constrain the time difference between events only with finite, yet arbitrary, precision and show the resulting logic to be EXPSPACE-complete. This result allows us to develop an algorithm for the verification of timing properties of real-time systems with a dense semantics.", "num_citations": "864\n", "authors": ["1573"]}
{"title": "Timed automata\n", "abstract": " Model checking is emerging as a practical tool for automated debugging of complex reactive systems such as embedded controllers and network protocols (see [23] for a survey). Traditional techniques for model checking do not admit an explicit modeling of time, and are thus, unsuitable for analysis of real-time systems whose correctness depends on relative magnitudes of different delays. Consequently, timed automata [7] were introduced as a formal notation to model the behavior of real-time systems. Its definition provides a simple way to annotate state-transition graphs with timing constraints using finitely many real-valued clock variables. Automated analysis of timed automata relies on the construction of a finite quotient of the infinite space of clock valuations. Over the years, the formalism has been extensively studied leading to many results establishing connections to circuits and logic, and much\u00a0\u2026", "num_citations": "743\n", "authors": ["1573"]}
{"title": "Alternating-time temporal logic\n", "abstract": " Temporal logic comes in two varieties: linear-time temporal logic assumes implicit universal quantification over all paths that are generated by system moves; branching-time temporal logic allows explicit existential and universal quantification over all paths. We introduce a third, more general variety of temporal logic: alternating-time temporal logic offers selective quantification over those paths that are possible outcomes of games, such as the game in which the system and the environment alternate moves. While linear-time and branching-time logics are natural specification languages for closed systems, alternating-time logics are natural specification languages for open systems. For example, by preceding the temporal operator \u201ceventually\u201d with a selective path quantifier, we can specify that in the game between the system and the environment, the system has a strategy to reach a certain state. Also the\u00a0\u2026", "num_citations": "562\n", "authors": ["1573"]}
{"title": "Parametric real-time reasoning\n", "abstract": " Traditional approaches to the algorithmic verification of real-time systems are limited to checking program correctness with respect to concrete timing properties(eg,\u201cmessage delivery wit hin 10 milliseconds\u201d). We address the more realistic and more ambitious problem of deriving symbolic constraints on the timing properties required of real-time systems (eg,\u201cmessage delivery within the time it takes to execute two assignment statements\u201d). To model this problem, we introduce parametric timed automata\u2014finite-state machines whose transitions are constrained with parametric timing requirements. The emptiness question for parametric timed automata is central to the verification problem. On the negative side, we show that in general this question is undecidable. On the positive side, we provide algorithms for checking the emptiness of restricted classesof parametric timed automata. The practical relevance of these\u00a0\u2026", "num_citations": "493\n", "authors": ["1573"]}
{"title": "Real-time logics: complexity and expressiveness\n", "abstract": " The theory of the natural numbers with linear order and monadic predicates underlies propositional linear temporal logic. To study temporal logics that are suitable for reasoning about real-time systems, we combine this classical theory of infinite state sequences with a theory of discrete time, via a monotonic function that maps every state to its time. The resulting theory of timed state sequences is shown to be decidable, albeit nonelementary, and its expressive power is characterized by \u03c9-regular sets. Several more expressive variants are proved to be highly undecidable. This framework allows us to classify a wide variety of real-time logics according to their complexity and expressiveness. Indeed, it follows that most formalisms proposed in the literature cannot be decided. We are, however, able to identify two elementary real-time temporal logics as expressively complete fragments of the theory of timed state\u00a0\u2026", "num_citations": "462\n", "authors": ["1573"]}
{"title": "Event-clock automata: A determinizable class of timed automata\n", "abstract": " We introduce event-recording automata. An event-recording automaton is a timed automaton that contains, for every event a, a clock that records the time of the last occurrence of a. The class of event-recording automata is, on one hand, expressive enough to model (finite) timed transition systems and, on the other hand, determinizable and closed under all boolean operations. As a result, the language-inclusion problem is decidable for event-recording automata. We present a translation from timed transition systems to event-recording automata, which leads to an algorithm for checking if two timed transition systems have the same set of timed behaviors.We also consider event-predicting automata, which contain clocks that predict the time of the next occurrence of an event. The class of event-clock automata, which contain both event-recording and event-predicting clocks, is a suitable specification language for\u00a0\u2026", "num_citations": "455\n", "authors": ["1573"]}
{"title": "Principles of cyber-physical systems\n", "abstract": " A foundational text that offers a rigorous introduction to the principles of design, specification, modeling, and analysis of cyber-physical systems. A cyber-physical system consists of a collection of computing devices communicating with one another and interacting with the physical world via sensors and actuators in a feedback loop. Increasingly, such systems are everywhere, from smart buildings to medical devices to automobiles. This textbook offers a rigorous and comprehensive introduction to the principles of design, specification, modeling, and analysis of cyber-physical systems. The book draws on a diverse set of subdisciplines, including model-based design, concurrency theory, distributed algorithms, formal methods of specification and verification, control theory, real-time systems, and hybrid systems, explaining the core ideas from each that are relevant to system design and analysis. The book explains how formal models provide mathematical abstractions to manage the complexity of a system design. It covers both synchronous and asynchronous models for concurrent computation, continuous-time models for dynamical systems, and hybrid systems for integrating discrete and continuous evolution. The role of correctness requirements in the design of reliable systems is illustrated with a range of specification formalisms and the associated techniques for formal verification. The topics include safety and liveness requirements, temporal logic, model checking, deductive verification, stability analysis of linear systems, and real-time scheduling algorithms. Principles of modeling, specification, and analysis are illustrated by constructing\u00a0\u2026", "num_citations": "395\n", "authors": ["1573"]}
{"title": "Techniques for automatic verification of real-time systems\n", "abstract": " This thesis proposes formal methods for specification and automatic verification of finite-state real-time systems. The traditional formalisms for reasoning about programs abstract away from quantitative time and, consequently, are inadequate for reasoning about real-time systems. We extend the methods based on automata and temporal logics to allow them to model timing delays and to verify real-time requirements.", "num_citations": "324\n", "authors": ["1573"]}
{"title": "Real-time logics: complexity and expressiveness\n", "abstract": " A unifying framework for the study of real-time logics is developed. In analogy to the untimed case, the underlying classical theory of timed state sequences is identified, it is shown to be nonelementarily decidable, and its complexity and expressiveness are used as a point of reference. Two orthogonal extensions of PTL (timed propositional temporal logic and metric temporal logic) that inherit its appeal are defined: they capture elementary, yet expressively complete, fragments of the theory of timed state sequences, and thus are excellent candidates for practical real-time specification languages.< >", "num_citations": "321\n", "authors": ["1573"]}
{"title": "Optimal paths in weighted timed automata\n", "abstract": " We consider an optimal-reachability problem for a timed automaton with respect to a linear cost function which results in a weighted timed automaton. Our solution to this optimization problem consists of reducing it to a (parametric) shortest-path problem for a finite directed graph. The directed graph we construct is a refinement of the region automaton due to Alur and Dill. We present an exponential time algorithm to solve the shortest-path problem for weighted timed automata starting from a single state, and a doubly-exponential time algorithm to solve this problem starting from a zone of the state space.", "num_citations": "313\n", "authors": ["1573"]}
{"title": "Formal verification of hybrid systems\n", "abstract": " In formal verification, a designer first constructs a model, with mathematically precise semantics, of the system under design, and performs extensive analysis with respect to correctness requirements. The appropriate mathematical model for embedded control systems is hybrid systems that combines the traditional state-machine based models for discrete control with classical differential-equations based models for continuously evolving physical activities. In this article, we briefly review selected existing approaches to formal verification of hybrid systems, along with directions for future research.", "num_citations": "264\n", "authors": ["1573"]}
{"title": "Hybrid systems III: verification and control\n", "abstract": " This reference book documents the scientific outcome of the DIMACS/SYCON Workshop on Verification and Control of Hybrid Systems, held at Rutgers University in New Brunswick, NJ, in October 1995. A hybrid system consists of digital devices that interact with analog environments. Computer science contributes expertise on the analog aspects of this emerging field of interdisciplinary research and design. The 48 revised full papers included were strictly refereed; they present the state of the art in this dynamic field with contributions by leading experts. Also available are the predecessor volumes published in the same series as LNCS 999 and LNCS 736.", "num_citations": "262\n", "authors": ["1573"]}
{"title": "Checkfence: checking consistency of concurrent data types on relaxed memory models\n", "abstract": " Concurrency libraries can facilitate the development of multi-threaded programs by providing concurrent implementations of familiar data types such as queues or sets. There exist many optimized algorithms that can achieve superior performance on multiprocessors by allowing concurrent data accesses without using locks. Unfortunately, such algorithms can harbor subtle concurrency bugs. Moreover, they requirememory ordering fences to function correctly on relaxed memory models.", "num_citations": "235\n", "authors": ["1573"]}
{"title": "Modularity for timed and hybrid systems\n", "abstract": " In a trace-based world, the modular specification, verification, and control of live systems require each module to be receptive; that is, each module must be able to meet its liveness assumptions no matter how the other modules behave. In a real-time world, liveness is automatically present in the form of diverging time. The receptiveness condition, then, translates to the requirement that a module must be able to let time diverge no matter how the environment behaves. We study the receptiveness condition for real-time systems by extending the model of reactive modules to timed and hybrid modules. We define the receptiveness of such a module as the existence of a winning strategy in a game of the module against its environment. By solving the game on region graphs, we present an (optimal) Exptime algorithm for checking the receptiveness of prepositional timed modules. By giving a fixpoint\u00a0\u2026", "num_citations": "228\n", "authors": ["1573"]}
{"title": "Model-checking for probabilistic real-time systems\n", "abstract": " Model-checking is a method of verifying concurrent systems in which a state-graph model of the system behavior is compared with a temporal logic formula. This paper extends model-checking to stochastic real-time systems, whose behavior depends on probabilistic choice and quantitative time. The specification language is TCTL, a branching-time temporal logic for expressing real-time properties. We interpret the formulas of the logic over generalized semi-Markov processes. Our model can express constraints like \u201cthe delay between the request and the response is distributed uniformly between 2 to 4 seconds\u201d.             We present an algorithm that combines model-checking for real-time non-probabilistic systems with model-checking for finite-state discrete-time Markov chains. The correctness of the algorithm is not obvious, because it analyzes the projection of a Markov process onto a finite state space\u00a0\u2026", "num_citations": "228\n", "authors": ["1573"]}
{"title": "Deterministic generators and games for LTL fragments\n", "abstract": " Deciding infinite two-player games on finite graphs with the winning condition specified by a linear temporal logic (Ltl) formula, is known to be 2Exptime-complete. In this paper, we identify Ltl fragments of lower complexity. Solving Ltl games typically involves a doubly exponential translation from Ltl formulas to deterministic \u03c9-automata. First, we show that the longest distance (length of the longest simple path) of the generator is also an important parameter, by giving an O(d log n)-space procedure to solve a B\u00fcchi game on a graph with n vertices and longest distance d. Then, for the Ltl fragment of the Boolean combinations of formulas obtained only by eventualities and conjunctions, we provide a translation to deterministic generators of exponential size and linear longest distance, show both of these bounds to be optimal, and prove the corresponding games to be Pspace-complete. Introducing next modalities in\u00a0\u2026", "num_citations": "161\n", "authors": ["1573"]}
{"title": "Modeling and verification of a dual chamber implantable pacemaker\n", "abstract": " The design and implementation of software for medical devices is challenging due to their rapidly increasing functionality and the tight coupling of computation, control, and communication. The safety-critical nature and the lack of existing industry standards for verification, make this an ideal domain for exploring applications of formal modeling and analysis. In this study, we use a dual chamber implantable pacemaker as a case study for modeling and verification of control algorithms for medical devices in UPPAAL. We begin with detailed models of the pacemaker, based on the specifications and algorithm descriptions from Boston Scientific. We then define the state space of the closed-loop system based on its heart rate and developed a heart model which can non-deterministically cover the whole state space. For verification, we first specify unsafe regions within the state space and verify the closed-loop\u00a0\u2026", "num_citations": "158\n", "authors": ["1573"]}
{"title": "Model-checking of correctness conditions for concurrent objects\n", "abstract": " The notions of serializability, linearizability, and sequential consistency are used in the specification of concurrent systems. We show that the model checking problem for each of these properties can be cast in terms of the containment of one regular language in another regular language shuffled using a semicommutative alphabet. The three model checking problems are shown to be, respectively, in P space, in E xpspace, and undecidable.", "num_citations": "152\n", "authors": ["1573"]}
{"title": "Timing analysis in COSPAN\n", "abstract": " We describe how to model and verify real-time systems using the formal verification tool Cospan. The verifier supports automata-theoretic verification of coordinating processes with timing constraints. We discuss different heuristics, and our experiences with the tool for certain benchmark problems appearing in the verification literature.", "num_citations": "145\n", "authors": ["1573"]}
{"title": "An axiomatic memory model for POWER multiprocessors\n", "abstract": " The growing complexity of hardware optimizations employed by multiprocessors leads to subtle distinctions among allowed and disallowed behaviors, posing challenges in specifying their memory models formally and accurately, and in understanding and analyzing the behavior of concurrent software. This complexity is particularly evident in the IBM\u00ae Power Architecture\u00ae, for which a faithful specification was published only in 2011 using an operational style. In this paper we present an equivalent axiomatic specification, which is more abstract and concise. Although not officially sanctioned by the vendor, our results indicate that this axiomatic specification provides a reasonable basis for reasoning about current IBM\u00ae POWER\u00ae multiprocessors. We establish the equivalence of the axiomatic and operational specifications using both manual proof and extensive testing. To demonstrate that the constraint\u00a0\u2026", "num_citations": "136\n", "authors": ["1573"]}
{"title": "Compositional modeling and analysis of multi-hop control networks\n", "abstract": " We propose a mathematical framework for modeling and analyzing multi-hop control networks designed for systems consisting of multiple control loops closed over a multi-hop (wireless) communication network. We separate control, topology, routing, and scheduling and propose formal syntax and semantics for the dynamics of the composed system, providing an explicit translation of multi-hop control networks to switched systems. We propose formal models for analyzing robustness of multi-hop control networks, where data is exchanged through a multi-hop communication network subject to disruptions. When communication disruptions are long, compared to the speed of the control system, we propose to model them as permanent link failures. We show that the complexity of analyzing such failures is NP-hard, and discuss a way to overcome this limitation for practical cases using compositional analysis. For\u00a0\u2026", "num_citations": "126\n", "authors": ["1573"]}
{"title": "The observational power of clocks\n", "abstract": " We develop a theory of equivalences for timed systems. Two systems are equivalent iff external observers cannot observe differences in their behavior. The notion of equivalence depends, therefore, on the distinguishing power of the observers. The power of an observer to measure time results in untimed, clock, and timed equivalences: an untimed observer cannot measure the time difference between events; a clock observer uses a clock to measure time differences with finite precision; a timed observer is able to measure time differences with arbitrary precision.             We show that the distinguishing power of clock observers grows with the number of observers, and approaches, in the limit, the distinguishing power of a timed observer. More precisely, given any equivalence for untimed systems, two timed systems are k-clock congruent, for a nonnegative integer k, iff their compositions with every\u00a0\u2026", "num_citations": "119\n", "authors": ["1573"]}
{"title": "Symbolic analysis for improving simulation coverage of Simulink/Stateflow models\n", "abstract": " Aimed at verifying safety properties and improving simulation coverage for hybrid systems models of embedded control software, we propose a technique that combines numerical simulation and symbolic methods for computing state-sets. We consider systems with linear dynamics described in the commercial modeling tool Simulink/Stateflow. Given an initial state x, and a discrete-time simulation trajectory, our method computes a set of initial states that are guaranteed to be equivalent to x, where two initial states are considered to be equivalent if the resulting simulation trajectories contain the same discrete components at each step of the simulation. We illustrate the benefits of our method on two case studies. One case study is a benchmark proposed in the literature for hybrid systems verification and another is a Simulink demo model from Mathworks.", "num_citations": "115\n", "authors": ["1573"]}
{"title": "Timed automata\n", "abstract": " Model checking is emerging as a practical tool for automated debugging of complex reactive systems such as embedded controllers and network protocols (see [20] for a survey). In model checking, a high-level description of a system is compared against a logical correctness requirement to discover inconsistencies. Traditional techniques for model checking do not admit an explicit modeling of time, and are thus, unsuitable for analysis of real-time systems whose correctness depends on relative magnitudes of different delays. Consequently, timed automata [6] were introduced as a formal notation to model the behavior of real-time systems. Its definition provides a simple, and yet general, way to annotate state-transition graphs with timing constraints using finitely many real-valued clock variables. Automated analysis of timed automata relies on the construction of a finite quotient of the infinite space of clock\u00a0\u2026", "num_citations": "114\n", "authors": ["1573"]}
{"title": "Verifying abstractions of timed systems\n", "abstract": " Given two descriptions of a real-time system at different levels of abstraction, we consider the problem of proving that the refined representation is a correct implementation of the abstract one. To avoid the complexity of building a representation for the refined system in its entirety, we develop a compositional framework for the implementation check to be carried out in a module-by-module manner using assume-guarantee style proof rules. On the algorithmic side, we show that the problem of checking the existence of timed simulation relations, a sufficient condition for correct implementation, is decidable. We study state homomorphisms as a way of specifying a correspondence between two modules. We present an algorithm for checking if a given mapping is a homomorphism preserving timed behaviors. We have implemented this check in the verifier Cospan, and applied our method to the compositional\u00a0\u2026", "num_citations": "110\n", "authors": ["1573"]}
{"title": "Back to the future: towards a theory of timed regular languages\n", "abstract": " Timed automata are nite-state machines constrained by timing requirements so that they accept timed words| words in which every symbol is labeled with a real-valued time. These automata were designed to lead to a theory of nite-state real-time properties with applications to the automatic veri cation of real-time systems. However, both deterministic and nondeterministic versions su er from drawbacks: several key problems, such as language inclusion, are undecidable for nondeterministic timed automata, whereas deterministic timed automata lack considerable expressive power when compared to decidable real-time logics. This is why we introduce two-way timed automata| timed automata that can move back and forth while reading a timed word. Two-wayness in its unrestricted form leads, like nondeterminism, to the undecidability of language inclusion. However, if we restrict the number of times an input symbol may be revisited, then two-wayness is both harmless and desirable. We show that the resulting class of bounded two-way deterministic timed automata is closed under all boolean operations, has decidable (PSPACE-complete) emptiness and inclusion problems, and subsumes all decidable real-time logics we know.We obtain a strict hierarchy of real-time properties: deterministic timed automata can accept more languages as the bound on the number of times an input symbol may be revisited is increased. This hierarchy is also enforced by the number of alternations between past and future operators in temporal logic. The combination of our results leads to a decision procedure for a real-time logic with past operators.", "num_citations": "107\n", "authors": ["1573"]}
{"title": "First-order and temporal logics for nested words\n", "abstract": " Nested words are a structured model of execution paths in procedural programs, reflecting their call and return nesting structure. Finite nested words also capture the structure of parse trees and other tree-structured data, such as XML. We provide new temporal logics for finite and infinite nested words, which are natural extensions of LTL, and prove that these logics are first-order expressively- complete. One of them is based on adding a \"within\" modality, evaluating a formula on a subword, to a logic CaRet previously studied in the context of verifying properties of recursive state machines. The other logic is based on the notion of a summary path that combines the linear and nesting structures. For that logic, both model-checking and satisfiability are shown to be EXPTIME-complete. Finally, we prove that first-order logic over nested words has the three-variable property, and we present a temporal logic for nested\u00a0\u2026", "num_citations": "104\n", "authors": ["1573"]}
{"title": "Parametric temporal logic for \u201cmodel measuring\u201d\n", "abstract": " We extend the standard model checking paradigm of linear temporal logic, LTL, to a \u201cmodel measuring\u201d paradigm where one can obtain more quantitative information beyond a \u201cYes/No\u201d answer. For this purpose, we define a parametric temporal logic, PLTL, which allows statements such as \u201ca request p is followed in at most x steps by a response q,\u201d where x is a free variable. We show how one can, given a formula ***(x1...,xk) of PLTL and a system model K satisfies the property ***, but if so find valuations which satisfy various optimality criteria. In particular, we present algorithms for finding valuations which minimize (or maximize) the maximum (or minimum) of all parameters. Theses algorithms exhibit the same PSPACE complexity as LTL model checking. We show that our choice of syntax for PLTL lies at the threshold of decidability for parametric temporal logics, in that several natural extensions have\u00a0\u2026", "num_citations": "104\n", "authors": ["1573"]}
{"title": "Optimal paths in weighted timed automata\n", "abstract": " We consider the optimal-reachability problem for a timed automaton with respect to a linear cost function which results in a weighted timed automaton. Our solution to this optimization problem consists of reducing it to computing (parametric) shortest paths in a finite weighted directed graph. We call this graph a parametric sub-region graph. It refines the region graph, a standard tool for the analysis of timed automata, by adding the information which is relevant to solving the optimal-reachability problem. We present an algorithm to solve the optimal-reachability problem for weighted timed automata that takes time exponential in O (n (| \u03b4 (A)|+| w max|)), where n is the number of clocks,| \u03b4 (A)| is the size of the clock constraints and| w max| is the size of the largest weight. We show that this algorithm can be improved, if we restrict to weighted timed automata with a single clock. In case we consider a single starting state for\u00a0\u2026", "num_citations": "97\n", "authors": ["1573"]}
{"title": "Automata-theoretic verification of real-time systems\n", "abstract": " Formal methods for specifying, analyzing, and manipulating the behavior of concurrent systems become much more attractive in practical use if they can be automated. A number of methods based on nite-state representations have achieved considerable success in practical applications such as protocol and hardware veri cation, precisely because many problems are decidable for nite-state representations. Finite-state veri cation methods include checking equivalences (such as bisimulation), preorders (such as simulation), temporal logic properties (eg. CTL model-checking), and inclusion of the language of one automaton in another. Until recently, temporal logics and nite automata were primarily concerned with qualitative temporal reasoning about systems. For example, whether a system deadlocks or livelocks, whether a property is always true, or whether some response eventually occurs. More recently, ways of extending nite-state techniques to timed systems have been discovered, which retain many of the desirable properties of conventional nite representations. In this chapter, we will concentrate on linear-time models, although nite-state real-time techniques can also be applied to branching-time problems, such as (timed) CTL model-checking and bisimulation checking. In the linear time model, it is assumed that an execution can be completely modeled as a sequence of states or system events, called a trace. The behavior of the system is a set of such traces. Since a set of sequences is a formal language, this leads naturally to the use of automata for the speci cation and veri cation of systems. When the systems are nite-state, we can\u00a0\u2026", "num_citations": "94\n", "authors": ["1573"]}
{"title": "Finitary fairness\n", "abstract": " Fairness is a mathematical abstraction: in a multiprogramming environment, fairness abstracts the details of admissible (\u201cfair\u201d) schedulers; in a distributed environment, fairness abstracts the relative speeds of processors. We argue that the standard definition of fairness often is unnecessarily weak and can be replaced by the stronger, yet still abstract, notion of finitary fairness. While standard weak fairness requires that no enabled transition is postponed forever, finitary weak fairness requires that for every computation of a system there is an unknown bound k such that no enabled transition is postponed more than k consecutive times. In general, the finitary restriction fin(F) of any given fairness  requirement Fis the union of all \u03c9-regular safety properties contained in F. The adequacy of the proposed abstraction is shown in two ways. Suppose we prove a program property under the assumption of finitary fairness. In a\u00a0\u2026", "num_citations": "90\n", "authors": ["1573"]}
{"title": "Optimal reachability for weighted timed games\n", "abstract": " Weighted timed automata are timed automata annotated with costs on locations and transitions. The optimal game-reachability problem for these automata is to find the best-cost strategy of supplying the inputs so as to ensure reachability of a target set within a specified number of iterations. The only known complexity bound for this problem is a doubly-exponential upper bound. We establish a singly-exponential upper bound and show that there exist automata with exponentially many states in a single region with pair-wise distinct optimal strategies.", "num_citations": "89\n", "authors": ["1573"]}
{"title": "Verifying automata specifications of probabilistic real-time systems\n", "abstract": " We present a model-checking algorithm for a system presented as a generalized semi-Markov process and a specification given as a deterministic timed automaton. This leads to a method for automatic verification of timing properties of finite-state probabilistic real-time systems.", "num_citations": "84\n", "authors": ["1573"]}
{"title": "Counter-strategy guided refinement of GR (1) temporal logic specifications\n", "abstract": " The reactive synthesis problem is to find a finite-state controller that satisfies a given temporal-logic specification regardless of how its environment behaves. Developing a formal specification is a challenging and tedious task and initial specifications are often unrealizable. In many cases, the source of unrealizability is the lack of adequate assumptions on the environment of the system. In this paper, we consider the problem of automatically correcting an unrealizable specification given in the generalized reactivity (1) fragment of linear temporal logic by adding assumptions on the environment. When a temporal-logic specification is unrealizable, the synthesis algorithm computes a counter-strategy as a witness. Our algorithm then analyzes this counter-strategy and synthesizes a set of candidate environment assumptions that can be used to remove the counter-strategy from the environment's possible behaviors. We\u00a0\u2026", "num_citations": "82\n", "authors": ["1573"]}
{"title": "Real-time system= discrete system+ clock variables\n", "abstract": " This paper introduces, gently but rigorously, the clock approach to real-time programming. We present with mathematical precision, assuming no prerequisites other than familiarity with logical and programming notations, the concepts that are necessary for understanding, writing, and executing clock programs. In keeping with an expository style, all references are clustered in bibliographic remarks at the end of each section. The first appendix presents proof rules for verifying temporal properties of clock programs. The second appendix points to selected literature on formal methods and tools for programming with clocks. In particular, the timed automaton, which is a\u00a0finite-state machine equipped with clocks, has become a\u00a0standard paradigm for real-time model checking; it underlies the tools HyTech, Kronos, and Uppaal, which are discussed elsewhere in this volume.", "num_citations": "81\n", "authors": ["1573"]}
{"title": "Accelerating search-based program synthesis using learned probabilistic models\n", "abstract": " A key challenge in program synthesis concerns how to efficiently search for the desired program in the space of possible programs. We propose a general approach to accelerate search-based program synthesis by biasing the search towards likely programs. Our approach targets a standard formulation, syntax-guided synthesis (SyGuS), by extending the grammar of possible programs with a probabilistic model dictating the likelihood of each program. We develop a weighted search algorithm to efficiently enumerate programs in order of their likelihood. We also propose a method based on transfer learning that enables to effectively learn a powerful model, called probabilistic higher-order grammar, from known solutions in a domain. We have implemented our approach in a tool called Euphony and evaluate it on SyGuS benchmark problems from a variety of domains. We show that Euphony can learn good models\u00a0\u2026", "num_citations": "77\n", "authors": ["1573"]}
{"title": "Automating modular verification\n", "abstract": " Modular techniques for automatic verification attempt to overcome the state-explosion problem by exploiting the modular structure naturally present in many system designs. Unlike other tasks in the verification of finite-state systems, current modular techniques rely heavily on user guidance. In particular, the user is typically required to construct module abstractions that are neither too detailed as to render insufficient benefits in state exploration, nor too coarse as to invalidate the desired systemproperties. In this paper, we construct abstractmodules automatically, using reachability and controllability information about the concrete modules. This allows us to leverage automatic verification techniques by applying them in layers: first we compute on the state spaces of system components, then we use the results for constructing abstractions, and finally we compute on the abstract state space of the system. Our\u00a0\u2026", "num_citations": "75\n", "authors": ["1573"]}
{"title": "Timing verification by successive approximation\n", "abstract": " Apparatus for developing and verifying systems. The disclosed apparatus employs a computationally-tractable technique for verifying whether a system made up of a set of processes, each of which has at least one delay constraint associated with it, satisfies a given temporal property. The technique deals with the verification as a language inclusion problem, ie, it represents both the set of processes and the temporal property as automata and determines whether there is a restriction of the set of processes such that the language of the automaton representing the restricted set of processes is included in the language of the automaton representing the temporal property. The technique is computationally tractable because it deals with the problem iteratively: it tests whether a current restriction of the set of processes is included, and if not, it employs a counter-example for the inclusion to either determine that the delay\u00a0\u2026", "num_citations": "75\n", "authors": ["1573"]}
{"title": "Automata based interfaces for control and scheduling\n", "abstract": " We propose the use of formal languages of infinite words over the alphabet of task identifiers as an interface between control designs and software implementations. We argue that this approach is more flexible than the classical real-time scheduling framework based on periodic tasks, and allows composition of interfaces by language-theoretic operations. We show that finite automata over infinite words offer analyzable representation and can capture many interesting interface specifications such as exponential stability of switched linear systems.", "num_citations": "73\n", "authors": ["1573"]}
{"title": "Perturbed timed automata\n", "abstract": " We consider timed automata whose clocks are imperfect. For a given perturbation error 0\u2009<\u2009\u03b5<\u20091, the perturbed language of a timed automaton is obtained by letting its clocks change at a rate within the interval [1\u2009\u2212\u2009\u03b5,1\u2009+\u2009\u03b5]. We show that the perturbed language of a timed automaton with a single clock can be captured by a deterministic timed automaton. This leads to a decision procedure for the language inclusion problem for systems modeled as products of 1-clock automata with imperfect clocks. We also prove that determinization and decidability of language inclusion are not possible for multi-clock automata, even with perturbation.", "num_citations": "72\n", "authors": ["1573"]}
{"title": "Marrying words and trees\n", "abstract": " Traditionally, data that has both linear and hierarchical structure, such as annotated linguistic data, is modeled using ordered trees and queried using tree automata. In this paper, we argue that nested words and automata over nested words offer a better way to capture and process the dual structure. Nested words generalize both words and ordered trees, and allow both word and tree operations. We study various classes of automata over nested words, and show that while they enjoy expressiveness and succinctness benefits over word and tree automata, their analysis complexity and closure properties are analogous to the corresponding word and tree special cases. In particular, we show that finite-state nested word automata can be exponentially more succinct than tree automata, and pushdown nested word automata include the two incomparable classes of context-free word languages and context-free tree\u00a0\u2026", "num_citations": "70\n", "authors": ["1573"]}
{"title": "Regular programming for quantitative properties of data streams\n", "abstract": " We propose quantitative regular expressions (QREs) as a high-level programming abstraction for specifying complex numerical queries over data streams in a modular way. Our language allows the arbitrary nesting of orthogonal sets of combinators: (a) generalized versions of choice, concatenation, and Kleene-iteration from regular expressions, (b) streaming (serial) composition, and (c) numerical operators such as min, max, sum, difference, and averaging. Instead of requiring the programmer to figure out the low-level details of what state needs to be maintained and how to update it while processing each data item, the regular constructs facilitate a global view of the entire data stream splitting it into different cases and multiple chunks. The key technical challenge in defining our language is the design of typing rules that can be enforced efficiently and which strike a balance between expressiveness and\u00a0\u2026", "num_citations": "68\n", "authors": ["1573"]}
{"title": "Modular refinement of hierarchic reactive machines\n", "abstract": " Scalable formal analysis of reactive programs demands integration of modular reasoning techniques with existing analysis tools. Principles such as abstraction, compositional refinement, and assume-guarantee reasoning are well understood for architectural hierarchy that describes the communication structure between component processes, and have been shown to be useful. In this paper, we develop the theory of modular reasoning for behavior hierarchy that describes control structure using hierarchic modes. From STATECHARTS to UML, behavior hierarchy has been an integral component of many software design languages, but only syntactically. We present the hierarchic reactive modules language that retains powerful features such as nested modes, mode reuse, exceptions, group transitions, history, and conjunctive modes, and yet has a semantic notion of mode hierarchy. We present an observational\u00a0\u2026", "num_citations": "68\n", "authors": ["1573"]}
{"title": "Closed-loop verification of medical devices with model abstraction and refinement\n", "abstract": " The design and implementation of software for medical devices is challenging due to the closed-loop interaction with the patient, which is a stochastic physical environment. The safety-critical nature and the lack of existing industry standards for verification make this an ideal domain for exploring applications of formal modeling and closed-loop analysis. The biggest challenge is that the environment model(s) have to be both complex enough to express the physiological requirements and general enough to cover all possible inputs to the device. In this effort, we use a dual chamber implantable pacemaker as a case study to demonstrate verification of software specifications of medical devices as timed-automata models in UPPAAL. The pacemaker model is based on the specifications and algorithm descriptions from Boston Scientific. The heart is modeled using timed automata based on the physiology of\u00a0\u2026", "num_citations": "66\n", "authors": ["1573"]}
{"title": "Hybrid Systems: Computation and Control: 7th International Workshop, HSCC 2004, Philadelphia, PA, USA, March 25-27, 2004, Proceedings\n", "abstract": " This volume contains the proceedings of the 7th Workshop on Hybrid Systems: Computation and Control (HSCC 2004) held in Philadelphia, USA, from March 25 to 27, 2004. The annual workshop on hybrid systems attracts researchers from academia and industry interested in modeling, analysis, and implemen-tion of dynamic and reactive systems involving both discrete and continuous behaviors. The previous workshops in the HSCC series were held in Berkeley, USA (1998), Nijmegen, TheNetherlands (1999), Pittsburgh, USA (2000), Rome, Italy (2001), Palo Alto, USA (2002), and Prague, Czech Republic (2003). This year\u2019s HSCC was organized in cooperation with ACM SIGBED (Special Interest Group on Embedded Systems) and was technically co-sponsored by the IEEE Control Systems Society. The program consisted of 4 invited talks and 43 regular papers selected from 117 regular submissions. The program covered topics such as tools for analysis and veri? cation, control and optimization, modeling, and engineering applica-ons, as in past years, and emerging directions in programming language support and implementation. The program also contained one special session focusing on the interplay between biomolecular networks, systems biology, formal methods, andthecontrolofhybridsystems.", "num_citations": "66\n", "authors": ["1573"]}
{"title": "Results about fast mutual exclusion\n", "abstract": " A fast mutual exclusion algorithm where only five accesses to the shared memory are needed in order to enter a critical section in the absence of contention is presented. In the presence of contention, the winning process may need to delay itself for 3* Delta time units, where Delta is an upper bound on the time taken by the slowest process to execute a statement involving an access to the shared memory. It is also proven that there is not two (or more) process mutual exclusion algorithm with an upper bound on the number of times a winning process needs to access the shared memory in order to enter its critical section in the presence of contention. However, under the assumption that busy-waiting counts as just one step, the authors present, for every fixed parameter k, an algorithm with the property that from a state where no process tries to enter its critical section, as long as the number of contenders does not\u00a0\u2026", "num_citations": "66\n", "authors": ["1573"]}
{"title": "Generating litmus tests for contrasting memory consistency models\n", "abstract": " Well-defined memory consistency models are necessary for writing correct parallel software. Developing and understanding formal specifications of hardware memory models is a challenge due to the subtle differences in allowed reorderings and different specification styles. To facilitate exploration of memory model specifications, we have developed a technique for systematically comparing hardware memory models specified using both operational and axiomatic styles. Given two specifications, our approach generates all possible multi-threaded programs up to a specified bound, and for each such program, checks if one of the models can lead to an observable behavior not possible in the other model. When the models differs, the tool finds a minimal \u201clitmus test\u201d program that demonstrates the difference. A number of optimizations reduce the number of programs that need to be examined. Our prototype\u00a0\u2026", "num_citations": "64\n", "authors": ["1573"]}
{"title": "Computing accumulated delays in real-time systems\n", "abstract": " We present a verification algorithm for duration properties of finite-state real-time systems. While simple real-time properties constrain the total elapsed time between events, duration properties constrain the accumulated time during which certain state predicates hold. We formalize the concept of durations by introducing duration measures for (dense-time) timed automata. Given a timed automaton with a duration measure, a start and a target state, and a duration constraint, the duration-bounded reachability problem asks if there is a run of the automaton from the start state to the target state such that the accumulated duration along the run satisfies the constraint. Our main result is a novel decision procedure for solving the duration-bounded reachability problem. We also prove that the problem is PSPACE-complete and demonstrate how the solution can be used to verify interesting duration properties of real\u00a0\u2026", "num_citations": "64\n", "authors": ["1573"]}
{"title": "Symbolic analysis of hybrid systems\n", "abstract": " A hybrid system is a dynamical system whose behavior exhibits both discrete and continuous change. A hybrid automaton is a mathematical model for hybrid systems, which combines, in a single formalism, automaton transitions for capturing discrete change with differential equations for capturing continuous change. In this survey, we demonstrate symbolic algorithms for the verification of and controller synthesis for linear hybrid automata, a subclass of hybrid automata that can be analyzed automatically.", "num_citations": "63\n", "authors": ["1573"]}
{"title": "Learning-based symbolic assume-guarantee reasoning with automatic decomposition\n", "abstract": " Compositional reasoning aims to improve scalability of verification tools by reducing the original verification task into subproblems. The simplification is typically based on the assume-guarantee reasoning principles, and requires decomposing the system into components as well as identifying adequate environment assumptions for components. One recent approach to automatic derivation of adequate assumptions is based on the L                         * algorithm for active learning of regular languages. In this paper, we present a fully automatic approach to compositional reasoning by automating the decomposition step using an algorithm for hypergraph partitioning for balanced clustering of variables. We also propose heuristic improvements to the assumption identification phase. We report on an implementation based on NuSMV, and experiments that study the effectiveness of automatic decomposition and the\u00a0\u2026", "num_citations": "59\n", "authors": ["1573"]}
{"title": "Nondeterministic streaming string transducers\n", "abstract": " We introduce nondeterministic streaming string transducers (nssts) \u2013 a new computational model that can implement MSO-definable relations between strings. An nsst makes a single left-to-right pass on the input string and uses a finite set of string variables to compute the output. In each step, it reads one input symbol, and updates its string variables in parallel with a copyless assignment. We show that nsst are closed under sequential composition and that their expressive power coincides with that of nondeterministic MSO-definable transductions. Further, we identify the class of functional                         nssts; such an nsst allows nondeterministic transitions, but for every successful run on a given input generates the same output string. We show that deciding functionality of an arbitrary nsst is decidable with pspace complexity, while the equivalence problem for functional nssts is pspace-complete. We also\u00a0\u2026", "num_citations": "58\n", "authors": ["1573"]}
{"title": "Regular specifications of resource requirements for embedded control software\n", "abstract": " For embedded control systems, a schedule for the allocation of resources to a software component can be described by an infinite word whose ith symbol models the resources used at the ith sampling interval. Dependency of performance on schedules can be formally modeled by an automaton (omega-regular language) which captures all the schedules that keep the system within performance requirements. We show how such an automaton is constructed for linear control designs and exponential stability or settling time performance requirements. Then, we explore the use of the automaton for online scheduling and for schedulability analysis. As a case study, we examine how this approach can be applied for the LQG control design. We demonstrate, by examples, that online schedulers can be used to guarantee performance in worst-case condition together with good performance in normal conditions. We also\u00a0\u2026", "num_citations": "56\n", "authors": ["1573"]}
{"title": "Handbook of networked and embedded control systems\n", "abstract": " Thishandbookwasmotivatedinpartbyourexperience (andthatofothers) in performing research and in teaching about networked and embedded control systems (NECS) as well as in implementing such systems. Although NECS\u2014along with the technologies that enable them\u2014have become ubiquitous, there are few, if any, sources where a student, researcher, or developer can gain a su? ciently broad view of the subject. Oftentimes, the needed information is scattered in articles, websites, and speci? cation sheets. Such di? culties are perhaps to be expected, given the relative newness of the subject and the diversity of its constitutive disciplines. From control theory and communi-tions, to computer science and electronics, the variety of approaches, tools, and language used by experts in each? eld often acts as a barrier to und-standing how ideas? t within the broader context of networked and embedded control. With the above in mind, we have gathered a collection of articles that provide at least an introduction to the important results, tools, software, and technologies that shape the area of NECS. Our goal was to present the most important knowledge about NECS in a book that would be useful to anyone who wants to learn about any aspect of the subject. We hope that we have succeeded and that every reader will? nd valuable information in the book. Wethanktheauthorsofeachofthechapters. Theyareallbusypeopleand we are extremely grateful to them for their outstanding work.", "num_citations": "56\n", "authors": ["1573"]}
{"title": "Systems computing challenges in the internet of things\n", "abstract": " A recent McKinsey report estimates the economic impact of the Internet of Things (IoT) to be between $3.9 to $11 trillion dollars by 20251 . IoT has the potential to have a profound impact on our daily lives, including technologies for the home, for health, for transportation, and for managing our natural resources. The Internet was largely driven by information and ideas generated by people, but advances in sensing and hardware have enabled computers to more easily observe the physical world. Coupling this additional layer of information with advances in machine learning brings dramatic new capabilities including the ability to capture and process tremendous amounts of data; to predict behaviors, activities, and the future in uncanny ways; and to manipulate the physical world in response. This trend will fundamentally change how people interact with physical objects and the environment. Success in developing value-added capabilities around IoT requires a broad approach that includes expertise in sensing and hardware, machine learning, networked systems, human-computer interaction, security, and privacy. Strategies for making IoT practical and spurring its ultimate adoption also require a multifaceted approach that often transcends technology, such as with concerns over data security, privacy, public policy, and regulatory issues. In this paper we argue that existing best practices in building robust and secure systems are insufficient to address the new challenges that IoT systems will present. We provide recommendations regarding investments in research areas that will help address inadequacies in existing systems, practices, tools, and\u00a0\u2026", "num_citations": "55\n", "authors": ["1573"]}
{"title": "Regular combinators for string transformations\n", "abstract": " We focus on (partial) functions that map input strings to a monoid such as the set of integers with addition and the set of output strings with concatenation. The notion of regularity for such functions has been defined using two-way finite-state transducers,(one-way) cost register automata, and MSO-definable graph transformations. In this paper, we give an algebraic and machine-independent characterization of this class analogous to the definition of regular languages by regular expressions. When the monoid is commutative, we prove that every regular function can be constructed from constant functions using the combinators of choice, split sum, and iterated sum, that are analogs of union, concatenation, and Kleene-*, respectively, but enforce unique (or unambiguous) parsing. Our main result is for the general case of non-commutative monoids, which is of particular interest for capturing regular string-to-string\u00a0\u2026", "num_citations": "54\n", "authors": ["1573"]}
{"title": "NetEgg: Programming network policies by examples\n", "abstract": " The emergence of programmable interfaces to network controllers offers network operators the flexibility to implement a variety of policies. We propose NetEgg, a programming framework that allows a network operator to specify the desired functionality using example behaviors. Our synthesis algorithm automatically infers the state that needs to be maintained to exhibit the desired behaviors along with the rules for processing network packets and updating the state. We report on an initial prototype of NetEgg. Our experiments evaluate the proposed framework based on the number of examples needed to specify a variety of policies considered in the literature, the computational requirements of the synthesis algorithm to translate these examples to programs, and the overhead introduced by the generated implementation for processing packets. Our results show that NetEgg can generate implementations that are\u00a0\u2026", "num_citations": "53\n", "authors": ["1573"]}
{"title": "Modeling and analysis of multi-hop control networks\n", "abstract": " We propose a mathematical framework, inspired by the Wireless HART specification, for modeling and analyzing multi-hop communication networks. The framework is designed for systems consisting of multiple control loops closed over a multi-hop communication network. We separate control, topology, routing, and scheduling and propose formal syntax and semantics for the dynamics of the composed system. The main technical contribution of the paper is an explicit translation of multi-hop control networks to switched systems. We describe a Mathematica notebook that automates the translation of multihop control networks to switched systems, and use this tool to show how techniques for analysis of switched systems can be used to address control and networking co-design challenges.", "num_citations": "52\n", "authors": ["1573"]}
{"title": "Regular transformations of infinite strings\n", "abstract": " The theory of regular transformations of finite strings is quite mature with appealing properties. This class can be equivalently defined using both logic (Monadic second-order logic) and finite-state machines (two-way transducers, and more recently, streaming string transducers); is closed under operations such as sequential composition and regular choice; and problems such as functional equivalence and type checking, are decidable for this class. In this paper, we initiate a study of transformations of infinite strings. The MSO-based definition for regular string transformations generalizes naturally to infinite strings. We define an equivalent generalization of the machine model of streaming string transducers to infinite strings. A streaming string transducer is a deterministic machine that makes a single pass over the input string, and computes the output fragments using a finite set of string variables that are updated in\u00a0\u2026", "num_citations": "50\n", "authors": ["1573"]}
{"title": "Automatic symbolic compositional verification by learning assumptions\n", "abstract": " Compositional reasoning aims to improve scalability of verification tools by reducing the original verification task into subproblems. The simplification is typically based on assume-guarantee reasoning principles, and requires user guidance to identify appropriate assumptions for components. In this paper, we propose a fully automated approach to compositional reasoning that consists of automated decomposition using a hypergraph partitioning algorithm for balanced clustering of variables, and discovering assumptions using the L                         * algorithm for active learning of regular languages. We present a symbolic implementation of the learning algorithm, and incorporate it in the model checker NuSmv. In some cases, our experiments demonstrate significant savings in the computational requirements of symbolic model checking.", "num_citations": "50\n", "authors": ["1573"]}
{"title": "Model checking of hierarchical state machines\n", "abstract": " Model checking is applied to a hierarchical state machine (ie, a state machine having at least one state (ie, a superstate) that is itself a state machine) without first flattening the hierarchical state machine. In one embodiment, the model checking involves one or more or reachability, cycle-detection, linear-time requirements, and branching-time requirements analyses. For reachability analysis, in addition to keeping track of whether states have been visited, the algorithm also keeps track of the exit nodes for each superstate. Cycle-detection analysis has two phases: a primary phase in which target states are identified and a secondary phase in which it is determined whether identified target states are part of closed processing paths or loops. For cycle-detection analysis, the algorithm keeps track of (1) whether states have been visited during the primary phase,(2) the exit nodes for each superstate, and (3) whether\u00a0\u2026", "num_citations": "50\n", "authors": ["1573"]}
{"title": "Quantitative network monitoring with netqre\n", "abstract": " In network management today, dynamic updates are required for traffic engineering and for timely response to security threats. Decisions for such updates are based on monitoring network traffic to compute numerical quantities based on a variety of network and application-level performance metrics. Today's state-of-the-art tools lack programming abstractions that capture application or session-layer semantics, and thus require network operators to specify and reason about complex state machines and interactions across layers. To address this limitation, we present the design and implementation of NetQRE, a high-level declarative toolkit that aims to simplify the specification and implementation of such quantitative network policies. NetQRE integrates regular-expression-like pattern matching at flow-level as well as application-level payloads with aggregation operations such as sum and average counts. We\u00a0\u2026", "num_citations": "48\n", "authors": ["1573"]}
{"title": "Efficient reachability analysis of hierarchical reactive machines\n", "abstract": " Hierarchical state machines is a popular visual formalism for software specifications. To apply automated analysis to such specifications, the traditional approach is to compile them to existing model checkers. Aimed at exploiting the modular structure more effectively, our approach is to develop algorithms that work directly on the hierarchical structure. First, we report on an implementation of a visual hierarchical language with modular features such as nested modes, variable scoping, mode reuse, exceptions, group transitions, and history. Then, we identify a variety of heuristics to exploit these modular features during reachability analysis. We report on an enumerative as well as a symbolic checker, and case studies.", "num_citations": "47\n", "authors": ["1573"]}
{"title": "Local liveness for compositional modeling of fair reactive systems\n", "abstract": " We argue that the standard constraints on liveness conditions in nonblocking trace models\u2014machine closure for closed systems, and receptiveness for open systems\u2014are unnecessarily weak and complex, and that liveness should, instead, be specified by augmenting transition systems with acceptance conditions that satisfy a locality constraint. First, locality implies machine closure and receptiveness, and thus permits the composition and modular verification of live transition systems. Second, while machine closure and receptiveness are based on infinite games, locality is based on repeated finite games, and thus easier to check. Third, no expressive power is lost by the restriction to local liveness conditions. We illustrate the appeal of local liveness using the model of Fair Reactive Systems, a nonblocking trace model of communicating processes.", "num_citations": "46\n", "authors": ["1573"]}
{"title": "Theory in practice for system design and verification\n", "abstract": " Methodology and tools for assisting developers in building high-confidence hardware and software at a reasonable cost has been one of the central themes in computer science since its inception. The formal methods research on this problem has focused on two complimentary goals: to provide mathematical abstractions to manage the complexity of the design and to develop analysis tools to check that the implementation works correctly as intended. Achieving these goals has proved to be extremely challenging for two reasons. First, the scale and complexity of systems being designed remains a moving target as computers have transformed from special-purpose and stand-alone number-crunching processors to networked devices interacting with the physical world. Second, once formalized, the computational problem of verifying that a system meets its specification is undecidable in the general case and has\u00a0\u2026", "num_citations": "44\n", "authors": ["1573"]}
{"title": "Languages of nested trees\n", "abstract": " We study languages of nested trees\u2014structures obtained by augmenting trees with sets of nested jump-edges. These graphs can naturally model branching behaviors of pushdown programs, so that the problem of branching-time software model checking may be phrased as a membership question for such languages. We define finite-state automata accepting such languages\u2014these automata can pass states along jump-edges as well as tree edges. We find that the model-checking problem for these automata on pushdown systems is EXPTIME-complete, and that their alternating versions are expressively equivalent to NT-\u03bc, a recently proposed temporal logic for nested trees that can express a variety of branching-time, \u201ccontext-free\u201d requirements. We also show that monadic second order logic (MSO) cannot exploit the structure: MSO on nested trees is too strong in the sense that it has an undecidable\u00a0\u2026", "num_citations": "44\n", "authors": ["1573"]}
{"title": "A fixpoint calculus for local and global program flows\n", "abstract": " We define a new fixpoint modal logic, the visibly pushdown \u03bc-calculus (VP-\u03bc), as an extension of the modal \u03bc-calculus. The models of this logic are execution trees of structured programs where the procedure calls and returns are made visible. This new logic can express pushdown specifications on the model that its classical counterpart cannot, and is motivated by recent work on visibly pushdown languages [4]. We show that our logic naturally captures several interesting program specifications in program verification and dataflow analysis. This includes a variety of program specifications such as computing combinations of local and global program flows, pre/post conditions of procedures, security properties involving the context stack, and interprocedural dataflow analysis properties. The logic can capture flow-sensitive and inter-procedural analysis, and it has constructs that allow skipping procedure calls so that\u00a0\u2026", "num_citations": "44\n", "authors": ["1573"]}
{"title": "Model-checking of real-time systems: a telecommunications application: experience report\n", "abstract": " We describe the application of model checking tools to analyze a real-time software challenge in the design of Lucent Technologies' 5ESS telephone switching system. We use two tools: COSPAN for checking real-time properties, and TPWB for checking probabilistic specifications. We report on the feedback given by the tools, and based on our experience, discuss the advantages and the limitations of the approach used.", "num_citations": "44\n", "authors": ["1573"]}
{"title": "Time-adaptive algorithms for synchronization\n", "abstract": " We consider concurrent systems in which there is an unknown upper bound on memory access time. Such a model is inherently different from the asynchronous model, where no such bound exists, and also from timing-based models, where such a bound exists and is known a priori. The appeal of our model lies in the fact that while it abstracts from implementation details, it is a better approximation of real concurrent systems than the asynchronous model. Furthermore, it is stronger than the asynchronous model, enabling us to design algorithms for problems that are unsolvable in the asynchronous model.Two basic synchronization problems, consensus and mutual exclusion, are investigated in a shared-memory environment that supports atomic read/write registers. We show that  is an upper and lowerbound on the time complexity of consensus, where  is the (unknown) upper bound on memory\u00a0\u2026", "num_citations": "43\n", "authors": ["1573"]}
{"title": "RTComposer: a framework for real-time components with scheduling interfaces\n", "abstract": " We present a framework for component-based design and scheduling of real-time embedded software. Each component has a clearly specified interface that includes the methods used for sensing, computation, and actuation, along with a requirement given as a regular set of macro-schedules. Each macro-schedule is an infinite sequence that specifies, for every time slot, the set of component methods invoked in that slot. The macro-scheduler composes the specifications of all the components, along with the platform specification that constrains which methods can be executed within a single slot, to generate a feasible macro-schedule. Within a slot, we use logical execution time semantics, and this micro-scheduling is implemented on top of a native priority-based scheduler. With this approach, each component can be specified and analyzed in a platform-independent way, and at the same time, the performance\u00a0\u2026", "num_citations": "41\n", "authors": ["1573"]}
{"title": "Time-triggered implementations of dynamic controllers\n", "abstract": " Bridging the gap between model-based design and platform-based implementation is one of the critical challenges for embedded software systems. In the context of embedded control systems that interact with an environment, a variety of errors due to quantization, delays, and scheduling policies may generate executable code that does not faithfully implement the model-based design. In this paper, we show that the performance gap between the model-level semantics of proportional-integral-derivative (PID) controllers and their implementation-level semantics can be rigorously quantified if the controller implementation is executed on a predictable time-triggered architecture. Our technical approach uses lifting techniques for periodic, time-varying linear systems in order to compute the exact error between the model semantics and the execution semantics. Explicitly computing the impact of the implementation on\u00a0\u2026", "num_citations": "41\n", "authors": ["1573"]}
{"title": "Bounded model checking of concurrent data types on relaxed memory models: A case study\n", "abstract": " Many multithreaded programs employ concurrent data types to safely share data among threads. However, highly-concurrent algorithms for even seemingly simple data types are difficult to implement correctly, especially when considering the relaxed memory ordering models commonly employed by today\u2019s multiprocessors. The formal verification of such implementations is challenging as well because the high degree of concurrency leads to a large number of possible executions. In this case study, we develop a SAT-based bounded verification method and apply it to a representative example, a well-known two-lock concurrent queue algorithm. We first formulate a correctness criterion that specifically targets failures caused by concurrency; it demands that all concurrent executions be observationally equivalent to some serial execution. Next, we define a relaxed memory model that conservatively\u00a0\u2026", "num_citations": "41\n", "authors": ["1573"]}
{"title": "\u201cNext\u201d heuristic for on-the-fly model checking\n", "abstract": " We present a new heuristic for on-the-fly enumerative invariant verification. The heuristic is based on a construct for temporal scaling, called next, that compresses a sequence of transitions leading to a given target set into a single metatransition. First, we give an on-the-fly algorithm to search a process expression built using the constructs of hiding, parallel composition, and temporal scaling. Second, we show that as long the target set \u0398 of transitions includes all transitions that access variables shared with the environment, the process next                         \u0398 for P and P are equivalent according to the weak-simulation equivalence. As a result, to search the product of given processes, we can cluster processes into groups with as little communication among them as possible, and compose the groups only after applying appropriate hiding and temporal scaling operators. Applying this process recursively gives\u00a0\u2026", "num_citations": "38\n", "authors": ["1573"]}
{"title": "Symbolic computational techniques for solving games\n", "abstract": " Games are useful in modular specification and analysis of systems where the distinction among the choices controlled by different components (for instance, the system and its environment) is made explicit. In this paper, we formulate and compare various symbolic computational techniques for deciding the existence of winning strategies. The game structure is given implicitly, and the winning condition is either a reachability game of the form \u201cp until q\u201d (for state predicates p and q) or a safety game of the form \u201cAlways p.\u201d               For reachability games, the first technique employs symbolic fixed-point computation using ordered binary decision diagrams (BDDs) [9]. The second technique checks for the existence of strategies that ensure winning within k steps, for a user-specified bound k, by reduction to the satisfiability of quantified boolean formulas. Finally, the bounded case can also be solved by reduction\u00a0\u2026", "num_citations": "36\n", "authors": ["1573"]}
{"title": "Verifying network protocol implementations by symbolic refinement checking\n", "abstract": " We consider the problem of establishing consistency of code implementing a network protocol with respect to the documentation as a standard RFC. The problem is formulated as a refinement checking between two models, the implementation extracted from code and the specification extracted from RFC. After simplifications based on assume-guarantee reasoning, and automatic construction of witness modules to deal with the hidden specification state, the refinement checking problem reduces to checking transition invariants. The methodology is illustrated on two case-studies involving popular network protocols, namely, PPP (point-to-point protocol for establishing connections remotely) and DHCP (dynamic-host-configuration-protocol for configuration management in mobile networks). We also present a symbolic implementation of a reduction scheme based on compressing internal transitions in a\u00a0\u2026", "num_citations": "36\n", "authors": ["1573"]}
{"title": "Playing games with boxes and diamonds\n", "abstract": " Deciding infinite two-player games on finite graphs with the winning condition specified by a linear temporal logic (Ltl) formula, is known to be 2Exptime-complete. The previously known hardness proofs encode Turing machine computations using the next and/or until operators. Furthermore, in the case of model checking, disallowing next and until, and retaining only the always and eventually operators, lowers the complexity from Pspace to Np. Whether such a reduction in complexity is possible for deciding games has been an open problem. In this paper, we provide a negative answer to this question. We introduce new techniques for encoding Turing machine computations using games, and show that deciding games for the Ltl fragment with only the always and eventually operators is 2Exptime-hard. We also prove- that if in this fragment we do not allow the eventually operator in the scope of the always\u00a0\u2026", "num_citations": "35\n", "authors": ["1573"]}
{"title": "Parametric temporal logic for \u201cmodel measuring\u201d\n", "abstract": " We extend the standard model checking paradigm of linear temporal logic, LTL, to a \u201cmodel measuring\u201d paradigm where one can obtain more quantitative information beyond a \u201cYes/No\u201d answer. For this purpose, we define a parametric temporal logic, PLTL, which allows statements such as \u201ca request p is followed in at most x steps by a response q\u201d, where x is a free variable. We show how one can, given a formula \u03d5(x                         1,...,x                         k) of PLTL and a system model K, not only determine whether there exists a valuation of x                         1,...,x                         k under which the system K satisfies the property \u03b5, but if so find valuations which satisfy various optimality criteria. In particular, we present algorithms for finding valuations which minimize (or maximize) the maximum (or minimum) of all parameters. These algorithms exhibit the same PSPACE complexity as LTL model checking.We show\u00a0\u2026", "num_citations": "35\n", "authors": ["1573"]}
{"title": "Computing accumulated delays in real-time systems\n", "abstract": " We present a verification algorithm for duration properties of real-time systems. While simple real-time properties constrain the total elapsed time between events, duration properties constrain the accumulated satisfaction time of state predicates. We formalize the concept of durations by introducing duration measures for timed automata. A duration measure assigns to each finite run of a timed automaton a real number \u2014the duration of the run\u2014 which may be the accumulated satisfaction time of a state predicate along the run. Given a timed automaton with a duration measure, an initial and a final state, and an arithmetic constraint, the duration-bounded reachability problem asks if there is a run of the automaton from the initial state to the final state such that the duration of the run satisfies the constraint. Our main result is an (optimal) PSPACE decision procedure for the duration-bounded reachability problem.", "num_citations": "35\n", "authors": ["1573"]}
{"title": "Ranking automata and games for prioritized requirements\n", "abstract": " Requirements of reactive systems are usually specified by classifying system executions as desirable and undesirable. To specify prioritized requirements, we propose to associate a rank with each execution. This leads to optimization analogs of verification and synthesis problems in which we compute the \u201cbest\u201d requirement that can be satisfied or enforced from a given state. The classical definitions of acceptance criteria for automata can be generalized to ranking conditions. In particular, given a mapping of states to colors, the B\u00fcchi ranking condition maps an execution to the highest color visited infinitely often by the execution, and the cyclic ranking condition with cycle k maps an execution to the modulo-k value of the highest color repeating infinitely often. The well-studied parity acceptance condition is a special case of cyclic ranking with cycle 2, and we show that the cyclic ranking condition can specify\u00a0\u2026", "num_citations": "34\n", "authors": ["1573"]}
{"title": "Pattern-based refinement of assume-guarantee specifications in reactive synthesis\n", "abstract": " We consider the problem of compositional refinement of components\u2019 specifications in the context of compositional reactive synthesis. Our solution is based on automatic refinement of assumptions and guarantees expressed in linear temporal logic (LTL). We show how behaviors of the environment and the system can be inferred from counter-strategies and strategies, respectively, as formulas in special forms called patterns. Instantiations of patterns are LTL formulas which hold over all runs of such strategies, and are used to refine the specification by adding new input assumptions or output guarantees. We propose three different approaches for compositional refinement of specifications, based on how much information is shared between the components, and demonstrate and compare the methods empirically.", "num_citations": "33\n", "authors": ["1573"]}
{"title": "Instrumenting C programs with nested word monitors\n", "abstract": " In classical automata-theoretic model checking of safety properties\u00a0[6], a system model generates a language L of words modeling system executions, and verification involves checking if L\u2009\u2229\u2009L\u2032\u2009=\u2009\u2205, L\u2032 being the language of words deemed \u201cunsafe\u201d by the specification. This view is also used in recent program analyzers like Blast\u00a0[5] and Slam\u00a0[2], where a specification is a word automaton (or monitor) with finite-state control-flow that accepts all \u201cunsafe\u201d program executions. Typical analysis constructs the \u201cproduct\u201d of a program and a monitor, in effect instrumenting the program with extra commands and assertions, so that the input program fails its specification if and only if the product program fails an assertion. The latter is then checked for possible assertion failures. Monitors also find use in testing and runtime verification, where we try finding assertion violations in the product program at runtime.", "num_citations": "33\n", "authors": ["1573"]}
{"title": "Scenario-based programming for SDN policies\n", "abstract": " Recent emergence of software-defined networks offers an opportunity to design domain-specific programming abstractions aimed at network operators. In this paper, we propose scenario-based programming, a framework that allows network operators to program network policies by describing representative example behaviors. Given these scenarios, our synthesis algorithm automatically infers the controller state that needs to be maintained along with the rules to process network events and update state. We have developed the NetEgg scenario-based programming tool, which can execute the generated policy implementation on top of a centralized controller, but also automatically infers flow-table rules that can be pushed to switches to improve throughput. We study a range of policies considered in the literature and report our experience regarding specifying these policies using scenarios. We evaluate NetEgg\u00a0\u2026", "num_citations": "32\n", "authors": ["1573"]}
{"title": "Scalable scheduling algorithms for wireless networked control systems\n", "abstract": " In this paper, we address the problem of designing scalable scheduling and routing policies over a time-triggered multi-hop control network, when closing a considerable number of control loops on the same network. The key idea is to formally define by means of regular languages the set of schedules for each control loop that satisfy a given control specification, and to exploit operators on regular languages to compute the set of schedules for the whole system. In order to test our methodology, we address a mineral floatation control problem derived from the Boliden (a Swedish mining company) mine in Garpenberg, and propose a scheduling solution that can be implemented on systems compliant with communication protocols for wireless networks (e.g. the WirelessHART specification).", "num_citations": "32\n", "authors": ["1573"]}
{"title": "Structured modeling of concurrent stochastic hybrid systems\n", "abstract": " We propose a modeling language for structured specification of interacting components with both hybrid and stochastic dynamics. The behavior of a stochastic hybrid agent is described using a hybrid automaton whose dynamics is specified by stochastic differential equations and probabilistic jumps. Stochastic hybrid agents interact with other agents using shared variables. The operations of parallel composition, instantiation and hiding are defined to allow hierarchical descriptions of complex agents. We report on a stochastic extension of the modeling environment Charon for hybrid systems, a simulation tool, and case studies using the tool.", "num_citations": "30\n", "authors": ["1573"]}
{"title": "Decision problems for additive regular functions\n", "abstract": " Additive Cost Register Automata (ACRA) map strings to integers using a finite set of registers that are updated using assignments of the form \u201cx:\u2009=\u2009y\u2009+\u2009c\u201d at every step. The corresponding class of additive regular functions has multiple equivalent characterizations, appealing closure properties, and a decidable equivalence problem. In this paper, we solve two decision problems for this model. First, we define the register complexity of an additive regular function to be the minimum number of registers that an ACRA needs to compute it. We characterize the register complexity by a necessary and sufficient condition regarding the largest subset of registers whose values can be made far apart from one another. We then use this condition to design a pspace algorithm to compute the register complexity of a given ACRA, and establish a matching lower bound. Our results also lead to a machine-independent\u00a0\u2026", "num_citations": "29\n", "authors": ["1573"]}
{"title": "On-the-fly reachability and cycle detection for recursive state machines\n", "abstract": " Searching the state space of a system using enumerative and on-the-fly depth-first traversal is an established technique for model checking finite-state systems. In this paper, we propose algorithms for on-the-fly exploration of recursive state machines, or equivalently pushdown systems, which are suited for modeling the behavior of procedural programs. We present algorithms for reachability (is a bad state reachable?) as well as for fair cycle detection (is there a reachable cycle with progress?). We also report on an implementation of these algorithms to check safety and liveness properties of recursive boolean programs, and its performance on existing benchmarks.", "num_citations": "29\n", "authors": ["1573"]}
{"title": "Modular strategies for infinite games on recursive graphs\n", "abstract": " In this paper, we focus on solving games in recursive game graphs that can model the control flow of sequential programs with recursive procedure calls. The winning condition is given as an \u03c9-regular specification over the observable, and, unlike traditional pushdown games, the strategy is required to be modular: resolution of choices within a component should not depend on the context in which the component is invoked, but only on the history within the current invocation of the component. We first consider the case when the specification is given as a deterministic B\u00fcchi automaton. We show the problem to be decidable, and present a solution based on two-way alternating tree automata with time complexity that is polynomial in the number of internal nodes, exponential in the specification and exponential in the number of exits of the components. We show that the problem is Exptime-complete in\u00a0\u2026", "num_citations": "29\n", "authors": ["1573"]}
{"title": "Deciding global partial-order properties\n", "abstract": " Model checking of asynchronous systems is traditionally based on the interleaving model, where an execution is modeled by a total order between events. Recently, the use of partial order semantics that allows independent events of concurrent processes to be unordered is becoming popular. Temporal logics that are interpreted over partial orders allow specifications relating global snapshots, and permit reduction algorithms to generate only one representative linearization of every possible partial-order execution during state-space search. This paper considers the satisfiability and the model checking problems for temporal logics interpreted over partially ordered sets of global configurations. For such logics, only undecidability results have been proved previously. In this paper, we present an Expspace decision procedure for a fragment that contains an eventuality operator and its dual. We also sharpen\u00a0\u2026", "num_citations": "29\n", "authors": ["1573"]}
{"title": "Compositional synthesis of reactive controllers for multi-agent systems\n", "abstract": " In this paper we consider the controller synthesis problem for multi-agent systems that consist of a set of controlled and uncontrolled agents. Controlled agents may need to cooperate with each other and react to the actions of uncontrolled agents in order to fulfill their objectives. Besides, the controlled agents may be imperfect, i.e., only partially observe their environment, for example due to the limitations in their sensors. We propose a framework for controller synthesis based on compositional reactive synthesis. We implement the algorithms symbolically and apply them to a robot motion planning case study where multiple robots are placed on a grid-world with static obstacles and other dynamic, uncontrolled and potentially adversarial robots. We consider different objectives such as collision avoidance, keeping a formation and bounded reachability. We show that by taking advantage of the structure of the\u00a0\u2026", "num_citations": "28\n", "authors": ["1573"]}
{"title": "Modular strategies for recursive game graphs\n", "abstract": " In this paper, we focus on solving games in recursive game graphs that can model the control flow in sequential programs with recursive procedure calls. While such games can be viewed as the pushdown games studied in the literature, the natural notion of winning in our framework requires the strategies to be modular with only local memory; that is, resolution of choices within a module does not depend on the context in which the module is invoked, but only on the history within the current invocation of the module. While reachability in (global) pushdown games is known to be EXPTIME-complete, we show reachability in modular games to be NP-complete. We present a fixpoint computation algorithm for solving modular games such that the worst-case number of iterations is exponential in the total number of returned values from the modules. If the strategy within a module does not depend on the global\u00a0\u2026", "num_citations": "28\n", "authors": ["1573"]}
{"title": "A composable specification language for reinforcement learning tasks\n", "abstract": " Reinforcement learning is a promising approach for learning control policies for robot tasks. However, specifying complex tasks (e.g., with multiple objectives and safety constraints) can be challenging, since the user must design a reward function that encodes the entire task. Furthermore, the user often needs to manually shape the reward to ensure convergence of the learning algorithm. We propose a language for specifying complex control tasks, along with an algorithm that compiles specifications in our language into a reward function and automatically performs reward shaping. We implement our approach in a tool called SPECTRL, and show that it outperforms several state-of-the-art baselines.", "num_citations": "24\n", "authors": ["1573"]}
{"title": "Bounded model checking for GSMP models of stochastic real-time systems\n", "abstract": " Model checking is a popular algorithmic verification technique for checking temporal requirements of mathematical models of systems. In this paper, we consider the problem of verifying bounded reachability properties of stochastic real-time systems modeled as generalized semi-Markov processes (GSMP). While GSMPs is a rich model for stochastic systems widely used in performance evaluation, existing model checking algorithms are applicable only to subclasses such as discrete-time or continuous-time Markov chains. The main contribution of the paper is an algorithm to compute the probability that a given GSMP satisfies a property of the form \u201ccan the system reach a target before time T within k discrete events, while staying within a set of safe states\u201d. For this, we show that the probability density function for the remaining firing times of different events in a GSMP after k discrete events can be effectively\u00a0\u2026", "num_citations": "24\n", "authors": ["1573"]}
{"title": "Exploiting behavioral hierarchy for efficient model checking\n", "abstract": " Inspired by the success of model checking in hardware and protocol verification, model checking techniques for software have been the focus of a lot of research in the last few years [5,3,2,6]. Model checking can be applied only to relatively small models due to its inherently high computational requirements, and there are two complementary trends to address scalability. The model extraction approach, exemplified by projects such as Bandera [6] and SLAM [3], involves constructing inputs to model checkers by abstracting programs written in languages such as C and Java. The model-based design approach, exemplified by modeling notations such as Statecharts [7], promotes design using high-level models that are compiled into code. Our research agenda is to develop model checking techniques for model-based design of software.", "num_citations": "24\n", "authors": ["1573"]}
{"title": "Fast timing-based algorithms\n", "abstract": " Concurrent systems in which there is a known upper bound \u0394 on memory access time are considered. Two prototypical synchronization problems, mutual exclusion and consensus, are studied, and solutions that have constant (i.e. independent of \u0394 and the total number of processes) time complexity in the absence of contention are presented. For mutual exclusion, in the absence of contention, a process needs only five accesses to the shared memory to enter its critical section, and in the presence of contention, the winning process may need to delay itself for 4\u2009\u22c5\u2009\u0394 time units. For consensus, in absence of contention, a process decides after four accesses to the shared memory, and in the presence of contention, it may need to delay itself for \u0394 time units.", "num_citations": "24\n", "authors": ["1573"]}
{"title": "Optimal scheduling for constant-rate multi-mode systems\n", "abstract": " Constant-rate multi-mode systems are hybrid systems that can switch freely among a finite set of modes, and whose dynamics is specified by a finite number of real-valued variables with mode-dependent constant rates. The schedulability problem for such systems is to design a mode-switching policy that maintains the state within a specified safety set. The main result of the paper is that schedulability can be decided in polynomial time. We also generalize our result to optimal schedulability problems with average cost and reachability cost objectives. Polynomial-time scheduling algorithms make this class an appealing formal model for design of energy-optimal policies. The key to tractability is that the only constraints on when a scheduler can switch the mode are specified by global objectives. Adding local constraints by associating either invariants with modes, or guards with mode switches, lead to undecidability\u00a0\u2026", "num_citations": "23\n", "authors": ["1573"]}
{"title": "Automatic synthesis of distributed protocols\n", "abstract": " Protocols for coordination among concurrent processes are an essential component of modern multiprocessor and distributed systems. The multitude of behaviors arising due to asynchronous concurrency makes the design of such protocols difficult, and consequently analyzing such protocols has been a central theme of research in formal verification for decades [25, 35, 13, 32]. Sustained research in improving verification tools has resulted in powerful heuristics for coping with the computational intractability of problems such as Boolean satisfiability and search through the state-space of concurrent systems [11, 26, 15]. Now that automated verification tools are mature enough to be applied to debugging of real-world protocols [12, 33, 23], the new research frontier is protocol synthesis for simplifying the design process via more intuitive programming abstractions for specifying the desired behavior.Traditionally a\u00a0\u2026", "num_citations": "22\n", "authors": ["1573"]}
{"title": "Software model checking using languages of nested trees\n", "abstract": " While model checking of pushdown systems is by now an established technique in software verification, temporal logics and automata traditionally used in this area are unattractive on two counts. First, logics and automata traditionally used in model checking cannot express requirements such as pre/post-conditions that are basic to analysis of software. Second, unlike in the finite-state world, where the \u03bc-calculus has a symbolic model-checking algorithm and serves as an \u201cassembly language\u201d to which temporal logics can be compiled, there is no common formalism\u2014either fixpoint-based or automata-theoretic\u2014to model-check requirements on pushdown models. In this article, we introduce a new theory of temporal logics and automata that addresses the above issues, and provides a unified foundation for the verification of pushdown systems. The key idea here is to view a program as a generator of structures\u00a0\u2026", "num_citations": "22\n", "authors": ["1573"]}
{"title": "Litmus tests for comparing memory consistency models: How long do they need to be?\n", "abstract": " Memory consistency litmus tests are small parallel programs that are designed to illustrate subtle differences between memory consistency models by exhibiting different outcomes for different models. In this paper, we show that for a class of memory models that is restricted yet expressive enough to include all store-atomic hardware memory models, litmus tests of a bounded size are sufficient for illustrating differences between memory consistency models in this class. We establish a bound of two threads and no more than six memory access instructions for differentiating litmus tests in this class of models. Thus, we can prove equivalence of two specification of memory consistency models in this class by exploring a bounded number of litmus tests. We build a tool for comparing memory models based on this result, and we use the tool to explore and map the space of this class of models.", "num_citations": "22\n", "authors": ["1573"]}
{"title": "Modular strategies for recursive game graphs\n", "abstract": " Many problems in formal verification and program analysis can be formalized as computing winning strategies for two-player games on graphs. In this paper, we focus on solving games in recursive game graphs which can model the control flow in sequential programs with recursive procedure calls. While such games can be viewed as the pushdown games studied in the literature, the natural notion of winning in our framework requires the strategies to be modular with only local memory; that is, resolution of choices within a module does not depend on the context in which the module is invoked, but only on the history within the current invocation of the module. While reachability in (global) pushdown games is known to be EXPTIME-complete, we show reachability in modular games to be NP-complete. We present a fixed-point computation algorithm for solving modular games such that in the worst case the\u00a0\u2026", "num_citations": "22\n", "authors": ["1573"]}
{"title": "Symbolic computational techniques for solving games\n", "abstract": " Games are useful in modular specification and analysis of systems where the distinction among the choices controlled by different components (for instance, the system and its environment) is made explicit. In this paper, we formulate and compare various symbolic computational techniques for deciding existence of winning strategies. The game structure is given implicitly, and the winning condition is of the form \u201cp until q\u201d for state predicates p and q. The first technique employs symbolic fixpoint computation using ordered binary decision diagrams [8]. The second technique checks for the existence of strategies that ensure winning within k steps, for a user specified bound k, by reduction to the satisfiability of quantified boolean formulas. Finally, the bounded case can also be solved by reduction to satisfiability of ordinary boolean formulas, and we discuss two techniques, one based on encoding the strategy tree, and\u00a0\u2026", "num_citations": "22\n", "authors": ["1573"]}
{"title": "Compositional synthesis with parametric reactive controllers\n", "abstract": " Reactive synthesis with the ambitious goal of automatically synthesizing correct-by-construction controllers from high-level specifications, has recently attracted significant attention in system design and control. In practice, complex systems are often not constructed from scratch but from a set of existing building blocks. For example in robot motion planning, a robot usually has a number of predefined motion primitives that can be selected and composed to enforce a high-level objective. In this paper, we propose a novel framework for synthesis from a library of parametric and reactive controllers. Parameters allow us to take advantage of the symmetry in many synthesis problems. Reactivity of the controllers takes into account that the environment may be dynamic and potentially adversarial. We first show how these controllers can be automatically constructed from parametric objectives specified by the user to form a\u00a0\u2026", "num_citations": "21\n", "authors": ["1573"]}
{"title": "Temporal reasoning for procedural programs\n", "abstract": " While temporal verification of programs is a topic with a long history, its traditional basis\u2014semantics based on word languages\u2014is ill-suited for modular reasoning about procedural programs. We address this issue by defining the semantics of procedural (potentially recursive) programs using languages of nested words and developing a framework for temporal reasoning around it. This generalization has two benefits. First, this style of reasoning naturally unifies Manna-Pnueli-style temporal reasoning with Hoare-style reasoning about structured programs. Second, it allows verification of \u201cnon-regular\u201d properties of specific procedural contexts\u2014e.g., \u201cIf a lock is acquired in a context, then it is released in the same context.\u201d We present proof rules for a variety of properties such as local safety, local response, and staircase reactivity; our rules are sufficient to prove all temporal properties over nested words. We\u00a0\u2026", "num_citations": "21\n", "authors": ["1573"]}
{"title": "Polyhedral flows in hybrid automata\n", "abstract": " A hybrid automaton is a mathematical model for hybrid systems, which combines, in a single formalism, automaton transitions for capturing discrete updates with differential constraints for capturing continuous flows. Formal verification of hybrid automata relies on symbolic fixpoint computation procedures that manipulate sets of states. These procedures can be implemented using boolean combinations of linear constraints over system variables, equivalently, using polyhedra, for the subclass of linear hybrid automata. In a linear hybrid automaton, the flow at each control mode is given by a rate polytope that constrains the allowed values of the first derivatives. The key property of such a flow is that, given a state-set described by a polyhedron, the set of states that can be reached as time elapses, is also a polyhedron. We call such a flow a polyhedral flow. In this paper, we study if we can generalize the syntax\u00a0\u2026", "num_citations": "18\n", "authors": ["1573"]}
{"title": "How to share an object: A fast timing-based solution\n", "abstract": " We consider the problem of transforming a given sequential implementation of a data structure into a wait-free concurrent implementation. Given the code for different operations of an object that is designed to work under the assumption that only a single process accesses it, we want to construct an implementation that works correctly in a concurrent environment where it may be accessed by many processes. We assume a shared memory model with atomic registers. It is well known that using atomic registers it is impossible to construct concurrent implementations of even very simple objects such as test-and-set bits. However, we show that the knowledge about relative speeds of processes can be used for such implementations. We assume that there is a known upper bound on the time taken by the slowest process to execute a statement involving an access to the shared memory. This timing assumption is very\u00a0\u2026", "num_citations": "18\n", "authors": ["1573"]}
{"title": "Verifying safety of a token coherence implementation by parametric compositional refinement\n", "abstract": " We combine compositional reasoning and reachability analysis to formally verify the safety of a recent cache coherence protocol. The protocol is a detailed implementation of token coherence, an approach that decouples correctness and performance. First, we present a formal and abstract specification that captures the safety substrate of token coherence, and highlights the symmetry in states of the cache controllers and contents of the messages they exchange. Then, we prove that this abstract specification is coherent, and check whether the implementation proposed by the protocol designers is a refinement of the abstract specification. Our refinement proof is parametric in the number of cache controllers, and is compositional as it reduces the refinement checks to individual controllers using a specialized form of assume-guarantee reasoning. The individual refinement obligations are discharged using\u00a0\u2026", "num_citations": "17\n", "authors": ["1573"]}
{"title": "Contention-free complexity of shared memory algorithms\n", "abstract": " Worst-case time complexity is a measure of the maximum time needed to solve a problem over all runs. Contention-free time complexity indicates the maximum time needed when a process executes by itself, without competition from other processes. Since contention is rare in well-designed systems, it is important to design algorithms which perform well in the absence of contention. We study the contention-free time complexity of shared memory algorithms using two measures: step complexity, which counts the number of accesses to shared registers; and register complexity, which measures the number of different registers accessed. Depending on the system architecture, one of the two measures more accurately reflects the elapsed time. We provide lower and upper bounds for the contention-free step and register complexity of solving the mutual exclusion problem as a function of the number of processes and\u00a0\u2026", "num_citations": "17\n", "authors": ["1573"]}
{"title": "Safe schedulability of bounded-rate multi-mode systems\n", "abstract": " Bounded-rate multi-mode systems (BMS) are hybrid systems that can switch freely among a finite set of modes, and whose dynamics is specified by a finite number of real-valued variables with mode-dependent rates that can vary within given bounded sets. The schedulability problem for BMS is defined as an infinite-round game between two players---the scheduler and the environment---where in each round the scheduler proposes a time and a mode while the environment chooses an allowable rate for that mode, and the state of the system changes linearly in the direction of the rate vector. The goal of the scheduler is to keep the state of the system within a pre-specified safe set using a non-Zeno schedule, while the goal of the environment is the opposite. Green scheduling under uncertainty is a paradigmatic example of BMS where a winning strategy of the scheduler corresponds to a robust energy-optimal\u00a0\u2026", "num_citations": "16\n", "authors": ["1573"]}
{"title": "Robust stability of multi-hop control networks\n", "abstract": " We propose formal models for analyzing robustness of multi-hop control networks, where data from sensors to controllers and from controllers to actuators is sent through a multi-hop communication network subject to disruptions. When communication disruptions are long, compared to the speed of the control system, we propose to model them as permanent link failures. We show that the complexity of analyzing such failures is NP-hard, and discuss a way to overcome this limitation for practical cases using compositional analysis. For typical packet transmission errors (errors with short time span), we propose a transient error model where links fail for one time slot independently of the past and of other links. We provide sufficient conditions for almost sure stability (stability with probability one) in presence of transient link failures, and give efficient decision procedures. The last part of the paper deals with errors that\u00a0\u2026", "num_citations": "16\n", "authors": ["1573"]}
{"title": "Model checking: From tools to theory\n", "abstract": " Model checking is often cited as a success story for transitioning and engineering ideas rooted in logics and automata to practice. In this paper, we discuss how the efforts aimed at improving the scope and effectiveness of model checking tools have revived the study of logics and automata leading to unexpected theoretical advances whose impact is not limited to model checking. In particular, we describe how our efforts to add context-free specifications to software model checking led us to the model of nested words as a representation of data with both a linear ordering and a hierarchically nested matching of items. Such dual structure occurs in diverse corners of computer science ranging from executions of structured programs where there is a well-nested matching of entries to and exits from functions and procedures, to XML documents with the hierarchical structure specified by start-tags matched with\u00a0\u2026", "num_citations": "16\n", "authors": ["1573"]}
{"title": "Symbolic analysis for GSMP models with one stateful clock\n", "abstract": " We consider the problem of verifying reachability properties of stochastic real-time systems modeled as generalized semi-Markov processes (GSMPs). The standard simulation-based techniques for GSMPs are not adequate for solving verification problems, and existing symbolic techniques either require memoryless distributions for firing times, or approximate the problem using discrete time or bounded horizon. In this paper, we present a symbolic solution for the case where firing times are random variables over a rich class of distributions, but only one event is allowed to retain its firing time when a discrete change occurs. The solution allows us to compute the probability that such a GSMP satisfies a property of the form \u201ccan the system reach a target, while staying within a set of safe states\u201d. We report on illustrative examples and their analysis using our procedure.", "num_citations": "16\n", "authors": ["1573"]}
{"title": "Formal analysis of hierarchical state machines\n", "abstract": " In hierarchical state machines, the states can be ordinary states or superstates which are state machines themselves. The notion of hierarchical state machines was popularized by the introduction of Statecharts, and exists in various object-oriented software development methodologies. This paper surveys results concerning the impact of hierarchy for formal specification and verification. We present a systematic study of the complexity of model checking problems in presence of hierarchy, the succinctness afforded by hierarchy from a language-theoretic perspective, and heuristics for exploiting hierarchy in model checking tools.", "num_citations": "16\n", "authors": ["1573"]}
{"title": "Automated refinement checking for asynchronous processes\n", "abstract": " We consider the problem of refinement checking for asynchronous processes where refinement corresponds to stutter-closed language inclusion. Since an efficient algorithmic solution to the refinement check demands the construction of a witness that defines the private specification variables in terms of the implementation variables, we first propose a construction to extract a synchronous witness from the specifi- cation. This automatically reduces individual refinement checks to reachability analysis. Second, to alleviate the state-explosion problem during search, we propose a reduction scheme that exploits the visibility information about transitions in a recursive manner based on the architectural hierarchy. Third, we establish compositional and assume-guarantee proof rules for decomposing the refinement check into subproblems. All these techniques work in synergy to reduce the computational\u00a0\u2026", "num_citations": "16\n", "authors": ["1573"]}
{"title": "A model-based approach to integrating security policies for embedded devices\n", "abstract": " Embedded devices like smartcards can now run multiple interacting applications. A particular challenge in this domain is to dynamically integrate diverse security policies. In this paper we show how a framework based on a concise formal model lets us securely customize a payment card equipped with a programmable chip. We present policy automata, a formal model of computations that grant or deny access to a resource. This model combines defeasible logic with state machines, representing complex policies as combinations of simpler modular policies. We use the model in a framework for specifying, merging and analyzing modular policies. This framework is implemented as Polaris, a tool which analyzes policy automata to reveal potential conflicts or redundancies, and compiles automata into Java Card applets.", "num_citations": "15\n", "authors": ["1573"]}
{"title": "Time for logic\n", "abstract": " This column is about the problem of verifying that computing systems relate properly to the passage of physical time. While the crucial importance of the real-time verification problem has long been realized in practice, the problem has stirred the interest of the theory community only recently, and only halfheartedly at that. As far as the authors can tell, the two main arguments that are usually brought forward to justify this negligence run as follows:1. There is no real-time verification problem. The real-time behavior of a program depends on myriad factors such as the operating system and the underlying hardware. Worse, many of these factors are usually hidden from the programmer. If your program misses a real-time deadline by a constant factor, use (or wait for) a faster machine.", "num_citations": "15\n", "authors": ["1573"]}
{"title": "Precise piecewise affine models from input-output data\n", "abstract": " Formal design and analysis of embedded control software relies on mathematical models of dynamical systems, and such models can be hard to obtain. In this paper, we focus on automatic construction of piecewise affine models from input-output data. Given a set of examples, where each example consists of a d-dimensional real-valued input vector mapped to a real-valued output, we want to compute a set of affine functions that covers all the data points up to a specified degree of accuracy, along with a disjoint partitioning of the space of all inputs defined using a Boolean combination of affine inequalities with one region for each of the learnt functions. While traditional machine learning algorithms such as linear regression can be adapted to learn the set of affine functions, we develop new techniques based on automatic construction of interpolants to derive precise guards defining the desired partitioning\u00a0\u2026", "num_citations": "14\n", "authors": ["1573"]}
{"title": "From monadic second-order definable string transformations to transducers\n", "abstract": " Courcelle (1992) proposed the idea of using logic, in particular Monadic second-order logic (MSO), to define graph to graph transformations. Transducers, on the other hand, are executable machine models to define transformations, and are typically studied in the context of string-to-string transformations. Engelfriet and Hoogeboom (2001) studied two-way finite state string-to-string transducers and showed that their expressiveness matches MSO-definable transformations (MSOT). Alur and Cerny (2011) presented streaming transducers-one-way transducers equipped with multiple registers that can store output strings, as an equi-expressive model. Natural generalizations of streaming transducers to string-to-tree (Alur and D'Antoni, 2012) and infinite-string-to-string (Alur, Filiot, and Trivedi, 2012) cases preserve MSO-expressiveness. While earlier reductions from MSOT to streaming transducers used two-way\u00a0\u2026", "num_citations": "14\n", "authors": ["1573"]}
{"title": "Specification and analysis of network resource requirements of control systems\n", "abstract": " We focus on spatially distributed control systems in which measurement and actuation data is sent via a bus shared with other applications. An approach is proposed for specifying and implementing dynamic scheduling policies for the bus with performance guarantees. Specifically, we propose an automata-based scheduler which we automatically generate from a model of the controlled plant and the controller. We show that, in addition to ensuring performance, our approach allows adjustments to dynamic conditions such as varying disturbances and network load. We present a full development path from performance specifications (exponential stability) to a control design and its implementation using Controller Area Network (CAN).", "num_citations": "14\n", "authors": ["1573"]}
{"title": "Modular refinement of hierarchic reactive machines\n", "abstract": " Scalable formal analysis of reactive programs demands integration of modular reasoning techniques with existing analysis tools. Modular reasoning principles such as abstraction, compositional refinement, and assume-guarantee reasoning are well understood for architectural hierarchy that describes the communication structure between component processes, and have been shown to be useful. In this paper, we develop the theory of modular reasoning for behavior hierarchy that describes control structure using hierarchic modes. From Statecharts to UML, behavior hierarchy has been an integral component of many software design languages, but only syntactically. We present the hierarchic reactive modules language that retains powerful features such as nested modes, mode reuse, exceptions, group transitions, history, and conjunctive modes, and yet has a semantic notion of mode hierarchy. We present an\u00a0\u2026", "num_citations": "14\n", "authors": ["1573"]}
{"title": "Heuristics for hierarchical partitioning with application to model checking\n", "abstract": " Given a collection of connected components, it is often desired to cluster together parts of strong correspondence, yielding a hierarchical structure. We address the automation of this process and apply heuristics to battle the combinatorial and computational complexity.               We define a cost function that captures the quality of a structure relative to the connections and favors shallow structures with a low degree of branching. Finding a structure with minimal cost is NP-complete. We present a greedy polynomial-time algorithm that approximates good solutions incrementally by local evaluation of a heuristic function. We argue for a heuristic function based on four criteria: the number of enclosed connections, the number of components, the number of touched connections and the depth of the structure.               We report on an application in the context of formal verification, where our algorithm serves as a\u00a0\u2026", "num_citations": "14\n", "authors": ["1573"]}
{"title": "GPUDrano: Detecting uncoalesced accesses in GPU programs\n", "abstract": " Graphics Processing Units (GPUs) have become widespread and popular over the past decade. Fully utilizing the parallel compute and memory resources that GPUs present remains a significant challenge, however. In this paper, we describe GPUDrano: a scalable static analysis that detects uncoalesced global memory accesses in CUDA programs. Uncoalesced global memory accesses arise when a GPU program accesses DRAM in an ill-structured way, increasing latency and energy consumption. We formalize the GPUDrano static analysis and compare it empirically against a dynamic analysis to demonstrate that false positives are rare for most programs. We implement GPUDrano in LLVM and show that it can run on GPU programs of over a thousand lines of code. GPUDrano finds 133 of the 143 uncoalesced static memory accesses in the popular Rodinia GPU benchmark suite, demonstrating the\u00a0\u2026", "num_citations": "13\n", "authors": ["1573"]}
{"title": "Algorithmic analysis of array-accessing programs\n", "abstract": " For programs whose data variables range over Boolean or finite domains, program verification is decidable, and this forms the basis of recent tools for software model checking. In this article, we consider algorithmic verification of programs that use Boolean variables, and in addition, access a single read-only array whose length is potentially unbounded, and whose elements range over an unbounded data domain. We show that the reachability problem, while undecidable in general, is (1) Pspace-complete for programs in which the array-accessing for-loops are not nested, (2) decidable for a restricted class of programs with doubly nested loops. The second result establishes connections to automata and logics defining languages over data words.", "num_citations": "13\n", "authors": ["1573"]}
{"title": "Quantifying the gap between embedded control models and time-triggered implementations\n", "abstract": " Mapping a set of feedback control components to executable code introduces errors due to a variety of factors such as discretization, computational delays, and scheduling policies. We argue that the gap between the model and the implementation can be rigorously quantified leading to predictability if the implementation is viewed as a sequence of control blocks executed in statically allocated time slots on a time-triggered platform. For linear systems controlled by linear controllers, we show how to calculate the exact error between the model-level semantics and the execution semantics of an implementation, allowing us to compare different implementations. The calculated error of different implementations is demonstrated using simulations on illustrative examples", "num_citations": "12\n", "authors": ["1573"]}
{"title": "Shared variables interaction diagrams\n", "abstract": " Scenario-based specifications offer an intuitive and visual way of describing design requirements of distributed software systems. For the communication paradigm based on messages, message sequence charts (MSC) offer a standardized and formal notation amenable to formal analysis. In this paper we define shared variables interaction diagrams (SVID) as the counterpart of MSCs when processes communicate via shared variables. After formally defining SVIDs, we develop an intuitive as well as formal definition of refinement for SVIDs. This notion provides a basis for systematically adding details to SVID requirements.", "num_citations": "12\n", "authors": ["1573"]}
{"title": "Transducer-based algorithmic verification of retransmission protocols over noisy channels\n", "abstract": " Unreliable communication channels are a practical reality. They add to the complexity of protocol design and verification. In this paper, we consider noisy channels which can corrupt messages. We present an approach to model and verify protocols which combine error detection and error control to provide reliable communication over noisy channels. We call these protocols retransmission protocols as they achieve reliable communication through repeated retransmissions of messages. These protocols typically use cyclic redundancy checks and sliding window protocols for error detection and control respectively. We propose models of these protocols as regular transducers operating on bit strings. Streaming string transducers provide a natural way of modeling these protocols and formalizing correctness requirements. The verification problem is posed as functional equivalence between the protocol\u00a0\u2026", "num_citations": "11\n", "authors": ["1573"]}
{"title": "Model checking of message flow diagrams\n", "abstract": " Model checking for message sequence charts (MSCs), message sequence chart graphs and hierarchical message sequence chart graphs (HMSCs) is provided. To verify the behavior of a given MSC, MSC graph and HMSC, a specification automaton is constructed. This specification automaton specifies the undesirable executions of the model under analysis. From the model under analysis, linearizations are defined from the model and a finite test automaton is constructed from the linearizations. The test automaton and the specification automaton are combined and it is determined whether there is an execution in the intersection. Where no state in the specification automaton is reachable from the test automaton, the model is verified.", "num_citations": "11\n", "authors": ["1573"]}
{"title": "Time-triggered implementations of dynamic controllers\n", "abstract": " Bridging the gap between model-based design and platform-based implementation is one of the critical challenges for embedded software systems. In the context of embedded control systems that interact with an environment, a variety of errors due to quantization, delays, and scheduling policies may generate executable code that does not faithfully implement the model-based design. In this article, we show that the performance gap between the model-level semantics of linear dynamic controllers, for example, the proportional-integral-derivative (PID) controllers and their implementation-level semantics, can be rigorously quantified if the controller implementation is executed on a predictable time-triggered architecture. Our technical approach uses lifting techniques for periodic time-varying linear systems in order to compute the exact error between the model semantics and the execution semantics. Explicitly\u00a0\u2026", "num_citations": "10\n", "authors": ["1573"]}
{"title": "Dispatch sequences for embedded control models\n", "abstract": " We consider the problem of mapping a set of control components to an executable implementation. The standard approach to this problem involves mapping control blocks to periodic tasks, and then generating a schedule. This schedule is platform-dependent, and its execution requires real-time operating system support. We propose an alternative approach which involves generating a dispatch sequence of control blocks in a platform-independent manner. Our solution relies on assigning relative complexity and relative importance measures to control components, and is an adaptation of the classical scheduling algorithms such as earliest\u2013deadline\u2013first. We show the benefits of our approach using simulation experiments on two case studies.", "num_citations": "10\n", "authors": ["1573"]}
{"title": "Compression of partially ordered strings\n", "abstract": " We introduce the problem of compressing partially ordered strings: given string \u03c3\u03b5\u03a3* and a binary independence relation I over \u03a3, how can we compactly represent an input if the decompressor is allowed to reconstruct any string that can be obtained from \u03c3 by repeatedly swapping adjacent independent symbols? Such partially ordered strings are also known as Mazurkiewicz traces, and naturally model executions of concurrent programs. Compression techniques have been applied with much success to sequential program traces not only to store them compactly but to discover important profiling patterns within them. For compression to achieve similar aims for concurrent program traces we should exploit the extra freedom provided by the independence relation.               Many popular string compression schemes are grammar-based schemes that produce a small context-free grammar generating uniquely\u00a0\u2026", "num_citations": "10\n", "authors": ["1573"]}
{"title": "Undecidability of partial order logics\n", "abstract": " In this paper we prove the Undecidability of certain temporal logics over partial orders. Our proof is generic and can be applied to characterize various temporal operators that cannot be used for automatic verification (model checking).", "num_citations": "10\n", "authors": ["1573"]}
{"title": "Compositional and symbolic synthesis of reactive controllers for multi-agent systems\n", "abstract": " We consider the controller synthesis problem for multi-agent systems that consist of a set of controlled and uncontrolled agents. Controlled agents may need to cooperate with each other and react to actions of uncontrolled agents in order to fulfill their objectives. Moreover, agents may be imperfect, i.e., only partially observe their environment. We propose a framework for controller synthesis based on compositional reactive synthesis. We implement the algorithms symbolically and apply them to a robot motion planning case study where multiple robots are placed on a grid-world with static obstacles and other dynamic, uncontrolled and potentially adversarial robots. We consider different objectives such as collision avoidance, keeping a formation and bounded reachability. We show that by taking advantage of the structure of the system, compositional synthesis algorithm can significantly outperform centralized\u00a0\u2026", "num_citations": "9\n", "authors": ["1573"]}
{"title": "An Introduction to the StreamQRE Language.\n", "abstract": " Real-time decision making in emerging IoT applications typically relies on computing quantitative summaries of large data streams in an efficient and incremental manner. We give here an introduction to the StreamQRE language, which has recently been proposed for the purpose of simplifying the task of programming the desired logic in such stream processing applications. StreamQRE provides natural and high-level constructs for processing streaming data, and it offers a novel integration of linguistic constructs from two distinct programming paradigms: streaming extensions of relational query languages and quantitative extensions of regular expressions. The former allows the programmer to employ relational constructs to partition the input data by keys and to integrate data streams from different sources, while the latter can be used to exploit the logical hierarchy in the input stream for modular specifications.", "num_citations": "9\n", "authors": ["1573"]}
{"title": "Colored nested words\n", "abstract": " Nested words allow modeling of linear and hierarchical structure in data, and nested word automata are special kinds of pushdown automata whose push/pop actions are directed by the hierarchical structure in the input nested word. The resulting class of regular languages of nested words has many appealing theoretical properties, and has found many applications, including model checking of procedural programs. In the nested word model, the hierarchical matching of open- and close- tags must be properly nested, and this is not the case, for instance, in program executions in presence of exceptions. This limitation of nested words narrows its model checking applications to programs with no exceptions.                 We introduce the model of colored nested words which allows such hierarchical structures with mismatches. We say that a language of colored nested words is regular if the language obtained by\u00a0\u2026", "num_citations": "9\n", "authors": ["1573"]}
{"title": "Relating average and discounted costs for quantitative analysis of timed systems\n", "abstract": " Quantitative analysis and controller synthesis problems for reactive real-time systems can be formalized as optimization problems on timed automata, timed games, and their probabilistic extensions. The limiting average cost and the discounted cost are two standard criteria for such optimization problems. In theory of finite-state probabilistic systems, a number of interesting results are available relating the optimal values according to these two different performance objectives. These results, however, do not directly apply to timed systems due to the infinite state-space of clock valuations. In this paper, we present some conditions under which the existence of the limit of optimal discounted cost objective implies the the existence of limiting average cost to the same value. Using these results we answer an open question posed by Fahrenberg and Larsen, and give simpler proofs of some known decidability results on\u00a0\u2026", "num_citations": "9\n", "authors": ["1573"]}
{"title": "DiffStream: differential output testing for stream processing programs\n", "abstract": " High performance architectures for processing distributed data streams, such as Flink, Spark Streaming, and Storm, are increasingly deployed in emerging data-driven computing systems. Exploiting the parallelism afforded by such platforms, while preserving the semantics of the desired computation, is prone to errors, and motivates the development of tools for specification, testing, and verification. We focus on the problem of differential output testing for distributed stream processing systems, that is, checking whether two implementations produce equivalent output streams in response to a given input stream. The notion of equivalence allows reordering of logically independent data items, and the main technical contribution of the paper is an optimal online algorithm for checking this equivalence. Our testing framework is implemented as a library called DiffStream in Flink. We present four case studies to illustrate\u00a0\u2026", "num_citations": "8\n", "authors": ["1573"]}
{"title": "Regular functions, cost register automata, and generalized min-cost problems\n", "abstract": " Motivated by the successful application of the theory of regular languages to formal verification of finite-state systems, there is a renewed interest in developing a theory of analyzable functions from strings to numerical values that can provide a foundation for analyzing {\\em quantitative} properties of finite-state systems. In this paper, we propose a deterministic model for associating costs with strings that is parameterized by operations of interest (such as addition, scaling, and ), a notion of {\\em regularity} that provides a yardstick to measure expressiveness, and study decision problems and theoretical properties of resulting classes of cost functions. Our definition of regularity relies on the theory of string-to-tree transducers, and allows associating costs with events that are conditional upon regular properties of future events. Our model of {\\em cost register automata} allows computation of regular functions using multiple \"write-only\" registers whose values can be combined using the allowed set of operations. We show that classical shortest-path algorithms as well as algorithms designed for computing {\\em discounted costs}, can be adopted for solving the min-cost problems for the more general classes of functions specified in our model. Cost register automata with  and increment give a deterministic model that is equivalent to {\\em weighted automata}, an extensively studied nondeterministic model, and this connection results in new insights and new open problems.", "num_citations": "8\n", "authors": ["1573"]}
{"title": "Deciding global partial-order properties\n", "abstract": " Model checking of asynchronous systems is traditionally based on the interleaving model, where an execution is modeled by a total order between atomic events. Recently, the use of partial order semantics, representing the causal order between events, is becoming popular. This paper considers the model checking problem for partial-order temporal logics. Solutions to this problem exist for partial order logics over local states. For the more general global logics that are interpreted over global states, only undecidability results have been proved. In this paper, we present a decision procedure for a partial order temporal logic over global states. We also sharpen the undecidability results by showing that a single until operator is sufficient for undecidability.", "num_citations": "8\n", "authors": ["1573"]}
{"title": "Continuous-time models for system design and analysis\n", "abstract": " We illustrate the ingredients of the state-of-the-art of model-based approach for the formal design and verification of cyber-physical systems. To capture the interaction between a discrete controller and its continuously evolving environment, we use the formal models of timed and hybrid automata. We explain the steps of modeling and verification in the tools Uppaal and SpaceEx using a case study based on a dual-chamber implantable pacemaker monitoring a human heart. We show how to design a model as a composition of components, how to construct models at varying levels of detail, how to establish that one model is an abstraction of another, how to specify correctness requirements using temporal logic, and how to verify that a model satisfies a logical requirement.", "num_citations": "7\n", "authors": ["1573"]}
{"title": "Specifying relaxed memory models for state exploration tools\n", "abstract": " In recent years there is a renewed interest in memory consistency models [5, 6, 2, 4, 7]. Although most of the research on verification and concurrent program implicitly assumes that memory is sequentially consistent, many common microprocessor and compiler optimizations lead to relaxed memory models. To ensure that software behaves correctly under various hardware and software optimizations such as store buffers and statement reordering, both hardware and software designers develop various memory models that aim to capture the trade-offs between optimizations and programmabilty (ie, the ease of writing correct code). there is a large number of different specifications for both hardware and software memory models, such as Sun SPARC\u2019s RMO [12], Intel\u2019s x86 [3] and PowerPC [2] for hardware, and the Java and C++ software memory models. Memory models have been studied extensively during the last 30 years, but most of the earlier work [11, 9, 8, 10, 1] focused on the design of memory models and the way it affects microprocessor design. Recent development in multicore processors and model checking techniques stirred new interest in memory models, focusing on new perspective such as verification of software in the context of weak memory models. One issue we have to tackle while dealing with relaxed memory models is the handling of memory models within state exploration tools. We would like to be able to explore the state space of programs running on a relaxed memory model for two reasons:1. We would like to be able to verify the correctness of a program running on a relaxed memory model. Even though most\u00a0\u2026", "num_citations": "7\n", "authors": ["1573"]}
{"title": "Visibly pushdown tree languages\n", "abstract": " The recently proposed fixpoint calculus VP-\u00b5 allows algorithmic verification of context-free branching-time properties of pushdown models. The calculus is interpreted over structured trees\u2014trees whose edges are tagged as call, return, and local transitions, modeling structured control flow. Its unusual expressive power motivates us to study tree automata and second-order logics over structured trees. We show that VP-\u00b5 indeed defines a robust class of languages by showing its equivalence with alternating visibly pushdown tree automata (VPTA). VPTAs have alternating transition structure, and stack-based control that is constrained so that call and return labels on edges are used as directives for push and pop operations. We also show that monadic second order logic (MSO) cannot exploit the structure: MSO with a predicate matching calls and returns in a structured tree is too strong in the sense that even its\u00a0\u2026", "num_citations": "7\n", "authors": ["1573"]}
{"title": "DISE: Dynamic instruction stream editing\n", "abstract": " Many people deserve thanks for helping me navigate through my PhD. First and foremost, I must thank my wife, Stephanie, for her loving support without which I certainly would not have succeeded. She is a wonderful companion, and I feel like the luckiest man on the planet to be married to her. I thank her for her patience through my many long work days, and for helping me stay sane through my many deadlines. My parents, Art and Nancy, were also extremely supportive throughout my six years in graduate school. I greatly appreciated their loving phone calls, emails, and visits. They have always been there for me. I also must thank, my brother, Ryan, my grandmother, Barbara, as well as Stephanie\u2019s family. Their encouragement and loving support certainly helped me through my PhD. My advisor, E Christopher Lewis, is chiefly responsible for my academic and professional development. I have benefitted profusely from his guidance and support. I learned from E what it means to deeply understand a research problem, and to always consider the broader impact of my research. E is also an incredible teacher, breaking the most complicated concepts down into simple manageable pieces. I will try to emulate these skills", "num_citations": "7\n", "authors": ["1573"]}
{"title": "Block-size independence for GPU programs\n", "abstract": " Optimizing GPU programs by tuning execution parameters is essential to realizing the full performance potential of GPU hardware. However, many of these optimizations do not ensure correctness and subtle errors can enter while optimizing a GPU program. Further, lack of formal models and the presence of non-trivial transformations prevent verification of optimizations.               In this work, we verify transformations involved in tuning the execution parameter, block-size. First, we present a formal programming and execution model for GPUs, and then formalize block-size independence of GPU programs, which ensures tuning block-size preserves program semantics. Next, we present an inter-procedural analysis to verify block-size independence for synchronization-free GPU programs. Finally, we evaluate the analysis on the Nvidia CUDA SDK samples, where 35 global kernels are verified to be block-size\u00a0\u2026", "num_citations": "6\n", "authors": ["1573"]}
{"title": "On the feasibility of automation for bandwidth allocation problems in data centers\n", "abstract": " Mapping virtual networks to physical networks under bandwidth constraints is a key computational problem for the management of data centers. Recently proposed heuristic strategies for this problem work efficiently, but are not guaranteed to always find an allocation even when one exists. Given that the bandwidth allocation problem is NP-complete, and the state-of-the-art SAT solvers have recently been successfully applied to NP-hard problems in planning and formal verification, the goal of this paper is to study whether these SAT solvers can be used to solve the bandwidth allocation problem exactly with acceptable overhead. We investigate alternative ways of encoding the allocation problem, and develop techniques for abstraction and refinement of network graphs for scalability. We report experimental comparisons of the proposed encodings with the existing heuristics for typical data-center topologies.", "num_citations": "6\n", "authors": ["1573"]}
{"title": "Can we verify cyber-physical systems? technical perspective\n", "abstract": " Can we verify cyber-physical systems?: technical perspective Page 1 96 CommuniCAtions of the ACm | OCTObER 2013 | vOl. 56 | nO. 10 a lot of research both in formal methods and in control theory communities in recent years. The following paper by Althoff et al. reports a major milestone in this quest. Since formal verification techniques have high computational costs, they need to be applied with a scalpel rather than with a hammer. The authors show great prudence in choosing their target. The design of charge-pump phase-locked loops is representative of both the technical challenges involved in the verification of hybrid systems, and of potential benefits of formal analysis. While the design has clearly specified requirements for stability and settling OvEr ThE PaST few decades, comput- ers have transformed from specialpurpose and standalone numbercrunching processors to networked devices interacting with \u2026", "num_citations": "6\n", "authors": ["1573"]}
{"title": "Plug and play components for the exploration of memory consistency models\n", "abstract": " Modern microprocessors implement many different memory consistency models, some of which have complex semantics. Although most system architects tend to specify memory models in an axiomatic style, executable specifications are useful for memory-model-aware verification of concurrent programs. In this paper, we describe a modular approach for executable specifications of memory models. We identify five different components that capture commonly occurring features of memory models. We show that these components can be combined together in different configurations in order to specify many existing memory models, including the three SPARC memory models, as well as non-storeatomic models that capture the essence of the x86 and PowerPC memory models.", "num_citations": "6\n", "authors": ["1573"]}
{"title": "Methods, systems, and computer readable media for generating software defined networking (SDN) policies\n", "abstract": " Methods, systems, and computer readable media for generating SDN policies are disclosed. One system includes a processor and a memory. The system also includes an SDN policy synthesizer (SPS) implemented using the processor and the memory. The SPS is configured to receive scenario based information indicating one or more behaviors for at least one SDN policy, to use a synthesis algorithm for generating the at least one SDN policy based on the scenario based information, and to provide the at least one SDN policy to an SDN controller.", "num_citations": "5\n", "authors": ["1573"]}
{"title": "Trends and challenges in algorithmic software verification\n", "abstract": " Recent years have witnessed remarkable progress in principles and tools for automated software verification. In this position paper, I briefly discuss the relevant projects in my group, and outline some near-term challenges for the community as concrete milestones for measuring progress.", "num_citations": "5\n", "authors": ["1573"]}
{"title": "An algorithmic approach to the specification verification of hybrid systems\n", "abstract": " \u30cf\u30a4\u30d6\u30ea\u30c3\u30c9\u30c0\u30a4\u30ca\u30df\u30ab\u30eb\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u89e3\u6790 (\u300c\u30cf\u30a4\u30d6\u30ea\u30c3\u30c9\u30b7\u30b9\u30c6\u30e0: \u30b7\u30b9\u30c6\u30e0\u5236\u5fa1\u3078\u306e\u65b0\u305f\u306a\u8996\u70b9\u7dcf\u5408\u7279\u96c6\u53f7\u300d)", "num_citations": "5\n", "authors": ["1573"]}
{"title": "On the complexity of shortest path problems on discounted cost graphs\n", "abstract": " Discounted Cost Register Automata (DCRA) associate costs with strings in a regular manner using the operation of discounted sum. The min-cost optimization problem for DCRAs corresponds to computing shortest paths in graphs with more general forms of discounting than the well-studied notion of future discounting. We present solutions to two classes of such shortest path problems: in presence of both past and future discounting, we show the decision problem is NP-complete, but has a polynomial-time approximation scheme; in presence of two future discounting criteria that are composed in a prioritized manner, we show that the problem is solvable in Nexptime.", "num_citations": "4\n", "authors": ["1573"]}
{"title": "Active learning of plans for safety and reachability goals with partial observability\n", "abstract": " Traditional planning assumes reachability goals and/or full observability. In this paper, we propose a novel solution for  safety and reachability planning  with  partial observability . Given a planning domain, a safety property, and a reachability goal, we automatically learn a  safe permissive plan  to guide the planning domain so that the safety property is not violated and that can force the planning domain to eventually reach states that satisfy the reachability goal, regardless of how the planning domain behaves. Our technique is based on the  active learning of regular languages  and  symbolic model checking . The planning method first learns a safe plan using the  L   *  algorithm, which is an efficient active learning algorithm for regular languages. We then check whether the safe plan learned is also permissive by Alternating-time Temporal Logic (ATL) model checking. If the plan is permissive, it is indeed a safe\u00a0\u2026", "num_citations": "4\n", "authors": ["1573"]}
{"title": "Variable reuse for efficient image computation\n", "abstract": " Image computation, that is, computing the set of states reachable from a given set in one step, is a crucial component in typical tools for BDD-based symbolic reachability analysis. It has been shown that the size of the intermediate BDDs during image computation can be dramatically reduced via conjunctive partitioning of the transition relation and ordering the conjuncts for facilitating early quantification. In this paper, we propose to enhance the effectiveness of these techniques by reusing the quantified variables. Given an ordered set of conjuncts, if the last conjunct that uses a variable u appears before the first conjunct that uses another variable v, then v can be renamed to u, assuming u will be quantified immediately after its last use. In general, multiple variables can share the same identifier so the BDD nodes that are inactive but not garbage collected may be activated. We give a polynomial\u00a0\u2026", "num_citations": "4\n", "authors": ["1573"]}
{"title": "Predictable programs in barcodes\n", "abstract": " We explore the challenges for making the programming interfaces for embedded devices open and safe, and present a prototype architecture for delivering verified programs using barcodes. In particular, we consider programs for microwave ovens, which provide a basic open API for controlling cooking times. In our architecture, recipes are written in Java, and their safety properties are formally verified using the model checker Spin. We use off-the-shelf utilities for compressing the byte code, and use two-dimensional barcodes for program delivery. We report on experiments that demonstrate the feasibility of the proposed architecture for predictability and delivery.", "num_citations": "4\n", "authors": ["1573"]}
{"title": "Model-based Design of Embedded Software\n", "abstract": " Traditional control engineering provides mathematical tools for designing control laws for dynamical systems. Programming languages and software engineering, while rich in techniques for layering and structuring of complex software with multiple features and concurrency, abstract from real-time and dynamics. As software embedded in physical devices gets complex and distributed, the emerging discipline of hybrid systems that combines control engineering and software science, can provide the foundation for systematic design. This paper outlines promising research directions for modeling and analysis of embedded systems for improved design automation and increased safety.", "num_citations": "4\n", "authors": ["1573"]}
{"title": "Reactive modules\n", "abstract": " We present af ormal model for concurrent systems. The model represents synchronous and asyn-chronous components in a uniform framework that supports compositional (assume-guarantee) and hierarchical (stepwise refinement) reasoning. While syn-chronous models are based on a notion of atomic com-putation step, and asynchronous models remove that notion by introducing stuttering, our model is based on a flexible notion of what constitutes a computation step: by applying an abstraction operator to a system, arbitrarily many consecutive steps can be collapsed into a single step. The abstraction operator, which may turn an asynchronous system into a synchronous one, allows us to describe systems at various levels of temporal detail. For describing systems at various levels of spatial detail, we use a hiding operator that may turn a synchronous system into an asynchronous one. We illustrate the model with diverse examples from synchronous circuits, asynchronous sharedmemory programs, and synchronous message passing. straction principles for reasoning about such systems.The salient features of our model are scalability along both the space and time axes, and interdefinability of synchronous and asynchronous behavior. Scalability. Scalability along the space axis means that spatial implementation details of a module, such as internal variables and wires, can be hidden from outside observers. Scalability along the time axis means that temporal implemementation details, such as internal computation steps and delays, can be hidden from outside observers.", "num_citations": "4\n", "authors": ["1573"]}
{"title": "Verisig 2.0: Verification of neural network controllers using taylor model preconditioning\n", "abstract": " This paper presents Verisig 2.0, a verification tool for closed-loop systems with neural network (NN) controllers. We focus on NNs with tanh/sigmoid activations and develop a Taylor-model-based reachability algorithm through Taylor model preconditioning and shrink wrapping. Furthermore, we provide a parallelized implementation that allows Verisig 2.0 to efficiently handle larger NNs than existing tools can. We provide an extensive evaluation over 10 benchmarks and compare Verisig 2.0 against three state-of-the-art verification tools. We show that Verisig 2.0 is both more accurate and faster, achieving speed-ups of up\u00a0to 21x and 268x against different tools, respectively.", "num_citations": "3\n", "authors": ["1573"]}
{"title": "Abstract Value Iteration for Hierarchical Reinforcement Learning\n", "abstract": " We propose a novel hierarchical reinforcement learning framework for control with continuous state and action spaces. In our framework, the user specifies subgoal regions which are subsets of states; then, we (i) learn options that serve as transitions between these subgoal regions, and (ii) construct a high-level plan in the resulting abstract decision process (ADP). A key challenge is that the ADP may not be Markov; we propose two algorithms for planning in the ADP that address this issue. Our first algorithm is conservative, allowing us to prove theoretical guarantees on its performance, which help inform the design of subgoal regions. Our second algorithm is a practical one that interweaves planning at the abstract level and learning at the concrete level. In our experiments, we demonstrate that our approach outperforms state-of-the-art hierarchical reinforcement learning algorithms on several challenging benchmarks.", "num_citations": "3\n", "authors": ["1573"]}
{"title": "Branching pushdown tree automata\n", "abstract": " We observe that pushdown tree automata (PTAs) known in the literature cannot express combinations of branching and pushdown properties. This is because a PTA processes the children of a tree node in possibly different control states but with identical stacks. We propose branching pushdown tree automata (BPTAs) as a solution. In a BPTA, a push-move views its matching pops as an unbounded, unordered set of successor moves and can assert existential and universal requirements on them, just the way finite automata on unranked, unordered trees pass requirements to the children of a tree node. We show that BPTAs can express some natural properties and are more expressive than PTAs. Using a small-model theorem, we prove their emptiness problem to be decidable. The problem becomes undecidable, however, if push-moves are allowed to specify the ordering of matching pops.", "num_citations": "3\n", "authors": ["1573"]}
{"title": "Exploiting hierarchical structure for efficient formal verification\n", "abstract": " Model checking is emerging as a practical tool for automated debugging of reactive systems such as embedded controllers and network protocols [9,11]. Since model checking is based on exhaustive state-space exploration, and the size of the state space of a design grows exponentially with the size of the description, scalability remains a challenge. The goal of our recent research has been to develop techniques for exploiting the modular design structure during model checking. Software design notations (e.g. Statecharts [10], Uml) provide rich constructs to facilitate modular descriptions. Instead of destroying this structure by compiling the descriptions into flat state-transition graphs, we are developing algorithms that are optimized for modular descriptions. In this talk, we summarize research concerning two different notions of hierarchy: architectural and behavioral.", "num_citations": "3\n", "authors": ["1573"]}
{"title": "Model-checking for probabilistic real-time system\n", "abstract": " Model-checking is a method of verifying concurrent systems in which a state-graph model of the system behavior is compared with a temporal logic formula. This paper extends model-checking to stochastic real-time systems, whose behavior depends on probabilistic choice and quantitative time. The specification language is TCTL, a branching-time temporal Jogic for expressing real-time properties. We interpret the formulas of the logic over generalized semi-Markov processes. Our model can express constraints like\" the delay between the request and the response is distributed uniformly between 2 to 4 seconds\".We present an algorithm that combines model-checking for real-time non-probabilistic systems with model-checking for finite-state discrete-time Markov chains. The correctness of the algorithm is not obvious, because it analyzes the projection of a Markov process onto a finite state space. The projection process is not Markov, so our most significant result is that the model-checking algorithm works.", "num_citations": "3\n", "authors": ["1573"]}
{"title": "Compositional reinforcement learning from logical specifications\n", "abstract": " We study the problem of learning control policies for complex tasks given by logical specifications. Recent approaches automatically generate a reward function from a given specification and use a suitable reinforcement learning algorithm to learn a policy that maximizes the expected reward. These approaches, however, scale poorly to complex tasks that require high-level planning. In this work, we develop a compositional learning approach, called DIRL, that interleaves high-level planning and reinforcement learning. First, DIRL encodes the specification as an abstract graph; intuitively, vertices and edges of the graph correspond to regions of the state space and simpler sub-tasks, respectively. Our approach then incorporates reinforcement learning to learn neural network policies for each edge (sub-task) within a Dijkstra-style planning algorithm to compute a high-level plan in the graph. An evaluation of the proposed approach on a set of challenging control benchmarks with continuous state and action spaces demonstrates that it outperforms state-of-the-art baselines.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "Example-guided synthesis of relational queries\n", "abstract": " Program synthesis tasks are commonly specified via input-output examples. Existing enumerative techniques for such tasks are primarily guided by program syntax and only make indirect use of the examples. We identify a class of synthesis algorithms for programming-by-examples, which we call Example-Guided Synthesis (EGS), that exploits latent structure in the provided examples while generating candidate programs. We present an instance of EGS for the synthesis of relational queries and evaluate it on 86 tasks from three application domains: knowledge discovery, program analysis, and database querying. Our evaluation shows that EGS outperforms state-of-the-art synthesizers based on enumerative search, constraint solving, and hybrid techniques in terms of synthesis time, quality of synthesized programs, and ability to prove unrealizability.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "Stream processing with dependency-guided synchronization\n", "abstract": " Real-time data processing applications with low latency requirements have led to the increasing popularity of stream processing systems. While such systems offer convenient APIs that can be used to achieve data parallelism automatically, they offer limited support for computations that require synchronization between parallel nodes. In this paper, we propose *dependency-guided synchronization (DGS)*, an alternative programming model and stream processing API for stateful streaming computations with complex synchronization requirements. In the proposed model, the input is viewed as partially ordered, and the program consists of a set of parallelization constructs which are applied to decompose the partial order and process events independently. Our API maps to an execution model called *synchronization plans* which supports synchronization between parallel nodes. Our evaluation shows that APIs offered by two widely used systems -- Flink and Timely Dataflow -- cannot suitably expose parallelism in some representative applications. In contrast, DGS enables implementations with scalable performance, the resulting synchronization plans offer throughput improvements when implemented manually in existing systems, and the programming overhead is small compared to writing sequential code.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "NetEgg: A Scenario-Based Programming Toolkit for SDN Policies\n", "abstract": " Recent emergence of software-defined networks offers an opportunity to design domain-specific programming abstractions aimed at network operators. In this paper, we propose scenario-based programming, a framework that allows network operators to program network policies by describing example behaviors in representative scenarios. Given these scenarios, our synthesis algorithm automatically infers the controller state that needs to be maintained along with the rules to process network events and update state. We have developed the NetEgg scenario-based programming tool, which can execute the generated policy implementation on top of a centralized controller, but also automatically infers flow-table rules that can be pushed to switches to improve throughput. We evaluate the performance of NetEgg based on the computational requirements of our synthesis algorithm as well as the overhead\u00a0\u2026", "num_citations": "2\n", "authors": ["1573"]}
{"title": "Schedulability of bounded-rate multimode systems\n", "abstract": " Bounded-rate multimode systems are hybrid systems that switch freely among a finite set of modes, and whose dynamics are specified by a finite number of real-valued variables with mode-dependent rates that vary within given bounded sets. The scheduler repeatedly proposes a time and a mode, while the environment chooses an allowable rate for that mode; the state of the system changes linearly in the direction of the rate. The scheduler aims to keep the state within a safe set, while the environment aims to leave it. We study the problem of existence of a winning scheduler strategy and associated complexity questions.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "Generating litmus tests for contrasting memory consistency models-extended version\n", "abstract": " Well-defined memory consistency models are necessary for writing correct parallel software. Developing and understanding formal specifications of hardware memory models is a challenge due to the subtle differences in allowed reorderings and different specification styles. To facilitate exploration of memory model specifications, we have developed a technique for systematically comparing hardware memory models specified using both operational and axiomatic styles. Given two specifications, our approach generates all possible multi-threaded programs up to a specified bound, and for each such program, checks if one of the models can lead to an observable behavior not possible in the other model. When the models differs, the tool finds a minimal \u201clitmus test\u201d program that demonstrates the difference. A number of optimizations reduce the number of programs that need to be examined. Our prototype implementation has successfully compared both axiomatic and operational specifications of six different hardware memory models. We describe two case studies:(1) development of a non-store atomic variant of an existing memory model, which illustrates the use of the tool while developing a new memory model, and (2) identification of a subtle specification mistake in a recently published axiomatic specification of TSO.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "The benefits of exposing calls and returns\n", "abstract": " Regular languages have robust theoretical foundations leading to numerous applications including model checking. Context-free languages and pushdown automata have been indispensable in program analysis due to their ability to model control flow in procedural languages, but the corresponding theory is fragile. In particular, non-closure under intersection and undecidability of the language inclusion problem disallows context-free specifications in model checking applications.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "of host publication\n", "abstract": " The limitations of the deterministic formulation of scheduling are outlined and a probabilistic approach is motivated. A number of models are reviewed with one being chosen as a basic framework. Response-time analysis is extended to incorporate a probabilistic characterisation of task arrivals and execution times. Copulas are used to represent dependencies.", "num_citations": "2\n", "authors": ["1573"]}
{"title": "A Framework for Transforming Specifications in Reinforcement Learning\n", "abstract": " Reactive synthesis algorithms allow automatic construction of policies to control an environment modeled as a Markov Decision Process (MDP) that are optimal with respect to high-level temporal logic specifications assuming the MDP model is known a priori. Reinforcement learning algorithms, in contrast, are designed to learn an optimal policy when the transition probabilities of the MDP are unknown, but require the user to associate local rewards with transitions. The appeal of high-level temporal logic specifications has motivated research to develop RL algorithms for synthesis of policies from specifications. To understand the techniques, and nuanced variations in their theoretical guarantees, in the growing body of resulting literature, we develop a formal framework for defining transformations among RL tasks with different forms of objectives. We define the notion of sampling-based reduction to relate two MDPs whose transition probabilities can be learnt by sampling, followed by formalization of preservation of optimal policies, convergence, and robustness. We then use our framework to restate known results, establish new results to fill in some gaps, and identify open problems.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Compositional Learning and Verification of Neural Network Controllers\n", "abstract": " Recent advances in deep learning have enabled data-driven controller design for autonomous systems. However, verifying safety of such controllers, which are often hard-to-analyze neural networks, remains a challenge. Inspired by compositional strategies for program verification, we propose a framework for compositional learning and verification of neural network controllers. Our approach is to decompose the task (e.g., car navigation) into a sequence of subtasks (e.g., segments of the track), each corresponding to a different mode of the system (e.g., go straight or turn). Then, we learn a separate controller for each mode, and verify correctness by proving that (i) each controller is correct within its mode, and (ii) transitions between modes are correct. This compositional strategy not only improves scalability of both learning and verification, but also enables our approach to verify correctness for arbitrary\u00a0\u2026", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Network Traffic Classification by Program Synthesis.\n", "abstract": " Writing classification rules to identify interesting network traffic is a time-consuming and error-prone task. Learning-based classification systems automatically extract such rules from positive and negative traffic examples. However, due to limitations in the representation of network traffic and the learning strategy, these systems lack both expressiveness to cover a range of applications and interpretability in fully describing the traffic\u2019s structure at the session layer. This paper presents Sharingan system, which uses program synthesis techniques to generate network classification programs at the session layer. Sharingan accepts raw network traces as inputs and reports potential patterns of the target traffic in NetQRE, a domain specific language designed for specifying session-layer quantitative properties. We develop a range of novel optimizations that reduce the synthesis time for large and complex tasks to a matter of minutes. Our experiments show that Sharingan is able to correctly identify patterns from a diverse set of network traces and generates explainable outputs, while achieving accuracy comparable to state-of-the-art learning-based systems.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Hedging bets in Markov decision processes\n", "abstract": " The classical model of Markov decision processes with costs or rewards, while widely used to formalize optimal decision making, cannot capture scenarios where there are multiple objectives for the agent during the system evolution, but only one of these objectives gets actualized upon termination. We introduce the model of Markov decision processes with alternative objectives (MDPAO) for formalizing optimization in such scenarios. To compute the strategy to optimize the expected cost/reward upon termination, we need to figure out how to balance the values of the alternative objectives. This requires analysis of the underlying infinite-state process that tracks the accumulated values of all the objectives. While the decidability of the problem of computing the exact optimal strategy for the general model remains open, we present the following results. First, for a Markov chain with alternative objectives, the optimal expected cost/reward can be computed in polynomial-time. Second, for a single-state process with two actions and multiple objectives we show how to compute the optimal decision strategy. Third, for a process with only two alternative objectives, we present a reduction to the minimum expected accumulated reward problem for one-counter MDPs, and this leads to decidability for this case under some technical restrictions. Finally, we show that optimal cost/reward can be approximated up to a constant additive factor for the general problem.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Interfaces for Control Components.\n", "abstract": " Interfaces for Control Components Page 1 Interfaces for Control Components Rajeev Alur University of Pennsylvania Joint work with Gera Weiss (and many others) Page 2 Interface-based Control Design Interface: Simplified description useful for system integration Control Designs Implementation Platforms Page 3 Interface Specs: Desirable Properties Compositional: Design each component in isolation Dependable: If interface spec is satisfied, performance goals are met Separation of concerns: Between control and software engineers Analyzability: Tool support to check if all interface specs can be met Page 4 Execution Period as Interface Spec Interface: Period at which sense-compute-actuate cycle to be executed Control Designer: Does sampling frequency ensure performance spec? Discrete-time control theory 3 ms 5 ms System Integrator: Can resource requirements of all the components be met? Platform-\u2026", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Verification and integration of real-time control software\n", "abstract": " Realizing the potential of networked embedded control systems will be predicated upon our ability to produce embedded software that can effectively and safely harness the functionality of sensors and processors. Embedded software is different, and more demanding, than the typical programming applications in many ways. Modern programming languages abstract away from real time and resources, and do not provide adequate support for embedded applications. Consequently, current development of embedded software requires significant low-level manual effort for scheduling and component assembly. This is inherently error-prone, timeconsuming, and platform-dependent. Consequently, developing novel programming and implementation methodology for synthesizing portable, predictable embedded software is an important challenge for networked control systems. In this abstract, we briefly discuss some\u00a0\u2026", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Learning plans for safety and reachability goals with partial observability\n", "abstract": " Traditional planning assumes reachability goals and/or full observability. In this paper, we propose a novel solution for safety and reachability planning with partial observability. Given a planning domain, a safety property, and a reachability goal, we automatically learn a safe and permissive plan to guide the planning domain so that the safety property is not violated and which can force the planning domain to eventually reach states satisfying the reachability goal no matter how the planning domain behaves. Our technique is based on active learning of regular languages and symbolic model checking. We describe an implementation of the proposed technique and demonstrate that the tool can efficiently construct safe and permissive plans for four examples.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Coherency of Shared Memory in Ad-hoc Networks\n", "abstract": " Memory coherence is a commonly accepted correctness criterion for distributed shared-memory computing platforms. Coherence is formulated assuming a static architecture in which all processors can communicate with one another. In this paper, we argue that the classical notion is not appropriate for ad-hoc networks consisting of mobile devices with constantly changing communication topology. We introduce and formalize a new correctness criterion, called group coherence, as a suitable abstract specification for shared-memory computing architectures over ad-hoc networks. We show that two existing systems, the Coda file system and Lampson\u2019s global naming scheme, satisfy our definition. Finally, we propose a timestamp-based extension of the popular Snoopy cache coherence protocol for caching in ad-hoc networks, and show it to be group coherent.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Linear Hybrid Automata\n", "abstract": " 1. Linearity: For every control mode v 2 V, the ow condition ow (v), the invariant condition inv (v), and the initial condition init (v) are linear expressions. For every control switch e 2 E, the jump condition Jump (e) is a linear expression.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Efficient formal verification of hierarchical descriptions\n", "abstract": " Model checking is emerging as a practical tool for detecting logical errors in early stages of system design. We investigate the model checking of hierarchical (nested) systems, i.e. finite state machines whose states themselves can be other machines. This nesting ability is common in various software design methodologies and is available in several commercial modeling tools. The straightforward way to analyze a hierarchical machine is to flatten it (thus, incurring an exponential blow up) and apply a model checking tool on the resulting ordinary FSM.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "Next steps in formal verification\n", "abstract": " Case studies in recent years have demonstrated that formal methods can indeed play a role in the design of complex distributed systems. What can we do to ensure that our techniques are applicable to a larger class of systems and are adopted by more industries? Here are some thoughts pertaining to this challenge.", "num_citations": "1\n", "authors": ["1573"]}
{"title": "E cient reachability analysis of hierarchical reactive machines\n", "abstract": " Hierarchical state machines is a popular visual formalism for software speci cations. To apply automated analysis to such specications, the traditional approach is to compile them to existing model checkers. Aimed at exploiting the modular structure more e ectively, our approach is to develop algorithms that work directly on the hierarchical structure. First, we report on an implementation of a visual hierarchical language with modular features such as nested modes, variable scoping, mode reuse, exceptions, group transitions, and history. Then, we identify a variety of heuristics to exploit these modular features during reachability analysis. We report on an enumerative as well as a symbolic checker, and case studies.", "num_citations": "1\n", "authors": ["1573"]}