{"title": "CloudSeer: Workflow Monitoring of Cloud Infrastructures via Interleaved Logs\n", "abstract": " Cloud infrastructures provide a rich set of management tasks that operate computing, storage, and networking resources in the cloud. Monitoring the executions of these tasks is crucial for cloud providers to promptly find and understand problems that compromise cloud availability. However, such monitoring is challenging because there are multiple distributed service components involved in the executions. CloudSeer enables effective workflow monitoring. It takes a lightweight non-intrusive approach that purely works on interleaved logs widely existing in cloud infrastructures. CloudSeer first builds an automaton for the workflow of each management task based on normal executions, and then it checks log messages against a set of automata for workflow divergences in a streaming manner. Divergences found during the checking process indicate potential execution problems, which may or may not be\u00a0\u2026", "num_citations": "138\n", "authors": ["1917"]}
{"title": "You Are What You Do: Hunting Stealthy Malware via Data Provenance Analysis.\n", "abstract": " To subvert recent advances in perimeter and host security, the attacker community has developed and employed various attack vectors to make a malware much stealthier than before to penetrate the target system and prolong its presence. Such advanced malware or \u201cstealthy malware\u201d makes use of various techniques to impersonate or abuse benign applications and legitimate system tools to minimize its footprints in the target system. It is thus difficult for traditional detection tools, such as malware scanners, to detect it, as the malware normally does not expose its malicious payload in a file and hides its malicious behaviors among the benign behaviors of the processes.In this paper, we present PROVDETECTOR, a provenancebased approach for detecting stealthy malware. Our insight behind the PROVDETECTOR approach is that although a stealthy malware attempts to blend into benign processes, its malicious behaviors inevitably interact with the underlying operating system (OS), which will be exposed to and captured by provenance monitoring. Based on this intuition, PROVDETECTOR first employs a novel selection algorithm to identify possibly malicious parts in the OS-level provenance data of a process. It then applies a neural embedding and machine learning pipeline to automatically detect any behavior that deviates significantly from normal behaviors. We evaluate our approach on a large provenance dataset from an enterprise network and demonstrate that it achieves very high detection performance of stealthy malware (an average F1 score of 0.974). Further, we conduct thorough interpretability studies to understand the internals\u00a0\u2026", "num_citations": "29\n", "authors": ["1917"]}
{"title": "Test data generation for derived types in C program\n", "abstract": " Test data generation is one of the important tasks during software testing. This paper proposes an approach to generating test cases automatically for the unit test of C programs with derived types including pointers, structures and arrays. Our approach combines symbolic execution and concrete execution. The approach captures operations on variables precisely by concrete execution, and thus it is capable of handling derived types. Benefited from symbolic execution, accessing variables as array index can be solved by a substitution strategy. The substitution strategy also translates a path constraint involving variables of derived type to the one containing only primitive variables. An implementation of this approach is integrated into our test case generation tool called CAUT. Experimental results show that our approach is effective to generate test data for derived types.", "num_citations": "23\n", "authors": ["1917"]}
{"title": "Adversarial defense framework for graph neural network\n", "abstract": " Graph neural network (GNN), as a powerful representation learning model on graph data, attracts much attention across various disciplines. However, recent studies show that GNN is vulnerable to adversarial attacks. How to make GNN more robust? What are the key vulnerabilities in GNN? How to address the vulnerabilities and defense GNN against the adversarial attacks? In this paper, we propose DefNet, an effective adversarial defense framework for GNNs. In particular, we first investigate the latent vulnerabilities in every layer of GNNs and propose corresponding strategies including dual-stage aggregation and bottleneck perceptron. Then, to cope with the scarcity of training data, we propose an adversarial contrastive learning method to train the GNN in a conditional GAN manner by leveraging the high-level graph representation. Extensive experiments on three public datasets demonstrate the effectiveness of DefNet in improving the robustness of popular GNN variants, such as Graph Convolutional Network and GraphSAGE, under various types of adversarial attacks.", "num_citations": "14\n", "authors": ["1917"]}
{"title": "CloudSeer: using logs to detect errors in the cloud infrastructure\n", "abstract": " Systems and methods are disclosed for detecting error in a cloud infrastructure by running a plurality of training tasks on the cloud infrastructure and generating training execution logs; generating a model miner with the training execution logs to represent one or more correct task executions in the cloud infrastructure; after training, running a plurality of tasks on the cloud infrastructure and capturing live execution logs; and from the live execution logs, if a current task deviates from the correct task execution, indicating an execution error for correction in real-time.", "num_citations": "12\n", "authors": ["1917"]}
{"title": "The verification of rCOS using Spin\n", "abstract": " The rCOS is a relational object-based language with a precise observation-oriented semantics. It can capture key features of object model including subtypes, visibility, inheritance, polymorphism and so on. To analyze the model specified by rCOS, we propose a verification approach to check whether those properties such as the assertion, invariant of class and method contracts hold. The Spin model checker is used in this approach. To enhance the ability of description of concurrency, we extend the original rCOS with parallel structure and synchronization mechanism. The Promela model is constructed from rCOS specification with non-trivial mapping rules. We also present a case study to show how our approach works.", "num_citations": "10\n", "authors": ["1917"]}
{"title": "Towards scalable compositional test generation\n", "abstract": " One difficulty of automated test case generation is to deal with compositional units that brings in compositional space explosion of program states. We present a new dynamic execution framework which analyzes program behaviors dynamically for automatic test inputs generation. We utilize forward slicing to explore those functions affecting conditional predicates in program under test.The functions that do not affect the conditional predicates are not in need of being analyzed symbolically. Pointer alias analysis is adopted to make slicing in the presence of pointers more precise. A dynamic partial execution technique is proposed to accelerate the speed of searching the unit space. The proposed approach can be applied to real programs and the experiments are also very encouraging.", "num_citations": "6\n", "authors": ["1917"]}
{"title": "Vessels: efficient and scalable deep learning prediction on trusted processors\n", "abstract": " Deep learning systems on the cloud are increasingly targeted by attacks that attempt to steal sensitive data. Intel SGX has been proven effective to protect the confidentiality and integrity of such data during computation. However, state-of-the-art SGX systems still suffer from substantial performance overhead induced by the limited physical memory of SGX. This limitation significantly undermines the usability of deep learning systems due to their memory-intensive characteristics.", "num_citations": "5\n", "authors": ["1917"]}
{"title": "{SIGL}: Securing Software Installations Through Deep Graph Learning\n", "abstract": " Many users implicitly assume that software can only be exploited after it is installed. However, recent supply-chain attacks demonstrate that application integrity must be ensured during installation itself. We introduce SIGL, a new tool for detecting malicious behavior during software installation. SIGL collects traces of system call activity, building a data provenance graph that it analyzes using a novel autoencoder architecture with a graph long short-term memory network (graph LSTM) for the encoder and a standard multilayer perceptron for the decoder. SIGL flags suspicious installations as well as the specific installation-time processes that are likely to be malicious. Using a test corpus of 625 malicious installers containing real-world malware, we demonstrate that SIGL has a detection accuracy of 96%, outperforming similar systems from industry and academia by up to 87% in precision and recall and 45% in accuracy. We also demonstrate that SIGL can pinpoint the processes most likely to have triggered malicious behavior, works on different audit platforms and operating systems, and is robust to training data contamination and adversarial attack. It can be used with application-specific models, even in the presence of new software versions, as well as application-agnostic meta-models that encompass a wide range of applications and installers.", "num_citations": "4\n", "authors": ["1917"]}
{"title": "Dataflow Tunneling: Mining Inter-request Data Dependencies for Request-based Applications\n", "abstract": " Request-based applications, e.g., most server-side applications, expose services to users in a request-based paradigm, in which requests are served by request-handler methods. An important task for request-based applications is inter-request analysis, which analyzes request-handler methods that are related by inter-request data dependencies together. However, in the request-based paradigm, data dependencies between related request-handler methods are implicitly established by the underlying frameworks that execute these methods. As a result, existing analysis tools are usually limited to the scope of each single method without the knowledge of dependencies between different methods. In this paper, we design an approach called dataflow tunneling to capture inter-request data dependencies from concrete application executions and produce data-dependency specifications. Our approach answers two\u00a0\u2026", "num_citations": "3\n", "authors": ["1917"]}
{"title": "Execution semantics for rCOS\n", "abstract": " rCOS, the abbreviation of Refinement Calculus for Object Systems, is designed to present mathematical characterization of essential object-oriented concepts for an object-based language with a rich variety of features including subtypes, inheritance, type casting, dynamic binding and polymorphism. This paper represents an operational semantics for the rCOS language based on labeled transition systems. The result semantics shows the process of how the effects of an rCOS program are produced. It can be a secure guide for the implementation of the rCOS language, which is being carried out by our group. For the purpose of extending verifiability and functionality, a set of auxiliary language features is introduced to the rCOS language. Concurrent execution structure is designed to specify multi-threaded programs. Also the simulation is introduced to specify the observable behaviors of objects, and it can be\u00a0\u2026", "num_citations": "3\n", "authors": ["1917"]}
{"title": "{SEAL}: Storage-efficient Causality Analysis on Enterprise Logs with Query-friendly Compression\n", "abstract": " Causality analysis automates attack forensic and facilitates behavioral detection by associating causally related but temporally distant system events. Despite its proven usefulness, the analysis suffers from the innate big data challenge to store and process a colossal amount of system events that are constantly collected from hundreds of thousands of end-hosts in a realistic network. In addition, the effectiveness of the analysis to discover security breaches relies on the assumption that comprehensive historical events over a long span are stored. Hence, it is imminent to address the scalability issue in order to make causality analysis practical and applicable to the enterprise-level environment.", "num_citations": "2\n", "authors": ["1917"]}
{"title": "This is Why We Can\u2019t Cache Nice Things: Lightning-Fast Threat Hunting using Suspicion-Based Hierarchical Storage\n", "abstract": " Recent advances in the causal analysis can accelerate incident response time, but only after a causal graph of the attack has been constructed. Unfortunately, existing causal graph generation techniques are mainly offline and may take hours or days to respond to investigator queries, creating greater opportunity for attackers to hide their attack footprint, gain persistency, and propagate to other machines. To address that limitation, we present Swift, a threat investigation system that provides high-throughput causality tracking and real-time causal graph generation capabilities. We design an in-memory graph database that enables space-efficient graph storage and online causality tracking with minimal disk operations. We propose a hierarchical storage system that keeps forensically-relevant part of the causal graph in main memory while evicting rest to disk. To identify the causal graph that is likely to be relevant\u00a0\u2026", "num_citations": "2\n", "authors": ["1917"]}
{"title": "Understanding and Debugging Complex Software Systems: A Data-Driven Perspective\n", "abstract": " YU, XIAO. Understanding and Debugging Complex Software Systems: A Data-Driven Perspective.(Under the direction of Guoliang Jin.)As the complexity of software systems has been growing rapidly over recent years, the assurance of reliability and performance is facing more and more challenges. One notable challenge lies in the understanding and debugging of complex systems that consist of many interconnected and interdependent subsystems and components. Such internal dependencies with the growing system scale create difficulties for both humans and tools. This dissertation focuses on addressing this challenge by new techniques that build various models from runtime data generated by live systems. The resulting models provide enhanced understanding for system development and management. This dissertation presents three techniques that target at three different but common types of systems: operating systems, cloud infrastructures, and request-based applications. These systems are the major parts of a typical modern software stack. All the three techniques are driven by runtime data that contain useful information for system understanding and debugging, but they differ in analysis purposes and targeted problems. One of these techniques shows how modeling and mining millions of stack traces can help developers spot and diagnose performance problems in real-world Windows installations. This technique can greatly complement the existing testing techniques, which may fail to capture problems that do not appear in the in-house environment. With real-world data, we show that many performance problems are created\u00a0\u2026", "num_citations": "1\n", "authors": ["1917"]}
{"title": "Java design pattern recognition based on relational calculus\n", "abstract": " This paper discussed about the relations both between classes and objects and established the relational calculus about model property. Finally, implemented a tool to check design pattern based on Java language through static and dynamic ways and did experiment based on the tool to verify several user's codes which using design pattern.", "num_citations": "1\n", "authors": ["1917"]}
{"title": "Property Checking for Design Patterns\n", "abstract": " Design patterns have been widely employed as a useful object-oriented technique in software engineering. In this paper, we present an approach to property checking for the application of design patterns in rCOS, which is known as a refinement calculus for object oriented systems. A relational calculus is proposed to specify the pattern properties we would like to check. To construct the abstract model from rCOS instead of analyzing directly on source code, we combine static and dynamic analysis together to achieve better checking efficiency. Class diagrams and object diagrams are obtained with the analysis of rCOS program. The extended operational semantics for rCOS with the object graph is given as the basis for representing object relationships. A general algorithm for calculating relational predicates is presented to perform the property checking. The examples of design patterns from GoF [7], such as abstract factory, builder etc, are also provided to illustrate the effectiveness of our approach from which we can tell whether some patterns are used correctly.", "num_citations": "1\n", "authors": ["1917"]}