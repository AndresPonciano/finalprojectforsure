{"title": "Modular specification and verification of object-oriented programs\n", "abstract": " Software systems play an increasingly important role in modern societies. Smart cards for personal identi? cation, e-banking, software-controlled me-cal tools, airbags in cars, and autopilots for aircraft control are only some examples that illustrate how everyday life depends on the good behavior of software. Consequently, techniques and methods for the development of hi-quality, dependable software systems are a central research topic in computer science. A fundamental approach to this area is to use formal speci? cation and veri? cation. Speci? cation languages allow one to describe the crucial p-perties of software systems in an abstract, mathematically precise, and implementation-independent way. By formal veri? cation, one can then prove that an implementation really has the desired, speci? ed properties. Although this formal methods approach has been a research topic for more than 30 years, its practical success is still restricted to domains in which devel-ment costs are of minor importance. Two aspects are crucial to widen the application area of formal methods:\u2013Formal speci? cation techniques have to be smoothly integrated into the software and program development process.\u2013The techniques have to be applicable to reusable software components. This way, the quality gain can be exploited for more than one system, thereby justifying the higher development costs. Starting from these considerations, Peter Muller \u0308 has developed new te-niques for the formal speci? cation and veri? cation of object-oriented so-ware. The speci? cation techniques are declarative and implementati-independent. They can be used for object-oriented\u00a0\u2026", "num_citations": "386\n", "authors": ["1743"]}
{"title": "Object invariants in dynamic contexts\n", "abstract": " Object invariants describe the consistency of object-oriented data structures and are central to reasoning about the correctness of object-oriented software. Yet, reasoning about object invariants in the presence of object references, methods, and subclassing is difficult. This paper describes a methodology for specifying and verifying object-oriented programs, using object invariants to specify the consistency of data and using ownership to organize objects into contexts. The novelty is that contexts can be dynamic: there is no bound on the number of objects in a context and objects can be transferred between contexts. The invariant of an object is allowed to depend on the fields of the object, on the fields of all objects in transitively-owned contexts, and on fields of objects reachable via given sequences of fields. With these invariants, one can describe a large variety of properties, including properties of cyclic\u00a0\u2026", "num_citations": "296\n", "authors": ["1743"]}
{"title": "Viper: A Verification Infrastructure for Permission-Based Reasoning\n", "abstract": " The automation of verification techniques based on first-order logic specifications has benefitted greatly from verification infrastructures such as Boogie and Why. These offer an intermediate language that can express diverse language features and verification techniques, as well as back-end tools: in particular, verification condition generators.                 However, these infrastructures are not well suited to verification techniques based on separation logic and other permission logics, because they do not provide direct support for permissions and because existing tools for these logics often favour symbolic execution over verification condition generation. Consequently, tool support for these logics (where available) is typically developed independently for each technique, dramatically increasing the burden of developing automatic tools for permission-based verification.                 In this paper, we present a\u00a0\u2026", "num_citations": "246\n", "authors": ["1743"]}
{"title": "A basis for verifying multi-threaded programs\n", "abstract": " Advanced multi-threaded programs apply concurrency concepts in sophisticated ways. For instance, they use fine-grained locking to increase parallelism and change locking orders dynamically when data structures are being reorganized. This paper presents a sound and modular verification methodology that can handle advanced concurrency patterns in multi-threaded, object-based programs. The methodology is based on implicit dynamic frames and uses fractional permissions to support fine-grained locking. It supports concepts such as multi-object monitor invariants, thread-local and shared objects, thread pre- and postconditions, and deadlock prevention with a dynamically changeable locking order. The paper prescribes the generation of verification conditions in first-order logic, well-suited for scrutiny by off-the-shelf SMT solvers. A verifier for the methodology has been implemented for an\u00a0\u2026", "num_citations": "199\n", "authors": ["1743"]}
{"title": "Verification of concurrent programs with Chalice\n", "abstract": " A program verifier is a tool that allows developers to prove that their code satisfies its specification for every possible input and every thread schedule. These lecture notes describe a verifier for concurrent programs called Chalice.                 Chalice\u2019s verification methodology centers around permissions and permission transfer. In particular, a memory location may be accessed by a thread only if that thread has permission to do so. Proper use of permissions allows Chalice to deduce upper bounds on the set of locations modifiable by a method and guarantees the absence of data races for concurrent programs. The lecture notes informally explain how Chalice works through various examples.", "num_citations": "150\n", "authors": ["1743"]}
{"title": "Ownership transfer in universe types\n", "abstract": " Ownership simplifies reasoning about object-oriented programs by controlling aliasing and modifications of objects. Several type systems have been proposed to express and check ownership statically.", "num_citations": "112\n", "authors": ["1743"]}
{"title": "Universes: A Type System for Alias and Dependency Control\n", "abstract": " Universes Anmelden mirmycoremods institutional repository Toggle navigation Suche Erweitert Experte Browsen nach Einrichtung nach Dokumenttyp nach Sachgruppe nach Personen Registrierung Registrierung 0 Merkliste \u00f6ffnen Start Informatik-Berichte Universes auf die Merkliste Abbrechen Buch (Monographie) 2001 Alle Rechte vorbehalten Ver\u00f6ffentlicht Universes : A Type Systems for Alias and Dependency Control M\u00fcller, Peter GND ; Poetzsch-Heffter, Arnd Vorschau Dateien Metadaten In Serie: Informatik-Berichte Vol. 279 Datum der Ver\u00f6ffentlichung: 2001 URN: urn:nbn:de:hbz:708-dh4065 Sprache: Englisch Umfang: 25 Seiten Erscheinungsort: Hagen Verlag: FernUniversit\u00e4t in Hagen DDC-Sachgruppe der DNB: 004 Informatik Einrichtung: Fakult\u00e4t f\u00fcr Mathematik und Informatik Zitieren Zitierform: M\u00fcller , Peter / Poetzsch-Heffter , Arnd: Universes. A Type Systems for Alias and Dependency Control. Hagen \u2026", "num_citations": "107\n", "authors": ["1743"]}
{"title": "A verification methodology for model fields\n", "abstract": " Model fields are specification-only fields that encode abstractions of the concrete state of a data structure. They allow specifications to describe the behavior of object-oriented programs without exposing implementation details.             This paper presents a sound verification methodology for model fields that handles object-oriented features, supports data abstraction, and can be applied to a variety of realistic programs. The key innovation of the methodology is a novel encoding of model fields, where updates of the concrete state do not automatically change the values of model fields. Model fields are updated only by a special pack statement. The methodology guarantees that the specified relation between a model field and the concrete state of an object holds whenever the object is valid, that is, is known to satisfy its invariant.             The methodology also improves on previous work in three significant ways\u00a0\u2026", "num_citations": "94\n", "authors": ["1743"]}
{"title": "Guiding dynamic symbolic execution toward unverified program executions\n", "abstract": " Most techniques to detect program errors, such as testing, code reviews, and static program analysis, do not fully verify all possible executions of a program. They leave executions unverified when they do not check certain properties, fail to verify properties, or check properties under certain unsound assumptions such as the absence of arithmetic overflow.", "num_citations": "86\n", "authors": ["1743"]}
{"title": "Leveraging rust types for modular specification and verification\n", "abstract": " Rust's type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Ensuring correctness properties beyond memory safety, for instance, the guaranteed absence of assertion failures or more-general functional correctness, requires static program verification. For traditional system programming languages, formal verification is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to the more-widespread verification of system software.   In this paper, we present a novel verification technique that leverages Rust's type system to greatly simplify the specification and verification of system software written in Rust. We analyse information from the Rust compiler and\u00a0\u2026", "num_citations": "75\n", "authors": ["1743"]}