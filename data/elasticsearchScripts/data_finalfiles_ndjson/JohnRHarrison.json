{"title": "HOL Light: A tutorial introduction\n", "abstract": " HOL Light is a new version of the HOL theorem prover. While retaining the reliability and programmability of earlier versions, it is more elegant, lightweight, powerful and automatic; it will be the basis for the Cambridge component of the HOL-2000 initiative to develop the next generation of HOL theorem provers. HOL Light is written in CAML Light, and so will run well even on small machines, e.g. PCs and Macintoshes with a few megabytes of RAM. This is in stark contrast to the resource-hungry systems which are the norm in this field, other versions of HOL included. Among the new features of this version axe a powerful simplifier, effective first order automation, simple higher-order matching and very general support for inductive and recursive definitions.             Many theorem provers, model checkers and other hardware verification tools are tied to a particular set of facilities and a particular style of interaction\u00a0\u2026", "num_citations": "418\n", "authors": ["1889"]}
{"title": "Handbook of practical logic and automated reasoning\n", "abstract": " This book meets the demand for a self-contained and broad-based account of the concepts, the machinery and the use of automated reasoning. The mathematical logic foundations are described in conjunction with practical application, all with the minimum of prerequisites. The approach is constructive, concrete and algorithmic: a key feature is that methods are described with reference to actual implementations (for which code is supplied) that readers can use, modify and experiment with. This book is ideally suited for those seeking a one-stop source for the general area of automated reasoning. It can be used as a reference, or as a place to learn the fundamentals, either in conjunction with advanced courses or for self study.", "num_citations": "399\n", "authors": ["1889"]}
{"title": "Theorem proving with the real numbers\n", "abstract": " This book discusses the use of the real numbers in theorem proving. Typ ically, theorem provers only support a few'discrete'datatypes such as the natural numbers. However the availability of the real numbers opens up many interesting and important application areas, such as the verification of float ing point hardware and hybrid systems. It also allows the formalization of many more branches of classical mathematics, which is particularly relevant for attempts to inject more rigour into computer algebra systems. Our work is conducted in a version of the HOL theorem prover. We de scribe the rigorous definitional construction of the real numbers, using a new version of Cantor's method, and the formalization of a significant portion of real analysis. We also describe an advanced derived decision procedure for the'Tarski subset'of real algebra as well as some more modest but practically useful tools for automating explicit calculations and routine linear arithmetic reasoning. Finally, we consider in more detail two interesting application areas. We discuss the desirability of combining the rigour of theorem provers with the power and convenience of computer algebra systems, and explain a method we have used in practice to achieve this. We then move on to the verification of floating point hardware. After a careful discussion of possible correctness specifications, we report on two case studies, one involving a transcendental function.", "num_citations": "326\n", "authors": ["1889"]}
{"title": "Experience with embedding hardware description languages in HOL.\n", "abstract": " The semantics of hardware description languages can be represented in higher order logic. This provides a formal de nition that is suitable for machine processing. Experiments are in progress at Cambridge to see whether this method can be the basis of practical tools based on the HOL theorem-proving assistant. Three languages are being investigated: ELLA, Silage and VHDL. The approaches taken for these languages are compared and current progress on building semantically-based theorem-proving tools is discussed.", "num_citations": "278\n", "authors": ["1889"]}
{"title": "HOL light: An overview\n", "abstract": " HOL Light is an interactive proof assistant for classical higher-order logic, intended as a clean and simplified version of Mike Gordon\u2019s original HOL system. Theorem provers in this family use a version of ML as both the implementation and interaction language; in HOL Light\u2019s case this is Objective CAML (OCaml). Thanks to its adherence to the so-called \u2018LCF approach\u2019, the system can be extended with new inference rules without compromising soundness. While retaining this reliability and programmability from earlier HOL systems, HOL Light is distinguished by its clean and simple design and extremely small logical kernel. Despite this, it provides powerful proof tools and has been applied to some non-trivial tasks in the formalization of mathematics and industrial formal verification.", "num_citations": "227\n", "authors": ["1889"]}
{"title": "A machine-checked theory of floating point arithmetic\n", "abstract": " Intel is applying formal verification to various pieces of mathematical software used in Merced, the first implementation of the new IA-64 architecture. This paper discusses the development of a generic floating point library giving definitions of the fundamental terms and containing formal proofs of important lemmas. We also briefly describe how this has been used in the verification effort so far.", "num_citations": "171\n", "authors": ["1889"]}
{"title": "Metatheory and reflection in theorem proving: A survey and critique\n", "abstract": " One way to ensure correctness of the inference performed by computer theorem provers is to force all proofs to be done step by step in a simple, more or less traditional, deductive system. Using techniques pioneered in Edinburgh LCF, this can be made palatable. However, some believe such an approach will never be e cient enough for large, complex proofs. One alternative, commonly called re ection, is to analyze proofs using a second layer of logic, a metalogic, and so justify abbreviating or simplifying proofs, making the kinds of shortcuts humans often do or appealing to specialized decision algorithms. In this paper we contrast the fully-expansive LCF approach with the use of re ection. We put forward arguments to suggest that the inadequacy of the LCF approach has not been adequately demonstrated, and neither has the practical utility of re ection (notwithstanding its undoubted intellectual interest). The LCF system with which we are most concerned is the HOL proof assistant. The plan of the paper is as follows. We examine ways of providing user extensibility for theorem provers, which naturally places the LCF and re ective approaches in opposition. A detailed introduction to LCF is provided, emphasizing ways in which it can be made e cient. Next, we present a short introduction to metatheory and its usefulness, and, starting from G odel's proofs and Feferman's trans nite progressions of theories, look at logicalre ection principles'. We show how to introduce computationalre ection principles' which do not extend the power of the logic, but may make deductions in it more e cient, and speculate about their practical usefulness. Applications\u00a0\u2026", "num_citations": "169\n", "authors": ["1889"]}
{"title": "A skeptic's approach to combining HOL and Maple\n", "abstract": " We contrast theorem provers and computer algebra systems, pointing out the advantages and disadvantages of each, and suggest a simple way to achieve a synthesis of some of the best features of both. Our method is based on the systematic separation of search for a solution and checking the solution, using a physical connection between systems. We describe the separation of proof search and checking in some detail, relating it to proof planning and to the complexity class NP, and discuss different ways of exploiting a physical link between systems. Finally, the method is illustrated by some concrete examples of computer algebra results proved formally in the HOL theorem prover with the aid of Maple.", "num_citations": "149\n", "authors": ["1889"]}
{"title": "A HOL theory of Euclidean space\n", "abstract": " We describe a formalization of the elementary algebra, topology and analysis of finite-dimensional Euclidean space in the HOL Light theorem prover. (Euclidean space is  with the usual notion of distance.) A notable feature is that the HOL type system is used to encode the dimension N in a simple and useful way, even though HOL does not permit dependent types. In the resulting theory the HOL type system, far from getting in the way, naturally imposes the correct dimensional constraints, e.g. checking compatibility in matrix multiplication. Among the interesting later developments of the theory are a partial decision procedure for the theory of vector spaces (based on a more general algorithm due to Solovay) and a formal proof of various classic theorems of topology and analysis for arbitrary N-dimensional Euclidean space, e.g. Brouwer\u2019s fixpoint theorem and the differentiability of inverse functions.", "num_citations": "135\n", "authors": ["1889"]}
{"title": "Formal verification of floating point trigonometric functions\n", "abstract": " We have formal verified a number of algorithms for evaluat-ing transcendental functions in double-extended precision floating point arithmetic in the Intel\u00ae IA-64 architecture. These algorithms are used in the ItaniumTM processor to provide compatibility with IA-32 (x86) hardware transcendentals, and similar ones are used in mathematical software libraries. In this paper we describe in some depth the formal verification of the sin and cos functions, including the initial range reduction step. This illustrates the diferent facets of verification in this field, covering both pure mathematics and the detailed analysis of floating point rounding.", "num_citations": "132\n", "authors": ["1889"]}
{"title": "The HOL Light theory of Euclidean space\n", "abstract": " We describe the library of theorems about N-dimensional Euclidean space that has been formalized in the HOL Light prover. This formalization was started in 2005 and has been extensively developed since then, partly in direct support of the Flyspeck project, partly out of a general desire to develop a well-rounded and comprehensive theory of basic analytical, geometrical and topological machinery. The library includes various \u2018big name\u2019 theorems (Brouwer\u2019s fixed point theorem, the Stone-Weierstrass theorem, the Tietze extension theorem), numerous non-trivial results that are useful in applications (second mean value theorem for integrals, power series for real and complex transcendental functions) and a host of supporting definitions and lemmas. It also includes some specialized automated proof tools. The library has as planned been applied to the Flyspeck project and has become the basis of a\u00a0\u2026", "num_citations": "124\n", "authors": ["1889"]}
{"title": "Formal proof\u2014theory and practice\n", "abstract": " Aformal proof is a proof written in a precise artificial language that admits only a fixed repertoire of stylized steps. This formal language is usually designed so that there is a purely mechanical process by which the correctness of a proof in the language can be verified. Nowadays, there are numerous computer programs known as proof assistants that can check, or even partially construct, formal proofs written in their preferred proof language. These can be considered as practical, computer-based realizations of the traditional systems of formal symbolic logic and set theory proposed as foundations for mathematics. Why should we wish to create formal proofs? Of course, one may consider it just a harmless and satisfying intellectual activity like solving crosswords or doing Sudoku puzzles and not seek a deeper justification. But we can identify two more substantial reasons:", "num_citations": "120\n", "authors": ["1889"]}
{"title": "Towards self-verification of HOL Light\n", "abstract": " The HOL Light prover is based on a logical kernel consisting of about 400 lines of mostly functional OCaml, whose complete formal verification seems to be quite feasible. We would like to formally verify (i) that the abstract HOL logic is indeed correct, and (ii) that the OCaml code does correctly implement this logic. We have performed a full verification of an imperfect but quite detailed model of the basic HOL Light core, without definitional mechanisms, and this verification is entirely conducted with respect to a set-theoretic semantics within HOL Light itself. We will duly explain why the obvious logical and pragmatic difficulties do not vitiate this approach, even though it looks impossible or useless at first sight. Extension to include definitional mechanisms seems straightforward enough, and the results so far allay most of our practical worries.", "num_citations": "109\n", "authors": ["1889"]}
{"title": "Scientific computing on Itanium-based systems\n", "abstract": " Floating-Point Division 223 normally provides merely an initial approximation to the reciprocal, and software must refine this to the correct quotient. For present purposes, it will be assumed that a correct quotient is one correctly rounded according to the stipulations of the IEEE Standard 754-1985 for binary floating-point arithmetic, including generation of appropriate flags or exceptions [2]. It may be that in certain special situations, for example in graphics applications, such a rigorous approach is not necessary, and it would suffice to have a quotient correct to only the last few bits, or even less. It is relatively easy to adapt the present algorithms for such purposes: they often work by successive improvement of an approximation, and one can more quickly obtain a less accurate result simply by omitting later stages. The algorithms will first be presented in a more mathematically abstract way, ignoring rounding errors except where otherwise indicated. Later the detailed effect of rounding errors and the actual implementation will be considered. Suppose then that frcpa gives a reciprocal approximation where according to the architecture definition, and has at most 11 significant bits. Simply multiplying the initial by gives an approximation to with a relative error slightly larger in the worst case owing to the rounding error committed in calculating", "num_citations": "109\n", "authors": ["1889"]}
{"title": "Floating point verification in HOL light: the exponential function\n", "abstract": " Since they often embody compact but mathematically sophisticated algorithms, operations for computing the common transcendental functions in floating point arithmetic seem good targets for formal verification using a mechanical theorem prover. We discuss some of the general issues that arise in verifications of this class, and then present a machine-checked verification of an algorithm for computing the exponential function in IEEE-754 standard binary floating point arithmetic. We confirm (indeed strengthen) the main result of a previously published error analysis, though we uncover a minor error in the hand proof and are forced to confront several subtle issues that might easily be overlooked informally.", "num_citations": "109\n", "authors": ["1889"]}
{"title": "A Mizar mode for HOL\n", "abstract": " The HOL theorem prover is implemented in the LCF manner. All inference is ultimately reduced to a collection of very simple (forward) primitive inference rules, but by programming it is possible to build alternative means of proving theorems on top, while preserving security. Existing HOL proofs styles are, however, very different from those used in textbooks. Here we describe the addition of another style, inspired by Mizar. We believe the resulting system combines the secure extensibility and interactivity of HOL with Mizar\u2019s readability and lack of logical prescriptiveness. Part of our work involves adding new facilities to HOL for first order automation, since this allows HOL to be more flexible, as Mizar is, over the precise logical connection between steps.", "num_citations": "103\n", "authors": ["1889"]}
{"title": "Verifying nonlinear real formulas via sums of squares\n", "abstract": " Techniques based on sums of squares appear promising as a general approach to the universal theory of reals with addition and multiplication, i.e. verifying Boolean combinations of equations and inequalities. A particularly attractive feature is that suitable \u2018sum of squares\u2019 certificates can be found by sophisticated numerical methods such as semidefinite programming, yet the actual verification of the resulting proof is straightforward even in a highly foundational theorem prover. We will describe our experience with an implementation in HOL Light, noting some successes as well as difficulties. We also describe a new approach to the univariate case that can handle some otherwise difficult examples.", "num_citations": "99\n", "authors": ["1889"]}
{"title": "A software implementation of the IEEE 754R decimal floating-point arithmetic using the binary encoding format\n", "abstract": " The IEEE Standard 754-1985 for binary floating-point arithmetic [19] was revised [20], and an important addition is the definition of decimal floating-point arithmetic [8], [24]. This is intended mainly to provide a robust reliable framework for financial applications that are often subject to legal requirements concerning rounding and precision of the results, because the binary floating-point arithmetic may introduce small but unacceptable errors. Using binary floating-point calculations to emulate decimal calculations in order to correct this issue has led to the existence of numerous proprietary software packages, each with its own characteristics and capabilities. The IEEE 754R decimal arithmetic should unify the ways decimal floating-point calculations are carried out on various platforms. New algorithms and properties are presented in this paper, which are used in a software implementation of the IEEE 754R decimal\u00a0\u2026", "num_citations": "97\n", "authors": ["1889"]}
{"title": "Formalized mathematics\n", "abstract": " It is generally accepted that in principle it's possible to formalize completely almost all of present-day mathematics. The practicability of actually doing so is widely doubted, as is the value of the result. But in the computer age we believe that such formalization is possible and desirable. In contrast to the QED Manifesto however, we do not o er polemics in support of such a project. We merely try to place the formalization of mathematics in its historical perspective, as well as looking at existing praxis and identifying what we regard as the most interesting issues, theoretical and practical.", "num_citations": "96\n", "authors": ["1889"]}
{"title": "Formal verification of IA-64 division algorithms\n", "abstract": " The IA-64 architecture defers floating point and integer division to software. To ensure correctness and maximum efficiency, Intel provides a number of recommended algorithms which can be called as subroutines or inlined by compilers and assembly language programmers. All these algorithms have been subjected to formal verification using the HOL Light theorem prover. As well as improving our level of confidence in the algorithms, the formal verification process has led to a better understanding of the underlying theory, allowing some significant efficiency improvements.", "num_citations": "94\n", "authors": ["1889"]}
{"title": "The computation of transcendental functions on the IA-64 architecture\n", "abstract": " The fast and accurate evaluation of transcendental functions (eg exp, log, sin, and atan) is vitally important in many fields of scientific computing. Intel provides a software library of these functions that can be called from both the C and FORTRAN programming languages. By exploiting some of the key features of the IA-64 floating-point architecture, we have been able to provide double-precision transcendental functions that are highly accurate yet can typically be evaluated in between 50 and 70 clock cycles. In this paper, we discuss some of the design principles and implementation details of these functions.", "num_citations": "92\n", "authors": ["1889"]}
{"title": "Formally verified mathematics\n", "abstract": " With the help of computational proof assistants, formal verification could become the new standard for rigor in mathematics.", "num_citations": "90\n", "authors": ["1889"]}
{"title": "Extending the HOL theorem prover with a computer algebra system to reason about the reals\n", "abstract": " In this paper we describe an environment for reasoning about the reals which combines the rigour of a theorem prover with the power of a computer algebra system.", "num_citations": "88\n", "authors": ["1889"]}
{"title": "A proof-producing decision procedure for real arithmetic\n", "abstract": " We present a fully proof-producing implementation of a quantifier elimination procedure for real closed fields. To our knowledge, this is the first generally useful proof-producing implementation of such an algorithm. While many problems within the domain are intractable, we demonstrate convincing examples of its value in interactive theorem proving.", "num_citations": "83\n", "authors": ["1889"]}
{"title": "Efficient and accurate computation of upper bounds of approximation errors\n", "abstract": " For purposes of actual evaluation, mathematical functions f are commonly replaced by approximation polynomials p. Examples include floating-point implementations of elementary functions, quadrature or more theoretical proof work involving transcendental functions. Replacing f by p induces a relative error \u03f5= p/f\u2212 1. In order to ensure the validity of the use of p instead of f, the maximum error, ie the supremum norm\u2016 \u03f5\u2016\u221e I must be safely bounded above over an interval I, whose width is typically of order 1. Numerical algorithms for supremum norms are efficient, but they cannot offer the required safety. Previous validated approaches often require tedious manual intervention. If they are automated, they have several drawbacks, such as the lack of quality guarantees. In this article, a novel, automated supremum norm algorithm on univariate approximation errors \u03f5 is proposed, achieving an a priori quality on the\u00a0\u2026", "num_citations": "74\n", "authors": ["1889"]}
{"title": "Inductive definitions: Automation and application\n", "abstract": " This paper demonstrates the great practical utility of inductive definitions in HOL. We describe a new package we have implemented for automating inductive definitions, based on the Knaster-Tarski fixpoint theorem. As an example, we use it to give a simple proof of the well-founded recursion theorem. We then describe how to generate free recursive types starting just from the Axiom of Infinity. This contrasts with the existing HOL development where several specific free recursive types are developed first.", "num_citations": "74\n", "authors": ["1889"]}
{"title": "Proof style\n", "abstract": " We are concerned with how computer theorem provers should expect users to communicate proofs to them. There are many stylistic choices that still allow the machine to generate a completely formal proof object. The most obvious choice is the amount of guidance required from the user, or from the machine perspective, the degree of automation provided. But another important consideration, which we consider particularly significant, is the bias towards a \u2018procedural\u2019 or \u2018declarative\u2019 proof style. We will explore this choice in depth, and discuss the strengths and weaknesses of declarative and procedural styles for proofs in pure mathematics and for verification applications. We conclude with a brief summary of our own experiments in trying to combine both approaches.", "num_citations": "69\n", "authors": ["1889"]}
{"title": "Optimizing proof search in model elimination\n", "abstract": " Many implementations of model elimination perform proof search by iteratively increasing a bound on the total size of the proof. We propose an optimized version of this search mode using a simple divide-and-conquer refinement. Optimized and unoptimized modes are compared, together with depth-bounded and best-first search, over the entire TPTP problem library. The optimized size-bounded mode seems to be the overall winner, but for each strategy there are problems on which it performs best. Some attempt is made to analyze why. We emphasize that our optimization, and other implementation techniques like caching, are rather general: they are not dependent on the details of model elimination, or even that the search is concerned with theorem proving. As such, we believe that this study is a useful complement to research on extending the model elimination calculus.", "num_citations": "69\n", "authors": ["1889"]}
{"title": "History of Interactive Theorem Proving.\n", "abstract": " By interactive theorem proving, we mean some arrangement where the machine and a human user work together interactively to produce a formal proof. There is a wide spectrum of possibilities. At one extreme, the computer may act merely as a checker on a detailed formal proof produced by a human; at the other the prover may be highly automated and powerful, while nevertheless being subject to some degree of human guidance. In view of the practical limitations of pure automation, it seems today that, whether one likes it or not, interactive proof is likely to be the only way to formalize most non-trivial theorems in mathematics or computer system correctness.Almost all the earliest work on computer-assisted proof in the 1950s [Davis, 1957; Gilmore, 1960; Davis and Putnam, 1960; Wang, 1960; Prawitz et al., 1960] and 1960s [Robinson, 1965; Maslov, 1964; Loveland, 1968] was devoted to truly automated theorem proving, in the sense that the machine was supposed to prove assertions fully automatically. It is true that there was still a considerable diversity of methods, with some researchers pursuing AI-style approaches [Newell and Simon, 1956; Gelerntner, 1959; Bledsoe, 1984] rather than the dominant theme of automated proof search, and that the proof search programs were often highly tunable by setting a complicated array of parameters. As described by Dick [2011], the designers of automated systems would often study the details of runs and tune the systems accordingly, leading to a continuous process of improvement and understanding that could in a very general sense be considered interactive. Nevertheless, this is not quite what\u00a0\u2026", "num_citations": "67\n", "authors": ["1889"]}
{"title": "St\u00e5lmarck\u2019s algorithm as a HOL derived rule\n", "abstract": " St\u00e5lmarck\u2019s algorithm is a patented technique for tautology-checking which has been used successfully for industrial-scale problems. Here we describe the algorithm and explore its implementation as a HOL derived rule.", "num_citations": "67\n", "authors": ["1889"]}
{"title": "Formalizing an analytic proof of the prime number theorem\n", "abstract": " We describe the computer formalization of a complex-analytic proof of the Prime Number Theorem (PNT), a classic result from number theory characterizing the asymptotic density of the primes. The formalization, conducted using the HOL Light theorem prover, proceeds from the most basic axioms for mathematics yet builds from that foundation to develop the necessary analytic machinery including Cauchy\u2019s integral formula, so that we are able to formalize a direct, modern and elegant proof instead of the more involved \u2018elementary\u2019 Erd\u00f6s-Selberg argument. As well as setting the work in context and describing the highlights of the formalization, we analyze the relationship between the formal proof and its informal counterpart and so attempt to derive some general lessons about the formalization of mathematics.", "num_citations": "65\n", "authors": ["1889"]}
{"title": "Floating-point verification using theorem proving\n", "abstract": " This chapter describes our work on formal verification of floating-point algorithms using the HOL Light theorem prover.", "num_citations": "61\n", "authors": ["1889"]}
{"title": "Binary decision diagrams as a HOL derived rule\n", "abstract": " Binary Decision Diagrams (BDDs) are a representation for Boolean formulas which makes many operations, in particular tautology-checking, surprisingly efficient in important practical cases. In contrast to such custom decision procedures, the HOL theorem prover expands all proofs out to a sequence of extremely simple primitive inferences. In this paper we describe how the BDD algorithm may be adapted to comply with such strictures, helping us to understand the strengths and limitations of the HOL approach.", "num_citations": "57\n", "authors": ["1889"]}
{"title": "Formal verification at intel\n", "abstract": " As designs become more complex, formal verification techniques are becoming increasingly important in the hardware industry. Many different methods are used, ranging from propositional tautology checking up to use of interactive higher-order theorem provers. Our own work is mainly concerned with the formal verification of floating-point mathematical functions. As this paper illustrates, such applications require a rather general mathematical framework and the ability to automate special-purpose proof algorithms in a reliable way. Our work uses the public-domain interactive theorem prover HOL Light, and we claim that this and similar 'LCF-style' theorem provers are a good choice for such applications.", "num_citations": "55\n", "authors": ["1889"]}
{"title": "Constructing the real numbers in HOL\n", "abstract": " This paper describes a construction of the real numbers in the HOL theorem-prover by strictly definitional means using a version of Dedekind's method. It also outlines the theory of mathematical analysis that has been built on top of it and discusses current and potential applications in verification and computer algebra.", "num_citations": "51\n", "authors": ["1889"]}
{"title": "Formalizing basic complex analysis\n", "abstract": " We describe the formalization of some of the basics of complex analysis in the HOL Light theorem prover. Besides being a beautiful area of mathematics, this has many potential applications, eg in analytic number theory. We have endeavoured to set up the kind of general analytic machinery that would make such applications feasible.", "num_citations": "49\n", "authors": ["1889"]}
{"title": "Formal verification of square root algorithms\n", "abstract": " We discuss the formal verification of some low-level mathematical software for the Intel\u00ae Itanium\u00ae architecture. A number of important algorithms have been proven correct using the HOL Light theorem prover. After briefly surveying some of our formal verification work, we discuss in more detail the verification of a square root algorithm, which helps to illustrate why some features of HOL Light, in particular programmability, make it especially suitable for these applications.", "num_citations": "48\n", "authors": ["1889"]}
{"title": "Floating point verification in HOL Light: The exponential function\n", "abstract": " Since they often embody compact but mathematically sophisticated algorithms, operations for computing the common transcendental functions in floating point arithmetic seem good targets for formal verification using a mechanical theorem prover. We discuss some of the general issues that arise in verifications of this class, and then present a machine-checked verification of an algorithm for computing the exponential function in IEEE-754 standard binary floating point arithmetic. We confirm (indeed strengthen) the main result of a previousl published error analysis, though we uncover a minor error in the hand proof and are forced to confront several subtle issues that might easily be overlooked informally.               The development described here includes, apart from the proof itself, a formalization of IEEE arithmetic, a mathematical semantics for the programming language in which the algorithm is expressed\u00a0\u2026", "num_citations": "46\n", "authors": ["1889"]}
{"title": "Verifying the accuracy of polynomial approximations in HOL\n", "abstract": " Many modern algorithms for the transcendental functions rely on a large table of precomputed values together with a low-order polynomial to interpolate between them. In verifying such an algorithm, one is faced with the problem of bounding the error in this polynomial approximation. The most straightforward methods are based on numerical approximations, and are not prima facie reducible to a formal HOL proof. We discuss a technique for proving such results formally in HOL, via the formalization of a number of results in polynomial theory, e.g. squarefree decomposition and Sturm's theorem, and the use of a computer algebra system to compute results that are then checked in HOL. We demonstrate our method by tackling an example from the literature.", "num_citations": "46\n", "authors": ["1889"]}
{"title": "Formalizing basic first order model theory\n", "abstract": " We define the syntax of unsorted first order logic as a HOL datatype and define the semantics of terms and formulas, and hence notions such as validity and satisfiability. We prove formally in HOL some elementary metatheorems such as Compactness, L\u00f6wenheim-Skolem and Uniformity, via canonical term models. The proofs are based on those in Kreisel and Krivine's book on model theory, but the HOL formalization raises several interesting issues. Because of the limited nature of type quantification in HOL, many of the theorems are awkward to state or prove in their standard form. Moreover, simple and elegant though the proofs seem, there are surprising difficulties formalizing Skolemization, one of the more intuitively obvious parts. On the other hand, we significantly improve on the original textbook versions of the arguments, proving two of the main theorems together rather than by separate arguments.", "num_citations": "43\n", "authors": ["1889"]}
{"title": "Reasoning about the reals: The marriage of HOL and Maple\n", "abstract": " Computer algebra systems are extremely powerful and flexible, but often give results which require careful interpretation or are downright incorrect. By contrast, theorem provers are very reliable but lack the powerful specialized decision procedures and heuristics of computer algebra systems. In this paper we try to get the best of both worlds by careful exploitation of a link between a theorem prover and a computer algebra system.", "num_citations": "43\n", "authors": ["1889"]}
{"title": "Scientific computing on the Itanium\u2122 processor\n", "abstract": " The 64-bit Intel\u00ae Itanium\u2122 architecture is designed for high-performance scientific and enterprise computing, and the Itanium processor is itsfirst silicon implementation. Features such as extensive arithmetic support, predication, speculation, and explicit parallelism can be used to provide a sound infrastructure for supercomputing. A largenumber of high-performance computer companies are offering Itanium\u2122-based systems, some capable of peak performance exceeding 50 GFLOPS. In this paper we give an overview of the most relevant architectural features and provide illustrations of how these features are used in both low-level and high-level support for scientific and engineering computing, including transcendental functions and linear algebra kernels.", "num_citations": "39\n", "authors": ["1889"]}
{"title": "Without loss of generality\n", "abstract": " One sometimes reads in a mathematical proof that a certain assumption can be made \u2018without loss of generality\u2019 (WLOG). In other words, it is claimed that considering what first appears only a special case does nevertheless suffice to prove the general result. Typically the intuitive justification for this is that one can exploit symmetry in the problem. We examine how to formalize such \u2018WLOG\u2019 arguments in a mechanical theorem prover. Geometric reasoning is particularly rich in examples and we pay special attention to this area.", "num_citations": "35\n", "authors": ["1889"]}
{"title": "Fast and accurate Bessel function computation\n", "abstract": " The Bessel functions are considered relatively difficult to compute. Although they have a simple power series expansion that is everywhere convergent, they exhibit approximately periodic behavior which makes the direct use of the power series impractically slow and numerically unstable. We describe an alternative method based on systematic expansion around the zeros, refining existing techniques based on Hankel expansions, which mostly avoids the use of multiprecision arithmetic while yielding accurate results.", "num_citations": "35\n", "authors": ["1889"]}
{"title": "Floating point verification in HOL\n", "abstract": " Floating-point verification is a very interesting application area for theorem provers. HOL is a general-purpose prover which is equipped with an extensive and rigorous theory of real analysis. We explain how it can be used in floating point verification, illustrating our remarks with complete verifications of simple square-root and (natural) logarithm algorithms.", "num_citations": "35\n", "authors": ["1889"]}
{"title": "Complex quantifier elimination in HOL\n", "abstract": " Building on a simple construction of the complex numbers and a proof of the Fundamental Theorem of Algebra, we implement, as a HOL derived inference rule, a decision method for the first order algebraic theory of C based on quantifier elimination. Although capable of solving some mildly interesting problems, we also implement a more efficient semidecision procedure for the universal fragment based on Gr\u00f6bner bases. This is applied to examples including the automatic proof of some simple geometry theorems. The general and universal procedures present an interesting contrast in that the latter can exploit the finding-checking separation to achieve greater efficiency, though this feature is only partly exploited in the present implementation.", "num_citations": "33\n", "authors": ["1889"]}
{"title": "Introduction to functional programming\n", "abstract": " These are the lecture notes accompanying the course Introduction to Functional Programming, which I taught at Cambridge University in the academic year 1996/7.This course has mainly been taught in previous years by Mike Gordon. I have retained the basic structure of his course, with a blend of theory and practice, and have borrowed heavily in what follows from his own lecture notes, available in book form as Part II of (Gordon 1988). I have also been influenced by those who have taught related courses here, such as Andy Gordon and Larry Paulson and, in the chapter on types, by Andy Pitts\u2019s course on the subject. The large chapter on examples is not directly examinable, though studying it should improve the reader\u2019s grasp of the early parts and give a better idea about how ML is actually used.", "num_citations": "29\n", "authors": ["1889"]}
{"title": "Decimal transcendentals via binary\n", "abstract": " We describe the design and implementation of a comprehensive library of transcendental functions for the new IEEE decimal floating-point formats. In principle, such functions are very much analogous to their binary counterparts,though with a few additional subtleties connected with 'scale' (preferred exponent). But our approach has been not to employ direct techniques, but rather to re-use existing binary functions as much as possible, both for greater efficiency and ease of implementation. For some functions the most straightforward approach (convert from decimal to binary, perform binary operation, convert back) works well. In many cases, however, these are insufficiently accurate, and subtler approaches must be used.", "num_citations": "27\n", "authors": ["1889"]}
{"title": "Intel\u00ae Itanium\u00ae floating-point architecture\n", "abstract": " The Intel\u00ae Itanium\u00ae architecture is increasingly becoming one of the major processor architectures present in the market today. Launched in 2001, the Intel Itanium processor was followed in 2002 by the Itanium 2 processor, with increased integer and floating-point performance. Measured by the SPEC CINT2000 benchmarks, the Itanium 2 processor still trails by about 25% the Intel P4 processor in integer performance, albeit P4 runs at more than three times Itanium's clock frequency. However, its floating-point performance clearly leads in the SPEC CFP2000 charts, and its rating is about 25% higher than that of the P4 processor. While the general features of the Itanium architecture such as large register sets, predication, speculation, and support for explicit parallelism [1] have been presented in several papers, books, and mainstream college textbooks [2], its floating-point architecture has been less publicized\u00a0\u2026", "num_citations": "23\n", "authors": ["1889"]}
{"title": "Verifying a synthesized implementation of IEEE-754 floating-point exponential function using HOL\n", "abstract": " Deep datapath and algorithm complexity have made the verification of floating-point units a very hard task. Most simulation and reachability analysis verification tools fail to verify a circuit with a deep datapath like most industrial floating-point units. Theorem proving, however, offers a better solution to handle such verification. In this paper, we have hierarchically formalized and verified a hardware implementation of the IEEE-754 table-driven floating-point exponential function algorithm using the higher-order logic (HOL) theorem prover. The high ability of abstraction in the HOL verification system allows its use for the verification task over the whole design path of the circuit, starting from gate-level implementation of the circuit up to a high-level mathematical specification.", "num_citations": "22\n", "authors": ["1889"]}
{"title": "Floating Point Verification\n", "abstract": " One of the most promising application areas for theorem proving is the verification of floating point hardware, a topic that has recently attracted some attention. We explain why a theorem prover equipped with a theory of real numbers is a good vehicle for this kind of application, showing in particular how it allows a natural specification style. We discuss different ways of specifying the accuracy of basic floating-point calculations, and as an illustration, verify simple algorithms for evaluating square roots and natural logarithms.", "num_citations": "22\n", "authors": ["1889"]}
{"title": "HOL Light Tutorial (for version 2.20)\n", "abstract": " The HOL Light theorem prover can be difficult to get started with. While the manual is fairly detailed and comprehensive, the large amount of background information that has to be absorbed before the user can do anything interesting is intimidating. Here we give an alternative \u2018quick start\u2019guide, aimed at teaching basic use of the system quickly by means of a graded set of examples. Some readers may find it easier to absorb; those who do not are referred after all to the standard manual.", "num_citations": "21\n", "authors": ["1889"]}
{"title": "Constructing the real numbers in HOL\n", "abstract": " We describe a construction of the real numbers in the HOL theorem-prover by strictly definitional means using a version of Dedekind's method. We also outline the theory of mathematical analysis that has been built on top of it, and discuss current and potential applications in verification and computer algebra.", "num_citations": "20\n", "authors": ["1889"]}
{"title": "Floating-point verification\n", "abstract": " Only in a few isolated safety-critical niches of the software industry (e.g. avionics) is any kind of formal verification widespread. But in the hardware industry, formal verification is widely practised, and increasingly seen as necessary. We can perhaps identify at least three reasons:               \u2013 Hardware is designed in a more modular way than most software, with refinement an important design method. Constraints of interconnect layering and timing means that one cannot really design \u2018spaghetti hardware\u2019.               \u2013 More proofs in the hardware domain can be largely automated, reducing the need for intensive interaction by a human expert with the mechanical theorem-proving system.               \u2013 The potential consequences of a hardware error are greater, since such errors often cannot be patched or worked around, and may in extremis necessitate a hardware replacement.", "num_citations": "18\n", "authors": ["1889"]}
{"title": "HOL Light tutorial\n", "abstract": " The HOL Light theorem prover can be difficult to get started with. While the manual is fairly detailed and comprehensive, the large amount of background information that has to be absorbed before the user can do anything interesting is intimidating. Here we give an alternative \u2018quick start\u2019guide, aimed at teaching basic use of the system quickly by means of a graded set of examples. Some readers may find it easier to absorb; those who do not are referred after all to the standard manual.", "num_citations": "17\n", "authors": ["1889"]}
{"title": "Hol\n", "abstract": " Statement                                         ~rational(sqrt(&2))                                         Definitions                                         Definition of               sqrt                                         let root = new_definition                                         \u2019root(n) x = @u. (&0 < x =\u2009=\u2009> &0 < u) / u pow n = x\u2019;;                                         let sqrt = new_definition                                         \u2019sqrt(x) = root(2) x\u2019;;", "num_citations": "17\n", "authors": ["1889"]}
{"title": "A short survey of automated reasoning\n", "abstract": " This paper surveys the field of automated reasoning, giving some historical background and outlining a few of the main current research themes. We particularly emphasize the points of contact and the contrasts with computer algebra. We finish with a discussion of the main applications so far.", "num_citations": "16\n", "authors": ["1889"]}
{"title": "HOL done right\n", "abstract": " In our opinion, history and compatibility considerations have rendered existing HOL implementations rather messy and badly organized. We describe how, building on joint work with Konrad Slind, we have produced a re-engineered HOL. Various experiments have been tried on this \u2018toy\u2019version, and we will report the results.", "num_citations": "15\n", "authors": ["1889"]}
{"title": "A HOL decision procedure for elementary real algebra\n", "abstract": " The elementary theory of real algebra, including multiplication, is decidable. More precisely, there is an algorithm to eliminate quantifiers which does not introduce new free variables or new constants other than rational numbers. Therefore if a closed term of elementary real algebra involves no constants other than the rational numbers, its truth or falsity can be determined automatically. Quite a number of interesting algebraic and geometric problems can be expressed in this decidable subset. In this paper we describe a HOL implementation of a quantifier-elimination procedure and give some preliminary results.", "num_citations": "15\n", "authors": ["1889"]}
{"title": "Theorem proving for verification (invited tutorial)\n", "abstract": " There are numerous verification techniques in active use. Traditional testing and simulation usually only provide a limited guarantee, since they can seldom exercise all possible situations. Methods based on abstraction consciously simplify the problem to make its complete analysis tractable, but still do not normally completely verify the ultimate target. We will confine ourselves here to full formal verification techniques that can be used to prove complete correctness of a (model of a) system with respect to a formal specification. Roughly speaking, these methods model the system and specification in a logical formalism and then apply general methods to determine whether the formal expressions are valid, indicating correctness of the model with respect to the specification. Typical formalisms include:                                                                        Propositional logic, a.k.a. Boolean algebra\u00a0\u2026", "num_citations": "14\n", "authors": ["1889"]}
{"title": "Methods and apparatus for fast argument reduction in a computing system\n", "abstract": " There is disclosed method, software and apparatus for evaluating a function f in a computing device using a reduction, core approximation and final reconstruction stage. According to one embodiment of the invention, an argument reduction stage uses an approximate reciprocal table in the computing device. According to another embodiment, an approximate reciprocal instruction I is operative on the computing device to use the approximate reciprocal table such that the argument reduction stage provides that\u2014C:= I (X) and R:= X\u00d7 C\u2212 1, the core approximation stage provides that p (R) is computed so that it approximates f (1+ R), and the final reconstruction stage provides that T= f (1/C) is fetched and calculated if necessary, and f (X) is reconstructed based on f (X)= f ([1/C]\u00d7[X\u00d7 C])= g (f (1/C), f (1+ R)).", "num_citations": "13\n", "authors": ["1889"]}
{"title": "Methods and apparatus for extracting integer remainders\n", "abstract": " Methods and apparatus for determining a remainder value are disclosed. The methods and apparatus extract a residuary subset bitfield value from a binary value that is calculated using a scaled approximate reciprocal value that is associated with a compound exponent scaling value. The residuary subset bitfield value is part of a range of contiguous bits that is associated with upper and lower boundary bit-position values that are part of the compound exponent scaling value. The methods and apparatus determine the remainder value based on the residuary subset bitfield value.", "num_citations": "13\n", "authors": ["1889"]}
{"title": "Automating elementary number-theoretic proofs using Gr\u00f6bner bases\n", "abstract": " We present a uniform algorithm for proving automatically a fairly wide class of elementary facts connected with integer divisibility. The assertions that can be handled are those with a limited quantifier structure involving addition, multiplication and certain number-theoretic predicates such as \u2018divisible by\u2019, \u2018congruent\u2019 and \u2018coprime\u2019; one notable example in this class is the Chinese Remainder Theorem (for a specific number of moduli). The method is based on a reduction to ideal membership assertions that are then solved using Gr\u00f6bner bases. As well as illustrating the usefulness of the procedure on examples, and considering some extensions, we prove a limited form of completeness for properties that hold in all rings.", "num_citations": "13\n", "authors": ["1889"]}
{"title": "Computing transcendental functions using single instruction multiple data (SIMD) operations\n", "abstract": " In one embodiment, the present invention includes a method for reducing an input argument x of a function to a range reduced value r according to a first reduction sequence, approximating a polynomial for a corresponding function of r having a dominant portion f (A)+ \u03c3r, and obtaining a result for the function using the polynomial.", "num_citations": "13\n", "authors": ["1889"]}
{"title": "Video production sharing apparatus and method\n", "abstract": " A video production sharing apparatus is provided with a first computer having a processor, memory, and an input device, the memory having programs stored therein, the programs implemented through the processor and designed to cause the processor to: 1) access at least one video stream, 2) manipulate viewing perspective of the at least one video stream with the input device of the first computer to generate an individualized video, and 3) transfer a data file of user inputs from the input device used to manipulate the at least one video stream to create the individualized video that describes the individualized video of the at least one video stream. A method is also provided.", "num_citations": "12\n", "authors": ["1889"]}
{"title": "Some new results on decidability for elementary algebra and geometry\n", "abstract": " We carry out a systematic study of decidability for theories (a) of real vector spaces, inner product spaces, and Hilbert spaces and (b) of normed spaces, Banach spaces and metric spaces, all formalized using a 2-sorted first-order language. The theories for list (a) turn out to be decidable while the theories for list (b) are not even arithmetical: the theory of 2-dimensional Banach spaces, for example, has the same many-one degree as the set of truths of second-order arithmetic.We find that the purely universal and purely existential fragments of the theory of normed spaces are decidable, as is the \u2200\u2203 fragment of the theory of metric spaces. These results are sharp of their type: reductions of Hilbert\u02bcs 10th problem show that the \u2203\u2200 fragments for metric and normed spaces and the \u2200\u2203 fragment for normed spaces are all undecidable.", "num_citations": "12\n", "authors": ["1889"]}
{"title": "Formal Methods at Intel\u2014An Overview\n", "abstract": " Formal Methods at Intel \u2014 An Overview Page 1 Formal Methods at Intel \u2014 An Overview John Harrison Intel Corporation 27 September 2011 1 Page 2 Summary \u25b6 Intel\u2019s diverse verification problems 2 Page 3 Summary \u25b6 Intel\u2019s diverse verification problems \u25b6 Verifying hardware with FEV and STE 2 Page 4 Summary \u25b6 Intel\u2019s diverse verification problems \u25b6 Verifying hardware with FEV and STE \u25b6 Verifying protocols with model checking and SMT 2 Page 5 Summary \u25b6 Intel\u2019s diverse verification problems \u25b6 Verifying hardware with FEV and STE \u25b6 Verifying protocols with model checking and SMT \u25b6 Verifying floating-point firmware with HOL 2 Page 6 Summary \u25b6 Intel\u2019s diverse verification problems \u25b6 Verifying hardware with FEV and STE \u25b6 Verifying protocols with model checking and SMT \u25b6 Verifying floating-point firmware with HOL \u25b6 Perspectives and future prospects 2 Page 7 Overview 3 Page 8 A diversity \u2026", "num_citations": "12\n", "authors": ["1889"]}
{"title": "A formalized proof of Dirichlet's theorem on primes in arithmetic progression\n", "abstract": " We describe the formalization using the HOL Light theorem prover of Dirichlet's theorem on primes in arithmetic progression. The proof turned out to be more straightforward than expected, but this depended on a careful choice of an informal proof to use as a starting-point. The goal of this paper iis twofold. First we describe a simple and efficient proof of the theorem informally, which iis otherwise difficult to find in one self-contained place at an elementary level. We also describe its, largely routine, HOL Light formalization, a task that took only a few days.", "num_citations": "12\n", "authors": ["1889"]}
{"title": "Formal proofs of hypergeometric sums\n", "abstract": " Algorithmic methods can successfully automate the proof, and even the discovery, of a large class of identities involving sums of hypergeometric terms. In particular, the Wilf-Zeilberger (WZ) algorithm is a uniform framework for a substantial class of hypergeometric summation problems. This algorithm can produce a rational function certificate that can, on the face of it, be used to verify the result by routine algebraic manipulations, independently of the working of the algorithm that discovered it. It is therefore very natural to consider using this certificate to produce, by automated means, a rigorous deductive proof in an interactive theorem prover. However, naive presentations of the WZ method tend to gloss over trivial-looking but rather knotty questions about zero denominators, which makes their rigorous formalization tricky and their ultimate logical justification somewhat obscure. We describe how we have\u00a0\u2026", "num_citations": "11\n", "authors": ["1889"]}
{"title": "Methods and apparatus for determining quotients\n", "abstract": " Methods, apparatus, and articles of manufacture for determining quotient values are disclosed. An example method identifies a reciprocal value of a divisor value. A bias value is then identified and a biased quotient value is determined based on a dividend value, the reciprocal value, and at least a portion of the bias value. A quotient value is then determined based on the biased quotient value.", "num_citations": "11\n", "authors": ["1889"]}
{"title": "Converting mathematical functions to power series\n", "abstract": " A processor based system may convert a mathematical function to a power series converging on that function. One or more sets of coefficients for the power series may be pre-computed and stored in machine readable storage medium. In response to a request to execute the mathematical function, the processor obtains coefficients of the terms of the power series from storage and sums up the terms.", "num_citations": "11\n", "authors": ["1889"]}
{"title": "Isolating critical cases for reciprocals using integer factorization\n", "abstract": " One approach to testing and/or proving correctness of a floating-point algorithm computing a function f is based on finding input floating-point numbers a such that the exact result f(a) is very close to a \"rounding boundary\", i.e. a floating-point number or a midpoint between them. We show how to do this for the reciprocal function by utilizing prime factorizations. We present the method and show examples, as well as making a fairly detailed study of its expected and worst-case behavior. We point out how this analysis of reciprocals can be useful in analyzing certain reciprocal algorithms, and also show how the approach can be trivially adapted to the reciprocal square root function.", "num_citations": "11\n", "authors": ["1889"]}
{"title": "Formalizing Dijkstra\n", "abstract": " We present a HOL formalization of the foundational parts of Dijkstra's classic monograph \u201cA Discipline of Programming\u2253. While embedding programming language semantics in theorem provers is hardly new, this particular undertaking raises several interesting questions, and perhaps makes an interesting supplement to the monograph. Moreover, the failure of HOL's first order proof tactic to prove one \u2018theorem\u2019 indicates a technical error in the book.", "num_citations": "10\n", "authors": ["1889"]}
{"title": "Rounding mode insensitive method and apparatus for integer rounding\n", "abstract": " A method and apparatus for integer rounding are described herein. In one embodiment, exemplary method includes adding a first value with a first constant, resulting in a second value, optionally performing a rounding operation on the second value, resulting in a third value, and extracting at least a portion of bits from the third value to generate an integer component corresponding to the first value, the first constant being selected such that an accuracy of the integer component is independent of a rounding mode of the rounding operation. Other methods and apparatuses are also described.", "num_citations": "9\n", "authors": ["1889"]}
{"title": "Method for achieving correctly rounded quotients in algorithms based on fused multiply-accumulate without requiring the intermediate calculation of a correctly rounded reciprocal\n", "abstract": " A method and apparatus for performing a floating point division of a dividend (a) by a divisor (b) to produce a correctly rounded-to-nearest quotient (q\u2032) having a mantissa of P bits in a data processing system is disclosed.", "num_citations": "9\n", "authors": ["1889"]}
{"title": "The HOL light manual (1.1)\n", "abstract": " HOL Light is a relatively new version of the HOL theorem prover (Gordon and Melham 1993). The whole implementation, even the axiomatization of the logic, has been re-engineered and simpli ed. Compared with other versions of HOL, it is relatively small and clean, and makes modest demands on the machine it is run on. The material that follows is not only a tutorial on the use of HOL Light and its interaction language, but also provides a detailed discussion of the implementation. HOL Light proves theorems in a system of classical higher order logic based on polymorphic simple type theory. All proof proceeds by the application of lowlevel primitive rules, maintaining a high degree of reliability. However, a suite of derived rules for proving various useful theorems automatically is provided, as is a full programming language in which users can implement their own derived rules. A number of useful mathematical theories, eg real analysis, are already available. To become an expert user of HOL Light, it is necessary to know something about programming in CAML Light, which is the implementation and interaction language. However, for readers primarily interested in theorem proving, it's no doubt somewhat dispiriting to spend a long time studying functional programming before even beginning to prove theorems. We have tried to minimize this problem in the organization that follows.We begin with a short introductory chapter highlighting the basic features of CAML and HOL, including the basic mechanism of user interaction and the principles behind derived inference rules. Features of HOL and CAML are illustrated as we go, and most readers will\u00a0\u2026", "num_citations": "9\n", "authors": ["1889"]}
{"title": "Theorem Proving in Higher Order Logics: 9th International Conference, TPHOLs' 96, Turku, Finland, August 26-30, 1996, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 9th International Conference on Theorem Proving in Higher Order Logics, TPHOL'96, held in Turku, Finland, in August 1996. The 27 revised full papers included together with one invited paper were carefully selected from a total of 46 submissions. The topics addressed are theorem proving technology, proof automation and decision procedures, mechanized theorem proving, extensions of higher order logics, integration of external tools, novel applications, and others. All in all, the volume is an up-to-date report on the state of the art in this increasingly active field.", "num_citations": "9\n", "authors": ["1889"]}
{"title": "Theorem Proving in Higher Order Logics: 13th International Conference, TPHOLs 2000 Portland, OR, USA, August 14-18, 2000 Proceedings\n", "abstract": " This volume is the proceedings of the 13th International Conference on Theo rem Proving in Higher Order Logics (TPHOLs 2000) held 14-18 August 2000 in Portland, Oregon, USA. Each of the 55 papers submitted in the full rese arch category was refereed by at least three reviewers who were selected by the program committee. Because of the limited space available in the program and proceedings, only 29 papers were accepted for presentation and publication in this volume. In keeping with tradition, TPHOLs 2000 also offered a venue for the presen tation of work in progress, where researchers invite discussion by means of a brief preliminary talk and then discuss their work at a poster session. A supplemen tary proceedings containing associated papers for work in progress was published by the Oregon Graduate Institute (OGI) as technical report CSE-00-009. The organizers are grateful to Bob Colwell, Robin Milner and Larry Wos for agreeing to give invited talks. Bob Colwell was the lead architect on the Intel P6 microarchitecture, which introduced a number of innovative techniques and achieved enormous commercial success. As such, he is ideally placed to offer an industrial perspective on the challenges for formal verification. Robin Milner contributed many key ideas to computer theorem proving, and to functional programming, through his leadership of the influential Edinburgh LCF project.", "num_citations": "7\n", "authors": ["1889"]}
{"title": "A reference version of HOL\n", "abstract": " The second author has implemented a reference version of the HOL logic (henceforth called gtt). This version, written in Standard ML, is as simple as possible, making as few assumptions as necessary to present the essence of HOL. This simplicity makes the implementation easy to understand, to port, to develop, to change, and to informally reason about. The first author has ported gtt to another dialect of ML, and developed the parsing, prettyprinting, and typechecking support needed to take gtt beyond its initial rudimentary conception. The implementation of gtt has already been of use in developing a variant of the HOL logic.As of this writing, there are at least four or five extant implementations of the HOL logic. These have been intensively developed, in some cases over decades, which leads us to an overwhelming question: why another? In particular, why gtt? There are several answers to this, stemming from different desires and needs in the HOL community.", "num_citations": "7\n", "authors": ["1889"]}
{"title": "Apparatus and method for capturing images\n", "abstract": " An apparatus is provided for capturing images including a base, and image capture adjustment mechanism, a first camera, and a second camera. The base is constructed and arranged to support an alignable array of cameras. The image capture adjustment mechanism is disposed relative to the base for adjusting an image capture line of sight for a camera relative to the base. The first camera is carried by the base, operably coupled with the image capture adjustment mechanism, and has an image capture device. The first camera has a line of sight defining a first field of view adjustable with the image capture adjustment mechanism relative to the base. The second camera is carried by the base and has an image capture device. The second camera has a line of sight defining a second field of view extending beyond a range of the field of view for the first camera in order to produce a field of view that is greater than\u00a0\u2026", "num_citations": "6\n", "authors": ["1889"]}
{"title": "Computational Logic.\n", "abstract": " Computational logic was born in the twentieth century and evolved in close symbiosis with the first electronic computers and the growing importance of computer science, informatics and artificial intelligence (AI). The field has now outgrown its humble beginnings and early expectations by far: with more than ten thousand people working in research and development of logic and logic-related methods, with several dozen international conferences and several times as many workshops addressing the growing richness and diversity of the field, and with the foundational role and importance these methods now assume in mathematics, computer science, artificial intelligence, cognitive science, linguistics, law, mechatronics and many other engineering fields where logic-related techniques are used inter alia to state and settle correctness issues, the field has diversified in ways that the pure logicians working in the early decades of the twenties century could have hardly anticipated-let alone those researchers of the previous centuries presented in this eleven volume account of the history of logic. Dating back to its roots in Greek, Indian, Chinese and Arabic philosophy the field has grown in richness and diversity over the centuries to finally reach the modern methodological approach first expressed in the work of Gottlob Frege. 1 Logical calculi, which not only capture formal reasoning, but also an important aspect of human thought, are now amenable to investigation with mathematical rigour and computational support and fertilized the early Leibniz\u2019dream of mechanized reasoning:\u201cCalculemus\u201d. The beginning of the last century saw the influence of\u00a0\u2026", "num_citations": "6\n", "authors": ["1889"]}
{"title": "High-level verification using theorem proving and formalized mathematics\n", "abstract": " Quite concrete problems in verification can throw up the need for a nontrivial body of formalized mathematics and draw on several special automated proof methods which can be soundly integrated into a general LCF-style theorem prover. We emphasize this point based on our own work on the formal verification in the HOL Light theorem prover of floating point algorithms.", "num_citations": "6\n", "authors": ["1889"]}
{"title": "Formal verification in industry\n", "abstract": " In mathematics, a general proposition can\u2019t be proved by testing many possible cases. A rigorous proof is something different. Sometimes even a huge weight of numerical evidence can be misleading. For example, Littlewood proved in 1914 that \u03c0 (n)\u2212 li (n) changes sign infinitely often, where \u03c0 (n) is the number of primes\u2264 n and li (n)=\u222b n", "num_citations": "6\n", "authors": ["1889"]}
{"title": "Binary decision diagrams as a HOL derived rule\n", "abstract": " Exhaustive testing of boolean terms has long been held to be impractical for nontrivial problems, since the problem of tautology-checking is NP-complete. Nevertheless research on Ordered Binary Decision Diagrams, which was given a great impetus by Bryant's pioneering work, shows that for a wide variety of realistic circuit problems, exhaustive analysis is tractable. In this paper we seek to explore how these datastructures can be used in making an efficient HOL derived rule, and illustrate our work with some examples both from hardware verification and pure logic.", "num_citations": "6\n", "authors": ["1889"]}
{"title": "Digit Serial Methods with Applications to Division and Square Root\n", "abstract": " We present a generic digit serial method (DSM) to compute the digits of a real number V. Bounds on these digits, and on the errors in the associated estimates of V formed from these digits, are derived. To illustrate our results, we derive such bounds for a parameterized family of high-radix algorithms for division and square root. These bounds enable a DSM designer to determine, for example, whether a given choice of parameters allows rapid formation and rounding of its approximation to V.", "num_citations": "5\n", "authors": ["1889"]}
{"title": "Methods and apparatus for extracting integer remainders\n", "abstract": " Methods and apparatus to determine a remainder value are disclosed. A disclosed example method involves, during a compilation phase, causing a processor to multiply a dividend value by a first value to generate a second value associated with a product. The first value is associated with a scaled approximate reciprocal of a divisor value, and the scaled approximate reciprocal of the divisor value is determined using a compound exponent value. During a runtime phase, the processor is caused to multiply a third value from the second value. The third value is generated using at least a subset bitfield of the second value. During the runtime phase, the processor is caused to determine a remainder value based on the third value. The processor is caused to store the remainder value in a memory.", "num_citations": "5\n", "authors": ["1889"]}
{"title": "Kings\u00b4 castles and sacred squares: the founding of Lo Monthang\n", "abstract": " The two upper floors have a simple wooden frame infill, but these also were originally more richly decorated, as they have been rebuilt after a collapse of this corner of the building (Tucci 1956: fig. 3). The two temples lie to the west and behind the palace, reached only by winding alleyways tunnelling under houses. All three buildings are entered from the east, so that the front of Jampa Lhakhang faces the rear of the palace. There is no obvious formal relationship between the monuments, nor indeed any formal planning within the town, although the buildings are approximately aligned with the walls. The temples, and the two lines of monumental ch\u00f6rten, are discovered accidentally, hidden amongst the enveloping houses. The very informal character of the streets, turning around the houses, narrowing and widening into small local gathering places, suggests that the residential development of the town was a\u00a0\u2026", "num_citations": "5\n", "authors": ["1889"]}
{"title": "First order logic in practice\n", "abstract": " There is a trend away from monolithic automated theorem provers towards using automation as a tool in support of interactive proof. We believe this is a fruitful drawing together of threads in automated reasoning. But it raises a number of issues that are often neglected in the classical rst order theorem proving literature such as the following. Is rst order automation actually useful, and if so, why? How can it be used for richer logics? What are the characteristic examples that require solution in practice? How do the traditional algorithms perform on thesepractical'examples| are they de cient or are they already too powerful? We discuss these and similar questions in the light of our own recent experience in this area using HOL 3].", "num_citations": "5\n", "authors": ["1889"]}
{"title": "The HOL reals library\n", "abstract": " This makes the real theory hierarchy a parent, sets up the most useful theorems from the theories REAL and TRANSC to autoload, and provides an interface map in real interface map which makes real operations more presentable. Note however that this interface map is not set up automatically. If required, the following command will set it up:2# set interface map real interface map;; However if there is an existing interface map, something rather more elaborate may be necessary. Various types are used in auxiliary ways within the theory hierarchy, but the only one which matters to most users is the type of real numbers, which is called simply", "num_citations": "5\n", "authors": ["1889"]}
{"title": "System and method for distributing multimedia events from a client\n", "abstract": " A system and method are provided for recording a video production from one or more panoramic and/or high resolution video feeds and recreating the video production at a remote location, or client using meta data, production data, and video feed from a remote source, and serve the video feed to multiple clients on a local area network.", "num_citations": "4\n", "authors": ["1889"]}
{"title": "Digit serial methods with applications to division and square root (with mechanically checked correctness proofs)\n", "abstract": " We present a generic digit serial method (DSM) to compute the digits of a real number  . Bounds on these digits, and on the errors in the associated estimates of  formed from these digits, are derived. To illustrate our results, we derive such bounds for a parameterized family of high-radix algorithms for division and square root. These bounds enable a DSM designer to determine, for example, whether a given choice of parameters allows rapid formation and rounding of its approximation to . All our claims are mechanically verified using the HOL-Light theorem prover, and are included in the appendix with commentary.", "num_citations": "4\n", "authors": ["1889"]}
{"title": "Preface: Twenty years of the QED manifesto\n", "abstract": " QED is the very tentative title of a project to build a computer system that effectively represents all important mathematical knowledge and techniques. The QED system will conform to the highest standards of mathematical rigor, including the use of strict formality in the internal representation of knowledge and the use of mechanical methods to check proofs of the correctness of all entries in the system...This special issue was preceded by a one-day QED+ 20 workshop3 taking place in Vienna on July 18, 2014, as a part of the Vienna Summer of Logic. Our main goal was to show on real formal developments the state of the art in formalization of mathematics 20 years after QED. We also wanted to remember and discuss QED and its goals, to see how we are (not yet) achieving them, and what are the current issues and their proposed/prototyped/working solutions. The workshop indeed managed to pack\u2013and perhaps overpack\u2013into one day talks about the greatest achievements in formalization done since QED. It started with John Harrison\u2019s personal memories of the QED discussions and workshops, his assessment of the successes and failures of QED-style efforts, followed by a lively discussion. Georges Gonthier then gave an overview of his famous formalizations on the Four Color theorem and Odd Order theorem, commenting on their history and links between them. This opulent morning series continued with Adam Grabowski\u2019s overview of the formalizations done in the Mizar Mathematical Library, Gerwin Klein\u2019s hands-on talk of the breakthrough project verifying the seL4 microkernel in Isabelle, Magnus Myreen\u2019s and Ramana Kumar\u2019s talks\u00a0\u2026", "num_citations": "4\n", "authors": ["1889"]}
{"title": "The HOL light formalization of euclidean space\n", "abstract": " The HOL Light formalization of Euclidean space Page 1 The HOL Light formalization of Euclidean space John Harrison Intel Corporation JMM special session on Formal Mathematics for Mathematicians January 8th, 2011 (09:30\u201310:00) 0 Page 2 Summary \u2022 History of this formalization \u2022 Encoding trick for R n \u2022 Vectors, matrices and linear algebra \u2022 Topology, convexity and polyhedra \u2022 Analysis, integration and measure \u2022 Complex analysis 1 Page 3 History of this formalization This formalization began following a discussion at NYU in February 2004, in an attempt to answer the question How to formalize Euclidean space in a natural and streamlined way in HOL Light, with the goal of supporting the Flyspeck project? Although Flyspeck is mainly concerned with R 3 , we try to work in the more general setting of Rn where possible. The general theory has also been applied to the special case of R 2 and used in a further \u2026", "num_citations": "4\n", "authors": ["1889"]}
{"title": "Some new results on decidability for elementary algebra and geometry\n", "abstract": " We carry out a systematic study of decidability for theories of (a) real vector spaces, inner product spaces, and Hilbert spaces and (b) normed spaces, Banach spaces and metric spaces, all formalised using a 2-sorted first-order language. The theories for list (a) turn out to be decidable while the theories for list (b) are not even arithmetical: the theory of 2-dimensional Banach spaces, for example, has the same many-one degree as the set of truths of second-order arithmetic. We find that the purely universal and purely existential fragments of the theory of normed spaces are decidable, as is the AE fragment of the theory of metric spaces. These results are sharp of their type: reductions of Hilbert's 10th problem show that the EA fragments for metric and normed spaces and the AE fragment for normed spaces are all undecidable.", "num_citations": "4\n", "authors": ["1889"]}
{"title": "The LCF approach to theorem proving\n", "abstract": " The idea of a more \u2018interactive\u2019approach was already anticipated by pioneers, eg Wang (1960):[...] the writer believes that perhaps machines may more quickly become of practical use in mathematical research, not by proving new theorems, but by formalizing and checking outlines of proofs, say, from textbooks to detailed formalizations more rigorous that Principia [Mathematica], from technical papers to textbooks, or from abstracts to technical papers.", "num_citations": "4\n", "authors": ["1889"]}
{"title": "Integer divide and remainder operations in the Intel IA-64 architecture\n", "abstract": " This paper examines the algorithms used and the implementation of the integer divide and remainder operations in the Intel IA-64 architecture. IA-64 processors do not include special hardware to perform these operations. Instead, they are carried out based mostly on floating-point operations, similar to the floating-point divide and remainder [1],[5]. The floating-point divide is performed using software sequences that implement Newton-Raphson or similar algorithms, using as a starting point a reciprocal approximation value provided by the IA-64 frcpa instruction.The paper shows first how the integer divide and remainder operations for various integer data types can be based directly on the existing single, double, and double-extended precision floating-point divide algorithms. It is shown next that significant performance improvements are possible if certain properties of the integer divide are used. Complete proofs\u00a0\u2026", "num_citations": "4\n", "authors": ["1889"]}
{"title": "Houses and households in southern Mustang\n", "abstract": " The Tibetan term khangba (Tib. khang-pa), literally meaning\" house\", is an imprecise expression as used in Mustang. It designates any residential building as well as the individual rooms a house contains (the Central Tibetan word for room, khangmig, Tib. khang-mig, is not used); it may also be used to signify the social and economic unit, the family, that owns or inhabits the house. Houses are not only material constructions but have important social and religious aspects, both with respect to the organisation of their space as well as to the way in which they relate to the other houses that constitute a given community. In this paper one house will be examined in some detail to illustrate the interrelation between the physical form of the building and its social and religious use. Angyal Gurung's family house1 in the", "num_citations": "4\n", "authors": ["1889"]}