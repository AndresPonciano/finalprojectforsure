{"title": "Automated test case generation for FBD programs implementing reactor protection system software\n", "abstract": " Automated and effective testing for function block diagram (FBD) programs has become an important issue, as FBD is increasingly used in implementing safety\u2010critical systems. This work describes an automated test case generation technique for FBD programs and its associated tool\u2014FBDTester. Given an FBD program and desired test coverage criteria, FBDTester generates test requirements and invokes the Satisfiability Modulo Theories solver iteratively to derive a set of test cases. An industrial case study using reactor protection system software shows that the automatically generated test suites detected at least 82% of the known faults, whereas manually generated test cases only detected approximately 35%. Mutation analysis revealed that the automatically generated test suites substantially outperformed manually generated ones. Although test sequence generation requires some manual effort in the current\u00a0\u2026", "num_citations": "43\n", "authors": ["2031"]}
{"title": "Empirical evaluation on FBD model-based test coverage criteria using mutation analysis\n", "abstract": " Function Block Diagram (FBD), one of the PLC programming languages, is a graphical modeling language which has been increasingly used to implement safety-critical software such as nuclear reactor protection software. With increased importance of structural testing for FBD models, FBD model-based test coverage criteria have been introduced. In this paper, we empirically evaluate the fault detection effectiveness of the FBD coverage criteria using mutation analysis. We produce 1800 test suites satisfying the FBD criteria and generate more than 600 mutants automatically for the target industrial FBD models. Then we evaluate mutant detection of the test suites to assess the fault detection effectiveness of the coverage criteria. Based on the experimental results, we analyze strengths and weaknesses of the FBD coverage criteria, and suggest possible improvements for the test coverage criteria.", "num_citations": "28\n", "authors": ["2031"]}
{"title": "Comparing offline and online testing of deep neural networks: An autonomous car case study\n", "abstract": " There is a growing body of research on developing testing techniques for Deep Neural Networks (DNNs). We distinguish two general modes of testing for DNNs: Offline testing where DNNs are tested as individual units based on test datasets obtained independently from the DNNs under test, and online testing where DNNs are embedded into a specific application and tested in a close-loop mode in interaction with the application environment. In addition, we identify two sources for generating test datasets for DNNs: Datasets obtained from real-life and datasets generated by simulators. While offline testing can be used with datasets obtained from either sources, online testing is largely confined to using simulators since online testing within real-life applications can be time consuming, expensive and dangerous. In this paper, we study the following two important questions aiming to compare test datasets and testing\u00a0\u2026", "num_citations": "27\n", "authors": ["2031"]}
{"title": "A theoretical framework for understanding mutation-based testing methods\n", "abstract": " In the field of mutation analysis, mutation is the systematic generation of mutated programs (i.e., mutants) from an original program. The concept of mutation has been widely applied to various testing problems, including test set selection, fault localization, and program repair. However, surprisingly little focus has been given to the theoretical foundation of mutation-based testing methods, making it difficult to understand, organize, and describe various mutation-based testing methods. This paper aims to consider a theoretical framework for understanding mutation-based testing methods. While there is a solid testing framework for general testing, this is incongruent with mutation-based testing methods, because it focuses on the correctness of a program for a test, while the essence of mutation-based testing concerns the differences between programs (including mutants) for a test. In this paper, we begin the\u00a0\u2026", "num_citations": "23\n", "authors": ["2031"]}
{"title": "Comprehensive analysis of FBD test coverage criteria using mutants\n", "abstract": " Function block diagram (FBD), a graphical modeling language for programmable logic controllers, has been widely used to implement safety critical system software such as nuclear reactor protection systems. With the growing importance of structural testing for FBD models, structural test coverage criteria for FBD models have been proposed and evaluated using mutation analysis in our previous work. We extend the previous work by comprehensively analyzing the relationships among fault detection effectiveness, test suite size, and coverage level through several research questions. We generate a large number of test suites achieving an FBD test coverage ranging from 0 to 100\u00a0%, and we also generate many artificial faults (i.e. mutants) for the FBD models. Our analysis results show that the fault detection effectiveness of the FBD coverage criteria increases with increasing coverage levels, and the\u00a0\u2026", "num_citations": "17\n", "authors": ["2031"]}
{"title": "Human resource allocation in software project with practical considerations\n", "abstract": " Software planning is very important for the success of a software project. Even if the same developers work on the same project, the time span of the project and the quality of software may change based on the project plan. When software managers plan a software project, they strive to allocate human resources in a more efficient way to produce a better software with less cost. The planning process is, however, time-consuming and complicated, especially when the size of the software project is large.         Many approaches have been proposed to help software project managers by providing optimal human resource allocations in terms of minimizing the cost. Previous approaches, however, only concentrated on minimizing the cost, and no existing works have considered the practical issues affecting project schedules in practice.         We elicited the practical considerations relating to the human resource allocation\u00a0\u2026", "num_citations": "17\n", "authors": ["2031"]}
{"title": "Modeling and verification for different types of system of systems using prism\n", "abstract": " A System of Systems (SoS) consists of complex Constituent Systems (CSs), which have managerial and operational independence. As the CSs have independence, the degree of authority to control the CSs varies depending on the different types of SoS, such as directed, acknowledged, and collaborative SoS. While many researchers have attempted to model SoSs and verify SoS-level goals, little attention has been paid to how different types of SoSs are characterized and realized during modeling and verification. Using a mass casualty incident response system as a common working example for different types of a SoS, we model the types of SoS with probabilistic models of PRISM, which can capture uncertain behaviors of an SoS in a quantitative manner and perform statistical model checking in order to verify to which extent each type of SoS achieves the SoS-level goal. Differences between the different types\u00a0\u2026", "num_citations": "16\n", "authors": ["2031"]}
{"title": "Practical Human Resource Allocation in Software Projects Using Genetic Algorithm\n", "abstract": " Software planning is becoming more complicated as the size of software project grows, making the planning process more important. Many approaches have been proposed to help software project managers by providing optimal human resource allocations in terms of minimizing the cost. Since previous approaches only concentrated on minimizing the cost, there has not been a study that considers the practical issues affecting project schedule in practice. We elicited the practical considerations on the human resource allocation problem by communicating with a group of software project experts. In this paper, we propose an approach for solving the human resource allocation problem using a genetic algorithm (GA) reflecting the practical considerations. Our experiment shows that our algorithm considers the practical considerations well, in terms of continuous allocation on relevant tasks, minimization of developer multitasking time, and balance of allocation.", "num_citations": "16\n", "authors": ["2031"]}
{"title": "Formal modeling and verification of a federated byzantine agreement algorithm for blockchain platforms\n", "abstract": " A blockchain is a type of distributed ledger that can record transactions between parties in a verifiable and permanent manner. Each node contains its ledger, and the contents of each ledger are maintained to be the same by a consensus algorithm. It is essential to ensure the safety and liveness of the consensus algorithms in blockchain platforms. The Stellar Consensus Protocol (SCP), which is a consensus algorithm for the Stellar cryptocurrency using the blockchain, is utilized for the federated Byzantine agreement. The quorum configuration is one of the essential factors for ensuring the safety and liveness of the SCP; however, it has been rarely studied. In this study, we model the SCP with timed automata and verify the model using a model checking technique, with the purpose of investigating and evaluating the SCP. Through the modeling and verification of the SCP, we could check whether a certain quorum\u00a0\u2026", "num_citations": "14\n", "authors": ["2031"]}
{"title": "A runtime verification framework for dynamically adaptive multi-agent systems\n", "abstract": " Dynamically adaptive multi-agent systems (DAMS) consist of multiple agents that adapt to changing system and environmental conditions in order to achieve collaborative goals. As DAMS are found in applications across various domains, ensuring the correct and safe adaptations of DAMS has become more important. Formal verification techniques such as model checking present a promising approach to guaranteeing the correctness of a software system with respect to certain system requirements. Previous works on formal verification for dynamically adaptive system or multi-agent system, however, have not addressed the runtime and collaborative nature inherent to DAMS operations. This work proposes a runtime verification framework for DAMS (DAMS-RV) based on an adaptive feedback loop, which is activated for each adaptation that system makes after a change in the system or environment. The proposed\u00a0\u2026", "num_citations": "9\n", "authors": ["2031"]}
{"title": "Digital Twins Are Not Monozygotic\u2013Cross-Replicating ADAS Testing in Two Industry-Grade Automotive Simulators\n", "abstract": " The increasing levels of software- and data-intensive driving automation call for an evolution of automotive soft-ware testing. As a recommended practice of the Verification and Validation (V&V) process of ISO/PAS 21448, a candidate standard for safety of the intended functionality for road vehicles, simulation-based testing has the potential to reduce both risks and costs. There is a growing body of research on devising test automation techniques using simulators for Advanced Driver-Assistance Systems (ADAS). However, how similar are the results if the same test scenarios are executed in different simulators? We conduct a replication study of applying a Search-Based Software Testing (SBST) solution to a real-world ADAS (PeVi, a pedestrian vision detection system) using two different commercial simulators, namely, TASS/Siemens PreScan and ESI Pro-SiVIC. Based on a minimalistic scene, we compare critical\u00a0\u2026", "num_citations": "5\n", "authors": ["2031"]}
{"title": "Mutation analysis for system of systems policy testing\n", "abstract": " A System of Systems (SoS) is a set of the constituent systems (CS) which has managerial and operational independence. To address an SoS-level goal that cannot be satisfied by each CS, an SoS policy guides or forces the CSs to collaborate with each other. If there is a fault in the SoS policy, SoS may fail to reach its goal, even if there is no fault in the CSs. Such a call for SoS policy testing leads to an essential question-how can testers evaluate the effectiveness of test cases?In this paper, we suggest a mutation analysis approach for SoS policy testing. Mutation analysis is a systematic way of evaluating test cases using artificial faults called mutants. As a general mutation framework for SoS policy testing, we present an overview of mutation analysis in SoS policy testing as well as the key aspects that must be defined in practice. To demonstrate the applicability of the proposed approach, we provide a case study\u00a0\u2026", "num_citations": "5\n", "authors": ["2031"]}
{"title": "Efficient testing of self-adaptive behaviors in collective adaptive systems\n", "abstract": " Collective adaptive systems (CAS) consist of multiple agents that adapt to changing system and environmental conditions in order to satisfy system goals and quality requirements. As more applications involve using CAS in a critical context, ensuring the correct and safe adaptive behaviors of quality-driven CAS has become more important. In this paper, we propose Collective Adaptive System Testing (CAST), a scalable and efficient approach to testing self-adaptive behaviors of CAS. We propose a selective method to instantiate and execute test cases relevant to the current adaptation context. This enables testers to focus testing on key self-adaptive behaviors while dealing with the scale and dynamicity of the system. An experimental evaluation using a traffic monitoring system is performed to validate its scalability, efficiency, and fault-detection effectiveness. The experimental results provide insights into how\u00a0\u2026", "num_citations": "4\n", "authors": ["2031"]}
{"title": "ABC+ extended action-benefit-cost modeling with knowledge-based decision-making and interaction model for system of systems simulation\n", "abstract": " The system of systems (SoS) is a large-scale and complex system composed of autonomous and independent constituent systems (CSs). It deals with complex requirements as SoS-level goals that are not able to be satisfied by a single CS. To analyze SoS-level behaviors considering CSs' autonomy and independence, SoS-level engineers need to model and simulate an SoS properly. Action-Benefit-Cost (ABC) modeling provides an effective and efficient way to model and simulate the autonomous and independent behaviors of CSs by focusing on their external actions, benefits, and costs. However, ABC modeling does not support internal-knowledge of a CS. In addition, ABC modeling does not support communications between CSs. SoS engineers also have difficulty in reflecting all possible interaction into models in advance of simulation. In this paper, we propose ABC+ modeling, which supports the three\u00a0\u2026", "num_citations": "3\n", "authors": ["2031"]}
{"title": "An Applicability Study of Action-Benefit-Cost Model and Statistical Model Checking for System of Systems Goal Achievement Verification\n", "abstract": " The notion of System of Systems (SoS), which is composed by many independent systems (ie, Constituent Systems, CS), has emerged in various domains including social infrastructure. It is widely expected that complex requirements, which cannot be achieved in each CS-level, will be achieved in an SoS-level. While verification of SoS-level goal achievement is one of the most important problems, concrete case studies on SoS modeling and verification are still rare. In this paper, we focus on the fact that each CS performs an action for its own purpose by its own decision-making mechanism. We propose a novel Action-Benefit-Cost (ABC) SoS model which caters to the independent decision-making mechanisms of CSs. Using an abstract SoS example, this proposal provides a case study for the modeling and quantitative verification of the ABC SoS model.", "num_citations": "2\n", "authors": ["2031"]}
{"title": "Quality based software project staffing and scheduling with cost bound\n", "abstract": " Software project planning is becoming more complicated and important as the size of software project grows. Many approaches have been proposed to help project managers by providing optimal staffing and scheduling in terms of minimizing the cost (i.e., necessary expanse) or time (i.e., time span or duration) required for the software project. Unfortunately, the software quality, another critical factor in software project planning, is largely overlooked in previous work. In this paper, we propose the quality based software project staffing and scheduling approach using a genetic algorithm (GA). We define a quality score by considering practical issues in software project planning in addition to task severity and defect amplification model. Further, the cost is utilized as a cost-bound in the GA to consider not only quality but also cost. Case study shows that the proposed approach improves the quality while the cost is\u00a0\u2026", "num_citations": "2\n", "authors": ["2031"]}
{"title": "\uc758\ub8cc \ub3c4\uba54\uc778 \uc790\uac00 \uc801\uc751\ud615 \uc2dc\uc2a4\ud15c \uc815\ud615 \uac80\uc99d \uc0ac\ub840\uc5f0\uad6c \ubc0f \ubd84\uc11d\n", "abstract": " DSpace at KOASAS: \uc758\ub8cc \ub3c4\uba54\uc778 \uc790\uac00 \uc801\uc751\ud615 \uc2dc\uc2a4\ud15c \uc815\ud615 \uac80\uc99d \uc0ac\ub840\uc5f0\uad6c \ubc0f \ubd84\uc11d KOASAS menu About KOASAS KAIST Library \uac80\uc0c9 Advanced Search Browse Communities & Collections Researchers at KAIST Titles Subject By Date rss_1.rss_2.atom_1.sherpa SEARCH DSpace at KOASAS College of Engineering(\uacf5\uacfc\ub300\ud559)School of Computing(\uc804\uc0b0\ud559\ubd80)CS-Conference Papers(\ud559\uc220\ud68c\uc758\ub17c\ubb38) \uc758\ub8cc \ub3c4\uba54\uc778 \uc790\uac00 \uc801\uc751\ud615 \uc2dc\uc2a4\ud15c \uc815\ud615 \uac80\uc99d \uc0ac\ub840\uc5f0\uad6c\ubc0f \ubd84\uc11d Cited 0 time in webofscience Cited 0 time in scopus Hit : 197 Download : 0 Export DC(XML) Excel \uc784\uc720\uc9c4 / \uc2e0\ub3d9\ud658 / \uc9c0\uc740\uacbd / \ubc15\uc9c0\ud6c8 / \ubc30\ub450\ud658researcher Publisher \uc18c\ud504\ud2b8\uc6e8\uc5b4\uacf5\ud559 \uc18c\uc0ac\uc774\uc5b4\ud2f0 Issue Date 2014-02-13 Language KOR Citation 2014 \ud55c\uad6d\uc18c\ud504\ud2b8\uc6e8\uc5b4\uacf5\ud559 \ud559\uc220\ub300\ud68c, v.16, no.1, pp.15 - 22 URI http://hdl.handle.net/10203/199338 Appears in Collection CS-Conference Papers(\ud559\uc220\ud68c \uc758\ub17c\ubb38) Files in This Item There are no files associated with this item. Display Full \u2026", "num_citations": "2\n", "authors": ["2031"]}
{"title": "Effective Removal of Operational Log Messages: an Application to Model Inference\n", "abstract": " Model inference aims to extract accurate models from the execution logs of software systems. However, in reality, logs may contain some \"noise\" that could deteriorate the performance of model inference. One form of noise can commonly be found in system logs that contain not only transactional messages---logging the functional behavior of the system---but also operational messages---recording the operational state of the system (e.g., a periodic heartbeat to keep track of the memory usage). In low-quality logs, transactional and operational messages are randomly interleaved, leading to the erroneous inclusion of operational behaviors into a system model, that ideally should only reflect the functional behavior of the system. It is therefore important to remove operational messages in the logs before inferring models. In this paper, we propose LogCleaner, a novel technique for removing operational logs messages. LogCleaner first performs a periodicity analysis to filter out periodic messages, and then it performs a dependency analysis to calculate the degree of dependency for all log messages and to remove operational messages based on their dependencies. The experimental results on two proprietary and 11 publicly available log datasets show that LogCleaner, on average, can accurately remove 98% of the operational messages and preserve 81% of the transactional messages. Furthermore, using logs pre-processed with LogCleaner decreases the execution time of model inference (with a speed-up ranging from 1.5 to 946.7 depending on the characteristics of the system) and significantly improves the accuracy of the inferred models, by\u00a0\u2026", "num_citations": "1\n", "authors": ["2031"]}
{"title": "Quality-based software project staffing and scheduling with project deadline\n", "abstract": " Software project planning includes several processes for estimating the effort required to complete software project tasks, allocating human resources to tasks, and creating a project plan. Because software planning is becoming more complicated as the size of software projects grow, it is difficult for project managers to decide on a reasonable project plan. To help them, many automatic software project planning approaches have been proposed. The approaches all focus on minimizing project duration. But if the plan is simply to minimize the duration, without considering software quality, the plan can harm the eventual software quality. In our research to create a reasonable project plan, we consider software quality as well as duration of the project, by defining a software quality score. The project manager can plan the project to maximize software quality for a specific project duration.", "num_citations": "1\n", "authors": ["2031"]}
{"title": "\uc18c\ud504\ud2b8\uc6e8\uc5b4 \uc0b0\uc5c5\uccb4 \ud53c\ub4dc\ubc31\uc744 \ubc18\uc601\ud55c \uc790\ub3d9\ud654\ub41c \uc778\ub825 \ud560\ub2f9\n", "abstract": " \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ud504\ub85c\uc81d\ud2b8\uc758 \uc131\uacf5\uc801 \uc218\ud589\uc744 \uc704\ud574\uc11c\ub294 \ud504\ub85c\uc81d\ud2b8 \ucd08\uae30 \ub2e8\uacc4\uc5d0\uc11c \ud569\ub9ac\uc801 \uc778\ub825\uacc4\ud68d\uc744 \uc138\uc6b0\uace0 \ud560\ub2f9\ud558\ub294 \uac83\uc774 \uc911\uc694\ud558\ub2e4. \uc774 \uacfc\uc815\uc5d0\uc11c \uad00\ub9ac\uc790\ub294 \uc790\ub3d9\ud654\ub41c \uc778\ub825\ud560\ub2f9 \uae30\ubc95\uc744 \ud1b5\ud574 \ud569\ub9ac\uc801 \uc758\uc0ac\uacb0\uc815\uc744 \uc9c0\uc6d0\ubc1b\uace0 \ube44\ud569\ub9ac\uc801 \uc778\ub825\ud560\ub2f9\uc73c\ub85c \uc778\ud574 \ubc1c\uc0dd\ud560 \uc218 \uc788\ub294 \ub9ac\uc2a4\ud06c\ub97c \uc904\uc77c \uc218 \uc788\ub2e4. \uc778\ub825\ud560\ub2f9 \uae30\ubc95\uc774 \uc0b0\uc5c5\uc801\uc73c\ub85c \uc720\uc6a9\ud558\uae30 \uc704\ud574\uc11c\ub294 \uc2e4\uc81c \uc2e4\ubb34\uc5d0\uc11c \uad00\ub9ac\uc790\uac00 \uace0\ub824\ud558\ub294 \uad6c\uccb4\uc801 \uc774\uc288\ub4e4\uc744 \ubc18\uc601\ud558\uc5ec \ud569\ub9ac\uc801 \ud560\ub2f9 \uacb0\uacfc\ub97c \uc0b0\ucd9c\ud560 \uc218 \uc788\uc5b4\uc57c \ud55c\ub2e4. \ubcf8 \uc5f0\uad6c\uc5d0\uc11c\ub294 \ud504\ub85c\uc81d\ud2b8 \uacc4\ud68d \ubc0f \uad00\ub9ac\uc5d0 \uc788\uc5b4 \ub9ce\uc740 \uacbd\ud5d8\uc744 \ucd95\uc801\ud574\uc628 \uc0b0\uc5c5\uccb4\uc640\uc758 \ud611\uc758\ub97c \ud1b5\ud574 \uc2e4\ubb34 \uc774\uc288\ub97c \ubc18\uc601\ud55c \uc778\ub825\ud560\ub2f9 \uae30\ubc95\uc744 \uac1c\ubc1c\ud55c\ub2e4. \uac1c\ubc1c\ub41c \uae30\ubc95\uc758 \ud504\ub85c\ud1a0\ud0c0\uc785 \uad6c\ud604\uc744 \ud1b5\ud574 \uae30\ubc95\uc5d0 \ubc18\uc601\ub41c \uc2e4\ubb34 \uc774\uc288\uac00 \ud560\ub2f9 \uacb0\uacfc\uc5d0 \ubbf8\uce58\ub294 \uc601\ud5a5\uc744 \ubd84\uc11d\ud558\uace0 \ud574\ub2f9 \uc774\uc288 \uace0\ub824\uc758 \ud569\ub9ac\uc131\uc744 \ud30c\uc545\ud55c\ub2e4. \uacb0\ub860\uc801\uc73c\ub85c, \ubcf8 \uc5f0\uad6c\uc5d0\uc11c\ub294 \uae30\uc874 \uae30\ubc95\uc5d0\uc11c \ubc18\uc601\ub418\uc9c0 \ubabb\ud588\ub358 \uc774\uc288\ub4e4\uc744 \ubc18\uc601\ud55c \uc0c8\ub85c\uc6b4 \uae30\ubc95\uc744 \uc81c\uc548\ud558\uc600\ub2e4.", "num_citations": "1\n", "authors": ["2031"]}
{"title": "FBD \ubaa8\ub378 \ub300\uc0c1 \ubba4\ud14c\uc774\uc158 \uc5f0\uc0b0\uc790 \uc815\uc758 \ubc0f \uc0ac\ub840\uc5f0\uad6c\n", "abstract": " Function Block Diagram(FBD)\ub294 \uc0b0\uc5c5\uc6a9 \ucef4\ud4e8\ud130\uc778 Programmable Logic Controller(PLC)\uc758 \ud45c\uc900 \ud504\ub85c\uadf8\ub798\ubc0d \uc5b8\uc5b4 \uc911 \ud558\ub098\uc774\ub2e4. \ub2e4\uc591\ud55c \uc2dc\ud5d8 \uae30\ubc95\ub4e4\uc758 \uc624\ub958 \uac80\ucd9c \ud6a8\uacfc\uc131\uc744 \ud3c9\uac00\ud558\uae30 \uc704\ud574 \ubba4\ud14c\uc774\uc158 \ubd84\uc11d \uae30\ubc95\uc774 \ub110\ub9ac \uc4f0\uc774\uace0 \uc788\ub294\ub370, FBD \ubaa8\ub378\uc5d0 \ub300\ud55c \ubba4\ud14c\uc774\uc158 \uc5f0\uc0b0\uc790\uac00 \uc815\uc758\ub418\uc5b4 \uc788\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0 \uc801\uc6a9\uc5d0 \uc5b4\ub824\uc6c0\uc774 \uc788\uc5c8\ub2e4. \ubcf8 \uc5f0\uad6c\uc5d0\uc11c\ub294 FBD \ubaa8\ub378\uc758 \ud2b9\uc131, \ub2e4\uc591\ud55c FBD \ubaa8\ub378\uc758 \uc2e4\uc81c \uc624\ub958 \ubc0f \uae30\uc874 \ubba4\ud14c\uc774\uc158 \ubd84\uc11d \uae30\ubc95\uc5d0 \uad00\ud55c \ubd84\uc11d\uc744 \ud1b5\ud574 \ubba4\ud14c\uc774\uc158 \uc5f0\uc0b0\uc790\ub97c \uc815\uc758\ud55c\ub2e4. \uc815\uc758\ub41c FBD \ubba4\ud14c\uc774\uc158 \uc5f0\uc0b0\uc790\ub97c \ud65c\uc6a9\ud558\uc5ec \uc2e4\uc81c \uc0b0\uc5c5\uacc4\uc5d0\uc11c \uc4f0\uc774\ub294 FBD \ubaa8\ub378\uc744 \ub300\uc0c1\uc73c\ub85c \ubba4\ud14c\uc774\uc158 \ubd84\uc11d\uc744 \uc218\ud589\ud558\uc5ec FBD \ubaa8\ub378 \uc2dc\ud5d8 \ub370\uc774\ud130\uc640 \uc2dc\ud5d8 \uae30\ubc95\uc744 \uccb4\uacc4\uc801\uc73c\ub85c \ud3c9\uac00\ud55c\ub2e4.", "num_citations": "1\n", "authors": ["2031"]}