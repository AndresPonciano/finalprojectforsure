{"title": "Preserving architectural choices throughout the component-based software development process\n", "abstract": " It is argued that architecture comprehension and regression testing of a software system are the most expensive maintenance activities. This is mainly due to the fact that architectural choices are either not explicit, at every stage of the software development process, or not preserved from one stage to another. In this paper, we present an Architectural Constraint Language (ACL) as a means to formally describe architectural choices at all the stages. This language is based on the UML\u2019s Object Constraint Language and on a set of MOF-compliant metamodels. We also present a prototype which validates the proposed approach. It allows the evaluation of ACL expressions at two stages and ensures, by using a transformation mechanism, that the constraints stated at one stage are subsequently preserved.", "num_citations": "33\n", "authors": ["95"]}
{"title": "A practical approach to the measurement of similarity between wsdl-based web services\n", "abstract": " Similarity measurement between web services is a key solution to benefit from the reuse of the large number of web services freely available in the internet. This paper presents a practical approach that enables an effective measurement of web service similarity based on their interfaces descibed with WSDL. The approach relies on the use of multiple matching techniques and different semantic and structural similarity metrics. The measurement of similarity determines the best substitute for a failed web service. So, it serves as a good indicator of the substitutability relation and thus of the capacity for reuse. A support tool, implementing the approach, is also presented with some experimental results conducted on real-world web services.", "num_citations": "32\n", "authors": ["95"]}
{"title": "QoS-aware optimal and automated semantic web service composition with user\u2019s constraints\n", "abstract": " Automated semantic web service composition is one of the critical research challenges of service-oriented computing, since it allows users to create an application simply by specifying the inputs that the application requires, the outputs it should produce, and any constraints it should respect. The composition problem has been handled using a variety of techniques, from artificial intelligence planning to optimization algorithms. However no approach so far has focused on handling three composition dimensions simultaneously, producing solutions that are: (1) fully functional (i.e., fully executable) by using a mechanism of semantic matching between the services involved in the solutions, (2) are optimized according to non-functional quality-of-service (QoS) measurements, and (3) respect global QoS constraints. This paper presents a novel approach based on a Harmony Search algorithm that addresses\u00a0\u2026", "num_citations": "31\n", "authors": ["95"]}
{"title": "A family of languages for architecture constraint specification\n", "abstract": " During software development, architecture decisions should be documented so that quality attributes guaranteed by these decisions and required in the software specification could be persisted. An important part of these architectural decisions is often formalized using constraint languages which differ from one stage to another in the development process. In this paper, we present a family of architectural constraint languages, called ACL. Each member of this family, called a profile, can be used to formalize architectural decisions at a given stage of the development process. An ACL profile is composed of a core constraint language, which is shared with the other profiles, and a MOF architecture metamodel. In addition to this family of languages, this paper introduces a transformation-based interpretation method of profiles and its associated tool.", "num_citations": "31\n", "authors": ["95"]}
{"title": "On-demand quality-oriented assistance in component-based software evolution\n", "abstract": " During an architectural evolution of a component-based software, certain quality attributes may be weakened. This is due to the lack of an explicit definition of the links between these non-functional characteristics and the architectural decisions implementing them. In this paper, we present a solution that aims at assisting the software maintainer during an evolution activity on his demand. It requires the definition of a documentation during development, organized in the form of bindings between formal descriptions of architectural decisions and their targeted quality attributes. Through an assistance algorithm, the approach uses this documentation in order to notify the maintainer of the possible effects of architectural changes on quality requirements. We also present a prototype tool which automates our proposals. This tool and the overall approach has been experienced on a real-world software in order to\u00a0\u2026", "num_citations": "29\n", "authors": ["95"]}
{"title": "Automatic web service tagging using machine learning and wordnet synsets\n", "abstract": " The importancy of Web services comes from the fact that they are an important means to realize SOA applications. Their increasing popularity caused the emergence of a fairly huge number of services. Therefore, finding a particular service among this large service space can be a hard task. User tags have proven to be a useful technique to smooth browsing experience in large document collections. Some service search engines proposes the facility of service tagging. It is usually done manually by the providers and the users of the services, which can be a fairly tedious and error prone task. In this paper we propose an approach for tagging Web services automatically. It adapts techniques from text mining and machine learning to extract tags from WSDL descriptions. Then it enriches these tags by extracting relevant synonyms using WordNet. We validated our approach on a corpus of 146 services\u00a0\u2026", "num_citations": "28\n", "authors": ["95"]}
{"title": "Using concept lattices to support web service compositions with backup services\n", "abstract": " In SOA, composite applications can be developed on the basis of collections of interacting web services. A service's functionality is exposed to the external world by an abstract interface, described by the standard WSDL language, which must be published by service providers to public registries where service consumers can find them. Nowadays, web service discovery has become a real problem, because of the lack of public registries to publish and organize the fairly huge number of existing services. In this paper, we propose an approach based on formal concept analysis (FCA) for classifying and browsing web services. Using this approach, the web services are organized into a lattice structure, to facilitate their browse and selection. A service lattice reveals the invisible relations between the services, enabling the discovery of a needed service as well as the identification of its possible alternatives. Thus\u00a0\u2026", "num_citations": "25\n", "authors": ["95"]}
{"title": "Component-based specification of software architecture constraints\n", "abstract": " Component-based software engineering provides for developers the ability to easily reuse and assemble software entities to build complex software. Component-based specification of software functional characteristics has been and is largely addressed, however this is not yet the case for what concerns software non-functional characteristics. In this paper, we propose a new way to express component-based software non-functional documentation, and we will focus more specifically on architecture constraints which formalize parts of architecture decisions, as executable, customizable, reusable and composable building blocks represented by components. Checking of architecture constraints is provided via service invocation through ports of a special kind of components, called constraint-components. The signatures of these checking services can be defined in required interfaces of business components, to\u00a0\u2026", "num_citations": "24\n", "authors": ["95"]}
{"title": "Software architecture constraint reuse-by-composition\n", "abstract": " Architecture constraints are specifications which enable developers to formalize design rules that architectures should respect, like the topological conditions of a given architecture pattern or style. These constraints can serve as a documentation to better understand an existing architecture description, or can serve as invariants that can be checked after the application of an architecture change to see whether design rules still hold. Like any specifications, architecture constraints are frequently subject to reuse. Besides, these constraints are specified and checked during architecture design time, when component descriptions are specified or selected from repositories, then instantiated and connected together to define architecture descriptions. These two facts (being subject to reuse and instantiation/connection) make architecture constraints good candidates for component-based design within a unified\u00a0\u2026", "num_citations": "22\n", "authors": ["95"]}
{"title": "Automatic tag identification in web service descriptions\n", "abstract": " With the increasing interest toward service-oriented architectures, the number of existing Web services is dramatically growing. Therefore, finding a particular service among this huge number of services is becoming a time-consuming task. User tags or keywords have proven to be a useful technique to smooth browsing experience in large document collections. Some service search engines, like Seekda, already propose this kind of facility. Service tagging, which is a fairly tedious and error prone task, is done manually by the providers and the users of the services. In this paper we propose an approach that automatically extracts tags from Web service descriptions. It identifies a set of relevant tags extracted from a service description and leaves only to the users the task of assigning tags not present in this description. The proposed approach is validated on a corpus of 146 services extracted from Seekda.", "num_citations": "21\n", "authors": ["95"]}
{"title": "Backing composite web services using formal concept analysis\n", "abstract": " A Web service is a software functionality accessible through the network. Web services are intended to be composed into coarser-grained applications. Achieving a required composite functionality requires the discovery of a collection of Web services out of the enormous service space. Each service must be examined to verify its provided functionality, making the selection task neither efficient nor practical. Moreover, when a service in a composition becomes unavailable, the whole composition may become functionally broken. Therefore, an equivalent service must be retrieved to replace the broken one, thus spending more time and effort. In this paper, we propose an approach for Web service classification based on FCA, using their operations estimated similarities. The generated lattices make the identification of candidate substitutes to a given service straightforward. Thus, service compositions can be\u00a0\u2026", "num_citations": "19\n", "authors": ["95"]}
{"title": "Simplifying transformation of software architecture constraints\n", "abstract": " The heterogeneity of the architectural constraint languages makes difficult the transformation of constraints throughout the development process. Indeed they have significantly different metamodels, which make the definition of mapping rules complex. In this paper, we present an approach that aims at simplifying transformations of architectural constraints. It is based on an architectural constraint language (ACL), which includes one core constraint expression language and different profiles. Each profile is defined upon a metamodel, which represents the architectural abstractions manipulated at each stage in the development process.", "num_citations": "18\n", "authors": ["95"]}
{"title": "Design of a UML profile for feature diagrams and its tooling implementation\n", "abstract": " This paper proposes an instrumented solution to integrate feature diagrams with UML models to be used as part of a general approach for designing software product lines and for product generation. The contribution is implemented in IBM Rational Software Architect (RSA). It is intended to be used in the context of large, complex and multi-domain projects, and at allowing model transformations to derive products. Our RSA implementation makes it possible to link feature diagrams with UML model artifacts. It allows traceability between feature models and other different kinds of models (requirements, class diagrams, sequence or activity diagrams, etc.). It is used in a project dedicated to create smart building optimization systems.", "num_citations": "17\n", "authors": ["95"]}
{"title": "Automated architectural component classification using concept lattices\n", "abstract": " While the use of components grows in software development, building effective component directories becomes a critical issue as architects need help to search components in repositories. During the life-cycle of component-based software, several tasks, such as construction from scratch or component substitution, would benefit from an efficient component classification and retrieval. In this paper, we analyze how we can build a classification of components using their technical description (i.e. functions and interfaces) in order to help automatic as well as manual composition and substitution. The approach is implemented in the CoCoLa prototype, which is dedicated to Fractal component directory management and validated through a case study.", "num_citations": "14\n", "authors": ["95"]}
{"title": "Enforcing architecture and deployment constraints of distributed component-based software\n", "abstract": " In the component-based software development process, the formalisation of architectural choices makes possible to explicit quality attributes. When dealing with the deployment of such component-based software in dynamic networks, in which disconnections or machine failures can occur, preserving architectural choices becomes difficult to ensure, as current architecture-centric languages and their support mainly focus on steps prior to the deployment one. We present in this paper a family of languages that formalise not only architectural choices but deployment aspects as well, both as constraints. Then, we show how all of these constraints are reified in order to manage the deployment of a component-based software in this context of a dynamic hosting platform. The proposed solution defines an automatic deployment that ensures permanently, at run time, the preservation of architecture and deployment\u00a0\u2026", "num_citations": "12\n", "authors": ["95"]}
{"title": "Opening web applications for third-party development: a service-oriented solution\n", "abstract": " Web applications are nowadays prevalent software systems in our everyday\u2019s life. A lot of these applications have been developed for end users only. Thus, they are not designed by considering future extensions that would be developed by third parties. One possible and interesting solution for opening these applications for such kind of extension development is to create and deploy Web services starting from these applications. In this paper, we present a method and a tool for semiautomatically creating Web service implementations from applications having Web interfaces. The proposed method generates operations that are published in Web services for each functionality provided by a Web application. In addition, it generates new operations starting from Web interfaces. Our approach goes further in the creation of services by generating executable orchestrations, as BPEL processes, starting from\u00a0\u2026", "num_citations": "11\n", "authors": ["95"]}
{"title": "Regression-based bootstrapping of web service reputation measurement\n", "abstract": " In the literature, many solutions for measuring the reputation of web services have been proposed. These solutions help in building service recommendation systems. Nonetheless, there are still many challenges that need to be addressed in this context, such as the \"cold start\" problem, and the lack of estimation of the initial reputation values of newcomer web services. As reputation measurement depends on the previous reputation values, the lack of initial values can subvert the performance of the whole service recommendation system, making it vulnerable to different threats, like the Sybil attack. In this paper, we propose a new bootstrapping mechanism for evaluating the reputation of newcomer web services based on their initial Quality of Service (QoS) attributes, and their similarity with \"long-standing\" web services. Basically, the technique uses regression models for estimating the unknown reputation values of\u00a0\u2026", "num_citations": "11\n", "authors": ["95"]}
{"title": "A process to identify relevant substitutes for healing failed WS-* orchestrations\n", "abstract": " Orchestrating web services aims to compose multiple services into workflows that answer complex user requirements. Web services are software components which are exposed to errors and failures that can occur during web service orchestration execution. Thus, many error-handling and healing approaches have been proposed to guarantee reliable orchestrations. Some of these approaches rely on the identification of relevant service substitutes to heal (by substitution) the defected services. In this paper, we propose an identification process of web service substitutes for healing failed web service orchestrations based on the measurement of similarity between service interfaces. The process reveals both simple and complex (compositions of) substitutes. We validated the approach via a set of experiments conducted on a collection of real web services.", "num_citations": "10\n", "authors": ["95"]}
{"title": "Nfrs-aware architectural evolution of component-based software\n", "abstract": " During software maintenance, some non-functional properties may be lost. This is due to the lack of an explicit definition of their links with the corresponding architectural choices. In this paper, we present a solution that automates the checking of non-functional properties after the evolution of a component-based software. Our approach emphasizes the interest of formally documenting the links binding non-functional requirements to architectural choices. The proposed formalism is based on the Object Constraint Language (OCL) applied to a software component metamodel. We also present a prototype tool which uses this documentation to warn the developer of possible effects of an architectural change on non-functional requirements.", "num_citations": "9\n", "authors": ["95"]}
{"title": "Le contrat d'\u00e9volution d'architectures. Un outil pour le maintien de propri\u00e9t\u00e9s non fonctionnelles.\n", "abstract": " Tout logiciel doit \u00e9voluer pour r\u00e9pondre aux exigences changeantes de ses utilisateurs et aux modifications de son environnement. Ces changements, souvent impr\u00e9visibles, r\u00e9alis\u00e9s par un tiers et dans l\u2019urgence, m\u00e8nent parfois le logiciel vers un \u00e9tat que ses cr\u00e9ateurs n\u2019auraient pas souhait\u00e9. Nous pr\u00e9sentons dans cet article un cadre pour une \u00e9volution contr\u00f4l\u00e9e d\u2019applications \u00e0 base de composants. Ce contr\u00f4le garantit la pr\u00e9servation de propri\u00e9t\u00e9s architecturales et par l\u00e0, de certaines propri\u00e9t\u00e9s non fonctionnelles.ABSTRACT. Software systems should evolve in order to respond to changing client requirements and their evolving environments. These changes, often unforeseen, done by tiers and in urgency, lead sometimes the software to a state initially undesired by its creators. We present, in this paper, a framework to preserve the consistency of component-based applications during their evolution. This evolution consistency is achieved by maintaining some architectural strategies and thus, preserving the corresponding non-functional properties indicated as important.", "num_citations": "9\n", "authors": ["95"]}
{"title": "A component-based meta-level architecture and prototypical implementation of a reflective component-based programming and modeling language\n", "abstract": " Component-based Software Engineering studies the design, development and maintenance of software constructed upon sets of connected components. Using existing standard solutions, component-based models are frequently transformed into non-component-based programs, most of the time object-oriented, for run-time execution. As a consequence many component-level descriptions (part of code), eg explicit architectures or ports declarations, vanish at the implementation stage, making debugging, transformations or reverse-engineering difficult. It has been shown that component-based programming languages contribute to bridge this gap between design and implementation and to provide a conceptual and practical continuum to fully develop applications with components. In this paper we go one step further in this direction by making a component-oriented programming and modeling language truly\u00a0\u2026", "num_citations": "8\n", "authors": ["95"]}
{"title": "An inheritance system for structural & behavioral reuse in component-based software programming\n", "abstract": " In the context of Component-based Programming, which addresses the implementation stage of a component-based software engineering development process, this paper describes a specification and an operational integration of an inheritance system into a self-contained new component-based programming language named Compo. Our proposal completes and extends related works by making it possible to apply inheritance to the full description of components, i.e. both to structural (description of provisions and requirements, of component architecture) and behavioral (full implementations of services) parts in component descriptions. Inheritance in Compo is designed to be used in conjunction with composition to maximize reuse capabilities and expressive power. Compo implementation proposes a clear operational solution for inheritance and for achieving and testing substitutions.", "num_citations": "8\n", "authors": ["95"]}
{"title": "Migrating Component-Based Web Applications to Web Services: Towards Considering a\" Web Interface as a Service\"\n", "abstract": " Web component-based development is a challenging development paradigm, whose attraction to practitioners is increasing more and more. One of the main advantages of this paradigm is the ability to build customizable and composable web application modules as independent units of development, and to share them with other developers by publishing them in libraries as COTS (Commercial Off The Shelf) or free components. In parallel, since many years, Web services confirmed their status of one of the most pertinent solutions for a service provider, like Google or Amazon, to open its solutions for third party development. In this paper, we present an approach to migrate existing web component-based applications to a set of primitive and composite Web services and deploy them on a web service provider. This transformation helps server-side web application developers in transforming their \"user interface\"\u00a0\u2026", "num_citations": "8\n", "authors": ["95"]}
{"title": "Supervising the evolution of web service orchestrations using quality requirements\n", "abstract": " Since many years, Web services have confirmed their status of one of the most pertinent solutions for a given service provider, like Google, Amazon or FedEx, to open its solutions for third party software development. New business logic can be implemented through orchestrations of existing Web services. This helps development teams in capitalizing resources held by the providers of these services. Nonetheless, these service-oriented software architectures, like any other software artifact, are subject to changes during their lifecycle, and thus can undergo an evolution phenomenon. In this phenomenon, it is argued that quality can be weakened after successive changes (Lehman\u2019s 7th law of software evolution), and this is mainly due to the lack of architecture documentation and tool support to supervise architecture changes. In this paper, we present an approach to supervise the evolution of Web service\u00a0\u2026", "num_citations": "8\n", "authors": ["95"]}
{"title": "Building the presentation-tier of rich web applications with hierarchical components\n", "abstract": " Nowadays information systems are increasingly distributed and deployed within the Internet platform. Without any doubt, the World Wide Web represents the de facto standard platform for hosting such distributed systems. The use of a multi-tiered architecture to develop such systems is often the best design decision to reach scalability, maintainability and reliability quality goals. Software in the presentation-tier of this architecture needs in practice to be designed with structured and reusable library modules. In this paper, we present a hierarchical component model which allows developers to build (model, generate code and then reuse) this software level of rich Web applications. In this model, components can be connected via their interfaces to build more complex components. These architecture design models can be reused together with their corresponding code using an association mechanism. As\u00a0\u2026", "num_citations": "8\n", "authors": ["95"]}
{"title": "Estimating the reputation of newcomer web services using a regression-based method\n", "abstract": " In this paper, we propose a novel method to estimate the initial reputation values of newcomer web services. In fact, the reputation of web services is one of the criteria used for recommending services in service-oriented computing environments. The lack of evaluating the initial reputation values can subvert the performance of a service recommendation system making it vulnerable to different threats like whitewashing and Sybil attacks, which negatively affect its quality of recommendation. The proposed method uses Quality of Service (QoS) attributes from a side, and reputation values of similar services from the second side, to estimate the reputation values of newcomer services. Basically, it employs regression models, including Support Vector Regression, in the estimation process of the unknown reputation values of newcomers from their known QoS values. We demonstrate the efficiency of the method in\u00a0\u2026", "num_citations": "7\n", "authors": ["95"]}
{"title": "Processing the evolution of quality requirements of web service orchestrations: a pattern-based approach\n", "abstract": " Currently Web services remain one of the leading technologies for implementing components of distributed service oriented software architectures. One of the most frequent form of compositions of these entities is Web service orchestration. As any other software artifact, such service compositions are subject to an unescapable evolution (Lehman's first law of software evolution). Either for answering new user requirements, for adapting, for correcting or for enhancing the provided functionality or quality, an architect has to conduct some evolutions on the design of these artifacts. In this paper, we present a method which aims at helping software architects of Web service orchestrations in processing an evolution of quality requirements. This method introduces a template for describing quality evolution \"intents\". It then analyzes these intents and assists the architects in answering them by proposing some patterns. We\u00a0\u2026", "num_citations": "7\n", "authors": ["95"]}
{"title": "Integrating quality requirements in engineering web service orchestrations\n", "abstract": " Today\u2019s Web services are considered as one of the leading technologies for implementing components of service-oriented software architectures for desktop, Web or mobile applications. When designing workflows of activities that involve the invocation of these Web Services, we build either orchestrations or choreographies. The engineering of such applications is an emerging research topic with many challenges. Among them, we can stress out the crucial question of how to answer quality requirements in such engineering processes. This paper, presents a method which aims at assisting software architects of Web Service orchestrations in integrating quality requirements in their artifacts. In order to satisfy a quality requirement, this method suggests a list of service-oriented patterns. We base our work on the postulate stating that quality can be implemented through patterns, which can be specified with checkable\u00a0\u2026", "num_citations": "6\n", "authors": ["95"]}
{"title": "A UML Pro\ufb01le for Feature Diagrams: Initiating a Model Driven Engineering Approach for Software Product Lines\n", "abstract": " This paper proposes an instrumented approach to integrate feature diagrams with UML models, via UML pro\ufb01les and a Rational Software Architect plugin. The concrete contribution is the speci\ufb01cation of a new UML pro\ufb01le based upon a meta-model synthesising existing feature diagrams semantics, and a Rational Software Architect (RSA) implementation. Our RSA implementation makes possible to link feature diagrams with UML model artefacts. Indeed, it allows traceability between feature models and other different kinds of models (requirements, class diagrams, sequences or activity diagrams, etc.).", "num_citations": "6\n", "authors": ["95"]}
{"title": "Towards software product lines application in the context of a smart building project\n", "abstract": " This paper presents proposals on how to apply software product lines in the context of smart buildings control systems. Our study is held in the context of the RIDER (Research for IT as a Driver of EneRgy efficiency) project, which is led by a consortium of several companies and research laboratories. The paper highlights various issues, including issues related to traceability, variability and automatic transformations in our specific application context. It then proposes solutions to apply existing concepts like feature diagrams, model-driven transformations and component-based architectures, or appropriate extensions of these concepts, in this context. Furthermore, we globally propose an approach to federate the various components involved in smart buildings, and to capitalize on the developed IT components by reusing them at the lower cost in the construction of future buildings.", "num_citations": "6\n", "authors": ["95"]}
{"title": "Specification and automatic checking of architecture constraints on object oriented programs\n", "abstract": " Context: Architecture constraints are specifications of conditions to which an architecture model must adhere in order to satisfy an architecture decision imposed by a given design principle. These constraints can be specified with predicate languages like OCL at design time and checked on design artifacts.Objective: Many works in the literature studied the importance of checking these constraints to guarantee quality on design models, and to prevent technical debt and maintenance difficulties. In this paper, we propose a process whose ultimate goal is to enable the checking of these constraints in the implementation stage.Method: The proposed process takes as input a textual specification of an architecture constraint specified at design stage. It translates this specification into meta-programs and then it uses them with aspect-oriented programming to check constraints at the implementation stage and at run-time\u00a0\u2026", "num_citations": "5\n", "authors": ["95"]}
{"title": "Generating reusable, searchable and executable \u201carchitecture constraints as services\u201d\n", "abstract": " Architecture constraints are components of design documentation. They enable designers to enforce rules that architecture descriptions should respect. Many systems make it possible to associate constraints to models at design stage but very few enable their association to code at implementation stage. When possible, this is done manually, which is a tedious, error prone and time consuming task. Therefore, we propose in this work a process to automatically generate executable constraints associated to programs\u2019 code from model-based constraints. First, the process translates the constraints specified at design-time into constraint-components described with an ADL, called CLACS. Then, it creates constraint-services which can be registered and later invoked to check their embedded constraints on component- and service-based applications. We chose to target components and services in order to make\u00a0\u2026", "num_citations": "5\n", "authors": ["95"]}
{"title": "Automatic translation of ocl meta-level constraints into java meta-programs\n", "abstract": " In order to make          explicit      and tangible      their design choices     , software developers      integrate, in their applications\u2019 models, constraints that their models and their implementations should satisfy. Various environments enable constraint checking during the modeling stage, but in most cases they do not generate code that would enable the checking of these constraints during the implementation stage. It turns out that this is possible in a number of cases. Environments that provide this functionality only offer it for functional constraints (related to the states of objects in applications) and not for architectural ones (related to the structure of applications). Considering this limitation, we describe in this paper a system that generates metaprograms starting from architecture constraints, written in OCL at the metamodel level, and associated to a specific UML model of an application. These metaprograms\u00a0\u2026", "num_citations": "5\n", "authors": ["95"]}
{"title": "Specification of an exception handling system for a replicated agent environment\n", "abstract": " Exception handling and replication are two mechanisms that increase software reliability. Exception handling helps programmers control situations in which the normal flow of a program execution cannot continue. Replication handles system failures. Exceptions handling and replication do not apply in the same way to the same situations and thus are two complementary mechanisms to increase software reliability. The paper proposes a specification of an execution history oriented exception handling system for an agent language and middleware providing replication. This paper proposes an original signaling algorithm adapted to replicated agents and a rationale of how exception handling and replication mechanisms can combine to increase programmers' capability to achieve reliable agent-based applications.", "num_citations": "5\n", "authors": ["95"]}
{"title": "Contractualisation de l'\u00e9volution architecturale de logiciels \u00e0 base de composants: une approche pour la pr\u00e9servation de la qualit\u00e9\n", "abstract": " De toutes les \u00e9tapes qui constituent le processus de maintenance, l'\u00e9tape de compr\u00e9hension d'une application avant son \u00e9volution, et l'\u00e9tape de v\u00e9rification de sa progression et de sa non r\u00e9gression apr\u00e9s \u00e9volution sont de loin les plus co\u00fbteuses. Dans cette these, je pr\u00e9sente une approche qui diminue les co\u00fbts associ\u00e9s a ces deux \u00e9tapes, pour des applications con\u00e7ues \u00e0 l'aide de composants. Dans cette approche, les liens unissant les attributs qualit\u00e9 d'une application et les d\u00e9cisions architecturales sont document\u00e9s formellement. La d\u00e9finition de ces liens se fait a chaque \u00e9tape du cycle de vie de l'application. J'ai d\u00e9velopp\u00e9 un environnement d'assistance \u00e0 l'\u00e9volution, qui exploite cette documentation, pour d'une part, garantir sa mise a jour et d'autre part, notifier au d\u00e9veloppeur les effets possibles sur les exigences qualit\u00e9 des changements architecturaux propos\u00e9s. Cette documentation forme ainsi un contrat dit d'\u00e9volution. Il s'agit d'un accord entre l'architecte de l'application et le responsable de son \u00e9volution. Le premier doit expliciter ses d\u00e9cisions de conception, sous la forme d'un ensemble de contraintes, afin qu'elles puissent \u00eatre respect\u00e9es lors du d\u00e9veloppement et de l'\u00e9volution. Le second doit respecter ce contrat afin de b\u00e9n\u00e9ficier d'une garantie de pr\u00e9servation de la qualit\u00e9 initialement requise. Ceci permet, principalement, de r\u00e9duire les co\u00fbts associ\u00e9s aux tests de non-r\u00e9gression sur l'aspect non-fonctionnel. Cette m\u00eame documentation est utilis\u00e9e pour tracer toutes les d\u00e9cisions architecturales tout au long du processus de d\u00e9veloppement d'un logiciel. Il est possible, ainsi, de v\u00e9rifier, \u00e0 une \u00e9tape donn\u00e9e du processus, la non\u00a0\u2026", "num_citations": "5\n", "authors": ["95"]}
{"title": "Spotlighting use case specific architectures\n", "abstract": " Most of the time a large software system implies a complex architecture. However, at some point of the system\u2019s execution, its components are not necessarily all running. Indeed, some components may not be concerned by a given use case, and therefore they do not consume/use or register the declared services. Thus, these architectural elements (components and their services) represent a \u201cnoise\u201d in the architecture model of the system. Their elimination from the architecture model may greatly reduce its complexity, and consequently helps developers in their maintenance tasks. In our work, we argue that a large service-oriented system has, not only one, but several architectures, which are specific to its runtime use cases. Indeed, each architecture reflects the services, and thereby the components, which are really useful for a given use case. In this paper, we present an approach for recovering such\u00a0\u2026", "num_citations": "4\n", "authors": ["95"]}
{"title": "Wringing out objects for programming and modeling component-based systems\n", "abstract": " Languages and technologies used to implement component-based software are not component-based, ie while the design phase happens in the component world, the programming phase occurs in the object-oriented world. When an object-oriented language is used for the programming stage, then the original component-based design vanish, because component concepts like requirements and architectures are not treated explicitly. This makes it difficult to keep model and its implementation causally connected. We present a new pure reflective component-based programming and modeling language where all core component concepts are treated explicitly and therefore keeping original component-design alive. The language makes it possible to model and program component-based software using the same language plus its uniform component-based meta-model and integrated reflection capabilities make\u00a0\u2026", "num_citations": "4\n", "authors": ["95"]}
{"title": "Reputation evaluation with malicious feedback prevention using a hits-based model\n", "abstract": " The reputation of web services is calculated by aggregating user feedback ratings. Though reputation is a subjective metric, it can be considered as a good indicator about service's Quality of Experience, and henceforth, it can be used for recommending services in an open ecosystem. In this work, we propose a three-phase process for evaluating web service reputation by aggregating user feedback ratings. The relationship between users and services is modeled as a bi-partite graph where an adapted HITS (Hypertext Induced Topic Search) algorithm is employed to distinguish between honest and malicious users in Phase I. Then, this model is used to evaluate, in Phase III, the reputation of web services from user ratings after punishing malicious users in Phase II. An experiment on a dataset of real Web services was conducted to validate the effectiveness of the proposed model in evaluating Web service reputation.", "num_citations": "3\n", "authors": ["95"]}
{"title": "An encoder-decoder architecture for the prediction of web service QoS\n", "abstract": " Quality of Service (QoS) prediction is an important task in Web service selection and recommendation. Existing approaches to QoS prediction are based on either Content Filtering or Collaborative Filtering. In the two cases, these approaches use external data or past interactions between users and services to predict missing or future QoS scores. One of the most effective techniques for QoS prediction is Matrix Factorization (MF), with Latent Factor Models. The key idea of MF consists in learning a compact model for both users and services. Thereafter QoS prediction is simply computed as a dot product between the user\u2019s latent model and the service\u2019s latent model. Despite the successful results of MF in the recommendation area, there are still a set of problems that should be handled, like: (i)\u00a0the sparsity of the input models, and (ii)\u00a0the learning of the latent factors which is prone to over-fitting. In this paper, we\u00a0\u2026", "num_citations": "3\n", "authors": ["95"]}
{"title": "Quality-driven design of web service business processes\n", "abstract": " Web service business processes are a kind of service compositions considered as one of the most frequent form of service-oriented software architectures. In this paper, we present a method that helps software architects in the design of such service architectures. This method assists the architects in answering them by proposing some patterns achieving quality requirements. We consider in our work that quality can be achieved through patterns, which are specified with checkable/process able languages. Besides this, the method that we propose simulates the application of these patterns and notifies the architect with its consequences on the other implemented qualities.", "num_citations": "3\n", "authors": ["95"]}
{"title": "Architecture constraints\n", "abstract": " This chapter introduces an additional concept for describing software architectures: architecture constraints. It explains the precise role of these entities and their importance in object\u2010oriented, component\u2010based or service\u2010oriented software engineering. The chapter then describes the way in which they are specified and interpreted. These constraints enable to enforce adherence to particular architecture pattern or style so as to ensure a certain level of maintainability. By interpreting these constraints, the author checks whether these patterns/styles are respected, after the evolution of architecture descriptions. The author presents a state of the art on the current architecture techniques and languages for expressing these constraints. The chapter then introduces author's recent research, where they author develops languages for expressing these constraints on architectures of object\u2010oriented, component\u2010based\u00a0\u2026", "num_citations": "3\n", "authors": ["95"]}
{"title": "Model-driven generation of context-specific feature models\n", "abstract": " Software Product Lines (SPL) aim at deriving software architectures or systems from a software artifact base. Configuring the SPL to derive a new product is now usually done by selecting appropriate software features in a kind of models, called feature models. In some situations, a feature represents a software artifact associated to an element e of a context the software product will manage. Such a feature and its associated software artifact may be cloned according to the number of occurrences of e in the context and constraints have to be respected. Hence, the feature model proposed to users for configuration has to be adapted in a new dedicated phase according to the context elements. We propose a model-driven engineering approach for transforming a generic feature model according to a context model that a derived software product will manage. More precisely this paper describes an original model transformation able to generate context specific feature models including duplicated features, and removing inappropriate features. Our transformation is validated on a smart building optimization software case study.", "num_citations": "3\n", "authors": ["95"]}
{"title": "Diagramme de Features, adaptation par transformation dans le contexte des b\u00e2timents intelligents\n", "abstract": " Software product lines in smart buildings involve large feature models in which the variability reflects the instrumentation and composition of the building. Moreover, some variation points must be duplicated on each occurrence of certain elements of the building (e.g., optimisation scenarios dedicated to each room of the building). We propose a model-driven approach to generate and configure feature models specific to a given building. In other ways, a diagram showing only appropriate features for a given building. This paper presents how an infrastructure model (describing a building), and a feature model are transformed to generate a infrastructure-specific feature diagrams.", "num_citations": "3\n", "authors": ["95"]}
{"title": "Software architecture constraints as customizable, reusable and composable entities\n", "abstract": " One of the major advantages of component-based software engineering is the ability for developers to reuse and assemble software entities to build complex software. Whereas decomposition of software into components has been and is largely addressed for what concerns the business (functional) part of applications, this is not yet the case for what concerns their documentation (non-functional) part. In this paper, we propose a new and original solution to express componentbased software non-functional documentation, and we will focus more especially on architecture constraints, which formalize parts of architecture decisions, as executable, customizable, reusable and composable building blocks represented by components. Component-based applications using business and constraint components can be modeled with CLACS, a dedicated ADL which is also introduced in the paper. Architecture\u00a0\u2026", "num_citations": "3\n", "authors": ["95"]}
{"title": "Une assistance pour l'\u00e9volution des logiciels \u00e0 base de composants\n", "abstract": " De toutes les \u00e9tapes qui constituent le processus de maintenance, l'\u00e9tape de compr\u00e9hension d'une application avant son \u00e9volution, et l'\u00e9tape de v\u00e9rification de sa progression et de sa non-r\u00e9gression apr\u00e8s \u00e9volution sont de loin les plus co\u00fbteuses. Nous pr\u00e9sentons une approche qui aide \u00e0 diminuer les co\u00fbts associ\u00e9s \u00e0 ces deux \u00e9tapes pour des applications con\u00e7ues \u00e0 l'aide de composants. Elle propose de documenter formellement, \u00e0 chaque \u00e9tape du de vie, les liens unissant les attributs qualit\u00e9 d'une application et les choix architecturaux qui leur sont d\u00e9di\u00e9s. Lors d'une \u00e9volution, un outil d'assistance exploite cette documentation pour, d'une part, garantir sa mise \u00e0 jour, et, d'autre part, notifier au d\u00e9veloppeur les effets possibles sur les exigences qualit\u00e9 des changements architecturaux qu'il r\u00e9alise.", "num_citations": "3\n", "authors": ["95"]}
{"title": "Building Hierarchical Component Directories\n", "abstract": " Component-based development is the software paradigm focused on building applications using reusable software components. Applications are built by assembling components, where the required interfaces of a component are connected to compatible provided interfaces of other components. In order to have an effective building process, software architects need adequate component directories that both index available components and ease their search. So far, existing approaches provide only a limited structure and indexation to store/register components and, as a consequence, they propose an inadequate searching process. Even when the indexes are built as flat or hierarchical structures, the indexed elements are not the components themselves, but part of them, such as services or functions, making the search of the needed compatible components imprecise. To cope with searching and compatibility problems, the contribution of this paper is twofold: it is composed of both a refined methodology (improving a previous approach) and a tool to build a hierarchically structured component directory. The component directory solves the identified problems letting an architect find components that are compatible with a given specification (to be assembled) or components that can substitute to a given one. This directory uses Formal Concept Analysis to build component type hierarchies thanks to a three step classification process that successively classifies functionality signatures, interfaces and, at last, component types. The refinement of the methodology is based on a substitutability relationship between components, where the notion of not\u00a0\u2026", "num_citations": "2\n", "authors": ["95"]}
{"title": "Bridging the Gap between Component-based Design and Implementation with a Reflective Programming Language\n", "abstract": " Component-based Software Engineering studies the design, development and maintenance of software constructed upon sets of connected components. Existing component-based models are frequently transformed into non-component-based programs, most of the time object-oriented, for runtime execution and then many component-related concepts, e.g. explicit architecture, vanish at the implementation stage. The main reason why is that with objects the component related concepts are treated implicitly and therefore the original intentions and qualities of the component-based design are hidden. This paper presents a reflective component-based programming and modeling language, which proposes the following original contributions: 1) Components are seen as objects in which requirements, architecture descriptions, connection points, etc. are explicit. This core idea aids in bridging the gap between component-based modeling and programming; 2) It revisits standard solutions for reification in the context of components when using the component-oriented reification to build up an executable meta-model designed on the idea of \"everything is a component\", allowing intercession on component descriptors and their instances; 3) It integrates reflection capabilities, making it possible to develop standard component-based application, but also to perform advanced architecture checking, code refactoring or model transformations using the same language.", "num_citations": "2\n", "authors": ["95"]}
{"title": "Combining exception handling and replication for improving the reliability of agent software\n", "abstract": " Exception handling and replication are two complementary mechanisms that increase software reliability. Exception handling helps programmers in controlling situations in which the normal execution flow of a program cannot continue. Replication handles system fail- ures through redundancy. Combining both techniques is a first step to- wards building a trustworthy software engineering framework. This paper presents some of the results from the Facoma project. It proposes the specification of an exception handling system for replicated agents as an adaptation of the Sage proposal. It then describes its implementation in the Dimax replicated agent environment.", "num_citations": "2\n", "authors": ["95"]}
{"title": "QoS-Driven Selection of Composable Web Services\n", "abstract": " Web Services are universally accessible software units that are advertised, discovered, and invoked over the internet. As web service technology is becoming widely adopted by organizations that need to integrate their information systems within and across organizational boundaries, it is important to identify automatically relevant composable services. In this paper, we propose an approach based on a variant of Formal Concept Analysis for the identification of composable services. It allows the classification of web services according to their QoS and composability levels and proposes a query mechanism that allows users to specify their required QoS and composability levels.In the case of multiple choices that satisfy users' requirements, we enhance our approach with a mechanism based on vectors for identifying the optimized choice. We validate our approach on a set of real-world web services obtained from Service-Finder.", "num_citations": "2\n", "authors": ["95"]}
{"title": "Component deployment evolution driven by architecture patterns and resource requirements\n", "abstract": " Software architectures are often designed with respect to some architecture patterns, like the pipeline and peer-to-peer. These patterns are the guarantee of some quality attributes, like maintainability or performance. These patterns should be dynamically enforced in the running system to benefit from their associated quality characteristics at runtime. In dynamic hosting platforms where machines can enter the network, offering new resources, or fail, making the components they host unavailable, these patterns can be affected. In addition, in this kind of infrastructures, some resource requirements can also be altered. In this paper we present an approach which aims at dynamically assist deployment process with information about architectural patterns and resource constraints. This ensures that, faced with disconnections or machine failures, the runtime system complies permanently with the original\u00a0\u2026", "num_citations": "2\n", "authors": ["95"]}
{"title": "Un m\u00e9ta-modele pour la description de contraintes architecturales sur l\u2019\u00e9volution des composants\n", "abstract": " Pour pr\u00e9server certaines propri\u00e9t\u00e9s non-fonctionnelles d\u2019applications \u00e0 base de composants lors de leur \u00e9volution, une approche par contrats peut \u00eatre envisag\u00e9e. Ces contrats, dits d\u2019\u00e9volution, comportent un certain nombre de contraintes architecturales. Pour la description de ces contraintes, nous utilisons OCL et un m\u00e9ta-mod\u00e8le de composants. Afin de d\u00e9finir le contrat d\u2019\u00e9volution tout au long du cycle de vie d\u2019une application, le m\u00e9ta-mod\u00e8le doit abstraire aussi bien les mod\u00e8les architecturaux d\u2019analyse/conception introduits par les ADL, que les mod\u00e8les d\u2019impl\u00e9mentation propos\u00e9s par les technologies de composants. Dans ce papier, nous pr\u00e9sentons ce m\u00e9ta-mod\u00e8le g\u00e9n\u00e9rique pour la description de contrats d\u2019\u00e9volution.ABSTRACT. In order to preserve certain non-functional properties during the evolution of componentbased applications, a contractual approach can be envisaged. These evolution contracts consist of a set of architectural constraints. To describe the architectural constraints, we use OCL (Object Constraint Language) and a component meta-model. In order to define the evolution contract during all the application lifecycle, the meta-model should be able to abstract, the architectural models introduced by ADLs in the Analysis/Design stage, as well as implementation models proposed by component technologies. In this paper, we present this generic meta-model for describing evolution contracts.", "num_citations": "2\n", "authors": ["95"]}
{"title": "A deep learning approach for collaborative prediction of Web service QoS\n", "abstract": " Web services are a cornerstone of many crucial domains, including cloud computing and the Internet of Things. In this context, QoS prediction for Web services is a highly important and challenging issue that facilitates the building of value-added processes such as compositions and workflows of services. Current QoS prediction approaches, like collaborative filtering methods, mainly suffer from obstacles related to data sparsity and the cold-start problem. Moreover, previous studies have not conducted in-depth explorations of the impact of the geographical characteristics of services/users and QoS ratings on the prediction problem. To address these difficulties, we propose a deep-learning-based approach for QoS prediction. The main idea consists of combining a matrix factorization model based on a deep autoencoder (DAE) with a clustering technique based on geographical characteristics to improve the\u00a0\u2026", "num_citations": "1\n", "authors": ["95"]}
{"title": "On investigating metamodel inaccurate structures\n", "abstract": " Metamodeling allows capturing domain knowledge through the definition of its structure (concepts and relations between them) and its constraints (logical expressions) often written in OCL. The OCL constraints added to a metamodel are of two types: 1) domain-related constraints: they differ from one domain to another and are expressed based on the experts' knowledge; 2) those that are added to the majority of metamodels to precise some inaccurate structures that may cause problems when instantiating models. We call these structures Metamodel Inaccurate Structures (MIS). In this paper, we performed an empirical study in order to point out the metamodel inaccurate structures. As a first step, a study is conducted on a set of OCL constraints taken from the UML metamodel to investigate the relation between structure and constraints. Then, to confirm our findings, we realized a quantitative analysis to count the\u00a0\u2026", "num_citations": "1\n", "authors": ["95"]}
{"title": "Inferring Architectural Evolution from Source Code Analysis\n", "abstract": " Several approaches have been proposed to study and provide information about the evolution of a software system, but very few proposals analyze and interpret this information at the architectural level. In this paper, we propose an approach that supports the understanding of software evolution at the architectural level. Our approach relies on the idea that an architectural tactic can be mapped to a number of operational representations, each of which is a transformation described using a set of elementary actions on source code entities (e.g., adding a package, moving a class from a package to another, etc.). These operational representations make it possible to: (1) detect architectural tactics\u2019 application (or cancellation) by analyzing different versions of the source code of analyzed systems, and (2) understand the architectural evolution of these systems. To evaluate the proposed approach, we carried\u00a0\u2026", "num_citations": "1\n", "authors": ["95"]}
{"title": "Automatic translation of architecture constraint specifications into components\n", "abstract": " Architecture constraints are specifications defined by developers at design-time and checked on design artifacts (architecture descriptions, like UML models). They enable to check, after an evolution, whether an architecture description still conforms to the conditions imposed by an architecture pattern, style or any design principle. One possible language for specifying such constraints is the OMG\u2019s OCL. Most of these architecture constraints are formalized as \"gross\" specifications, without any structure or parameterization possibilities. This causes difficulties in their reuse. We propose in this work a process for translating architecture constraints into a special kind of components called constraint-components. This makes these specifications reusable (easily put and checked out in/from repositories), parametrizable (generic and applicable in different contexts) and composable with others. We implemented\u00a0\u2026", "num_citations": "1\n", "authors": ["95"]}
{"title": "G\u00e9n\u00e9ration de m\u00e9ta-programmes Java \u00e0 partir des contraintes architecturales OCL\n", "abstract": " Afin de formaliser leurs choix de conception, les concepteurs des logiciels sp\u00e9cifient des contraintes sur les mod\u00e8les de leurs applications. Il s'av\u00e8re important de sp\u00e9cifier ces contraintes non seulement dans la phase de conception mais aussi dans la phase d'impl\u00e9mentation en les rendant v\u00e9rifiables sur le code. La sp\u00e9cification de ces contraintes peut se faire manuellement mais celles-ci peuvent \u00eatre obtenues automatiquement avec la g\u00e9n\u00e9ration de code de leurs mod\u00e8les. Plusieurs travaux et outils existent permettant la g\u00e9n\u00e9ration automatique des diff\u00e9rents mod\u00e8les en code source. Cependant, la plupart de ces outils ne consid\u00e8rent pas la g\u00e9n\u00e9ration des contraintes textuelles associ\u00e9es \u00e0 ces mod\u00e8les en code. Pour ceux qui le font, la transformation est appliqu\u00e9e sur des contraintes fonctionnelles mais non architecturales. Dans ce contexte, nous avons d\u00e9velopp\u00e9 une m\u00e9thode qui permet d'\u00e9crire des contraintes d\u2019architecture d\u2019un mod\u00e8le donn\u00e9 en se basant sur son m\u00e9ta-mod\u00e8le et ensuite g\u00e9n\u00e9rer du code \u00e0 partir de ces contraintes sous la forme d\u2019un m\u00e9ta-programme.", "num_citations": "1\n", "authors": ["95"]}
{"title": "Catalogue of architectural patterns characterized by constraint components, Version 1.0\n", "abstract": " This report documents a catalogue of architectural patterns built from constraint components. Constraint component is a concept used to represent architectural constraints by components. It facilitates the reusability, the composability and the customizability of architectural constraints. This report revises a list of existing architectural patterns in the literature and represents them using constraint components.", "num_citations": "1\n", "authors": ["95"]}
{"title": "Many-Valued Concept Lattices for Backing Composite Web Services\n", "abstract": " A Web service is a software functionality accessible through the network.Web services are intended to be composed to realize domain-specific applications. Achieving a required functionality by a service composition necessitates the discovery of a collection of Web services out of the enormous service space. Each service from this service space must be examined to verify its functionality, which makes the discovery task neither efficient nor practical. Moreover, when a service in a composition becomes unavailable or functionally broken, the whole composition may become broken too. Therefore, a functionally equivalent service must be discovered, in order to replace the broken service, thus spending more time and effort. In this paper, we propose an approach that facilitates the discovery of a web service and the identification of its candidate substitutes. We use many-valued concept lattices to classify web services, depending on the similarity estimated between their operations. This classification enables the identification of a needed web service as well as its possible alternatives. Thus, a Web service composition can be achieved more easily and can be supported with backup services, to recover the functionality of a broken service.", "num_citations": "1\n", "authors": ["95"]}
{"title": "Components and Service Farms\n", "abstract": " Software components and web services are software building blocks that are used in the composition of mod- ern software applications. They both provide functionalities that require to be advertised by registries in order to be discovered and reused during software building processes. Building or evolving existing software implies assembling software components. This task is not trivial because it requires to select the adequate component or service that provides some part of the desired application functionality and connects easily (with minimum adapta- tions) to other selected components. Within this context, we identified two main issues: (1) finding appropriate components from huge databases, and (2) creating and maintaining distributed applications.", "num_citations": "1\n", "authors": ["95"]}
{"title": "AlkoWeb: Un outil pour mod\u00e9liser l'architecture des applications Web riches\n", "abstract": " La couche pr\u00e9sentation des architectures n-tiers a besoin d'\u00eatre con\u00e7ue avec des modules correctement structur\u00e9s et r\u00e9utilisables. Dans ce article, nous pr\u00e9sentons un mod\u00e8le de composants hi\u00e9rarchiques qui permet aux d\u00e9veloppeurs de mod\u00e9liser, de g\u00e9n\u00e9rer du code et de r\u00e9utiliser ce niveau logiciel des applications Web riches. Dans ce mod\u00e8le, les composants peuvent \u00eatre inter-connect\u00e9s via leurs interfaces pour construire des composants plus complexes. Ces mod\u00e8les peuvent \u00eatre r\u00e9utilis\u00e9s avec leur code gr\u00e2ce \u00e0 un m\u00e9canisme d'association. Comme nous le montrons dans cet article, ceci est une propri\u00e9t\u00e9 int\u00e9ressante pour assister les d\u00e9veloppeurs pour naviguer dans le code source et les mod\u00e8les de leurs applications. Ceci permet par ailleurs de maintenir une coh\u00e9rence entre les artefacts de ces deux \u00e9tapes du processus de d\u00e9veloppement (conception et impl\u00e9mentation).", "num_citations": "1\n", "authors": ["95"]}
{"title": "Exception handling in a replicated agent environment\n", "abstract": " This document is the semestrial report of the Lirmm partner for the Facoma project. It concludes semester 2 - out of 6 - for the project. During this semester, partners from Lirmm and Lgi2p have worked on: i) defining an exception handling system for agents. This work is based on previous work that has been done by these partners on the Sage exception handling system that was adapted to the context of the Facoma pro ject; ii) refining their knowledge and understanding of the Dimax replicated agent environment provided by the Lip6 partner; iii) setting the first elements of a specification of an exception handling system dedicated to agents that evolve in a replication-based environment. Indeed, exception handling and replication are two mechanisms that increase the reliability of an application. Exceptions are situations in which the normal flow of a program cannot continue. Replication prevents an application from suffering from system failures. Exceptions and system failures do not apply to the same situations and therefore are complementary to each other. One of the objective of the Facoma project is to study how an exception handling system and a replication mechanism can combine to increase the reliability of agent-based applications.", "num_citations": "1\n", "authors": ["95"]}