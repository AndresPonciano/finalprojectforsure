{"title": "A term rewriting approach to the automated termination analysis of imperative programs\n", "abstract": " An approach based on term rewriting techniques for the automated termination analysis of imperative programs operating on integers is presented. An imperative program is transformed into rewrite rules with constraints from quantifier-free Presburger arithmetic. Any computation in the imperative program corresponds to a rewrite sequence, and termination of the rewrite system thus implies termination of the imperative program. Termination of the rewrite system is analyzed using a decision procedure for Presburger arithmetic that identifies possible chains of rewrite rules, and automatically generated polynomial interpretations are used to show finiteness of such chains. An implementation of the approach has been evaluated on a large collection of imperative programs, thus demonstrating its effectiveness and practicality.", "num_citations": "36\n", "authors": ["703"]}
{"title": "Rewriting Induction+ Linear Arithmetic= Decision Procedure\n", "abstract": " This paper presents new results on the decidability of inductive validity of conjectures. For these results, a class of term rewrite systems (TRSs) with built-in linear integer arithmetic is introduced and it is shown how these TRSs can be used in the context of inductive theorem proving. The proof method developed for inductive theorem proving couples (implicit) inductive reasoning with a decision procedure for the theory of linear integer arithmetic with (free) constructors. The effectiveness of the new decidability results on a large class of conjectures is demonstrated by an evaluation of the prototype implementation Sail2.", "num_citations": "32\n", "authors": ["703"]}
{"title": "Dependency pairs for rewriting with built-in numbers and semantic data structures\n", "abstract": " This paper defines an expressive class of constrained equational rewrite systems that supports the use of semantic data structures (e.g., sets or multisets) and contains built-in numbers, thus extending our previous work presented at CADE 2007 [6]. These rewrite systems, which are based on normalized rewriting on constructor terms, allow the specification of algorithms in a natural and elegant way. Built-in numbers are helpful for this since numbers are a primitive data type in every programming language. We develop a dependency pair framework for these rewrite systems, resulting in a flexible and powerful method for showing termination that can be automated effectively. Various powerful techniques are developed within this framework, including a subterm criterion and reduction pairs that need to consider only subsets of the rules and equations. It is well-known from the dependency pair framework for\u00a0\u2026", "num_citations": "28\n", "authors": ["703"]}
{"title": "Inductive decidability using implicit induction\n", "abstract": " Decision procedures are widely used in automated reasoning tools in order to reason about data structures. In applications, many conjectures fall outside the theory handled by a decision procedure. Often, reasoning about user-defined functions on those data structures is needed. For this, inductive reasoning has to be employed. In this work, classes of function definitions and conjectures are identified for which inductive validity can be automatically decided using implicit induction methods and decision procedures for an underlying theory. The class of equational conjectures considered in this paper significantly extends the results of Kapur & Subramaniam (CADE, 2000) [15], which were obtained using explicit induction schemes. Firstly, nonlinear conjectures can be decided automatically. Secondly, function definitions can use other defined functions in their definitions, thus allowing mutually recursive\u00a0\u2026", "num_citations": "20\n", "authors": ["703"]}
{"title": "A Theory of Arrays with set and copy Operations\n", "abstract": " The theory of arrays is widely used in order to model main memory in program analysis, software verification, bounded model checking, symbolic execution, etc. Nonetheless, the basic theory as introduced by McCarthy is not expressive enough for important practical cases, since it only supports array updates at single locations. In programs, memory is often modified using functions such as memset or memcpy/memmove, which modify a userspecified range of locations whose size might not be known statically. In this paper we present an extension of the theory of arrays with set and copy operations which make it possible to reason about such functions. We also discuss further applications of the theory.", "num_citations": "10\n", "authors": ["703"]}
{"title": "Operational termination of conditional rewriting with built-in numbers and semantic data structures\n", "abstract": " While ordinary conditional rewrite systems are more elegant than unconditional ones, they still have limited expressive power since semantic data structures, such as sets or multisets, cannot be modeled elegantly. Extending our work presented at RTA 2008 [Falke, S. and D. Kapur, Dependency pairs for rewriting with built-in numbers and semantic data structures, in: A. Voronkov, editor, Proceedings of the 19th Conference on Rewriting Techniques and Applications (RTA '08), Lecture Notes in Computer Science 5117 (2008), pp. 94\u2013109], the present paper defines a class of conditional rewrite systems that allows the use of semantic data structures and supports built-in natural numbers, including constraints taken from Presburger arithmetic. The framework is both expressive and natural. Rewriting is performed using a combination of normalized equational rewriting with recursive evaluation of conditions and validity\u00a0\u2026", "num_citations": "10\n", "authors": ["703"]}
{"title": "Term rewriting with built-in numbers and collection data structures\n", "abstract": " Term rewrite systems have been extensively used in order to model computer programs for the purpose of formal verification. This is in particular true if the termination behavior of computer programs is investigated, and automatic termination proving for term rewrite systems has received increased interest in recent years. Ordinary term rewrite systems, however, exhibit serious drawbacks. First, they do not provide a tight integration of natural numbers or integers. Since the pre-defined semantics of these primitive data types cannot be utilized, reasoning about termination of ordinary term rewrite systems operating on numbers is often cumbersome or even impossible. Second, ordinary term rewrite system cannot accurately model collection data structures such as sets or multisets which are supported by many high-level programming languages such as Maude or OCaml. This dissertation introduces a new class of term rewrite systems that addresses both of these drawbacks and thus makes it possible to accurately model computer programs using a high level of abstraction in a natural formalism. Then, the problem of automatically proving termination for this new class of term rewrite systems is investigated. The resulting dependency pair framework provides a flexible and modular method for proving termination. In addition to unrestricted rewriting, termination of rewriting with the innermost strategy or a context-sensitive rewriting strategy is investigated as well. The techniques for proving termination that are developed in this dissertation have been implemented in the well-known termination prover AProVE. An empirical evaluation shows that the\u00a0\u2026", "num_citations": "10\n", "authors": ["703"]}
{"title": "Automated termination analysis for equational rewriting\n", "abstract": " Equational term rewriting plays a prominent role in many areas of computer science, including specification, verification, and automated reasoning. In these applications, termination is an important property that is generally assumed to be given. This thesis investigates methods that can be used to analyze the termination behavior of equational term rewriting in a fully automated way.After presenting methods based on reduction orders, we introduce the powerful dependency pair method that is well suited for automation. The main part of this work presents new improvements of the dependency pair method that significantly increase its efficiency and power in practice. The results have been implemented in the termination prover AProVE for the two classes of equational theories most commonly found in practice, namely associative-commutative (AC) theories and theories of non-free constructors. There are other systems for automated analysis of AC-termination available, but empirical results indicate that the contributions of this thesis improve upon the previously known techniques in practice. For theories of non-free constructors, AProVE is, to the best of our knowledge, the only system that provides powerful methods for fully automated termination proofs.", "num_citations": "7\n", "authors": ["703"]}
{"title": "When is a formula a loop invariant?\n", "abstract": " Invariant properties at various program locations play a critical role in enhancing confidence in the reliability of software. A procedure for checking whether a given set of formulas associated with various program locations is an invariant or not is proposed. The procedure attempts to check whether the formulas are preserved by various program paths, in which case it declares the formulas to be invariant; otherwise, it attempts to strengthen them based on verification conditions generated from the program paths that did not preserve the formulas. This iterative process is continued until a verification condition along some path cannot be satisfied or an initial state of the program violates the formulas strengthened thus far. It is shown that under certain conditions, for certain theories including conjunctions of polynomial equalities, the procedure terminates, either declaring the input set of formulas to be not\u00a0\u2026", "num_citations": "6\n", "authors": ["703"]}
{"title": "Dependency pairs for rewriting with non-free constructors\n", "abstract": " A method based on dependency pairs for showing termination of functional programs on data structures generated by constructors with relations is proposed. A functional program is specified as an equational rewrite system, where the rewrite system specifies the program and the equations express the relations on the constructors that generate the data structures. Unlike previous approaches, relations on constructors can be collapsing, including idempotency and identity relations. Relations among constructors may be partitioned into two parts: (i) equations that cannot be oriented into terminating rewrite rules, and (ii) equations that can be oriented into terminating rewrite rules, in which case an equivalent convergent system for them is generated. The dependency pair method is extended to normalized rewriting, where constructor-terms in the redex are normalized first. The method has been applied to\u00a0\u2026", "num_citations": "6\n", "authors": ["703"]}
{"title": "Termination of context-sensitive rewriting with built-in numbers and collection data structures\n", "abstract": " Context-sensitive rewriting is a restriction of rewriting that can be used to elegantly model declarative specification and programming languages such as Maude. Furthermore, it can be used to model lazy evaluation in functional languages such as Haskell. Building upon previous work on constrained equational rewrite systems (CERSs), an expressive and elegant class of rewrite systems that contains built-in numbers and supports the use of collection data structures such as sets or multisets, context-sensitive rewriting with CERSs is investigated in this paper. This integration results in a natural way for specifying algorithms in the rewriting framework. In order to automatically prove termination of this kind of rewriting, a dependency pair framework for context-sensitive rewriting with CERSs is developed, resulting in a flexible termination method that can be automated effectively. Several powerful termination\u00a0\u2026", "num_citations": "5\n", "authors": ["703"]}
{"title": "Predicting Failures of Inductive Proof Attempts\n", "abstract": " Reasoning about recursively defined data structures and functions defined on them typically requires proofs by induction. Despite advances made in automating inductive reasoning, proof attempts by theorem provers frequently fail while performing inductive reasoning. A user of such a system must scrutinize a failed proof attempt and do intensive debugging to understand the cause of failure. The failure of proof attempts could be because of a number of reasons even when a conjecture is believed to be valid. One reason is that an induction scheme used in a proof attempt is not powerful enough to yield useful induction hypotheses which can be applied effectively. Or the proof attempt might need intermediate lemmas. The focus of the research reported in this paper is to analyze possible failures of proof attempts due to inapplicability of induction hypotheses and predict failure a priori before even attempting a proof, so as to avoid failed attempts. Definitions of functions appearing in a conjecture are analyzed to determine whether their interaction in the conjecture guarantees a proof attempt to get stuck. The analysis relies on the concept of blocking of a function definition by another function definition. If, in a conjecture, a function g appears as an argument to another function f such that when the definition of g is expanded, f blocks a function symbol resulting from the definition of g, then a proof attempt of the conjecture based on expanding the definition of g is likely to get stuck. The concept of a flawed induction scheme is introduced capturing this idea. It is shown that if a proof of a conjecture is attempted using only flawed induction schemes, then\u00a0\u2026", "num_citations": "2\n", "authors": ["703"]}
{"title": "Predicting failures of and repairing inductive proof attempts\n", "abstract": " Inductive reasoning is critical for ensuring reliability of computational descriptions, especially of algorithms defined on recursive data structures. Despite advances made in automating inductive reasoning, proof attempts by theorem provers frequently fail while performing inductive reasoning. A user of such a system must scrutinize a failed proof attempt and do intensive debugging to understand the cause of failure, and then provide additional information to make a failed proof attempt succeed. A method for predicting a priori failure of proof attempts by induction is proposed. It is based on analyzing the definitions of function symbols appearing in a conjecture. Further, failure analysis is shown to provide information that can be used to make those proof attempts succeed for valid conjectures. The failure of proof attempts could be because of a number of reasons even when a conjecture is believed to be valid. It might\u00a0\u2026", "num_citations": "1\n", "authors": ["703"]}