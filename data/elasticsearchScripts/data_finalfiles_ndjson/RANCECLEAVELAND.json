{"title": "Tableau-based model checking in the propositional mu-calculus\n", "abstract": " This paper describes a procedure, based around the construction of tableau proofs, for determining whether finite-state systems enjoy properties formulated in the propositional mu-calculus. It presents a tableau-based proof system for the logic and proves it sound and complete, and it discusses techniques for the efficient construction of proofs that states enjoy properties expressed in the logic. The approach is the basis of an ongoing implementation of a model checker in the Concurrency Workbench, an automated tool for the analysis of concurrent systems.", "num_citations": "338\n", "authors": ["315"]}
{"title": "The NCSU concurrency workbench\n", "abstract": " The NCSU Concurrency Workbench is a tool for verifying finite-state systems. A key feature is its flexibility; its modular design eases the task of adding new analyses and changing the language users employ for describing systems. This note gives an overview of the system's features, including its capacity for generating diagnostic information for incorrect systems, and discusses some of its applications.", "num_citations": "286\n", "authors": ["315"]}
{"title": "Priorities in process algebras\n", "abstract": " An operational semantics for an algebraic theory of concurrency that incorporates a notion of priority into the definition of the execution of actions is developed. An equivalence based on strong observational equivalence is defined and shown to be a congruence, and a complete axiomatization is given for finite terms. Several examples higlight the novelty and usefulness of our approach.", "num_citations": "201\n", "authors": ["315"]}
{"title": "Testing equivalence as a bisimulation equivalence\n", "abstract": " In this paper we show how the testing equivalences and preorders on transition systems may be interpreted as instances of generalized bisimulation equivalences and prebisimulation preorders. The characterization relies on defining transformations on the transition systems in such a way that the testing relations on the original systems correspond to (pre)bisimulation relations on the altered systems. On the basis of these results, it is possible to use algorithms for determining the (pre)bisimulation relations in the case of finite-state transition systems to compute the testing relations.", "num_citations": "173\n", "authors": ["315"]}
{"title": "Divergence and fair testing\n", "abstract": " This paper develops a new testing-based semantic theory of processes that aims to circumvent difficulties that traditional testing/failures theories have in dealing with divergent behavior. Our framework incorporates a notion of fairness into the determination of when a process passes a test; we contrast this definition with existing approaches and give characterizations of the induced semantic preorders. An example highlights the utility of our results.", "num_citations": "112\n", "authors": ["315"]}
{"title": "Architecture design of a scalable intrusion detection system for the emerging network infrastructure\n", "abstract": " This document describes the design of a scalable intrusion detection system funded by DARPA through Contract No. F30602-96-C0325. This three-year project aims at designing and developing a software system for protecting against intruders from breaking into network routers, switches, and network management channels. The project is a joint collaboration between MCNC and North Carolina State University (NCSU). Given the increasing popularity of the Internet, intrusion incidents are becoming common events of life. Some of these incidents are simply out of innocuous curiosity. Some, however, are due to malicious attempts in order to compromise the availability of information system or the integrity and privacy of the information itself. Despite the best e orts of the protocol designers, implementors, and system administrators, it is prudent to assume that attacks will occur and some, unfortunately, will succeed. Therefore, it is vitally important to develop means to automatically detect and respond to these attacks in order to maintain critical information services.Depending on the goals of the intruder, the targets of attack may range from individual end hosts to a network of routers and switches. In this project, we focus our e ort on the protection of the network infrastructure since the attacks on the routers/switches have the potential of disrupting a large scale of information services on which the national defense and economy may depend. Our goal of designing this detection system is to provide a comprehensive approach which leverages on the application of novel detection techniques together with extension of some existing host-based intrusion\u00a0\u2026", "num_citations": "101\n", "authors": ["315"]}
{"title": "Dissociable neural systems supporting knowledge about human character and appearance in ourselves and others\n", "abstract": " Functional neuroimaging has identified a neural system comprising posterior cingulate (pCC) and medial prefrontal (mPFC) cortices that appears to mediate self-referential thought. It is unclear whether the two components of this system mediate similar or different psychological processes, and how specific this system is for self relative to others. In an fMRI study, we compared brain responses for evaluation of character (e.g., honest) versus appearance (e.g., svelte) for oneself, one's mother (a close other), and President Bush (a distant other). There was a double dissociation between dorsal mPFC, which was more engaged for character than appearance judgments, and pCC, which was more engaged for appearance than character judgments. A ventral region of mPFC was engaged for judgments involving one's own character and appearance, and one's mother's character, but not her appearance. A follow\u00a0\u2026", "num_citations": "93\n", "authors": ["315"]}
{"title": "Priority in process algebra\n", "abstract": " This chapter surveys the semantic ramifications of extending traditional process algebras with notions of priority that allow some transitions to be given precedence over others. The need for these enriched formalisms arises when one wishes to model system features such as interrupts, prioritized choice, or real-time behavior.Approaches to priority in process algebras can be classified according to whether the induced notion of pre-emption on transitions is global or local and whether priorities are static or dynamic. Early work in the area concentrated on global pre-emption and static priorities and led to formalisms for modeling interrupts and aspects of real-time, such as maximal progress, in centralized computing environments. More recent research has investigated localized notions of pre-emption in which the distribution of systems is taken into account, as well as dynamic priority approaches. The latter allows\u00a0\u2026", "num_citations": "93\n", "authors": ["315"]}
{"title": "A compositional approach to statecharts semantics\n", "abstract": " Statecharts is a visual language for specifying reactive system behavior. The formalism extends traditional finite-state machines with notions of hierarchy and concurrency, and it is used in many popular software design notations. A large part of the appeal of Statecharts derives from its basis in state machines, with their intuitive operational interpretation. The classical semantics of Statecharts, however, suffers from a serious defect; it is not compositional, meaning that the behavior of system descriptions cannot be inferred from the behavior of their subsystems. Compositionality is a prerequisite for exploiting the modular structure of Statecharts for simulation, verification, and code generation, and it also provides the necessary foundation for reusability. This paper suggests a new compositional approach to formalizing Statecharts semantics as flattened labeled transition systems in which transitions represent system\u00a0\u2026", "num_citations": "93\n", "authors": ["315"]}
{"title": "Efficient model checking via the equational/spl mu/-calculus\n", "abstract": " This paper studies the use of an equational variant of the modal /spl mu/-calculus as a unified framework for efficient temporal logic model checking. In particular we show how an expressive temporal logic, CTL*, may be efficiently translated into the /spl mu/-calculus. Using this translation, one may then employ /spl mu/-calculus model-checking techniques, including on-the-fly procedures, BDD-based algorithms and compositional model-checking approaches, to determine if systems satisfy formulas in CTL*.", "num_citations": "91\n", "authors": ["315"]}
{"title": "Optimality in abstractions of model checking\n", "abstract": " This paper investigates the use of abstract-interpretationinspired techniques for improving the performance of procedures for determining when systems satisfy formulas in branching-time temporal logic. A framework for abstracting system descriptions is developed, and a particular method for generating abstract systems from given abstractions on system states is defined and shown to be both safe and optimal, in the sense that concrete systems satisfy all the temporal formulas enjoyed by their abstracted counterparts. One may then use a model checker on an abstracted (and hence smaller) system in order to infer properties of a concrete system.", "num_citations": "85\n", "authors": ["315"]}
{"title": "A theory of testing for real-time\n", "abstract": " This paper develops a framework for generating testing preorders that relate processes on the basis of their timing behavior as well as their degree of relative nondeterminism. The framework is then applied to two different scenarios. In the rst, relations are constructed that relate processes on the basis of all timing considerations. In the second, relations are constructed that relate processes on the basis of their relative speeds. In both cases, alternative denotational characterizations of the resulting preorders are presented, and examples are given to illustrate the utility of the approach.", "num_citations": "83\n", "authors": ["315"]}
{"title": "Efficient local model-checking for fragments of the modal \u03bc-calculus\n", "abstract": " This paper develops efficient local model-checking algorithms for expressive fragments of the modal \u039c-calculus. The time complexity of our procedures matches that of the best existing global algorithms; however, in contrast to those routines, ours explore a system's state space in a need-driven fashion and do not require its a priori construction. Consequently, our algorithms should perform better in practice. Our approach relies on a novel reformulation of the model-checking problem for the modal mucalculus in terms of checking whether certain linear-time temporal formulas are satisfied by generalized Kripke structures that we call and-or Kripke structures.", "num_citations": "78\n", "authors": ["315"]}
{"title": "Evidence-based model checking\n", "abstract": " This paper shows that different \u201cmeta-model-checking\u201d analyses can be conducted efficiently on a generic data structure we call a support set. Support sets may be viewed as abstract encodings of the \u201cevidence\u201d a model checker uses to justify the yes/no answers it computes. We indicate how model checkers may be modified to compute supports sets without compromising their time or space complexity. We also show how support sets may be used for a variety of different analyses of model-checking results, including: the generation of diagnostic information for explaining negative model-checking results; and certifying the results of model checking (is the evidence internally consistent?).", "num_citations": "77\n", "authors": ["315"]}
{"title": "Testing equivalence as a bisimulation equivalence\n", "abstract": " In this paper we show how the testing equivalences and preorders on transition systems may be interpreted as instances of generalized bisimulation equivalences and prebisimulation preorders. The characterization relies on defining transformations on the transition systems in such a way that the testing relations on the original systems correspond to (pre)bisimulation relations on the altered systems. Using these results, it is possible to use algorithms for determining the (pre)bisimulation relations in the case of finite-state transition systems to compute the testing relations.", "num_citations": "75\n", "authors": ["315"]}
{"title": "TwoTowers: A tool integrating functional and performance analysis of concurrent systems\n", "abstract": " We present TwoTowers, a tool for analyzing functional and performance properties of concurrent systems expressed as terms in the stochastically timed reward process algebra EMPAr. TwoTowers builds on two existing tools, CWB-NC and MarCA, that have been retargeted to carry out functional and performance analysis (respectively) of EMPAr, system specifications. As an example, we describe the application of TwoTowers to the Lehmann-Rabin randomized distributed algorithm for the dining philosopher problem.", "num_citations": "73\n", "authors": ["315"]}
{"title": "RTSL: a language for real-time schedulability analysis\n", "abstract": " The paper develops a generalized approach to schedulability analysis that is mathematically founded in a process algebra called RTSL. Within RTSL one may describe the functional behavior, timing behavior, timing constraints (or deadlines), and scheduling discipline for real-time systems. The formal semantics of RTSL then allows the reachable state space of finite state systems to be automatically generated and searched for timing exceptions. We provide a generalized schedulability analysis technique to perform this state-based analysis.< >", "num_citations": "69\n", "authors": ["315"]}
{"title": "Triggered message sequence charts\n", "abstract": " We propose an extension to Message Sequence Charts called Triggered Message Sequence Charts (TMSCs) that are intended to capture system specifications involving nondeterminism in the form of conditional scenarios. The visual syntax of TMSCs closely resembles that of MSCs; the semantics allows us to translate a TMSC specification into a framework that supports a notion of refinement based on Denicola's and Hennessy's must preorder. A simple but non-trivial example illustrates the utility of our extension to MSCs.", "num_citations": "64\n", "authors": ["315"]}
{"title": "System and method for automatic test-case generation for software\n", "abstract": " A method for generating test cases for software and a test case generator comprising a simulator that drives software under test from one input state to the next. The simulator is constrained by predetermined criteria to visit states that meet the criteria thus preserving computer resources. The states reached by the simulator are tested.", "num_citations": "60\n", "authors": ["315"]}
{"title": "A front-end generator for verification tools\n", "abstract": " This paper describes the Process Algebra Compiler (PAC), a front-end generator for process-algebra-based verification tools. Given descriptions of a process algebra's concrete and abstract syntax and semantics as structural operational rules, the PAC produces syntactic routines and functions for computing the semantics of programs in the algebra. Using this tool greatly simplifies the task of adapting verification tools to the analysis of systems described in different languages; it may therefore be used to achieve source-level compatibility between different verification tools. Although the initial verification tools targeted by the PAC are MAUTO and the Concurrency Workbench, the structure of the PAC caters for the support of other tools as well.", "num_citations": "60\n", "authors": ["315"]}
{"title": "Testing-based abstractions for value-passing systems\n", "abstract": " This paper presents a framework for the abstract interpretation of processes that pass values. We define a process description language that is parameterized with respect to the set of values that processes may exchange and show that an abstraction over values induces an abstract semantics for processes. Our main results state that if the abstract value interpretation safely/optimally approximates the ground interpretation, then the resulting abstracted processes safely/optimally approximate those derived from the ground semantics (in a precisely defined sense). As the processes derived from an abstract semantics in general have far fewer states than those derived from a concrete semantics, our technique enables the automatic analysis of systems that lie beyond the scope of existing techniques.", "num_citations": "58\n", "authors": ["315"]}
{"title": "Statecharts via process algebra\n", "abstract": " Statecharts is a visual language for specifying the behavior of reactive systems. The language extends finite-state machines with concepts of hierarchy, concurrency, and priority. Despite its popularity as a design notation for embedded systems, precisely defining its semantics has proved extremely challenging. In this paper, we present a simple process algebra, called Statecharts Process Language (SPL), which is expressive enough for encoding Statecharts in a structure-preserving and semanticspreserving manner. We also establish that the behavioral equivalence bisimulation, when applied to SPL, preserves Statecharts semantics.", "num_citations": "57\n", "authors": ["315"]}
{"title": "Generic tools for verifying concurrent systems\n", "abstract": " Despite the enormous strides made in automatic verification technology over the past decade and a half, tools such as model checkers remain relatively underused in the development of software. One reason for this is that the bewildering array of specification and verification formalisms complicates the development and adoption by users of relevant tool support. This paper proposes a remedy to this state of affairs in the case of finite-state concurrent systems by describing an approach to developing customizable yet efficient verification tools.", "num_citations": "56\n", "authors": ["315"]}
{"title": "An algebraic theory of process efficiency\n", "abstract": " This paper presents a testing-based semantic theory for reasoning about the efficiency of concurrent systems as measured in terms of the amount of their internal activity. The semantic preorders are given an algebraic characterization, and their optimality is established by means of a full abstractness result. They are also shown to subsume existing bisimulation-based efficiency preorders. An example is provided to illustrate the utility of this approach.", "num_citations": "53\n", "authors": ["315"]}
{"title": "Modeling and verifying distributed systems using priorities: A case study\n", "abstract": " This paper illustrates the use of priorities in process algebras by a real-world example dealing with the design of a safety-critical network that is part of a railway signaling system. Priorities in process algebras support an intuitive modeling of distributed systems since undesired interleavings can be suppressed. This fact also leads to a substantial reduction of the sizes of models. We have implemented a CCS-based process algebra with priorities as a new front-end for the NCSU Concurrency Workbench, and we used model checking for verifying properties of the signaling system.", "num_citations": "51\n", "authors": ["315"]}
{"title": "JiNao: Design and implementation of a scalable intrusion detection system for the OSPF routing protocol\n", "abstract": " The JiNao IDS project focuses on detecting intrusions, especially insider attacks, against the OSPF (Open Shortest Path First) routing protocol. This paper presents the design, implementation and experiments of the protocol analysis and statistic anomaly detection modules in JiNao. Three OSPF insider attacks (ie, maxseq, maxage, and seq++ attacks) have been developed for evaluating JiNao's detecting capability. JiNao's protocol analysis module o ers the exibility to track down di erent attack signatures across multiple network protocols. The statistic module is based upon the algorithm developed by SRI's NIDES (Next-generation Intrusion Detection Expert System) project. Some modi cations and improvements to the algorithm are made for a more e ective implementation. Furthermore, a SNMP-based network management interface has been designed and implemented such that the JiNao IDS can be integrated with network management systems.", "num_citations": "50\n", "authors": ["315"]}
{"title": "Triggered message sequence charts\n", "abstract": " This paper introduces triggered message sequence charts (TMSCs), a graphical, mathematically well-founded framework for capturing scenario-based system requirements of distributed systems. Like message sequence charts (MSCs), TMSCs are graphical depictions of scenarios, or exchanges of messages between processes in a distributed system. Unlike MSCs, however, TMSCs are equipped with a notion of trigger that permits requirements to be made conditional, a notion of partiality indicating that a scenario may be subsequently extended, and a notion of refinement for assessing whether or not a more detailed specification correctly elaborates on a less detailed one. The TMSC notation also includes a collection of composition operators allowing structure to be introduced into scenario specifications so that interactions among different scenarios may be studied. In the first part of this paper, TMSCs are\u00a0\u2026", "num_citations": "47\n", "authors": ["315"]}
{"title": "A theory of testing for Markovian processes\n", "abstract": " We present a testing theory for Markovian processes in order to formalize a notion of efficiency which may be useful for the analysis of soft real time systems. Our Markovian testing theory is shown to enjoy close connections with the classical testing theory of De Nicola-Hennessy and the probabilistic testing theory of Cleaveland-Smolka et al. The Markovian testing equivalence is also shown to be coarser than the Markovian bisimulation equivalence. A fully abstract characterization is developed to ease the task of establishing testing related relationships between Markovian processes. It is then demonstrated that our Markovian testing equivalence, which is based on the (easier to work with) probability of executing a successful computation whose average duration is not greater than a given amount of time, coincides with the Markovian testing equivalence based on the (more intuitive) probability of reaching\u00a0\u2026", "num_citations": "47\n", "authors": ["315"]}
{"title": "The Concurrency Workbench of the New Century, Version 1.2-User's Manual\n", "abstract": " This document describes how to use a particular automatic verication tool: The Concurrency Workbench of the New Century (CWB-NC, previously called Concurrency Workbench of North Carolina)[23, 11]. The CWB-NC provides support for automatically answering the verication question: does system sys satisfy specication spec? To implement such a tool, the verication question must be formulated more carefully by xing the following: a precise notation for dening systems a precise notation for dening specications what it means for a system to satisfy a specication The CWB-NC supports several formulations of the verication question. The simplest type of verication supported by the tool is reachability analysis. Here, as in each type of verication, the rst step in using the tool is to write a description of the system at hand in one of the several design languages supported by the CWB-NC. The description is then parsed by the tool and checked for syntactic correctness. The user then gives a logical formula describing a\\bad state\" that the system should never reach. Given such a formula and system description, the CWB-NC explores every possible state the system may reach during execution and checks to see if a bad state is reachable. If a bad state is detected, a description of the execution sequence leading to the state is reported to the user. Many bugs such as deadlock and critical section violations may be found using this approach. Reachability analysis is actually a special case of a more general type of verication called model checking. In the model checking approach a system is again described using a design language and a property the\u00a0\u2026", "num_citations": "45\n", "authors": ["315"]}
{"title": "Modeling and verifying active structural control systems\n", "abstract": " This paper presents the results of a case study involving the use of a formal graphical notation, Modechart, and an automatic verification tool, the Concurrency Workbench, in the analysis of the design of a fault-tolerant active structural control system. Such control systems must satisfy strict requirements on their timing behavior; we show how to use various equivalence-based features supported by the Workbench to examine the timing behavior of different design alternatives, one of which has in excess of 1019 states. The central insight arising from the study involves the importance of compositionality for reasoning about large and complex systems; in particular, the success of the case study depends integrally on our notation's and tool's support of componentwise minimization.", "num_citations": "45\n", "authors": ["315"]}
{"title": "An algebraic theory of multiple clocks\n", "abstract": " This paper develops a temporal process algebra, CSA, for reasoning about distributed systems that involve qualitative timing constraints. It is a conservative extension of Milner's CCS that combines the idea of multiple clocks from the algebra PMC with the assumption of maximal progress familiar from timed process algebras such as TPL. Using a typical class of examples drawn from hardware design, we motivate why these features are useful and in some cases necessary for modeling and verifying distributed systems. We also present fully-abstract behavioral congruences based on the notion of strong bisimulation and observational equivalence, respectively. For temporal strong bisimulation we give sound and complete axiomatizations for several classes of processes.", "num_citations": "44\n", "authors": ["315"]}
{"title": "Automated validation of software models\n", "abstract": " The paper describes the application of an automated verification tool to a software model developed at Ford Motor Company. Ford already has in place an advanced model-based software development framework that employs the Matlab(R), Simulink(R), and Stateflow(R) modeling tools. During this project, we applied the invariant checker Salsa to a Simulink(R)/Stateflow(R) model of automotive software to check for nondeterminism, missing cases, dead code, and redundant code. During the analysis, a number of anomalies were detected that had not been found during manual review. We argue that the detection and correction of these problems demonstrates a cost-effective application of formal verification that elevates our level of confidence in the model.", "num_citations": "43\n", "authors": ["315"]}
{"title": "Probabilistic temporal logics via the modal mu-calculus\n", "abstract": " This paper presents a mu-calculus-based modal logic for describing properties of reactive probabilistic labeled transition systems (RPLTSs) and develops a model-checking algorithm for determining whether or not states in finite-state RPLTSs satisfy formulas in the logic. The logic is based on the distinction between (probabilistic) \u201csystems\u201d and (nonprobabilistic) \u201cobservations\u201d: using the modal mu-calculus, one may specify sets of observations, and the semantics of our logic then enable statements to be made about the measures of such sets at various system states. The logic may be used to encode a variety of probabilistic modal and temporal logics; in addition, the model-checking problem for it may be reduced to the calculation of solutions to systems of non-linear equations. Finally, the logic induces an equivalence on RPLTSs that coincides with accepted notions of probabilistic bisimulation in the literature.", "num_citations": "42\n", "authors": ["315"]}
{"title": "Assessing model-based testing: an empirical study conducted in industry\n", "abstract": " We compare manual testing without any automation performed by a tester at a software company with model-based testing (MBT) performed by a tester at a research center.", "num_citations": "40\n", "authors": ["315"]}
{"title": "Architectural interaction diagrams: AIDs for system modeling\n", "abstract": " This paper develops a modeling paradigm called Architectural Interaction Diagrams, or AIDs, for the high-level design of systems containing concurrent, interacting components. The novelty of AIDs is that they introduce interaction mechanisms, or buses, as first-class entities into the modeling vocabulary. Users then have the capability, in their modeling, of using buses whose behavior captures interaction at a higher level of abstraction than that afforded by modeling notations such as Message Sequence Charts or process algebra, which typically provide only one fixed interaction mechanism. This paper defines AIDs formally by giving them an operational semantics that describes how buses combine subsystem transitions into system-level transitions. This semantics enables AIDs to be simulated; to incorporate subsystems given in different modeling notations into a single system model; and to use testing\u00a0\u2026", "num_citations": "40\n", "authors": ["315"]}
{"title": "Efficient Model Checking Via B\u00fcchi Tableau Automata?\n", "abstract": " This paper describes an approach to engineering efficient model checkers that are generic with respect to the temporal logic in which system properties are given. The methodology is based on the \u201ccompilation\u201d of temporal formulas into variants of alternating tree automata called alternating B\u00fcchi tableau automata (ABTAs). The paper gives an efficient on-the-fly model-checking procedure for ABTAs and illustrates how translations of temporal logics into ABTAs may be concisely specified using inference rules, which may be thus seen as high-level definitions of \u201cmodel checkers\u201d for the logic given. Heuristics for simplifying ABTAs are also given, as are experimental results in the CWB-NC verification tool suggesting that, despite the generic ABTA basis, our approach can perform better than model checkers targeted for specific logics. The ABTA-based approach we advocate simplifies the retargeting of model\u00a0\u2026", "num_citations": "37\n", "authors": ["315"]}
{"title": "Simulation revisited\n", "abstract": " This paper develops an efficient algorithm for determining when one system is capable of simulating the behavior of another. The method combines an iterative algorithm for computing behavioral preorders with an algorithm that simultaneously computes the bisimulation equivalence classes of the systems in question. Experimental data indicate that the new routine dramatically outperforms the best-known algoritm for computing simulation, even when the systems are minimized with respect to bisimulation before the simulation algorithm is invoked.", "num_citations": "34\n", "authors": ["315"]}
{"title": "An operational framework for value-passing processes\n", "abstract": " This paper develops a semantic framework for concurrent languages with value passing. An operation analogous to substitution in the \u03bb-calculus is given, and a semantics is given for a value-passing version of Milner's Calculus of Communicating Systems (CCS). An operational equivalence is then defined and shown to coincide with Milner's (early) bisimulation equivalence. We also show how semantics maybe given for languages with asynchronous communication primitives. In contrast with existing approaches to value passing, this semantics does not reduce data exchange to pure synchronization over (potentially infinite) families of ports indexed by data, and it avoids variable renamings that are not local to processes engaged in communication.", "num_citations": "30\n", "authors": ["315"]}
{"title": "Automatic requirement extraction from test cases\n", "abstract": " This paper describes a method for extracting functional requirements from tests, where tests take the form of vectors of inputs (supplied to the system) and outputs (produced by the system in response to inputs). The approach uses data-mining techniques to infer invariants from the test data, and an automated-verification technology to determine which of these proposed invariants are indeed invariant and may thus be seen as requirements. Experimental results from a pilot study involving an automotive-electronics application show that using tests that fully cover the structure of the software yield more complete invariants than structurally-agnostic black-box tests.", "num_citations": "29\n", "authors": ["315"]}
{"title": "Priority and abstraction in process algebra\n", "abstract": " This paper defines a behavioral equivalence based on the notion of weak observational equivalence for processes in which actions may take priority over other actions. The largest congruence contained in this relation is then identified and given a complete equational axiomatization for finite processes. An example illustrates the utility of this equivalence which, in contrast with other equivalences for systems with priorities, abstracts from internal computation.", "num_citations": "29\n", "authors": ["315"]}
{"title": "Probabilistic temporal logics via the modal mu-calculus\n", "abstract": " This paper presents a mu-calculus-based modal logic for describing properties of probabilistic labeled transition systems (PLTSs) and develops a model-checking algorithm for determining whether or not states in finite-state PLTSs satisfy formulas in the logic. The logic is based on the distinction between (probabilistic) \u201csystems\u201d and (non- probabilistic) \u201cobservations\u201d: using the modal mu-calculus, one may specify sets of observations, and the semantics of our logic then enable statements to be made about the measures of such sets at various system states. The logic may be used to encode a variety of probabilistic modal and temporal logics; in addition, the model-checking problem for it may be reduced to the calculation of solutions to systems of non-linear equations.", "num_citations": "28\n", "authors": ["315"]}
{"title": "Generating diagnostic information for behavioral preorders\n", "abstract": " This paper describes a method for generating diagnostic information that explains why a given finite-state system fails to be greater than its specification with respect to the prebisimulation preorder. The information takes the form of a logical formula satisfied by the specification but not by the system and thus may be used by system designers for debugging purposes. Our technique relies on modifying an algorithm for computing the prebisimulation preorder so that information needed for generating these distinguishing formulas is saved appropriately. As a number of other behavioral preorders may be characterized in terms of prebisimulation preorder, our approach may be used as a basis for computing diagnostic information for these relations as well.", "num_citations": "28\n", "authors": ["315"]}
{"title": "A process algebra with distributed priorities\n", "abstract": " This paper presents a process algebra for distributed systems in which some actions may take precedence over others. In contrast with existing approaches to priorities, our algebra only allows actions to preempt others at the same \u201clocation\u201d and therefore captures a notion of localized precedence. Using Park's and Milner's notion of strong bisimulation as a basis, we develop a behavioral congruence and axiomatize it for finite processes; we also derive an associated observational congruence. Simple examples highlight the utility of the theory.", "num_citations": "25\n", "authors": ["315"]}
{"title": "Fast on-the-fly parametric real-time model checking\n", "abstract": " This paper presents a local algorithm for solving the universal parametric real-time model-checking problem. The problem may be phrased as follows: given a real-time system and temporal formula, both of which may contain parameters, and a constraint over the parameters, does every allowed parameter assignment ensure that the real-time system satisfies the formula? Our approach relies on translating these model-checking problems into predicate equation systems, and then using an efficient proof-search algorithm to solve these systems. Experimental data shows that our method substantially outperforms existing approaches for systems that contain errors, while exhibiting comparable behavior for systems that are correct. This fast error-detection capability of our technique makes it especially interesting for design approaches in which model checkers are used \"early and often\" to detect design errors in an\u00a0\u2026", "num_citations": "24\n", "authors": ["315"]}
{"title": "Analyzing concurrent systems using the Concurrency Workbench\n", "abstract": " This paper presents a case study illustrating the different analytical facilities provided by the Concurency Workbench, an automatic verification tool for finite-state systems. The system we consider is the Alternating Bit Protocol, a communications protocol designed to ensure error-free data transfer over lossy media. Using the Workbench we investigate several features of the protocol, and we isolate a crucial property (the assumption of which is unstated in the protocol definition) that media must have in order for the protocol to be deadlock-free.", "num_citations": "24\n", "authors": ["315"]}
{"title": "Verifying an Intelligent Structural Control System: A Case Study.\n", "abstract": " Describes the formal verification of the timing properties of the design of an intelligent structural control system using the Concurrency Workbench, an automatic verification tool for finite-state processes. The high-level design of the system is first given in Modechart, a graphical specification language for real-time systems, and then translated into a temporal process algebra supported by the Workbench. The facilities provided by this tool are then used to analyze the system and ultimately show it to be correct.< >", "num_citations": "23\n", "authors": ["315"]}
{"title": "On Automatically Distinguishing Inequivalent Processes.\n", "abstract": " This paper describes a technique for generating a logical formula that differentiates between two bisimulation-mequivalent finite-state systems. The method works in conjunction with a partition-refinement algorithm for computing bisimulation equivalence and yields formulas that are often minimal in a precisely defined sense. As a number of other behavioral equivalences may be characterized in terms of bisimulation equivalence, our technique may be used to generate appropriate distinguishing information for these relations also.", "num_citations": "23\n", "authors": ["315"]}
{"title": "A practical approach to implementing real-time semantics\n", "abstract": " This paper investigates implementations of process algebras which are suitable for modeling concurrent real-time systems. It suggests an approach for efficiently implementing real-time semantics using dynamic priorities. For this purpose a process algebra with dynamic priority is defined, whose semantics corresponds one-to-one to traditional real-time semantics. The advantage of the dynamic-priority approach is that it drastically reduces the state-space sizes of the systems in question while preserving all properties of their functional and real-time behavior. The utility of the technique is demonstrated by a case study that deals with the formal modeling and verification of several aspects of the widely-used SCSI-2 bus-protocol. The case study is carried out in the Concurrency Workbench of North Carolina, an automated verification tool in which the process algebra with dynamic priority is implemented. It\u00a0\u2026", "num_citations": "22\n", "authors": ["315"]}
{"title": "Towards behavioral reflexion models\n", "abstract": " Software architecture has become essential in the struggle to manage today's increasingly large and complex systems. Software architecture views are created to capture important system characteristics on an abstract and, thus, comprehensible level. As the system is implemented and later maintained, it often deviates from the original design specification. Such deviations can have implication for the quality of the system, such as reliability, security, and maintainability. Software architecture compliance checking approaches, such as the reflexion model technique, have been proposed to address this issue by comparing the implementation to a model of the systems' architecture design. However, architecture compliance checking approaches focus solely on structural characteristics and ignore behavioral conformance. This is especially an issue in Systems-of-Systems. Systems-of-Systems (SoS) are decompositions\u00a0\u2026", "num_citations": "21\n", "authors": ["315"]}
{"title": "Security assurance cases for medical cyber\u2013physical systems\n", "abstract": " With cybersecurity increasingly becoming a focus of regulatory concern, both medical device manufacturers and regulators are facing another challenge: how to establish, and also demonstrate, that the devices are also secure. This paper outlines an approach to constructing assurance cases to capture assumptions about the attacker by 1) identifying the hazards of interest to attacker; 2) identifying attack surfaces; 3) enumerating vulnerabilities and attack scenarios; and 4) ranking attack scenarios on the basis of a risk model. Introducing the security considerations early in the design cycle, we can better integrate security with existing engineering processes to yield documents that both improve the engineering processes and are acceptable for regulatory oversight.", "num_citations": "20\n", "authors": ["315"]}
{"title": "Priority and abstraction in process algebra\n", "abstract": " More than 15 years ago, Cleaveland and Hennessy proposed an extension of the process algebra CCS in which some actions may take priority over others. The theory was equipped with a behavioral congruence based on strong bisimulation.This article gives a full account of the challenges in, and the solutions employed for, defining a semantic theory of observation congruence for this process algebra. A full-abstraction result is presented whose proof relies on a novel approach based on successive approximations for identifying the largest congruence contained in an intuitive but na\u00efve equivalence. Prioritized observation congruence is also characterized equationally for the class of finite processes, while its utility for system verification is demonstrated by an illustrative example.", "num_citations": "20\n", "authors": ["315"]}
{"title": "Formal verification of software-based medical devices considering medical guidelines\n", "abstract": " Objective                 \u00a0\u00a0\u00a0\u00a0Software-based devices have increasingly become an important part of several clinical scenarios. Due to their critical impact on human life, medical devices have very strict safety requirements. It is therefore necessary to apply verification methods to ensure that the safety requirements are met. Verification of software-based devices is commonly limited to the verification of their internal elements without considering the interaction that these elements have with other devices as well as the application environment in which they are used. Medical guidelines define clinical procedures, which contain the necessary information to completely verify medical devices. The objective of this work was to incorporate medical guidelines into the verification process in order to increase the reliability of the software-based medical devices\u00a0\u2026", "num_citations": "19\n", "authors": ["315"]}
{"title": "Validating automotive control software using instrumentation-based verification\n", "abstract": " This paper discusses the results of an application of a formally based verification technique, called Instrumentation-Based Verification (IBV), to a production automotive lighting controller. The goal of the study is to assess, from both a tools as well as a methodological perspective, the performance of IBV in an industrial setting. The insights obtained as a result of the project include a refinement of a previously developed architecture for requirements specifications; observations about changes to model-based design workflows; insights into the role of requirements during development; and the capability of automated verification to detect inconsistencies among requirements as well as between requirements and design models.", "num_citations": "19\n", "authors": ["315"]}
{"title": "Fast generic model-checking for data-based systems\n", "abstract": " This paper shows how predicate equation systems (PESs) may be used to solve model-checking problems for systems, such as those involving real-time or value passing, that manipulate data. PESs are first defined and the encoding of model-checking problems described; then generic global and local approaches for solving PESs are given. Real-time model checking is then considered in detail, and a new, efficient on-the-fly technique for real-time model checking based on proof search in PESs is developed and experimentally shown to significantly outperform existing approaches when system specifications or formula specifications contain errors and to be competitive when both are correct.", "num_citations": "19\n", "authors": ["315"]}
{"title": "Time, abstraction, causality and modularity in interactive systems\n", "abstract": " We study discrete models of interactive distributed systems structured into components and operating concurrently in a time frame. For such models of the data or signal flow in interactive system we assume that there is a source and a cause for each communication event and its associated information. To understand the logical dependencies for the events of systems causality is a key issue for reasoning about the event flow. Being interested in a structured modular approach we want to be able to abstract away all internal aspects of systems that are used as components within a system's architecture. We speak of interface abstraction. The interface abstraction is to keep only the aspects relevant for the usage of the component and the construction of the interface abstraction of the architecture. We speak of modularity if the interface abstraction of an architecture is the result of the composition of the interface\u00a0\u2026", "num_citations": "19\n", "authors": ["315"]}
{"title": "A logical process calculus\n", "abstract": " This paper presents the Logical Process Calculus (LPC), a formalism that supports heterogeneous system specifications containing both operational and declarative subspecifications. Syntactically, LPC extends Milner's Calculus of Communicating Systems with operators from the alternation-free linear-time \u03bc-calculus (LT\u03bc). Semantically, LPC is equipped with a behavioral preorder that generalizes Hennessy's and De Nicola's must-testing preorder as well as LT\u03bc's satisfaction relation, while being compositional for all LPC operators. From a technical point of view, the new calculus is distinguished by the inclusion of (i) both minimal and maximal fixed-point operators and (ii) an unimplementability predicate on process terms which tags inconsistent specifications. The utility of LPC is demonstrated by means of an example highlighting the benefits of heterogeneous system specification.", "num_citations": "18\n", "authors": ["315"]}
{"title": "Recovering views of inter-system interaction behaviors\n", "abstract": " This paper presents an approach for recovering application-level views of the interaction behaviors between systems that communicate via networks. Rather than illustrating a single behavior, a sequence diagram is constructed that describes the characteristics of multiple combined behaviors. The approach has several properties that make it particularly suitable for analyzing heterogeneous systems. First, since the interactions are retrieved from observing the network communication, our technique can be applied to systems that are implemented in different languages and run on different platforms. Second, it does not require the availability or modification of source code. After the behaviors are extracted, we employ methods to merge multiple observed behaviors to a single sequence diagram that illustrates the overall behavior.The contributions of this paper are a technique for observing and processing the\u00a0\u2026", "num_citations": "17\n", "authors": ["315"]}
{"title": "Unit verification: the CARA experience\n", "abstract": " The computer-aided resuscitation algorithm, or CARA, is part of a US Army-developed automated infusion device for treating blood loss experienced by combatants injured on the battlefield. CARA is responsible for automatically stabilizing a patient\u2019s blood pressure by infusing blood as needed based on blood pressure data the CARA system collects. The control part of the system is implemented in software, which is extremely safety critical and thus must perform correctly .               This paper describes a case study in which a verification tool, the Concurrency Workbench of the New Century (CWB-NC), is used to analyze a model of the CARA system. The huge state space of CARA makes it problematic to conduct traditional \u201cpush-button\u201d automatic verification such as model checking. Instead, we develop a technique called unit verification, which entails taking small units of a system, putting them in a\u00a0\u2026", "num_citations": "17\n", "authors": ["315"]}
{"title": "Verification of an active control system using temporal process algebra\n", "abstract": " In this paper we describe complementary approaches that can be used to ensure the reliability of real-time systems, such as those used in active structural control systems. These approaches include both model-checking and simulation, and are based on a temporal process algebra. We combine these formal methods with a high-level, graphical modeling technique, Modechart, to specify an active structural control system consisting of several processors. Timing requirements on the system are specified and verified with a combination of process algebraic models and modal logic, and various simulation concepts are described for debugging models and for gaining insight into system behavior.", "num_citations": "17\n", "authors": ["315"]}
{"title": "Computing diagnostic tests for incorrect processes\n", "abstract": " This paper presents a method for generating diagnostic tests that is to be used in conjunction with an algorithm for computing the testing preorder of Hennessy and DeNicola. These tests may be used to debug a finite-state system that fails to meet (i.e be larger in the testing preorder than) a specification; in this case, the system is guaranteed to fail the test that is produced, while the specification is guaranteed to pass it. Our technique relies on transforming the diagnostic information produced by a general preorder algorithm into tests when the general preorder algorithm is used to compute the testing preorder. The method does not affect the time complexity computing the testing preorder.", "num_citations": "17\n", "authors": ["315"]}
{"title": "Model based design verification: A monitor based approach\n", "abstract": " This paper assesses the utility of an automated functional verification methodology in the design of a body electronics application. The use of design models as detailed specifications for software is gaining steady acceptance in the automotive industry because of the advantages it offers in terms of rapid system prototyping and automatic code generation. This paper argues that such modeling effort can also be used to provide support for design verification, so that errors may be pinpointed before they find their way into code, when they become much harder and more expensive to isolate, diagnose and repair.", "num_citations": "16\n", "authors": ["315"]}
{"title": "Comparing model checkers for timed UML activity diagrams\n", "abstract": " This paper describes the results of an experimental study on the use of model checkers to verify properties of UML activity diagrams. The motivation for the study derives from the desirability of checking properties of systems early in the development process, and the fact that UML is a commonly used notation for system models. The study assesses the performance of different model checking tools, and strategies for converting activity diagrams into the tools input notation, for a class of real time activity diagrams used in medical device design. This paper compares different translations for four model checkers in particular: UPPAAL, PES, SPIN and NuSMV. The performance of these model checkers is then compared using a suite of UML activity diagrams of varying complexity developed by us for this purpose. The results of a case study involving the design of an infusion pump are also presented.", "num_citations": "15\n", "authors": ["315"]}
{"title": "The integrated CWB-NC/PIOAtool for functional verification and performance analysis of concurrent systems\n", "abstract": " This paper reports on an effort to integrate two verification tools, the Concurrency Workbench of the New Century (CWB-NC) and PIOATool. Our aim is to build a single tool that combines the \u201cfunctional\u201d analysis capabilities of the CWB-NC with the compositional performance-analysis features of PIOATool. We discuss some of the issues involved in the integration, highlighting a particular integration paradigm in which one tool becomes a subshell of the other.", "num_citations": "15\n", "authors": ["315"]}
{"title": "A process algebra with distributed priorities\n", "abstract": " This paper presents a process algebra for distributed systems in which some actions may take precedence over others. The algebra is distinguished by the design decision that it only allows actions to pre-empt others at the same \u201clocation\u201d and therefore captures a notion of localized precedence. Using Park's and Milner's notion of strong bisimulation as a basis, we develop a behavioral congruence and axiomatize it for finite processes; we also derive an associated observational congruence and present logical characterizations of our behavioral relations. Simple examples highlight the utility of the theory.", "num_citations": "14\n", "authors": ["315"]}
{"title": "Gdr: A visualization tool for graph algorithms\n", "abstract": " 1. Introduction. This report describes GDR for Graph Drawing, a tool for editing graphs and animating graph algorithms. The motivation for animation tools comes primarily from the classroom; students often have difficulty mastering the formal concepts of graph theory, even though they usually have no trouble in following the associated visual intuitions. An appropriate animation tool can provide an invaluable link between formalism and graphical intuition, since students are given the opportunity to see how a formal presentation of a graph algorithm directly translates into visually intuitive operations on graphs. For this reason, animation systems can also play a very useful research role as testbeds for prototyping new algorithms and for testing conjectures about graphs.The design of GDR was strongly influenced by our desire for the tool to be easyto-use even by relatively inexperienced programmers, portable, and flexible. Our approach was to develop GDR as a tool rather than a self-contained system, so that it is easily modified and simple to interface with other software. This has led to two approaches to using GDR in conjunction with other tools. In the first, GDR functions as a graph editor; users create graphs using the tool, save them in files, and feed the files as input into the other tools. This mode of interaction only requires that front-ends be written for the other tools that can parse the very simple output generated by GDR. The second mode of interaction is object-oriented; GDR provides a high-level interface to graph objects that programmers can write programs to manipulate using calls to functions implemented in GDR. Users of GDR can\u00a0\u2026", "num_citations": "14\n", "authors": ["315"]}
{"title": "A semantic theory for heterogeneous system design\n", "abstract": " This paper extends DeNicola and Hennessy\u2019s testing theory from labeled transition system to B\u00fcchi processes and establishes a tight connection between the resulting B\u00fcchi must-preorder and satisfaction of linear-time temporal logic (LTL) formulas. An example dealing with the design of a communications protocol testifies to the utility of the theory for heterogeneous system design, in which some components are specified as labeled transition systems and others are given as LTL formulas.", "num_citations": "13\n", "authors": ["315"]}
{"title": "Predictability of real-time systems: A process-algebraic approach\n", "abstract": " This paper presents a testing-based semantic preorder that relates real-time systems given in the process description language TPL on the basis of the predictability of their timing behavior. This predictability is measured in terms of the amount of variability present in processes' \"activity-completion times\". The semantic preorder is shown to coincide with an already existing, well-investigated implementation relation for TPL-the must-preorder. The optimality of our relation is also established by means of a full abstraction result. An example is provided to illustrate the utility of this work.", "num_citations": "13\n", "authors": ["315"]}
{"title": "Notions of centralized and decentralized opacity in linear systems\n", "abstract": " We formulate notions of opacity for cyberphysical systems modeled as discrete-time linear time-invariant systems. A set of secret states is k-ISO with respect to a set of nonsecret states if, starting from these sets at time 0, the outputs at time k are indistinguishable to an adversarial observer. Necessary and sufficient conditions to ensure that a secret specification is k-ISO are established in terms of sets of reachable states. We also show how to adapt techniques for computing underapproximations and overapproximations of the set of reachable states of dynamical systems in order to soundly approximate k-ISO. Furthermore, we provide a condition for output controllability, if k-ISO holds, and show that the converse holds under an additional assumption. We extend the theory of opacity for single-adversary systems to the case of multiple adversaries and develop several notions of decentralized opacity. We study the\u00a0\u2026", "num_citations": "12\n", "authors": ["315"]}
{"title": "Model Checking is Refinement--Relating B\u00fcchi Testing and Linear-time Temporal Logic\n", "abstract": " This paper develops a semantic foundation for reasoning about reactive systems specifications featuring combinations of labeled transition systems and formulas in linear time temporal logic LTL. Using Buechi automata as a semantic basis, the paper introduces two refinement preorders based on DeNicola and Hennessys notion of may-and must-testing. Alternative characterizations for these relations are provided and used to show that the new preorders are conservative extensions of the traditional DeNicola and Hennessy preorders. The paper then establishes a tight connection between LTL formula satisfaction and the Buechi must-preorder. More precisely, it is shown that a labeled transition system satisfies an LTL formula if and only if it refines an appropriately defined Buechi automaton that can be constructed from the formula. Consequently, the Buechi must-preorder allows for a uniform treatment of traditional notions of process refinement and model checking. The implications of the novel theory are illustrated by means of a simple example system, in which some components are specified as transition systems and others as LTL formulas.Descriptors:", "num_citations": "12\n", "authors": ["315"]}
{"title": "Pragmatics of model checking: an STTT special section\n", "abstract": " Since its discovery in the early 1980s, model checking has emerged as one of the most exciting areas in the field of formal verification of system correctness. The chief reason for this enthusiasm resides in the fact that model checkers establish in a fully automated manner whether or not a system satisfies formal requirements; users need not construct proofs. Until the early 1990s, however, the practical impact of model checking was modest, in large part because the state-explosion problem limited the applicability of the technology. Recent advances in the field have dramatically expanded the scope of model checking, however, and interest in it on the part of practitioners is growing. This special section surveys several recent approaches to attacking the state explosion that are supporting the continued advancement of model checking as a viable technology for improved system design.", "num_citations": "12\n", "authors": ["315"]}
{"title": "Priorities for modeling and verifying distributed systems\n", "abstract": " This paper illustrates the use of priorities in process algebras by a real-world example dealing with the design of a safety-critical network which is part of a railway signaling system. Priorities in process algebras support an intuitive modeling of distributed systems since undesired inter-leavings can be suppressed. This fact also leads to a substantial reduction of the sizes of models. We have implemented a CCS-based process algebra with priorities as a new front-end for the NCSU Concurrency Workbench, and we use model checking for verifying properties of the signaling system.", "num_citations": "12\n", "authors": ["315"]}
{"title": "Type-theoretic models of concurrency\n", "abstract": " Sequential computation has well-understood correctness criteria and proof  techniques for verifying programs, but the novelty and complexity of  concurrent computation complicates a similar analysis of concurrenct  programs. This thesis examines the use of a system for developing formal  mathematics, the Nuprl proof development system, as a tool for reasoning  about concurrency and ameliorating somewhat the complex chore of analyzing  concurrent programs.", "num_citations": "12\n", "authors": ["315"]}
{"title": "A framework for opacity in linear systems\n", "abstract": " We present a framework for opacity in cyberphysical systems modeled as discrete time linear time invariant systems. A set of secret states is k-ISO with respect to a set of nonsecret states if, starting from these sets at time 0, the outputs at time k are indistinguishable to a passive adversarial observer. Necessary and sufficient conditions for k-ISO are given in terms of reachable sets of the system. Properties of k-ISO under unions and intersections are verified. It is seen that while unions of opaque sets preserve opacity, this is not necessarily true for intersections. We show that under certain conditions, k-ISO is equivalent to output controllability. Finally, we present an algorithm to compute a k-ISO set of states, given candidate secret and nonsecret sets of initial states.", "num_citations": "11\n", "authors": ["315"]}
{"title": "A menagerie of timed automata\n", "abstract": " Timed automata are state-machine-like structures used to model real-time systems. Since their invention in the early 1990s, a number of often subtly differing variants have appeared in the literature; one of this article\u2019s key contributions is defining, highlighting, and reconciling these differences. The article achieves this by defining a baseline theory of timed automata, characterizing each variant both syntactically and semantically, and giving, when possible, syntactic and semantic conversion to and from the baseline version. This article also surveys various extensions to the basic timed-automaton framework.", "num_citations": "11\n", "authors": ["315"]}
{"title": "Modeling web services composition with timed Pi calculus\n", "abstract": " The Web service technology is the de facto standard to expose the functions of business applications for implementing the integration of existing e-business and improving business processes. We need to study the problem of modeling, testing and verifying the behaviors of Web services, especially in services composition. This study focuses on the issue of behavioral modeling in a service composition. It adopts the timed PI calculus to model service behaviors and interactions in a formal way. To handle the structural composition, we improve the syntax and semantic of timed PI Calculus. Based on the evolution of the timed PI calculus process, we can compose services on the fly and ensure the correctness of services composition. Our case study shows that the proposed approach has a good scalability and efficacy for service composition. In conclusion, our approach is an improvement method to modeling Web\u00a0\u2026", "num_citations": "11\n", "authors": ["315"]}
{"title": "Abstractions for preserving all CTL* formulae\n", "abstract": " Abstractions for Preserving All CTL* Formulae | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleReportsAbstractions for Preserving All CTL* Formulae ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide books cover image Abstractions for Preserving All CTL* Formulae March 1994 Authors: Rance W Cleaveland profile image Rance Cleaveland, S Purushothaman Iyer profile image S. P Iyer, Daniel Yankelevich profile image \u00a9 \u2026", "num_citations": "11\n", "authors": ["315"]}
{"title": "Architecture reconstruction and analysis of medical device software\n", "abstract": " New research is underway at the FDA to investigate the benefits of integrating architecture analysis into safety evaluations of medical-device software. Due to the complexity in setting up testing environments for such software, the FDA is unable to conduct large-scale safety testing, instead, it must rely on other techniques to build an argument for whether the software is safe or not. The architecture analysis approach, formalized using relational algebra, is based on reconstructing abstract, yet precise, architectural views from source code to help build such arguments about safety. This paper discusses the use of the formal approach to analyze the Computer-Assisted Resuscitation Algorithm (CARA) software, which controls an infusion pump designed to provide automated assistance for transfusing blood. The results suggest that a) architecture analysis offers many insights related to software quality in general and\u00a0\u2026", "num_citations": "10\n", "authors": ["315"]}
{"title": "Dynamic priorities for modeling real-time\n", "abstract": " This paper describes an approach for modeling real-time systems using dynamic priorities The advantage of the technique is that it drastically reduces the state space sizes of the systems in question while preserving properties of their functional behavior. We demonstrate the utility of our approach by formally modeling and verifying aspects of the widely-used SCSI-2 bus-protocol. It turns out that the state space of this model is about an order of magnitude smaller than the one resulting from traditional real-time semantics.", "num_citations": "10\n", "authors": ["315"]}
{"title": "Efficient temporal-logic query checking for presburger systems\n", "abstract": " This paper develops a framework for solving temporal-logic query-checking problems for a class of infinite-state system models that compute with integer-valued variables (so-called Presburger systems, in which Presburger formulas are used to define system behavior). The temporal-logic query checking problem may be formulated as follows: given a model and a temporal logic formula with placeholders, compute a set of assignments of formulas to placeholders such that the resulting temporal formula is satisfied by the given model. Temporal-logic query checking has proved useful as a means for requirements and design understanding; existing work, however, has focused only on propositional temporal logic and finite-state systems. Our method is based on a symbolic model-checking technique that relies on proof search. The paper first introduces this model-checking approach and then shows how it can be\u00a0\u2026", "num_citations": "9\n", "authors": ["315"]}
{"title": "An analysis method for medical device security\n", "abstract": " This paper is a proposal for a poster. In it we describe a medical device security approach that researchers at Fraunhofer used to analyze different kinds of medical devices for security vulnerabilities. These medical devices were provided to Fraunhofer by a medical device manufacturer whose name we cannot disclose due to non-disclosure agreements.", "num_citations": "8\n", "authors": ["315"]}
{"title": "Constructing safety assurance cases for medical devices\n", "abstract": " This paper lays out a approach for safety assurance case argumentation. The approach links together in a principled manner a device's highest-level safety claims, operating environments and hazards; and its safety requirements, final implementation, and test and other validation results. This approach is intended for the creation of safety assurance cases for pre-market submissions to a regulatory authority like the Food and Drug Administration.", "num_citations": "8\n", "authors": ["315"]}
{"title": "Opacity for switched linear systems: Notions and characterization\n", "abstract": " A switched system consists of a finite number of subsystems and a rule that orchestrates switching among them. We develop notions of opacity for discrete-time switched linear systems. We distinguish between cases when the secret is specified as a set of initial modes, a set of initial states, or a combination of the two. The novelty of our schemes is in the fact that we place restrictions on: i) the allowed transitions between modes (specified by a directed graph), ii) the number of allowed changes of modes (specified by lengths of paths in the directed graph), and iii) the dwell times in each mode. Each notion of opacity is characterized in terms of allowed switching sequences and sets of reachable states and/ or modes. Finally, we present algorithmic procedures to verify these notions, and provide bounds on their computational complexity.", "num_citations": "7\n", "authors": ["315"]}
{"title": "Formal modeling of middleware-based distributed systems\n", "abstract": " Effective design of middleware-based systems requires modeling notations that allow the use of process-interaction schemes provided by different middleware packages directly in designs. Traditional design notations typically only support a fixed class of interprocess interaction schemes, and designers wishing to use them for modeling middleware-based systems must devote significant effort to encoding the middleware primitives in the notation. In this paper, we demonstrate how a new graphical design notation, Architectural Interaction Diagrams (AIDs), which provides parameterized support for different interaction schemes, may be used to model a real-life middleware-based system like the Event Heap coordination infrastructure of the i-Room ubiquitous computing environment.", "num_citations": "7\n", "authors": ["315"]}
{"title": "TRIM: A tool for triggered message sequence charts\n", "abstract": " TRIM is a tool for analyzing system requirements expressed using Triggered Message Sequence Charts (TMSCs). TMSCs enhance MSCs with capabilities for expressing conditional and partial behavior and with a refinement ordering. This paper shows how the Concurrency Workbench of the New Century may be adapted to check refinements between TMSC specifications.", "num_citations": "7\n", "authors": ["315"]}
{"title": "Experience report: Model-based test automation of a concurrent flight software bus\n", "abstract": " Many systems make use of concurrent tasks, however it is often difficult to test concurrent design. Therefore, many test cases are simplified and do not fully test all concurrency aspects of the system. We encountered this problem when analyzing test cases for concurrent flight software at NASA. To address this problem, we developed and evaluated a model based testing (MBT) technique for testing of concurrent systems. Using MBT, the tester creates a model, which is based on the requirements of the system under test (SUT), and lets the computer generate innumerable test cases automatically from the model. We evaluate the effectiveness of the technique using Microsoft's Spec Explorer MBT tool. We apply the technique on NASA's Core Flight Software (cFS) software bus module API, which is based on a concurrent publisher-subscriber architecture style and is a safety-critical system. We describe how we created\u00a0\u2026", "num_citations": "6\n", "authors": ["315"]}
{"title": "A framework for decentralized opacity in linear systems\n", "abstract": " We formulate several notions of decentralized opacity for cyberphysical systems in the presence of multiple adversarial observers. Broadly speaking, we study the following cases: i) the presence or lack of a centralized coordinator, and ii) the presence or absence of collusion among the adversaries. In the case of colluding adversaries, we derive a condition for non-opacity that depends on the structure of the directed graph representing the communication between adversaries. Finally, we define a notion of opacity where the condition that the outputs be indistinguishable is relaxed.", "num_citations": "6\n", "authors": ["315"]}
{"title": "UML-VT: A Formal Verification Environment for UML Activity Diagrams.\n", "abstract": " This paper introduces a translation tool that supports formal verification of UML activity diagrams using the model checkers: UPPAAL, SPIN, NuSMV and PES. The motivation for this tool arises from the desire to check the properties of a system early in the development process, and the fact that UML is commonly used to describe software models. The tool is implemented as an Eclipse-plugin that automatically translates the UML activities and logical requirements into valid input notation for the model checkers. The automated aspect of the plugin allows users without a background in formal methods to verify the safety and liveness of a system. The translation strategies implemented in this plugin are the result of an experimental study. A tutorial video can be found in https://www. youtube. com/watch? v= AHsih8REUxM.", "num_citations": "6\n", "authors": ["315"]}
{"title": "Refinement-based requirements modeling using triggered message sequence charts\n", "abstract": " Triggered message sequence charts (TMSCs) are a visual, mathematically precise notation for capturing system requirements as conditional and partial scenarios. We show how TMSCs may be used to formalize two different requirements modeling methodologies. The first approach combines prescriptive (\"do this\") and constraint-based (\"don't do that\") requirements within a single specification; it is useful for composing localized subsystem requirements with global system ones. The second approach supports layered specifications in which partial descriptions of requirements may be elaborated on in a succession of steps; it is suitable for the incremental development of complex behavior in which \"error\" scenarios are \"layered on top of\" normative ones. Both methodologies derive their formal robustness from the notion of semantic refinement for TMSCs, which is based on DeNicola's and Hennessy's must preorder\u00a0\u2026", "num_citations": "6\n", "authors": ["315"]}
{"title": "Towards formal but flexible scenarios\n", "abstract": " We argue that the evident utility of scenario-based modeling can be greatly enhanced when enriched with a mathematically precise notion of conditionality and partiality, such as that found in Triggered Message Sequence Charts (TMSCs). Unlike traditional Message Sequence Charts, the TMSC formalism allows scenarios to be conditional and partial, supports logical as well as behavioral operators for scenario composition, and is equipped with a refinement notion drawn from traditional process theory that provides a rigorous basis for stepwise development of specifications. This paper illustrates these points via the Center TRACON Automation System for flight control.", "num_citations": "6\n", "authors": ["315"]}
{"title": "The concurrency workbench of north carolina\n", "abstract": " The di culty of building concurrent software systems has sparked a large research e ort to develop formal approaches to the design and analysis of these systems. To reason formally about real-world systems, tool support is necessary; consequently, a number of tools embodying various analyses have been developed. Some of these tools include capabilities for performing automatic veri cation. In general these tools o er decision procedures that answer the veri cation question: does system sys satisfy speci cation spec? The tools di er in the formal notation used to describe systems and give speci cations and in the decision procedures used to determine whether or not a system meets its speci cation. This document describes how to use a particular automatic veri cation tool: The Concurrency Workbench of North Carolina (CWB-NC) 9, 11]. The CWB-NC provides support for automatically answering the veri cation question: does system sys satisfy speci cation spec? To implement such a tool, the veri cation question must be formulated more carefully by xing the following: a precise notation for de ning systems a precise notation for de ning speci cations what it means for a system to satisfy a speci cationLike its predecessor, the Edinburgh Concurrency Workbench 8, 14], the CWB-NC supports several formulations of the veri cation question. One formulation supported by the CWB-NC and its predecessor involves using a process algebra such as CCS 13] for de ning systems and speci cations and using a behavioral equivalence to relate systems and speci cations. A number of useful behavioral equivalences have been proposed. A behavioral\u00a0\u2026", "num_citations": "6\n", "authors": ["315"]}
{"title": "The power of proofs: New algorithms for timed automata model checking\n", "abstract": " This paper presents the first model-checking algorithm for an expressive modal mu-calculus over timed automata, , and reports performance results for an implementation. This mu-calculus contains extended time-modality operators and can express all of TCTL. Our algorithmic approach uses an \u201con-the-fly\u201d strategy based on proof search as a means of ensuring high performance for both positive and negative answers to model-checking questions. In particular, a set of proof rules for solving model-checking problems are given and proved sound and complete; our algorithm then model-checks a property by constructing a proof (or showing none exists) using these rules. One noteworthy aspect of our technique is that we show that verification performance can be improved with derived rules, whose correctness can be inferred from the more primitive rules on which they are based. In this paper, we give\u00a0\u2026", "num_citations": "5\n", "authors": ["315"]}
{"title": "Executable requirements specifications using triggered message sequence charts\n", "abstract": " Triggered Message Sequence Charts (TMSCs) are a scenario-based visual formalism for early stage requirements specifications of distributed systems. In this paper, we present a formal operational semantics for TMSCs that allow the simulation of TMSC system descriptions, so that errors and inconsistencies in specification may be detected early on. The semantics is defined in terms of Structured Operational Semantics (SOS) rules that guide the step-wise execution of TMSC specifications. We also consider the equivalence of this semantics and the TMSC denotational semantics that has been presented in previous work.", "num_citations": "5\n", "authors": ["315"]}
{"title": "An extensible operational semantics for UML activity diagrams\n", "abstract": " This paper presents an operational semantics for UML activity diagrams, which can be extended according to domain-specific needs. The purpose of this semantics is three-fold: to give a robust basis for verifying model correctness; to help validate model transformations; and to provide a well-formed basis for assessing whether a proposed extension/interpretation of the modeling language is consistent with the standard. The challenges of a general formal framework for UML models include the semi-formality of the semantics specification, the extensibility of the language, and (sometimes deliberate, sometimes accidental) under-specification of model behavior in the standard. We also propose the use of simulation relations to verify whether a language extension is consistent with the UML standard.", "num_citations": "4\n", "authors": ["315"]}
{"title": "Generalized synchronization trees\n", "abstract": " This paper develops a generalized theory of synchronization trees. In their original formulation, synchronization trees modeled the behavior of nondeterministic discrete-time reactive systems and served as the foundational theory upon which process algebra was based. In this work, a more general notion of tree is proposed that is intended to support the modeling of systems with a variety of notions of time, including continuous and hybrid versions. (Bi)simulation is also studied, and it is shown that two notions that coincide in the discrete setting yield different relations in the generalized framework. A CSP-like parallel composition operator for generalized trees is defined as a means of demonstrating the support for compositionality the new framework affords.", "num_citations": "4\n", "authors": ["315"]}
{"title": "Integrating model checking and UML based model-driven development for embedded systems\n", "abstract": " This paper discusses issues associated with integrating model checkers into a model-based development environment for embedded systems. The environment, DMOSES, is based on a formalization of UML Activity Diagrams and is used to generate correct and efficient code from such models; a key application area is the medical-device domain. A recent effort has focused on introducing formal reasoning into the development flow so that modelers can assess the correctness of their models before generating code from them. The verification of system requirements is shown using a case study of an infusion pump. This paper discusses issues involved in integrating model checkers into DMOSES and reports on a performance evaluation of two model checkers in particular: NuSMV and UPPAAL", "num_citations": "4\n", "authors": ["315"]}
{"title": "A software architectural approach to security by design\n", "abstract": " This paper shows how an architecture description notation that has support for timed events can be used to provide a meta-language for specifying exact communication semantics. The advantages of such an approach is that a designer is made fully aware of the ramifications of her design choices so that an attacker can no longer take advantage of hidden assumptions", "num_citations": "4\n", "authors": ["315"]}
{"title": "An integrated framework for scenarios and state machines\n", "abstract": " This paper develops a semantic framework for interpreting heterogeneous system specifications consisting of a mixture of scenario-based requirements and state-based design. Such specifications arise naturally in spiral- and refinement-based development methodologies in which parts of a system have detailed designs while others exist in more abstract form as a collection of requirements. More precisely, we consider the scenario-based notation of Triggered Message Sequence Charts (TMSCs) and the state-based notation of Communicating State Machines (CSMs), and show how they may be integrated in a semantic framework that is founded on the mathematical theory of acceptance trees. Our semantic theory is also equipped with a robust notion of refinement, which allows us to relate one heterogeneous specification with another. A case-study serves to illustrate the utility of our framework as a\u00a0\u2026", "num_citations": "4\n", "authors": ["315"]}
{"title": "An algebraic theory of boundary crossing transitions\n", "abstract": " This paper gives a process-algebraic semantics for the hierarchical state machine (HSM) fragment of Statecharts, in which state transitions are permitted to cross state boundaries. Although frowned upon by researchers as promoting unstructured modeling, such transitions are used extensively in practice to model parameterized start states and conditional exit states. The purpose of this work is to develop a compositional semantics for HSMs that may be fit together with compositional semantic accounts for Statecharts without boundary-crossing transitions in order to arrive at a compositional theory for virtually the whole Statecharts language. Our technical development consists of a process algebra for HSMs that is equipped with an operational semantics, an argument that bisimulation is a congruence for the algebra, a syntax-directed translation procedure for HSMs into the process algebra, and an equational\u00a0\u2026", "num_citations": "4\n", "authors": ["315"]}
{"title": "Hypermedia: Openness, Structural Awareness, and Adaptivity: International Workshops OHS-7, SC-3, and AH-3, Aarhus, Denmark, August 14-18, 2001. Revised Papers\n", "abstract": " This book presents the joint post-proceedings of three International Workshops held as part of the 12th ACM Conference on Hypertext and Hypermedia in Aarhus, Denmark in August 2001. The 28 revised full papers presented were carefully refereed and selected during two rounds of reviewing and revision. In accordance with the workshop topics, the papers are organized in sections on open hypermedia systems, structural computing, and adaptive hypermedia.", "num_citations": "4\n", "authors": ["315"]}
{"title": "Branching-Time Probabilistic Model Checking\u00a3\n", "abstract": " This paper presents a probabilistic semantics for the alternation-free modal mu-calculus. This semantics precisely defines the probability with which a system that includes a mixture of probabilistic and nondeterministic choices satisfies a formula in the logic. An algorithm for computing these probabilities is also given.", "num_citations": "4\n", "authors": ["315"]}
{"title": "Tools and Algorithms for Construction and Analysis of Systems\n", "abstract": " This volume contains the proceedings of the fifth international meeting on Tools and Algorithms for the Construction and Analysis of Systems (TACAS\u201999). TACAS\u201999 took place on 22\u201325 March 1999 in Amsterdam as a constituent conference of the European Joint Conferences on Theory and Practice of Software (ETAPS). More information about it may be found in the foreword. Previous TACAS meetings occurred in 1998 (Lisbon), 1997 (Twente), 1996 (Passau), and 1995 (Aarhus). Like TACAS\u201998, TACAS\u201999 was a conference, while the meetings before 1998 were workshops. All previous TACAS proceedings have been published as volumes in Springer\u2019s Lecture Notes in Computer Science series. TACAS\u2019s mission is to provide a forum for researchers, developers and users interested in rigorously based tools for the construction and analysis of systems. The conference aims to bridge the gaps between different communities\u2014including but not limited to those devoted to formal methods, real-time, software engineering, communications protocols, hardware, theorem proving, and programming languages\u2014that have traditionally had little interaction but share common interests in and techniques for tool development. In particular, by providing a venue for the discussion of common problems, heuristics, algorithms, data structures and methodologies, TACAS hopes to support researchers in their quest to improve the utility, reliability, flexibility and efficiency of tools for building systems.These proceedings contain an invited paper, 28 refereed contributions, a position statement, and the text of an ETAPS tool demonstration that was reviewed\u00a0\u2026", "num_citations": "4\n", "authors": ["315"]}
{"title": "Query checking for linear temporal logic\n", "abstract": " The query-checking problem for temporal logic may be formulated as follows. Given a Kripke structure M and a temporal-logic query of form , which may be thought of as a temporal formula with a missing propositional subformula , find the most precise propositional formula f that, when substituted for  in , ensures M satisfies the resulting temporal property. Query checking has been used for system comprehension, specification reconstruction, and other related applications in the formal analysis of systems.                 In this paper we present an automaton-based methodology for query checking over linear temporal logic (LTL). While this problem is known to be hard in the general case, we show that by exploiting several key observations about the interplay between the input model M and the query , we can produce results for many problems of interest. In support of this claim, we\u00a0\u2026", "num_citations": "3\n", "authors": ["315"]}
{"title": "Architecturebased Static Analysis of Medical Device Software: Initial Results\n", "abstract": " New research is underway at the FDA to investigate the benefits of integrating architecture analysis into safety evaluations of medical-device software. Due to the complexity in setting up testing environments for such software, the FDA is unable to conduct large-scale safety testing; instead, it must rely on other techniques to build an argument for whether the software is safe or not. The preliminary architecture analysis approach discussed in this paper is based on reconstructing abstract, yet precise, architectural views from source code to help build such arguments about safety. This paper discusses the use of the approach to analyze the Computer-Assisted Resuscitation Algorithm (CARA) software, which controls an infusion pump designed to provide automated assistance for transfusing blood. The initial results suggest that architectural analysis results can be used to help configure static analysis tools to improve\u00a0\u2026", "num_citations": "3\n", "authors": ["315"]}
{"title": "Model-based verification of automotive control software\n", "abstract": " This talk will report on the use of an approach, called Instrumentation Based Verification, for checking the correctness of models of control software given in Simulink\u00ae and Stateflow\u00ae. In IBV, engineers formalize requirements as so-called monitor models, whose purpose is to search executions of the main controller model for violations of required behavior. Testing is then performed on the instrumented controller model in order to check for the possibility of deviations between controller and requirements. Tools such as Reactis\u00ae provide automated support for conducting these activities, and the technique has attracted interest in automotive, aerospace and medical-device settings. The presentation will first review model-based development and IBV and their industrial motivations. It will then report on a project between the Fraunhofer Center for Experimental Software Engineering and a major automotive\u00a0\u2026", "num_citations": "3\n", "authors": ["315"]}
{"title": "A Theory of Efficiency for Markovian Processes\n", "abstract": " We present a testing theory for Markovian processes based on a quantification of the probability with which they pass tests within a given amount of time, in order to establish in this setting a notion of process efficiency which may be useful for the analysis of soft real time systems. The Markovian testing theory is developed for continuous time processes, discrete time processes, and mixed processes where the duration of an action can be either exponentially distributed or zero. Our Markovian testing theory is shown to enjoy close connections with the classical testing theory of De Nicola-Hennessy and the probabilistic testing theory of Cleaveland-Smolka et al. The relationship between the induced Markovian testing equivalence and the Markovian bisimulation equivalence is also presented.In order to ease the task of establishing testing related relationships between Markovian processes, a fully abstract alternative characterization of our Markovian testing preorder is developed which is based on extended traces. A proof technique is derived from such an alternative characterization. It is also demonstrated that our Markovian testing equivalence, which is based on the (easier to work with) probability of executing a successful computation whose average duration is not greater than a given amount of time, coincides with the Markovian testing equivalence based on the (more intuitive) probability of reaching success within a given amount of time.", "num_citations": "3\n", "authors": ["315"]}
{"title": "An operational semantics of value passing\n", "abstract": " This paper develops an operational semantics for concurrent languages with value passing. An operation analogous to substitution in the-calculus is given, and an operational equivalence is de ned and shown to coincide with Milner's bisimulation equivalence. In contrast with existing process-algebraic approaches to value passing, this semantics does not reduce data exchange to pure synchronization over (potentially in nite) families of ports indexed by data.", "num_citations": "3\n", "authors": ["315"]}
{"title": "CONCUR'91: 2nd International Conference on Concurrency Theory, Amsterdam, The Netherlands, August 26-29, 1991. Proceedings\n", "abstract": " CONCUR'91 is the second international conference on concurrency theory, organized in association with the NFI project Transfer. It is a sequel to the CONCUR'90 conference. Its basic aim is to communicate ongoing work in concurrency theory. This proceedings volume contains 30 papers selected for presentation at the conference (from 71 submitted) together with four invited papers and abstracts of the other invited papers. The papers are organized into sections on process algebras, logics and model checking, applications and specification languages, models and net theory, design and real-time, tools and probabilities, and programming languages. The proceedings of CONCUR'90 are available asVolume 458 of Lecture Notes in Computer Science.", "num_citations": "3\n", "authors": ["315"]}
{"title": "By the PRL Group\n", "abstract": " CiteSeerX \u2014 By the PRL Group: Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA By the PRL Group: (1985) Cached Download as a PDF Download Links [www.cs.cornell.edu] [www.cs.cornell.edu] Save to List Add to Collection Correct Errors Monitor Changes by RL Constable , SF Allen , HM Bromley , WR Cleaveland , JF Cremer , RW Harper , DJ Howe , TB Knoblock , NP Mendler , P. Panangaden , JT Sasaki , SF Smith Citations: 1 - 0 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases prl group Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us Developed at and hosted by The College of \u00a9 -\u2026", "num_citations": "3\n", "authors": ["315"]}
{"title": "Temporal-logic query checking over finite data streams\n", "abstract": " This paper describes a technique for solving temporal-logic queries over finite sets of finite-length data streams. Such data streams arise in many domains, including server logs, program testing, and financial and marketing data; temporal-logic formulas that are satisfied by all data streams in a set can provide insight into the underlying dynamics of the system generating the streams. Our approach to finding such formulas involves queries, or formulas that include an unknown, given in a variant of Linear Temporal Logic (LTL). Solving such a query involves computing all propositional formulas that, when substituted for the unknown in the query, yield an LTL formula satisfied by all data streams in the set. We give an automaton-based approach to solving these queries and demonstrate a working implementation via a pilot study.", "num_citations": "2\n", "authors": ["315"]}
{"title": "Programming is modeling\n", "abstract": " This paper considers the relationship between modeling and programming in the context of embedded-software development. In this domain, design and development techniques such as model-based development and model-driven design are often used to improve the efficiency with which software is produced and to broaden the class of engineers who can develop it. This has led some to suggest that modeling has become, or is becoming, programming. The argument advanced in this paper is that the converse is in fact true: programming should rather be considered a form of modeling, with the programming language constituting an executable metalanguage in which models of dynamical systems are encoded and simulated, or \u201crun\u201d. Modeling instead plays a design role, with some models used as a basis for the generation of code, although this is not a requirement: models for which code cannot be\u00a0\u2026", "num_citations": "2\n", "authors": ["315"]}
{"title": "Improving invariant mining via static analysis\n", "abstract": " This paper proposes the use of static analysis to improve the generation of invariants from test data extracted from Simulink models. Previous work has shown the utility of such automatically generated invariants as a means for updating and completing system specifications; they also are useful as a means of understanding model behavior. This work shows how the scalability and accuracy of the data mining process can be dramatically improved by using information from data/control flow analysis to reduce the search space of the invariant mining and to eliminate false positives. Comparative evaluations of the process show that the improvements significantly reduce execution time and memory consumption, thereby supporting the analysis of more complex models, while also improving the accuracy of the generated invariants.", "num_citations": "2\n", "authors": ["315"]}
{"title": "An extensible formal semantics for UML activity diagrams\n", "abstract": " This paper presents an operational semantics for UML activity diagrams. The purpose of this semantics is three-fold: to give a robust basis for verifying model correctness; to help validate model transformations; and to provide a well-formed basis for assessing whether a proposed extension/interpretation of the modeling language is consistent with the standard. The challenges of a general formal framework for UML models include the semi-formality of the semantics specification, the extensibility of the language, and (sometimes deliberate, sometimes accidental) under-specification of model behavior in the standard. Our approach is based on structural operational semantics, which can be extended according to domain-specific needs. The presented semantics has been implemented and tested.", "num_citations": "2\n", "authors": ["315"]}
{"title": "Data Structure Choices for On-the-Fly Model Checking of Real-Time Systems\n", "abstract": " This paper studies the performance of sparsematrix-based data structures to represent clock zones (convex sets of clock values) in an on-the-fly predicate equation system model checker for timed automata. We analyze the impact of replacing the dense difference bound matrix (DBM) with both the linked-list CRDZone and array-list CRDArray data structure. From analysis on the pairedexample-by-example differences in time performance, we infer the DBM is either competitive with or slightly faster than the CRDZone, and both perform faster than the CRDArray. Using similar analysis on space performance, we infer the CRDZone takes the least space, and the DBM takes less space than the CRDArray.", "num_citations": "2\n", "authors": ["315"]}
{"title": "Model based verification and validation of distributed control architectures\n", "abstract": " This paper describes a framework for modeling and validating distributed real-time embedded control systems. The modeling component of the framework combines executable architectural specifications with component models in notations such as Simulink and Stateflow to yield simulate-able models of distributed systems. The paper then discusses techniques for comparing the behavior of these system models with idealized control specifications given in Simulink/Stateflow. The framework is intended to support design processes in which a controls engineer develops a controller model that is then used as a specification by a system-engineering team responsible for a system model that may involve deployment-platform details.", "num_citations": "2\n", "authors": ["315"]}
{"title": "Temporal process logic\n", "abstract": " Abstract of Invited Talk               Research in the specification and verification of concurrent systems falls into two general categories. The temporal logic school advocates temporal logic as a language for formulating system requirements, with the semantics of the logic being used as a basis for determining whether or not a system is correct. The process-algebraic community focuses on the use of \u201chigher-level\u201d system descriptions as specifications of \u201clower-level\u201d ones, with a refinement relation being used to determine whether an implementation conforms to a specification. From a user\u2019s perspective, the approaches offer different benefits and drawbacks. Temporal logic supports \u201cscenario-based\u201d specifications, since formulas may be given that focus on single aspects of system behavior. On the other hand, temporal logic specifications suffer from a lack of compositionality, since the language of specifications differs\u00a0\u2026", "num_citations": "2\n", "authors": ["315"]}
{"title": "The role of observations in probabilistic open systems\n", "abstract": " This paper considers a logic, based on the modal mu-calculus, for describing properties of probabilistic open distributed systems and develops a model-checking algorithm for determining whether or not states in finite-state probabilistic systems satisfy formulas in the logic. The central contribution of the paper is a semantics that distinguishes between observations, the meaning of a temporal formula, and its measure. The ensuing model-checking problem reduces to the calculation of a (particular) solution to a system of non-linear equations.", "num_citations": "2\n", "authors": ["315"]}
{"title": "The Concurrency Workbench of North Carolina, Version 1.11-User's Manual\n", "abstract": " This document describes how to use a particular automatic verification tool: The Concurrency Workbench of North Carolina (CWB-NC)[9, 11]. The CWB-NC provides support for automatically answering the verification question: does system sys satisfy specification spec? To implement such a tool, the verification question must be formulated more carefully by fixing the following:", "num_citations": "2\n", "authors": ["315"]}
{"title": "Semantic theories and system design\n", "abstract": " This note proposes three areas that concurrency-theoretic research could fruitfully expand on in the future. The first involves the development of a framework for integrating different semantic theories. The second concerns exploring links between theories of concurrency on one hand and programming and design notations on the other. The final one revolves around the use of semantic theories in general as a rigorous basis for software engineering.", "num_citations": "2\n", "authors": ["315"]}
{"title": "Formality and software design\n", "abstract": " This note proposes three areas that software-oriented formal methods research could fruitfully expand on in the future. The first involves the study of formal yet easily undestood models of software that are amenable to automated analysis. The second concerns investigations into the appropriate incorporation of formal reasoning into the software design process. The final one revolves around approaches to incorporating more formal-methods material into undergraduate and graduate computing curricula.", "num_citations": "2\n", "authors": ["315"]}
{"title": "The process algebra compiler of north carolina\n", "abstract": " This document explains how to use the Process Algebra Compiler of North Carolina (PACNC) a tool that eases the task of changing the speci cation language accepted by the Concurrency Workbench of North Carolina (CWB-NC) 3, 2], a process-algebra-based veri cation tool. Like its predecessor, the Edinburgh Concurrency Workbench 1], the CWB-NC allows the user to describe a concurrent system in a design language such as CCS 4] and analyze the behavior of the system with di erent methods such as equivalence checking, preorder checking, model checking, or random simulation. The CWB-NC is designed in a modular fashion so that the analysis routines are not dependent on the speci c input language that the tool accepts. Therefore, changing the input language that the tool accepts is feasable; however, doing so is a tedious and time-consuming task. The PAC-NC greatly simpli es this job. Figure 1 shows that given a high-level description of the syntax and semantics of a speci cation language, the PAC-NC generates Standard ML source code implementing an interface which allows the CWB-NC to analyze systems speci ed in the new language.", "num_citations": "2\n", "authors": ["315"]}
{"title": "An algebraic theory of distributed real-time\n", "abstract": " This paper develops a real-time process algebra, TPLmc, for modeling and reasoning about distributed real-time systems. Like the algebra PMC, TPLmc includes operators for binding processes to di erent clocks; unlike PMC, however, TPLmc includes a version of the maximal progress assumption. Using simple examples, we motivate why these features are useful and in some cases necessary for modeling and verifying distributed systems; we also present a behavioral congruence based on Milner's observational equivalence and develop logical characterizations of the behavioral relations.", "num_citations": "2\n", "authors": ["315"]}
{"title": "A tool for modeling and verifying real-time systems\n", "abstract": " This paper describes a modeling and verification environment for real-time systems. The environment supports both a graphical design language (Modechart) and a textually based one (Temporal CCS) and implements different methodologies, including simulation, system minimization, and equivalence checking, for analyzing systems. The tool has been applied to the verification of active structural control systems.", "num_citations": "2\n", "authors": ["315"]}
{"title": "Towards Automated Comprehension and Alignment of Cardiac Models at the System Invariant Level\n", "abstract": " The study of cardiac arrhythmias has spurred the development of models across a variety of formulations and scales and designed for different purposes, each with distinct configuration spaces. Nevertheless, these models should be able to exhibit equivalent behavior when their contexts overlap. Configuring models to both support this context equivalence and still exhibit intended behavioral characteristics can be challenging. Due to the complexity of this problem, automation can be desirable. We present a framework aimed at automating the comprehension and alignment of cardiac model behaviors. For model comprehension, we mine a set of properties (invariants) that a model with given configuration will exhibit when executed. Comprehension can be extended to model alignment: we perform comprehension of one model, and then mine a set of configurations for a second, each of which produces invariants\u00a0\u2026", "num_citations": "1\n", "authors": ["315"]}
{"title": "A tableau construction for finite linear-time temporal logic\n", "abstract": " This paper describes a method for converting formulas in finite propositional linear-time temporal logic (Finite LTL) into finite-state automata whose languages are the models of the given formula. Finite LTL differs from traditional LTL in that formulas are interpreted with respect to finite, rather than infinite, sequences of states; this fact means that traditional finite-state automata, rather than {\\omega}-automata such as those developed by B\\\"uchi and others, suffice for recognizing models of such formulas. The approach considered is based on well-known tableau-construction techniques developed for LTL, which we adapt here for the setting of Finite LTL. The resulting automata may be used as a basis for model checking, satisfiability testing, and model synthesis.", "num_citations": "1\n", "authors": ["315"]}
{"title": "Bisimulation in behavioral dynamical systems and generalized synchronization trees\n", "abstract": " In this paper, we describe a method for representing a behavioral dynamical system as a Generalized Synchronization Tree (GST). The method of representation we propose is analogous to the \u201cunrolling\u201d of a Labeled Transition System (LTS) into a bisimilar Synchronization Tree (ST). Thus, for behavioral systems endowed with state maps, we are able to establish conditions under which bisimilar behavioral systems result in bisimilar GST representations and conversely. Preservation of bisimulation equivalence is critical to future study of composition operators for behavioral systems and GSTs. Additionally, we define a composition operator for GSTs constructed from behavioral systems, and prove a congruence result for strong bisimulation.", "num_citations": "1\n", "authors": ["315"]}
{"title": "Automated Specification Extraction and Analysis with Specstractor\n", "abstract": " This paper presents Specstractor, a tool chain for the extraction and analysis of system specifications in the form of collections of invariants. Such invariants convey valuable information about the behavior of a software system and are also useful in identifying missing or defective parts of existing specifications. Using data-mining techniques, Specstractor derives likely invariants from test data that it automatically generates from the system under analysis, using an iterative approach to refine the set of proposed invariants and eliminate false positives. The paper describes the Spectstractor technology and evaluates it on real-world artifacts from automotive-control and medical-device applications.", "num_citations": "1\n", "authors": ["315"]}
{"title": "Functional and Nonfunctional Design Verification for Embedded Software Systems\n", "abstract": " In model-based design verification, software models are checked against functional and nonfunctional requirements. Many of the mathematically well-founded theories developed for functional verification suffer from limitations (poor integration with industrial modeling tools and inability to scale to larger, more complicated systems) that restrict their practical adoption. Nonfunctional verification approaches, because of their inherent subjectivity (\u201cwhat does it mean for a system to be modifiable?\u201d), remain largely ad hoc and manual. There is also another overarching problem in that functional and nonfunctional verification take place on widely different representations of the system making it difficult to ensure that these representations are consistent with each other. This chapter highlights the latest research done into (1) a practical, formal, coverage-based functional verification approach called instrumentation-based\u00a0\u2026", "num_citations": "1\n", "authors": ["315"]}
{"title": "Integrated Functional and Non-Functional Design Verification for Embedded Software Systems\n", "abstract": " This paper describes an approach to integrating functional and non-functional design verification for embedded control software. The method uses functional models, which have traditionally been used in functional verification processes, to drive non-functional verification also. This is achieved by defining strategies for extracting non-functional models, which contain structural and quantitative information about nonfunctional characteristics such as performance and modifiability, from functional ones. Non-functional verification tools may then be used on the resulting models to check that desired non-functional properties, such as ease of modification, are catered for in the design. An extended example involving the analysis of a model for modifiability is presented, as is tool support for extracting non-functional models from functional ones.", "num_citations": "1\n", "authors": ["315"]}
{"title": "Secure requirements elicitation through triggered message sequence charts\n", "abstract": " This paper argues for performing information-flow-based securityanalysis in the first phase of the software development life cycle itself ie in the requirements elicitation phase. Message Sequence Charts (MSC)s have been widely accepted as a formal scenario-based visual notation for writing down requirements. In this paper, we discuss a method for checking if a TMSC (Triggered Message Sequence Chart), a recently propsed enhancement to classical MSCs, satisifes one of the most important information flow properties namely non-interference.", "num_citations": "1\n", "authors": ["315"]}
{"title": "Preface by the section editor\n", "abstract": " The papers in this special section present a sampling of new symbolic approaches for determining whether or not a system satisfies its specification. Abstracts of these articles appeared originally in the Proceedings of the 1999 Symposium on Tools and Algorithms for the Construction and Analysis of Systems (TACAS \u201999).", "num_citations": "1\n", "authors": ["315"]}
{"title": "On Full Abstractness for Fair Testing\n", "abstract": " Fair-testing preorders were introduced in 13, 3] in order to overcome di culties that traditional testing/failures preorders have in tackling divergent behavior. This paper establishes the appropriateness and\\optimality\" of the fair-must precongruence by proving that it is the coarsest precongruence respecting a natural notion of observable behavior (maximal traces) under a non-catastrophic interpretation of divergence. This result follows from a new and elegant characterization of fair-must preorder.", "num_citations": "1\n", "authors": ["315"]}
{"title": "Formal Timing Analysis for Fault-Tolerant Active Structural Control Systems\n", "abstract": " This paper presents the results of a case study involving the use of a formal graphical notation, Modechart, and an automatic veri cation tool, the Concurrency Workbench, to the analysis of the design of a fault-tolerant active structural control system. Such control systems must satisfy strict requirements on their timing behavior; we show how to use various features supported by the Workbench to examine the timing behavior of di erent design alternatives, one of which has in excess of 1019 states. The simple techniques illustrated here may be used by systems designers to model and analyze other large and complex real-time systems as well.", "num_citations": "1\n", "authors": ["315"]}
{"title": "A generalized approach to real-time schedulability analysis\n", "abstract": " A generalized approach to real-time schedulability analysis | IEEE Real-Time Systems Newsletter ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search IEEE Real-Time Systems Newsletter Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsIEEE Real-Time Systems NewsletterVol. , No. -2A generalized approach to real-time schedulability analysis article A generalized approach to real-time schedulability analysis Share on Authors: Andre Norman Fredette profile image Andre N. Fredette View Profile , Rance W Cleaveland profile image Rance Cleaveland View Profile Authors Info & Affiliations Publication: IEEE Real-Time Systems NewsletterMarch 0! /\u2026", "num_citations": "1\n", "authors": ["315"]}
{"title": "Type Theory and Concurrency\n", "abstract": " The burgeoning interest in concurrent computation has sparked an increased  interest in theoretical models of concurrency. While standard sequential  programming has a well-understood semantics and proof theory, the  nondeterministic nature of concurrency has made a similar understanding of  concurrent programming extremely difficult. Much interesting work in the  field has been done, and much remains yet to be done; it is our intention in  this paper to present a different kind of model of concurrency, a  type-theoretic one, which we hope will shed light on reasoning about  concurrency. We encode the synchronization tree model of Milner's CCS as a type in the  Nuprl Type Theory. This is a constructive type theory equipped with a rich  collection of inference rules for reasoning about types. We relate the  equality in the type of synchronization trees with various behavioral  equivalences. We also discuss the relation between the logic induced by our  models and various modal logics for reasoning about concurrency.", "num_citations": "1\n", "authors": ["315"]}