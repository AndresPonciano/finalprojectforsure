{"title": "Generating range fixes for software configuration\n", "abstract": " To prevent ill-formed configurations, highly configurable software often allows defining constraints over the available options. As these constraints can be complex, fixing a configuration that violates one or more constraints can be challenging. Although several fix-generation approaches exist, their applicability is limited because (1) they typically generate only one fix, failing to cover the solution that the user wants; and (2) they do not fully support non-Boolean constraints, which contain arithmetic, inequality, and string operators. This paper proposes a novel concept, range fix, for software configuration. A range fix specifies the options to change and the ranges of values for these options. We also design an algorithm that automatically generates range fixes for a violated constraint. We have evaluated our approach with three different strategies for handling constraint interactions, on data from five open source projects\u00a0\u2026", "num_citations": "118\n", "authors": ["1527"]}
{"title": "Feature model mining\n", "abstract": " Software systems have grown larger and more complex in recent years.  Generative software development strives to automate software development from a systems family by generating implementations using domain-specific languages.  In current practice, specifying domain-specific languages is a manual task requiring expert analysis of multiple information sources. Furthermore, the concepts and relations represented in a language are grown through its usage.  Keeping the language consistent with its usage is a time-consuming process requiring manual comparison between the language instances and its language specification. Feature model mining addresses these issues by synthesizing a representative model bottom-up from a sample set of instances called configurations.  This thesis presents a mining algorithm that reverse-engineers a probabilistic feature model from a set of individual configurations. A configuration consists of a list of features that are defined as system properties that a stakeholder is interested in. Probabilistic expressions are retrieved from the sample configurations through the use of conjunctive and disjunctive association rule mining. These expressions are used to construct a probabilistic feature model.     The mined feature model consists of a hierarchy of features, a set of additional hard constraints and soft constraints. The hierarchy describes the dependencies and alternative relations exhibited among the features. The additional hard constraints are a set of propositional formulas which must be satisfied in a legal configuration. Soft constraints describe likely defaults or common patterns.   Systems families are\u00a0\u2026", "num_citations": "16\n", "authors": ["1527"]}
{"title": "Feature model synthesis\n", "abstract": " Variability provides the ability to adapt and customize a software system's artifacts for a particular context or circumstance.  Variability enables code reuse, but its mechanisms are often tangled within a software artifact or scattered over multiple artifacts. This makes the system harder to maintain for developers, and harder to understand for users that configure the software.  Feature models provide a centralized source for describing the variability in a software system. A feature model consists of a hierarchy of features\u2014the common and variable system characteristics\u2014with constraints between features.  Constructing a feature model, however, is a arduous and time-consuming manual process.  We developed two techniques for feature model synthesis.  The first, Feature-Graph-Extraction, is an automated algorithm for extracting a feature graph from a propositional formula in either conjunctive normal form (CNF), or disjunctive normal form (DNF). A feature graph describes all feature diagrams that are complete with respect to the input. We evaluated our algorithms against related synthesis algorithms and found that our CNF variant was significantly faster than the previous comparable technique, and the DNF algorithm performed similarly to a comparable, but newer technique, with the exception of several models where our algorithm was faster.  The second, Feature-Tree-Synthesis, is a semi-automated technique for building a feature model given a feature graph. This technique uses both logical constraints and text to address the most challenging part of feature model synthesis\u2014constructing the feature hierarchy\u2014by ranking potential parents of a\u00a0\u2026", "num_citations": "15\n", "authors": ["1527"]}
{"title": "The Software Architecture of the GIMP\n", "abstract": " In this paper, we examine the architecture of the GNU Image Manipulation Program (GIMP) from two separate points of view. We begin by constructing a conceptual architecture using available developer documentation. We then describe the GIMP\u2019s control flow based on our conceptual architecture and describe how the architecture allows for the extensibility of the GIMP.The conceptual architecture is then compared to the concrete architecture, the architecture defined by the implementation of the system. We present a landscape diagram as a visual representation of the GIMP\u2019s concrete architecture. Our analysis decomposes the concrete architecture into major top-level components and provides a sub-architectural analysis of the GIMP Core.", "num_citations": "5\n", "authors": ["1527"]}
{"title": "Retrieving Sequence Diagrams from Aspect-Oriented Systems\n", "abstract": " Aspect-oriented programming is built on the concept of separating concerns. While separation of concerns reduces textual scattering and tangling by encapsulating concerns within a localised module, the behaviour of an aspect-oriented program becomes scattered. Capturing the sequential behaviour of an aspect-oriented program is essential for the validation of the program\u2019s run-time semantics.SequenceRetriever, a tool for retrieving UML sequence diagrams during the execution of a program is presented. The SequenceRetriever tool is built on top of an extensible framework which facilitates the development of additional trace components and diagram types. An AspectJ trace component and an Eclipse TPTP trace component is implemented. Using the two trace components, sequence diagrams of several programs is presented. A comparison between the AspectJ and TPTP sequence diagrams reveal the ajc weaver implementation of several aspect-oriented constructs.", "num_citations": "1\n", "authors": ["1527"]}