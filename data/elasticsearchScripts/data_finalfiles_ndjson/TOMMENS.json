{"title": "A survey of software refactoring\n", "abstract": " We provide an extensive overview of existing research in the field of software refactoring. This research is compared and discussed based on a number of different criteria: the refactoring activities that are supported, the specific techniques and formalisms that are used for supporting these activities, the types of software artifacts that are being refactored, the important issues that need to be taken into account when building refactoring tool support, and the effect of refactoring on the software process. A running example is used to explain and illustrate the main concepts.", "num_citations": "1609\n", "authors": ["106"]}
{"title": "A taxonomy of model transformation\n", "abstract": " This article proposes a taxonomy of model transformation, based on the discussions of a working group on model transformation of the Dagstuhl seminar on Language Engineering for Model-Driven Software Development. This taxonomy can be used, among others, to help developers in deciding which model transformation language or tool is best suited to carry out a particular model transformation activity.", "num_citations": "1448\n", "authors": ["106"]}
{"title": "A state-of-the-art survey on software merging\n", "abstract": " Software merging is an essential aspect of the maintenance and evolution of large-scale software systems. This paper provides a comprehensive survey and analysis of available merge approaches. Over the years, a wide variety of different merge techniques has been proposed. While initial techniques were purely based on textual merging, more powerful approaches also take the syntax and semantics of the software into account. There is a tendency towards operation-based merging because of its increased expressiveness. Another tendency is to try to define merge techniques that are as general, accurate, scalable, and customizable as possible, so that they can be used in any phase in the software life-cycle and detect as many conflicts as possible. After comparing the possible merge techniques, we suggest a number of important open problems and future research directions.", "num_citations": "685\n", "authors": ["106"]}
{"title": "Software Evolution\n", "abstract": " Software has become omnipresent and vital in our information-based society, so all software producers should assume responsibility for its reliability. While \"reliable\" originally assumed implementations that were effective and mainly error-free, additional issues like adaptability and maintainability have gained equal importance recently. For example, the 2004 ACM/IEEE Software Engineering Curriculum Guidelines list software evolution as one of ten key areas of software engineering education. Mens and Demeyer, both international authorities in the field of software evolution, together with the invited contributors, focus on novel trends in software evolution research and its relations with other emerging disciplines such as model-driven software engineering, service-oriented software development, and aspect-oriented software development. They do not restrict themselves to the evolution of source code but also address the evolution of other, equally important software artifacts such as databases and database schemas, design models, software architectures, and process management. The contributing authors provide broad overviews of related work, and they also contribute to a comprehensive glossary, a list of acronyms, and a list of books, journals, websites, standards and conferences that together represent the community\u2019s body of knowledge. Combining all these features, this book is the indispensable source for researchers and professionals looking for an introduction and comprehensive overview of the state of the art. In addition, it is an ideal basis for an advanced course on software evolution.", "num_citations": "488\n", "authors": ["106"]}
{"title": "Towards a taxonomy of software change\n", "abstract": " Previous taxonomies of software change have focused on the purpose of the change (i.e., the why) rather than the underlying mechanisms. This paper proposes a taxonomy of software change based on characterizing the mechanisms of change and the factors that influence these mechanisms. The ultimate goal of this taxonomy is to provide a framework that positions concrete tools, formalisms and methods within the domain of software evolution. Such a framework would considerably ease comparison between the various mechanisms of change. It would also allow practitioners to identify and evaluate the relevant tools, methods and formalisms for a particular change scenario. As an initial step towards this taxonomy, the paper presents a framework that can be used to characterize software change support tools and to identify the factors that impact on the use of these tools. The framework is evaluated by\u00a0\u2026", "num_citations": "406\n", "authors": ["106"]}
{"title": "Identifying refactoring opportunities using logic meta programming\n", "abstract": " We show how automated support can be provided for identifying refactoring opportunities, e.g., when an application's design should be refactored and which refactoring(s) in particular should be applied. Such support is achieved by using the technique of logic meta programming to detect so-called bad smells and by defining a framework that uses this information to propose adequate refactorings. We report on some initial but promising experiments that were applied using the proposed techniques.", "num_citations": "245\n", "authors": ["106"]}
{"title": "Analysing refactoring dependencies using graph transformation\n", "abstract": " Refactoring is a widely accepted technique to improve the structure of object-oriented software. Nevertheless, existing tool support remains restricted to automatically applying refactoring transformations. Deciding what to refactor and which refactoring to apply still remains a difficult manual process, due to the many dependencies and interrelationships between relevant refactorings. In this paper, we represent refactorings as graph transformations, and we propose the technique of critical pair analysis to detect the implicit dependencies between refactorings. The results of this analysis can help the developer to make an informed decision of which refactoring is most suitable in a given context and why. We report on several experiments we carried out in the AGG graph transformation tool to support our claims.", "num_citations": "213\n", "authors": ["106"]}
{"title": "Detecting and resolving model inconsistencies using transformation dependency analysis\n", "abstract": " Model inconsistency management is a crucial aspect of model-driven software engineering. It is therefore important to provide automated support for this activity. The problem is, however, that the resolution of inconsistencies may give rise to new inconsistencies. To address this problem, we propose to express inconsistency detection and resolutions as graph transformation rules, and to apply the theory of critical pair analysis to analyse potential dependencies between the detection and resolution of model inconsistencies. As a proof-of-concept, we report on an experiment that we have carried out along these lines using the critical pair analysis algorithm implemented in the state-of-the-art graph transformation tool AGG. The results show that both anticipated and unexpected dependencies between inconsistency detection and resolution rules are found by AGG. We discuss how the integration of the\u00a0\u2026", "num_citations": "164\n", "authors": ["106"]}
{"title": "On the use of graph transformations for model refactoring\n", "abstract": " Model-driven software engineering promotes the use of models and transformations as primary artifacts. Several formalisms can be used for the specification of model transformations. We propose to represent models as graphs, and model transformations as graph transformations. In particular, we focus on the activity of model refactoring, and show how graph transformation theory can provide formal support for this activity. We also show how such support can be implemented in state-of-the-art graph transformation tools such as AGG and Fujaba, and provide two concrete experiments. Critical pair analysis in AGG enables the analysis of dependencies between model refactorings. The round-trip engineering facility of Fujaba enables the automatic generation of code for model refactorings.", "num_citations": "137\n", "authors": ["106"]}
{"title": "Towards a taxonomy of software evolution\n", "abstract": " Previous taxonomies of software evolution have focused on the purpose of the change (ie, the why) rather than the underlying mechanisms. This paper proposes a taxonomy of software evolution based on the characterizing mechanisms of change and the factors that influence these mechanisms. The taxonomy is organized into the following logical groupings: temporal properties, objects of change, system properties, and change support.The ultimate goal of this taxonomy is to provide a framework that positions concrete tools, formalisms and methods within the domain of software evolution. Such a framework would considerably ease comparison between these tools, formalisms and methods. It would also allow practitioners to evaluate their potential use in particular change scenarios. As an initial step towards this taxonomy, the paper presents a framework that can be used to characterize software change support tools and to identify the factors that impact on the use of these tools. The framework is evaluated by applying it to three different change support tools and by comparing these tools based on this analysis.", "num_citations": "116\n", "authors": ["106"]}
{"title": "Challenges in model-driven software engineering\n", "abstract": " After more than a decade of research in Model-Driven Engineering (MDE), the state-of-the-art and the state-of-the-practice in MDE has significantly progressed. Therefore, during this workshop we raised the question of how to proceed next, and we identified a number of future challenges in the field of MDE. The objective of the workshop was to provide a forum for discussing the future of MDE research and practice. Seven presenters shared their vision on the future challenges in the field of MDE. Four breakout groups discussed scalability, consistency and co-evolution, formal foundations, and industrial adoption, respectively. These themes were identified as major categories of challenges by the participants. This report summarises the different presentations, the MDE challenges identified by the workshop participants, and the discussions of the breakout groups.", "num_citations": "112\n", "authors": ["106"]}
{"title": "Detecting structural refactoring conflicts using critical pair analysis\n", "abstract": " Refactorings are program transformations that improve the software structure while preserving the external behaviour. In spite of this very useful property, refactorings can still give rise to structural conflicts when parallel evolutions to the same software are made by different developers. This paper explores this problem of structural evolution conflicts in a formal way by using graph transformation and critical pair analysis. Based on experiments carried out in the graph transformation tool AGG, we show how this formalism can be exploited to detect and resolve refactoring conflicts.", "num_citations": "110\n", "authors": ["106"]}
{"title": "A formal foundation for object-oriented software evolution\n", "abstract": " My PhD thesis claims that the principles behind object-oriented software evolution are independent of a particular domain or phase in the software lifecycle. To validate this claim, a formalism based on graphs and graph rewriting was developed and applied to a particular aspect of software evolution, namely the problem of software upgrading and software merging. When the same piece of software is modified in parallel by different software developers, unexpected inconsistencies can arise. Formal support can be provided to detect and resolve these inconsistencies in a general way.", "num_citations": "106\n", "authors": ["106"]}
{"title": "Measuring software flexibility\n", "abstract": " Flexibility has been recognised as a desirable quality of software since the earliest days of software engineering. Classic and contemporary software design literature suggests that particular implementations are more flexible than others, but stops short of suggesting objective criteria for quantifying such claims. To measure software flexibility in precise terms, we introduce the notion of evolution complexity and demonstrate how it can be used to measure and compare the flexibility of (1) programming paradigms (Object-Oriented against Procedural programs),(2) architectural styles (Shared Data, Pipes and Filters, and Abstract Data Type) and (3) design patterns (Visitor and the Abstract Factory). We also demonstrate how evolution complexity can be used to choose the most flexible design policy. We conclude with experimental results corroborating our claims.", "num_citations": "105\n", "authors": ["106"]}
{"title": "The evolution of Eclipse\n", "abstract": " We present a metrics-based study of the evolution of Eclipse, an open source integrated development environment, based on data from seven major releases, from releases 1.0 to 3.3. We investigated whether three of the laws of software evolution were supported by the data. We found that Eclipse displayed continual change and growth, hence supporting laws 1 and 6. Six size indicators, out of eight, closely followed trend models. Four were linear and two superlinear. We found evidence of increasing complexity (law 2) in only two indicators, out of five. At subproject level, size and complexity are not distributed uniformly, and subproject size can be modelled as a negative exponential function of the rank position. We encountered a range of different size and complexity trends across subprojects. Our approach and results can help in evaluating the future evolution of Eclipse, the evolution of other systems and in\u00a0\u2026", "num_citations": "98\n", "authors": ["106"]}
{"title": "An empirical comparison of dependency network evolution in seven software packaging ecosystems\n", "abstract": " Nearly every popular programming language comes with one or more package managers. The software packages distributed by such package managers form large software ecosystems. These packaging ecosystems contain a large number of package releases that are updated regularly and that have many dependencies to other package releases. While packaging ecosystems are extremely useful for their respective communities of developers, they face challenges related to their scale, complexity, and rate of evolution. Typical problems are backward incompatible package updates, and the risk of (transitively) depending on packages that have become obsolete or inactive. This manuscript uses the libraries.io dataset to carry out a quantitative empirical analysis of the similarities and differences between the evolution of package dependency networks for seven packaging ecosystems of varying sizes and\u00a0\u2026", "num_citations": "95\n", "authors": ["106"]}
{"title": "A comparison of identity merge algorithms for software repositories\n", "abstract": " Software repository mining research extracts and analyses data originating from multiple software repositories to understand the historical development of software systems, and to propose better ways to evolve such systems in the future. Of particular interest is the study of the activities and interactions between the persons involved in the software development process. The main challenge with such studies lies in the ability to determine the identities (e.g., logins or e-mail accounts) in software repositories that represent the same physical person. To achieve this, different identity merge algorithms have been proposed in the past. This article provides an objective comparison of identity merge algorithms, including some improvements over existing algorithms. The results are validated on a selection of large ongoing open source software projects.", "num_citations": "94\n", "authors": ["106"]}
{"title": "Describing the impact of refactoring on internal program quality\n", "abstract": " The technique of refactoring\u2013restructuring the source-code of an object-oriented program without changing its external behavior\u2013has been embraced by many object-oriented software developers as a way to accommodate changing requirements. The overall goal of refactoring is to improve the maintainability of software. Unfortunately, it is unclear how specific quality factors are affected. Therefore, this paper proposes a formalism to describe the impact of a representative number of refactorings on an AST representation of the source code, extended with cross-references. We elicitate how internal program quality metrics can be formally defined on top of this program structure representation, and demonstrate how to project the impact of refactorings on these internal program quality metric values in the form of potential drifts or improvements.", "num_citations": "94\n", "authors": ["106"]}
{"title": "Evolving software architecture descriptions of critical systems\n", "abstract": " 43 MAY 2010 system. The description must also be accurately and traceably linked to the software\u2019s implementation, so that any change to the architecture is reflected directly in the implementation, and vice versa. Otherwise, the architecture description will become rapidly obsolete as the software evolves to accommodate changes. The architecture description must thus be an integral part of the softwareintensive system and its documentation.", "num_citations": "93\n", "authors": ["106"]}
{"title": "Automating support for software evolution in UML\n", "abstract": " Disciplined support for evolution of software artifacts is important in all phases of the software life-cycle. In order to achieve this support, a uniform underlying foundation for software evolution is necessary. While, in the past, reuse contracts have been proposed as such a formalism in a number of different domains, this paper generalises the formalism, and integrates it into the UML metamodel. As such, support for evolution becomes readily available for many kinds of UML models, ranging from requirements to the implementation phase.", "num_citations": "91\n", "authors": ["106"]}
{"title": "An empirical comparison of dependency issues in OSS packaging ecosystems\n", "abstract": " Nearly every popular programming language comes with one or more open source software packaging ecosystem(s), containing a large collection of interdependent software packages developed in that programming language. Such packaging ecosystems are extremely useful for their respective software development community. We present an empirical analysis of how the dependency graphs of three large packaging ecosystems (npm, CRAN and RubyGems) evolve over time. We study how the existing package dependencies impact the resilience of the three ecosystems over time and to which extent these ecosystems suffer from issues related to package dependency updates. We analyse specific solutions that each ecosystem has put into place and argue that none of these solutions is perfect, motivating the need for better tools to deal with package dependency update problems.", "num_citations": "79\n", "authors": ["106"]}
{"title": "A graph-based metamodel for object-oriented software metrics\n", "abstract": " Metrics are essential in object-oriented software engineering for several reasons, among which quality assessment and improvement of development team productivity. While the mathematical nature of metrics calls for clear definitions, frequently there exist many contradicting definitions of the same metric depending on the implementation language. We suggest to express and define metrics using a language-independent metamodel based on graphs. This graph-based approach allows for an unambiguous definition of generic object-oriented metrics and higher-order metrics. We also report on some prototype tools that implement these ideas.We thank Kim Mens, Roel Wuyts and the anonymous reviewers for their comments on drafts of this paper.", "num_citations": "77\n", "authors": ["106"]}
{"title": "Ontology evolution\n", "abstract": " The research area of ontology engineering seems to have reached a certain level of maturity, considering the vast amount of contemporary methods and tools for formalising and applying knowledge representation models. However, there is still little understanding of, and support for, the evolutionary aspects of ontologies. This is particularly crucial in distributed and collaborative settings such as the Semantic Web, where ontologies naturally co-evolve with their communities of use. For managing the evolution of single ontologies, established techniques from data schema evolution have been successfully adopted, and consensus on a general ontology evolution process model seems to emerge. Much less explored, however, is the problem of evolution of interorganisational ontologies. In this \u201ccomplex\u201d and dynamic setting, a collaborative change process model requires more powerful engineering, argumentation\u00a0\u2026", "num_citations": "76\n", "authors": ["106"]}
{"title": "Encapsulation and composition as orthogonal operators on mixins: A solution to multiple inheritance problems\n", "abstract": " In class-based multiple inheritance systems, interpretations as different as duplication, sharing and specialization are associated with the single phenomenon of name collisions. To deal with those name collisions, various mechanisms have been proposed, but these solutions generally restrain software reusability which is considered to be one of the key features of OO systems. On top of this, most multiple inheritance systems do not completely cover all the different interpretations of name collisions. This paper shows that the entire multiple inheritance dilemma can and should be seen as a conflict between inheritance and data encapsulation only. Orthogonalizing these two concepts in a mixin-based framework permits appropriate solutions of all the problems listed above. To this extent a formal model is proposed together with its denotational semantics. This minimal multiple inheritance model establishes a valuable basis for OO languages and software engineering systems.", "num_citations": "70\n", "authors": ["106"]}
{"title": "A formal approach to model refactoring and model refinement\n", "abstract": " Model-driven engineering is an emerging software engineering approach that relies on model transformation. Typical kinds of model transformations are model refinement and model refactoring. Whenever such a transformation is applied to a consistent model, we would like to know whether the consistency is preserved by the transformation. Therefore, in this article, we formally define and explore the relation between behaviour inheritance consistency of a refined model with respect to the original model, and behaviour preservation of a refactored model with respect to the original model. As it turns out, there is a strong similarity between these notions of behaviour consistency and behaviour preservation. To illustrate this claim, we formalised the behaviour specified by UML 2.0 sequence and protocol state machine diagrams. We show how the reasoning capabilities of description logics, a decidable\u00a0\u2026", "num_citations": "68\n", "authors": ["106"]}
{"title": "Language-independent detection of object-oriented design patterns\n", "abstract": " This paper shows that one can reason at a meta level about the structure of object-oriented source code in a language-independent way. To achieve this, we propose a language-independent meta-level interface to extract complex information about the structure of the source code. This approach is validated by defining a set of logic queries to detect object-oriented best practice patterns and design patterns in two different languages: Smalltalk and Java. The queries were applied to two similar medium-sized applications available for each language, and the results were confirmed by manually investigating the source code and available documentation.", "num_citations": "66\n", "authors": ["106"]}
{"title": "Analysing the evolution of social aspects of open source software ecosystems\n", "abstract": " Empirical software engineering is concerned with statistical studies that aim to understand and improve certain aspects of the software development process. Many of these focus on the evolution and maintenance of evolving software projects. They rely on repository mining techniques to extract relevant data from software repositories or other data sources frequently used by software developers. We enlarge these empirical studies by exploring social software engineering, studying the developer community, including the way developers work, cooperate, communicate and share information. The underlying hypothesis is that social aspects significantly influence the way in which the software project will evolve over time. We present some preliminary results of an empirical study we are carrying out on the different types of activities of the community involved in the GNOME open source ecosystem, and we discuss suggestions for future work.", "num_citations": "65\n", "authors": ["106"]}
{"title": "A declarative evolution framework for object-oriented design patterns\n", "abstract": " Object-oriented design patterns and high-level refactorings are popular means of implementing and evolving large object-oriented software systems. Unfortunately, these techniques are inadequately supported at implementation level by current-day software development environments. To alleviate this problem, we propose to use the promising technique of declarative metaprogramming. It offers a tight, yet flexible, symbiosis between a base language and a metalevel declarative reasoning engine. It provides a uniform and language-independent way to specify design patterns and transformations declaratively, to instantiate patterns and generate code for them, and to deal with the evolution of these pattern instances. Providing support for evolution of a software system in terms of the design pattern instances it uses is the main emphasis of this paper.", "num_citations": "62\n", "authors": ["106"]}
{"title": "Evidence for the pareto principle in open source software activity\n", "abstract": " Numerous empirical studies analyse evolving open source software (OSS) projects, and try to estimate the activity and effort in these projects. Most of these studies, however, only focus on a limited set of artefacts, being source code and defect data. In our research, we extend the analysis by also taking into account mailing list information. The main goal of this article is to find evidence for the Pareto principle in this context, by studying how the activity of developers and users involved in OSS projects is distributed: it appears that most of the activity is carried out by a small group of people. Following the GQM paradigm, we provide evidence for this principle. We selected a range of metrics used in economy to measure inequality in distribution of wealth, and adapted these metrics to assess how OSS project activity is distributed. Regardless of whether we analyse version repositories, bug trackers, or mailing lists, and for all three projects we studied, it turns out that the distribution of activity is highly imbalanced.", "num_citations": "60\n", "authors": ["106"]}
{"title": "Conditional graph rewriting as a domain-independent formalism for software evolution\n", "abstract": " This paper presents a formal approach for managing unanticipated software evolution. Labelled typed nested graphs are used to represent arbitrarily complex software artifacts, and conditional graph rewriting is used for managing evolution of these artifacts. More specifically, we detect structural and behavioural inconsistencies when merging parallel evolutions of the same software artifact. The approach is domain-independent, in the sense that it can be customised to many different domains, such as software architectures, UML analysis and design models, and software code.", "num_citations": "58\n", "authors": ["106"]}
{"title": "A framework for analysing and visualising open source software ecosystems\n", "abstract": " Nowadays, most empirical studies in open source software evolution are based on the analysis of program code alone. In order to get a better understanding of how software evolves over time, many more entities that are part of the software ecosystem need to be taken into account. We present a general framework to automate the analysis of the evolution of software ecosystems. The framework incorporates a database that stores all relevant information obtained thanks to several mining tools, and provides a unified data source to visualisation tools. One such visualisation tool is integrated in order to get a first quick overview of the evolution of different aspects of the software project under study. The framework is extensible in order to accommodate more and different types of input and output, depending on the needs of the user. We compare our framework against existing solutions, and show how we can use this\u00a0\u2026", "num_citations": "57\n", "authors": ["106"]}
{"title": "When GitHub meets CRAN: An analysis of inter-repository package dependency problems\n", "abstract": " When developing software packages in a software ecosystem, an important and well-known challenge is how to deal with dependencies to other packages. In presence of multiple package repositories, dependency management tends to become even more problematic. For the R ecosystem of statistical computing, dependency management is currently insufficient to deal with multiple package versions and inter-repository package dependencies. We explore how the use of GitHub influences the R ecosystem, both for the distribution of R packages and for inter-repository package dependency management. We also discuss how these problems could be addressed.", "num_citations": "56\n", "authors": ["106"]}
{"title": "Resolving model inconsistencies using automated regression planning\n", "abstract": " One of the main challenges in model-driven software engineering is to automate the resolution of design model inconsistencies. We propose to use the artificial intelligence technique of automated planning for the purpose of resolving such inconsistencies through the generation of one or more resolution plans. We implemented Badger, a regression planner in Prolog that generates such plans. We assess its scalability on the resolution of different types of structural inconsistencies in UML models using both generated models and reverse-engineered models of varying sizes, the largest ones containing more than 10,000 model elements. We illustrate the metamodel-independence of our approach by applying it to the resolution of code smells in a Java program. We discuss how the user can adapt the order in which resolution plans are presented by modifying the cost function of the planner algorithm.", "num_citations": "51\n", "authors": ["106"]}
{"title": "Challenges in model refactoring\n", "abstract": " Refactoring is a well-known technique to improve the quality of software. Fowler (1999) defines it as \u201cA change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behaviour\u201d. At the level of models, research on refactoring is still in its infancy. Many open questions remain that are worthy of further investigation. From a practical point of view, very few tools provide integrated support for model refactoring. Also, the types of models for which refactoring is supported is very limited. Therefore, the goal of this position paper is to discuss some of the most important challenges in model refactoring. As the scenario depicted in Figure 1 shows, it is far from trivial to deal with model refactorings. Suppose that we have a model built up from many different views, using a variety of notations (eg, class diagrams, state diagrams, interaction diagrams, and many more). Suppose that part of the corresponding source code is generated automatically, and another part is hand-written. When we apply a model refactoring to a single view in the model (step 1), we will need to synchronise all related views, in order to avoid them becoming inconsistent (step 2). Next, since the model has been changed, part of the code needs to be regenerated (step 3). Finally, the hand-written code needs to be adapted as well (step 4).", "num_citations": "50\n", "authors": ["106"]}
{"title": "Incremental resolution of model inconsistencies\n", "abstract": " During model-driven software development, we are inevitably confronted with design models that contain a wide variety of inconsistencies. Interactive and automated support for detecting and resolving these inconsistencies is therefore indispensable. In this paper, we report on an iterative inconsistency resolution process. Our approach relies on the underlying formalism of graph transformation. We exploit the mechanism of critical pair analysis to analyse dependencies and conflicts between inconsistencies and resolutions, to detect resolution cycles and to analyse the completeness of resolutions. The results of this analysis are integrated in the iterative inconsistency resolution process and can help the software engineer to develop and evolve models in presence of inconsistencies.", "num_citations": "50\n", "authors": ["106"]}
{"title": "Supporting model refactorings through behaviour inheritance consistencies\n", "abstract": " This paper addresses the problem of consistency preservation in model-driven software development. Software models typically embody many different views that need to be kept consistent. In the context of consistency within a model, behaviour inheritance consistencies restrict the way the behaviour of a subclass can specialize the behaviour of a superclass. In the context of model evolution, model refactorings restructure a model while preserving its behavioural properties. It is still an open research question how to define behaviour preservation properties for model refactorings. We claim that behaviour inheritance consistencies correspond, in an evolution context, to the preservation of behavioural properties between model versions. To illustrate this claim, we implemented consistency rules and preservation behaviour rules in Racer, a reasoning engine for description logics. We show how the same\u00a0\u2026", "num_citations": "48\n", "authors": ["106"]}
{"title": "Generation of Sierpinski triangles: A case study for graph transformation tools\n", "abstract": " In this paper, we consider a large variety of solutions for the generation of Sierpinski triangles, one of the case studies for the AGTIVE graph transformation tool contest [15]. A Sierpinski triangle shows a well-known fractal structure. This case study is mostly a performance benchmark, involving the construction of all triangles up to a certain number of iterations. Both time and space performance are involved. The transformation rules themselves are quite simple.", "num_citations": "46\n", "authors": ["106"]}
{"title": "Assessing the Kodkod model finder for resolving model inconsistencies\n", "abstract": " In model-driven software engineering (MDE), software is built through the incremental development, composition and transformation of a variety of models. We are inevitably confronted with design models that contain a wide variety of inconsistencies. Interactive and automated support for detecting and resolving these inconsistencies is indispensable. We evaluate an approach to automate the generation of concrete models in which structural inconsistencies are resolved. We implemented this approach in the model finder Kodkod and assessed its suitability for model inconsistency resolution based on an objective set of criteria.", "num_citations": "45\n", "authors": ["106"]}
{"title": "On the maintainability of CRAN packages\n", "abstract": " When writing software, developers are confronted with a trade-off between depending on existing components and reimplementing similar functionality in their own code. Errors may be inadvertently introduced because of dependencies to unreliable components, and it may take longer time to fix these errors. We study such issues in the context of the CRAN archive, a long-lived software ecosystem consisting of over 5000 R packages being actively maintained by over 2500 maintainers, with different flavors of each package depending on the development status and target operating system. Based on an analysis of package dependencies and package status, we present preliminary results on the sources of errors in these packages per flavor, and the time that is needed to fix these errors.", "num_citations": "44\n", "authors": ["106"]}
{"title": "Model-driven software refactoring\n", "abstract": " In this chapter, we explore the emerging research domain of model-driven software refactoring. Program refactoring is a proven technique that aims at improving the quality of source code. Applying refactoring in a model-driven software engineering context raises many new challenges such as how to define, detect and improve model quality, how to preserve model behavior, and so on. Based on a concrete case study with a state-ofthe-art model-driven software development tool, AndroMDA, we explore some of these challenges in more detail. We propose to resolve some of the encountered problems by relying on wellunderstood techniques of meta-modeling, model transformation and graph transformation.", "num_citations": "42\n", "authors": ["106"]}
{"title": "Transformation dependency analysis-a comparison of two approaches.\n", "abstract": " L\u2019analyse de d\u00e9pendance de transformations est essentiel pour am\u00e9liorer le support de techniques actuelles de d\u00e9veloppement logiciel\u2013deux exemples sont la restructuration de programmes et la transformation de mod\u00e8les. Or, il est peu clair comment les outils de support actuels peuvent \u00eatre compar\u00e9s, \u00e0 cause d\u2019une diff\u00e9rence de terminologie, de concepts utilis\u00e9s, et de fondations formelles (graphes versus logique). Dans cet article nous discutons d\u2019une comparaison experimentale de deux outils: AGG et Condor. Entre autres, nous avons trouv\u00e9 un gain d\u2019efficacit\u00e9 de plusieurs ordres de magnitude en utilisant l\u2019approche bas\u00e9e sur la logique.", "num_citations": "40\n", "authors": ["106"]}
{"title": "Analysing object-oriented application frameworks using concept analysis\n", "abstract": " This paper proposes to use the formal technique of Concept Analysis to analyse how methods and classes in an object-oriented inheritance hierarchy are coupled by means of the inheritance and interfaces relationships. Especially for large and complex inheritance hierarchies, we believe that a formal analysis of how behaviour is reused can provide insight in how the hierarchy was built and the different relationships among the classes. To perform this analysis, we use behavioural information provided by the self sends and super sends made in each class of the hierarchy. The proposed technique allows us to identify weak spots in the inheritance hierarchy that may be improved, and to serve as guidelines for extending or customising an object-oriented application framework. As a first step, this paper reports on an initial experiment with the Magnitude hierarchy in the Smalltalk programming language.", "num_citations": "39\n", "authors": ["106"]}
{"title": "On the topology of package dependency networks: A comparison of three programming language ecosystems\n", "abstract": " Package-based software ecosystems are composed of thousands of interdependent software packages. Many empirical studies have focused on software packages belonging to a single software ecosystem, and suggest to generalise the results to more ecosystems. We claim that such a generalisation is not always possible, because the technical structure of software ecosystems can be very different, even if these ecosystems belong to the same domain. We confirm this claim through a study of three big and popular package-based programming language ecosystems: R's CRAN archive network, Python's PyPI distribution, and JavaScript's NPM package manager. We study and compare the structure of their package dependency graphs and reveal some important differences that may make it difficult to generalise the findings of one ecosystem to another one.", "num_citations": "35\n", "authors": ["106"]}
{"title": "Supporting disciplined reuse and evolution of UML models\n", "abstract": " UML provides very little support for modelling evolvable or reusable specifications and designs. To cope with this problem, the UML needs to be extended with support for reuse and evolution of model components. As a first step, this paper enhances the UML metamodel with the \u201creuse contract\u201d formalism to deal with evolution of collaborating class interfaces. Such a formal semantics for reuse allows us to detect evolution and composition conflicts automatically.", "num_citations": "35\n", "authors": ["106"]}
{"title": "An ecosystemic and socio-technical view on software maintenance and evolution\n", "abstract": " In this invited paper I focus on the difficulties of maintaining and evolving software systems that are part of a larger ecosystem. While not every software system falls under this category, software ecosystems are becoming ubiquitous due to the omnipresence of open source software. I present several challenges that arise during maintenance and evolution of software ecosystems, and I argue how some of these challenges should be addressed by adopting a socio-technical view and by relying on a multidisciplinary and mixed methods research approach. My arguments are accompanied by an extensive, though unavoidably incomplete, set of references to the state-of-the-art research in this domain.", "num_citations": "34\n", "authors": ["106"]}
{"title": "ECOS: Ecological studies of open source software ecosystems\n", "abstract": " Software ecosystems, collections of projects developed by the same community, are among the most complex artefacts constructed by humans. Collaborative development of open source software (OSS) has witnessed an exponential increase in two decades. Our hypothesis is that software ecosystems bear many similarities with natural ecosystems. While natural ecosystems have been the subject of study for many decades, research on software ecosystems is more recent. For this reason, the ECOS research project aims to determine whether and how selected ecological models and theories from natural ecosystems can be adapted and adopted to understand and better explain how OSS projects (akin to biological species) evolve, and to determine what are the main factors that drive the success or popularity of these projects. Expressed in biological terms, we wish to use knowledge on the evolution of natural\u00a0\u2026", "num_citations": "34\n", "authors": ["106"]}
{"title": "Towards a survival analysis of database framework usage in Java projects\n", "abstract": " Many software projects rely on a relational database in order to realize part of their functionality. Various database frameworks and object-relational mappings have been developed and used to facilitate data manipulation. Little is known about whether and how such frameworks co-occur, how they complement or compete with each other, and how this changes over time. We empirically studied these aspects for 5 Java database frameworks, based on a corpus of 3,707 GitHub Java projects. In particular, we analysed whether certain database frameworks co-occur frequently, and whether some database frameworks get replaced over time by others. Using the statistical technique of survival analysis, we explored the survival of the database frameworks in the considered projects. This provides useful evidence to software developers about which frameworks can be used successfully in combination and which\u00a0\u2026", "num_citations": "32\n", "authors": ["106"]}
{"title": "On the complexity of software systems\n", "abstract": " Developing the tools necessary for reasoning about and understanding large, complex software systems requires interdisciplinary research that borrows from other domains where complexity similarly comes into play.", "num_citations": "31\n", "authors": ["106"]}
{"title": "A historical analysis of Debian package incompatibilities\n", "abstract": " Users and developers of software distributions are often confronted with installation problems due to conflicting packages. A prototypical example of this are the Linux distributions such as Debian. Conflicts between packages have been studied under different points of view in the literature, in particular for the Debian operating system, but little is known about how these package conflicts evolve over time. This article presents an extensive analysis of the evolution of package incompatibilities, spanning a decade of the life of the Debian stable and testing distributions for its most popular architecture, i386. Using the technique of survival analysis, this empirical study sheds some light on the origin and evolution of package incompatibilities, and provides the basis for building indicators that may be used to improve the quality of package-based distributions.", "num_citations": "28\n", "authors": ["106"]}
{"title": "Model transformation: A survey of the state of the art\n", "abstract": " Model\u2010Driven Engineering (MDE) is an approach to software development where the principle artefacts are models. In contrast, the state of the art in MDE support is model centric, where the code can be fully generated from the models. Accepting the basic idea that everything is a model, and adopting a model\u2010centric view, we need techniques and tools that allow us to manipulate and reason about such models. The technique that can be used to achieve this is commonly referred to as model transformation. It is needed for supporting a wide range of model\u2010driven activities such as code generation, model extraction, model refactoring, model verification, model simulation, and many more. Model transformation languages serve to specify the syntax and semantics of model transformations, and are essential if we want to provide automated support for model transformation. This chapter overviews a wide variety of\u00a0\u2026", "num_citations": "28\n", "authors": ["106"]}
{"title": "Co-evolving code-related and database-related changes in a data-intensive software system\n", "abstract": " Current empirical studies on the evolution of software systems are primarily analysing source code. Sometimes, social aspects such as the activity of contributors are considered as well. Very few studies, however, focus on data-intensive software systems (DISS), in which a significant part of the total development effort is devoted to maintaining and evolving the database schema. We report on early results obtained in the empirical analysis of the co-evolution between code-related and database-related activities in a large open source DISS. As a case study, we have analysed OSCAR, for which the historical information spanning many years is available in a Git repository.", "num_citations": "27\n", "authors": ["106"]}
{"title": "Guiding architectural restructuring through architectural styles\n", "abstract": " Software architectures constitute one of the main artefacts of software-intensive system development. They outline the essential components and interconnections of a software system at a high level of abstraction, ignoring unnecessary details. How to address the evolution of software architectures, however, is still an important topic of current research. In this article, we use UML 2 as architectural description language notation and formalise it with graph transformation, with a proof-of-concept implemented in the AGG tool. We use this formalisation to express and reason about architectural evolution patterns that introduce architectural styles.", "num_citations": "27\n", "authors": ["106"]}
{"title": "Refactoring of UML models using AGG\n", "abstract": " Model refactoring is an emerging research topic that is heavily inspired by refactoring of object-oriented programs. Current-day UML modeling environments provide poor support for evolving UML models and applying refactoring techniques at model level. As UML models are intrinsically graph-based in nature we propose to use graph transformations to specify and apply model refactoring. More in particular, we use a specific graph transformation tool, AGG, and provide recommendations of how AGG may be improved to better support model refactoring. These recommendations are based on a small experiment that we have carried out with refactoring of UML class diagrams and state machines.", "num_citations": "26\n", "authors": ["106"]}
{"title": "What do package dependencies tell us about semantic versioning?\n", "abstract": " The semantic versioning (semver) policy is commonly accepted by open source package management systems to inform whether new releases of software packages introduce possibly backward incompatible changes. Maintainers depending on such packages can use this information to avoid or reduce the risk of breaking changes in their own packages by specifying version constraints on their dependencies. Depending on the amount of control a package maintainer desires to have over her package dependencies, these constraints can range from very permissive to very restrictive. This article empirically compares semver compliance of four software packaging ecosystems (Cargo, npm, Packagist and Rubygems), and studies how this compliance evolves over time. We explore to what extent ecosystem-specific characteristics or policies influence the degree of compliance. We also propose an evaluation based\u00a0\u2026", "num_citations": "25\n", "authors": ["106"]}
{"title": "A historical dataset for the GNOME ecosystem\n", "abstract": " We present a dataset of the open source software ecosystem Gnome from a social point of view. We have collected historical data about the contributors to all Gnome projects stored on git.gnome.org, taking into account the problem of identity matching, and associating different activity types to the contributors. This type of information is very useful to complement the traditional, source-code related information one can obtain by mining and analyzing the actual source code. The dataset can be obtained at https://bitbucket.org/mgoeminne/sgl-flossmetric-dbmerge.", "num_citations": "24\n", "authors": ["106"]}
{"title": "What does it take to develop a million lines of open source code?\n", "abstract": " This article presents a preliminary and exploratory study of the relationship between size, on the one hand, and effort, duration and team size, on the other, for 11 Free/Libre/Open Source Software (FLOSS) projects with current size ranging between between 0.6 and 5.3 million lines of code (MLOC). Effort was operationalised based on the number of active committers per month. The extracted data did not fit well an early version of the closed-source cost estimation model COCOMO for proprietary software, overall suggesting that, at least to some extent, FLOSS communities are more productive than closed-source teams. This also motivated the need for FLOSS-specific effort models. As a first approximation, we evaluated 16 linear regression models involving different pairs of attributes. One of our experiments was to calculate the net size, that is, to remove any suspiciously large outliers or jumps in the growth\u00a0\u2026", "num_citations": "24\n", "authors": ["106"]}
{"title": "Transformational software evolution by assertions\n", "abstract": " This paper explores the use of software transformations as a formal foundation for software evolution. More precisely, we express software transformations in terms of assertions (preconditions, postconditions and invariants) on top of the formalism of graph rewriting. This allows us to tackle scalability issues in a straightforward way. Useful applications include: detecting syntactic merge conflicts, removing redundancy in a transformation sequence, factoring out common subsequences, etc.", "num_citations": "24\n", "authors": ["106"]}
{"title": "On the development and distribution of R packages: An empirical analysis of the R ecosystem\n", "abstract": " This paper explores the ecosystem of software packages for R, one of the most popular environments for statistical computing today. We empirically study how R packages are developed and distributed on different repositories: CRAN, BioConductor, R-Forge and GitHub. We also explore the role and size of each repository, the inter-repository dependencies, and how these repositories grow over time. With this analysis, we provide a deeper insight into the extent and the evolution of the R package ecosystem.", "num_citations": "23\n", "authors": ["106"]}
{"title": "Averting the next software crisis\n", "abstract": " The paper states that for parallel programming to become mainstream, software engineering will need to help pave the way.", "num_citations": "23\n", "authors": ["106"]}
{"title": "Specifying domain-specific refactorings for andromda based on graph transformation\n", "abstract": " Applying refactoring in a model-driven software engineering context raises many new challenges that need to be addressed. In this paper, we consider model-driven software development based on the code generation framework AndroMDA. Considering the UML profile for AndroMDA, we come up with a number of domain-specific model refactorings. In its most recent version, the AndroMDA code generation can be based on the Eclipse Modeling Framework (EMF) which has evolved towards the de facto standard technology to specify UML models. We show how domain-specific refactorings can be specified by EMF transformation incorporating graph transformation concepts. This opens up the possibility to reason about domain-specific refactorings in a formal way.", "num_citations": "23\n", "authors": ["106"]}
{"title": "Analyzing the evolution of testing library usage in open source Java projects\n", "abstract": " Software development projects frequently rely on testing-related libraries to test the functionality of the software product automatically and efficiently. Many such libraries are available for Java, and developers face a hard time deciding which libraries are most appropriate for their project, or when to migrate to a competing library. We empirically analysed the usage of eight testing-related libraries in 4,532 open source Java projects hosted on GitHub. We studied how frequently specific (pairs of) libraries are used over time. We also identified if and when library usages are replaced by competing ones during a project's lifetime. We found that some libraries are considerably more popular than their competitors, while some libraries become more popular over time. We observed that many projects tend to use multiple libraries together. We also observed permanent and temporary migrations between competing libraries\u00a0\u2026", "num_citations": "22\n", "authors": ["106"]}
{"title": "Analyzing ecosystems for open source software developer communities\n", "abstract": " Software systems are among the most complex artefacts ever created by humans. Among them, collaborative development of open source software (OSS) has witnessed an exponential increase in the last two decades. It represents a successful model of software development where communities of developers collaborate on an often voluntary basis, while users and developers of the software systems can submit bug reports and requests for changes, and need to be kept satisfied in order to maintain their involvement in the system.Drawing the analogy with biological ecosystems, collections of OSS projects developed by the same developer community and interacting together can be considered as software ecosystems. While being significantly different, we can observe many similarities between both types of ecosystems. A biological ecosystem is defined as a biological environment consisting of all species living\u00a0\u2026", "num_citations": "21\n", "authors": ["106"]}
{"title": "On the evolution complexity of design patterns\n", "abstract": " Software co-evolution can be characterised as a way to \u201cadjust\u201d any given software implementation to a change (\u201cshift\u201d) in the software requirements. In this paper, we propose a formal definition of evolution complexity to precisely quantify the cost of adjusting a particular implementation to a change (\u201cshift\u201d) in the requirements. As a validation, we show that this definition formalises intuition about the evolvability of design patterns.", "num_citations": "21\n", "authors": ["106"]}
{"title": "Unanticipated software evolution\n", "abstract": " This workshop was dedicated to research towards better support for unanticipated software evolution (USE) in development tools, programming languages, component models and related runtime infrastructures.The report gives an overview of the submitted papers and summarizes the essence of discussions during plenary sessions and in working groups.", "num_citations": "19\n", "authors": ["106"]}
{"title": "Research trends in structural software complexity\n", "abstract": " There are many dimensions of software complexity. In this article, we explore how structural complexity is measured and used to study and control evolving software systems. We also present the current research challenges and emerging trends in this domain that has remained active for nearly four decades, and continues to evolve.", "num_citations": "18\n", "authors": ["106"]}
{"title": "Resolving Model Inconsistencies with Automated Planning.\n", "abstract": " Various approaches have been explored to detect and resolve software model inconsistencies in a generic and scalable way. In this position paper, we outline our research that aims to use the technique of automated planning for the purpose of resolving model inconsistencies. We discuss the scalability results of the approach obtained through several stress-tests and we propose several alternatives to the automated planning approach.", "num_citations": "17\n", "authors": ["106"]}
{"title": "Abstract semantics for ESM systems\n", "abstract": " ESM systems are a graph-rewriting formalism for concurrent systems: a global system state is represented by a graph and a run of the system is described by a graph rewriting process. These rewriting processes are formally described by computation structures. It is demonstrated that the computation structures of an ESM system P may be viewed as the arrows of a category Cat comp (P) where objects are system states. This category generalizes the well-known notion of a transition system. From Cat comp (P) various more abstract semantics are derived, and for each of them a powerful composition operation on computations, generalizing both the sequential and parallel composition of computations, is defined.", "num_citations": "17\n", "authors": ["106"]}
{"title": "On the interaction of relational database access technologies in open source Java projects\n", "abstract": " This article presents an empirical study of how the use of relational database access technologies in open source Java projects evolves over time. Our observations may be useful to project managers to make more informed decisions on which technologies to introduce into an existing project and when. We selected 2,457 Java projects on GitHub using the low-level JDBC technology and higher-level object relational mappings such as Hibernate XML configuration files and JPA annotations. At a coarse-grained level, we analysed the probability of introducing such technologies over time, as well as the likelihood that multiple technologies co-occur within the same project. At a fine-grained level, we analysed to which extent these different technologies are used within the same set of project files. We also explored how the introduction of a new database technology in a Java project impacts the use of existing ones. We observed that, contrary to what could have been expected, object-relational mapping technologies do not tend to replace existing ones but rather complement them.", "num_citations": "16\n", "authors": ["106"]}
{"title": "A taxonomy of model transformation and its application to graph transformation\n", "abstract": " This article proposes a taxonomy of model transformation, based on the discussions of a working group on model transformation of the Dagstuhl seminar on Language Engineering for Model-Driven Software Development. This taxonomy can be used to help developers in deciding which model transformation approach is best suited to deal with a particular problem. We validate the taxonomy by applying it to graph transformation, a promising technology to deal with model transformation.", "num_citations": "16\n", "authors": ["106"]}
{"title": "Badger: A regression planner to resolve design model inconsistencies\n", "abstract": " One of the main challenges in model-driven software engineering is to deal with design model inconsistencies. Automated techniques to detect and resolve these inconsistencies are essential. We propose to use the artificial intelligence technique of automated planning for the purpose of resolving software model inconsistencies. We implemented a regression planner in Prolog and validated it on the resolution of different types of structural inconsistencies for generated models of varying sizes. We discuss the scalability results of the approach obtained through several stress-tests and discuss the limitations of our approach.", "num_citations": "15\n", "authors": ["106"]}
{"title": "Maispion: A tool for analysing and visualising open source software developer communities\n", "abstract": " We present Maispion, a tool for analysing software developer communities. The tool, developed in Smalltalk, mines mailing list and version repositories, and provides visualisations to provide insights into the ecosystem of open source software (OSS) development. We show how Maispion can analyze the history of medium to large OSS communities, by applying our tool to three well-known open source projects: Moose, Drupal and Python.", "num_citations": "15\n", "authors": ["106"]}
{"title": "maintaineR: A web-based dashboard for maintainers of CRAN packages\n", "abstract": " The R development community maintains thousands of packages through its Comprehensive R Archive Network CRAN. The growth and evolution of this archive makes it more and more difficult to maintain packages and their interdependencies, and the existing tools that aim to help developers in this process no longer suffice. We propose maintaine R, a web-based dashboard that allows CRAN package developers to understand and deal with the implications and problems raised by package updates. The dashboard complements existing analysis tools by providing additional support such as the visualisation of package dependencies and reverse dependencies, package conflicts, cross-package function clones, and so on.", "num_citations": "13\n", "authors": ["106"]}
{"title": "Enabling dynamic software evolution through automatic refactoring\n", "abstract": " Many software systems must always stay opera-tional, and cannot be shutdown in order to adapt them to new requirements. For such systems, dynamic software evolution techniques are needed. In this paper we show how we can exploit automated refactorings to improve a software the component structure of a software system while the system is running in order to facilitate future evolutions. We report on some experiments we performed in Smalltalk to achieve this goal.", "num_citations": "13\n", "authors": ["106"]}
{"title": "Supporting reuse and evolution of UML models\n", "abstract": " During the last two decades an entire range of mechanisms has been developed to support the definition, customisation and reuse of implementation-level components such as classes and objects. Some indicative examples are inheritance, late-binding polymorphism, object-oriented frameworks [Wirfs-Brock90], meta-object protocols [Kiczales&al91] and aspect-oriented programming [Kiczales&al97]. Although it is generally acknowledged that reuse is much more important during the analysis and design phase than during the implementation phase, there is much less support for, and understanding of, reuse at these phases of the software life cycle. Some support for model reuse does exist. Examples are \u201cfacades\u201d and \u201cvariation points\u201d[Jacobson&al97] and \u201csynthesis\u201d of role model components [Reenskaug&al96]. In general, however, it is not clear what an analysis or design component is, and even less clear how such model components can be composed and reused. Taking UML 1.1 [Rational97] as a representative example, we observe that it does not provide enough support for dealing with reusable components. To go beyond the reuse of single classes, packages can be used to encapsulate model elements and pattern structures to define generic models. Experience with implementation reuse has learned, however, that besides the issue of encapsulation, customisation and composition of complex models needs to be addressed as well. Unfortunately, customisation of packages containing complicated components is poorly supported in UML.Experience with implementation reuse has also learned that building and reusing components\u00a0\u2026", "num_citations": "13\n", "authors": ["106"]}
{"title": "Parametric modelling within immersive environments: building a bridge between existing tools and virtual reality headsets\n", "abstract": " Even though architectural modelling radically evolved over the course of its history, the current integration of Augmented Reality (AR) and Virtual Reality(VR) components in the corresponding design tasks is mostly limited to enhancing visualisation. Little to none of these tools attempt to tackle the challenge of modelling within immersive environments, that calls for new input modalities in order to move away from the traditional mouse and keyboard combination. In fact, relying on 2D devices for 3D manipulations does not seem to be effective as it does not offer the same degrees of freedom. We therefore present a solution that brings VR modelling capabilities to Grasshopper, a popular parametric design tool. Together with its associated proof-of-concept application, our extension offers a glimpse at new perspectives in that field. By taking advantage of them,one can edit geometries with real-time feedback on the generated models, without ever leaving the virtual environment. The distinctive characteristics of VR applications provide a range of benefits without obstructing design activities. The designer can indeed experience the architectural models at full scale from a realistic point-of-view and truly feels immersed right next to them.", "num_citations": "11\n", "authors": ["106"]}
{"title": "The ecology of software ecosystems\n", "abstract": " Software ecosystems--collections of software projects developed and used by the same community--are extremely complex. Comparing them with biological ecosystems can yield new strategies for improving their effectiveness and resilience.", "num_citations": "11\n", "authors": ["106"]}
{"title": "ProMoBox in Practice: A Case Study on the GISMO Domain-Specific Modelling Language.\n", "abstract": " Domain-specific modelling (DSM) helps designing systems at a higher level of abstraction, by providing languages that are closer to the problem space than to the solution space. Unfortunately, specifying and verifying properties of the modelled system has been mostly neglected by DSM approaches. At best, this is only partially supported by translating models to formal representations on which properties are specified and evaluated based on logic-based formalisms. This contradicts the DSM philosophy as domain experts are usually not familiar with such formalisms. To overcome this shortcoming, the ProMoBox approach lifts property specification and verification tasks up to the domain-specific level. For a given DSM language, some operations at the metamodel level are needed to allow specification and verification of properties. This paper reports on a practical case study of how to apply the ProMoBox approach on GISMO, a DSM language designed specifically for developing gestural interaction applications.", "num_citations": "11\n", "authors": ["106"]}
{"title": "Techniques and tools for parallelizing software\n", "abstract": " With the emergence of multicore and manycore processors, engineers must design and develop software in drastically new ways to benefit from the computational power of all cores. However, developing parallel software is much harder than sequential software because parallelism can't be abstracted away easily. Authors Hans Vandierendonck and Tom Mens provide an overview of technologies and tools to support developers in this complex and error-prone task.", "num_citations": "11\n", "authors": ["106"]}
{"title": "Statechart modelling of interactive gesture-based applications\n", "abstract": " Developing intuitive interactive applications that are easy to maintain by developers is quite challenging, due to the complexity and the many technical aspects involved in such applications. In this article, we tackle the problem in two complementary ways. First, we propose a gestural interface to improve the user experience when interacting with applications that require the manipulation of 3D graphical scenes. Second, we reduce the complexity of developing such applications by modeling their executable behaviour using statecharts. We validate our approach by creating a modular and extensible Java framework for the development of interactive gesture-based applications. We developed a proofof-concept application using this framework, that allows the user to construct and manipulate 3D scenes in OpenGL by using hand gestures only. These hand gestures are captured by the Kinect sensor, and translated into events and actions that are interpreted and executed by communicating statecharts that model the main behaviour of the interactive application.", "num_citations": "11\n", "authors": ["106"]}
{"title": "Colored graph transformation rules for model-driven engineering of multi-target systems\n", "abstract": " Multi-target systems are interactive systems that are aimed at covering multiple contexts of use: by enabling users to carry out their tasks thanks to different input and output interaction modalities, these systems should support multiple computing platforms, multiple users, and multiple environments. This paper introduces a model-driven engineering method for developing user interfaces for such multi-target systems. It relies on a transformational approach that applies graph transformation rules on a graph representation of the models in order to support model-to-model transformation. In order to factor out parts that are common in transformation rules used for similar contexts of use, the notion of colored graph transformation is introduced. Each model element is assigned to a specific color depending on the desired target, here the interaction modality involved. Colored transformation rules based on these colored\u00a0\u2026", "num_citations": "11\n", "authors": ["106"]}
{"title": "Using graph transformation to support collaborative ontology evolution\n", "abstract": " In collaborative ontology engineering, contexts are key to manage the complexity of different dependency types between ontological artefacts. Instead of being frustrated by out-of-control evolution processes, proper context dependency management will allow human experts to focus on the meaning interpretation and negotiation processes. This requires support for the detection and resolution of meaning ambiguities and conflicts. In this article, we explore to which extent the theory of graph transformation can be used to support this activity. More specifically, we propose the use of critical pair analysis as a formal means to analyse conflicts between ontologies that are evolving in parallel. We illustrate this with an example from a realistic case study.", "num_citations": "11\n", "authors": ["106"]}
{"title": "High-level transformations to support framework-based software development\n", "abstract": " In this paper, we show how elaborate support for framework-based software development can be provided based on explicit documentation of the hot spots of object-oriented application frameworks. This support ranges from automatically verifying whether appropriate design constraints are preserved, over providing high-level transformations that guide a developer when instantiating applications from a framework, to supporting software upgrades based on these transformations. The hot spots are documented by means of design patterns, and we use metapatterns as an abstraction to define the associated design constraints and high-level transformations.", "num_citations": "11\n", "authors": ["106"]}
{"title": "A ground-truth dataset and classification model for detecting bots in GitHub issue and PR comments\n", "abstract": " Bots are frequently used in Github repositories to automate repetitive activities that are part of the distributed software development process. They communicate with human actors through comments. While detecting their presence is important for many reasons, no large and representative ground-truth dataset is available, nor are classification models to detect and validate bots on the basis of such a dataset. This paper proposes a ground-truth dataset, based on a manual analysis with high interrater agreement, of pull request and issue comments in 5,000 distinct Github accounts of which 527 have been identified as bots. Using this dataset we propose an automated classification model to detect bots, taking as main features the number of empty and non-empty comments of each account, the number of comment patterns, and the inequality between comments within comment patterns. We obtained a very high\u00a0\u2026", "num_citations": "10\n", "authors": ["106"]}
{"title": "Heterogeneous modeling of gesture-based 3D applications\n", "abstract": " Model-driven software engineering (MDE) is a well-known approach for developing software. It reduces complexity, facilitates maintenance and allows for the simulation, verification, validation and execution of software models. In this article, we show how MDE and model execution can be leveraged in the context of human-computer interaction (HCI). We claim that in this application domain it is beneficial to use heterogeneous models, combining different models of computation for different components of the system. We report on a case study that we have carried out to develop an executable model of a gesture-based application for manipulating 3D objects, using the Kinect sensor as input device, and the OGRE graphical engine as output device for real-time rendering. The interaction part of this application is fully specified as an executable heterogeneous model with the ModHel'X modeling environment. We\u00a0\u2026", "num_citations": "10\n", "authors": ["106"]}
{"title": "4th workshop on object-oriented architectural evolution\n", "abstract": " The aim of the fourth workshop on Object-Oriented Architectural Evolution was to discuss into more detail a number of important issues raised during the previous workshop: the relationship between domain analysis and software architecture, the importance of architectural views and layering techniques, and the applicability of existing object-oriented principles and evolution techniques. This paper summarises the results of the debates held about these issues, reports on convergences of view taken place during the workshop, and suggests some research topics that are worthwhile to pursue in the future.", "num_citations": "10\n", "authors": ["106"]}
{"title": "Giving Precise semantics to Reuse in UML\n", "abstract": " In UML there is little support for reusing specifications and designs. To deal with this problem, we enhance UML with support for definition, reuse and evolution of reusable components. This is not a trivial task, since some language concepts lack a precise semantics, while the interpretation of others is simply \u201cbeyond the scope of UML\u201d. By providing our own definitions in these cases, and by making use of packages, refinements, and the built-in extension mechanisms, a precise semantics is given to reuse of UML models. Among others, this precise semantics allows us to detect reuse conflicts automatically.", "num_citations": "10\n", "authors": ["106"]}
{"title": "A generic framework for executable gestural interaction models\n", "abstract": " Integrating new input devices and their associated interaction techniques into interactive applications has always been challenging and time-consuming, due to the learning curve and technical complexity involved. Modeling devices, interactions and applications helps reducing the accidental complexity. Visual modeling languages can hide an important part of the technical aspects involved in the development process, thus allowing a faster and less error-prone development process. However, even with the help of modeling, a gap remains to be bridged in order to go from models to the actual implementation of the interactive application. In this paper we use ICO, a visual formalism based on high-level Petri nets, to develop a generic layered framework for specifying executable models of interaction using gestural input devices. By way of the CASE tool Petshop we demonstrate the framework's feasibility to handle\u00a0\u2026", "num_citations": "9\n", "authors": ["106"]}
{"title": "On the use of formal techniques to support model evolution\n", "abstract": " Model-driven engineering (MDE) is an emerging software engineering discipline that relies on model transformation. Model transformations can be very diverse, and encompass, among others, the following techniques: code generation, reverse engineering, model refinement and model refactoring. Due to the inherently volatile nature of all kinds of software artefacts, and models in particular, all existing and future MDE approaches should explicitly take into account the inevitable process of model evolution. In this paper, we explain how formal support for model evolutino is needed. We motivate this by using the formalism of description logic to support the activity of model inconsistency management, and by using tthe formalism of graph transformation to support the activity of model refactoring.", "num_citations": "9\n", "authors": ["106"]}
{"title": "Using genetic programming to generate protocol adaptors for interprocess communication\n", "abstract": " As mobile devices become more powerful, interprocess communication becomes increasingly more important. Unfortunately, this larger freedom of mobility gives rise to unknown environments. In these environments, processes that want to communicate with each other will be unable to do so because of protocol conflicts. Although conflicting protocols can be remedied by using adaptors, the number of possible combinations of different protocols increases dramatically. Therefore we propose a technique to generate protocol adaptors automatically. This is realised by means of genetically engineered classifier systems that use Petri nets as a specification for the underlying protocols. This paper reports on an experiment that validates this approach.", "num_citations": "9\n", "authors": ["106"]}
{"title": "A method for testing and validating executable statechart models\n", "abstract": " Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the\u00a0\u2026", "num_citations": "8\n", "authors": ["106"]}
{"title": "Evolving Software Ecosystems A Historical and Ecological Perspective.\n", "abstract": " Software ecosystems are collections of interacting and communicating software projects developed by the same developer community. Dealing with the complex interaction and dynamics of these ecosystems is an important problem that raises additional challenges compared to the maintenance of individual software systems. In particular, the social aspect becomes crucial, requiring to understand evolving ecosystems as dynamic socio-technical networks. Based on software repository mining research advances, in this lecture I explore the state of the art in the empirical analysis of software ecosystems, with a focus on the evolutionary aspect. I present some of the challenges that need to be overcome during the extraction and cleaning of data obtained from different data sources (such as version control repositories, bug trackers, and mailing lists). I draw an analogy between software ecosystems and natural ecosystems, and illustrate through previously reported empirical case studies how ecological diversity metrics and econometric inequality metrics can be used to increase understanding of evolving software ecosystems from dual viewpoints.It should be noted that this article has been conceived as a work of reference. It does not provide any novel research results by itself, but rather introduces the important concepts and challenges in the field. It also provides many pointers for further reading for those researchers that wish to start working in this important research domain.", "num_citations": "8\n", "authors": ["106"]}
{"title": "Resolving inconsistencies in model-driven engineering using automated planning\n", "abstract": " One of the main research challenges in model-driven software engineering is to deal with inconsistencies in software design models. Automated techniques to detect and resolve these inconsistencies are essential. A wide range of model inconsistency resolution approaches have been presented in literature.In this dissertation, we study a novel approach that uses automated planning, an artificial intelligence technique, for the purpose of automatically generating resolution plans for model inconsistencies. We present two different planning approaches to generate resolution plans: Fast-Forward Planning System (FF), an existing domain-independent heuristic state-space progression planner; and Badger, a new domain-specific regression planner that we have implemented in Prolog. We study their feasibility in the domain of model inconsistency resolution. Badger has demonstrated good performance for inconsistency resolution, is metamodel-independent and can generate multiple resolutions plans. In addition, the planner algorithm of Badger can be adapted by taking full advantage of the domain knowledge.", "num_citations": "8\n", "authors": ["106"]}
{"title": "Qualgen: Modeling and analysing the quality of evolving software systems\n", "abstract": " In this article we present an ongoing interuniversity research collaboration in the context of a large ERDF-funded research project aiming to enhance and support the quality of evolving software-intensive systems. The project focuses on two aspects in particular, namely the development of a quality metamodel for measuring and controlling the quality of software-related activities, and the instantiation of this framework to measure the quality of evolving libre software distributions from the point of view of different stakeholders.", "num_citations": "8\n", "authors": ["106"]}
{"title": "Fine-grained interlaced code loading for mobile systems\n", "abstract": " In the advent of ubiquitous mobile systems in general and mobile agents in particular, network latency becomes a critical factor. This paper investigates interlaced code loading, a promising technique that permutes the application code at method level and exploits parallelism between loading and execution of code to reduce network latency. It allows many applications to start execution earlier, especially programs with a predictable startup phase (such as building a GUI). The feasibility of the technique has been validated by implementing a prototype tool in Smalltalk, and applying it to three applications and a wide range of different bandwidths. We show how existing applications can be adapted to maximally benefit from the technique and provide design guidelines for new applications. For applications that rely on a GUI, the time required to build the GUI can be reduced to 21 % on the average.", "num_citations": "8\n", "authors": ["106"]}
{"title": "Bot or not? Detecting bots in GitHub pull request activity based on comment similarity\n", "abstract": " Many empirical studies focus on socio-technical activity in social coding platforms such as GitHub, for example to study the onboarding, abandonment, productivity and collaboration among team members. Such studies face the difficulty that GitHub activity can also be generated automatically by bots of a different nature. It therefore becomes imperative to distinguish such bots from human users. We propose an automated approach to detect bots in GitHub pull request (PR) activity. Relying on the assumption that bots contain repetitive message patterns in their PR comments, we analyse the similarity between multiple messages from the same GitHub identity, using a clustering method that combines the Jaccard and Levenshtein distance. We empirically evaluate our approach by analysing 20,090 PR comments of 250 users and 42 bots in 1,262 GitHub repositories. Our results show that the method is able to clearly\u00a0\u2026", "num_citations": "7\n", "authors": ["106"]}
{"title": "A declarative meta-programming approach to framework documentation\n", "abstract": " The documentation of software artifacts in general, and object-oriented frameworks in particular, has always been problematic. In this paper, we advocate the use of a declarative meta-programming environment to document software artifacts. In particular, we show how a significant and important part of the design of a framework can be adequately and concisely documented in such an environment, and how this allows us to use this documentation in an active way.", "num_citations": "7\n", "authors": ["106"]}
{"title": "Using declarative metaprogramming to detect possible refactorings\n", "abstract": " In this paper, we advocate the use of declarative metaprogramming to detect violations of important (object-oriented) design guidelines and best practices. This is particularly useful for detecting when a design should be refactored, and which refactorings in particular should be applied. As we will show, a declarative environment incorporating metaprogramming capabilities is very well suited for detecting such violations and providing information for possible refactorings.", "num_citations": "7\n", "authors": ["106"]}
{"title": "A survey on formal models for OO\n", "abstract": " In this text, an overview is presented of different kinds of formal models for OO that have been proposed over the years. We discuss both concurrent and sequential models. Within the realm of sequential models we make a distinction depending on whether the formalisms are based on lambdacalculus or not.", "num_citations": "7\n", "authors": ["106"]}
{"title": "Towards collaborative immersive environments for parametric modelling\n", "abstract": " The Architecture, Engineering and Construction (AEC) industry started to integrate Augmented Reality (AR) and Virtual Reality (VR) solutions in Computer-Aided Architectural Design (CAAD) tools, but their use is mostly limited to visualisation purposes. Few of these tools propose the ability of advanced modelling directly within an immersive environment. To fill this void, we previously proposed a software bridge between Grasshopper, a popular tool for parametric architectural modelling, and the HTC Vive VR headset. This bridge allows to adjust parameter values and get real-time feedback on the corresponding parametric geometries from within a VR environment.               In this paper, we discuss how to extend that solution with support for live collaboration as design processes very often involve multiple collaborators. This requires addressing a variety of related challenges such as bandwidth and latency\u00a0\u2026", "num_citations": "6\n", "authors": ["106"]}
{"title": "Anonymized e-mail interviews with R package maintainers active on CRAN and GitHub\n", "abstract": " This technical report accompanies a research article that empirically studies the problems related to inter-repository package dependencies in the R ecosystem of statistical computing, with a focus on R packages hosted on CRAN and GitHub. The current report provides supplementary material, reproducing an anonymised and sanitised version of e-mail interviews that have been conducted in November 2015 with five active R package maintainers. The goal was to gain a better understanding in how R package maintainers develop and distribute their packages through GitHub and CRAN. All five interviewees were actively maintaining packages on GitHub, some were also active on CRAN. They have been selected based on their profile (the number of R packages they maintain on GitHub and/or CRAN) as well as their gender (three interviewees were male, two were female).", "num_citations": "6\n", "authors": ["106"]}
{"title": "Towards the analysis of evolution OSS ecosystems\n", "abstract": " Interactions between user and developer communities on the one hand, and open-source software (OSS) evolution and quality on the other hand, are not intensively studied. However, these communities significantly influence how the software evolves. Empirical studies about this influence could offer us a way to propose changes in the software development process in order to improve the overall software quality. We propose to study the effect that user and developer communities have on the evolution and the quality of OSS, thereby extending previous studies of OSS evolution with knowledge about the ecosystem that surrounds it. We outline our current research that consists in an empirical analysis of the evolution of three well-known OSS, to try to find a relation between their quality and development popularity.", "num_citations": "6\n", "authors": ["106"]}
{"title": "Syntactic Quality Assurance Techniques for Software Models\n", "abstract": " In today\u2019s software development, developers have to deal with increasing requirements and systems including complex interconnections. Complexity, requirements management and numerous versions (of software products) are the main challenges in the development and evolution of software controlled systems. One answer to these challenges are model-based development technologies which give models more relevance compared to other artifacts. Hence, the construction and use of models have become central activities in modern software engineering.The correct handling of models requires new techniques in particular for their quality assurance. These techniques are in the focus of current research. There are already first approaches which often rely on well-known techniques from software engineering. Metrics, smells and refactorings are some of these techniques, which have proved to be useful in practice. Equivalent techniques for models are the focus of this diploma thesis and will be illustrated within a continuous example. Besides, model quality in general is discussed. The discussed techniques are limited to syntactic quality assurance techniques. This means that they do not deal with the semantics of models in a formal manner. A more general consideration is-according to the current state of research-difficult and would furthermore go beyond the scope of this diploma thesis. The de facto standard in software modeling is UML. For this reason this thesis concentrates on UML 2 models. The diploma thesis is structured along the use of the techniques. A detailed discussion of model quality is followed by chapters presenting model\u00a0\u2026", "num_citations": "6\n", "authors": ["106"]}
{"title": "Graph-based tool support to improve model quality\n", "abstract": " During model-driven software development, we are inevitably confronted with design models that contain a wide variety of design defects. Interactive tool support for improving the model quality by resolving these defects in an automated way is therefore indispensable. In this paper, we report on the development of such a tool, based on the underlying formalism of graph transformation. Due to the fact that the tool is developed as a front-end of the AGG Engine, a general purpose graph transformation engine, it can exploit some of its interesting built-in mechanisms such as critical pair analyis and the ability to reason about sequential dependencies. We explore how this can help to improve the process of quality improvement, and we compare our work with related research.", "num_citations": "6\n", "authors": ["106"]}
{"title": "GISMO: a domain-specific modelling language for executable prototyping of gestural interaction\n", "abstract": " This paper presents Gismo, an extensible domain-specific modelling language for prototyping executable models of gestural interaction. Relying on an underlying customisable framework, domain-specific models can specify, simulate and execute the behaviour of how users interact with a software application through the use of different interaction controllers and gesture types (eg, specific hand movements or other body gestures). Model transformation technology is used to define the domain-specific operational semantics of Gismo, as well as to verify domain-specific properties. ICO models are automatically generated from Gismo models, and are executed by an underlying framework that can communicate with the target software application. We illustrate the use of Gismo through a running example that models the gestural interaction of a graphical application using dynamic hand gestures to control an animated\u00a0\u2026", "num_citations": "5\n", "authors": ["106"]}
{"title": "An empirical study of identical function clones in CRAN\n", "abstract": " Code clone analysis is a very active subject of study, and research on inter-project code clones is starting to emerge. In the context of software package repositories specifically, developers are confronted with the choice between depending on code implemented in other packages, or cloning this code in their own package. This article presents an empirical study of identical function clones in the CRAN package archive network, in order to understand the extent of this practice in the R community. Depending on too many packages may hamper maintainability as unexpected conflicts may arise during package updates. Duplicating functions from other packages may reduce maintainability since bug fixes or code changes are not propagated automatically to its clones. We study how the characteristics of cloned functions in CRAN snapshots evolve over time, and classify these clones depending on what has prevented\u00a0\u2026", "num_citations": "5\n", "authors": ["106"]}
{"title": "Giving Precise Semantics to Reuse and Evolution in UML\n", "abstract": " Next to the fact that UML is becoming an industry standard, probably one of its most salient features is its built-in extension mechanisms, namely stereotypes and constraints. This should make it easy to extend UML notation with new functionality. Unfortunately, the lack of a precise semantics for UML is one of the main inhibitors of its extendibility. Many difficulties need to be overcome in order to add reuse and evolution features to UML.", "num_citations": "5\n", "authors": ["106"]}
{"title": "Agora: reintroducing safety in prototype-based languages\n", "abstract": " Prototype-based languages are often described as being more flexible and expressive than class-based languages. This greater flexibility makes prototype-based languages well-suited for rapid prototyping and exploratory programming, but comes with a serious loss of safety. Examples of this are the encapsulation problem and the prototype corruption problem most prototype-based languages suffer from. These problems preclude prototypebased languages from being widely used. We propose a prototype-based language that eliminates these problems and thus reintroduces safety in prototype-based languages.", "num_citations": "5\n", "authors": ["106"]}
{"title": "A feasibility study of quality assessment during software maintenance\n", "abstract": " In software maintenance, most of the measurement effort focuses on the evaluation and/or prediction of software maintainability. Many other software measures defined to assess other quality characteristics, such as completeness, are arguably useful to assist the software maintenance process. We carried out a study on six student projects, using customised operational quality assessment models (MoCQA models). We designed and investigated different measures of completeness and their capability to support the maintenance of software. The study indicates that the selected completeness measures help support adequately the maintenance process by identifying and locating the flaws. The results also suggest that this usefulness of simple customised software measures is mainly impacted by the accuracy of the description of the measured entities.", "num_citations": "4\n", "authors": ["106"]}
{"title": "Automated planning for resolving model inconsistencies\u2013a scalability study\n", "abstract": " Various approaches have been explored to detect and resolve software model inconsistencies. In this article, we outline our research that uses the artificial intelligence technique of automated planning for the purpose of resolving software model inconsistencies. We discuss the feasibility and scalability of a progression planner, and provide initial results of using a regression planner to improve the scalability.", "num_citations": "4\n", "authors": ["106"]}
{"title": "Relationship between size, effort, duration and number of contributors in large FLOSS projects\n", "abstract": " This contribution presents initial results in the study of the relationship between size, effort, duration and number of contributors in eleven evolving Free/Libre Open Source Software (FLOSS) projects, in the range from approx. 650,000 to 5,300,000 lines of code. Our initial motivation was to estimate how much effort is involved in achieving a large FLOSS system. Software cost estimation for proprietary projects has been an active area of study for many years. However, to our knowledge, no previous similar research has been conducted in FLOSS effort estimation. This research can help planning the evolution of future FLOSS projects and in comparing them with proprietary systems. Companies that are actively developing FLOSS may benefit from such estimates. Such estimates may also help to identify the productivity \u2019baseline\u2019 for evaluating improvements in process, methods and tools for FLOSS evolution.", "num_citations": "4\n", "authors": ["106"]}
{"title": "WS 9. The First International Workshop on Unanticipated Software Evolution\n", "abstract": " This workshop was dedicated to research towards better support for unanticipated software evolution (USE) in development tools, programming languages, component models and related runtime infrastructures. The report gives an overview of the submitted papers and summarizes the essence of discussions during plenary sessions and in working groups.", "num_citations": "4\n", "authors": ["106"]}
{"title": "Analysing object oriented framework reuse using concept analysis\n", "abstract": " This paper proposes the use of the formal technique of Concept Analysis to analyse how classes in an object-oriented inheritance hierarchy are coupled by means of the inheritance and interfaces relationships. To perform our analysis, we use the information provided by the self-send and super-send behaviour of each class in the hierarchy. Especially for large and complex inheritance hierarchies, we believe that this analysis can help in understanding the software, in particular with how reuse is achieved. Additionally, the proposed technique allows us to identify weak spots in the inheritance hierarchy that may be improved, and to serve as guidelines for extending or customising an object-oriented application framework. As a first step, this position paper reports on an initial experiment with the Magnitude hierarchy in the Smalltalk programming language.", "num_citations": "4\n", "authors": ["106"]}
{"title": "Incremental Design of Layered State Diagrams\n", "abstract": " Nested state diagrams are a commonly accepted design notation for modelling complex software systems at different levels of detail. Besides nesting, other layering mechanisms are needed. However, incremental development of layered state diagrams raises the problem of change management. Changes made at high abstraction layers can have a serious impact on more concrete layers, as conflicts can be introduced that are propagated through all layers. To resolve these conflicts, the methodology of reuse contracts is applied. Carefully choosing a set of incremental modification operators and investigating their interactions allows us to categorise the conflicts. These conflicts can be detected semi-automatically, facilitating incremental design.", "num_citations": "4\n", "authors": ["106"]}
{"title": "On the usage of JavaScript, Python and Ruby packages in Docker Hub images\n", "abstract": " Docker is one of the most popular containerization technologies. A Docker container can be saved into an image including all environmental packages required to run it, such as system and third-party packages from language-specific package repositories. Relying on its modularity, an image can be shared and included in other images to simplify the way of building and packaging new software. However, some package managers allow to include duplicated packages in an image, increasing its footprint; and outdated packages may miss new features and bug fixes or contain reported security vulnerabilities, putting the image in which they are contained at risk. Previous research has focused on studying operating system packages within Docker images, but little attention has been given to third-party packages. This article empirically studies installation practices, outdatedness and vulnerabilities of JavaScript\u00a0\u2026", "num_citations": "3\n", "authors": ["106"]}
{"title": "On the impact of pull request decisions on future contributions\n", "abstract": " The pull-based development process has become prevalent on platforms such as GitHub as a form of distributed software development. Potential contributors can create and submit a set of changes to a software project through pull requests. These changes can be accepted, discussed or rejected by the maintainers of the software project, and can influence further contribution proposals. As such, it is important to examine the practices that encourage contributors to a project to submit pull requests. Specifically, we consider the impact of prior pull requests on the acceptance or rejection of subsequent pull requests. We also consider the potential effect of rejecting or ignoring pull requests on further contributions. In this preliminary research, we study three large projects on \\textsf{GitHub}, using pull request data obtained through the \\textsf{GitHub} API, and we perform empirical analyses to investigate the above questions. Our results show that continued contribution to a project is correlated with higher pull request acceptance rates and that pull request rejections lead to fewer future contributions.", "num_citations": "3\n", "authors": ["106"]}
{"title": "Inter-component dependency issues in software ecosystems\n", "abstract": " Software engineering research has traditionally focused on studying the development and evolution processes of individual software projects. The omnipresence of the Internet gave rise to a wide range of collaborative software development tools, especially in the open-source development scene. This has led to bigger and more geographically distributed communities of developers, and made it possible to develop more complex software systems. It also gave rise to so-called software ecosystems, that is,\u201ccollections of software products that have some given degree of symbiotic relationships\u201d[1]. Analyzing software projects from such an ecosystemic perspective can reveal new insights into why and how they evolve. Projects that are part of an ecosystem tend to be interdependent, and developers contributing to this ecosystem may be involved in multiple projects and share implicit or explicit knowledge across these projects. Hence, the evolution of a project may be affected to a certain degree by the changes in connected projects. This implies that project evolution should be studied in the context of its surrounding ecosystem. This view is shared by Lungu [2], who defined a software ecosystem as \u201ca set of software projects that are developed and evolve together in the same environment.\u201d One of the main reasons for dependencies between components in an ecosystem is software reuse, a basic principle of software engineering [3]. Software components often rely on (ie, reuse) the functionality offered by other components (eg, libraries), rather than reimplementing the same functionality. While this tends to reduce the effort from the point of view of\u00a0\u2026", "num_citations": "3\n", "authors": ["106"]}
{"title": "Using graph transformation to evolve software architectures\n", "abstract": " This volume presents informal pre-proceedings of BENEVOL 2008, the 7 th BElgian-NEtherlands software eVOLution workshop hold in Eindhoven on December 11-12, 2008. The aim of the workshop is to bring researchers to identify and discuss important principles, problems, techniques and results related to software evolution research and practice.", "num_citations": "3\n", "authors": ["106"]}
{"title": "Unanticipated software evolution\n", "abstract": " This workshop was dedicated to research towards better support for unanticipated software evolution (USE) in development tools, programming languages, component models and related runtime infrastructures.The report gives an overview of the submitted papers and summarizes the essence of discussions during plenary sessions and in working groups.", "num_citations": "19\n", "authors": ["106"]}
{"title": "WS 9. The First International Workshop on Unanticipated Software Evolution\n", "abstract": " This workshop was dedicated to research towards better support for unanticipated software evolution (USE) in development tools, programming languages, component models and related runtime infrastructures. The report gives an overview of the submitted papers and summarizes the essence of discussions during plenary sessions and in working groups.", "num_citations": "4\n", "authors": ["106"]}
{"title": "On package freshness in Linux distributions\n", "abstract": " The open-source Linux operating system is available through a wide variety of distributions, each containing a collection of installable software packages. It can be important to keep these packages as fresh as possible to benefit from new features, bug fixes and security patches. However, not all distributions place the same emphasis on package freshness. We conducted a survey in the first half of 2020 with 170 Linux users to gauge their perception of package freshness in the distributions they employ, the value they place on package freshness and the reasons why they do so, and the methods they use to update packages. The results of this survey reveal that, for the aforementioned reasons, keeping packages up to date is an important concern to Linux users and that they install and update packages through their distribution\u2019s official repositories whenever possible, but often resort to third-party repositories and\u00a0\u2026", "num_citations": "2\n", "authors": ["106"]}
{"title": "On the Effect of Discussions on Pull Request Decisions.\n", "abstract": " Open-source software relies on contributions from different types of contributors. Online collaborative development platforms, such as GitHub, usually provide explicit support for these contributions through the mechanism of pull requests, allowing project members and external contributors to discuss and evaluate the submitted code. These discussions can play an important role in the decision-making process leading to the acceptance or rejection of a pull request. We empirically examine in this paper 183K pull requests and their discussions, for almost 4.8 K GitHub repositories for the Cargo ecosystem. We investigate the prevalence of such discussions, their participants and their size in terms of messages and durations, and study how these aspects relate to pull request decisions.", "num_citations": "2\n", "authors": ["106"]}
{"title": "Comparing automated planning approaches for model inconsistency resolution\n", "abstract": " A wide variety of approaches has been proposed to detect and resolve software model inconsistencies. In this article, we present a new type of approach that uses the artificial intelligence technique of automated planning for the purpose of resolving software model inconsistencies. We objectively compare two different variants of automated planning, progression and regression planning, and we discuss how to improve the proposed techniques further.", "num_citations": "2\n", "authors": ["106"]}
{"title": "Am\u00e9lioration de la qualit\u00e9 de modeles: Une \u00e9tude de deux approches compl\u00e9mentaires\n", "abstract": " Une des principales activit\u00e9s de l'IDM est la gestion de l'\u00e9volution de mod\u00e8les. Cette derni\u00e8re a pour principal d\u00e9fi d'arriver \u00e0 pr\u00e9server, voire d'am\u00e9liorer la qualit\u00e9 des mod\u00e8les. Dans la litt\u00e9rature, deux diff\u00e9rentes approches ont \u00e9t\u00e9 propos\u00e9es pour am\u00e9liorer la qualit\u00e9 de mod\u00e8les : la gestion d'incoh\u00e9rences de mod\u00e8les et le refactoring de mod\u00e8les. M\u00eame si ces deux approches ont des objectifs diff\u00e9rents, elles viennent r\u00e9pondre \u00e0 un souci commun : la d\u00e9tection et la r\u00e9solution de d\u00e9fauts trouv\u00e9s dans un mod\u00e8le, le terme d\u00e9faut portant une interpr\u00e9tation diff\u00e9rente pour chacune des deux approches. La gestion d'incoh\u00e9rences de mod\u00e8les et le refactoring de mod\u00e8les s'appuient, pour la plupart des travaux, sur des techniques similaires. Dans cet article, nous \u00e9tudierons et classifierons l'\u00e9tat de l'art en gestiond'incoh\u00e9rences de mod\u00e8les et de refactoring de mod\u00e8les. Nous montrerons que ces deux approches sont\u00a0\u2026", "num_citations": "2\n", "authors": ["106"]}
{"title": "Inconsistency Resolution in Model-Driven Engineering: An approach using Automated Planning\n", "abstract": " In the context of Model-Driven Engineering (MDE), one of the main research challenges is to detect and resolve model inconsistencies in a generic and scaleable way. Various approaches have been explored in the past to address this problem. In this short paper, we outline our novel research that aims to use the technique of automated planning for the purpose of resolving model inconsistencies. Initial results appear promising, but further work is necessary to assess whether the approach scales up and works in practice.", "num_citations": "2\n", "authors": ["106"]}
{"title": "Refactoring des mod\u00e8les: concepts et d\u00e9fis\n", "abstract": " Dans le cadre de l\u2019ing\u00e9nierie dirig\u00e9e par les mod\u00e8les (IDM), l\u2019activit\u00e9 de refactoring des mod\u00e8les est peu \u00e9tudi\u00e9e. Cette activit\u00e9 consiste \u00e0 restructurer un mod\u00e8le pour en am\u00e9liorer ses facteurs de qualit\u00e9, tels que l\u2019adaptabilit\u00e9, la compr\u00e9hensibilit\u00e9 et l\u2019efficacit\u00e9, tout en pr\u00e9servant le comportement de l\u2019application logicielle li\u00e9e \u00e0 ce mod\u00e8le. Avec cet article court, nous structurons le domaine de recherches de refactorings des mod\u00e8les, et nous proposons quelques pistes de travail. Notamment, nous discuterons de la pr\u00e9servation du comportement et de la coh\u00e9rence intra-mod\u00e8le et inter-mod\u00e8les. Nous examinerons \u00e9galement les technologies mises en oeuvre pour la r\u00e9alisation des outils de refactoring des mod\u00e8les.ABSTRACT. In model-driven engineering (MDE), the activity of model refactoring is not sufficiently addressed. Model refactoring aims to improve the structure of a model while preserving the external behaviour and other quality characteristics such as adaptability, understandability and performance. In this short article we shed more light on the current state-of-the-art in this important research domain, and we suggest important avenues of further research.", "num_citations": "2\n", "authors": ["106"]}
{"title": "Graph-transformation based support for model evolution\n", "abstract": " During model-driven software development, we are inevitably confronted with design models that contain a wide variety of design defects. Interactive tool support for improving the model quality by resolving these defects in an automated way is therefore indispensable. In this paper, we report on the development of such a tool, based on the underlying formalism of graph transformation. Due to the fact that the tool is developed as a front-end of the AGG Engine, a general purpose graph transformation engine, it can exploit some of its interesting built-in mechanisms such as critical pair analyis and the ability to reason about sequential dependencies. We explore how this can help to improve the process of quality improvement, and we compare our work with related research.Copyright notice This document is for educational use only. it is meant to serve as reading material for the SegraVis Advanced School on Visual Modelling Techniques. The document is based on a co-authored paper that has been submitted for publication elsewhere. The main difference is that the current versions contains many annotations.", "num_citations": "2\n", "authors": ["106"]}
{"title": "Reducing Network Latency by Application Streaming.\n", "abstract": " In the advent of mobile code, network latency becomes a critical factor. This paper investigates application streaming, a technique that exploits parallelism between loading and execution of mobile code to reduce network latency. It allows applications to migrate from host to host without sacrificing execution time during the migration phase and it allows the application to start its job at the receiving host much earlier. The feasibility of the technique has been validated by implementing prototype tools in Java and the Borg mobile agent environment.", "num_citations": "2\n", "authors": ["106"]}
{"title": "Barcelona, Spain, October 7-8, 2002: Graph-Based Tools (GraBaTs 2002)\n", "abstract": " Graphs are well-known, well-understood, and frequently used means to depict networks of related items. They are successfully used as the underlying mathematical concept in various application domains. In all these domains tools are developed that store, retrieve, manipulate and display graphs as underlying data structures, despite of the fact that in most cases these graphs have a different name such as object diagrams,(meta) class diagrams, hyper documents, semantic webs etc. It is the purpose of this workshop to summarize the state of the art of graph-based tool development, bring together developers of graph-based tools in different application fields and to encourage new tool development cooperations. Motivation Graphs are an obvious means to describe structural aspects in various fields of computer science. They have been successfully used in application areas such as compiler compiler toolkits\u00a0\u2026", "num_citations": "2\n", "authors": ["106"]}
{"title": "Moving code\n", "abstract": " In general, the goal of Advanced \u00cbeparation of Concerns (A\u00cboC) technologies is to provide encapsulations for all kinds of concerns, with a specific focus on cross-cutting concerns. An application is formed by composing these different concerns using some composition mechanism, specifically focused on concern integration and composition. In some cases, however, a specific concern needs to be decomposed in the resulting application. In this paper, we identify a need for decomposition in A\u00cboC technologies, using a case dealing with code movement. We will present an example problem in which adding new code at specific join-points in the code does not suffice to implement a cross-cutting concern dealing with'distribution'.", "num_citations": "2\n", "authors": ["106"]}
{"title": "How magic is zero? an empirical analysis of initial development releases in three software package distributions\n", "abstract": " Distributions of open source software packages dedicated to specific programming languages facilitate software development by allowing software projects to depend on the functionality provided by such reusable packages. The health of a software project can be affected by the maturity of the packages on which it depends. The version numbers of the used package releases provide an indication of their maturity. Packages with a 0. yz version number are commonly assumed to be under initial development, implying that they are likely to be less stable, and depending on them may be less healthy.", "num_citations": "1\n", "authors": ["106"]}
{"title": "On the Usage of Badges in Open Source Packages on GitHub.\n", "abstract": " Continuously attracting contributors is key to the health of open source software projects. The appearance of badges in online collaborative development platforms affords maintainers the opportunity to advertise the quality of their project to potential contributors. In this preliminary research, we analyse 14,592 GitHub package repositories for Cargo and 203,029 repositories for Packagist. We measure how prevalent badges are in those repositories, which badges are used, when and how they are introduced, and which combinations of badges co-occur. We find that the most widespread badges convey static information or relay information about the build status of a project. Those badges are typically added early in projects and prior to or at the same time as other badges.", "num_citations": "1\n", "authors": ["106"]}
{"title": "An empirical comparison of the development history of CloudStack and Eucalyptus\n", "abstract": " Open source cloud computing solutions, such as CloudStack and Eucalyptus, have become increasingly popular in recent years. Despite this popularity, a better understanding of the factors influencing user adoption is still under active research. For example, increased project agility may lead to solutions that remain competitive in a rapidly evolving market, while keeping the software quality under control. Like any software system that is subject to frequent evolution, cloud computing solutions are subject to errors and quality problems, which may affect user experience and require frequent bug fixes. While prior comparisons of cloud platforms have focused most often on their provided services and functionalities, the current paper provides an empirical comparison of CloudStack and Eucalyptus, focusing on quality-related software development aspects. More specifically, we study the change history of the source\u00a0\u2026", "num_citations": "1\n", "authors": ["106"]}
{"title": "Evolution patterns: Designing and reusing architectural evolution knowledge to introduce architectural styles\n", "abstract": " Software architectures are critical in the successful development and evolution of software-intensive systems. While formal and automated support for architectural descriptions has been widely addressed, their evolution is equally crucial, but significantly less well-understood and supported. In order to face a recurring evolution need, we introduce the concept of evolution pattern. It formalises an architectural evolution through both a set of concepts and a reusable evolution process. We propose it through the recurring need of introducing an architectural style on existing software architectures. We formally describe and analyse the feasibility of architectural evolution patterns, and provide a practical validation by implementing them in COSABuilder, an Eclipse plugin for the COSA architectural description language.", "num_citations": "1\n", "authors": ["106"]}
{"title": "Introduction to the special issue on software maintenance and evolution research\n", "abstract": " The past decade has seen tremendous changes in the landscape of software engineering activities in industry and of software engineering research topics in academia. Software engineering activities used to be mostly \u201chidden\u201d behind the closed doors of software industries. In the 1990\u2019s, the emergence of the open-source development model and movement revolutionized software development but also software engineering research. Nowadays, open-source software (OSS) development has become a major source of new libraries and programs, and more and more industries either use OSS or even release OSS themselves. Even large corporations, in which trade secrets were the norm, now consider releasing their source code as open-source, for example Microsoft with its Windows operating system (http://arstechnica. com/information-technology/2015/04/open-source-windows-is-definitely-possible-but-dont\u00a0\u2026", "num_citations": "1\n", "authors": ["106"]}
{"title": "Petrinect: A tool for executable modeling of gestural interaction\n", "abstract": " In this showpiece we demonstrate PetriNect, an instance of a generic layered framework that we have developed for the specification and use of executable models of gestural interaction with virtual objects. The framework is built on top of Petshop and uses ICO models, a variant of high-level Petri nets. PetriNect uses the Kinect as input device for allowing the user to interact gesturally with virtual objects. We present two simple proof-of-concept prototype applications that have been developed for the purpose of this showpiece: a simple Pong game, and the interaction with a virtual bookshelf.", "num_citations": "1\n", "authors": ["106"]}
{"title": "KinectBalls: An Interactive Tool for Ball Throwing Games\n", "abstract": " We present a tool that was developed in the context of the first author\u2019s masters project. The tool implements an interactive computer game combining the real and the virtual world in a seamless way. The player interacts with the game by throwing balls towards a wall on which a virtual 3D scene is projected. Using the Kinect 3D sensor, we compute and predict the trajectory, speed and position of the ball. Upon impact with the screen, a virtual ball continues its trajectory in the virtual scene, and interacts with the objects around it using a physical and a graphical 3D engine Bullet, and Ogre3D. The prototype game has been successfully tested on a large number of people of varying ages.", "num_citations": "1\n", "authors": ["106"]}
{"title": "Towards an empirical analysis of the maintainability of CRAN packages\n", "abstract": " The R ecosystem has been the subject of study by several researchers. In this presentation, we focus on the CRAN archive, containing all packages contributed by R developers. This software ecosystem contains over 5000 packages being actively maintained by over 2500 maintainers. Through an empirical analysis of this ecosystem, we aim to understand the factors that affect the reliability and maintainability of CRAN packages. To do so, we use the built-in and automated CRAN check mechanism that daily checks for different sources of errors in contributed packages. According to the imposed policy, package developers have the obligation to fix these errors, if not their package will get automatically archived after a certain amount of time. Based on an analysis of the package dependencies, characteristics, of the package maintainer and the target platform, we present preliminary results on the sources of errors in each package, and the time needed to fix these errors. With such a study, we aim to get a better insight in the main factors that cause packages to become more reliable, which is not only beneficial to the package maintainer itself, but to the ecosystem as a whole.", "num_citations": "1\n", "authors": ["106"]}
{"title": "CSMR 2009 European Projects Track\n", "abstract": " The European Projects track of CSMR 2009 presents research projects related to the themes of the conference, carried out by a wide variety of European research institutes and companies. It provides an opportunity for researchers involved in these projects to disseminate their objectives, deliverables and outcome. At the same time it allows the CSMR participants to get a better insight in which research projects are currently going on in Europe within the field of software maintenance and reengineering.", "num_citations": "1\n", "authors": ["106"]}
{"title": "Workshop on graph-based tools\n", "abstract": " Graphs are well-known, well-understood, and frequently used means to depict networks of related items. They are successfully used as the underlying mathematical concept in various application domains. In all these domains tools are developed that store, retrieve, manipulate and display graphs. It is the purpose of this workshop to summarize the state of the art of graph-based tool development, bring together developers of graph-based tools in different application fields and to encourage new tool development cooperations.", "num_citations": "1\n", "authors": ["106"]}
{"title": "Proceedings of the Workshop on Formal Foundations of Software Evolution\n", "abstract": " Proceedings of the Workshop on Formal Foundations of Software Evolution \u2014 Vrije Universiteit Brussel Skip to main navigation Skip to search Skip to main content Vrije Universiteit Brussel Logo Help & FAQ English Nederlands Home Research Units Profiles Projects Research output Activities Equipment Prizes Press / Media Student theses Impacts Search by expertise, name or affiliation Proceedings of the Workshop on Formal Foundations of Software Evolution Tom Mens, Michel Wermelinger Vrije Universiteit Brussel Research output: Other contribution Overview Original language English Publisher Workshop on Formal Foundations of Software Evolution Publication status Published - 2001 Bibliographical note Workshop on Formal Foundations of Software Evolution Access to Document ftp://prog.vub.ac.be/tech_report/2001/vub-prog-01-06.pdf Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Mens, \u2026", "num_citations": "1\n", "authors": ["106"]}
{"title": "A basic formalism for systematic software evolution\n", "abstract": " In this extended abstract, we present reuse contracts as a simple but powerful formalism for dealing with software evolution in a systematic way.", "num_citations": "1\n", "authors": ["106"]}
{"title": "Self sends as primary construct: a criterion for object-oriented language design\n", "abstract": " Most object-oriented languages provide a self pseudo variable that serves two purposes: invoking methods through self sends and returning a self reference. Current formal models capture this behaviour by introducing a self parameter that fulfils both roles. We will show that this double functionality is incompatible with object-based encapsulation. Moreover we will point out that the separation of both functionalities is needed in type systems. We propose a formal model based on a primitive self send construct, and present its denotational semantics. A self reference is implemented through a self send instead of the other way around. This model is extended formally with an object-based encapsulation mechanism. It allows us to keep inheritance, encapsulation and typing orthogonal. This way we obtain a flexible and incremental software development scheme.", "num_citations": "1\n", "authors": ["106"]}
{"title": "Scripting Modeling Languages\n", "abstract": " Domain-Independent Models are mainly used for documentation purposes and are most of the time too complex to be directly executed, even by code generation. Domain-Specific Models can sometimes be executed, but their scope is too specific to be reused for other purposes. We propose to develop a mechanism that allows the creation of modeling languages that will be directly executed into software applications. We inspire ourselves from dynamic languages, especially scripting languages, and adapt their approach to models in order to be able to execute models directly, not for an entire application, but for a specific and well-defined part of it. The goal of scripting languages is to raise the level of abstraction of the host language and to delegate some work to an external language. With the help of two concrete examples, we claim that scripting modeling languages can meet this objective better than textual scripting languages and that an application can evolve only by using script models.", "num_citations": "1\n", "authors": ["106"]}