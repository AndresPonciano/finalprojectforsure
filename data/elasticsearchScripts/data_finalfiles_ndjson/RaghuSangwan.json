{"title": "Global software development handbook\n", "abstract": " Economics and technology have dramatically re-shaped the landscape of software development. It is no longer uncommon to find a software development team dispersed across countries or continents. Geographically distributed development challenges the ability to clearly communicate, enforce standards, ensure quality levels, and coordinate tasks. Globa", "num_citations": "307\n", "authors": ["1319"]}
{"title": "Using RFID tags for tracking patients, charts and medical equipment within an integrated health delivery network\n", "abstract": " Tracking patients, charts and equipment in hospitals and across integrated health delivery networks is mostly done manually on white boards or manual entry within health information systems. Some health delivery networks have adopted systems using a combination of infrared and radio frequency (RF) technology to help manage the tracking process. This paper proposes an approach that can improve the operational efficiency of a health delivery network by automating this process through the use of RF identification (RFID) tags. RFID tags are low power communication devices that can be embedded in a patient's ID bracelet, inside a patient chart and medical equipment, and can help track their location and status.", "num_citations": "98\n", "authors": ["1319"]}
{"title": "Cost estimation for global software development\n", "abstract": " Global software development has gathered pace in recent years. Many software projects now involve asynchronous collaboration among geographically distributed teams several time zones apart. Software costestimation for such projects becomes challenging due to factors such as effort expended in team building and knowledge transfer, creating an architecture of the software product that can be easily distributed and that minimizes cross-site communication, facilitating communication among remote teams collaborating on parts of the architecture that are interrelated and their day-to-day governance. In this paper we structure the additional cost drivers of distributed development and examine the significance of each of these factors as a contributor to the overall cost of a software development project. We suggest ways in which COCOMO II, the most widely used software development cost estimation model, can\u00a0\u2026", "num_citations": "57\n", "authors": ["1319"]}
{"title": "Making architecture visible to improve flow management in lean software development\n", "abstract": " Lean practices use the principle of Little's law to improve the flow of value to the end user by eliminating sources of waste from a software development process. Little's law defines throughput as a ratio of work in process and cycle time. Increasing throughput (or productivity) requires continuously improving (that is, decreasing) cycle time while ensuring that the work-in-process limit doesn't exceed the capacity available to process the work. This article shares experiences regarding the role architecture plays in lean software management practices. Release plans that give as much emphasis to architecturally significant tasks as to feature-based high-priority functionality can achieve better outcomes by avoiding conditions that lead to wasted time and effort. The application of lean software development practices can improve with better practical guidance on how to manage architecture flow as well as feature flow.", "num_citations": "45\n", "authors": ["1319"]}
{"title": "Test-driven development in large projects\n", "abstract": " Test-driven development (TDD) is a key practice for agile developers because it involves writing test cases ahead of the code, which can improve design. The TDD process works well for projects in which a collocated team develops a small to medium system, but it can be challenging for large systems, especially those involving geographically distributed teams. The main obstacle is the degree of integration: when the team must integrate many individual classes developed at distributed sites, the coordination and communication grows exponentially with the number of individual developers and sites. This does not mean that TDD is ineffective for large-scale geographically distributed projects, but developers must take care to account for its focus on unit testing and its failure to rigorously address communications issues during system and integration testing. In this article, suggestions to scale up TDD are presented\u00a0\u2026", "num_citations": "45\n", "authors": ["1319"]}
{"title": "Structural epochs in the complexity of software over time\n", "abstract": " A case study using a new complexity measurement framework called Structure 101 tracked the structural complexity of three open source software products through their different releases. The analysis found that, as these software products evolved, a large proportion of structural complexity in early releases at the application-code level progressively migrated to higher-level design and architectural elements in subsequent releases, or vice-versa. This pattern repeated itself throughout the evolution of the software product. Refactoring efforts successfully reduced complexity at lower levels, but shifted the complexity to higher levels in the design hierarchy. Conversely, design restructuring at higher levels shifted complexity to lower levels. If this trend holds true for other software products, then mere code refactoring might not be enough to effectively managing structural complexity. Periodic major restructuring of\u00a0\u2026", "num_citations": "34\n", "authors": ["1319"]}
{"title": "Integrating a software architecture-centric method into object-oriented analysis and design\n", "abstract": " The choice of methodology for the development of the architecture for software systems has a direct effect on the suitability of that architecture. If the development process is driven by the user\u2019s functional requirements, we would expect the architecture to appropriately reflect those requirements. We would also expect other aspects not captured in the functional specification to be absent from the architecture. The same phenomenon is true in development approaches that stress the importance of systemic quality attributes or other non-functional requirements; those requirements are prominent in the resulting architecture, while other requirement types not stressed by the approach are absent. In other words, the final architecture reflects the focus of the development approach. An ideal approach, therefore, is one that incorporates all goals, expectations, and requirements: both business and technical. To accomplish\u00a0\u2026", "num_citations": "33\n", "authors": ["1319"]}
{"title": "A system for program visualization in the classroom\n", "abstract": " This paper describes the use of a system which will allow effortless visualization and animation of standard C/C++ programs. The system brings alive programs so that students in CS 1 and CS 2 classes can more easily see each instruction and its effects. They can also see the effects of larger entities such as functions. The system serves as an excellent instructional tool and debugger.", "num_citations": "31\n", "authors": ["1319"]}
{"title": "A visual interface for effortless animation of C/C++ programs\n", "abstract": " This paper introduces a software visualization system that (i) creates animations of programs without the programmer writing any animation code, and (ii) provides a window interface that automatically displays program information, explicitly showing the scope and context of its data, and allowing considerable control over animation displays. Programs are specified in textual form but the system creates high-level dynamic displays using bit-mapped graphics and window-interface technology. The dynamics of the displays make a program come to life. The current system was designed primarily for use in CS-I and CS-II courses. Therefore, it assumes that programs will use acyclic linked data structures and relatively small data sets. It provides the programmer no control over the animations and only limited control over the layout. However, we feel this is a reasonable trade-off for the ease of use the system provides.", "num_citations": "29\n", "authors": ["1319"]}
{"title": "Architecture leadership and management in globally distributed software development\n", "abstract": " Globally distributed software development is inherently difficult. The fundamental problem is that communication, coordination and control mechanisms that operate so naturally and invisibly in co-located projects are not available or not as effective for distributed teams. Maintaining a shared up-to-date understanding of the system under design among distributed teams separated by physical, temporal, and cultural distances, therefore, becomes challenging. Under such circumstances the role of a project architect takes on an added significance. The architect must bridge the gaps that exist among the distributed teams especially those with interrelated tasks. Bridging gaps across teams requires proactive effort to create, among distributed teams, a shared level of understanding of the system context, its problem domain and an overarching vision of the system to be designed. We call this a shared project context\u00a0\u2026", "num_citations": "21\n", "authors": ["1319"]}
{"title": "Web app security: A comparison and categorization of testing frameworks\n", "abstract": " Web app developers often face challenges in using the many available security-testing frameworks, owing to those frameworks' inherent complexity and the lack of proper documentation. No up-to-date criteria exist that can help practitioners and organizations select an appropriate framework. Consequently, numerous vulnerabilities go undetected in the final product, creating a potential for major attacks. To help practitioners select the right framework, researchers classified 26 frameworks, using 27 criteria.", "num_citations": "19\n", "authors": ["1319"]}
{"title": "Adoption of XP practices in the industry\u2014A survey\n", "abstract": " Agile software development has recently become popular in the software industry. The methodologies in the Agile family are considered to be based on best practices. The most popular approach, Extreme Programming (XP), recommends certain best practices during the requirements gathering, implementation and testing phases of software development. In this paper, the authors analyze the best practices according to data from recent case studies and survey studies to see if and how they are followed. Metaphor was the least used practice, while unit testing was one of the most popular. Most of the practices varied across studies and projects. Agile software development is evolutionary in nature, so customizing the practices is still well within its sounds. Copyright \u00a9 2007 John Wiley & Sons, Ltd.", "num_citations": "19\n", "authors": ["1319"]}
{"title": "Architectural dependency analysis to understand rework costs for safety-critical systems\n", "abstract": " To minimize testing and technology upgrade costs for safety-critical systems, a thorough understanding and analysis of architectural dependencies is essential. Unmanaged dependencies create cost overruns and degraded qualities in systems. Architecture dependency analysis in practice, however, is typically performed in retrospect using code structures, the runtime image of a system, or both. Retrospective analysis can miss important dependencies that surface earlier in the life cycle. Development artifacts such as the software architecture description and the software requirements specification can augment the analysis process; however, the quality, consistency, and content of these artifacts vary widely. In this paper, we apply a commonly used dependency analysis metric, stability, and a visualization technique, the dependency structure matrix, to an architecture common to safety-critical systems that was re\u00a0\u2026", "num_citations": "14\n", "authors": ["1319"]}
{"title": "How business goals drive architectural design\n", "abstract": " This paper illustrates how business goals can significantly impact a software management system's architecture without necessarily affecting its functionality. These goals include 1) supporting hardware devices from different manufacturers, 2) considering language, culture, and regulations of different markets, 3) assessing tradeoffs and risks to determine how the product should support these goals, 4) refining goals such as scaling back on intended markets, depending on the company's comfort level with the tradeoffs and risks. More importantly, these business goals correspond to quality attributes the end system must exhibit. The system must be modifiable to support a multitude of hardware devices and consider different languages and cultures. Supporting different regulations in different geographic markets requires the system to respond to life-threatening events in a timely manner performance requirement.", "num_citations": "14\n", "authors": ["1319"]}
{"title": "Software and systems architecture in action\n", "abstract": " Modern-day projects require software and systems engineers to work together in realizing architectures of large and complex software-intensive systems. To date, the two have used their own tools and methods to deal with similar issues when it comes to the requirements, design, testing, maintenance, and evolution of these architectures. Software and Systems Architecture in Action explores practices that can be helpful in the development of architectures of large-scale systems in which software is a major component. Examining the synergies that exist between the disciplines of software and systems engineering, it presents concepts, techniques, and methods for creating and documenting architectures. The book describes an approach to architecture design that is driven from systemic quality attributes determined from both the business and technical goals of the system, rather than just its functional requirements. This architecture-centric design approach utilizes analytically derived patterns and tactics for quality attributes that inform the architect\u2019s design choices and help shape the architecture of a given system. The book includes coverage of techniques used to assess the impact of architecture-centric design on the structural complexity of a system. After reading the book, you will understand how to create architectures of systems and assess their ability to meet the business goals of your organization. Ideal for anyone involved with large and complex software-intensive systems, the book details powerful methods for engaging the software and systems engineers on your team. The book is also suitable for use in undergraduate and graduate\u00a0\u2026", "num_citations": "13\n", "authors": ["1319"]}
{"title": "K-means clustering and principal components analysis of microarray data of L1000 landmark genes\n", "abstract": " Dimensionality reduction methods such as principal component analysis (PCA) are used to select relevant features, and k-means clustering performs well when applied to data with low effective dimensionality. This study integrated PCA and k-means clustering using the L1000 dataset, containing gene microarray data from 978 landmark genes, which have been previously shown to predict expression of ~81% of the remaining 21,290 target genes with low error. Groups within the L1000 dataset were characterized using both microarray and clinical metadata to assess whether 978 landmark genes would improve clustering results, compared to a random set of 978 genes. The role of clinical variables, including morphological diagnosis, were assessed across k-means clustering groups within homogeneous tissue samples in the L1000 dataset. Results show that the 978 landmark genes better differentiated k-means\u00a0\u2026", "num_citations": "12\n", "authors": ["1319"]}
{"title": "Structural complexity in architecture-centric software evolution\n", "abstract": " In a previous Computer column, \"How Business Goals Drive Architectural Design\" (Aug. 2007, pp. 101-103), an architecture-centric approach to software design in which the final architecture embodies the systemic properties and nonfunctional requirements that are critical to the application's success was proposed. Here, it is considered whether such an approach produces systems that are subsequently easier to evolve. Using an Internet-based collaborative system and its whiteboard subsystem as an example, it is shown that architecture-centric methods can result in a significantly improved system that not only meets its quality expectations but is not excessively complex.", "num_citations": "11\n", "authors": ["1319"]}