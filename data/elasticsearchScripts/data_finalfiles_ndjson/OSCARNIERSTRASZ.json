{"title": "Context-oriented programming\n", "abstract": " Context-dependent behavior is becoming increasingly important for a wide range of application domains, from pervasive computing to common business applications. Unfortunately, mainstream programming languages do not provide mechanisms that enable software entities to adapt their behavior dynamically to the current execution context. This leads developers to adopt convoluted designs to achieve the necessary runtime flexibility. We propose a new programming technique called Context-oriented Programming (COP) which addresses this problem. COP treats context explicitly, and provides mechanisms to dynamically adapt behavior in reaction to changes in context, even after system deployment at runtime. In this paper we lay the foundations of COP, show how dynamic layer activation enables multi-dimensional dispatch, illustrate the application of COP by examples in several language extensions, and demonstrate that COP is largely independent of other commitments to programming style.", "num_citations": "646\n", "authors": ["104"]}
{"title": "Traits: Composable Units of Behavior\n", "abstract": " Despite the undisputed prominence of inheritance as the fundamental reuse mechanism in object-oriented programming languages, the main variants\u2014single inheritance, multiple inheritance, and mixin inheritance\u2014all suffer from conceptual and practical problems. In the first part of this paper, we identify and illustrate these problems. We then present traits, a simple compositional model for structuring object-oriented programs. A trait is essentially a group of pure methods that serves as a building block for classes and is a primitive unit of code reuse. In this model, classes are composed from a set of traits by specifying glue code that connects the traits together and accesses the necessary state. We demonstrate how traits overcome the problems arising from the different variants of inheritance, we discuss how traits can be implemented effectively, and we summarize our experience applying traits to refactor\u00a0\u2026", "num_citations": "537\n", "authors": ["104"]}
{"title": "Regular types for active objects\n", "abstract": " Previous work on type-theoretic foundations for object-oriented programming languages has mostly focussed on applying or extending functional type theory to functional \u201cobjects.\u201cThis approach, while benefitting from a vast body of existing literature, has the disadvantage of dealing with state change either in a roundabout way or not at all, and completely side-stepping issues of concurrency. In particular, dynamic issues of non-uniform service availability and conformance to protocols are not addressed by functional types. We propose a new type framework that characterizes objects as regular (finite state) processes that provide guarantees of service along public channels. We also propose an original notion of subtyping for regular types that extends Wegner and Zdonik\u2019s \u201cprinciple of substitutability\u201d to non-uniform service availability, and we relate it to known process equivalences. Finally, we formalize what it\u00a0\u2026", "num_citations": "479\n", "authors": ["104"]}
{"title": "Component-oriented software development\n", "abstract": " Despite the contributions of object-oriented technology, there are several open research problems that must be resolved to reach the goal of effective componentoriented development. First, object-oriented mechanisms for composition and reuse must be cleanly integrated with other features, such as concurrency, persistence and distribution. Second, effective reuse of software presupposes the existence of tools to support the organization and retrieval of components according to application requirements, and the interactive construction of running applications from components. Third, since the design of reusable frameworks is an iterative, evolutionary process, it is necessary to manage software and software information in such a way that designs and implementations can evolve gracefully.", "num_citations": "277\n", "authors": ["104"]}
{"title": "A Survey of Object-Oriented Concepts.\n", "abstract": " The object-oriented paradigm has gained popularity in various guises not only in programming languages, but in user interfaces, operating systems, databases, and other areas. We argue that the fundamental object-oriented concept is encapsulation, and that all object-oriented mechanisms and approaches exploit this idea to various ends. We introduce the most important of these mechanisms as they are manifested in existing object-oriented systems, and we discuss their relevance in the context of modern application development.", "num_citations": "261\n", "authors": ["104"]}
{"title": "Active objects in Hybrid\n", "abstract": " Most object-oriented languages are strong on reusability or on strong-typing, but weak on concurrency. In response to this gap, we are developing Hybrid, an object-oriented language in which objects are the active entities. Objects in Hybrid are organized into domains, and concurrent executions into activities. All object communications are based on remote procedure-calls. Unstructured sends and accepts are forbidden. To this the mechanisms of delegation and delay queues are added to enable switching and triggering of activities. Concurrent subactivities and atomic actions provided for compactness and simplicity. We show how solutions to many important concurrent problems, such a pipelining, constraint management and \u201cadministration\u201d can be compactly expressed using these mechanisms.", "num_citations": "218\n", "authors": ["104"]}
{"title": "Research directions in software composition\n", "abstract": " Software composition is the construction of software applications from components that implement abstractions pertaining to a particular problem domain. Raising the level of abstraction is a time-honored way of dealing with complexity, but the real benefit of composable software systems lies in their increased flexibility: a system built from components should be easy to recompose to address new requirements[Nierstrasz and Dami 1995]. A certain amount of success has been are powerful, not because they provide libraries of reusable object classes, but because they define the responsibilities, the collaborations, and the interfaces of the fundamental objects of a system; that is, because they define generic software architectures.", "num_citations": "216\n", "authors": ["104"]}
{"title": "Component-oriented software technology\n", "abstract": " Modern software systems are increasingly required to be open and distributed. Such systems are open not only in terms of network connections and interoperability support for heterogeneous hardware and software platforms, but, above all, in terms of evolving and changing requirements. Although object-oriented technology offers some relief, to a large extent the languages, methods and tools fail to address the needs of open systems because they do not escape from traditional models of software development that assume system requirements to be closed and stable. We argue that open systems requirements can only be adequately addressed by adopting a component-oriented as opposed to a purely object-oriented software development approach, by shifting emphasis away from programming and towards generalized software composition.", "num_citations": "196\n", "authors": ["104"]}
{"title": "Class management for software communities\n", "abstract": " Object-oriented programming may engender an approach to software development characterized by the large-scale reuse of object classes. Large-scale reuse is the use of a class not just by its original developers, but by other developers who may be from other organizations, and may use the classes over a long period of time. Our hypothesis is that the successful dissemination and reuse of classes requires a well-organized community of developers who are ready to share ideas, methods, tools and code. Furthermore, these communities should be supported by software information systems which manage and provide access to class collections. In the following sections we motivate the need for software communities and software information systems. The bulk of this article discusses various issues associated with managing the very large class collections produced and used by these communities.", "num_citations": "172\n", "authors": ["104"]}
{"title": "Requirements for a composition language\n", "abstract": " The key requirement for open systems is that they be flexible, or recomposable. This suggests that they must first of all be composable. Object-oriented techniques help by allowing applications to be viewed as compositions of collaborating objects, but are limited in supporting other kinds of abstractions that may have finer or coarser granularity than objects. A composition language supports the technical requirements of a componentoriented development approach by shifting emphasis from programming and inheritance of classes to specification and composition of components. Objects are viewed as processes, and components are abstractions over the object space. An application is viewed as an explicit composition of software components. By making software architectures explicit and manipulable, we expect to better support application evolution and flexibility. In this position paper we will elaborate our\u00a0\u2026", "num_citations": "157\n", "authors": ["104"]}
{"title": "A component model for field devices\n", "abstract": " Component-based software development is becoming mainstream for conventional applications. However, components can be difficult to deploy in embedded systems because of non-functional requirements. Pecos is a collaborative project between industrial and research partners that seeks to enable component-based technology for a class of embedded systems known as \u201cfield devices\u201d. In this paper we introduce a component model for field devices that captures a range of non-functional properties and constraints.", "num_citations": "147\n", "authors": ["104"]}
{"title": "The effect of object-oriented frameworks on developer productivity\n", "abstract": " Cost and time estimation are difficult problems in software development projects. Software metrics tackle this problem by assuming a statistical correlation between the size of a software project and the amount of effort typically required to realize it. To be useful in estimating cost, a size metric must take into account the inherent complexity of the system. Such metrics have been applied with varying degrees of success, but the nature of software development has been changing, and some of the assumptions behind the established cost-estimation techniques are slowly being invalidated. The System Meter (SM) is a new software sizing approach based on the notion of system description. System descriptions encompass all kinds of software artifacts, from requirement documents to final code. For each kind or level of artifacts, there is a corresponding flavor of SM. In our studies we used the first operational flavor, the\u00a0\u2026", "num_citations": "145\n", "authors": ["104"]}
{"title": "Piccola \u2014\u00a0A Small Composition Language\n", "abstract": " Component-based software development offers a plausible solution to one of the toughest and most persistent problems in software engineering: how to effectively maintain software systems in the face of changing and evolving requirements. Soft-ware systems, instead of being programmed in the conventional sense, are con-structed and configured using libraries of components. Applications can be adapted to changing requirements by reconfiguring components, adapting existing compo-nents or introducing new ones.We argue that the flexibility and adaptability needed for component-based applications to cope with changing requirements can be enhanced substantially if we think not only in terms of components, but also in terms of architectures, scripts, coordination and glue. In particular, we claim that application development is best supported by consciously applying the paradigm", "num_citations": "135\n", "authors": ["104"]}
{"title": "Components, scripts and glue\n", "abstract": " Experience has shown us that object-oriented technology alone is not enough to guarantee that the systems we develop will be flexible and adaptable. Even \u201cwell-designed\u201d object-oriented software may be difficult to understand and adapt to new requirements. We propose a conceptual framework that will help yield more flexible object-oriented systems by encouraging explicit separation of computational and compositional elements. We distinguish between components that adhere to an architectural style, scripts that specify compositions, and glue that may be needed to adapt components\u2019 interfaces and contracts. We also discuss a prototype of an experimental composition language called PICCOLA that attempts to combine proven ideas from scripting languages, coordination models and languages, glue techniques, and architectural specification", "num_citations": "135\n", "authors": ["104"]}
{"title": "On the effectiveness of clone detection by string matching\n", "abstract": " Although duplicated code is known to pose severe problems for software maintenance, it is difficult to identify in large systems. Many different techniques have been developed to detect software clones, some of which are very sophisticated, but are also expensive to implement and adapt. Lightweight techniques based on simple string matching are easy to implement, but how effective are they? We present a simple string\u2010based approach which we have successfully applied to a number of different languages such COBOL, JAVA, C++, PASCAL, PYTHON, SMALLTALK, C and PDP\u201011 ASSEMBLER. In each case the maximum time to adapt the approach to a new language was less than 45 minutes. In this paper we investigate a number of simple variants of string\u2010based clone detection that normalize differences due to common editing operations, and assess the quality of clone detection for very different case\u00a0\u2026", "num_citations": "127\n", "authors": ["104"]}
{"title": "Practical object-oriented back-in-time debugging\n", "abstract": " Back-in-time debuggers are extremely useful tools for identifying the causes of bugs. Unfortunately the \u201comniscient\u201d approaches that try to remember all previous states are impractical because they consume too much space or they are far too slow. Several approaches rely on heuristics to limit these penalties, but they ultimately end up throwing out too much relevant information. In this paper we propose a practical approach that attempts to keep track of only the relevant data. In contrast to other approaches, we keep object history information together with the regular objects in the application memory. Although seemingly counter-intuitive, this approach has the effect that data not reachable from current application objects (and hence, no longer relevant) is garbage collected. We describe the technical details of our approach, and we present benchmarks that demonstrate that memory consumption stays\u00a0\u2026", "num_citations": "123\n", "authors": ["104"]}
{"title": "KNOs: KNowledge acquisition, dissemination, and manipulation Objects\n", "abstract": " Most object-oriented systems lack two useful facilities: the ability of objects to migrate to new environments and the ability of objects to acquire new operations dynamically. This paper proposes Knos, an object-oriented environment that supports these actions. Knos' operations, data structures, and communication mechanisms are discussed. Knos objects \u201clearn\u201d by exporting and importing new or modified operations. The use of such objects as intellectual support tools is outlined. In particular, various applications involving cooperation, negotiation, and apprenticeship among objects are described.", "num_citations": "111\n", "authors": ["104"]}
{"title": "Context-oriented programming: beyond layers\n", "abstract": " While many software systems today have to be aware of the context in which they are executing, there is still little support for structuring a program with respect to context. A first step towards better context-orientation was the introduction of method layers. This paper proposes two additional language concepts, namely the implicit activation of method layers, and the introduction of dynamic variables.", "num_citations": "105\n", "authors": ["104"]}
{"title": "Composing active objects\n", "abstract": " Many of the shortcomings of present-day object-oriented programming languages can be traced to two phenomena:(i) the lack of general support for software composition, and (ii) the semantic interference between language features addressing operational and compositional aspects of object-oriented programming. To remedy this situation, we propose the development of a \u201cpattern language\u201d for active objects in which objects and, more generally, applications, are constructed by composing software patterns. A \u201cpattern\u201d can be any reusable software abstraction, including functions, objects, classes and generics. In this paper we seek to establish both informal requirements for a pattern language and a formal basis for defining the semantics of patterns. First, we identify some basic requirements for supporting object composition and we review the principal language design choices with respect to these requirements. We then survey the various problems of semantic interference in existing languages. Next, we present a formal \u201cobject calculus\u201d and show how it can be used to define the semantics of patterns in much the same way that the \u03bb calculus can be used to give meaning to constructs of functional programming languages. We conclude by summarizing the principle open problems that remain to define a practical pattern language for active objects.", "num_citations": "98\n", "authors": ["104"]}
{"title": "Viewing object as patterns of communicating agents\n", "abstract": " Following our own experience developing a concurrent object-oriented language as well of that of other researchers, we have identified several key problems in the design of a concurrency model compatible with the mechanisms of object-oriented programming. We propose an approach to language design in which an executable notation describing the behaviour of communicating agents is extended by syntactic patterns that encapsulate language constructs. We indicate how various language models can be accommodated, and how mechanisms such as inheritance can be modeled. Finally, we introduce a new notion of types that characterizes concurrent objects in terms of their externally visible behaviour.", "num_citations": "98\n", "authors": ["104"]}
{"title": "Applications= components+ scripts\n", "abstract": " Piccola is a language for composing applications from software components. It has a small syntax and a minimal set of features needed for specifying different styles of software composition. The core features of Piccola are communicating agents, which perform computations, and forms, which are the communicated values. Forms are a special notion of extensible, immutable records. Forms and agents allow us to unify components, static and dynamic contexts and arguments for invoking services. Through a series of examples, we present a tour of Piccola, illustrating how forms and agents suffice to express a variety of compositional abstractions and styles.", "num_citations": "93\n", "authors": ["104"]}
{"title": "Towards an object calculus\n", "abstract": " The development of concurrent object-based programming languages has suffered from the lack of any generally accepted formal foundations for defining their semantics. Furthermore, the delicate relationship between object-oriented features supporting reuse and operational features concerning interaction and state change is poorly understood in a concurrent setting. To address this problem, we propose the development of an object calculus, borrowing heavily from relevant work in the area of process calculi. To this end, we briefly review some of this work, we pose some informal requirements for an object calculus, and we present the syntax, operational semantics and use through examples of a proposed object calculus, called OC.", "num_citations": "93\n", "authors": ["104"]}
{"title": "Beyond objects: components\n", "abstract": " Traditional software development approaches do not cope well with the evolving requirements of open systems. We argue that such systems are best viewed as flexible compositions of \u201csoftware components\u201d designed to work together as part of a component framework that formalizes a class of applications with a common software architecture. To enable such a view of software systems, we need appropriate support from programming language technology, software tools, and methods. We will briefly review the current state of object-oriented technology, insofar as it supports component-oriented development, and propose a research agenda of topics for further investigation. 3", "num_citations": "88\n", "authors": ["104"]}
{"title": "Objects + scripts = applications\n", "abstract": " We argue that object-oriented programming is only half of the story. Flexible, configurable applications can be viewed as collections of reusable objects conforming to standard interfaces together with scripts that bind these objects together to perform certain tasks. Scripting encourages a component-oriented approach to application development in which frameworks of reusable components (objects and scripts) are carefully engineered in an evolutionary software life-cycle, with the ultimate goal of supporting application construction largely from these interchangeable, prefabricated components. The activity of constructing the running application is supported by a visual scripting tool that replaces the textual paradigm of programming with a visual paradigm of direct manipulation and editing of both application and user interface components. We present scripting by means of some simple examples, and we describe a prototype of a visual scripting tool, called Vista. We conclude with some observations on the environmental support needed to support a component-oriented software life-cycle, using as a specific example the application development environment of ITHACA, a large European project of which Vista is a part.", "num_citations": "85\n", "authors": ["104"]}
{"title": "A formal language for composition\n", "abstract": " A composition language based on a formal semantic foundation will facilitate pre-cise specification of glue abstractions and compositions, and will support reasoning about their behavior. The semantic foundation, however, must address a set of requirements like encapsulation, objects as processes, components as abstractions, plug compatibility, a formal object model, and scalability. In this work, we propose the a L-calculus, an extension of the 7-calculus, as a formal foundation for software composition, define a language in terms of it, and illustrate how this language can be used to plug components together.", "num_citations": "78\n", "authors": ["104"]}
{"title": "Embedding languages without breaking tools\n", "abstract": " Domain-specific languages (DSLs) are increasingly used as embedded languages within general-purpose host languages. DSLs provide a compact, dedicated syntax for specifying parts of an application related to specialized domains. Unfortunately, such language extensions typically do not integrate well with the development tools of the host language. Editors, compilers and debuggers are either unaware of the extensions, or must be adapted at a non-trivial cost. We present a novel approach to embed DSLs into an existing host language by leveraging the underlying representation of the host language used by these tools. Helvetia is an extensible system that intercepts the compilation pipeline of the Smalltalk host language to seamlessly integrate language extensions. We validate our approach by case studies that demonstrate three fundamentally different ways to extend or adapt the host language\u00a0\u2026", "num_citations": "72\n", "authors": ["104"]}
{"title": "Software cartography: Thematic software visualization with consistent layout\n", "abstract": " Software visualizations can provide a concise overview of a complex software system. Unfortunately, as software has no physical shape, there is no \u2018natural\u2019 mapping of software to a two\u2010dimensional space. As a consequence most visualizations tend to use a layout in which position and distance have no meaning, and consequently layout typically diverges from one visualization to another. We propose an approach to consistent layout for software visualization, called Software Cartography, in which the position of a software artifact reflects its vocabulary, and distance corresponds to similarity of vocabulary. We use Latent Semantic Indexing (LSI) to map software artifacts to a vector space, and then use Multidimensional Scaling (MDS) to map this vector space down to two dimensions. The resulting consistent layout allows us to develop a variety of thematic software maps that express very different aspects of\u00a0\u2026", "num_citations": "65\n", "authors": ["104"]}
{"title": "Back to the future in one week\u2014implementing a Smalltalk VM in PyPy\n", "abstract": " We report on our experiences with the Spy project, including implementation details and benchmark results. Spy is a re-implementation of the Squeak (i.e. Smalltalk-80) VM using the PyPy toolchain. The PyPy project allows code written in RPython, a subset of Python, to be translated to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters can be derived from one abstract interpreter definition. Spy aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current Spy codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk VMs, but which still run slower than in Squeak itself. Spy was built from\u00a0\u2026", "num_citations": "64\n", "authors": ["104"]}
{"title": "Consistent layout for thematic software maps\n", "abstract": " Software visualizations can provide a concise overview of a complex software system. Unfortunately, since software has no physical shape, there is no ``natural'' mapping of software to a two-dimensional space. As a consequence most visualizations tend to use a layout in which position and distance have no meaning, and consequently layout typical diverges from one visualization to another. We propose a consistent layout for software maps in which the position of a software artifact reflects its vocabulary, and distance corresponds to similarity of vocabulary. We use latent semantic indexing (LSI) to map software artifacts to a vector space, and then use multidimensional scaling (MDS) to map this vector space down to two dimensions.The resulting consistent layout allows us to develop a variety of thematic software maps that express very different aspects of software while making it easy to compare them. The\u00a0\u2026", "num_citations": "59\n", "authors": ["104"]}
{"title": "Encapsulating and exploiting change with changeboxes\n", "abstract": " Real world software systems change continuously to meet new demands. Most programming languages and development environments, however, are more concerned with limiting the effects of change rather than enabling and exploiting change. Various techniques and technologies to exploit change have been developed over the years, but there exists no common support for these approaches. We propose Changeboxes as a general-purpose mechanism for encapsulating change as a first-class entity in a running software system. Changeboxes support multiple, concurrent and possibly inconsistent views of software artifacts within the same running system. Since Changeboxes are first-class, they can be manipulated to control the scope of change in a running system. Furthermore, Changeboxes capture the semantics of change. Changeboxes can be used, for example, to encapsulate refactorings, or to replay\u00a0\u2026", "num_citations": "59\n", "authors": ["104"]}
{"title": "The programming language Ada reference manual\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "57\n", "authors": ["104"]}
{"title": "Augmenting static source views in IDEs with dynamic metrics\n", "abstract": " Mainstream IDEs such as Eclipse support developers in managing software projects mainly by offering static views of the source code. Such a static perspective neglects any information about runtime behavior. However, object-oriented programs heavily rely on polymorphism and late-binding, which makes them difficult to understand just based on their static structure. Developers thus resort to debuggers or profilers to study the system's dynamics. However, the information provided by these tools is volatile and hence cannot be exploited to ease the navigation of the source space. In this paper we present an approach to augment the static source perspective with dynamic metrics such as precise runtime type information, or memory and object allocation statistics. Dynamic metrics can leverage the understanding for the behavior and structure of a system. We rely on dynamic data gathering based on aspects to\u00a0\u2026", "num_citations": "51\n", "authors": ["104"]}
{"title": "A calculus for modeling software components\n", "abstract": " Many competing definitions of software components have been proposed over the years, but still today there is only partial agreement over such basic issues as granularity (are components bigger or smaller than objects, packages, or application?), instantiation (do components exist at run-time or only at compile-time?), and state (should we distinguish between components and \u201cinstances\u201d of components?). We adopt a minimalist view in which components can be distinguished by composable interfaces. We have identified a number of key features and mechanisms for expressing composable software, and propose a calculus for modeling components, based on the asynchronous \u03c0 calculus extended with explicit namespaces, or \u201cforms\u201d. This calculus serves as a semantic foundation and an executable abstract machine for Piccola, an experimental composition language. The calculus also enables\u00a0\u2026", "num_citations": "49\n", "authors": ["104"]}
{"title": "Application development through reuse: the ITHACA tools environment\n", "abstract": " This paper presents the architecture and basic features of the ITHACA Application Development Environment based on a Software Information System for enhancing reusability of both software components and artifacts about development of these components. Object-oriented techniques are used in the Environment at all levels of the development of an application: requirement specification, scripting, implementation through class refinement and tailoring. In the Environment, it is tracked how the various products of the development phases were produced by providing tools for the Application Engineer who is responsible for abstracting application skeletons and development information and storing these as Application Frames into a Software Information Base. In particular, the paper describes the Requirement Collection And Specification Tool (RECAST) and the Visual Scripting Tool (Vista) of the ITHACA\u00a0\u2026", "num_citations": "49\n", "authors": ["104"]}
{"title": "Exploiting dynamic information in IDEs improves speed and correctness of software maintenance tasks\n", "abstract": " Modern IDEs such as Eclipse offer static views of the source code, but such views ignore information about the runtime behavior of software systems. Since typical object-oriented systems make heavy use of polymorphism and dynamic binding, static views will miss key information about the runtime architecture. In this paper, we present an approach to gather and integrate dynamic information in the Eclipse IDE with the goal of better supporting typical software maintenance activities. By means of a controlled experiment with 30 professional developers, we show that for typical software maintenance tasks, integrating dynamic information into the Eclipse IDE yields a significant 17.5 percent decrease of time spent while significantly increasing the correctness of the solutions by 33.5 percent. We also provide a comprehensive performance evaluation of our approach.", "num_citations": "48\n", "authors": ["104"]}
{"title": "The moldable debugger: A framework for developing domain-specific debuggers\n", "abstract": " Debuggers are crucial tools for developing object-oriented software systems as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to explore and exhibit the execution stack and system state, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort. To reduce this gap, we propose a framework for developing domain-specific debuggers called the Moldable Debugger. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations\u00a0\u2026", "num_citations": "47\n", "authors": ["104"]}
{"title": "A system for managing structured messages\n", "abstract": " Message systems send and receive messages but do not manage the information the messages contain. Database management systems manage the information of a global database but do not have a notion of address. In this paper the authors outline a prototype system which integrates the facilities of message systems and database management systems. The system manages structured messages according to their contents. The messages can be stored within a station and transferred between stations. Information present in the messages can be queried in a distributed manner. Message structure can also be exploited by automatic procedures which recognize triggering conditions and perform user specified actions.", "num_citations": "47\n", "authors": ["104"]}
{"title": "Towards a formal composition language\n", "abstract": " When do we call a software development environment a composition environment? A composition environment must be built of three parts: i) a reusable component library, ii) a component framework determining the software architecture, and iii) an open and flexible composition language. Most of the effort in component technology was spent on the first two parts. Now it is crucial to address the last part and find an appropriate model to glue existing components together. In this work, we investigate existing component and glue models, define a set of requirements a composition language must fulfill, and report our first results using a prototype implementation of a general-purpose composition language based on the \u03c0-calculus.", "num_citations": "46\n", "authors": ["104"]}
{"title": "Tracking objects to detect feature dependencies\n", "abstract": " The domain-specific ontology of a software system includes a set of features and their relationships. While the problem of locating features in object-oriented programs has been widely studied, runtime dependencies between features are less well understood. Features cannot be understood in isolation, since their behavior often depends on objects created and referenced in previously exercised features. It is difficult to spot runtime dependencies between features just by browsing source code. Hence, code modifications intended for one feature, often inadvertently affect other features. In this paper, we propose an approach to precisely identify dependencies between features based on a fine-grained dynamic analysis which captures details about how objects are referenced at runtime. The results of two case studies indicate that our approach helps software maintainers in understanding critical feature dependencies.", "num_citations": "45\n", "authors": ["104"]}
{"title": "Practical domain-specific debuggers using the Moldable Debugger framework\n", "abstract": " Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the\u00a0\u2026", "num_citations": "43\n", "authors": ["104"]}
{"title": "Fitting round objects into square databases\n", "abstract": " Object-oriented systems could use much of the functionality of database systems to manage their objects. Persistence, object identity, storage management, distribution and concurrency control are some of the things that database systems traditionally handle well. Unfortunately there is a fundamental difference in philosophy between the object-oriented and database approaches, namely that of object independence versus data independence. We discuss the ways in which this difference in outlook manifests itself, and we consider the possibilities for resolving the two views, including the current work on object-oriented databases. We conclude by proposing an approach to co-existence that blurs the boundary between the object-oriented execution environment and the database.", "num_citations": "43\n", "authors": ["104"]}
{"title": "Ordering broken unit tests for focused debugging\n", "abstract": " Current unit test frameworks present broken unit tests in an arbitrary order, but developers want to focus on the most specific ones first. We have therefore inferred a partial order of unit tests corresponding to a coverage hierarchy of their sets of covered method signatures: When several unit tests in this coverage hierarchy break, we can guide the developer to the test calling the smallest number of methods. Our experiments with four case studies indicate that this partial order is semantically meaningful, since faults that cause a unit test to break generally cause less specific unit tests to break as well.", "num_citations": "42\n", "authors": ["104"]}
{"title": "Identify the champion\n", "abstract": " The peer review process for technical contributions to conferences in computing sciences is very thorough, and can be as stringent as the review process for journal publications in other domains. The programme committee for such a conference will typically convene at a meeting, where submitted papers are discussed, and accepted or rejected for presentation at the conference. Experience shows that discussions are more focussed, and the entire process runs more smoothly if most of the time is devoted to those papers that are actually \u201cchampioned\u201d by some committee member. In order to make this work effectively, however, the notion of \u201cchampioning\u201d must be introduced early in the review process. This paper presents a set of process patterns that help to achieve this goal.", "num_citations": "42\n", "authors": ["104"]}
{"title": "Formalizing composable software systems \u2013 A research agenda\n", "abstract": " Flexibility is achieved in open systems by adopting software architectures that allow software components to be easily plugged in, adapted and exchanged. But open systems are generally concurrent, distributed and heterogeneous in addition to being adaptable. Ad hoc approaches to specifying component frameworks can lead to unexpected semantic conflicts. We propose, instead, to develop a rigorous foundation for composable software systems by a series of experiments in modelling concurrent and object-based software abstractions as composable, communicating processes. Eventually we hope to identify and realize the most useful compositional idioms as a composition language for open systems specification.", "num_citations": "42\n", "authors": ["104"]}
{"title": "Security smells in android\n", "abstract": " The ubiquity of smartphones, and their very broad capabilities and usage, make the security of these devices tremendously important. Unfortunately, despite all progress in security and privacy mechanisms, vulnerabilities continue to proliferate.,,Research has shown that many vulnerabilities are due to insecure programming practices. However, each study has often dealt with a specific issue, making the results less actionable for practitioners. To promote secure programming practices, we have reviewed related research, and identified avoidable vulnerabilities in Android-run devices and the security code smells that indicate their presence. In particular, we explain the vulnerabilities, their corresponding smells, and we discuss how they could be eliminated or mitigated during development. Moreover, we develop a lightweight static analysis tool and discuss the extent to which it successfully detects several\u00a0\u2026", "num_citations": "41\n", "authors": ["104"]}
{"title": "Explicit namespaces\n", "abstract": " A namespace is a mapping from labels to values. Most programming languages support different forms of namespaces, such as records, dictionaries, objects, environments, packages and even keyword-based parameters. Typically only a few of these notions are first-class, leading to arbitrary restrictions and limited abstraction power in the host language. Piccola is a small language that unifies various notions of namespaces as first-class forms, or extensible, immutable records. By making namespaces explicit, Piccola is easily able to express various abstractions that would normally require more heavyweight techniques, such as language extensions or meta-programming.", "num_citations": "41\n", "authors": ["104"]}
{"title": "The moldable inspector\n", "abstract": " Object inspectors are an essential category of tools that allow developers to comprehend the run-time of object-oriented systems. Traditional object inspectors favor a generic view that focuses on the low-level details of the state of single objects. Based on 16 interviews with software developers and a follow-up survey with 62 respondents we identified a need for object inspectors that support different high-level ways to visualize and explore objects, depending on both the object and the current developer need. We propose the Moldable Inspector, a novel inspector model that enables developers to adapt the inspection workflow to suit their immediate needs by making the inspection context explicit, providing multiple interchangeable domain-specific views for each object, and supporting a workflow that groups together multiple levels of connected objects. We show that the Moldable Inspector can address multiple\u00a0\u2026", "num_citations": "40\n", "authors": ["104"]}
{"title": "Towards a type theory for active objects\n", "abstract": " A key property of object-oriented languages is that they promote software reuse through inter-changeability or plug compatibility of software components that conform to the same message-passing interface. A characterization of such an interface is a type, and can be viewed as a constraint on the behaviour of an object. An object that conforms to the type meets the constraint. A subtype, in this view, is simply a stronger constraint: all objects that conform to a subtype also conform to the supertype. The nature of these constraints may vary, however, as may the rules for determining when one type is a subtype of another. The choice of characterization will depend on the computational model of a particular language and the way in which objects interact. We seek to develop a notion of type that will serve to characterize concurrent, active objects whose behaviour may not conform to a strict client/server model of\u00a0\u2026", "num_citations": "38\n", "authors": ["104"]}
{"title": "The ITHACA technology a landscape for object-oriented application development\n", "abstract": " The ITHACA environment offers an application support system which incorporates advanced technologies in the fields of object-oriented programming in general and programming languages, database technologies, user interface systems and software development tools in particular. ITHACA provides an integrated and open-ended toolkit which exploits the benefits of object-oriented technologies for promoting reusability, tailorability and integratability, factors which are crucial for ensuring software quality and productivity. Industrial applications from the fields of office automation, public administration, finance/insurance and chemical engineering are developed in parallel and used to evaluate the suitability of the system.", "num_citations": "37\n", "authors": ["104"]}
{"title": "What is the 'object' in object-oriented programming?\n", "abstract": " Object-oriented programming has become quite widespread in recent years, although there are few guidelines to help us distinguish when a system is\" truly\" object-oriented or not. In this paper we discuss what have emerged as the main concepts in the object-oriented approach, and we attempt to motivate these concepts in terms of how they aid in software development.", "num_citations": "37\n", "authors": ["104"]}
{"title": "Model-centric, context-aware software adaptation\n", "abstract": " Software must be constantly adapted to changing requirements. The time scale, abstraction level and granularity of adaptations may vary from short-term, fine-grained adaptation to long-term, coarse-grained evolution. Fine-grained, dynamic and context-dependent adaptations can be particularly difficult to realize in long-lived, large-scale software systems. We argue that, in order to effectively and efficiently deploy such changes, adaptive applications must be built on an infrastructure that is not just model-driven, but is both model-centric and context-aware. Specifically, this means that high-level, causally-connected models of the application and the software infrastructure itself should be available at run-time, and that changes may need to be scoped to the run-time execution context.               We first review the dimensions of software adaptation and evolution, and then we show how model-centric design can\u00a0\u2026", "num_citations": "36\n", "authors": ["104"]}
{"title": "Composable encapsulation policies\n", "abstract": " Given the importance of encapsulation to object-oriented programming, it is surprising to note that mainstream object-oriented languages offer only limited and fixed ways of encapsulating methods. Typically one may only address two categories of clients, users and heirs, and one must bind visibility and access rights at an early stage. This can lead to inflexible and fragile code as well as clumsy workarounds. We propose a simple and general solution to this problem in which encapsulation policies can be specified separately from implementations. As such they become composable entities that can be reused by different classes. We present a detailed analysis of the problem with encapsulation and visibility mechanisms in mainstream OO languages, we introduce our approach in terms of a simple model, and we evaluate how our approach compares with existing approaches. We also assess the impact of\u00a0\u2026", "num_citations": "35\n", "authors": ["104"]}
{"title": "A Tour of Hybrid \u2014\u00a0A Language for Programming with Active Objects\n", "abstract": " Object-oriented programming is a powerful paradigm for organizing software into reusable components. There have been several attempts to adapt and extend this paradigm to the programming of concurrent and distributed applications. Hybrid is a language whose design attempts to retain multiple inheritance, genericity and strong-typing, and incorporate a notion of active objects. Objects in Hybrid are potentially active entities that communicate with one another through a messagepassing protocol loosely based on remote procedure calls. Non-blocking calls and delay queues are the two basic mechanisms for interleaving and scheduling activities. A prototype implementation of a compiler and run-time system for Hybrid have been completed. We shall review aspects of the language design and attempt to evaluate its shortcomings. We conclude with a list of requirements that we pose as a challenge for the design of future concurrent object-oriented languages.", "num_citations": "35\n", "authors": ["104"]}
{"title": "A calculus for reasoning about software composition\n", "abstract": " Although the term software component has become commonplace, there is no universally accepted definition of the term, nor does there exist a common foundation for specifying various kinds of components and their compositions. We propose such a foundation. The Piccola calculus is a process calculus, based on the asynchronous \u03c0-calculus, extended with explicit namespaces. The calculus is high level, rather than minimal, and is consequently convenient for expressing and reasoning about software components, and different styles of composition. We motivate and present the calculus, and outline how it is used to specify the semantics of Piccola, a small composition language. We demonstrate how the calculus can be used to simplify compositions by partial evaluation, and we briefly outline some other applications of the calculus to reasoning about compositional styles.", "num_citations": "34\n", "authors": ["104"]}
{"title": "OpenSpaces: an object-oriented framework for reconfigurable coordination spaces\n", "abstract": " Tuple spaces have turned out to be one of the most fundamental abstractions for coordinating communicating agents. At the same time, researchers continue to propose new variants of tuple spaces, since no one approach seems to be universally applicable to all problem domains. Some models offer a certain configurability, but existing approaches generally stop at a fixed set of configuration options and static configuration at instantiation time. We argue that a more open approach is needed, and present OpenSpaces, an object-oriented framework that supports static configurability through subclassing across several dimensions, as well as dynamic configurability of policies through run-time composition. We introduce OpenSpaces by showing how it can be used to instantiate a typical application, and we present an overview of the framework, implemented in Smalltalk, detailing the various degrees of\u00a0\u2026", "num_citations": "33\n", "authors": ["104"]}
{"title": "Directions in Object-Oriented Research.\n", "abstract": " Object-oriented systems as an approach have inherited concepts, methods and tools from many other areas in computer science. We can venture to say that object-oriented systems consist of a repackaging and relabeling of a cross section of computer science. As a result many different researchers see projections of their ideas within object-oriented systems. This situation explains two phenomena. First, in a short period object-oriented systems evolved from an esoteric, exotic way of programming in certain artificial intelligence applications to a diverse and expanding area of research. Second, there are disagreements among researchers on basic definitions; for example,\u201cWhat is an object?\u201d Researchers coming from programming languages, artificial intelligence and databases, among other fields, have their own and conflicting ideas on when an \u201cobject\u201d can be called an object. There is no reason to worry. Loose definitions are inevitable and sometimes welcome during a dynamic period of scientific discovery. They should and will become more rigorous during a period of consolidation that will inevitably follow.Directions in object-oriented research to some extent follow the roots of the researchers. We see, therefore, object-oriented research related to programming languages, to operating systems, to databases, etc. This does not necessarily mean that object-oriented researchers are rediscovering the results already present in other areas. On the contrary, researchers in other areas are finding a new territory in which to apply their ideas. The net effect is, however, that the directions in object-oriented research can be clearly categorized\u00a0\u2026", "num_citations": "33\n", "authors": ["104"]}
{"title": "Language boxes\n", "abstract": " As domain-specific modeling begins to attract widespread acceptance, pressure is increasing for the development of new domain-specific languages. Unfortunately these DSLs typically conflict with the grammar of the host language, making it difficult to compose hybrid code except at the level of strings; few mechanisms (if any) exist to control the scope of usage of multiple DSLs; and, most seriously, existing host language tools are typically unaware of the DSL extensions, thus hampering the development process. Language boxes address these issues by offering a simple, modular mechanism to encapsulate (i) compositional changes to the host language, (ii) transformations to address various concerns such as compilation and syntax highlighting, and (iii) scoping rules to control visibility of fine-grained language extensions. We describe the design and implementation of language boxes, and show with\u00a0\u2026", "num_citations": "32\n", "authors": ["104"]}
{"title": "Exploiting runtime information in the IDE\n", "abstract": " Developers rely on the mechanisms provided by their IDE to browse and navigate a large software system. These mechanisms are usually based purely on a system's static source code. The static perspective, however, is not enough to understand an object-oriented program's behavior, in particular if implemented in a dynamic language. We propose to enhance IDEs with a program's runtime information (e.g., message sends and type information) to support program comprehension through precise navigation and informative browsing. To precisely specify the type and amount of runtime data to gather about a system under development, dynamically and on demand, we adopt a technique known as partial behavioral reflection. We implemented navigation and browsing enhancements to an IDE that exploit this runtime information in a prototype called Hermion. We present preliminary validation of our experimental\u00a0\u2026", "num_citations": "32\n", "authors": ["104"]}
{"title": "Towards a Taxonomy of SUnit Tests.\n", "abstract": " Not all unit tests are alike. Some tests are simple oneliners, while others contain a battery of assertions. Certain tests focus on a single method, while others test interactions between methods. There are even tests that do not contain assertions at all. This can make it difficult for a developer to understand which methods are tested by which tests, to what degree they are tested, and what to take into account while refactoring. We have manually analyzed the test base of a large existing object-oriented system in order to derive a first taxonomy of unit tests. We have then developed some simple tools to semi-automatically categorize tests according to this taxonomy, and applied it to two case studies. Beside explaining our taxonomy, we report on our initial results using it, namely that a majority of unit tests focus on single methods and that our lightweight automatic categorization could already classify more than 50% of these single method commands.", "num_citations": "32\n", "authors": ["104"]}
{"title": "Advances in data mining\n", "abstract": " These are the proceedings of the tenth event of the Industrial Conference on Data Mining ICDM held in Berlin (www. data-mining-forum. de). For this edition the Program Committee received 175 submissions. After the peerreview process, we accepted 49 high-quality papers for oral presentation that are included in this book. The topics range from theoretical aspects of data mining to applications of data mining such as on multimedia data, in marketing, finance and telecommunication, in medicine and agriculture, and in process control, industry and society. Extended versions of selected papers will appear in the international journal Transactions on Machine Learning and Data Mining (www. ibai-publishing. org/journal/mldm).Ten papers were selected for poster presentations and are published in the ICDM Poster Proceeding Volume by ibai-publishing (www. ibai-publishing. org). In conjunction with ICDM four\u00a0\u2026", "num_citations": "31\n", "authors": ["104"]}
{"title": "Enriching reverse engineering with annotations\n", "abstract": " Much of the knowledge about software systems is implicit, and therefore difficult to recover by purely automated techniques. Architectural layers and the externally visible features of software systems are two examples of information that can be difficult to detect from source code alone, and that would benefit from additional human knowledge. Typical approaches to reasoning about data involve encoding an explicit meta-model and expressing analyses at that level. Due to its informal nature, however, human knowledge can be difficult to characterize up-front and integrate into such a meta-model. We propose a generic, annotation-based approach to capture such knowledge during the reverse engineering process. Annotation types can be iteratively defined, refined and transformed, without requiring a fixed meta-model to be defined in advance. We show how our approach supports reverse engineering by\u00a0\u2026", "num_citations": "30\n", "authors": ["104"]}
{"title": "Research topics in software composition.\n", "abstract": " Traditional software development approaches do not cope well with the evolving requirements of open systems. We argue that such systems are best viewed as flexible compositions of \u201csoftware components\u201d designed to work together as part of a component framework that formalizes a class of applications with a common software architecture. To enable such a view of software systems, we need appropriate support from programming language technology, software tools, and methods. We will briefly review the current state of object-oriented technology, insofar as it supports component-oriented development, and propose a research agenda of topics for further investigation.", "num_citations": "30\n", "authors": ["104"]}
{"title": "Hyperparameter optimization to improve bug prediction accuracy\n", "abstract": " Bug prediction is a technique that strives to identify where defects will appear in a software system. Bug prediction employs machine learning to predict defects in software entities based on software metrics. These machine learning models usually have adjustable parameters, called hyperparameters, that need to be tuned for the prediction problem at hand. However, most studies in the literature keep the model hyperparameters set to the default values provided by the used machine learning frameworks. In this paper we investigate whether optimizing the hyperparameters of a machine learning model improves its prediction power. We study two machine learning algorithms: k-nearest neighbours (IBK) and support vector machines (SVM). We carry out experiments on five open source Java systems. Our results show that (i) models differ in their sensitivity to their hyperparameters, (ii) tuning hyperparameters gives at\u00a0\u2026", "num_citations": "29\n", "authors": ["104"]}
{"title": "Embedding spatial software visualization in the IDE: an exploratory study\n", "abstract": " Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. Spatial representation of software is a promising approach of increasing interest. However, little is known about how developers interact with spatial visualizations that are embedded in the IDE. In this paper, we present a pilot study that explores the use of Software Cartography for program comprehension of an unknown system. We investigated whether developers establish a spatial memory of the system, whether clustering by topic offers a sound base layout, and how developers interact with maps. We report our results in the form of observations, hypotheses, and implications. Key findings are a) that developers made good use of the map to inspect search results and call graphs, and b) that developers found the base layout surprising and often confusing. We conclude with concrete advice for the\u00a0\u2026", "num_citations": "29\n", "authors": ["104"]}
{"title": "Scripting coordination styles\n", "abstract": " The fact that so many different kinds of coordination models and languages have been proposed suggests that no one single approach will be the best for all coordination problems. Different coordination styles exhibiting different properties may be more suitable for some problems than others. Like other architectural styles, coordination styles can be expressed in terms of components, connectors and composition rules. We propose an approach in which coordination styles are expressed as \u201ccomponent algebras\u201d: components of various sorts can be combined using operators that realize their coordination, yielding other sorts of components. We show how several coordination styles can be defined and applied using Piccola, a small language for composing software components. We furthermore show how glue abstractions can be used to bridge coordination styles when more than one style is needed for a\u00a0\u2026", "num_citations": "28\n", "authors": ["104"]}
{"title": "Komponenten, Komponentenframeworks und Gluing\n", "abstract": " In der letzten Zeit wird immer h\u00e4ufiger von komponentenorientierter Softwareentwicklung gesprochen, wobei meistens nicht klar ist, was darunter eigentlich zu verstehen ist. Was macht ein St\u00fcck Software zur Komponente? Wir sagen, da\u00df Softwarekomponenten in einer speziellen Art und Weise konstruiert werden m\u00fcssen, um mit anderen Komponenten zu einer Applikation zusammengef\u00fcgt werden zu k\u00f6nnen. Mit anderen Worten, eine Softwarekomponente ist Teil eines Komponentenframeworks, da\u00df (i) eine Bibliothek von Black-Box-Komponenten zu Verf\u00fcgung stellt,(ii) eine wiederverwendbare Softwarearchitektur definiert, in der die Komponenten geeignet integriert sind und (iii) eine bestimmte Art von Glue, die es uns erlaubt, Komponenten miteinander zu verbinden. In diesem Artikel versuchen wir, den Ist-Zustand der Komponententechnologie wiederzugeben und behaupten, da\u00df nur eine bessere Unterst\u00fctzung im Bereich Frameworks und Gluing die Komponententechnologie vorw\u00e4rts bringen kann.", "num_citations": "28\n", "authors": ["104"]}
{"title": "Generating a catalog of unanticipated schemas in class hierarchies using formal concept analysis\n", "abstract": " ContextInheritance is the cornerstone of object-oriented development, supporting conceptual modeling, subtype polymorphism and software reuse. But inheritance can be used in subtle ways that make complex systems hard to understand and extend, due to the presence of implicit dependencies in the inheritance hierarchy.ObjectiveAlthough these dependencies often specify well-known schemas (i.e., recurrent design or coding patterns, such as hook and template methods), new unanticipated dependency schemas arise in practice, and can consequently be hard to recognize and detect. Thus, a developer making changes or extensions to an object-oriented system needs to understand these implicit contracts defined by the dependencies between a class and its subclasses, or risk that seemingly innocuous changes break them.MethodTo tackle this problem, we have developed an approach based on Formal\u00a0\u2026", "num_citations": "27\n", "authors": ["104"]}
{"title": "Detecting implicit collaboration patterns\n", "abstract": " A key problem during software development and maintenance is to detect and recognize recurring collaborations among software artifacts that are implicit in the code. These collaboration patterns are typically signs of applied idioms, conventions and design patterns during the development of the system, and may entail implicit contracts that should be respected during maintenance, but are not documented explicitly. We apply formal concept analysis to detect implicit collaboration patterns. Our approach generalizes Antoniol and Tonella one for detecting classical design patterns. We introduce a variation to their algorithm to reduce the computation time of the concepts, a language-independent approach for object-oriented languages, and a post-processing phase in which pattern candidates are filtered out. We identify collaboration patterns in the analyzed applications, match them against libraries of known design\u00a0\u2026", "num_citations": "27\n", "authors": ["104"]}
{"title": "Software evolution as the key to productivity\n", "abstract": " Despite the existence of a seemingly continuous stream of new technologies and methods, software productivity remains universally unimpressive. We argue that, as long as industry remains focused on short-term goals, and maintains a technology-centric view of software development, no progress will be made. A clear symptom of this problem is the fact that the metaphors we apply to software development are largely obsolete. Instead of thinking about software as we do about bridges, buildings or hardware components, we should encourage a view of software as a living and evolving entity that is developed and maintained by people. We begin with some assertions that are intended as food for thought. We continue by reviewing what we consider to be some of the key difficulties with software development today. We conclude with a few recommendations for research into software practices that take\u00a0\u2026", "num_citations": "27\n", "authors": ["104"]}
{"title": "Automatic feature selection by regularization to improve bug prediction accuracy\n", "abstract": " Bug prediction has been a hot research topic for the past two decades, during which different machine learning models based on a variety of software metrics have been proposed. Feature selection is a technique that removes noisy and redundant features to improve the accuracy and generalizability of a prediction model. Although feature selection is important, it adds yet another step to the process of building a bug prediction model and increases its complexity. Recent advances in machine learning introduce embedded feature selection methods that allow a prediction model to carry out feature selection automatically as part of the training process. The effect of these methods on bug prediction is unknown. In this paper we study regularization as an embedded feature selection method in bug prediction models. Specifically, we study the impact of three regularization methods (Ridge, Lasso, and ElasticNet) on\u00a0\u2026", "num_citations": "26\n", "authors": ["104"]}
{"title": "Applications= Components+ Scripts: A tour of Piccola\n", "abstract": " . Piccola is a language for composing applications from software components. It has a small syntax and a minimal set of features needed for specifying different styles of software composition. The core features of Piccola are communicating agents, which perform computations, and forms, which are the communicated values. Forms are a special notion of extensible, immutable records. Forms and agents allow us to unify components, static and dynamic contexts and arguments for invoking services. Through a series of examples, we present a tour of Piccola, illustrating how forms and agents suffice to express a variety of compositional abstractions and styles. 1. Introduction Piccola is intended to be a general-purpose language for software composition. Whereas existing programming languages appear to be suitable for implementing software components, and many scripting languages and fourth-generation languages have been developed to address the needs of particular component models, there has...", "num_citations": "26\n", "authors": ["104"]}
{"title": "Beyond objects: objects\n", "abstract": " Object-orientation offers more than just objects, classes and inheritance as means to structure applications. It is an approach to application development in which software systems can be constructed by composing and refining pre-designed, plug-compatible software components. But for this approach to be successfully applied, programming languages must provide better support for component specification and software composition, the software development life-cycle must separate the issues of generic component design and reuse from that of constructing applications to meet specific requirements, and, more generally, the way we develop, manage, exchange and market software must adapt to better support large-scale reuse for software communities. In this paper we shall explore these themes and we will highlight a number of key research directions and open problems to be explored as steps towards\u00a0\u2026", "num_citations": "26\n", "authors": ["104"]}
{"title": "Visual Scripting: Towards interactive construction of object-oriented applications\n", "abstract": " Object-oriented programming techniques are known to improve the flexibility and reusability of certain kinds of software. Libraries of object classes, however, continue to be difficult both to develop and to reuse. We present an approach to object-oriented application development in which applications are constructed by interactively \u201cscripting\u201d cooperating, reusable software objects. A visual scripting tool is being developed within ITHACA2, an Esprit II project which seeks to produce an integrated environment for the rapid and flexible development of object-oriented applications for selected application domains.", "num_citations": "26\n", "authors": ["104"]}
{"title": "Flow-centric, back-in-time debugging\n", "abstract": " Conventional debugging tools present developers with means to explore the run-time context in which an error has occurred. In many cases this is enough to help the developer discover the faulty source code and correct it. However, rather often errors occur due to code that has executed in the past, leaving certain objects in an inconsistent state. The actual run-time error only occurs when these inconsistent objects are used later in the program. So-called back-in-time debuggers help developers step back through earlier states of the program and explore execution contexts not available to conventional debuggers. Nevertheless, even Back-in-Time Debuggers do not help answer the question, \u201cWhere did this object come from?\u201d The Object-Flow Virtual Machine, which we have proposed in previous work, tracks the flow of objects to answer precisely such questions, but this VM does not provide dedicated\u00a0\u2026", "num_citations": "25\n", "authors": ["104"]}
{"title": "Feature driven browsing\n", "abstract": " Development environments typically present the software engineer with a structural perspective of an object-oriented system in terms of packages, classes and methods. From a structural perspective it is difficult to gain an understanding of how source entities participate in a system's features at runtime, especially when using dynamic languages such as Smalltalk. In this paper we evaluate the usefulness of offering an alternative, complementary feature-centric perspective of a software system when performing maintenance activities. We present a feature-centric environment combining interactive visual representations of features with a source code browser displaying only the classes and methods participating in a feature under investigation. To validate the usefulness of our feature-centric view, we conducted a controlled empirical experiment where we measured and compared the performance of subjects when\u00a0\u2026", "num_citations": "25\n", "authors": ["104"]}
{"title": "Message flow analysis\n", "abstract": " Message management systems with facilities for the automatic processing of messages can exhibit anomalous behaviour such as infinite loops and deadlock. In this paper we present some methods for analyzing the behaviour of these systems by generating expressions of message flow from the procedure specifications. Message domains are partitioned into state spaces, and procedures can be interpreted as automata effecting state changes. Blocking of procedures and procedure loops can then be detected by studying the resulting finite automaton and Petri net representations of message flow.", "num_citations": "25\n", "authors": ["104"]}
{"title": "Practical, pluggable types for a dynamic language\n", "abstract": " Most languages fall into one of two camps: either they adopt a unique, static type system, or they abandon static type-checks for run-time checks. Pluggable types blur this division by (i) making static type systems optional, and (ii) supporting a choice of type systems for reasoning about different kinds of static properties. Dynamic languages can then benefit from static-checking without sacrificing dynamic features or committing to a unique, static type system. But the overhead of adopting pluggable types can be very high, especially if all existing code must be decorated with type annotations before any type-checking can be performed. We propose a practical and pragmatic approach to introduce pluggable type systems to dynamic languages. First of all, only annotated code is type-checked. Second, limited type inference is performed on unannotated code to reduce the number of reported errors. Finally, external\u00a0\u2026", "num_citations": "24\n", "authors": ["104"]}
{"title": "Capturing how objects flow at runtime\n", "abstract": " Most of today\u2019s dynamic analysis approaches are based on method traces. However, in the case of objectorientation understanding program execution by analyzing method traces is complicated because the behavior of a program depends on the sharing and the transfer of object references (aliasing). We argue that trace-based dynamic analysis is at a too low level of abstraction for objectoriented systems. We propose a new approach that captures the life cycle of objects by explicitly taking into account object aliasing and how aliases propagate during the execution of the program. In this paper, we present in detail our new meta-model and discuss future tracks opened by it.", "num_citations": "24\n", "authors": ["104"]}
{"title": "PECOS in a Nutshell\n", "abstract": " Software is more and more becoming the major cost factor for embedded devices. In fact, software accounts for more than 50 percent of the development costs of such a device. The PECOS (PErvasive Component Systems) project seeks to overcome this by providing a component-based technology for the development of a specific class of embedded systems known as\u201d field devices\u201d. It takes into account the specific properties of this application area. Therefore the PECOS project has developed a component model, a composition language, and tools for field device software development which help to overcome the shortcomings of the current practice. The PECOS approach covers the whole software life-cycle of a field device. It defines a detailed software process which coordinates all development steps from requirements specification to deployment.The PECOS project consortium consists of four partners: ABB Corporate Research Centre in Ladenburg, Research Centre for Information Technologies (FZI), the Software Composition Group at the University of Bern (SCG), and Object Technology International (OTI). The roles of the partners within the project has been the following. ABB acted as main contractor, project coordinator and user in the project: ABB\u2019s Instruments Business Unit is developing a large number of different field devices and aims at introducing component based technology in their production. In addition, ABB has got expert knowledge in the field device domain and has carried out a number of case studies within the project. FZI and SCG have been charged with the research part of the project, which concerned the PECOS\u00a0\u2026", "num_citations": "24\n", "authors": ["104"]}
{"title": "An implementation of Hybrid\n", "abstract": " This paper is a report on a prototype implementation of Hybrid, a strongly-typed, concurrent, object-oriented language. The implementation we describe features a compile-time system for translating Hybrid object type definitions into C, a run-time system for supporting communication, concurrency and object persistence, and a type manager that mediates between the two.", "num_citations": "24\n", "authors": ["104"]}
{"title": "An Object-Oriented Environment for OIS Applications.\n", "abstract": " Object-oriented programming environments are increasingly needed for programming OIS applications. A prototype object-oriented language has been implemented, and we are refining the language and its implementation. The environment integrates a number of database and operating system concepts, in particular, abstract data types, database constraints, atomic transactions, data persistency, triggering of events, reliability and crash recovery, and a large virtual memory. We outline the object model, discuss a number of implementation issues, and give some examples of objects useful in an OIS application environment.", "num_citations": "24\n", "authors": ["104"]}
{"title": "Office Procedures\n", "abstract": " This paper outlines an effort to introduce automation into forms-oriented office procedures. The system allows its users to specify a set of operations on electronic forms. Actions are triggered automatically when certain events occur, for example, when forms or combinations of forms arrive at particular nodes in the network of stations. The actions deal with operations on forms. The paper discusses the facilities provided for the specification of form-oriented automatic procedures and sketches their implementation.", "num_citations": "24\n", "authors": ["104"]}
{"title": "Example-driven reconstruction of software models\n", "abstract": " As software systems evolve, they become more complex and harder to understand and maintain. Certain reverse engineering techniques attempt to reconstruct software models from source code with the help of a parser for the source language. Unfortunately a great deal of effort may be required to build a specialized parser for a legacy programming language or dialect. On the other hand, (i) we typically do not need a complete parser that recognizes all language constructs, and (ii) we have a rich supply of (legacy) examples. We present an approach to use these facts to rapidly and incrementally develop parsers as follows: we specify mappings from source code examples to model elements; we use the mappings to generate a parser; we parse as much code as we can; we use the exceptional cases to develop new example mappings; and we iterate. Experiments with Java and Ruby, two very different languages\u00a0\u2026", "num_citations": "23\n", "authors": ["104"]}
{"title": "Run-Time Evolution through Explicit Meta-Objects.\n", "abstract": " Software must be constantly adapted due to evolving domain knowledge and unanticipated requirements changes. To adapt a system at run-time we need to reflect on its structure and its behavior. Objectoriented languages introduced reflection to deal with this issue, however, no reflective approach up to now has tried to provide a unified solution to both structural and behavioral reflection. This paper describes Albedo 1, a unified approach to structural and behavioral reflection. Albedo is a model of fined-grained unanticipated dynamic structural and behavioral adaptation. Instead of providing reflective capabilities as an external mechanism we integrate them deeply in the environment. We show how explicit meta-objects allow us to provide a range of reflective features and thereby evolve both application models and environments at run-time.", "num_citations": "22\n", "authors": ["104"]}
{"title": "Supporting compositional styles for software evolution\n", "abstract": " Software is not just difficult to develop, it is even more difficult to maintain in the face of changing requirements. The complexity of software evolution can, however be significantly reduced if we manage to separate the stable artifacts (the \"components\") from their configuration (the \"scripts\"). We have proposed a simple, unifying framework of forms, agents, and channels for modelling components and scripts, and we have developed an experimental composition language, called Piccola, based on this framework, that supports the specification of applications as flexible compositions of stable components. We show how Piccola can be used to reduce the complexity of software evolution through the specification and use of an appropriate compositional style, and we illustrate the approach through a non-trivial example of mixin layer composition.", "num_citations": "22\n", "authors": ["104"]}
{"title": "Integrated Office Systems.\n", "abstract": " New techniques are sorely needed to aid in the development and maintenance of large application systems. The problem with traditional approaches to software engineering is well in evidence in the field of office information systems: it is costly and difficult to extend existing applications, and to get unrelated applications to \u201ctalk\u201d to each other. The objectoriented approach is already being tentatively applied in the modeling of \u201coffice objects\u201d and in the presentation of these entities to users as such in \u201cdesktop\u201d interfaces to office software. In order to fully exploit the approach to achieve integrated office systems, we need to use object-oriented programming languages, object-oriented run-time support, and object-oriented software engineering environments.We can view the fundamental idea behind the object-oriented approach as that of encapsulation: object-oriented languages and systems exploit encapsulation in various ways in an attempt to enhance productivity through, for example, reusability mechanisms such as class inheritance.(See [Nierstrasz 1988] in this book for an elaboration of this view.) The importance of object-oriented techniques for software engineering has long been established: encapsulation has been successfully used by programmers ever since macros and subroutines were invented. Encapsulation is important not only for the purpose of decomposing large software problems into manageable pieces, but can also be exploited to achieve software maintainability, reusability, and even \u201crapid prototyping\u201d, as object-oriented systems like Smalltalk [Goldberg and Robson 1983] have demonstrated.", "num_citations": "22\n", "authors": ["104"]}
{"title": "Understanding classes using X-Ray views\n", "abstract": " Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views\u2014a technique based on Concept Analysis\u2014which reveal the internal relationships between groups of methods and attributes of a class. XRay views are composed out of elementary collaborations between attributes and methods and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it to three Smalltalk classes: OrderedCollection, Scanner, and UIBuilder.", "num_citations": "21\n", "authors": ["104"]}
{"title": "Change-enabled software systems\n", "abstract": " Few real software systems are built completely from scratch nowadays. Instead, systems are built iteratively and incrementally, while integrating and interacting with components from many other systems. Adaptation, reconfiguration and evolution are normal, ongoing processes throughout the lifecycle of a software system. Nevertheless the platforms, tools and environments we use to develop software are still largely based on an outmoded model that presupposes that software systems are closed and will not significantly evolve after deployment. We claim that in order to enable effective and graceful evolution of modern software systems, we must make these systems more amenable to change by (i) providing explicit, first-class models of software artifacts, change, and history at the level of the platform, (ii) continuously analysing static and dynamic evolution to track emergent properties, and (iii) closing the\u00a0\u2026", "num_citations": "20\n", "authors": ["104"]}
{"title": "A case study in coordination: Conference management on the internet\n", "abstract": " The purpose of this note is to informally specify a case study in coordination describing a real world problem. The case study concerns peer review and evaluation of submissions to scientific conferences exploiting the Internet as the infrastructure for communication and cooperation. More precisely, we intend to specify a system for supporting all the activities which typically have to be performed by a number of people widely distributed all over the world to submit, select, and prepare the set of papers which will be published in the proceedings of a scientific conference. The goal is to build the final version of conference proceedings, including a list of accepted papers.", "num_citations": "20\n", "authors": ["104"]}
{"title": "Using Metaobjects to Model Concurrent Objects with PICT.\n", "abstract": " We seek to support the development of open, distributed applications from plug-compatible software abstractions. In order to rigorously specify these abstractions, we are elaborating a formal object model for software composition in which objects and related software abstractions are viewed as patterns of communicating processes. The semantic foundation is Milner's \u03c0 calculus, and the starting point for our object model is Pierce and Turner's encoding of objects as processes in the experimental PICT programming language. Our experience shows that common object-oriented programming abstractions such as dynamic binding, inheritance, genericity, and class variables are most easily modelled when metaobjects are explicitly reified as first class entities (ie, processes). Furthermore, various roles that are typically merged (or confused) in object-oriented languages such as classes, implementations, and metaobjects, each show up as strongly-typed, first class processes.", "num_citations": "20\n", "authors": ["104"]}
{"title": "Domain-specific program checking\n", "abstract": " Lint-like program checkers are popular tools that ensure code quality by verifying compliance with best practices for a particular programming language. The proliferation of internal domain-specific languages and models, however, poses new challenges for such tools. Traditional program checkers produce many false positives and fail to accurately check constraints, best practices, common errors, possible optimizations and portability issues particular to domain-specific languages. We advocate the use of dedicated rules to check domain-specific practices. We demonstrate the implementation of domain-specific rules, the automatic repair of violations, and their application to two case-studies: (1) Seaside defines several internal DSLs through a creative use of the syntax of the host language; and (2) Magritte adds meta-descriptions to existing code by means of special methods. Our empirical validation\u00a0\u2026", "num_citations": "19\n", "authors": ["104"]}
{"title": "Cache coherence protocols for many-core CMPs\n", "abstract": " Multi-core architectures have emerged as the best alternative to take advantage of the increasing number of transistors currently offered in a single die. For example, the dual-core IBM Power6 (Le et al., 2007) and the eight-core Sun UltraSPARC T2 (Shah et al., 2007) have a relatively small number of cores, which are typically connected through a shared medium, ie, a bus or a crossbar. However, CMP architectures that integrate tens of processor cores (usually known as many-core CMPs) are expected for the near future, after Intel recently unveiled the 80-core Polaris prototype (Azimi et al., 2007). Since the area required by a shared interconnect becomes impractical as the number of cores grows (Kumar et al., 2005), it seems that the processing cores of future CMPs will be connected by means of unordered point-to-point networks. Hence, tiled CMP architectures (Taylor et al., 2002; Zhang & Asanovic, 2005), which are designed as arrays of replicated tiles connected over a point-to-point network, have arisen as a scalable alternative to current small-scale CMP designs and they will help in keeping complexity manageable.On the other hand, most CMP systems provide programmers with the intuitive sharedmemory model, which requires efficient support for cache coherence. Although a great deal of attention was devoted to scalable cache coherence protocols in the last decades in the context of shared-memory multiprocessors, the technological parameters and constraints entailed by many-core CMPs demand new solutions to the cache coherence problem (Bosschere et al., 2007; Azimi et al., 2007).", "num_citations": "19\n", "authors": ["104"]}
{"title": "Agent coordination via scripting languages\n", "abstract": " In recent years, so-called scripting languages have become increasingly popular as they provide means to build quickly flexible applications from a set of prefabricated components. These languages typically support a single, specific architectural style of composing components (e.g. the pipes and filters architectural style), and they are designed to address a specific application domain. Although scripting languages and coordination languages have evolved from different roots and have been developed to solve different problems, we argue that both address similar separations of concerns. Scripting languages achieve a separation of components from the scripts that configure and compose them, whilst coordination languages separate computational entities from the coordination code that manages dependencies between them. In this chapter we will define coordination in the context of a conceptual\u00a0\u2026", "num_citations": "19\n", "authors": ["104"]}
{"title": "Exception evolution in long-lived Java systems\n", "abstract": " Exception handling allows developers to deal with abnormal situations that disrupt the execution flow of a program. There are mainly three types of exceptions: standard exceptions provided by the programming language itself, custom exceptions defined by the project developers, and third-party exceptions defined in external libraries. We conjecture that there are multiple factors that affect the use of these exception types. We perform an empirical study on long-lived Java projects to investigate these factors. In particular, we analyze how developers rely on the different types of exceptions in throw statements and exception handlers. We confirm that the domain, the type, and the development phase of a project affect the exception handling patterns. We observe that applications have significantly more error handling code than libraries and they increasingly rely on custom exceptions. Also, projects that belong to\u00a0\u2026", "num_citations": "18\n", "authors": ["104"]}
{"title": "Recovery and analysis of transaction scope from scattered information in Java enterprise applications\n", "abstract": " Java Enterprise Applications (JEAs) are large systems that integrate multiple technologies and programming languages. Transactions in JEAs simplify the development of code that deals with failure recovery and multi-user coordination by guaranteeing atomicity of sets of operations. The heterogeneous nature of JEAs, however, can obfuscate conceptual errors in the application code, and in particular can hide incorrect declarations of transaction scope. In this paper we present a technique to expose and analyze the application transaction scope in JEAs by merging and analyzing information from multiple sources. We also present several novel visualizations that aid in the analysis of transaction scope by highlighting anomalies in the specification of transactions and violations of architectural constraints. We have validated our approach on two versions of a large commercial case study.", "num_citations": "18\n", "authors": ["104"]}
{"title": "Analyzing, capturing and taming software change\n", "abstract": " Software systems need to continuously change to remain useful. Change appears in several forms and needs to be accommodated at different levels. We propose Change- boxes as a mechanism to encapsulate, manage, analyze and exploit changes to software systems. Our thesis is that only by making change explicit and manipulable can we en- able the software developer to manage software change more effectively than is currently possible. Furthermore we argue that we need new insights into assessing the impact of changes and we need to provide new tools and techniques to manage them. We report on the results of some initial prototyping efforts, and we outline a series of research activities that we have started to explore the potential of Changeboxes.", "num_citations": "18\n", "authors": ["104"]}
{"title": "A guide to specifying concurrent behaviour with Abacus\n", "abstract": " We present the syntax, semantics and usage of Abacus, an executable notation for specifying concurrent computations that extends CCS with label prefixing and filtering operators for encapsulating systems of communicating agents and a pattern mechanism for parameterizing behaviour expressions. Abacus is intended to be used as a semantic target and a prototyping tool for the specification of concurrent object-based languages and systems. We illustrate the use of Abacus through a series of standard concurrency examples, concluding with an executable specification of SAL, a Simple Actor Language.", "num_citations": "18\n", "authors": ["104"]}
{"title": "Hybrid\u2013A Language for Programming with Active Objects\n", "abstract": " Hybrid is an object-oriented programming language in which objects are the active entities. Active objects in Hybrid are both concurrent and persistent, thus unifying the notion of an \u201cobject\u201d with that of processes and files. Hybrid introduces the concept of an activity as a means for controlling the interactions between active objects. The language provides constructs that allow one to restrict or relax this control in a fairly simple way. In particular, mechanisms for delaying and \u201cdelegating\u201d activities are provided. Furthermore, Hybrid is designed so as to provide powerful constructs for reusing code in a way that is consistent with strong-typing.", "num_citations": "18\n", "authors": ["104"]}
{"title": "Towards a moldable debugger\n", "abstract": " The debugger is an essential tool in any programming environment, as it helps developers understand the dynamic behaviour of software systems. However, traditional debuggers fail in answering domain-specific questions, as the semantics of what they show and do are fixed. In this paper we introduce our work towards a moldable debugger which, unlike traditional debuggers, both adapts itself and can be adapted to a particular debugging context. Thus, it allows developers to answer their questions by using concepts from their own application domains.", "num_citations": "17\n", "authors": ["104"]}
{"title": "Unanticipated partial behavioral reflection\n", "abstract": " Dynamic, unanticipated adaptation of running systems is of interest in a variety of situations, ranging from functional upgrades to on-the-fly debugging or monitoring of critical applications. In this paper we study a particular form of computational reflection, called unanticipated partial behavioral reflection, which is particularly well-suited for unanticipated adaptation of real-world systems. Our proposal combines the dynamicity of unanticipated reflection, i.e.,\u00a0 reflection that does not require preparation of the code of any sort, and the selectivity and efficiency of partial behavioral reflection. First, we propose unanticipated partial behavioral reflection which enables the developer to precisely select the required reifications, to flexibly engineer the metalevel and to introduce the meta behavior dynamically. Second, we present a system supporting unanticipated partial behavioral reflection in Squeak Smalltalk, called\u00a0\u2026", "num_citations": "17\n", "authors": ["104"]}
{"title": "Using contextual information to assess package cohesion\n", "abstract": " Complex systems are decomposed into cohesive packages with the goal of limiting the scope of changes: if our packages are cohesive, we hope that changes will be limited to the packages responsible for the features we are changing, or at worst the packages that are immediate clients of those features. But how should we measure cohesion? Traditional cohesion metrics focus on the explicit dependencies and interactions between the classes within the package under study. A package, however, may be conceptually cohesive even though its classes exhibit no explicit dependencies. We propose a group of contextual metrics that assess the cohesion of a package based on the degree to which its classes are used together by common clients.We apply these metrics to various case studies, and contrast the degree of cohesion detected with that of traditional cohesion metrics. In particular, we note that object-oriented frameworks may appear not to be cohesive with traditional metrics, whereas our contextual metrics expose the implicit cohesion that results from the framework\u2019s clients.", "num_citations": "17\n", "authors": ["104"]}
{"title": "Supporting Software Reuse in Concurrent Object-Oriented Languages: Exploring the Language Design Space\n", "abstract": " The design of programming languages that cleanly integrate concurrency constructs and objectoriented features that promote software reuse is an open problem. We describe a design space that characterizes approaches to object-oriented concurrency in terms of a number of language design choices concerning the relationship between objects and concurrency. We identify requirements for software reuse and, with the help of an example that illustrates several of these requirements, explore the design space in order to evaluate which design choices interfere with reuse and which appear to adequately support it. We conclude by highlighting open research issues which, we believe, are essential for achieving effective reuse of concurrent software.", "num_citations": "17\n", "authors": ["104"]}
{"title": "Talents: an environment for dynamically composing units of reuse\n", "abstract": " Reuse in object\u2010oriented languages typically focuses on inheritance. Numerous techniques have been developed to provide finer\u2010grained reuse of methods, such as flavors, mixins, and traits. These techniques, however, only deal with reuse at the level of classes. Class\u2010based reuse is inherently static. Increasing use of reflection and meta\u2010programming techniques in real\u2010world applications underlines the need for more dynamic approaches. New approaches have shifted to object\u2010specific reuse. However, these techniques fail to provide a complete solution to the composition issues arising during reuse. We propose a new approach that deals with reuse at the object level and that supports behavioral and state composition. We introduce a new abstraction called a talent that models features that are shared between objects of different class hierarchies. Talents provide a composition mechanism that is as flexible\u00a0\u2026", "num_citations": "16\n", "authors": ["104"]}
{"title": "Using context information to re-architect a system\n", "abstract": " Successful software systems cope with complexity by organizing classes into packages. However, a particular organization may be neither straightforward nor obvious for a given developer. As a consequence, classes can be misplaced, leading to duplicated code and ripple effects with minor changes effecting multiple packages. We claim that contextual information is the key to rearchitecture a system. Exploiting contextual information, we propose a technique to detect misplaced classes by analyzing how client packages access the classes of a given provider package. We define locality as a measure of the degree to which classes reused by common clients appear in the same package. We then use locality to guide a simulated annealing algorithm to obtain optimal placements of classes in packages. The result is the identification of classes that are candidates for relocation. We apply the technique to three applications and validate the usefulness of our approach via developer interviews.", "num_citations": "16\n", "authors": ["104"]}
{"title": "Separation of concerns through unification of concepts\n", "abstract": " Separation of concerns is a principle we apply to reduce complexity. This principle is especially important when it is used to separate stable from flexible parts of software systems to reduce the complexity of software evolution. We encapsulate the stable parts as components and the flexible parts as scripts. But there is a large range of requirements and consequent techniques available to achieve this separation. We propose a simple, unifying framework of forms, agents, and channels for modelling components and scripts. We have also developed an experimental composition language, called Piccola, based on this framework, that supports the specification of applications as flexible compositions of stable components.", "num_citations": "16\n", "authors": ["104"]}
{"title": "Explicit connectors for coordination of active objects\n", "abstract": " The trend to interconnect software systems increased the pressure on object oriented (OO) programming languages to include concurrency control features. Thread packages that are not integrated into programming languages tend to be hard to use [Lea97]. Thus for example JAVA, a recent OO programming language introduces a small and consistent set of object synchronization primitives. However, Bloom [Blo79] already pointed out the need of factoring out synchronization code (in non OO context). This was also reflected in OO synchronization approaches like the generic synchronization policies [McH94] or the D-language [LK97]. Such approaches feature separation of concerns and high level synchronization abstractions instead of built-in primitives. However their declarations affect only single class declarations therefore they do not cover the field of multi-object synchronization, where different kind of objects share resources concurrently. The management of such dependencies between otherwise independent objects is called coordination. Our FLO/C model is situated in this context: we want to introduce an OO model that factors out high-level coordination abstractions. Our model is situated in the same area as the synchronizers of Agha and Fr\u00f8lund [FA93]. We both use rules to enforce interaction behavior. However, in FLO/C the rules are supported by explicit coordinator objects that allow us to achieve run-time flexibility like the dynamic exchange of coordination policies.Instantiating coordination in specialized objects has a tradition in the domain of software architecture design. There the distinction between components and\u00a0\u2026", "num_citations": "16\n", "authors": ["104"]}
{"title": "Application development using objects\n", "abstract": " Much of the cost of developing and maintaining applications can be attributed to our disposition to build systems largely from scratch. An application development support system would shift the emphasis from programming of arbitrary systems to configuration of certain classes of applications from pre-packaged software. In order for this style of application development to be successful, we argue that it should be carried out in an object-oriented software environment. Such an environment would consist of an object-oriented language and system that integrates various object-oriented approaches, user interface tools for monitoring and interacting with active objects, object design tools, and support for evolving application-oriented objects.", "num_citations": "16\n", "authors": ["104"]}
{"title": "Introducing Hybrid: A Unified Object-Oriented System\n", "abstract": " Hybrid is a data abstraction language that attempts to unify a number of object-oriented concepts into a single, coherent system. In this paper we give an overview of our object model, describe a number of the language constructs, and briefly discuss the issue of object management.", "num_citations": "16\n", "authors": ["104"]}
{"title": "An object-oriented system\n", "abstract": " Applications in Office Information Systems are often very difficult to implement and prototype, largely because of the lack of appropriate programming tools. We argue here that \u201cobject\u201d have many of the primitives that we need for building OIS systems, and we describe an object-oriented programming system that we have developed.", "num_citations": "16\n", "authors": ["104"]}
{"title": "Security code smells in Android ICC\n", "abstract": " Android Inter-Component Communication (ICC) is complex, largely unconstrained, and hard for developers to understand. As a consequence, ICC is a common source of security vulnerabilities in Android apps. To promote secure programming practices, we have reviewed related research, and identified avoidable ICC vulnerabilities in Android-run devices and the security code smells that indicate their presence. We explain the vulnerabilities and their corresponding smells, and we discuss how they can be eliminated or mitigated during development. We present a lightweight static analysis tool on top of Android Lint that analyzes the code under development and provides just-in-time feedback within the IDE about the presence of such smells in the code. Moreover, with the help of this tool we study the prevalence of security code smells in more than 700 open-source apps, and manually inspect around 15% of the\u00a0\u2026", "num_citations": "15\n", "authors": ["104"]}
{"title": "Composing unit tests\n", "abstract": " If we were to apply the testing techniques of object-oriented systems prescribed by the XUnit framework to a car factory, the result would be an inefficient process: A tire would be created, quality assured and then thrown away, only to be recreated later to test the functionality of the whole car.XUnit makes it difficult to reuse intermediate results of low level unit tests. As a consequence a higher level unit test is forced to recreate test scenarios which were already created by lower level unit tests. This duplicated testing effort is time-consuming both for setting up new scenarios and for running the tests. To address this problem we suggest a semi-automatic approach to compose tests. First we describe how we can detect candidates of composable test cases by partially ordering their sets of covered method signatures, then we present techniques to refactor unit tests accordingly.", "num_citations": "15\n", "authors": ["104"]}
{"title": "The ITHACA application development environment\n", "abstract": " The goal of ITHACA is to produce a complete object-oriented application development environment. This paper reports on the status of ITHACA in relation to this ambitious goal concentrating on the tools comprising the application development environment. Some general observations and recommendations are made concerning the integration of the tools. Future directions of the project are also outlined.", "num_citations": "15\n", "authors": ["104"]}
{"title": "JIT Feedback\u2014what Experienced Developers like about Static Analysis\n", "abstract": " Although software developers are usually reluctant to use static analysis to detect issues in their source code, our automatic just-in-time static analysis assistant was integrated into an Integrated Development Environment, and was evaluated positively by its users. We conducted interviews to understand the impact of the tool on experienced developers, and how it performs in comparison with other static analyzers. We learned that the availability of our tool as a default IDE feature and its automatic execution are the main reasons for its adoption. Moreover, the fact that immediate feedback is provided directly in the related development context is essential to keeping developers satisfied, although in certain cases feedback delivered later was deemed more useful. We also discovered that static analyzers can play an educational role, especially in combination with domain-specific rules.", "num_citations": "14\n", "authors": ["104"]}
{"title": "Test blueprints-exposing side effects in execution traces to support writing unit tests\n", "abstract": " Writing unit tests for legacy systems is a key maintenance task. When writing tests for object-oriented programs, objects need to be set up and the expected effects of executing the unit under test need to be verified. If developers lack internal knowledge of a system, the task of writing tests is non-trivial. To address this problem, we propose an approach that exposes side effects detected in example runs of the system and uses these side effects to guide the developer when writing tests. We introduce a visualization called Test Blueprint, through which we identify what the required fixture is and what assertions are needed to verify the correct behavior of a unit under test. The dynamic analysis technique that underlies our approach is based on both tracing method executions and on tracking the flow of objects at runtime. To demonstrate the usefulness of our approach we present results from two case studies.", "num_citations": "14\n", "authors": ["104"]}
{"title": "Object-Based Models and Languages for Concurrent Systems: ECOOP'94 Workshop on Models and Languages for Coordination of Parallelism and Distribution, Bologna, Italy, July 5\u00a0\u2026\n", "abstract": " This volume presents carefully refereed versions of the best papers presented at the Workshop on Models and Languages for Coordination of Parallelism and Distribution, held during ECOOP'94 in Bologna, Italy in July 1994. Recently a new class of models and languages for distributed and parallel programming has evolved; all these models share a few basic concepts: simple features for data description and a small number of mechanisms for coordinating the work of agents in a distributed setting. This volume demonstrates that integrating such features with those known from concurrent object-oriented programming is very promising with regard to language support for distribution and software composition.", "num_citations": "14\n", "authors": ["104"]}
{"title": "Composing Tests from Examples.\n", "abstract": " Understanding and maintaining complex software systems is a difficult task. In principle, tests can be a good source of information about how the system works. Unfortunately, tests are frequently unstructured and disconnected from each other and from their units under test. We propose a new approach to organizing unit tests in which tests produce examples of their units under tests which also can be reused for composing higher-level tests. The approach is based on the Eg meta-model, which classifies tests according to their granularity and their goals. We have developed the EgBrowser, an experimental tool for specifying tests that conform to the Eg metamodel while keeping track of the connection between tests themselves and their units under test. Initial usability studies suggest that the approach is both easy to learn and more efficient than the programmatic approach to developing tests.", "num_citations": "13\n", "authors": ["104"]}
{"title": "Model Driven Engineering Languages and Systems\n", "abstract": " BORIS Deutsch English Fran\u00e7ais Login BORIS Bern Open Repository and Information System University of Bern Home Statistics Model Driven Engineering Languages and Systems Nierstrasz, Oscar; Whittle, Jon; Harel, David; Reggio, Gianna (eds.) (2006). Model Driven Engineering Languages and Systems. Lecture Notes in Computer Science: Vol. 4199. Heidelberg: Springer 10.1007/11880240 Full text not available from this repository. (Request a copy) Item Type: Book (Edited Volume) Division/Institute: 08 Faculty of Science > Institute of Computer Science (INF) 08 Faculty of Science > Institute of Computer Science (INF) > Software Composition Group (SCG) UniBE Contributor: Nierstrasz, Oscar Marius Subjects: 000 Computer science, knowledge & systems ISSN: 0302-9743 Series: Lecture Notes in Computer Science Publisher: Springer Language: English Submitter: Factscience Import Date Deposited: 04 Oct :: \u2026", "num_citations": "13\n", "authors": ["104"]}
{"title": "Recovering the evolution of object oriented software systems using a flexible query engine\n", "abstract": " Since software systems must evolve to cope with changing demands, the investment of time and effort won\u2019t cease after first delivery. Developers that join a project later in the development cycle may have a hard time to understand the structure of complex systems. Moreover they may not know about concepts that emerged from earlier implementations. We therefore want to find out what exactly happens during evolution of software systems. We developed a method based on simple metric heuristics to detect changes between different versions of a software system. With our query-based approach we can measure overall changes in terms of removals and additions in the code. We are also able to detect different kinds of refactorings like restructuring in the class hierarchy and moved features between entities. Historical information about code size and changes in the code structure helps us to find interesting patterns and to discover unknown relationships and dependencies among source code entities. i", "num_citations": "13\n", "authors": ["104"]}
{"title": "Temporal scripts for objects\n", "abstract": " Computer animation, computer simulation, computer music and other areas often need to deal with concurrent activities with specific temporal characteristics. This paper proposes a scripting facility to help program such applications. This facility provides support for specifying long-term behaviour of objects in an object-oriented environment. Temporal scripts can be instantiated and combined using a. set of temporal operators, saying for example that two activities begin at the same time, or that one has to follow the other. Through a flexible sampling policy based on a notion of virtual time, temporal specifications can be executed at various temporal resolutions, and therefore can be reused in different contexts.", "num_citations": "13\n", "authors": ["104"]}
{"title": "Parsing for agile modeling\n", "abstract": " In order to analyze software systems, it is necessary to model them. Static software models are commonly imported by parsing source code and related data. Unfortunately, building custom parsers for most programming languages is a non-trivial endeavor. This poses a major bottleneck for analyzing software systems programmed in languages for which importers do not already exist. Luckily, initial software models do not require detailed parsers, so it is possible to start analysis with a coarse-grained importer, which is then gradually refined. In this paper we propose an approach to \u201cagile modeling\u201d that exploits island grammars to extract initial coarse-grained models, parser combinators to enable gradual refinement of model importers, and various heuristics to recognize language structure, keywords and other language artifacts.", "num_citations": "12\n", "authors": ["104"]}
{"title": "Overview of webclef 2007\n", "abstract": " This paper describes the WebCLEF 2007 task. The task definition\u2014which goes beyond traditional navigational queries and is concerned with undirected information search goals\u2014combines insights gained at previous editions of WebCLEF and of the WiQA pilot that was run at CLEF 2006. We detail the task, the assessment procedure and the results achieved by the participants.", "num_citations": "12\n", "authors": ["104"]}
{"title": "Parsing by example\n", "abstract": " We live in a world where we are surrounded with information technology. The software systems around us are countless. All of those systems have been written once and must be maintained today. While a system evolves it becomes difficult to maintain. We use reengineering tools today to simplify maintenance tasks. With the support of such tools we can change the form of software systems in a way that makes them easier to analyze.Before we can use any reengineering tool with a software system we must reverse engineer that system. To reverse engineer a software system means that we need to build a model from the system. This model represents our system in a more abstract way than the source code itself does. The way from the source code to the model is often a problem. If a reengineering tool supports a specific model the maintainers of that tool must provide a parser for every programming language they want to support. Such parsers translate source code written in a particular language into a model. There are so many languages used in systems today that it is not possible to support all of them. Additionally, the languages themselves evolve and so we need parsers for every version and every dialect of a programming language. There are a number of approaches to solve that problem (for example fuzzy parsing). Most of these approaches are not flexible enough for today\u2019s needs: We cannot adapt them to another programming language or if we can we need a lot of knowledge about the language and about the whole parsing technique. Depending on the technique that we use we must write a parser or at least a grammar as a\u00a0\u2026", "num_citations": "12\n", "authors": ["104"]}
{"title": "Triggering Active Objects\n", "abstract": " Active objects are concurrent, active entities based on the object-oriented paradigm. We present a model for understanding active objects based on the remote procedure call, and on the notion of activities, which capture a single-thread flow of control between objects. We also present simple mechanisms for creating activities, interleaving and delaying activities, and for constructing atomic actions and concurrent subactivities. We show how these mechanisms can be used to capture very general forms of triggering. Our model for active objects, and the mechanisms for manipulating activities are embedded in Hybrid, a concurrent, object-oriented language. The model is also useful for understanding and dealing with deadlock in such systems.", "num_citations": "12\n", "authors": ["104"]}
{"title": "Transactional memory in a dynamic language\n", "abstract": " Concurrency control is mostly based on locks and is therefore notoriously difficult to use. Even though some programming languages provide high-level constructs, these add complexity and potentially hard-to-detect bugs to the application. Transactional memory is an attractive mechanism that does not have the drawbacks of locks, however, the underlying implementation is often difficult to integrate into an existing language. In this paper we show how we have introduced transactional semantics into Smalltalk by using the reflective facilities of the language. Our approach is based on method annotations, incremental parse tree transformations and an optimistic commit protocol. The implementation does not depend on modifications to the virtual machine and therefore can be changed at the language level. We report on a practical case study, benchmarks and further and on-going work.", "num_citations": "11\n", "authors": ["104"]}
{"title": "Transactional memory for Smalltalk\n", "abstract": " Concurrency control in Smalltalk is based on locks and is therefore notoriously difficult to use. Even though some implementations provide high-level constructs, these add complexity and potentially hard-to-detect bugs to the application. Transactional memory is an attractive mechanism that does not have the drawbacks of locks, however the underlying implementation is often difficult to integrate into an existing language. In this paper we show how we have introduced transactional semantics in Smalltalk by using the reflective facilities of the language. Our approach is based on method annotations, incremental parse tree transformations and an optimistic commit protocol. We report on a practical case study, benchmarks and further and on-going work.", "num_citations": "11\n", "authors": ["104"]}
{"title": "Idioms for composing games with etoys\n", "abstract": " Creating one's own games has been the main motivation for many people to learn programming. But the barrier to learn a general purpose programming language is very high, especially if some positive results can only be expected after having manually written more than 100 lines of code. With this paper we first motivate potential users by showing that one can create classic board- and arcade games like Lights Out, TicTacToe, or Pacman within the playful and constructivist visual learning environment EToys dragging together only a few lines of code. Then we present recurring idioms which helped to develop these games", "num_citations": "11\n", "authors": ["104"]}
{"title": "Contractual types\n", "abstract": " Real software systems are open and evolving. It is a constant challenge in such environments to ensure that software components are safely composed in the face of changing dependencies and incomplete knowledge. To address this problem, we propose a new kind of type system which allows us to infer not only the type provided by a software component in an open system, but also the type it requires of its environment, subject to certain constraints. The contractual type we infer for components can then be statically checked when components are composed. To illustrate our approach, we introduce the form calculus, a calculus of explicit environments, and we present a type system that infers types for form expressions.", "num_citations": "11\n", "authors": ["104"]}
{"title": "The impact of feature selection on predicting the number of bugs\n", "abstract": " Bug prediction is the process of training a machine learning model on software metrics and fault information to predict bugs in software entities. While feature selection is an important step in building a robust prediction model, there is insufficient evidence about its impact on predicting the number of bugs in software systems. We study the impact of both correlation-based feature selection (CFS) filter methods and wrapper feature selection methods on five widely-used prediction models and demonstrate how these models perform with or without feature selection to predict the number of bugs in five different open source Java software systems. Our results show that wrappers outperform the CFS filter; they improve prediction accuracy by up to 33% while eliminating more than half of the features. We also observe that though the same feature selection method chooses different feature subsets in different projects, this subset always contains a mix of source code and change metrics.", "num_citations": "10\n", "authors": ["104"]}
{"title": "Exploring cheap type inference heuristics in dynamically typed languages\n", "abstract": " Although dynamically typed languages allow developers to be more productive in writing source code, their lack of in-formation about types of variables is one of the main obstacles during program comprehension. Static type information helps developers to decrease software maintenance time. Inference of types of variables requires complex algorithms to avoid false positives or negatives. Their main aim is to shorten the list of possible types for a variable. We have developed a couple of cheap heuristics that use easily accessible information about the presence of each class in the available source code to promote the correct type towards the top of the list of possible types for a variable. Our evaluation of a proof-of-concept prototype, implemented in Pharo Smalltalk, shows that both for domain-specific types and standard libraries these heuristics tend to work well. The evaluated heuristics prove to be reasonably\u00a0\u2026", "num_citations": "10\n", "authors": ["104"]}
{"title": "A promising approach for debugging remote promises\n", "abstract": " Promises are synchronization constructs that hide the complexity of process synchronisation from the developer by providing a placeholder for the result of a potentially incomplete computation performed in a concurrent process.", "num_citations": "10\n", "authors": ["104"]}
{"title": "Communityexplorer: A framework for visualizing collaboration networks\n", "abstract": " Understanding the network of collaborations, identifying the key players, potential future collaborators, and trends in the field are very important to carry out a project successfully. In this paper, we present CommunityExplorer, a visualization framework that facilitates presenting, exploring, and understanding the network of collaborations at once. The framework performs data extraction, parsing, and modeling automatically. It is easy to adopt and utilizes a bigraph visualization that scales well. We demonstrate the advantage of CommunityExplorer to identify the collaboration of authors on 346 and 104 research papers published in SOTFVIS/VISSOFT and IWST communities respectively. We found that even though SOFTVIS/VISSOFT has more contributors, IWST exhibits more collaboration. We discovered that contributors in IWST are more resilient than those in SOFTVIS/VISSOFT, which are more volatile. Moreover\u00a0\u2026", "num_citations": "10\n", "authors": ["104"]}
{"title": "Inferring types by mining class usage frequency from inline caches\n", "abstract": " Dynamically typed languages allow developers to write more expressive source code, but their lack of static information about types of variables increases the complexity of a program. Static type information about types of variables facilitates program comprehension and maintenance.", "num_citations": "10\n", "authors": ["104"]}
{"title": "Lessons in software evolution learned by listening to smalltalk\n", "abstract": " The biggest challenge facing software developers today is how to gracefully evolve complex software systems in the face of changing requirements. We clearly need software systems to be more dynamic, compositional and model-centric, but instead we continue to build systems that are static, baroque and inflexible. How can we better build change-enabled systems in the future? To answer this question, we propose to look back to one of the most successful systems to support change, namely Smalltalk. We briefly introduce Smalltalk with a few simple examples, and draw some lessons for software evolution. Smalltalk\u2019s simplicity, its reflective design, and its highly dynamic nature all go a long way towards enabling change in Smalltalk applications. We then illustrate how these lessons work in practice by reviewing a number of research projects that support software evolution by exploiting Smalltalk\u2019s\u00a0\u2026", "num_citations": "10\n", "authors": ["104"]}
{"title": "Interactive 3-D visualization of feature-traces\n", "abstract": " The maintenance or reengineering of an object-oriented system includes its reverse engineering. In other words its internal structure and behavior needs to be understood. Many researchers have proposed different techniques to support the reverse engineering effort. The two predominant approaches to reverse engineering are:\u2022 static analysis of source code\u2022 dynamic analysis of behavior of a system at execution time.Both techniques have strengths and short comings. The static analysis of an object-oriented software system face difficulties such as polymorphism and it may be difficult to correlate parts with system functionality. Dynamic analysis approaches generally do not achieve full coverage of a software system. Moreover, due to the volume of data captured during dynamic analysis of a system, it is difficult to infer high-level views.", "num_citations": "10\n", "authors": ["104"]}
{"title": "A coordination component framework for open systems\n", "abstract": " Coordination technology addresses the construction of open, flexible systems from software agents in distributed systems. Most of the work on coordination technology so far has focused on the development of special coordination languages and environments that provide the basic mechanisms for realizing the coordination layer of a distributed application. Typically each new language proposes its own set of coordination abstractions that realizes a particular paradigm for realizing coordination. Coordination problems, however, are not always well-suited to a particular paradigm. Instead of proposing a new language, we are attempting to develop an open set of software components that realize various useful coordination abstractions. We are validating our approach by developing an experimental framework of coordination components in Java and applying them to a canonical set of sample applications. We present our initial analysis of the coordination domain, and give a few examples of simple applications using the developed coordination components.", "num_citations": "10\n", "authors": ["104"]}
{"title": "Using objects to implement office procedures\n", "abstract": " Office information systems (OISs) provide facilities for automatically triggering procedures when certain conditions become true or particular events take place such as receipt of mail. Such systems are characterized by a high degree of parallel activity that cooperates with but may run independently of user processes. Traditional high-level programming languages do not readily capture this sort of behaviour. This makes building a customized OIS a painful process.\" Objects\" are entities with contents and a set of rules describing their use. We believe that objects are a useful primitive for designing and building such systems quickly.", "num_citations": "10\n", "authors": ["104"]}
{"title": "Form procedures\n", "abstract": " This paper outlines an effort to introduce automation into an office forms system (OFS). OFS allows its users to perform a set of operations on electronic forms. Actions are triggered automatically when forms or combinations of forms arrive at particular nodes in the network of stations. The actions deal with operations on forms. This paper discusses the facilities provided for the specification of form-oriented automatic procedures and sketches their implementation.", "num_citations": "10\n", "authors": ["104"]}
{"title": "Idea: Benchmarking Android data leak detection tools\n", "abstract": " Virtual application stores for mobile platforms contain many malign and benign applications that exhibit security issues, such as the leaking of sensitive data. In recent years, researchers have proposed a myriad of techniques and tools to detect such issues automatically. However, it is unclear how these approaches perform compared to each other. The tools are often no longer available, thus comparing different approaches is almost infeasible. In this work, we propose an approach to execute static analysis tools and collect their output to obtain unified reports in a common format. We review the current state-of-the-art in Android data leak detection tools, and from a list of 87 approaches, of which we were able to obtain and execute five. We compare these using a set of known vulnerabilities and discuss the overall performance of the tools. We further present an approach to compare security analysis tools by\u00a0\u2026", "num_citations": "9\n", "authors": ["104"]}
{"title": "Spotter: towards a unified search interface in IDEs\n", "abstract": " Program comprehension requires developers to reason about many kinds of highly interconnected software entities. Dealing with this reality prompts developers to continuously intertwine searching and navigation. Nevertheless, most integrated development environments (IDEs) address searching by means of many disconnected search tools, making it difficult for developers to reuse search results produced by one search tool as input for another search tool. This forces developers to spend considerable time manually linking disconnected search results. To address this issue we propose Spotter, a model for expressing and combining search tools in a unified way. The current implementation shows that Spotter can unify a wide range of search tools. More information about Spotter can be found at scg. unibe. ch/research/moldablespotter.", "num_citations": "9\n", "authors": ["104"]}
{"title": "GTInspector: A moldable domain-aware object inspector\n", "abstract": " Understanding the run-time behaviour of object-oriented applications entails the comprehension of run-time objects. Traditional object inspectors favor generic views that focus on the low-level details of the state of single objects. While universally applicable, this generic approach does not take into account the varying needs of developers that could benefit from tailored views and exploration possibilities. GTInspector is a novel moldable object inspector that provides different high-level ways to visualize and explore objects, adapted to both the object and the current developer need. More information about the GTInspector can be found at: scg. unibe. ch/research/moldableinspector", "num_citations": "9\n", "authors": ["104"]}
{"title": "The Moldable Inspector: a framework for domain-specific object inspection\n", "abstract": " Answering run-time questions in object-oriented systems involves reasoning about and exploring connections between multiple objects. Developer questions exercise various aspects of an object and require multiple kinds of interactions depending on the relationships between objects, the application domain and the differing developer needs. Nevertheless, traditional object inspectors, the essential tools often used to reason about objects, favor a generic view that focuses on the low-level details of the state of individual objects. This leads to an inefficient effort, increasing the time spent in the inspector. To improve the inspection process, we propose the Moldable Inspector, a novel approach for an extensible object inspector. The Moldable Inspector allows developers to look at objects using multiple interchangeable presentations and supports a workflow in which multiple levels of connecting objects can be seen together. Both these aspects can be tailored to the domain of the objects and the question at hand. We further exemplify how the proposed solution improves the inspection process, introduce a prototype implementation and discuss new directions for extending the Moldable Inspector.", "num_citations": "9\n", "authors": ["104"]}
{"title": "Exposing side effects in execution traces\n", "abstract": " We need to understand the impact of side effects whenever changing complex object-oriented software systems. This can be difficult as side effects are at best implicit in static views of the software, and typically execution traces do not capture data flow between parts of the system. To solve this problem, we complement execution traces with dynamic object flow information. In our previous work we analyzed object flows between features and classes. In this paper, we use object flow information to analyze side effects in execution traces and to detect how future behavior in the trace is affected by it. Using a visualization, the developer can study how a selected part of the program accessed program state and what side effect its execution produced. Like this, the developer can investigate how a particular part of the program works without needing to understand the source code in detail. To illustrate our approach, we use a running example of writing unit tests for a legacy system.", "num_citations": "9\n", "authors": ["104"]}
{"title": "Supporting feature analysis with runtime annotations\n", "abstract": " The dynamic analysis approach to feature identification describes a technique for capturing feature behavior and mapping it to source code. Major drawbacks of this approach are (1) large amounts of data and (2) lack of support for sub-method elements. In this paper we propose to leverage sub-method reflection to identify and model features. We perform an on-the-fly analysis resulting in annotating the operations participating in a feature's behavior with meta-data.The primary advantage of our annotation approach is that we obtain a fine-grained level of granularity while at the same time eliminating the need to retain and analyze large traces for feature analysis.", "num_citations": "9\n", "authors": ["104"]}
{"title": "Scripting: Higher-level programming for component-based systems\n", "abstract": " Components and Modules can be written in Python or in C/C++. A client of a module is not aware whether it is written in Python or in a system programming language. On systems with dynamic loading, recompilation of the Python interpreter is not necessary; a module itself has to be a shared library.# see python: 1", "num_citations": "9\n", "authors": ["104"]}
{"title": "Object-Based Distributed Programming: ECOOP'93 Workshop, Kaiserslautern, Germany, July 26-27, 1993. Proceedings\n", "abstract": " Interest has grown rapidly over the past dozen years in the application of object-oriented programming and methods to the development of distributed, open systems. This volume presents the proceedings of a workshop intended to assess the current state of research in this field and to facilitate interaction between groups working on very different aspects of object-oriented distributed systems. The workshop was held as part of the 1993 European Conference on Object-Oriented Programming (ECOOP'93). Over fifty people submitted position papers and participated in the workshop, and almost half presented papers. The presented papers were carefully reviewed and revised after the workshop, and 14 papers were selected for this volume.", "num_citations": "9\n", "authors": ["104"]}
{"title": "It's duck (typing) season!\n", "abstract": " Duck typing provides a way to reuse code and allow a developer to write more extensible code. At the same time, it scatters the implementation of a functionality over multiple classes and causes difficulties in program comprehension. The extent to which duck typing is used in real programs is not very well understood. We report on a preliminary study of the prevalence of duck typing in more than a thousand dynamically-typed open source software systems developed in Smalltalk. Although a small portion of the call sites in these systems is duck-typed, in half of the analysed systems at least 20% of methods are duck-typed.", "num_citations": "8\n", "authors": ["104"]}
{"title": "On the evolution of exception usage in Java projects\n", "abstract": " Programming languages use exceptions to handle abnormal situations during the execution of a program. While programming languages often provide a set of standard exceptions, developers can further create custom exceptions to capture relevant data about project- and domain-specific errors. We hypothesize that, given their usefulness, custom exceptions are used increasingly as software systems mature. To assess this claim, we empirically analyze the evolution of exceptions and exception-handling code within four, popular and long-lived Java systems. We observe that indeed the amount of error-handling code, together with the number of custom exceptions and their usage in catch handlers and throw statements increase as projects evolve. However, we find that the usage of standard exceptions increases more than the usage of custom exceptions in both catch handlers and throw statements. A\u00a0\u2026", "num_citations": "8\n", "authors": ["104"]}
{"title": "Modeling features at runtime\n", "abstract": " A feature represents a functional requirement fulfilled by a system. Since many maintenance tasks are expressed in terms of features, it is important to establish the correspondence between a feature and its implementation in source code. Traditional approaches to establish this correspondence exercise features to generate a trace of runtime events, which is then processed by post-mortem analysis. These approaches typically generate large amounts of data to analyze. Due to their static nature, these approaches do not support incremental and interactive analysis of features. We propose a radically different approach called live feature analysis, which provides a model at runtime of features. Our approach analyzes features on a running system and also makes it possible to \u201cgrow\u201d feature representations by exercising different scenarios of the same feature, and identifies execution elements even to the\u00a0\u2026", "num_citations": "8\n", "authors": ["104"]}
{"title": "Ten things I hate about object-oriented programming\n", "abstract": " BORIS Deutsch English Fran\u00e7ais Login BORIS Bern Open Repository and Information System University of Bern Home Statistics Ten Things I Hate About Object-Oriented Programming Nierstrasz, Oscar (2010). Ten Things I Hate About Object-Oriented Programming. Journal of Object Technology, 9(5) Z\u00fcrich: AITO 10.5381/jot...e1 Full text not available from this repository. (Request a copy) Item Type: Journal Article (Original Article) Division/Institute: 08 Faculty of Science > Institute of Computer Science (INF) 08 Faculty of Science > Institute of Computer Science (INF) > Software Composition Group (SCG) UniBE Contributor: Nierstrasz, Oscar Marius ISSN: 1660-1769 Publisher: AITO Language: English Submitter: Factscience Import Date Deposited: 04 Oct 2013 14:17 Last Modified: 12 Sep 2017 10:12 Publisher DOI: 10.5381/jot...e1 URI: https://boris.unibe.ch/id/eprint/4957 (FactScience: 209616) Actions (login required\u2026", "num_citations": "8\n", "authors": ["104"]}
{"title": "CompAS: A new approach to commonality and variability analysis with applications in computer assisted orthopaedic surgery\n", "abstract": " In rapidly evolving domains such as Computer Assisted Orthopaedic Surgery (CAOS) emphasis is often put first on innovation and new functionality, rather than in developing the common infrastructure needed to support integration and reuse of these innovations. In fact, developing such an infrastructure is often considered to be a high-risk venture given the volatility of such a domain. We present CompAS, a method that exploits the very evolution of innovations in the domain to carry out the necessary quantitative and qualitative commonality and variability analysis, especially in the case of scarce system documentation. We show how our technique applies to the CAOS domain by using conference proceedings as a key source of information about the evolution of features in CAOS systems over a period of several years. We detect and classify evolution patterns to determine functional commonality and variability\u00a0\u2026", "num_citations": "8\n", "authors": ["104"]}
{"title": "A Calculus of Evolving Objects.\n", "abstract": " The demands of developing modern, highly dynamic applications have led to an increasing interest in dynamic programming languages and mechanisms. Not only must applications evolve over time, but the object models themselves may need to be adapted to the requirements of different run-time contexts. Class-based models and prototype-based models, for example, may need to co-exist to meet the demands of dynamically evolving applications. Multi-dimensional dispatch, fine-grained and dynamic software composition, and run-time evolution of behaviour are further examples of diverse mechanisms which may need to co-exist in a dynamically evolving run-time environment. How can we model the semantics of these highly dynamic features, yet still offer some reasonable safety guarantees? To this end we present an original calculus in which objects can adapt their behaviour at run-time. Both objects and environments are represented by first-class mappings between variables and values. Message sends are dynamically resolved to method calls. Variables may be dynamically bound, making it possible to model a variety of dynamic mechanisms within the same calculus. Despite the highly dynamic nature of the calculus, safety properties are assured by a type assignment system.", "num_citations": "8\n", "authors": ["104"]}
{"title": "An object-based visual scripting environment\n", "abstract": " Scripting is a programming technique in which applications are constructed by com-posing specially designed, pre-packaged software components using a restricted set of scripting operators. Scripting simplifies programming by cutting down the number of the syntactic and semantic features found in a complete programming language, yet is inherently open-ended in that software components can be provided by a separate target language. We explore scripting models in which the basic components are written in an object-oriented target language. We introduce a visual scripting tool as a script development environment. Visual scripts present components and links graphically, and a visual scripting tool supports the construction of scripts through the interactive editing of scripts' graphical counterparts.", "num_citations": "8\n", "authors": ["104"]}
{"title": "Towards moldable development tools\n", "abstract": " Developers commonly ask detailed and domain-specific questions about the software systems they are developing and maintaining. Integrated development environments (IDEs) form an essential category of tools for developing software that should support software engineering decision making. Unfortunately, rigid and generic IDEs that focus on low-level programming tasks, that promote code rather than data, and that suppress customization, offer limited support for informed decision making during software development. We propose to improve decision making within IDEs by moving from generic to context-aware IDEs through moldable tools. In this paper, we promote the idea of moldable tools, illustrate it with concrete examples, and discuss future research directions.", "num_citations": "7\n", "authors": ["104"]}
{"title": "Agile software assessment with Moose\n", "abstract": " During software maintenance, much time is spent reading and assessing existing code. Unfortunately most of the tools available for exploring and assessing code, such as browsers, debuggers and profilers, focus on development tasks, and offer little to support program understanding. We present a platform for software and data analysis, called Moose, which enables the rapid development of custom tools for software assessment. We demonstrate how Moose supports agile software assessment through a series of demos, we illustrate some of the custom tools that have been developed, and we draw various lessons learned for future work in this domain", "num_citations": "7\n", "authors": ["104"]}
{"title": "Using first-class contexts to realize dynamic software updates\n", "abstract": " Applications that need to be updated but cannot be easily restarted must be updated at run-time. We evaluate the reflective facilities of Smalltalk with respect to dynamic software and the state-of-the-art in this field. We conclude that while fine for debugging, the existing reflective facilities are not appropriate for dynamically updating production systems under constant load. We propose to enable dynamic updates by introducing first-class contexts as a mechanism to allow multiple versions of objects to coexist. Object states can be dynamically migrated from one context to another, and can be kept in sync with the help of bidirectional transformations. We demonstrate our approach with ActiveContext, an extension of Smalltalk with first-class contexts. ActiveContext eliminates the need for a system to be quiescent for it to be updated. ActiveContext is realized in Pinocchio, an experimental Smalltalk implementation that\u00a0\u2026", "num_citations": "7\n", "authors": ["104"]}
{"title": "A unified framework using spatial color descriptor and motion-based post refinement for shot boundary detection\n", "abstract": " We propose a unified framework which combines a novel color representation, i.e. spatial color descriptors, and a post-refinement process to detect various types of shot boundaries, including abrupt shot changes, flashlights, dissolves, fade-ins and fade-outs. The spatial color descriptor involving color adjacency and color vector angle histograms incorporates spatial information into color representation and provides robust performance in shot boundary detection. Moreover, a motion-based post-refinement process is developed to effectively eliminate false positives in gradual transition detection, where rapid camera motion or object movement may lead to performance degradation. Experimental results show that these two techniques are integrated seamlessly to give satisfactory performance and present the robustness of spatial color descriptors.", "num_citations": "7\n", "authors": ["104"]}
{"title": "Agents everywhere, all the time\n", "abstract": " Moore\u2019s Law is pushing us inevitably towards a world of pervasive, wireless, spontaneously networked computing devices. Whatever these devices do, they will have to talk to and negotiate with one another, and so software agents will have to represent them. Whereas conventional services on intranets will continue to be distributed using established middleware standards, internet services are being built on top of http, wap or other protocols, and exchange information in HTML, XML, and just about anything that can be wrapped as a MIME type or streamed. This situation leads us to three software problems:(i) How can we simplify the task of programming these agents?(ie, Java is not enough),(ii) How can agents interact and interoperate in an open, evolving network environment?(ie, XML is not enough),(iii) How can we reason about the services that agents provide and use?(ie, IDL is not enough). We discuss these questions in the context of our work on Piccola, a small composition language, and outline ongoing and further research.", "num_citations": "7\n", "authors": ["104"]}
{"title": "A coordination component framework for open distributed systems\n", "abstract": " We have investigated software development for open distributed systems in order to make this development easier. Easier in the sense that software parts will be better reusable, more flexible and better maintainable. The hardest part is to address evolution of these systems because not all application requirements can be known in advance. In particular we have investigated the coordination aspects of open distributed systems. Coordination technology addresses the management of interaction of software agents in a distributed or parallel environment and, therefore, typically describes architectural aspects of a system. To reach the goal of easier software development we have applied a component oriented approach: generic coordination solutions are provided as generic architectures with blackbox components. Applications are constructed using these architectures and composing and parameterizing these generic components. In this way we make the interaction part of a system reusable and flexible. The architecture of the system is also made clearer and therefore easier understandable.A prototype coordination framework and a set of sample applications that are representative for open distributed systems and that use this framework, have been developed in the concurrent object-oriented programming language Java. We show that, using our component-oriented approach, we gain reusability, flexibility and provide clear architectures of applications. A major problem, however, concerning the genericity of components, is the application dependent information that may be needed by a coordination solution: the genericity of the solution is\u00a0\u2026", "num_citations": "7\n", "authors": ["104"]}
{"title": "Temporal scripting using tempo\n", "abstract": " A language for scheduling temporal activities in an object-oriented environment is proposed. Particular emphasis is put on reusing temporal speci cations in various contexts, which is achieved through a mechanism of parameterized sampling based on a notion of virtual time. A small set of temporal operators are used to build parallel and sequential compositions of activities. Complex activities can be encapsulated as object methods, thereby making them more easily reusable. The system, called TEMPO, has been implemented within C++; it has been used for generating computer animations, and is easily extendable to other time-driven applications.", "num_citations": "7\n", "authors": ["104"]}
{"title": "ECOOP'93-Object-Oriented Programming: 7th European Conference, Kaiserslautern, Germany, July 26-30, 1993. Proceedings\n", "abstract": " It is now more than twenty-five years since object-oriented programming was \u201cinve-ed\u201d(actually, more than thirty years since work on Simula started), but, by all accounts, it would appear as if object-oriented technology has only been \u201cdiscovered\u201d in the past ten years! When the first European Conference on Object-Oriented Programming was held in Paris in 1987, I think it was generally assumed that Object-Oriented Progr-ming, like Structured Programming, would quickly enter the vernacular, and that a c-ference on the subject would rapidly become superfluous. On the contrary, the range and impact of object-oriented approaches and methods continues to expand, and,-spite the inevitable oversell and hype, object-oriented technology has reached a level of scientific maturity that few could have foreseen ten years ago. Object-oriented technology also cuts across scientific cultural boundaries like p-haps no other field of computer science, as object-oriented concepts can be applied to virtually all the other areas and affect virtually all aspects of the software life cycle.(So, in retrospect, emphasizing just Programming in the name of the conference was perhaps somewhat short-sighted, but at least the acronym is pronounceable and easy to rem-ber!) This year\u2019s ECOOP attracted 146 submissions from around the world-making the selection process even tougher than usual. The selected papers range in topic from programming language and database issues to analysis and design and reuse, and from experience reports to theoretical contributions.", "num_citations": "7\n", "authors": ["104"]}
{"title": "CHASSIS-Une Plate-forme pour la Construction de Syst\u00e8mes d'Information Ouverts\n", "abstract": " Les syst\u00e8mes d'information d'aujourd'hui ont de plus en plus la n\u00e9cessit\u00e9 d'\u00eatre ouverts. Ceci implique qu'ils doivent r\u00e9pondre aux besoins de r\u00e9seaux ouverts, de logiciel et de mat\u00e9riel h\u00e9t\u00e9rog\u00e8nes et \u201cinterop\u00e9rables,\u201d et, surtout, \u00e0 des besoins \u00e9volutifs et changeants. Le projet CHASSIS vise le d\u00e9veloppement d'un cadre informatique et m\u00e9thodologique pour la conception et la construction de syst\u00e8mes d'information h\u00e9t\u00e9rog\u00e8nes, s\u00fbrs et fiables \u00e0 partir de composants de logiciel et bases de donn\u00e9es soit d\u00e9j\u00e0 existants soit d\u00e9velopp\u00e9s pour l'occasion, et leur int\u00e9gration s\u00fbre et fiable. Dans CHASSIS, l'orientation-objet est la technologie cl\u00e9 pour la construction d'un tel syst\u00e8me, car son interface uniforme est r\u00e9alis\u00e9e par un mod\u00e8le de donn\u00e9es orient\u00e9-objet, et la couche d'int\u00e9gration est r\u00e9alis\u00e9e par du logiciel orient\u00e9-objet. CHASSIS consiste en des mod\u00e8les objets pour l'int\u00e9gration de base de donn\u00e9es et langages de programmation, du logiciel orient\u00e9-objet pour l'int\u00e9gration des syst\u00e8mes, des m\u00e9thodes de sp\u00e9cification pour soutenir le processus de conception, et des m\u00e9canismes de s\u00e9curit\u00e9 avanc\u00e9s qui permettent d'assurer un haut degr\u00e9 de s\u00e9curit\u00e9 pour le syst\u00e8me d'information r\u00e9sultant. CHASSIS est un projet de collaboration Suisse entre l'Universit\u00e9 de Z\u00fcrich, l'Universit\u00e9 de Gen\u00e8ve, et le centre de recherche d'Asea Brown Boveri (Baden).", "num_citations": "7\n", "authors": ["104"]}
{"title": "Prototyping in einer objektorientierten Entwicklungsumgebung\n", "abstract": " Prototyping von Software ist eine Entwurfstechnik, die durch einen zyklischen Entwurfsproze\u00df und durch die rasche Entwicklung von operationalen Systemen \u201cbessere\u201d Software, im Sinn von zuverl\u00e4ssiger und den Anforderungen entsprechend, erzeugen hilft. Objektorientierte Programmierung ist eine Programmiertechnik, die durch die Wiederverwendung bereits existierender Softwareobjekte ausgezeichnet ist. Die wichtigsten Mechanismen in objektorientierten Sprachen zur Wiederverwendung sind die (mehrfache) Vererbung und die Instantiierung von Objektklassen. Dabei zeigt sich, da\u00df die objektorientierte Programmierung nicht nur verschiedene in der Literatur bekannte Prototypingans\u00e4tze unterst\u00fctzt, sondern auch da\u00df Prototyping ein inh\u00e4rentes Konzept im objektorientierten Software Lifecycle darstellt. Welche Werkzeuge und Entwicklungsumgebungen ben\u00f6tigt werden, um einen objektorientierten Prototypingansatz Realit\u00e4t werden zu lassen, wird diskutiert.", "num_citations": "7\n", "authors": ["104"]}
{"title": "Towards a Catalogue of Mobile Elicitation Techniques\n", "abstract": " [Context and Motivation] Mobile apps are crucial for many businesses. Their reach and impact on the end users and on the business in return demands that requirements are elicited carefully and properly. Traditional requirements elicitation techniques may not be adequate in the mobile apps domain. [Question/problem] Researchers have proposed numerous requirements elicitation techniques for the mobile app domain, but unfortunately, the community still lacks a comprehensive overview of available techniques. [Principle ideas/results] This paper presents a literature survey of about 60 relevant publications, in which we identify 24 techniques that target mobile apps. We found that only every second strategy was evaluated empirically, and even worse, non-functional requirements were rarely considered. We provide an evaluation scheme that is intended to support readers in efficiently finding\u00a0\u2026", "num_citations": "6\n", "authors": ["104"]}
{"title": "Exploiting type hints in method argument names to improve lightweight type inference\n", "abstract": " The lack of static type information is one of the main obstacles to program comprehension in dynamically-typed languages. While static type inference algorithms try to remedy this problem, they usually suffer from the problem of false positives or false negatives. In order to partially compensate for the lack of static type information, a common practice in dynamically-typed languages is to name or annotate method arguments in such a way that they reveal their expected type, e.g., aString, anInt, or string: String. Recent studies confirmed that these type annotations are indeed frequently used by developers in dynamically-typed languages. We propose a lightweight heuristic that uses these hints from method argument names to augment the performance of a static type inference algorithm. The evaluation through a proof-of-concept prototype implemented in Pharo Smalltalk shows that the augmented algorithm\u00a0\u2026", "num_citations": "6\n", "authors": ["104"]}
{"title": "Towards improving the mental model of software developers through cartographic visualization\n", "abstract": " Software is intangible and knowledge about software systems is typically tacit. The mental model of software developers is thus an important factor in software engineering. It is our vision that developers should be able to refer to code as being \"up in the north\", \"over in the west\", or \"down-under in the south\". We want to provide developers, and everyone else involved in software development, with a *shared*, spatial and stable mental model of their software project. We aim to reinforce this by embedding a cartographic visualization in the IDE (Integrated Development Environment). The visualization is always visible in the bottom-left, similar to the GPS navigation device for car drivers. For each development task, related information is displayed on the map. In this paper we present CODEMAP, an eclipse plug-in, and report on preliminary results from an ongoing user study with professional developers and students.", "num_citations": "6\n", "authors": ["104"]}
{"title": "Senseo: Enriching Eclipse's static source views with dynamic metrics\n", "abstract": " Maintaining object-oriented systems that use inheritance and polymorphism is difficult, since runtime information, such as which methods are actually invoked at a call site, is not visible in the static source code. We have implemented Senseo, an Eclipse plugin enhancing Eclipse's static source views with various dynamic metrics, such as runtime types, the number of objects created, or the amount of memory allocated in particular methods.", "num_citations": "6\n", "authors": ["104"]}
{"title": "Practical, pluggable types\n", "abstract": " Most languages fall into one of two camps: either they adopt a unique, static type system, or they abandon static type-checks for runtime checks. Pluggable types blur this division by (i) making static type systems optional, and (ii) supporting a choice of type systems for reasoning about different kinds of static properties. Dynamic languages can then benefit from static-checking without sacrificing dynamic features or committing to a unique, static type system. But the overhead of adopting pluggable types can be very high, especially if all existing code must be decorated with type annotations before any type-checking can be performed. We propose a practical and pragmatic approach to introduce pluggable type systems to dynamic languages. First of all, only annotated code is type-checked. Second, limited type inference is performed on unannotated code to reduce the number of reported errors. Finally, external\u00a0\u2026", "num_citations": "6\n", "authors": ["104"]}
{"title": "Moose\u2014a Language-Independent Reengineering Environment\n", "abstract": " Aging software systems are difficult and expensive to maintain. Moose is a language-independent environment that supports a wide range of tools to visualise, analyse and manipulate complex software systems.", "num_citations": "6\n", "authors": ["104"]}
{"title": "A guide to JPiccola\n", "abstract": " Piccola is small, experimental composition language\u2014a language for building applications from software components implemented in another, host programming language. This document describes JPiccola, the implementation of Piccola for the Java host language. Chapter 1 (\u201cPiccola in a Nutshell\u201d) presents a small example that illustrates the key concepts of Piccola. Chapter 2 presents a step-by-step tutorial of JPiccola including exercises that can be carried out with JPiccola version 3.7 a.", "num_citations": "6\n", "authors": ["104"]}
{"title": "Measuring the Effects of Object-Oriented Frameworks on the Software Process\n", "abstract": " A field study of over thirty projects using Object Technology has shown that the availability (or absence) of reusable frameworks has substantial productivity impacts. This can make it more difficult to reliably estimate the size and cost of such projects early in the software process. The newly proposed System Meter method tackles this problem by distinguishing functionality to be implemented from functionality supported by reusable components. It therefore yields more uniform and predictable productivity measures. Moreover, it can also be applied already after a preliminary analysis phase, in contrast to the more traditional Function Points approach.", "num_citations": "6\n", "authors": ["104"]}
{"title": "Java Cryptography Uses in the Wild\n", "abstract": " [Background] Previous research has shown that developers commonly misuse cryptography APIs.[Aim] We have conducted an exploratory study to find out how crypto APIs are used in open-source Java projects, what types of misuses exist, and why developers make such mistakes.[Method] We used a static analysis tool to analyze hundreds of open-source Java projects that rely on Java Cryptography Architecture, and manually inspected half of the analysis results to assess the tool results. We also contacted the maintainers of these projects by creating an issue on the GitHub repository of each project, and discussed the misuses with developers.[Results] We learned that 85% of Cryptography APIs are misused, however, not every misuse has severe consequences. Developer feedback showed that security caveats in the documentation of crypto APIs are rare, developers may overlook misuses that originate in\u00a0\u2026", "num_citations": "5\n", "authors": ["104"]}
{"title": "KOWALSKI: Collecting API clients in easy mode\n", "abstract": " Understanding API usage is important for upstream and downstream developers. However, compiling a dataset of API clients is often a tedious task, especially since one needs many clients to draw a representative picture of the API usage.In this paper, we present KOWALSKI, a tool that takes the name of an API, then finds and downloads client binaries by exploiting the Maven dependency management system. As a case study, we collect clients of Apache Lucene, the de facto standard for full-text search, analyze the binaries, and create a typed call graph that allows developers to identify hotspots in the API.A video demonstrating how KOWALSKI is used for this experiment can be found at https://youtu.be/zdx28GnoSRQ.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Efficiently extracting full parse trees using regular expressions with capture groups\n", "abstract": " Regular expressions with capture groups offer a concise and natural way to define parse trees over the text that they are parsing, however classical algorithms only return a single match for each capture group, not the full parse tree. We describe an algorithm based on finite-state automata that extracts full parse trees from text in \u0398 (n,m) time and \u0398(dn + m) space (where n is the size of the text, m the size of the pattern, and d the number of groups in the pattern). It is the first to do so in a single pass with complete control over greediness. This allows the algorithm to process streaming data using all constructs familiar to users of regular expressions.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Integrating textual and visual information for cross-language image retrieval\n", "abstract": " This paper explores the integration of textual and visual information for cross-language image retrieval. An approach which automatically transforms textual queries into visual representations is proposed. The relationships between text and images are mined. We employ the mined relationships to construct visual queries from textual ones. The retrieval results of textual and visual queries are combined. We conduct English monolingual and Chinese-English cross-language retrieval experiments to evaluate the proposed approach. The selection of suitable textual query terms to construct visual queries is the major concern. Experimental results show that the proposed approach improves retrieval performance, and nouns are appropriate to generate visual queries.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Separating concerns with first-class namespaces\n", "abstract": " As applications evolve, it becomes harder and harder to separate independent concerns. Small changes to a software system increasingly affect different parts of the source code. AOP and related approaches offer various ways to separate concerns into concrete software artifacts, but what is the essence of this process? We claim that first-class namespaces\u2014which we refer to as forms\u2014offer a suitable foundation for separating concerns by offering simple yet expressive mechanisms for defining composable abstractions. We demonstrate how forms help a programmer to separate concerns by means of practical examples in Piccola, an experimental composition language.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Supporting software change in the programming language\n", "abstract": " In this paper we briefly review various kinds of software changes and the issues that arise from them. As a consequence, we propose research into programming languages with explicit support for representing first-class changes, and for manipulating and merging multiple viewpoints of evolving software systems.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Typeful compositional styles\n", "abstract": " In component-based software development, a software application is composed of components that are plugged together. While components represent the stable parts, the changing or evolving configuration of a system is defined in scripts. The separation of changing from stable parts promises flexible software systems.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Piccola \u2014\u00a0a small compositional language (invited talk)\n", "abstract": " Piccola - A Small Compositional Language (Invited Talk) | Proceedings of the IFIP TC6/WG6.1 Third International Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS) ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsProceedings of the IFIP TC6/WG6.Third International Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS)Piccola - A Small Compositional Language (Invited Talk) Article Piccola - A Small Compositional Language (Invited Talk) Share on Author: Oscar Nierstrasz View Profile Authors Info & Affiliations Publication: Proceedings of the IFIP TC6/.-(\u2026", "num_citations": "5\n", "authors": ["104"]}
{"title": "Scripting applications in the public administration domain\n", "abstract": " Scripting is an approach for constructing open applications from prepackaged software components. A scripting model characterizes and standardizes the interconnection interfaces of software components appropriate to an application domain. We present a scripting model for the domain of public administration applications, and we provide a scenario of scripting applications in this domain. This scripting model is being incorporated into a prototype visual scripting tool which provides a graphical editing facility for interactively scripting applications.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Message flow modeling\n", "abstract": " A message management system provides users with a facility for automatically handling messages. This paper describes a technique for characterizing the behaviour of such a system in terms of message flow. Messages may be conveniently classed according to what path or sequences of stations they visit. Complicated or unpredictable behaviour may be modeled non-deterministically, and the resulting message paths are shown to be regular expressions.", "num_citations": "5\n", "authors": ["104"]}
{"title": "A combinatorial application of matrix Riccati equations and their q-analogue\n", "abstract": " The generating functions for a large class of combinatorial problems involving the enumeration of permutations may be expressed as solutions to matrix Riccati equations. We show that the generating functions for the permutation problem in which the number of inversions is also preserved form a system of matrix Riccati equations in which the differential operator is the Eulerian differential operator. We obtain the classical result of MacMahon concerning permutations.", "num_citations": "5\n", "authors": ["104"]}
{"title": "Replicomment: identifying clones in code comments\n", "abstract": " Code comments are the primary means to document implementation and facilitate program comprehension. Thus, their quality should be a primary concern to improve program maintenance. While much effort has been dedicated to detecting bad smells, such as clones in code, little work has focused on comments. In this paper we present our solution to detect clones in comments that developers should fix. RepliComment can automatically analyze Java projects and report instances of copy-and-paste errors in comments, and can point developers to which comments should be fixed. Moreover, it can report when clones are signs of poorly written comments. Developers should fix these instances too in order to improve the quality of the code documentation. Our evaluation of 10 well-known open source Java projects identified over 11K instances of comment clones, and over 1,300 of them are potentially critical. We\u00a0\u2026", "num_citations": "4\n", "authors": ["104"]}
{"title": "What do class comments tell us? An investigation of comment evolution and practices in Pharo Smalltalk\n", "abstract": " ObjectiveTherefore, our goal is to investigate developer commenting practices and compare them to the comment guidelines.MethodThis paper reports the first empirical study investigating commenting practices in Pharo Smalltalk. First, we analyze class comment evolution over seven Pharo versions. Then, we quantitatively and qualitatively investigate the information types embedded in class comments. Finally, we study the adherence of developer commenting practices to the official class comment template over Pharo versions.ResultsOur results show that there is a rapid increase in class comments in the initial three Pharo versions, while in subsequent versions developers added comments to both new and old classes, thus maintaining a similar code to comment ratio. We furthermore found three times as many information types in class comments as those suggested by the template. However, the information\u00a0\u2026", "num_citations": "4\n", "authors": ["104"]}
{"title": "Web APIs in Android through the lens of security\n", "abstract": " Web communication has become an indispensable characteristic of mobile apps. However, it is not clear what data the apps transmit, to whom, and what consequences such transmissions have. We analyzed the web communications found in mobile apps from the perspective of security. We first manually studied 160 Android apps to identify the commonly-used communication libraries, and to understand how they are used in these apps. We then developed a tool to statically identify web API URLs used in the apps, and restore the JSON data schemas including the type and value of each parameter. We extracted 9714 distinct web API URLs that were used in 3 376 apps. We found that developers often use the java.net package for network communication, however, third-party libraries like OkHttp are also used in many apps. We discovered that insecure HTTP connections are seven times more prevalent in closed\u00a0\u2026", "num_citations": "4\n", "authors": ["104"]}
{"title": "Moldable, context-aware searching with Spotter\n", "abstract": " Software systems involve many different kinds of domain-specific and interrelated software entities. A common strategy employed by developers to deal with this reality is to perform exploratory investigations by means of searching. Nevertheless, most integrated development environments (IDEs) support searching through generic and disconnected search tools. This impedes search tasks over domain-specific entities, as considerable effort is wasted by developers locating and linking data and concepts relevant to their application domains.", "num_citations": "4\n", "authors": ["104"]}
{"title": "Exemplifying moldable development\n", "abstract": " Developing and evolving software requires developers to continuously make decisions about how to steer the design and implementation of their applications. To make informed decisions developers commonly formulate detailed and domain-specific questions about their software systems and use tools to explore available information and answer those questions. Development tools however focus on generic programming tasks while program comprehension and analysis tools typically are not tightly integrated with their development tools and environments. This has a negative effect on program comprehension as it increases the effort and the time needed to obtain an answer.", "num_citations": "4\n", "authors": ["104"]}
{"title": "The death of object-oriented programming\n", "abstract": " Modern software systems are increasingly long-lived. In order to gracefully evolve these systems as they address new requirements, developers need to navigate effectively between domain concepts and the code that addresses those domains. One of the original promises of object-orientation was that the same object-oriented models would be used throughout requirements analysis, design and implementation. Software systems today however are commonly constructed from a heterogeneous \u201clanguage soup\u201d of mainstream code and dedicated DSLs addressing a variety of application and technical domains. Has object-oriented programming outlived its purpose?                 In this essay we argue that we need to rethink the original goals of object-orientation and their relevance for modern software development. We propose as a driving maxim, \u201cProgramming is Modeling,\u201d and explore what this implies\u00a0\u2026", "num_citations": "4\n", "authors": ["104"]}
{"title": "Ownership, filters and crossing handlers: flexible ownership in dynamic languages\n", "abstract": " Sharing mutable objects can result in broken invariants, exposure of internal details, and other subtle bugs. To prevent such issues, it is important to control accessibility and aliasing of objects. Dynamic Ownership is an effective way to do so, but its owner-as-dominator discipline is too restrictive: objects are either accessible or not. We propose in this paper to control accessibility and aliasing with more flexibility using two mechanisms, filters and crossing handlers. We demonstrate the benefits of the flexibility offered by these mechanisms, and report on the adaptation of a Smalltalk web server with our approach. We conclude that our variant of dynamic ownership is flexible enough to accommodate an existing design, while at the same time constraining it enough to highlight design anomalies.", "num_citations": "4\n", "authors": ["104"]}
{"title": "Language and Automata Theory and Applications\n", "abstract": " These proceedings contain the papers that were presented at the 9th International Conference on Language and Automata Theory and Applications (LATA 2015), held in Nice, France, during March 2\u20136, 2015.The scope of LATA is rather broad, including: algebraic language theory; algorithms for semi-structured data mining; algorithms on automata and words; automata and logic; automata for system analysis and program verification; automata networks; automata, concurrency, and Petri nets; automatic structures; cellular automata; codes; combinatorics on words; computational complexity; data and image compression; descriptional complexity; digital libraries and document engineering; foundations of finite state technology; foundations of XML; fuzzy and rough languages; grammars (Chomsky hierarchy, contextual, unification, categorial, etc.); grammatical inference and algorithmic learning; graphs and graph\u00a0\u2026", "num_citations": "4\n", "authors": ["104"]}
{"title": "Self-aware, evolving eternal systems\n", "abstract": " Few real software systems are built completely from scratch nowadays. Instead, systems are built iteratively and incrementally, while integrating and interacting with components from many other systems. These systems also last longer than their developers might imagine --- they are, in effect, eternal. Nevertheless the platforms, tools and environments we use to develop software are still largely based on an outmoded model that presupposes that software systems are closed and will not significantly evolve after deployment. We claim that in order to enable effective and graceful evolution of eternal systems, we must make them self-aware. A self-aware eternal system supports evolution by: (i) providing explicit, first-class models of software artifacts, change and history at the level of the platform, (ii) continuously analysing static and dynamic evolution to track emergent properties, and (iii) closing the gap between the domain model and the developers' view of the evolving system. We outline our vision of self-aware eternal systems and identify the research challenges to realizing this vision.", "num_citations": "4\n", "authors": ["104"]}
{"title": "Putting change at the center of the software process\n", "abstract": " For over thirty years now, software components have been perceived as being essential stepping stones towards flexible and maintainable software systems. But where do the components come from? Once we have the components, how do we put them together? And when we are missing components, how should we synthesize them?               Lehman and Belady established in a classic study that a number of \u201cLaws\u201d of Software Evolution apply to successful software projects [10]. Of these, the two most insightful are perhaps:                                                                            Continuing change: A program that is used in a real-world environment must change, or become progressively less useful in that environment.                                                                                             Increasing complexity: As a program evolves, it becomes more complex, and extra resources are needed to preserve and simplify its structure\u00a0\u2026", "num_citations": "4\n", "authors": ["104"]}
{"title": "Software Engineering--ESEC/FSE'99: 7th European Software Engineering Conference Held Jointly with the 7th ACM SIGSOFT Symposium on the Foundations of Software Engineering\u00a0\u2026\n", "abstract": " For the second time, the European Software Engineering Conference is being held jointly with the ACM SIGSOFT Symposium on the Foundations of Software Engine-ing (FSE). Although the two conferences have different origins and traditions, there is a significant overlap in intent and subject matter. Holding the conferences jointly when they are held in Europe helps to make these thematic links more explicit, and enco-ages researchers and practitioners to attend and submit papers to both events. The ESEC proceedings have traditionally been published by Springer-Verlag, as they are again this year, but by special arrangement, the proceedings will be distributed to members of ACM SIGSOFT, as is usually the case for FSE. ESEC/FSE is being held as a single event, rather than as a pair of collocated events. Submitted papers were therefore evaluated by a single program committee. ESEC/FSE represents a broad range of software engineering topics in (mainly) two continents, and consequently the program committee members were selected to represent a spectrum of both traditional and emerging software engineering topics. A total of 141 papers were submitted from around the globe. Of these, nearly half were classified as research-pers, aquarterasexperiencepapers, andtherestasbothresearchandexperiencepapers. Twenty-nine papers from five continents were selected for presentation and inclusion in the proceedings. Due to the large number of industrial experience reports submitted, we have also introduced this year two sessions on short case study presentations.", "num_citations": "4\n", "authors": ["104"]}
{"title": "APROCO A Programmable Coordination Medium\n", "abstract": " To keep up with rapidly changing requirements applications are increasingly built out of software components. A new trend is now to give those software components control over their own actions, to turn them into concurrently running software agents. These software agents have to be relatively independent to keep them exchangeable. Although independent, they still need to interact in order to achieve the application's overall goal. This results in the need to coordinate their interactions. A number of coordination models were created to express common coordination solutions. Linda is one of the most prominent representatives of such coordination models. Linda is widely used because it offers simple means to separate coordination code from computational code within a single agent. Linda also offers a high degree of decoupling of agents through its generative communication style. However, Linda offers no direct support for the concentration of the coordination aspects of a whole applica...", "num_citations": "4\n", "authors": ["104"]}
{"title": "Two models of concurrent objects\n", "abstract": " We propose two models of concurrent objects that address, respectively, methodological and semantic issues of object-oriented programming languages. The first is a conceptual model to aid in the design of object-oriented languages for concurrent and distributed applications, and the second is a computational model that can be used to define the semantics of such languages. The second model has evolved, in a sense, from the first, though it is intended to be both more neutral and more general.", "num_citations": "4\n", "authors": ["104"]}
{"title": "Caveats in eliciting mobile app requirements\n", "abstract": " Factors such as app stores or platform choices heavily affect functional and non-functional mobile app requirements. We surveyed 45 companies and interviewed ten experts to explore how factors that impact mobile app requirements are understood by requirements engineers in the mobile app industry.", "num_citations": "3\n", "authors": ["104"]}
{"title": "CryptoExplorer: An Interactive Web Platform Supporting Secure Use of Cryptography APIs\n", "abstract": " Research has shown that cryptographic APIs are hard to use. Consequently, developers resort to using code examples available in online information sources that are often not secure. We have developed a web platform, named CryptoExplorer, stocked with numerous real-world secure and insecure examples that developers can explore to learn how to use cryptographic APIs properly. This platform currently provides 3 263 secure uses, and 5 897 insecure uses of Java Cryptography Architecture mined from 2 324 Java projects on GitHub. A preliminary study shows that CryptoExplorer provides developers with secure crypto API use examples instantly, developers can save time compared to searching on the internet for such examples, and they learn to avoid using certain algorithms in APIs by studying misused API examples. We have a pipeline to regularly mine more projects, and, on request, we offer our dataset\u00a0\u2026", "num_citations": "3\n", "authors": ["104"]}
{"title": "The Object Repository: Pulling Objects out of the Ecosystem\n", "abstract": " In this paper we propose the idea of constructing an Object Repository--a repository of code snippets that, when executed, produce an instance of some class. Such a repository may be useful for several software engineering tasks like augmenting software documentation, testing object inspectors, improving program comprehension etc.", "num_citations": "3\n", "authors": ["104"]}
{"title": "Clone detection that scales\n", "abstract": " We show a clone detector that can scale to all source code ever written, in all versions. This is achieved by completely avoiding random reads from a central table, in other words all mappers and all reducers use, as input, only a contiguous slice of their input tables. Furthermore, we show the results of using our clone detector on 15,180 projects, all downloadable Java projects listed on the public meta repository \u201cohloh\u201d. On just three machines, we can finish clone detection across projects and versions in less than 20 hours. Besides offering a scaleable clone detector, our libraries allow anyone to download massive amounts of source code, store it space-efficiently and run cluster-style analysis on it, on commodity hardware. We intuit a reasonable configuration for the work load we have, and then systematically test the individual settings for performance, to tweak the overall configuration. ii", "num_citations": "3\n", "authors": ["104"]}
{"title": "Ownership, filters and crossing handlers\n", "abstract": " Sharing mutable objects can result in broken invariants, exposure of internal details, and other subtle bugs. To prevent such issues, it is important to control accessibility and aliasing of objects. Dynamic Ownership is an effective way to do so, but its owner-as-dominator discipline is too restrictive: objects are either accessible or not. We propose in this paper to control accessibility and aliasing with more flexibility using two mechanisms, filters and crossing handlers. We demonstrate the benefits of the flexibility offered by these mechanisms, and report on the adaptation of a Smalltalk web server with our approach. We conclude that our variant of dynamic ownership is flexible enough to accommodate an existing design, while at the same time constraining it enough to highlight design anomalies.", "num_citations": "3\n", "authors": ["104"]}
{"title": "Talents: Dynamically composable units of reuse\n", "abstract": " Reuse in object-oriented languages typically focuses on inheritance. Numerous techniques have been developed to provide finer-grained reuse of methods, such as flavors, mixins and traits. These techniques, however, only deal with reuse at the level of classes.", "num_citations": "3\n", "authors": ["104"]}
{"title": "Unifying subjectivity\n", "abstract": " Subjective behavior is essential for applications that must adapt their behavior to changing circumstances. Many different solutions have been proposed in the past, based, for example, on perspectives, roles, contextual layers, and \u201cforce trees\u201d. Although these approaches are somehow equally expressive, each imposes a particular world view which may not be appropriate for all applications. We propose a unification of these approaches, called Subjectopia, which makes explicit the underlying abstractions needed to support subjective behavior, namely subjects, contextual elements and decision strategies. We demonstrate how Subjectopia subsumes existing approaches, provides a more general foundation for modeling subjective behavior, and offers a means to alter subjective behavior in a running system.", "num_citations": "3\n", "authors": ["104"]}
{"title": "Model Driven Engineering Languages and Systems: 9th International Conference, MoDELS 2006, Genova, Italy, October 1-6, 2006, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 9th International Conference on Model Driven Engineering Languages and Systems (formerly UML conferences), MoDELS 2006. The book presents 51 revised full papers and 2 invited papers. Discussion is organized in topical sections on evaluating UML, MDA in software development, concrete syntax, applying UML to interaction and coordination, aspects, model integration, formal semantics of UML, security, model transformation tools and implementation, and more.", "num_citations": "3\n", "authors": ["104"]}
{"title": "Applying RMA for Scheduling Field Device Components\n", "abstract": " PECOS is a collaborative project between industrial and research partners that seeks to enable component-based technology for a class of embedded systems known as \u201cfield devices\u201d. Results so far include a component model for field devices and a composition language for specifying connections between software components. Here we investigate the application of Rate Monotonic Analysis (RMA) to the problem of generating real-time schedules for compositions of field device components.", "num_citations": "3\n", "authors": ["104"]}
{"title": "Implementing the FACE object model in C++\n", "abstract": " FACE is an object\u2013oriented, self-descripting data model with first-class types. FACE can be used to model software, eg object\u2013oriented frameworks. We explore techniques and mechanisms to implement the reflective FACE data model in the statically typed, object\u2013oriented language C++. Some comparison of FACE with other meta level approaches like MetaObject Protocols or Open Implementations is done, and a short example modeling software is described.", "num_citations": "3\n", "authors": ["104"]}
{"title": "How could object-oriented concepts and parallelism cohabit?\n", "abstract": " A lot of new languages and new concepts have been conceived in order to promote parallelism in the object-oriented framework. These proposals could be investigated using different concepts related to parallelism and object orientation. Among these concepts, we can find shared variables/message passing, inheritance/delegation, reflection. The degrees of a good cohabitation may be appreciated by combining the above concepts. In order to have significant criteria we have to determine how languages fit some requirements. These requirements should cover the different phases of programs development i.e. specification, design and implementation. To structure the discussion, we may focus on some formalisms and languages, in order to specify and to implement concurrent objects. The benefits of the different classes of these formalisms and languages should be discussed from a methodological point of view\u00a0\u2026", "num_citations": "3\n", "authors": ["104"]}
{"title": "CHASSIS-A Platform for Constructing Open Information Systems\n", "abstract": " Present-day computer-based information systems are increasingly required to be open systems. This means that they must cope with open networks, heterogeneous interoperable hardware and software systems, and, above all, evolving and changing requirements. The CHASSIS project aims to develop a software and methodology framework for (i) the security- and reliability-oriented systematic design and construction of heterogeneous information systems from individual existing and newly developed application software components and database systems, and (ii) their secure and reliable interoperation. In CHASSIS, object-orientation is the key technology for the construction of such a system as its uniform interface is realized by an object-oriented data model and the homogenization layer is realized by object-oriented software. CHASSIS includes object models for database and language integration, software to support system integration, specification methods to support the design process and advanced security mechanisms to provide the resulting information system with a high degree of security. CHASSIS is a joint Swiss project between the University of Z\u00fcrich, the University of Geneva, and the Asea Brown Boveri Research Centre (Baden).", "num_citations": "3\n", "authors": ["104"]}
{"title": "Panel: What is an object\n", "abstract": " Yonezawa: I would like to answer the question of\" what is an object\" by listing essential features of concurrent objects, as I think the notion of objects should be inherently concurrent. The features are: persistent identity, as an object models some entity; encapsulated local state, which means access protection except by message passing; and state changes triggered by message receipt, or method invocation; autonomous thread (s) of control, that", "num_citations": "3\n", "authors": ["104"]}
{"title": "Mapping Object Descriptions to Behaviours\n", "abstract": " There is a lack of good formalisms and tools for describing the semantics of object-oriented and concurrent programming languages. We propose a computational model for objects in which events are synchronous communications between concurrent agents, computations are partial orderings of events, and behaviours are the possible event unfoldings in which an agent, or a system of concurrent agents, may participate. Furthermore, we introduce a language called Abacus for defining executable behaviour expressions, and we speculate how this language may be used as part of a practical system for defining the formal semantics of programming languages.", "num_citations": "3\n", "authors": ["104"]}
{"title": "How to identify class comment types? A multi-language approach for class comment classification\n", "abstract": " Most software maintenance and evolution tasks require developers to understand the source code of their software systems. Software developers usually inspect class comments to gain knowledge about program behavior, regardless of the programming language they are using. Unfortunately, (i) different programming languages present language-specific code commenting notations and guidelines; and (ii) the source code of software projects often lacks comments that adequately describe the class behavior, which complicates program comprehension and evolution activities. To handle these challenges, this paper investigates the different language-specific class commenting practices of three programming languages: Python, Java, and Smalltalk. In particular, we systematically analyze the similarities and differences of the information types found in class comments of projects developed in these languages. We\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Hurdles for developers in cryptography\n", "abstract": " Prior research has shown that cryptography is hard to use for developers. We aim to understand what cryptography issues developers face in practice. We clustered 91954 cryptography-related questions on the Stack Overflow website, and manually analyzed a significant sample (i.e., 383) of the questions to comprehend the crypto challenges developers commonly face in this domain. We found that either developers have a distinct lack of knowledge in understanding the fundamental concepts, \\eg OpenSSL, public-key cryptography or password hashing, or the usability of crypto libraries undermined developer performance to correctly realize a crypto scenario. This is alarming and indicates the need for dedicated research to improve the design of crypto APIs.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Towards Detecting Inconsistent Comments in Java Source Code Automatically\n", "abstract": " A number of tools are available to software developers to check consistency of source code during software evolution. However, none of these tools checks for consistency of the documentation accompanying the code. As a result, code and documentation often diverge, hindering program comprehension. This leads to errors in how developers use source code, especially in the case of APIs of reusable libraries. We propose a technique and a tool, upDoc, to automatically detect code-comment inconsistency during code evolution. Our technique builds a map between the code and its documentation, ensuring that changes in the code match the changes in respective documentation parts. We conduct a preliminary evaluation using inconsistency examples from an existing dataset of Java open source projects, showing that upDoc can successfully detect them. We present a roadmap for the further development of the\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "What do class comments tell us? An investigation of comment evolution and practices in Pharo\n", "abstract": " Previous studies have characterized code comments in different programming languages. However, very few studies have focused on the analysis of the information embedded in code comments. None of them compared the developer's practices to write the comments to the standard guidelines and analyzed these characteristics in the Pharo Smalltalk environment. The class commenting practices have their origins in Smalltalk-80, going back 40 years. Smalltalk offers a brief template for entering a comment for newly-created classes. These templates have evolved over the years, particularly in the Pharo environment. This paper reports the first empirical study investigating commenting practices in Pharo Smalltalk. We quantitatively and qualitatively analyze class comments of the most recent version of Pharo, to investigate the information types of Pharo comments. Finally, we study the adherence of developer\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Testability first!\n", "abstract": " Background: The pivotal role of testing in high-quality software production has driven a significant effort in evaluating and assessing testing practices. Aims: We explore the state of testing in a large industrial project over an extended period. Method: We study the interplay between bugs in the project and its test cases, and interview developers and stakeholders to uncover reasons underpinning our observations. Results: We realized that testing is not well adopted, and that testability(i.e., ease of testing) is low. We found that developers tended to abandon writing tests when they assessed the effort to be high. Frequent changes in requirements and pressure to add new features also hindered developers from writing tests. Conclusions: Regardless of the debates on test first or later, we hypothesize that the underlying reasons for poor test quality are rooted in a lack of attention to testing early in the development of a\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Improving live debugging of concurrent threads through thread histories\n", "abstract": " Concurrency issues are inherently harder to identify and fix than issues in sequential programs, due to aspects like indeterminate order of access to shared resources and thread synchronisation. Live debuggers are often used by developers to gain insights into the behaviour of concurrent programs by exploring the call stacks of threads. Nevertheless, contemporary live debuggers for concurrent programs are usually sequential debuggers augmented with the ability to display different threads in isolation. To these debuggers every thread call stack begins with a designated start routine and the calls that led to the creation of the thread are not visible, as they are part of a different thread. This requires developers to manually link stack traces belonging to related but distinct threads, adding another burden to the already difficult act of debugging concurrent programs. To improve debugging of concurrent programs we\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Harvesting the wisdom of the crowd to infer method nullness in Java\n", "abstract": " Null pointer exceptions are common bugs in Java projects. Previous research has shown that dereferencing the results of method calls is the main source of these bugs, as developers do not anticipate that some methods return null. To make matters worse, we find that whether a method returns null or not (nullness), is rarely documented. We argue that method nullness is a vital piece of information that can help developers avoid this category of bugs. This is especially important for external APIs where developers may not even have access to the code. In this paper, we study the method nullness of Apache Lucene, the de facto standard library for text processing in Java. Particularly, we investigate how often the result of each Lucene method is checked against null in Lucene clients. We call this measure method nullability, which can serve as a proxy for method nullness. Analyzing Lucene internal and external\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Renraku: The one static analysis model to rule them all\n", "abstract": " Most static analyzers are monolithic applications that define their own ways to analyze source code and present the results. Therefore aggregating multiple static analyzers into a single tool or integrating a new analyzer into existing tools requires a significant amount of effort.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Moldable Tools for Object-Oriented Development\n", "abstract": " Object-oriented programming aims to facilitate navigation between domain concepts and the code that addresses those domains by enabling developers to directly model those domain concepts in the code. To make informed decisions, developers then formulate detailed and domain-specific questions about their systems in terms of domain concepts and use tools to explore available information and answer those questions. Development tools however focus mainly on object-oriented idioms and do not expose or exploit domain concepts constructed on top of object-oriented programming idioms. Analysis tools are typically not tightly integrated with development tools. This has a negative effect on program comprehension, increasing the effort and the time for obtaining answers.           To improve program comprehension, we propose to better integrate domain concepts and program comprehension tools into\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "When QualityAssistant meets pharo: Enforced code critiques motivate more valuable rules\n", "abstract": " Static analysis tools can aid in software quality assessment, but are rarely used by software developers. Poor usage of quality analysis tools not only means missed opportunities for the quality of software systems, but also results in little feedback, which in turn slows the improvements of the quality rules themselves.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Specifying dynamic analyses by extending language semantics\n", "abstract": " Dynamic analysis is increasingly attracting attention for debugging, profiling, and program comprehension. Ten to twenty years ago, many dynamic analyses investigated only simple method execution traces. Today, in contrast, many sophisticated dynamic analyses exist, for instance, for detecting memory leaks, analyzing ownership properties, measuring garbage collector performance, or supporting debugging tasks. These analyses depend on complex program instrumentations and analysis models, making it challenging to understand, compare, and reproduce the proposed approaches. While formal specifications and proofs are common in the field of static analysis, most dynamic analyses are specified using informal, textual descriptions. In this paper, we propose a formal framework using operational semantics that allows researchers to precisely specify their dynamic analysis. Our goal is to provide an\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Dynamic synchronization: a synchronization model through behavioral reflection\n", "abstract": " In conventional software applications, synchronization code is typically interspersed with functional code, thereby impacting understandability and maintainability of the code base. At the same time, the synchronization defined statically in the code is not capable of adapting to different runtime situations. We propose a new approach to synchronization which strictly separates the functional code from the synchronization requirements to be used and which adapts objects to be synchronized dynamically to their environment. First-class synchronization specifications express safety requirements, and a Dynamic Synchronization System dynamically adapts objects to different runtime situations. We present an overview of a prototype of our approach together with several classical concurrency problems, and we discuss open issues for further research.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Composing new abstractions from object fragments\n", "abstract": " As object-oriented languages are extended with novel modularization mechanisms, better underlying models are required to implement these high-level features. This paper describes Cell, a language model that builds on delegation-based chains of object fragments. Composition of groups of cells is used: 1) to represent objects, 2) to realize various forms of method lookup, and 3) to keep track of method references. A running prototype of Cell is provided and used to realize the basic kernel of a Smalltalk system. The paper shows, using several examples, how higher-level features such as traits can be supported by the lower-level model.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Software composition\n", "abstract": " Component-based software development is the next step after object-oriented programming that promises to overcome problems, such as re-usability and complexity, that have not yet been solved adequately with current programming techniques. Component-based software development addresses the complexity problem by producing software from smaller, typically black-box, components. These advantages have also been identified by the industry and hence a number of commercial component models have been developed. Although these component models are a first step towards the right direction, they only scratch the surface of software composition.There are many more challenges faced that cannot be solved by the development of a component model alone. Such challenges are the composition of components, their development, and verification. Software Composition is the premiere workshop to advance the research in these fields of component-based software development. SC 2005 is the fourth workshop in this series which has been organized as colocated event with the ETAPS conference. This year, proceedings will be printed by Springer Verlag in the form of post-proceedings. That is, they will appear after the workshop to allow presenters to include new insights that they have gained during the discussions of the workshop. The program consists of a keynote given by Prof. Oscar Nierstrasz and 13 technical paper presentations (9 full and 4 short papers). The technical papers were carefully selected from a total of 41 submitted papers. Each paper was thoroughly peer reviewed by at least three members of the program\u00a0\u2026", "num_citations": "2\n", "authors": ["104"]}
{"title": "Partial ordering tests by coverage sets\n", "abstract": " A single software fault may cause several tests to break, if they cover the same methods. The coverage sets of tests may not just overlap, but include one another. This information could be of great use to developers who would like to focus on the most specific test that concerns a given fault. Unfortunately, existing unit testing tools neither gather nor exploit this information.We have developed a simple approach that analyses a set of test suites, and infers the partial order corresponding to inclusion hierarchy of the coverage sets. When several tests in an inclusion chain break, we can guide the developer to the most specific test in the chain. Our first experiments with three case studies suggest that most unit tests for typical applications are, in fact, comparable to other tests, and can therefore be partially ordered. Furthermore, we show that this partial order is semantically meaningful, since faults that cause a test to break will, in nearly all cases cause less specific tests too break too.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Meta-level Language Bridging\n", "abstract": " Scripting and composition languages offer high-level mechanisms to combine and compose services provided by a lower-level host programming language. Inter-language bridging mechanisms are therefore needed to map host language entities and services to abstractions of the scripting language, and vice versa.Many popular languages such as Python, Perl, and Ruby use a bridging approach based on wrappers that must be written or generated in the host language. Other languages like Jython and Kawa adopt a fixed bridging strategy that exploits reflective features provided by the host language. Although both of these approaches are usable, they are cumbersome and low-level. In particular, it can be very difficult to adapt host language services to cooperate seamlessly with abstractions of the scripting language.", "num_citations": "2\n", "authors": ["104"]}
{"title": "Scripting: Higher-level programming for component-based systems\n", "abstract": " Components and Modules can be written in Python or in C/C++. A client of a module is not aware whether it is written in Python or in a system programming language. On systems with dynamic loading, recompilation of the Python interpreter is not necessary; a module itself has to be a shared library.# see python: 1Problem: check for keywords missing from master file", "num_citations": "2\n", "authors": ["104"]}
{"title": "Worrisome patterns in developers: A survey in cryptography\n", "abstract": " We surveyed 97 developers who had used cryptography in open-source projects, in the hope of identifying developer security and cryptography practices. We asked them about individual and company-level practices, and divided respondents into three groups (i.e., high, medium, and low) based on their level of knowledge. We found differences between the high-profile developers and the other two groups. For instance, high-profile developers have more years of experience in programming, have attended more security and cryptography courses, have more background in security, are highly concerned about security, and tend to use security tools more than the other two groups. Nevertheless, we observed worrisome patterns among all participants such as the high usage of unreliable sources like Stack Overflow, and the low rate of security tool usage.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Mining inline cache data to order inferred types in dynamic languages\n", "abstract": " The lack of static type information in dynamically-typed languages often poses obstacles for developers. Type inference algorithms can help, but inferring precise type information requires complex algorithms that are often slow. A simple approach that considers only the locally used interface of variables can identify potential classes for variables, but popular interfaces can generate a large number of false positives. We propose an approach called inline-cache type inference (ICTI) to augment the precision of fast and simple type inference algorithms. ICTI uses type information available in the inline caches during multiple software runs, to provide a ranked list of possible classes that most likely represent a variable's type. We evaluate ICTI through a proof-of-concept that we implement in Pharo Smalltalk. The analysis of the top-n+ 2 inferred types (where n is the number of recorded run-time types for a variable) for\u00a0\u2026", "num_citations": "1\n", "authors": ["104"]}
{"title": "A tour of Piccola\n", "abstract": " Piccola is a language for composing applications from Software components. It has a small syntax and a minimal set of features needed for specifying different styles of software composition. The core features of Piccola are communicating agents, which perform computations, and forms, which are the communicated values. Forms are a special notion of extensible, immutable records. Forms and agents allow us to unify components, static and dynamic contexts and arguments for invoking services. Through a series of examples, we present a tour of Piccola, illustrating how forms and agents suffice to express a variety of compositional abstractions and styles.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Logic, Language, and Computation: 7th International Tbilisi Symposium on Logic, Language, and Computation, TbiLLC 2007, Tbilisi, Georgia, October 1-5, 2007. Revised Selected Papers\n", "abstract": " Edited in collaboration with FoLLI, the Association of Logic, Language and Information, this book constitutes the refereed proceedings of the 7th International Tbilisi Symposium on Logic, Language, and Computation, TbiLLC 2007, held in Tbilisi, Georgia, in October 2007. The 22 revised full papers included in the book were carefully reviewed and selected from numerous presentations given at the symposium. The focus of the papers is on the following topics: conceptual modeling of spatial relations, pragmatics and game theory, atypical valency phenomena, lexical typology, formal semantics and experimental evidence, exceptional quantifier scope, Georgian focussing particles, polarity and pragmatics, dynamics of belief, learning theory, inquisitive semantics, modal logic, coalgebras, computational linguistics of Georgian, type-logical grammar and cross-serial dependencies, non-monotonic logic, Japanese quantifiers, intuitionistic logic, semantics of negated nominals, word sense disambiguation, semantics of question-embedding predicates, and reciprocals and computational complexity.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Human Machine Interaction: Research Results of the MMI Program\n", "abstract": " Human Machine Interaction : Research Results of the MMI Program | Titel Title external user (warning warning ) Log in as language uk Home Library My Library Search result Record nr. 1244159 Record number 1244159 Title Human Machine Interaction : Research Results of the MMI Program show extra info. edited by David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, Denis Lalanne, J\u00fcrg Kohlas Author(s) Hutchison, David ; Pandu Rangan, C ; Kittler, Josef ; Weikum, Gerhard ; Vardi, Moshe Y ; Tygar, Doug ; Terzopoulos, Demetri ; Sudan, Madhu ; Steffen, Bernhard ; Naor, Moni ; Mitchell, John C ; Mattern, Friedemann ; Lalanne, Denis ; Kleinberg, Jon M ; Kanade, Takeo ; Nierstrasz, Oscar ; Kohlas, J\u00fcrg Publisher , (\u2026", "num_citations": "1\n", "authors": ["104"]}
{"title": "Using dynamic analysis for api migration\n", "abstract": " When changing the API of a framework, we need to migrate its clients. This is best done automatically. In this paper, we focus on API migration where the mechanism for inversion of control changes. We propose to use dynamic analysis for such API migration since structural refactorings alone are often not sufficient. We consider JExample as a case-study. JExample extends JUnit with first-class dependencies and fixture injection. We investigate how dynamically collected information about test coverage and about instances under test can be used to detect dependency injection candidates.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Hermion-Exploiting the Dynamics of Software\n", "abstract": " The current Squeak Smalltalk IDE provides a structural perspective on a software system in terms of packages, classes and methods. However, from this perspective it is difficult to gain an understanding of how source entities participate at system\u2019s run-time. Hermion enriches the traditional IDE with a view on the dynamics of the system,(i) by offering a complementary feature-centric perspective of a software system to allow developers to reason about how specific run-time features of their software are implemented,(ii) by integrating dynamic information into the static perspective on a system, ie, source code, and (iii) by providing mechanisms to query run-time information.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Combining Development Environments with Reverse Engineering.\n", "abstract": " Understanding and maintaining large software systems is a complex and time-consuming yet inevitable challenge. Most systems frequently change and evolve over time to meet new requirements. To perform these changes a software engineer must have an in-depth understanding of the inner structure and implementation of a system. However, the integrated development environment (IDE) usually provides little in the way of support to ease the understanding and changing of software systems.A large body of research exists in the area of reverse engineering and many promising concepts to improve program comprehension have emerged, such as object or method histograms, polymetric views and class blueprints [3]. But the visualizations of reverseengineered information about software systems are usually separated from the user\u2019s working environment, the IDE, and integrated into dedicated reverse engineering tools such as Moose or CodeCrawler. This means that a programmer working on maintenance tasks does not have access to important information about the structure or the dynamic behavior of a software system, such as a view presenting how a class communicates to other classes. For instance, due to the lack of dynamic information (eg, collaborators of a class) the developer is forced to frequently browse a large code space without the benefit of goal-directed navigational support. Empirical studies report that an engineer performing maintenance tasks on a system spends at least 35% of the time in navigating dependencies between source artifacts (eg, which class uses which other classes)[2]. Because so much time is spent\u00a0\u2026", "num_citations": "1\n", "authors": ["104"]}
{"title": "Using context information to re-architecture a system\n", "abstract": " Successful software systems cope with complexity by organising classes into packages. However, a particular organisation may be neither straightforward nor obvious for a given developer. As a consequence, classes can be misplaced, leading to duplicated code and ripple effects with minor changes affecting multiple packages. We claim that contextual information is the key to re-architecture a system. Exploiting contextual information, we propose a technique to detect misplaced classes by analysing how client packages access the classes of a given provider package. We define locality as a measure of the degree to which classes reused by common clients appear in the same package. We then use locality to guide a simulated annealing algorithm to obtain optimal placements of classes in packages. The result is the identification of classes that are candidates for relocation.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Software Composition: 4th International Workshop, SC 2005, Edinburgh, UK, April 9, 2005, Revised Selected Papers\n", "abstract": " Component-based software development is the next step after object-oriented programmingthatpromisesto reducecomplexityandimprovereusability. These advantages have also been identi? ed by the industry, and consequently, over the past years, a large number of component-based techniques and processes have been adopted in many of these organizations. A visible result of this is the number ofcomponentmodels thathavebeendevelopedandstandardized. These models de? ne how individual software components interact with each other and simplify the design process of software systems by allowing developers to choose from previously existing components. The development of component models is a? rst step in the right direction, but there are many challenges that cannot be solved by the development of a new component model alone. Such challengesare the adaptation of components, and their development and veri? cation. Software Composition is the premiere workshop to advance the research in component-based software engineering and its related? elds. SC 2005 was the fourth workshop in this series. As in previous years, SC 2005 was organized as an event co-located with the ETAPS conference. This year\u2019s program consisted of a keynote on the revival of dynamic l-guages given by Prof. Oscar Nierstrasz and 13 technical paper presentations (9 full and 4 short papers). The technical papers were carefully selected from a total of 41 submitted papers. Each paper was thoroughly peer reviewed by at leastthreemembers oftheprogramcommittee andconsensusonacceptancewas achieved by means of an electronic PC\u00a0\u2026", "num_citations": "1\n", "authors": ["104"]}
{"title": "Partial ordering unit tests by coverage sets\n", "abstract": " A single software fault may cause several unit tests to break, if they cover the same methods. The coverage sets of unit tests may not just overlap, but include one another. This information could be of great use to developers who would like to focus on the most specific test that concerns a given fault. Unfortunately, existing unit testing tools neither gather nor exploit this information.We have developed a simple approach that analyses a set of test suites, and infers the partial order corresponding to inclusion hierarchy of the coverage sets. When several unit tests in an inclusion chain break, we can guide the developer to the most specific test in the chain.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Components, scripts and glue\n", "abstract": " 3. Methods: How to drive application development from frameworks? How to iteratively develop and evolve component frameworks?", "num_citations": "1\n", "authors": ["104"]}
{"title": "A Tour of Hybrid\n", "abstract": " Object-oriented programming is a powerful paradigm for organizing software into reusable components. There have been several attempts to adapt and extend this paradigm to the programming of concurrent and distributed applications. Hybrid is a language whose design attempts to retain multiple inheritance, genericity and strong-typing, and incorporate a notion of active objects. Objects in Hybrid are potentially active entities that communicate with one another through a messagepassing protocol loosely based on remote procedure calls. Non-blocking calls and delay queues are the two basic mechanisms for interleaving and scheduling activities. A prototype implementation of a compiler and run-time system for Hybrid have been completed. We shall review aspects of the language design and attempt to evaluate its shortcomings. We conclude with a list of requirements that we pose as a challenge for the design of future concurrent object-oriented languages.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Abacus: a Notation for Describing Concurrent Computations\n", "abstract": " Abacus is an experimental notation for specifying concurrent computations, to be used as a semantic target for defining and prototyping concurrent language constructs. We present the current implementation and its underlying computational model, and we illustrate its computational power and expressiveness through examples and by demonstrating equivalence with other models.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Coordination Patterns\n", "abstract": " Patterns were first systematically catalogued in the domain of architecture:\u201cEach pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice.\u201d", "num_citations": "1\n", "authors": ["104"]}
{"title": "The ADL Scripting Model and Component Set\n", "abstract": " The Activity Definition Language (ADL)[1][4] is a language for defining coordination procedures, or workflows. It is a textual as opposed to a graphical language. ADL activity and procedure definitions are \u201ccompiled\u201d into CooL code, and the latter is then compiled and linked in with the run-time system for coordination procedures, called the COP kernel.Vista [2][3][5] is a tool for visually scripting together pluggable software components to construct new applications. Vista maintains the graphical presentation of components and keeps track of permissible connections between them. The interfaces and the definition of \u201cplug compatibility\u201d for a component set are defined in a scripting model.", "num_citations": "1\n", "authors": ["104"]}
{"title": "Object-oriented support for generic application frames\n", "abstract": " One step in trying to define a reuse-based software development paradigm is reasoning about the development process itself and the required information to support it. We work towards this goal by proposing a tool for designing Generic Application Frames based on the careful structuring of past experience as well as domain information. We claim that the benefits of the object-oriented paradigm have yet to be properly scaled, and that they can be achieved by applying object-oriented design techniques to describe both software components and development methods.", "num_citations": "1\n", "authors": ["104"]}