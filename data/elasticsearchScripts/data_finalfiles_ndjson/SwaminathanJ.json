{"title": "Compact visualization of Java program execution\n", "abstract": " The context of this work is a practical, open\u2010source visualization system, called JIVE, that supports two forms of runtime visualizations of Java programs \u2013 object diagrams and sequence diagrams. They capture, respectively, the current execution state and execution history of a Java program. These diagrams are similar to those found in the UML for specifying design\u2013time decisions. In our work, we construct these diagrams at execution time, thereby ensuring continuity of notation from design to execution. In so doing, a few extensions to the UML notation are proposed in order to better represent runtime behavior. As sequence diagrams can become long and unwieldy, we present techniques for their compact representation. A key result in this paper is a novel labeling scheme based upon regular expressions to compactly represent long sequences and an O(r2) algorithm for computing these labels, where r is the\u00a0\u2026", "num_citations": "25\n", "authors": ["959"]}
{"title": "Towards Program Execution Summarization: Deriving State Diagrams from Sequence Diagrams\n", "abstract": " We propose a summarization technique that provides a clear and concise picture of the history of program execution with respect to entities of interest to a programmer. We develop our technique in the context of JIVE, a tool for Java execution visualization that renders execution states and history using UML object and sequence diagrams respectively. While these notations have been developed for specifying design-time decisions, the distinguishing aspect of our work is that we adapt their use for execution-time. Sequence diagrams tend to be long and unwieldy, and often exhibit a repetitive structure, hence we develop a novel procedure to summarize the sequence diagram in the form a state diagram with finite states. This summarization is user-driven, in that the user annotates the key variables of interest in the source code. This information together with an execution trace of the program for a particular input\u00a0\u2026", "num_citations": "13\n", "authors": ["959"]}
{"title": "Consistency of Java run-time behavior with design-time specifications\n", "abstract": " We present a novel framework for formal verification of run-time behaviour of Java programs. We focus on the class of programs with a repetitive behaviour, such as servers and interactive programs, including programs exhibiting concurrency and non-determinism. The design-time specifications for such programs can be specified as UML-like finite-state diagrams, or Kripke structures, in the terminology of model checking. In order to verify the run-time behavior of a Java program, we extract a state diagram from the execution trace of the Java program and check whether the run-time state diagram is consistent with the design-time diagram. We have implemented this framework as an extension of JIVE (Java Interactive Visualization Environment), a state-of-the-art dynamic analysis and visualization tool which constructs object, sequence, and state diagrams for Java program executions. JIVE is available as an open\u00a0\u2026", "num_citations": "12\n", "authors": ["959"]}
{"title": "Runtime Visualization and Verification in JIVE\n", "abstract": " Jive is a runtime visualization system that provides (1) a visual representation of the execution of a Java program, including UML-style object and sequence diagrams as well as domain specific diagrams, (2) temporal query-based analysis over program schedules, executions, and traces, (3) finite-state automata based upon key object attributes of interest to the user, and (4) verification of the correctness of program execution with respect to design-time specifications. In this paper we describe the overall Jive tool-chain and its features.", "num_citations": "7\n", "authors": ["959"]}
{"title": "Decoding Parallel Program Execution by using Java Interactive Visualization Environment (JIVE): Behavioral and Performance Analysis\n", "abstract": " With the proliferation of multi-core systems in the last decade or so even the personal computers have acquired the capability of supporting parallel programs. However, most applications are simply not designed to take advantage of this capability. This is firstly due to the difficulty in comprehending parallel programs. Secondly, the speed-up achieved due to parallelism is diminished by the overhead incurred. We study both these aspects in the context of fork/join, the parallel programming framework supported by Java and Java Interactive Visualization Environment (JIVE), a dynamic analysis framework for debugging and visualizing Java programs. In this paper, we demonstrate how JIVE can be used to decode parallel program execution and their behavior on single, dual and quad core systems. We also present the results of the performance study undertaken to compare the performance of parallel programs\u00a0\u2026", "num_citations": "5\n", "authors": ["959"]}
{"title": "Construction of activity diagrams from java execution traces\n", "abstract": " The aim of the work is to construct an activity diagram from the execution trace of Java programs to provide better program comprehension through visualisation. The execution trace is obtained during run-time when the Java program is debugged and the Java Interactive Visualisation Environment (JIVE) produces the details corresponding to the execution. The information from the trace is observed to develop an algorithm for the activity diagram construction. The reliance on PlantUML syntax has significantly guided in activity diagram notations used. Several basic programs containing the different constructs in Java are chosen for the analysis of the execution trace, and the events generated for these are studied to develop the algorithm. The execution trace is a collection of various fields which retrieves valuable information regarding the execution. The fields deliver relevant information regarding the\u00a0\u2026", "num_citations": "4\n", "authors": ["959"]}
{"title": "Comparison of sequence diagram from execution against design-time state specification\n", "abstract": " Simulating real world applications containing many functionalities using programs tend to become very complex in structure and behaviour. Validating such programs for its correctness require correct outputs and their ability to cope with erroneous scenarios. This work proposes a methodology for the verification of such programs defined using Java, based on their design-time and run-time model, where both the models are defined using the behavioural Unified Modeling Language state and sequence diagrams. The design-time behaviour is depicted by the state diagram and the run-time behaviour by sequence diagram, which is defined over the execution trace of the program. This work includes an automated and algorithmic approach to perform validation of application software.", "num_citations": "3\n", "authors": ["959"]}
{"title": "Towards reduction of software maintenance cost through assignment of critical functionality scores\n", "abstract": " Software maintenance incurs a significant cost during the life cycle of any software product. This is due to multiple factors such as addition of features demanded by new requirements, modification of existing features triggered by fixing of defects in the code and extending product support to newer platforms. These factors cause the testing phase to be repeated each time thereby increasing the maintenance cost. The quality of the code compounds to the maintenance cost since poorly written code are hard to comprehend and work with. This paper proposes a methodology to reduce the testing effort through successive releases by determining a set of most significant functionalities by computing scores based on the usage frequency, code maintainability and change vulnerability. The scores are recomputed as the software evolves over successive releases to keep the testing effort minimal.", "num_citations": "2\n", "authors": ["959"]}
{"title": "Building a common notation for enabling comparison of design and execution\n", "abstract": " Design and implementation are two major aspects of the software development and the deviation between them needs to be minimized to the best extent possible. Of the many difficulties in detecting the deviation is the absence of common notation to compare the implementation artefact (code) against the design artefact. In this paper we present an approach to bridge the gap by providing a methodology to construct call trees from both the artefacts and thus enabling comparison of both using a common notation. Design is usually captured as scenarios and hence we use sequence diagrams for its specification. An implementation is accurately understood when it is executed and hence we use execution events to capture it. Building on these two artefacts, we provide a systematic procedure to construct call trees that can be compared against each other for deviation. This paper is an outcome of our ongoing work\u00a0\u2026", "num_citations": "1\n", "authors": ["959"]}
{"title": "Run-time Model Extraction of a Java-based UAV Controller\n", "abstract": " This case study discusses the structural and behavioral properties of jUAV, a Java-based adaptation of Paparazzi-UAV, the opensource system that consists of ground station software and autopilot systems for both autonomous and manual flying of unmanned aerial vehicles. Although the system has been popular and used widely, there hasnt been a high-level analysis of its structure and behavior. We carry out such an analysis by extracting finite-state automata from execution of the Java-based flight controller of the UAV. Our experiments were carried out using the open-source Eclipse plugin JIVE, which automatically extracts an execution trace from the execution of Java program. Using this execution trace and JIVEs state diagram feature, we were able to construct finite state machine (FSM) that clarify important properties of the controllers cyclic behavior. We employ byte-code instrumentation (BCI) to efficiently obtain long execution traces (on the order of a million execution events), and we present the automata for key use cases, such as circling around a point, and show how its correctness properties can be stated. The paper also presents experimental results to clarify that the overhead caused BCI does not adversely affect the real-time behavior of the periodic tasks that the UAV needs to perform.", "num_citations": "1\n", "authors": ["959"]}