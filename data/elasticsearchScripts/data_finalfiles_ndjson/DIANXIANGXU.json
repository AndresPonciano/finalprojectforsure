{"title": "Cast: Collaborative agents for simulating teamwork\n", "abstract": " Psychological studies on teamwork have shown that an effective team often can anticipate information needs of teammates based on a shared mental model. Existing multi-agent models for teamwork are limited in their ability to support proactive information exchange among teammates. To address this issue, we have developed and implemented a multi-agent architecture called CAST that simulates teamwork and supports proactive information exchange in a dynamic environment. We present a formal model for proactive information exchange. Knowledge regarding the structure and process of a team is described in a language called MALLET. Beliefs about shared team processes and their states are represented using Petri Nets. Based on this model, CAST agents offer information proactively to those who might need it using an algorithm called DIARG. Empirical evaluations using a multi-agent synthetic testbed application indicate that CAST enhances the effectiveness of teamwork among agents without sacrificing a high cost for communications.", "num_citations": "234\n", "authors": ["358"]}
{"title": "Threat-driven modeling and verification of secure software using aspect-oriented Petri nets\n", "abstract": " Design-level vulnerabilities are a major source of security risks in software. To improve trustworthiness of software design, this paper presents a formal threat-driven approach, which explores explicit behaviors of security threats as the mediator between security goals and applications of security features. Security threats are potential attacks, i.e., misuses and anomalies that violate the security goals of systems' intended functions. Security threats suggest what, where, and how security features for threat mitigation should be applied. To specify the intended functions, security threats, and threat mitigations of a security design as a whole, we exploit aspect-oriented Petri nets as a unified formalism. Intended functions and security threats are modeled by Petri nets, whereas threat mitigations are modeled by Petri net-based aspects due to the incremental and crosscutting nature of security features. The unified formalism\u00a0\u2026", "num_citations": "193\n", "authors": ["358"]}
{"title": "Security of software defined networks: A survey\n", "abstract": " Software Defined Networking (SDN) has emerged as a new network architecture for dealing with network dynamics through software-enabled control. While SDN is promoting many new network applications, security has become an important concern. This paper provides an extensive survey on SDN security. We discuss the security threats to SDN according to their effects, i.e., Spoofing, Tampering, Repudiation, Information disclosure, Denial of Service, and Elevation of Privilege. We also review a wide range of SDN security controls, such as firewalls, IDS/IPS, access control, auditing, and policy management. We describe several pathways of how SDN is evolving.", "num_citations": "164\n", "authors": ["358"]}
{"title": "State-based incremental testing of aspect-oriented programs\n", "abstract": " Taking aspects as incremental modifications to their base classes, this paper presents an incremental approach to testing whether or not aspect-oriented programs and their base classes conform to their respective behavior models. We exploit a rigorous aspect-oriented extension to state models for capturing the impact of aspects on the state transitions of base class objects as well as an explicit weaving mechanism for composing aspects into their base models. We generate abstract tests for base classes and aspect-oriented programs from their state models. As base class tests are not necessarily valid for aspect-oriented programs, we identify several rules for maximizing reuse of concrete base class tests for aspects according to the state-based impact of aspects on their base classes. To illustrate our approach, we use two examples that indicate distinctive types of aspect-oriented applications and exhibit\u00a0\u2026", "num_citations": "114\n", "authors": ["358"]}
{"title": "Automated security test generation with formal threat models\n", "abstract": " Security attacks typically result from unintended behaviors or invalid inputs. Security testing is labor intensive because a real-world program usually has too many invalid inputs. It is highly desirable to automate or partially automate security-testing process. This paper presents an approach to automated generation of security tests by using formal threat models represented as Predicate/Transition nets. It generates all attack paths, i.e., security tests, from a threat model and converts them into executable test code according to the given Model-Implementation Mapping (MIM) specification. We have applied this approach to two real-world systems, Magento (a web-based shopping system being used by many online stores) and FileZilla Server (a popular FTP server implementation in C++). Threat models are built systematically by examining all potential STRIDE (spoofing identity, tampering with data, repudiation\u00a0\u2026", "num_citations": "112\n", "authors": ["358"]}
{"title": "A formal architectural model for logical agent mobility\n", "abstract": " The process of agent migration is the major difference between logical code mobility of software agents and physical mobility of mobile nodes in ad hoc networks. Without considering agent transfer, it would make little sense to mention the modeling of strong code mobility, which aims to make a migrated agent restarted exactly from the state when it was stopped before migration. From the perspective of system's architecture, this paper proposes a two-layer approach for the formal modeling of logical agent mobility (LAM) using predicate/transition (PrT) nets. We view a mobile agent system as a set of agent spaces and agents could migrate from one space to another. Each agent space is explicitly abstracted to be a component, consisting of an environmental part and an internal connector dynamically binding agents with their environment. We use a system net, agent nets, and a connector net to model the\u00a0\u2026", "num_citations": "105\n", "authors": ["358"]}
{"title": "Towards better fault localization: A crosstab-based statistical approach\n", "abstract": " It is becoming prohibitively expensive and time consuming, as well as tedious and error-prone, to perform debugging manually. Among the debugging activities, fault localization has been one of the most expensive, and therefore, a large number of fault-localization techniques have been proposed over the recent years. This paper presents a crosstab-based statistical technique that makes use of the coverage information of each executable statement and the execution result (success or failure) with respect to each test case to localize faults in an effective and efficient manner. A crosstab is constructed for each executable statement, and a statistic is computed to determine the suspiciousness of the corresponding statement. Statements with a higher suspiciousness are more likely to contain bugs and should be examined before those with a lower suspiciousness. Case studies are performed on both small- (the\u00a0\u2026", "num_citations": "101\n", "authors": ["358"]}
{"title": "A State-Based Approach to Testing Aspect-Oriented Programs.\n", "abstract": " This paper presents a state-based approach to testing aspect-oriented programs. Aspectual state models, as an extension to the testable FREE state model of classes, are exploited to capture the impact of aspects on the state models of classes. To generate test suites for adequately testing object behavior and interaction between classes and aspects in terms of message sequences, we transform an aspectual state model to a transition tree, where each path from the root to some leaf node indicates a template of test cases, ie message sequences. Since the statebased approach is directly built upon the test design patterns for object-oriented programs, it is not only applicable to the simultaneous development of classes and aspects, but also to the incremental development of aspects based on the existing classes.", "num_citations": "81\n", "authors": ["358"]}
{"title": "Compositional schedulability analysis of real-time systems using time Petri nets\n", "abstract": " This paper presents an approach to the schedulability analysis of real-time systems modeled in time Petri nets by separating timing properties from other behavioral properties. The analysis of behavioral properties is conducted based on the reachability graph of the underlying Petri net, whereas timing constraints are checked in terms of absolute and relative firing domains. If a specific task execution is schedulable, we calculate the time span of the task execution, and pinpoint nonschedulable transitions to help adjust timing constraints. A technique for compositional timing analysis is also proposed to deal with complex task sequences, which not only improves efficiency but also facilitates the discussion of the reachability issue with regard to schedulability. We identified a class of well-structured time Petri nets such that their reachability can be easily analyzed.", "num_citations": "79\n", "authors": ["358"]}
{"title": "A threat model driven approach for security testing\n", "abstract": " In this paper, we propose a novel threat model-driven security testing approach for detecting undesirable threat behavior at runtime. Threats to security policies are modelled with UML (unified modeling language) sequence diagrams. From a design-level threat model we extract a set of threat traces, each of which is an event sequence that should not occur during the system execution. The same threat model is also used to decide what kind of information should be collected at runtime and to guide the code instrumentation. The instrumented code is recompiled and executed using test cases randomly generated. The execution traces are collected and analyzed to verify whether the aforementioned undesirable threat traces are matched. If an execution trace is an instance of a threat trace, security violations are reported and actions should be taken to mitigate the threat in the system. Thus the linkage between\u00a0\u2026", "num_citations": "74\n", "authors": ["358"]}
{"title": "Modeling mobile agent systems with high level Petri nets\n", "abstract": " The paper presents a Petri net based approach for architectural modeling of mobile agent systems. An agent template (net) is proposed to model a changing number of autonomous and communicative software agents. An agent space is explicitly abstracted as a component, consisting of mobility environment (system net), agent templates (agent nets), and internal connector (net). Agent transfer is naturally captured by transition firing. To assure the strong mobility, the agent's state is delivered during migration. Agent mobility in OMG's MASIF is also examined by formalizing the interoperable agent system architecture.", "num_citations": "72\n", "authors": ["358"]}
{"title": "A threat model\u2010based approach to security testing\n", "abstract": " Software security issues have been a major concern in the cyberspace community, so a great deal of research on security testing has been performed, and various security testing techniques have been developed. Threat modeling provides a systematic way to identify threats that might compromise security, and it has been a well\u2010accepted practice by the industry, but test case generation from threat models has not been addressed yet. Thus, in this paper, we propose a threat model\u2010based security testing approach that automatically generates security test sequences from threat trees and transforms them into executable tests. The security testing approach we consider consists of three activities in large: building threat models with threat trees; generating security test sequences from threat trees; and creating executable test cases by considering valid and invalid inputs. To support our approach, we implemented\u00a0\u2026", "num_citations": "71\n", "authors": ["358"]}
{"title": "A tool for automated test code generation from high-level Petri nets\n", "abstract": " Automated software testing has gained much attention because it is expected to improve testing productivity and reduce testing cost. Automated generation and execution of tests, however, are still very limited. This paper presents a tool, ISTA (Integration and System Test Automation), for automated test generation and execution by using high-level Petri nets as finite state test models. ISTA has several unique features. It allows executable test code to be generated automatically from a MID (Model-Implementation Description) specification - including a high-level Petri net as the test model and a mapping from the Petri net elements to implementation constructs. The test code can be executed immediately against the system under test. It supports a variety of languages of test code, including Java, C/C++, C#, VB, and html/Selenium IDE (for web applications). It also supports automated test generation for\u00a0\u2026", "num_citations": "69\n", "authors": ["358"]}
{"title": "Modeling and verifying multi-agent behaviors using predicate/transition nets\n", "abstract": " In a multi-agent system, how agents accomplish a goal task is usually specified by multi-agent plans built from basic actions (eg operators) of which the agents are capable. A critical problem with such an approach is how can the designer make sure the plans are reliable. To tackle this problem, this paper presents a formal approach for modeling and analyzing multi-agent behaviors using Predicate/Transition (PrT) nets, a high-level formalism of Petri nets. We construct a multi-agent model by representing agent capabilities as transitions. To verify a multi-agent PrT model, we adapt the planning graphs as a compact structure for the reachability analysis. We also demonstrate that, based on the PrT model, whether parallel actions specified in multi-agent plans can be executed in parallel and whether the plans guarantee the achievement of the goal can be verified by analyzing the dependency relations among the\u00a0\u2026", "num_citations": "66\n", "authors": ["358"]}
{"title": "Misuse case-based design and analysis of secure software architecture\n", "abstract": " This paper presents an approach to the architectural design and analysis of secure software systems based on the system requirements elicited in the form of use cases and misuse cases. We identify architectural components and their connections and analyze whether or not a candidate architecture can address security concerns. This provides a smooth transition from requirements specification to high-level design for engineering secure software systems, and greatly improves the traceability of security concerns, which allows a system developer to know what requirement an architectural component references back to. We demonstrate our approach through a case study on a security-intensive hospital information system.", "num_citations": "64\n", "authors": ["358"]}
{"title": "Security test generation using threat trees\n", "abstract": " Software security issues have been a major concern to the cyberspace community, so a great deal of research on security testing has been performed, and various security testing techniques have been developed. Most of these techniques, however, have focused on testing software systems after their implementation is completed. To build secure and dependable software systems in a cost-effective way, however, it is necessary to put more effort upfront during the software development life cycle. In this paper, we provided a security testing approach that derives test cases from design-level artifacts. The security testing approach we consider consists of four activities: building threat trees from threat modeling; generating security tests from threat trees; generating test inputs including valid and invalid inputs; and assigning input values to parameters. We also conducted an empirical study to show feasibility of our\u00a0\u2026", "num_citations": "50\n", "authors": ["358"]}
{"title": "Integrating safety analysis with functional modeling\n", "abstract": " Functional modeling and safety analysis are two important aspects of safety-critical embedded systems. However, they are often conducted separately. In this paper, we present an approach for integrating fault-tree-based safety analysis into statechart-based functional modeling. The proposed approach uses systematic transformation steps that maintain the semantics of both the fault tree and the statechart. It also provides a set of conversion rules that transform the gates of fault trees into statechart notations. The resultant model shows how the system behaves when a failure condition occurs and acts as a basis model that ensures safety through requirement validation. Using the gas burner case study, we demonstrate the advantages of the integrated model over the use of separate models, such as the lack of ambiguities, separation of concerns, and taking the order of the occurrence of faults into consideration.", "num_citations": "47\n", "authors": ["358"]}
{"title": "A systematic capture and replay strategy for testing complex gui based java applications\n", "abstract": " In this paper we propose a testing strategy that targets Java applications with complex GUI structure and event interactions. We present a capture and replay testing technique which can be employed for different testing purposes: GUI convergence, functional testing and regression testing. The proposed strategy drastically improves, and from different aspects, on standard capture and replay tools. This is done by combining both a model based testing approach with the capture and replay approach and by implementing different automated test oracles. We first model the behavior of the system from the functional specifications or from a trusted version of the system. Tests are then derived from this model to exercise the system in order to ensure correct functional behavior and to cover goal oriented interactions. The case study applies the test strategy on a role-based, multi-user computer game to demonstrate the\u00a0\u2026", "num_citations": "46\n", "authors": ["358"]}
{"title": "An automated test generation technique for software quality assurance\n", "abstract": " The world's increased dependence on software-enabled systems has raised major concerns about software reliability and security. New cost-effective tools for software quality assurance are needed. This paper presents an automated test generation technique, called Model-based Integration and System Test Automation (MISTA), for integrated functional and security testing of software systems. Given a Model-Implementation Description (MID) specification, MISTA generates test code that can be executed immediately with the implementation under test. The MID specification uses a high-level Petri net to capture both control- and data-related requirements for functional testing, access control testing, or penetration testing with threat models. After generating test cases from the test model according to a given criterion, MISTA converts the test cases into executable test code by mapping model-level elements into\u00a0\u2026", "num_citations": "45\n", "authors": ["358"]}
{"title": "Model-based test code generation for software testing\n", "abstract": " A method of creating test code automatically from a test model is provided. In the method, an indicator of an interaction by a user with a user interface window presented in a display of a computing device is received. The indicator indicates that a test model definition is created. A mapping window includes a first column and a second column. An event identifier is received in the first column and text mapped to the event identifier is received in the second column. The event identifier defines a transition included in the test model definition and the text defines code implementing a function of a system under test associated with the transition in the mapping window. A code window is presented in the display. Helper code text is received. The helper code text defines second code to generate executable code from the code implementing the function of the system under test. Executable test code is generated using the\u00a0\u2026", "num_citations": "41\n", "authors": ["358"]}
{"title": "Handbook of Finite State Based Models and Applications\n", "abstract": " Applicable to any problem that requires a finite number of solutions, finite state-based models (also called finite state machines or finite state automata) have found wide use in various areas of computer science and engineering. Handbook of Finite State Based Models and Applications provides a complete collection of introductory materials on finite state theories, algorithms, and the latest domain applications. For beginners, the book is a handy reference for quickly looking up model details. For more experienced researchers, it is suitable as a source of in-depth study in this area. The book first introduces the fundamentals of automata theory, including regular expressions, as well as widely used automata, such as transducers, tree automata, quantum automata, and timed automata. It then presents algorithms for the minimization and incremental construction of finite automata and describes Esterel, an automata-based synchronous programming language for embedded system software development. Moving on to applications, the book explores regular path queries on graph-structured data, timed automata in model checking security protocols, pattern matching, compiler design, and XML processing. It also covers other finite state-based modeling approaches and applications, including Petri nets, statecharts, temporal logic, and UML state machine diagrams.", "num_citations": "41\n", "authors": ["358"]}
{"title": "Threat-driven architectural design of secure information systems\n", "abstract": " To deal with software security issues in the early stages of system development, this paper presents a threatdriven approach to the architectural design and analysis of secure information systems. In this approach, we model security threats to systems with misuse cases and mitigation requirements with mitigation use cases at the requirements analysis phase. Then we drive system architecture design (including the identification of architectural components and their connections) by use cases, misuse cases, and mitigation use cases. According to the misuse case-based threat model, we analyze whether or not a candidate architecture is resistant to the identified security threats and what constraints must be imposed on the choices of system implementation. This provides a smooth transition from requirements specification to high-level design and greatly improves the traceability of security concerns in high assurance information systems. We demonstrate our approach through a case study on a security-intensive payroll information system.", "num_citations": "38\n", "authors": ["358"]}
{"title": "A model-based approach to test generation for aspect-oriented programs\n", "abstract": " This paper presents an approach to generating tests for adequately exercising interaction between aspects and classes based on aspect-oriented UML models. In this approach, an aspect-oriented model consists of class diagrams, aspect diagrams, and sequence diagrams. Since methods of classes and advices of aspects are both specified by sequence diagrams, the advices on a given method can be weaved into a new sequence diagram, which is essential to the weaving mechanism in AOSD. For a woven sequence diagram, the approach exploits goal-directed reasoning to construct a flow graph for a given coverage criteria (eg the combination of branch coverage and polymorphic coverage in this paper), and further expands the graph to a flow tree, where each path is a test. Then the approach derives objects with desired states for exercising each test in the flow tree.", "num_citations": "37\n", "authors": ["358"]}
{"title": "A threat-driven approach to modeling and verifying secure software\n", "abstract": " This paper presents a formal approach to threat-driven modeling and verification of secure software using aspect-oriented Petri nets. Based on the behavior model of intended functions, we identify and build formal models of security threats, which are potential misuses and anomalies of the intended functions that violate security goals. Threat mitigations are further modeled in an aspect-oriented paradigm. Taking Petri nets as a formal basis for modeling behaviors, threats, and mitigations as a whole, we verify properties of and consistency between behaviors and threats, and absence of identified threats from the integrated model of functions and threat mitigations. This makes it possible to achieve a design that is provably resistant to the anticipated threats and thus reduce significant design-level vulnerabilities.", "num_citations": "35\n", "authors": ["358"]}
{"title": "Illumination invariant face recognition based on neural network ensemble\n", "abstract": " An illumination invariant face recognition method based on neural network ensemble architecture is proposed. Given a face image with an arbitrary illumination direction, it can complete recognition in a uniform way with high performance without knowing or estimating the illumination direction. Experimental result shows that the recognition ratio of the ensemble architecture is higher than the conventional approach that uses a single neural network to recognize faces of a specific illumination direction.", "num_citations": "30\n", "authors": ["358"]}
{"title": "Modeling and integrating aspects with UML activity diagrams\n", "abstract": " Dealing with crosscutting concerns has been a critical problem in software development processes. Aspect-Oriented Programming (AOP) provides a viable programming-level solution by separating crosscutting concerns from primary concerns. To facilitate handling crosscutting concerns at earlier software development phases, this paper proposes an aspect-oriented modeling and integration approach at the design level. In our approach, primary concerns are depicted with UML activity diagrams as primary models, whereas crosscutting concerns are described with aspectual extended activity diagrams as aspect models. Each aspect model consists of pairs of pointcut and advice model. Aspect models can be integrated into primary models automatically. To this end, a prototype tool called Jasmine-AOI has been implemented as an Eclipse plug-in. With the tool support, we have conducted two case studies\u00a0\u2026", "num_citations": "29\n", "authors": ["358"]}
{"title": "Testing aspect-oriented programs with UML design models\n", "abstract": " The new constructs in aspect-oriented programming bring new types of programming faults with respect to crosscutting concerns, such as incorrect pointcuts and advice. This paper presents a UML-based approach to testing whether or not an aspect-oriented program conforms to its expected crosscutting behavior. We explore aspect-oriented UML design models to derive tests for exercising interactions between aspects and classes. Each aspect-oriented model consists of class diagrams, aspect diagrams, and sequence diagrams. For a method under test, we weave the sequence diagrams of the advice on the method into the method's sequence diagram. Based on the woven sequence diagram and class/aspect diagrams, we then generate an AOF (Aspect-Object Flow) tree by applying coverage criteria such as condition coverage, polymorphic coverage, and loop coverage to woven sequence diagrams. In the\u00a0\u2026", "num_citations": "28\n", "authors": ["358"]}
{"title": "Model checking aspect-oriented design specification\n", "abstract": " Aspects can be used in a harmful way that invalidates desired properties. Rigorous specification and analysis of aspect design is thus highly desirable. This paper presents an approach to model-checking state-based specification of aspect-oriented design. It is based on a rigorous formalism for capturing crosscutting concerns with respect to the design-level state models of classes. An aspect model not only encapsulates pointcuts and advice, but also supports inter-model declarations, aspect precedence, and references to the behaviors of other classes in advice models. For verification purposes, we convert the aspect-oriented state model of a system into woven models and further transform the woven models and the non-base class models into FSP processes. The generated FSP processes are checked by the LTSA model checker against the desired system properties. We have applied our approach to the\u00a0\u2026", "num_citations": "28\n", "authors": ["358"]}
{"title": "Aspect flow graph for testing aspect-oriented programs\n", "abstract": " Our research deals with combining state models (class and aspect) and flow graphs (method and advice) as an aspect scope coverage model for producing test suites. Essentially, the result is a hybrid testing model which is a combination of a responsibility-based testing model and an implementation-based testing model. We are interested in deriving test suites that cross classes and aspects. The approach consists of merging the class state model and the aspect state model into an aspect scope state model (ASSM). The ASSM allows us to trace the behaviour of aspect-oriented programs (AOP) by identifying sequence results of the states transitions of the AOP. Next, guided by ASSM, the transitions between the class and the aspect, and corresponding actions, are substituted by the advice and method flow graphs to construct an aspect flow graph (AFG). In addition to the AFG, a transition tree for the generic collection of behaviour model is generated in terms of ASSM and an invariant boundary set of the parameters alone with the parameter relationships that determine behaviours. Given the AFG and the transition tree, we can refine more concert, executable code-based test suites.", "num_citations": "28\n", "authors": ["358"]}
{"title": "Modeling and analyzing multi-agent behaviors using predicate/transition nets\n", "abstract": " How agents accomplish a goal task in a multi-agent system is usually specified by multi-agent plans built from basic actions (e.g. operators) of which the agents are capable. The plan specification provides the agents with a shared mental model for how they are supposed to collaborate with each other to achieve the common goal. Making sure that the plans are reliable and fit for the purpose for which they are designed is a critical problem with this approach. To address this problem, this paper presents a formal approach to modeling and analyzing multi-agent behaviors using Predicate/Transition (PrT) nets, a high- level formalism of Petri nets. We model a multi-agent problem by representing agent capabilities as transitions in PrT nets. To analyze a multi-agent PrT model, we adapt the planning graphs as a compact structure for reachability analysis, which is coherent to the concurrent semantics. We also\u00a0\u2026", "num_citations": "28\n", "authors": ["358"]}
{"title": "Threat-driven design and analysis of secure software architectures\n", "abstract": " Computer software is a major source of security risks in information systems. To deal with software security issues in the early stages of software development, this paper presents a threatdriven approach to the architectural design and analysis of secure software. Based on the identification and mitigation of security threats as misuse use cases, we leverage use cases, misuse cases, and mitigation use cases to design architectural components and their connections for candidate architectures. We then analyze whether or not candidate architectures are resistant to the identified security threats and what constraints must be imposed on the choices of system implementation. This provides a smooth transition from requirements specification to high-level design and greatly improves the traceability of security concerns in high assurance software systems. We demonstrate our approach through two case studies; one on a hospital information system and one on a payroll information system.", "num_citations": "27\n", "authors": ["358"]}
{"title": "Prioritizing state-based aspect tests\n", "abstract": " In aspect-oriented programming, aspects are essentially incremental modifications to their base classes. Therefore aspect-oriented programs can be tested in an incremental fashion - we can first test the base classes and then test the base classes and aspects as a whole. This paper demonstrates that, in this incremental testing paradigm, we can prioritize aspect tests so as to report failure earlier. We explore test prioritization for testing aspect-oriented programs against their state models with transition coverage and round-trip coverage. Aspect tests are generated from woven state models obtained by composing aspect models into their base class models. We prioritize aspect tests by identifying the extent to which an aspect modifies its base classes. The modification is measured by the number of new and changed components in state transitions (start state, event, precondition, postcondition, end state). Transitions\u00a0\u2026", "num_citations": "25\n", "authors": ["358"]}
{"title": "Integrating functional and security requirements with use case decomposition\n", "abstract": " Misuse case modeling is a viable option to depict the security requirements together with functional requirements. To investigate the interplay between functional and security requirements, this paper presents an approach to decomposing use cases, misuse cases, and mitigation use cases. We identify relationships among decomposed cases for each case type (use, misuse, mitigation use) and ensure consistency among the cases as decomposition occurs by properly modeling shared and optional cases. We also assign applicable actors to the decomposed cases. Decomposition is conducted for each case type independently and then integrated with the \"threatens\" and \"mitigates\" relationships. We provide processes for the proper use of the \"threatens\" relationship between misuse cases and use cases and the \"mitigates\" relationship between mitigation use cases and misuse cases at different levels of\u00a0\u2026", "num_citations": "24\n", "authors": ["358"]}
{"title": "State-based testing of integration aspects\n", "abstract": " Aspect-oriented programming supports a variety of composition strategies, from the clearly acceptable to the questionable. One of the strategies is to make an aspect integrate separate concerns. Such integration aspects, like other aspects, may introduce various programming faults, including incorrect join points, pointcuts, and advice. This paper presents a preliminary study on the state-based testing of integration aspects. We exploit aspect-oriented state models for specifying integration aspects, compose state models of aspects and classes, and generate test cases for integration aspects from their state models. We exercise integration aspects through the interface of their base classes. We also discuss the issues of testing deeply crosscut integration aspects through the clients of their base classes.", "num_citations": "23\n", "authors": ["358"]}
{"title": "An aspect-oriented approach to security requirements analysis\n", "abstract": " This paper presents an aspect-oriented approach to integrated elicitation of functional and security requirements based on use case-driven development. We identify security threats with respect to use cases and adopt threat mitigations for preventing or reducing security threats. To capture crosscutting nature of threats and mitigations, we specify them as aspects that encapsulate pointcuts and advice. A threat (mitigation) pointcut is a collection of join points in use cases at which the use cases are threatened (secured); whereas threat/mitigation advice describes how a threat can become an attack (can be mitigated). Eliciting threats and mitigations as aspects provides a structured way for separating functional and security concerns", "num_citations": "22\n", "authors": ["358"]}
{"title": "On the development of a digital forensics curriculum\n", "abstract": " Computer Crime and computer related incidents continue their prevalence and frequency, resulting in losses approaching billions of dollars. To fight against these crimes and frauds, it is urgent to develop digital forensics education programs to train a suitable workforce that can effectively investigate computer crimes and incidents. There is presently no standard to guide the design of digital forensics curriculum for an academic program. In this research, previous work on digital forensics curriculum design and existing education programs are thoroughly investigated. Both digital forensics educators and practitioners were surveyed and results were analyzed to determine the industry and law enforcement need for skills and knowledge for their digital forensic examiners. Based on the survey results and the topics that make up certificate programs in digital forensics, topics that are desired in digital forensics courses\u00a0\u2026", "num_citations": "21\n", "authors": ["358"]}
{"title": "Generation of test requirements from aspectual use cases\n", "abstract": " To effectively uncover aspect defects, system (or subsystem) testing is of importance because aspects crosscut multiple system components. This paper presents an approach for generating system test requirements from aspect-oriented use cases. Central to this approach is the formalization of a testable system model from aspect-oriented use cases. We explicitly capture various constraints among base and aspectual use cases. Specifically, we transform aspect-oriented use case diagrams and descriptions into aspect-oriented Petri nets. This makes it possible to generate meaningful use case sequences with respect to various coverage criteria (such as use case coverage, transition coverage and state coverage). When scenario tests for individual use cases are available, they can be composed into system tests according to the generated use case sequences.", "num_citations": "21\n", "authors": ["358"]}
{"title": "UML-based modeling and analysis of security threats\n", "abstract": " Poor design has been a major source of software security problems. Rigorous and designer-friendly methodologies for modeling and analyzing secure software are highly desirable. A formal method for software development, however, often suffers from a gap between the rigidity of the method and the informal nature of system requirements. To narrow this gap, this paper presents a UML-based framework for modeling and analyzing security threats (i.e. potential security attacks) rigorously and visually. We model the intended functions of a software application with UML statechart diagrams and the security threats with sequence diagrams, respectively. Statechart diagrams are automatically converted into a graph transformation system, which has a well-established theoretical foundation. Method invocations in a sequence diagram of a security threat are interpreted as a sequence of paired graph transformations\u00a0\u2026", "num_citations": "20\n", "authors": ["358"]}
{"title": "Privacy and social capital in online social networks\n", "abstract": " In online social networks (OSNs), individual users have a strong desire to expand their social networks through OSN activities and try to maximize the benefits from the social relationships, called social capital. However, with a large-scale social network, their privacy rights have been significantly intruded by adversarial users that perform social attacks including false / illegal private information dissemination or the use of fake identities. In this work, we study how individual users can expand their social networks by making trustworthy friends while not leaking their private information out to unauthorized parties or social attackers. We adopt the concepts of trust and reputation in order to preserve users' privacy while enhancing their social capital in OSNs. Given a social network topology from the Facebook, we model an individual user's interactions with other users based on feeding (e.g., posting information) and\u00a0\u2026", "num_citations": "19\n", "authors": ["358"]}
{"title": "Data placement in P2P data grids considering the availability, security, access performance and load balancing\n", "abstract": " Data dependability is an important issue in data Grids. Replication schemes have been widely used in distributed systems to ensure availability and improve access performance. Alternatively, data partitioning schemes (secret sharing, erasure coding with encryption) can be used to provide availability and, in addition, to offer confidentiality protection. In peer-to-peer data Grids, such confidentiality protection is essential since the nodes hosting the data shares may not be trustworthy or may be compromised. However, difficulties in generating new shares and potential security concerns for share reallocation make a pure data partitioning scheme not easily adaptable to dynamic user access patterns. In this paper, we consider combining replication and data partitioning to assure data availability, confidentiality, load balance, and efficient access for data Grid applications. Data are partitioned and shares are\u00a0\u2026", "num_citations": "19\n", "authors": ["358"]}
{"title": "Specification and analysis of attribute-based access control policies: An overview\n", "abstract": " Attribute-based access control (ABAC) is a new generation of access control techniques. It enables fine-grained access control by using various attributes of authorization elements, facilitates collaborative policy administration within a large enterprise or across multiple organizations, and allows for decoupling of access control policies from application logic. Nevertheless, ABAC-based systems can be very complex to manage. High expressiveness of ABAC specifications also increases the possibility of having defects. Therefore testing and verification are important for assuring that ABAC policies are specified and enforced correctly. This paper presents an overview of the existing work on specification, dynamic testing, and static verification of ABAC policies. It not only summarizes the up-to-date research progresses, but also provides an understanding about the limitations and open issues of the existing work. It is\u00a0\u2026", "num_citations": "18\n", "authors": ["358"]}
{"title": "Testing aspect\u2010oriented programs with finite state machines\n", "abstract": " Aspect\u2010oriented programming yields new types of programming faults due to the introduction of new constructs for dealing with crosscutting concerns. To reveal aspect faults, this paper presents a framework for testing whether or not aspect\u2010oriented programs conform to their state models. It supports two families of strategies (i.e. structure\u2010oriented and property\u2010oriented) for automated generation of aspect tests from aspect\u2010oriented state models. A structure\u2010oriented testing strategy derives tests and test code from an aspect\u2010oriented state model to meet a given structural coverage criterion, such as state coverage, transition coverage, or round trip. A property\u2010oriented testing strategy generates test code from the counterexamples of model checking. Two such strategies are checking an aspect\u2010oriented state model against trap properties and checking mutants of aspect models against system properties. Mutation\u00a0\u2026", "num_citations": "18\n", "authors": ["358"]}
{"title": "Aspect-oriented modeling and verification with finite state machines\n", "abstract": " Aspect-oriented programming modularizes crosscutting concerns into aspects with the advice invoked at the specified points of program execution. Aspects can be used in a harmful way that invalidates desired properties and even destroys the conceptual integrity of programs. To assure the quality of an aspect-oriented system, rigorous analysis and design of aspects are highly desirable. In this paper, we present an approach to aspect-oriented modeling and verification with finite state machines. Our approach provides explicit notations (e.g., pointcut, advice and aspect) for capturing crosscutting concerns and incremental modification requirements with respect to class state models. For verification purposes, we compose the aspect models and class models in an aspect-oriented model through a weaving mechanism. Then we transform the woven models and the class models not affected by the aspects\u00a0\u2026", "num_citations": "17\n", "authors": ["358"]}
{"title": "Aspect-oriented specification of threat-driven security requirements\n", "abstract": " This paper presents an aspect-oriented approach to integrated specification of functional and security requirements based on use-case-driven software development. It relies on explicit identification of security threats and threat mitigations. We first identify security threats with respect to use-case based functional requirements in terms of security goals and the STRIDE category. Then, we suggest threat mitigations for preventing or reducing security threats. To capture the crosscutting nature of threats and mitigations, we specify them as aspects that encapsulate pointcuts and advice. This provides a structured way for separating functional and security concerns and for analysing the interaction between them.", "num_citations": "17\n", "authors": ["358"]}
{"title": "Automated test code generation from class state models\n", "abstract": " This paper presents an approach to automated generation of executable test code from class models represented by the UML protocol state machines. It supports several coverage criteria for state models, including state coverage, transition coverage, and basic and extended round-trip coverage. It allows the tester to add and modify detailed test parameters (e.g., actual arguments for method invocations and implementation-specific environments) if necessary. When the state model is modified due to requirements change, the hand-crafted test parameters, if still valid, are automatically reused. This reduces the working load for regeneration of tests for modified models. In addition to test code, we also automatically generate state wrapper aspects in AspectJ, which facilitates comparing actual object states to expected states during test execution. This enables the automated verdict of pass/failure for test cases without\u00a0\u2026", "num_citations": "16\n", "authors": ["358"]}
{"title": "A UML-based framework for design and analysis of dependable software\n", "abstract": " A formal method for software development often introduces a gap between rigidity of the method and informal nature of system requirements. This paper presents a UML-based framework for design and analysis of dependable software while narrowing such a gap. We model the intended functions of a software application with UML statecharts and security threats, i.e., potential attacks, with sequence diagrams. The statechart diagrams are converted into a graph transformation system, which is a well-studied formal method. This allows security threats to be verified against intended functions.", "num_citations": "16\n", "authors": ["358"]}
{"title": "Interaction-based reputation model in online social networks\n", "abstract": " Due to the proliferation of using various online social media, individual users put their privacy at risk by posting and exchanging enormous amounts of messages or activities with other users. This causes a serious concern about leaking private information out to malevolent entities without users\u2019 consent. This work proposes a reputation model in order to achieve efficient and effective privacy preservation in which a user\u2019s reputation score can be used to set the level of privacy and accordingly to determine the level of visibility for all messages or activities posted by the users. We derive a user\u2019s reputation based on both individual and relational characteristics in online social network environments. We demonstrate how the proposed reputation model can be used for automatic privacy assessment and accordingly visibility setting for messages/activities created by a user.", "num_citations": "14\n", "authors": ["358"]}
{"title": "Modeling security attacks with statecharts\n", "abstract": " Software security is becoming a key quality concern as software applications are increasingly being used in untrustworthy computing environments such as the internet. Software is designed with the mindset of its functionalities and cost, where the focus is on the operational behavior while security concerns are neglected or marginally considered. As a result, software engineers build the software while lacking the knowledge about security and its effect on the system. This paper presents an approach for modeling the behavior of security threats using statecharts. The proposed approach introduces modular design for representing threats through the use of components and reusability. Through the focus on the behavior of an attack, software engineers can clearly define and understand security concerns as the application is being designed and developed. In addition, modeling security threats with statecharts\u00a0\u2026", "num_citations": "14\n", "authors": ["358"]}
{"title": "A logic based language for networked agents\n", "abstract": " This paper presents a logic based language, SAFIN, for developing networked software agents. It integrates agent-oriented programming, KQML and basic mobile techniques to support intelligent behaviors, software interoperatablity and code transportability. As prototype based logic objects, agents are composed of network connections, knowledge bases (facts and beliefs), databases, behaviors, constraints, services, goals and KQML performatives. An approach to non-monotonic inheritance with both predicate level and clause level knowledge reuse is proposed and formally defined. Multi-level components and the interfaces to FTP services and relational database systems are also provided for developing specific distributed agents.", "num_citations": "14\n", "authors": ["358"]}
{"title": "Detecting saturation attacks based on self-similarity of OpenFlow traffic\n", "abstract": " As a new networking paradigm, Software-Defined Networking (SDN) separates data and control planes to facilitate programmable functions and improve the efficiency of packet delivery. Recent studies have shown that there exist various security threats in SDN. For example, a saturation attack may disturb the normal delivery of packets and even make the SDN system out of service by flooding the data plane, the control plane, or both. The existing research has focused on saturation attacks caused by SYN flooding. This paper presents an anomaly detection method, called SA-Detector, for dealing with a family of saturation attacks through IP spoofing, ICMP flooding, UDP flooding, and other types of TCP flooding, in addition to SYN flooding. SA-Detector builds upon the study of self-similarity characteristics of OpenFlow traffic between the control and data planes. Our work has shown that the normal and abnormal\u00a0\u2026", "num_citations": "13\n", "authors": ["358"]}
{"title": "Security mutation testing of the FileZilla FTP server\n", "abstract": " Security has become a priority for software development and many security testing techniques have been developed over the years. Benchmarks based on real-world systems, however, are in great demand for evaluating the vulnerability detection capability of these techniques. To develop such a benchmark, this paper presents an approach to security mutation analysis of FileZilla Server, a popular FTP server implementation as a case study. In the existing mutation testing research, mutants are created through syntactic changes. Such syntactic changes may not result in meaningful security vulnerabilities in security-intensive software. Our approach creates security mutants by considering the causes and consequences of vulnerabilities. The causes of vulnerabilities include design-level (eg, incorrect policy enforcement) and implementation-level defects (such programming errors as buffer overflow and unsafe\u00a0\u2026", "num_citations": "13\n", "authors": ["358"]}
{"title": "A systematic approach for integrating fault trees into system statecharts\n", "abstract": " As software systems are encompassing a wide range of fields and applications, software reliability becomes a crucial step. The need for safety analysis and test cases that have high probability to uncover plausible faults are necessities in proving software quality. System models that represent only the operational behavioral of a system are incomplete sources for deriving test cases and performing safety analysis before the implementation process. Therefore, a system model that encompasses faults is required. This paper presents a technique that formalizes a safety model through the incorporation of faults with system specifications. The technique focuses on introducing semantic faults through the integration of fault trees with system specifications or statechart. The method uses a set of systematic transformation rules that tries to maintain the semantics of both fault trees and statechart representations during the\u00a0\u2026", "num_citations": "13\n", "authors": ["358"]}
{"title": "Model-based testing of SDN firewalls: a case study\n", "abstract": " In Software defined networking (SDN), security mechanisms such as firewalls need to deal with dynamic network environments. This raises challenges for quality assurance of these security mechanisms. This paper presents a case study on model-based testing of SDN firewall programs. The subject program is the firewall module of Floodlight, one of the most popular SDN platforms in Java. We model the expected firewall behavior with function nets, a modeling formalism in the MISTA tool. The test code is generated automatically by MISTA. The result of our case study shows that the generated model-based tests have achieved much higher mutation coverage than the existing Junit tests in the Floodlight firewall program. This indicates that model-based testing can be a viable option for quality assurance of SDN-based firewall programs.", "num_citations": "12\n", "authors": ["358"]}
{"title": "Mining executable specifications of web applications from Selenium IDE tests\n", "abstract": " A common practice for system testing of web-based applications is to perform the test cases through a web browser. These tests are often recorded and managed by a record and replay tool, such as Selenium IDE. Mining specifications from such tests can be very useful for understanding, verifying, and debugging the system under test. This paper presents an approach to mining a behavior specification from a Selenium IDE test suite such that (a) it captures the behavior of the tests at a high level of abstraction, (b) the behavior can be simulated, and (c) all the tests are completely reproducible from the specification. We first identify similar test actions through context-sensitive clustering so as to normalize the given Selenium IDE tests. Then, we mine patterns of test actions that represent meaningful functions and transform Selenium IDE tests into abstract tests, which are similar to the tests used in the existing model\u00a0\u2026", "num_citations": "12\n", "authors": ["358"]}
{"title": "Identifying suspicious addresses in Bitcoin thefts\n", "abstract": " Bitcoin as a popular digital currency has been a target of theft and other illegal activities. Key to the forensic investigation is to identify bitcoin addresses involved in the bitcoin transfers. This paper presents a framework, FABT, for forensic analysis of bitcoin transactions by identifying suspicious bitcoin addresses. It formalizes the clues of a given case as transaction patterns defined over a comprehensive set of features. FABT converts the bitcoin transaction data into a formal model, called Bitcoin Transaction Net (BTN). The traverse of all bitcoin transactions in the order of their occurrences is captured by the firing sequence of all transitions in the BTN. When analyzing transaction flows, FABT exploits the notion of \u201cbitcoin fluid\u201d to track where the bitcoins passed through given addresses (called dyeing addresses) have flown and determine the extent to which each of the other addresses is related to the dyeing\u00a0\u2026", "num_citations": "11\n", "authors": ["358"]}
{"title": "Automated Coverage-Based Testing of XACML Policies\n", "abstract": " While the standard language XACML is very expressive for specifying fine-grained access control policies, defects can get into XACML policies for various reasons, such as misunderstanding of access control requirements, omissions, and coding errors. These defects may result in unauthorized accesses, escalation of privileges, and denial of service. Therefore, quality assurance of XACML policies for real-world information systems has become an important issue. To address this issue, this paper presents a family of coverage criteria for XACML policies, such as rule coverage, rule pair coverage, decision coverage, and Modified Condition/Decision Coverage (MC/DC). To demonstrate the assurance levels of these coverage criteria, we have developed methods for automatically generating tests, ie, access requests, to satisfy the coverage criteria using a constraint solver. We have evaluated these methods through\u00a0\u2026", "num_citations": "11\n", "authors": ["358"]}
{"title": "Automated fault localization of XACML policies\n", "abstract": " Access control policies in distributed systems, particularly implemented in the XACML standard language, are increasingly complex. Faults may exist in complex policies for various reasons such as misunderstanding of the access control requirements, omissions, and coding errors. These faults, if not removed before deployment, may lead to unauthorized accesses or denial of service. Manual localization of these faults, however, can be a challenging task. Inspired by spectrum-based fault localization for software debugging, this paper presents an approach for automatically localizing the fault (s) in a given XACML policy by exploring test coverage information of the policy elements. We investigate two test coverage criteria (ie, reachability and firing) of policy elements and 14 scoring methods for ranking policy elements to determine the fault location (s). To evaluate the fault localization methods, we have used real\u00a0\u2026", "num_citations": "11\n", "authors": ["358"]}
{"title": "Software Security.\n", "abstract": " \u25a0 \u7531\u4e8e\u7f51\u7edc\u5ba1\u67e5\u5bfc\u81f4\u4e2d\u56fd\u5927\u9646\u7528\u6237\u8bbf\u95ee Mac App Store \u6709\u8fde\u63a5\u56f0\u96be, \u90e8\u5206\u5f00\u53d1\u8005\u51fa\u4e8e\u65b9\u4fbf\u9009\u62e9\u4e86\u56fd\u5185\u7b2c\u4e09\u65b9\u6e20\u9053\u4e0b\u8f7d (\u5982\u767e\u5ea6\u4e91\u76d8, \u8fc5\u96f7\u79bb\u7ebf\u7b49) \u6216\u8005\u4ece\u793e\u4ea4\u5e73\u53f0\u67e5\u627e\u83b7\u5f97\u5f00\u53d1\u7a0b\u5e8f, \u7531\u6b64\u5e26\u6765\u4e86\u5b89\u5168\u9690\u60a3", "num_citations": "11\n", "authors": ["358"]}
{"title": "Mining test oracles for test inputs generated from java bytecode\n", "abstract": " Search-based test generation can automatically produce a large volume of test inputs. However, it is difficult to define the test oracle for each of the test inputs. This paper presents a mining approach to building a decision tree model according to the test inputs generated from Java bytecode. It converts Java bytecode into the Jimple representation, extracts predicates from the control flow graph of the Jimple code, and uses these predicates as attributes for organizing training data to build a decision tree. Our case studies show that the mining approach generated accurate behavioral models and that test oracles derived from these models were able to kill 94.67% of the mutants with injected faults.", "num_citations": "10\n", "authors": ["358"]}
{"title": "Towards an enhanced design level security: integrating attack trees with statecharts\n", "abstract": " Software security has become more and more critical as we are increasingly depending on the Internet, an untrustworthy computing environment. Software functionality and security are tightly related to each other, vulnerabilities due to design errors, inconsistencies, incompleteness, and missing constraints in system specifications can be wrongly exploited by security attacks. These two concerns, however, are often handled separately. In this paper we present a threat driven approach that improves on the quality of software through the realization of a more secure functional model. The approach introduces systematic transformation rules and integration steps for mapping attack tree representations into lower level dynamic behavior, then integrates this behavior into state chart-based functional models. Through the focus on both the functional and threat behavior, software engineers can introduce, clearly define\u00a0\u2026", "num_citations": "10\n", "authors": ["358"]}
{"title": "A Petri Net Based Software Architecture for UAV Simulation.\n", "abstract": " This paper presents a Petri net-based hierarchical architecture for multiple Unmanned Aerial Vehicle (UAV) simulations in order to facilitate rapid prototyping via visual modeling and analysis. Using high-level Colored Petri nets, we specify UAV control structure by a hierarchy of mission control net and task nets: the mission control net, built upon task nets, models the decision making process of the UAV simulation; tasks nets are built from primitive UAV behaviors and environmental behaviors. To realize effects of UAV behaviors on the simulation environment, procedures may be associated with transitions in Petri nets. To demonstrate the approach, we describe two experimental UAV mission scenarios: sweeping search and multi-point attack.", "num_citations": "10\n", "authors": ["358"]}
{"title": "Measurement of source code readability using word concreteness and memory retention of variable names\n", "abstract": " Source code readability is critical to software quality assurance and maintenance. In this paper, we present a novel approach to the automated measurement of source code readability based on Word Concreteness and Memory Retention (WCMR) of variable names. The approach considers programming and maintenance as processes of organizing variables and their operations to describe solutions to specific problems. The overall readability of given source code is calculated from the readability of all variables contained in the source code. The readability of each variable is determined by how easily its meaning is memorized (i.e., word concreteness) and how quickly they are forgotten over time (i.e., memory retention). Our empirical study has used 14 open source applications with over a half-million lines of code and 10,000 warning defects. The result shows that the WCMR-based source code readability\u00a0\u2026", "num_citations": "9\n", "authors": ["358"]}
{"title": "Mining for core patterns in stock market data\n", "abstract": " We introduce an algorithm that uses stock sector information directly in conjunction with time series subsequences for mining core patterns within the sectors of stock market data. The core patterns within a sector are representative groups of stocks for the sector when it shows coherent behavior. Multiple core patterns may exist in a sector at the same time. In comparison with clustering algorithms, the core patterns are shown to be more stable as the stock price evolves. The proposed algorithm has only one free parameter, for which we provide an empirical choice. We demonstrate the effectiveness of the algorithm through a comparison with the DBScan clustering algorithm using data from the Standard and Poor 500 Index.", "num_citations": "9\n", "authors": ["358"]}
{"title": "Forensic Analysis of Bitcoin Transactions\n", "abstract": " Bitcoin [1] as a popular digital currency has been a target of theft and other illegal activities. Key to the forensic investigation is to identify bitcoin addresses involved in bitcoin transfers. This paper presents a framework, FABT, for forensic analysis of bitcoin transactions by identifying suspicious bitcoin addresses. It formalizes the clues of a given case as transaction patterns defined over a comprehensive set of features. FABT converts the bitcoin transaction data into a formal model, called Bitcoin Transaction Net (BTN). The traverse of all bitcoin transactions in the order of their occurrences is captured by the firing sequence of all transitions in the BTN. We have applied FABT to identify suspicious addresses in the Mt.Gox case. A subgroup of the suspicious addresses has been found to share many characteristics about the received/transferred amount, number of transactions, and time intervals.", "num_citations": "8\n", "authors": ["358"]}
{"title": "Deviant: A Mutation Testing Tool for Solidity Smart Contracts\n", "abstract": " Solidity is a widely used scripting language for developing smart contracts in blockchain applications. Quality assurance of Solidity contracts is of critical importance because bugs can lead to considerable loss of assets. As software testing is a common practice for quality assurance, many Solidity projects have included built-in tests. It is unclear, however, what level of quality assurance these built-in tests can achieve. This paper presents Deviant, a mutation testing tool for Solidity smart contracts. It automatically generates mutants of a given Solidity project and runs all mutants against the given tests to evaluate their effectiveness. To simulate various faults in Solidity smart contracts, Deviant provides mutation operators for all the unique features of Solidity according to the Solidity fault taxonomy, in addition to the traditional programming constructs. We have used Deviant to evaluate the effectiveness of the tests for\u00a0\u2026", "num_citations": "8\n", "authors": ["358"]}
{"title": "Software security testing via misuse case modeling\n", "abstract": " Software security testing is an important technique for discovering software vulnerabilities that violate security requirements. Existing security testing methods, however, seldom generate security tests directly from security requirements specifications. To address this issue, this paper presents an approach for constructing security test models from the artifacts of misuse case modeling (i.e., use/misuse cases and mitigation use cases), which is a popular method for security requirements specification in the software development process. The security test models can then be used to automatically generate security tests, which consist of test inputs (normal behaviors from use cases and attack actions from misuse cases) and test oracles from mitigation use cases. We have applied the approach to two case studies. One case study demonstrates that the proposed approach can build security test models in a structured\u00a0\u2026", "num_citations": "8\n", "authors": ["358"]}
{"title": "Automated integration testing using logical contracts\n", "abstract": " Modern computer software usually consists of a number of interacting components. Defects pertaining to component interactions may not be visible until the components are integrated. To exercise component interactions, we propose an integration testing approach based on the core concept of contracts (i.e., preconditions and postconditions of component calls in first-order logic). To enable correctness analysis and generation of coverage-based tests (including state coverage, transition or component coverage, and reachability coverage) of a contract-based test model, we transform the test model into an operational model. We have implemented this approach into a framework that has the capacity to generate executable test code in a large collection of programming languages and to run the generated test code in a rich variety of test execution environments. To demonstrate the cost-effectiveness of our\u00a0\u2026", "num_citations": "8\n", "authors": ["358"]}
{"title": "Automated Test Code Generation from UML Protocol State Machines.\n", "abstract": " This paper presents a framework for automated generation of executable test code from UML 2.0 protocol state machines. It supports several coverage criteria for state models, including state coverage, transition coverage, and basic and extended round-trip coverage. It transforms the state invariants and transition postconditions of a state model into executable assertions to be verified against the actual object states by runtime code instrumentation. Handcrafted test data are reused from one development version to the next due to the change of requirements. This reduces the working load for test regeneration of modified models. Our framework also reports the complexity of generated test suites, which can facilitate empirical evaluation of different coverage criteria for state models.", "num_citations": "8\n", "authors": ["358"]}
{"title": "A formal model-based approach for developing an interoperable mobile agent system\n", "abstract": " Mobile agents provide an effective and flexible approach to developing complex distributed systems. Formalizing the software architecture of mobile agent systems supports the development of high quality agent systems. In this paper, the software architecture of an interoperable mobile agent system is defined using two-layer predicate transition (PrT) nets. Based on the two-layer PrT net models, a formal model-based approach to develop mobile agents systems is proposed. The approach presented in this paper naturally integrates formal methods and practical approaches in each phase of the development life-cycle of the agent system. The proposed approach for agent systems can also be used to develop other complex software systems.", "num_citations": "8\n", "authors": ["358"]}
{"title": "An aspect-oriented approach to mobile agent access control\n", "abstract": " This paper presents an aspect-oriented approach to access control in mobile agent systems, where a multipoint security check mechanism visualizes the services of a host as individual components and access of each will require authentication. Since the security check crosscuts various functional components of mobile agents and their platforms, it is naturally handled in the aspect-oriented paradigm. This approach is suitable not only for developing mobile agent systems from scratch, but also for enhancing legacy mobile agent systems. We demonstrate our approach through a case study.", "num_citations": "8\n", "authors": ["358"]}
{"title": "A hybrid knowledge representation based on logical objects\n", "abstract": " This paper presents a hybrid knowledge representation based on the framework of logical knowledge objects (LKO), which are viewed as abstractions with behaviors, state and inheritance. It accommodates the main features of various knowledge representations, such as rule, frame, semantic network and blackboard, while amalgamating logic programming and object oriented programming paradigms. Therefore, it supports such notions as inheritance, modularity, reusability, structuring and dynamic modification of knowledge, which have turned out to be extremely useful for the design and maintenance of large scale knowledge based systems and expert systems. Using the framework, we can explicitly define the hierarchy of logical objects and easily obtain the solutions. With the basic notions and the semantics of LKO introduced, we focus on how it fits for the various knowledge representations, and discuss the\u00a0\u2026", "num_citations": "8\n", "authors": ["358"]}
{"title": "Detecting Saturation Attacks in SDN via Machine Learning\n", "abstract": " Software Defined Networking (SDN) is a new network paradigm that facilitates network management by separating the control plane from the data plane. Studies have shown that an SDN may experience a high packet loss rate and a long delay in forwarding messages when the OpenFlow channel is overwhelmed by a saturation attack. The existing approaches have focused on the detection of saturation attacks caused by TCP-SYN flooding through periodic analysis of network traffic. However, there are two issues. First, previous approaches are incapable of detecting other types, especially unknown types, of saturation attacks. Second, they rely on predetermined time-window of network traffic and thus are unable to determine what time window of traffic data would be appropriate for effective attack detection. To tackle these problems, this paper first investigates the impact of different time-windows of OpenFlow\u00a0\u2026", "num_citations": "7\n", "authors": ["358"]}
{"title": "Model checking of security properties in industrial control systems (ICS)\n", "abstract": " With the increasing inter-connection of operation technology to the IT network, the security threat to the Industrial Control System (ICS) is increasing daily. Therefore, it is critical to utilize formal verification technique such as model checking to mathematically prove the correctness of security and safety requirements in the controller logic before it is deployed on the field. However, model checking requires considerable effort for regular ICS users and control technician to verify properties. This paper, provides a simpler approach to the model checking of temperature process control system by first starting with the control module design without formal verification. Second, identifying possible vulnerabilities in such design. Third, verifying the safety and security properties with a formal method.", "num_citations": "7\n", "authors": ["358"]}
{"title": "Formalizing semantic differences between combining algorithms in XACML 3.0 policies\n", "abstract": " XACML is a standard language for specifying attribute-based access control policies of computer and software systems. It offers a variety of combining algorithms for flexible policy composition. While they are intended to be different, they also bear similarities. Some combining algorithms can be functionally equivalent with respect to the given policy or policies. To correctly use the combining algorithms, it is important to understand the subtle similarities and differences. This paper presents a formal treatment of the semantic differences between the commonly used combining algorithms in XACML 3.0. For each pair of the selected combining algorithms, we identify when they are functionally equivalent and when they are not equivalent. This rigorous understanding helps minimize incorrect uses of combining algorithms that may lead to unauthorized access and denial of service. It also provides a foundation for\u00a0\u2026", "num_citations": "7\n", "authors": ["358"]}
{"title": "Maximizing the availability of replicated services in widely distributed systems considering network availability\n", "abstract": " Availability is an important issue in distributed environments that promise to provide quality of services and thus the mechanisms to improve data or service availability is critical to ensure such quality of service. Replication schemes have been widely used to improve data or service availability. In addition to the number of replicas, the location of the replicas also impacts the data availability. In this paper, we consider the impact of node and network link failures on the availability of replicated data and services. Efficient replica allocation algorithms with runtime of O(K|V| 2 ) are developed to improve data availability, where K is the predetermined number of replica and |V| is the number of nodes in the system. Experimental studies have been conducted to evaluate how effective the proposed replica allocation algorithms on improving the availability of replicated data or services. The results show that the two proposed\u00a0\u2026", "num_citations": "7\n", "authors": ["358"]}
{"title": "Testing access control and obligation policies\n", "abstract": " As access control with obligatory constraints is critical to assuring system accountability, research on the specification and monitoring of obligation policy has gained increasing attention. However, a correctly specified obligation policy may be implemented incorrectly for various reasons, such as programming errors. This paper presents a model-based approach to testing access control and obligation policies. We build test models of access control and obligation policies based on system functions and derive tests from the models for exercising the system implementation. As a black box technique, our approach is independent of how access control and obligation requirements are implemented in the system under test. We demonstrate our approach through the testing of a real-world online banking system, which is being used by many financial organizations. The mutation analysis indicated that our testing\u00a0\u2026", "num_citations": "7\n", "authors": ["358"]}
{"title": "Mutation analysis of magento for evaluating threat model-based security testing\n", "abstract": " Security testing is a major means for assuring software security and many security testing techniques have been developed in the past. Benchmarks, however, are in great demands for empirically evaluating the vulnerability detection capabilities of these techniques. To develop such a benchmark, this paper presents an approach to security mutation analysis of Magento, a fully-fledged open source e-commerce web application for evaluating automated security testing techniques. We create security mutants by injecting vulnerabilities in a systematic way. Specifically, we consider the causes of vulnerabilities according to OWASP's top 10 web application security risks, the application's business logic, as well as various consequences of vulnerabilities (i.e., STRIDE attacks). We have created 63 mutants and applied them successfully to the evaluation of two security testing techniques that use threat trees and threat\u00a0\u2026", "num_citations": "7\n", "authors": ["358"]}
{"title": "Security Analysis of FileZilla Server Using Threat Models.\n", "abstract": " FTP is a widely used protocol for working with remote file systems. Various FTP implementations have had security problems reported as late as 2010. There lacks a systematic analysis of FTP security. In this paper, threat models are built to provide a systematic coverage of potential security attacks against an FTP server. Security tests are then generated from the threat models and applied to FileZilla Server, a popular FTP server implementation. When FileZilla Server is properly deployed, it holds fast against our security attacks. To further evaluate the effectiveness, the security tests are used to exercise a number of security mutants of FileZilla Server where various vulnerabilities are injected deliberately. The threat models have detected all but one of the injected vulnerabilities. This indicates that our threat model-based approach to security analysis of FileZilla Server is very effective.", "num_citations": "7\n", "authors": ["358"]}
{"title": "Analysis and Prediction of Endorsement-Based Skill Assessment in LinkedIn\n", "abstract": " In LinkedIn, skill endorsements are used as a key indicator to assess a user's skill level so that a recruiter can find right candidates. However, the simple counting of skill endorsements has shown serious limitations to correctly assess a user's skill level particularly when false endorsements prevail for self-promotion or collusive promotion. To address this issue, we propose a framework using regression analysis to evaluate assessment methods under varying the degree of false endorsements. We define two types of assessment scores: authority score (AS) and credit score (CS). The AS is calculated based on an endorser's expertise level in a particular skill set while the CS is estimated based on the endorser's trustworthiness. Based on these two types of skill assessments, we define a hybrid method that calculates AS based on CS, which is called credit-based AS, or namely CAS. We conduct performance analysis\u00a0\u2026", "num_citations": "6\n", "authors": ["358"]}
{"title": "Model-Based Testing of Obligatory ABAC Systems\n", "abstract": " Attribute-based access control (ABAC) with obligations is a new technique for achieving fine-grained access control and accountability. An obligatory ABAC system can be implemented incorrectly for various reasons, such as programming errors and incorrect access control and obligation specification. To reveal these implementation defects, this paper presents an approach to model-based testing of obligatory ABAC systems. In this approach, we first build a test model by specifying a functional model and an obligatory ABAC policy. The policy represents access control and obligation constraints on the functional model. Then we weave the policy with the functional model into an integrated model that represents both functions under test and access control and obligation constraints on them. Test cases can then be generated from the integrated model. Our approach is built upon MISTA, an open source test code\u00a0\u2026", "num_citations": "6\n", "authors": ["358"]}
{"title": "Towards automatic repair of access control policies\n", "abstract": " Access control policies written in the XACML standard language tend to be complex due to the great variety of attribute types and operations for fine-grained access control. The complexity not only increases the likelihood of having authorization faults in access control policies, but also makes it challenging to find and fix these faults. This paper presents an approach for automating the process of debugging XACML policies. It consists of two main techniques: fault localization and mutation-based policy repair. Fault localization aims to find the most suspicious policy elements according to the correlation between the execution information of policy elements and the test execution results. Mutation-based policy repair aims to modify the suspicious policy elements by using well-defined mutation operators. Our empirical studies have used a large number of faulty policies with one or two seeded faults. Our approach was\u00a0\u2026", "num_citations": "6\n", "authors": ["358"]}
{"title": "Fault-Based Testing of Combining Algorithms in XACML3. 0 Policies.\n", "abstract": " With the increasing complexity of software, new access control methods have emerged to deal with attributebased authorization. As a standard language for attribute-based access control policies, XACML offers a number of rule and policy combining algorithms to meet different needs of policy composition. Due to their variety and complexity, however, it is not uncommon to apply combining algorithms incorrectly, which can lead to unauthorized access or denial of service. To solve this problem, this paper presents a fault-based testing approach for determining incorrect combining algorithms in XACML 3.0 policies. It exploits an efficient constraint solver to generate queries to which a given policy produces different responses than its combining algorithm-based mutants. Such queries can determine whether or not the given combining algorithm is used correctly. Our empirical studies using sizable XACML policies have demonstrated that our approach is effective.", "num_citations": "6\n", "authors": ["358"]}
{"title": "Rule-Based Test Input Generation from Bytecode\n", "abstract": " Search-based test generators, such as those using genetic algorithms and alternative variable methods, can automatically generate test inputs. They typically rely on fitness functions to calculate fitness scores for guiding the search process. This paper presents a novel rule-based testing (RBT) approach to automated generation of test inputs from Java byte code without using fitness functions. It extracts tagged paths from the control flow graph of given byte code, analyzes and monitors the predicates in the tagged paths at runtime, and generates test inputs using predefined rules. Our case studies show that RBT has outperformed the test input generators using genetic algorithms and alternative variable methods.", "num_citations": "6\n", "authors": ["358"]}
{"title": "A methodology for building effective test models with function nets\n", "abstract": " Building effective test models is critical to the applications of model-based testing. This paper presents a methodology for guiding model-based testing with function nets, which are lightweight high-level Petri nets. High-level Petri nets are traditionally used for modeling, simulation, and verification purposes. In this paper, however, function nets are test models for automated generation of test cases. The proposed methodology has three key features. First, based on an analogy between modeling and programming, it identifies the basic building blocks for composing test models. Second, it provides structured processes for building test models from workflows and from the contracts of the components under test. Third, it provides several techniques for reducing the complexity of test models and thus the number of tests. The methodology has been applied to the function testing and security testing of several industry\u00a0\u2026", "num_citations": "6\n", "authors": ["358"]}
{"title": "Multi-agent designs for ambient systems\n", "abstract": " Designing and developing software for an ambient intelligence (AmI) system involves difficult challenges related to the varied roles of many heterogeneous devices and communication channels, and intelligent user interfaces. Because ambient systems have unpredictable requirements and are context-aware, software designs must support dynamic and sustainable change. We argue that such designs should utilize formal methods and aspect-oriented techniques, to help in supporting model validation and verification. Features of an aspect-oriented, multi-agent, architectural description language are presented as a mechanism for reasoning about cross-cutting concerns.", "num_citations": "6\n", "authors": ["358"]}
{"title": "Trade-off Analysis of Misuse Case-based Secure Software Architectures: A Case Study.\n", "abstract": " Based on the threat-driven architectural design of secure information systems, this paper introduces an approach for the tradeoff analysis of secure software architectures in order to determine the effects of security requirements on the system. We use a case study on a payroll information system (PIS) to show the approach from misuse case identification through the architecture tradeoff analysis. In the case study, we discuss how to make tradeoff between security and availability with respect to the number of servers present.", "num_citations": "6\n", "authors": ["358"]}
{"title": "Collaborative Agents for C2 Teamwork Simulation.\n", "abstract": " Existing team training software often requires that trainees be organized as physical teams and the members of the same team be trained at the same time. To demonstrate that team training software can be made more flexible, this paper presents an approach to incorporating software agents into the distributed command-and-control (C2) simulation software DDD, which supports only human players. Based on the multi-agent architecture CAST, the software agents are designed as a team to perform C2 tasks in the DDD. By associating the agents with the same basic capabilities as the DDD provides its human users, we illustrate how to specify the teamwork knowledge for the agent team, and how to make agents efficiently reason about the dynamic, partially observable environment. Different methods of communication and coordination among agents are also briefly described.", "num_citations": "6\n", "authors": ["358"]}
{"title": "Logical objects with constraints\n", "abstract": " This paper presents a novel programming language called LOC (Logical Objects with Constraints), which combines logic programming and object-oriented programming paradigms. In LOC, logical objects are viewed as abstractions with state, constraints, behaviors and inheritance. It therefore supports such notions as inheritance, modularity and reusability, which have turned out to be extremely useful for large scale software systems. The operational interpretation defined in the style of natural semantics is simple and clear. The transformation of LOC into Prolog is also explored to indirectly illustrate the descriptive semantics.", "num_citations": "6\n", "authors": ["358"]}
{"title": "VERIFYING CONSISTENCE AND REDUNDANCE OF PRODUCTION SYSTEM KNOWLEDGE BASE [J]\n", "abstract": " This paper describes several forms of inconsistent and redundant rules or rule chains in production system knowledge base. Techniques and methods are also given to verify these rules or rule chains. They help engineers to construct and maintain knowledge base effectively and lay the foundation of automatic knowledge acquisition.", "num_citations": "6\n", "authors": ["358"]}
{"title": "Undergraduate Research Experience in Cybersecurity for Underrepresented Students and Students with Limited Research Opportunities\n", "abstract": " Undergraduate research opportunities have expanded from elite universities in the United States to universities and learning institutions of all ranks and sizes. Research studies have showed some positive outcomes of the research experience for undergraduates (REU), such as enhanced research skills and competencies. However, with the widespread implementation of REU programs across the country, there are some serious and challenging issues, such as fierce competition among students for limited participation opportunities and a overlooking of underrepresented students\u2019 needs. This study reported a nine-week REU Site program in cybersecurity designed for underrepresented students (women and minorities) and participants from institutions with limited research opportunities for the past three years. Results showed that most participants enjoyed the opportunity to work on a real world project and to\u00a0\u2026", "num_citations": "5\n", "authors": ["358"]}
{"title": "Detecting Saturation Attacks in Software-Defined Networks\n", "abstract": " Software-Defined Networking (SDN) is a new net-working paradigm that has revolutionized network architectures. The separation of data and control planes improves the efficiency of packet delivery. However, there exist various security attacks against SDN systems. For example, a saturation attack may disturb the normal delivery of packets and even make the SDN system out of service by flooding the data plane, the control plane, or both. This paper presents an anomaly detection method, called SA-Detector, for dealing with a family of saturation attacks. SA-Detector builds upon the study of self-similarity of OpenFlow traffic, which has shown that the normal and abnormal traffic patterns between the controller and the OpenFlow switches have different characteristics. We have evaluated the performance of SA-Detector with different time scales, network scales, Internet applications, and attack implementations. The\u00a0\u2026", "num_citations": "5\n", "authors": ["358"]}
{"title": "Bayesian Unigram-Based Inference for Expanding Abbreviations in Source Code\n", "abstract": " Programmers often utilize abbreviations for naming identifiers when writing code. However, the difficulty to retrieve the original words of abbreviations during the maintenance phase makes the source code more problematic to comprehend. In this paper, we describe a Bayesian unigram-based inference to automatically expand abbreviations to their original words to enhance source code comprehension. Our approach automatically extracts a list of candidate words from the source code for a given abbreviation and employs the abbreviation's unigram statistical properties as evidence to find the best candidate word. We evaluated our approach on a set of 531 abbreviations randomly picked from eight open source projects and found that our approach correctly expands 83.62% of the set. Our approach provides an improvement of 48.3% in abbreviation expansion accuracy over the current state-of-the-art approaches.", "num_citations": "5\n", "authors": ["358"]}
{"title": "Network parallelization in HPC clusters\n", "abstract": " HPC typically employs parallelization in software and hardware in order to accelerate the computing processing. The underlying network itself is used collectively by all HPC experiments. In this paper, we propose a parallelization for the underlying network based on the different running HPC experiments or jobs. Each experiment/job will be logically sliced and isolated from other experiments. Additionally, each experiment/job includes different logical nodes across the HPC cluster. SDN controller is used to manage and control the slicing process. We evaluated this model using Opendaylight controller, FlowVisor and Mininet. We showed the impact that such network parallelization/slicing will bring to HPC clusters in terms of cluster efficiency and experiments' performance.", "num_citations": "5\n", "authors": ["358"]}
{"title": "Forensic Evidence Identification and Modeling for Attacks against a Simulated Online Business Information System\n", "abstract": " Forensic readiness of business information systems can support future forensics investigation or auditing on external/internal attacks, internal sabotage and espionage, and business fraud. To establish forensics readiness, it is essential for an organization to identify which fingerprints are relevant and where they can be located, to determine whether they are logged in a forensically sound way and whether all the needed fingerprints are available to reconstruct the events successfully. Also, a fingerprint identification and locating mechanism should be provided to guide potential forensics investigation in the future. Furthermore, mechanisms should be established to automate the security incident tracking and reconstruction processes. In this research, external and internal attacks are first modeled as augmented attack trees based on the vulnerabilities of business information systems. Then, modeled attacks are\u00a0\u2026", "num_citations": "5\n", "authors": ["358"]}
{"title": "Human-agent teamwork for distributed team training\n", "abstract": " This paper presents an approach to human-agent mixed teams for distributed team training, demonstrated through the integration of the domain independent multiagent architecture CAST with the military command-and-control simulation software DDD (distributed dynamic decision-making). We extend the CAST architecture in a way such that agents can replace any number of teammates on a DDD team. To capture the overall picture of teamwork, we explore the MALLET language in CAST for the specification of team structures and processes that involve both humans and agents.", "num_citations": "5\n", "authors": ["358"]}
{"title": "Towards an object-oriented logic framework for knowledge based systems\n", "abstract": " This article presents an object-oriented logic framework, LKO, for the dependable development of knowledge based systems. Based on logical objects which are viewed as abstractions with states, constraints, behaviors and nonmonotonic inheritance, a hybrid knowledge representation amalgamating rule, frame, semantics network and blackboard is available for both most structured and flat knowledge and requirements of knowledge based systems. After the iterations of specification modification and verification in terms of knowledge acquisition activities, prototypes are correctly formed. The LKO methodology, applying the concepts of rapid prototyping, top-down design and object-orientation, is designed to deal with changing and incomplete requirements and to provide multiple abstract models of the domain, where formal methods might be used at each abstract level.", "num_citations": "5\n", "authors": ["358"]}
{"title": "vswitchguard: Defending openflow switches against saturation attacks\n", "abstract": " While the decoupling of control and data planes in software-defined networking (SDN) facilitates orchestrating network traffic, it suffers from security threats. For example, saturation attacks can make SDN out of service by exhausting the controller' and switch's computational resources. The existing research has focused on defense against limited types of saturation attacks. In this paper, we propose vSwitchGuard, a framework for detection and countermeasure of known and unknown saturation attacks in SDN. vSwitchGuard aims to identify the victim switches targeted by known or unknown types of saturation attacks with machine learning classifiers and restore the victim switches to their safe state through deep packet inspection. We have evaluated three supervised classifiers and four semi-supervised classifiers for five types of saturation attacks (TCP-SYN, UDP, ICMP, IP-Spoofing, and TCP-SARFU) and their\u00a0\u2026", "num_citations": "4\n", "authors": ["358"]}
{"title": "Statistical unigram analysis for source code repository\n", "abstract": " Unigram is a fundamental element of -gram in natural language processing. However, unigrams collected from a natural language corpus are unsuitable for solving problems in the domain of computer programming languages. In this paper, we analyze the properties of unigrams collected from an ultra-large source code repository. Specifically, we have collected 1.01 billion unigrams from 0.7 million open source projects hosted at GitHub.com. By analyzing these unigrams, we have discovered statistical properties regarding (1) how developers name variables, methods, and classes, and (2) how developers choose abbreviations. We describe a probabilistic model which relies on these properties for solving a well-known problem in source code analysis: how to expand a given abbreviation to its original indented word. Our empirical study shows that using the unigrams extracted from source code repository\u00a0\u2026", "num_citations": "4\n", "authors": ["358"]}
{"title": "Automated Generation of Integration Test Sequences from Logical Contracts\n", "abstract": " This paper exploits logical contracts (i.e., Preconditions and post conditions) to automatically generate integration tests. The approach transforms a contract-based test model into an operational model, which makes it feasible to analyze correctness of the test model and generate integration tests to meet coverage criteria of the test model. This approach has been implemented in MISTA, a tool for automated generation of executable tests. MISTA allows executable test code to be generated in a rich variety of programming languages (e.g., Java, C, C++, C#, and PHP) and test execution environments. We have evaluated the fault-detection capability of contract-based test models through fault injection. The results show that contract-based tests can be highly effective in fault detection and that robustness tests targeting the situations of broken contracts are critical to finding faults related to component interactions.", "num_citations": "4\n", "authors": ["358"]}
{"title": "System resilience modeling and enhancement for the cloud\n", "abstract": " It has become increasingly evident that large scale systems such as clouds can be brittle and may exhibit unpredictable behavior when faced with unexpected disturbances. Even weak and innocuous disturbances can bring down the system inoperative and may introduce catastrophic disasters to the society. The goal of this research is to explore the fundamental theories that govern cloud system resilience and to provide novel and effective mechanisms to model and enhance the resilience of cloud. A food web like process interaction model is developed and system resilience enhancement mechanisms are proposed based on the control of the strength of interactions. Also, the effectiveness and limitations of modularization on resilience enhancement is illustrated by using a replica consistency control protocol. The research has shown that weakening key process interactions and modularizing complex systems are\u00a0\u2026", "num_citations": "4\n", "authors": ["358"]}
{"title": "Modeling and analyzing a mobile agent-based clinical information system\n", "abstract": " This paper presents an approach for modeling and model-checking a mobile agent system specified by LAM, which is a two-layer formal method for characterizing logical agent mobility using Predicate/Transition (PrT) nets. Based on the transformation of PrT nets into input programs of the model checker SPIN, we model check a variety of properties with respect to agents, logical agent mobility, agent environments, and system interaction in a mobile agent system model. We demonstrate our approach through a case study on the modeling and analysis of a mobile agent\u2013based clinical information system.", "num_citations": "4\n", "authors": ["358"]}
{"title": "Generating parallel plans based on planning graph analysis of predicate/transition nets\n", "abstract": " Multi-agent systems often exhibit rich parallelism among agents. It is desirable in a multi-agent planner to explicitly represent parallel actions. This paper presents an approach for generating parallel execution plans based on the planning graph analysis. Instead of representing a planning problem by STRIPS operators, we model multi-agent planning domains using Predicate/Transition (PrT) nets (a high-level formalism of Petri nets), which are well suited for capturing dynamic behaviors of concurrent systems. We demonstrate that the planning graph analysis is adaptable for the analysis of PrT nets. Based on the planning graph analysis of a PrT net, a parallel plan with explicit representation of parallel actions can be automatically generated.", "num_citations": "4\n", "authors": ["358"]}
{"title": "Automated Strong Mutation Testing of XACML Policies\n", "abstract": " While the existing methods for testing XACML policies have varying levels of effectiveness, none of them can reveal the majority of policy faults. The undisclosed faults may lead to unauthorized access and denial of service. This paper presents an approach to strong mutation testing of XACML policies that automatically generates tests from the mutants of a given policy. Such mutants represent the targeted faults that may appear in the policy. In this approach, we first compose the strong mutation constraints that capture the semantic difference between each mutant and its original policy. Then, we use a constraint solver to derive an access request (ie, test). The test suite generated from all the mutants of a policy can achieve a perfect mutation score, thus uncover all hypothesized faults or demonstrate their absence. Based on the mutation-based approach, this paper further explores optimal test suite that achieves a\u00a0\u2026", "num_citations": "3\n", "authors": ["358"]}
{"title": "Predicting friendship strength for privacy preserving: a case study on Facebook\n", "abstract": " Effective friend classification in Online Social Networks (OSN) has many benefits in privacy. Anything posted by a user in social networks like Facebook is distributed among all their friends. Although the user can select the manual option for their post-dissemination, it is not feasible every time. Since not all friends are the same in social networks, the visibility access for the post should be different for different strengths of friendship for privacy. Previous works in finding friendship strength in social networks have used interaction and similarity based features but none of them has considered using sentiment-based features as the driving factor to determine the strength.", "num_citations": "3\n", "authors": ["358"]}
{"title": "Formalizing semantic differences of combining algorithms in XACML 3.0\n", "abstract": " XACML3. 0 offers a variety of rule and policy combining algorithms for flexible policy composition. While they are intended to be different, they also bear similarities. In particular, some rule (or policy) combining algorithms can be functionally equivalent with respect to the given policy (or policies). To correctly use the combining algorithms, it is important to understand their similarities and differences. This report aims at formalizing semantic similarities and differences of the commonly used combining algorithms. For each pair of the selected combining algorithms, we identify when they are functionally equivalent and when they are not equivalent. The results of comparisons are presented in 49 theorems with detailed proofs.", "num_citations": "3\n", "authors": ["358"]}
{"title": "Integrated modeling and analysis of attribute based access control policies and workflows in healthcare\n", "abstract": " Healthcare information systems deal with sensitive data across complex workflows. They often allow various stakeholders from different environments to access data across organizational boundaries. This elevates the risk of exposing sensitive healthcare information to unauthorized personnel. To prevent unwanted access to sensitive information, healthcare organizations need to adopt effective workflows and access control mechanisms. This research addresses this issue by developing a methodology for integrated modeling and analysis of organizational workflows and attribute-based access control policies. This methodology can help identify workflow activities that are not being protected by access control policies and improve existing access control policies. In addition to subjects, resources, and actions, our methodology introduces 'environment' as a new element to workflow activity. This allows more\u00a0\u2026", "num_citations": "3\n", "authors": ["358"]}
{"title": "Resilience as a new system engineering for cloud computing\n", "abstract": " It has become increasingly evident that large scale systems such as clouds can be brittle and may exhibit unpredictable behavior when faced with unexpected disturbances. Even weak and innocuous disturbances can bring down the system inoperative and may introduce catastrophic disasters to the society. The goal of this research is to explore the fundamental principles and theories that govern cloud system resilience and to provide novel and effective mechanisms to model and enhance the resilience of cloud. A food web like process interaction model is developed and system resilience enhancement mechanisms are proposed based on the control of the strength of interactions. Also, the effectiveness and limitations of modularization on resilience enhancement is illustrated by using a replica consistency control protocol. The research has shown that weakening key process interactions and modularizing complex systems are very effective on resilience enhancement.", "num_citations": "3\n", "authors": ["358"]}
{"title": "Ensuring Consistent Use/Misuse Case Decomposition for Secure Systems.\n", "abstract": " Misuse case modeling is a viable option to depict the security requirements together with functional requirements. We then use decomposition to investigate the interplay between functional and security requirements, thus creating a complete set of securitycentric requirements that can guide subsequent software development phases. Part of the initial decomposition is to identify relationships (\u201cincludes\u201d and \u201cextends\u201d) among decomposed cases for each case type (use, misuse, mitigation use). Decomposition is conducted for each case type independently and then integrated with the \u201cthreatens\u201d and \u201cmitigates\u201d relationships where misuse cases \u201cthreaten\u201d use cases and mitigation use cases \u201cmitigate\u201d misuse cases. Consistency must be maintained as decomposition continues and additional cases are created so that the initial relationships of each case type are preserved. Relationship specific conditions must be met for a relationship to be present among the decomposed cases. We introduce a condition-driven process to ensure consistency of decomposition past the initial identification and modeling of the relationships present among the three cases types.", "num_citations": "3\n", "authors": ["358"]}
{"title": "An Aspect-Oriented Approach to Mobile Agent Security\n", "abstract": " This paper presents an aspect-oriented approach to access control and log-based non-repudiation for mobile agent systems. Such security issues are treated as concerns that crosscut various functional components of mobile agents and their platforms so that they are addressed in a more structured way. This approach is therefore suitable not only for the development of new mobile agent systems, but also for security enhancement to legacy mobile agent systems. We adopt a multi-point security check, which visualizes the services of a host as individual components and access of each will require authentication. Due to the ready availability of the audit record of the agent, further damage can be prevented.", "num_citations": "3\n", "authors": ["358"]}
{"title": "Network slicing to improve multicasting in HPC clusters\n", "abstract": " In high performance computing (HPC) resources\u2019 extensive experiments are frequently executed. HPC resources (e.g. computing machines and switches) should be able to handle running several experiments in parallel. Typically HPC utilizes parallelization in programs, processing and data. The underlying network is seen as the only non-parallelized HPC component (i.e. no dynamic virtual slicing based on HPC jobs). In this scope we present an approach in this paper to utilize software defined networking (SDN) to parallelize HPC clusters among the different running experiments. We propose to accomplish this through two major components: A passive module (network mapper/remapper) to select for each experiment as soon as it starts the least busy resources in the network, and an SDN-HPC active load balancer to perform more complex and intelligent operations. Active load balancer can logically\u00a0\u2026", "num_citations": "2\n", "authors": ["358"]}
{"title": "Detecting Incorrect Uses of Combining Algorithms in XACML 3.0 Policies\n", "abstract": " With the increasing complexity of software, new access control methods have emerged to deal with attribute-based authorization. As a standard language for specifying attribute-based access control policies, XACML offers a number of rule and policy combining algorithms to meet different needs of policy composition. Due to their variety and complexity, however, it is not uncommon to apply combining algorithms incorrectly, which can lead to unauthorized access or denial of service. To solve this problem, this paper presents a fault-based testing approach for revealing incorrect combining algorithms in XACML 3.0 policies. The theoretical foundation of this approach relies on the formalization of semantic differences between rule combining algorithms and between policy combining algorithms. It allows the use of a constraint solver for generating queries to which a given policy produces different responses than its\u00a0\u2026", "num_citations": "2\n", "authors": ["358"]}
{"title": "Software security testing of an online banking system: a unique research experience for undergraduates and computer teachers\n", "abstract": " This paper presents a unique summer project for a group of undergraduate students and high school computer teachers to gain research experiences in the area of cybersecurity. The students and teachers were selected from the participants in the NSF REU and RET programs at the host institution. Through the research on security testing of a real-world online banking system, the students and teachers have not only learned about the cutting-edge security testing techniques, but also made publishable contributions to the research base. The two collaborating graduate assistants served as an immediate role model for the undergraduates and an indirect role model for high school students through the teachers. With the help from the graduate assistants, the students and teachers were able to work effectively toward achieving their research objectives. The internal competition helped the participants get a better\u00a0\u2026", "num_citations": "2\n", "authors": ["358"]}
{"title": "Secure system modeling: Integrating security attacks with statecharts\n", "abstract": " Software security is becoming an important concern as software applications are increasingly depending on the Internet, an untrustworthy computing environment. Vulnerabilities due to design errors, inconsistencies, incompleteness, and missing constraints in software design can be wrongly exploited by security attacks. Software functionality and security, however, are often handled separately in the development process. Software is designed with the mindset of its functionalities and cost, where the focus is mainly on the operational behavior. Security concerns, on the other hand, are often described in an imprecise way and open to subjective interpretations. This paper presents a threat driven approach that improves on the quality of software through the realization of a more secure model. The approach introduces systematic transformation rules and integration steps for integrating attack tree representations into statechart-based functional models. Through the focus on the behavior of an attack from the perspective of the system behavior, software engineers can clearly define and understand security concerns as software is designed. Security analysis and threat identification are then applied to the integrated model in order to identify and mitigate vulnerabilities at the design level.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Distributed control of self-organizing systems with petri nets.\n", "abstract": " In self-organizing systems there are primitive elements that interact and produce emergent global properties. We describe a distributed Petri net control architecture for interacting agents thatare capable of carrying out autonomous actions, yet collaborate with each other in structured ways. Control is fully decentralized among the agents. The approach was motivated by an application to mission planning for unmanned air vehicles (UAVs), but is applicable to more general agent-oriented systems.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Knowledge-based human-Agent teamwork for distributed training\n", "abstract": " This paper presents a knowledge-based approach to human-agent mixed teams for distributed team training in CAST-DDD. CAST-DDD is a marriage between the multi-agent architecture CAST and the command-and-control simulation tool DDD, where CAST agents can replace some or all members on a DDD team. We explore the MALLET language in CAST to capture DDD teamwork knowledge that involve both humans and agents. To allow for adjustable autonomy of human team members, we provide a repetitive choice construct for embedding non-deterministic operations in human-agent team processes. To offer a visible picture of teamwork status, team processes are visualized and tracked via an extended formalism of Predicate/Transition nets. In addition, we describe different communication and coordination methods for members of a human-agent mixed team as well as how agents reason about the dynamic, partially observable environment of the DDD simulation.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Design an Interoperable Mobile Agent System Based on Predicate Transition Net Models.\n", "abstract": " Mobile agents provide an effective and flexible style to develop advanced distributed systems. In order to promote interoperability and ensure the quality of mobile agent systems, it is necessary to formalize software architecture of mobile agent systems. In this paper, we not only define the software architecture of interoperable mobile agent systems using predicate transition nets, but also analyze the interoperability between agents. In addition, a formal model-driven design method to develop mobile agent systems is described with examples. Our method naturally integrates formal methods and practical approaches in the agent system design phase. The method can be used to develop other complex software systems as well.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Threat-Driven Architectural Design of Secure Information Systems.\n", "abstract": " To deal with software security issues in the early stages of system development, this paper presents a threat-driven approach to the architectural design and analysis of secure information systems. In this approach, we model security threats to systems with misuse cases and mitigation requirements with mitigation use cases at the requirements analysis phase. Then we drive system architecture design (including the identification of architectural components and their connections) by use cases, misuse cases, and mitigation use cases. According to the misuse case-based threat model, we analyze whether or not a candidate architecture is resistant to the identified security threats and what constraints must be imposed on the choices of system implementation. This provides a smooth transition from requirements specification to high-level design and greatly improves the traceability of security concerns in high\u00a0\u2026", "num_citations": "2\n", "authors": ["358"]}
{"title": "Research on inheritance of software agent\n", "abstract": " As a kind of restricted intelligent objects, agent is a natural way to research the inheritance feature of software agent and integrate inheritance mechanisms into AOP (agent-oriented programming). Based on BDI model of agents, the semantics of inheritance and cloning behavior of agents are addressed. The semantics of inheritance are discussed from two aspects: single inheritance and multiple inheritance. The dynamic cloning mechanisms of agent instances are formally classified into four types: function split, logic split, preference split and retrogress split. The principle of each cloning mechanism is presented and the examples are provided based on the electronic commerce systems.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Reasoning about inheritance and cloning behaviors of software agents\n", "abstract": " With agents being a kind of restricted intelligent object, it is a natural way to research the inheritance feature of software agents and integrate inheritance mechanisms into AOP. Based on BDI models of agents, the paper addresses the semantics of static inheritance and dynamic inheritance of agents. For static inheritance, the semantics are discussed from two perspectives: single inheritance and multiple inheritance. For dynamic inheritance, we identify and formally classify dynamic cloning behaviors of agent instances into four types: function split, logic split, preference split and retrogress split.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Reasoning about team tracking\n", "abstract": " One subject of much ongoing research is team tracking --- tracking a team's joint goals and intentions in dynamic, real-time domains. In this paper, a theory of team tracking and an architecture for team-oriented communication-based agents are presented. The problems faced in tracking ill-structured teams are also discussed.", "num_citations": "2\n", "authors": ["358"]}
{"title": "The Syntax and Semantics of Splaw-an Agent Specification and Programming Language\n", "abstract": " Slnce AOP was proposed by Shoham, the agent-oriented methodology has been studied from different aspects-However, whether and how much a new methodology can be accepted mainly depends on whether the language reflecting this new methodology can be used widely or not. For this purpose, it is very important to design a suitable programming language for agent. This paper descr1bes the syntax of an agent specification and programming language-SPLAW, provides operational semantics for each statement defined in SPLAW, and by means of labeled transition systeml presents the proof rules which can be used to prove the properties such as safety and liveness. SPLAW has at least the following advantages. First, it is based on KQML, the standard inter-agent communication language, which rnakes it possible for agents written in SPLAW to interoperate with other agents obeying KQML. Second, the feature of inheritance is first supported by an agent programming language, which facilitates the construction of multi-thread systems that take on some object-oriented features. Last but not least, instead of adopting built-in modalities in the programming language, SPLAW try to assign mental states such as belief, intention and desire for agents from external viewpoint, which may provide a feasible solution to unify the fields of theory research and practical system design.", "num_citations": "2\n", "authors": ["358"]}
{"title": "SELF-CONFIDENCE DEGREE OF AGENT'S BEHAVIORS AND ITS REVISION RULES [J]\n", "abstract": " In multi-agent systems, individual agents should also have social abili-ties in order to complete their own problem solving and to help others with their ac-tivities, as well as autonomy, responsiveness and proactiveness. Social ability re-quires that agents should respond timely to requests from other agents and committo their own actions. If an agent advertises a willingness to perform a service, thenit is obliged to perform this service when asked to do so. However, ability and in-tention don't mean confidence. An agent cannot be sure whether the services per-formed satisfy its clients or not. Especially when more than one agent has the samecapabilities to provide the services, all of them contest for the opportunity, whichowned by one, all the others lost. Knowing that when it fails, the client will neverget satisfying services which it should have, no matter whether this agent has e-nough confidence to per form successfully. So, action entrusting should be done ac-cording to certain rules or strategies. From social behaviors of agents, the conceptof self-confidence degree of agent's behaviors is introduced in this paper. Some mo-dification rules for self-confidence degree of behaviors which agents should meetin multi-agent systems are also characterized. Finally an action entrusting algo-rithm is designed, which provides a feasible and reasonable solution for the designof actual multi-agent systems.", "num_citations": "2\n", "authors": ["358"]}
{"title": "Enhancing Availability for Distributed Replicated Services Considering Network Edge Availability\n", "abstract": " Mechanism to improve data or service availability is critical for an enterprise to ensure the quality of service in terms of availability. Replication has been used to improve system availability. The number and location of the replicas are two impact factors on availability. In this paper, we will consider the impact of the node and network edge failures on the availability of replicated data or services. The Effective availability modeling approach is designed and efficient availability computing algorithms are developed to model and compute availability of replicated services for systems with the tree topology. The availability enhancement problem (maximizing the objective function) is transformed to a p-median problem (minimizing the objective function) through re-define the availability enhancement problem. An efficient replica allocation algorithm is developed to improve data availability in tree networks, with a runtime complexity of O (K| V| 2), where K is the number of replicas and| V| is the number of nodes in the tree network. Finally, experimental studies have been conducted to evaluate how efficient and effective the proposed availability computing algorithm and the availability enhancement algorithm on improving the availability of replicated data or services. The results show that the proposed solutions are efficient and effective on availability computing and availability enhancement.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Conformance Testing of Balana: An Open Source Implementation of the XACML3. 0 Standard.\n", "abstract": " Attribute-Based Access Control (ABAC) has gained increasing attention. Currently, Balana is the only open-source implementations of XACML 3.0, which is an OASIS standard for specifying ABAC. Considering that XACML is much more complex than traditional access control models, conformance testing of any XACML implementation is an important problem. Using a non-conformance implementation may lead to misunderstanding of access decisions or even security violations. This paper presents an approach to conformance testing of Balana, focusing on the main elements of the XACML3. 0 language, such as targets, rules, policies, and policy sets. In particular, we have thoroughly tested the key rule combining algorithms in policies and policy combining algorithms in policy sets. This has revealed several conformance issues.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Analysis of Healthcare Workflows in Accordance with Access Control Policies\n", "abstract": " Healthcare information systems deal with sensitive data across complex workflows. They often allow various stakeholders from different environments to access data across organizational boundaries. This elevates the risk of exposing sensitive healthcare information to unauthorized personnel, leading \u2018controlling access to resources'a major concern. To prevent unwanted access to sensitive information, healthcare organizations need to adopt effective workflows and access control mechanisms. Many healthcare organizations are not yet considering or do not know how to accommodate the \u2018context'element as a crucial element in their workflows and access control policies. The authors envision the future of healthcare where \u2018context'will be considered as a crucial element. They can accommodate context through a new element \u2018environment'in workflows, and can accommodate context in policies through well\u00a0\u2026", "num_citations": "1\n", "authors": ["358"]}
{"title": "An Approach for Analyzing Software Specifications in Petri Nets.\n", "abstract": " In this paper, we present an approach for analyzing software specifications in Predicate/Transitions (PrT) nets. The approach is designed as a two-phase process to ensure it is not only practical but also rigorous for analyzing formal software specifications in PrT nets. In the first phase, a PrT net model is analyzed using model based testing technique with tool MISTA. Then the important properties defined in temporal logic formulas for the PrT net model is further checked using model checking technique with tool NuSMV to ensure the correctness of the model. The errors found in the first phase and the counter examples generated in the second phase can help developers to find problems in the model. The analysis process is illustrated by analyzing an Alternating Bit Protocol (ABP), and problems found in one ABP model in PrT nets have demonstrated the effectiveness of the approach.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Reach Availability Modeling of Replicated Services\n", "abstract": " Availability is an important issue in distributed systems providing quality of services. Data or service availability modeling is very important to ensure such quality of services. Many factors, such as node availability and network link availability, could affect the data or service availability in a distributed system, and replication schemes have been widely used to improve data or service availability. In this paper, we consider node and network link failures, as well as the impact of multiple replicas on data availability. Efficient availability computing algorithms are developed to model data availability for a system with different topologies. Finally, experimental studies have been conducted to see how well our modeling approach is for the availability modeling of distributed environment with data replication.", "num_citations": "1\n", "authors": ["358"]}
{"title": "A Stochastic Model for Optimizing the Patching Time of Software Bugs.\n", "abstract": " New bugs and vulnerabilities are discovered and reported from time to time even after software products are released. One of the common ways to handle these bugs is to patch the software. In this paper, the authors propose a stochastic model for optimizing the patching time for software bugs and vulnerabilities. The optimal patching time can be computed in the patching script development and operational costs in fix. The authors present two case studies using the Nimda worm vulnerability in Microsoft Internet Information Services web server and the bug report of the Debian project. These studies indicate that the patch applications are later than their optimal fix time.", "num_citations": "1\n", "authors": ["358"]}
{"title": "A Comparative Study of Access Control Languages\n", "abstract": " In this paper, we compare three open source access control languages, XACML, JAAS and Java ACL. In addition to a conceptual analysis, we use a Web-based health care system as a common application, in which controlled access is implemented through each of the languages. We compare the languages using standard software metrics, such as reusability, policy expressiveness, extensibility, error handling, and programmatic control. The results of the comparative study indicate a high degree of variance in the three languages. They can serve as a useful guide for software developers to select an access control language that best meets their requirements.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Automated evaluation of runtime object states against model-level states for state-based test execution\n", "abstract": " Evaluation of runtime object states against the model-level states defined in a state model is critical to state based test automation. This paper presents a state mapping framework to support the automated state-based test execution process. The framework automatically keeps track of runtime object states and maps these states to model-level abstract states. It also includes a comparator to determine whether or not a test is successful. This framework is implemented in the aspect-oriented programming language AspectJ. Therefore, the runtime instrumentation mechanism for state evaluation does not modify the source code under test (either in Java or AspectJ). This is an important advantage because otherwise all the changes made to the code for testing purposes have to be cancelled after testing. We have conducted several experiments to evaluate the framework by calculating and comparing the total consumed\u00a0\u2026", "num_citations": "1\n", "authors": ["358"]}
{"title": "Testing for Software Safety\n", "abstract": " Objective\u2022 This research focuses on testing whether or not the hazardous conditions identified by design-level fault tree analysis will occur in the target implementation.", "num_citations": "1\n", "authors": ["358"]}
{"title": "A Petri net simulator for self-organizing systems\n", "abstract": " Self-organizing systems have the general property that the primitive elements that comprise the system interact in order to achieve emergent global properties. We describe an extended Petri net simulation architecture for such systems that is based on interacting agents that carry out autonomous actions, yet collaborate with each other in structured ways. There is no central controlling entity. The approach was motivated by an application to mission planning for unmanned air vehicles (UAVs), but is applicable to more general agent-oriented systems.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Misuse Case-based Analysis of Secure Software Arc hitecture\n", "abstract": " This paper presents an approach to the architectural analysis of secure software systems based on the system requirements elicited in the form of use and misuse cases. We identify architectural components and their connections and analyze whether or not a candidate architecture can address security concerns. This provides an effective way for the smooth transition from requirements specification to high-level design for engineering secure software systems, and greatly improves the traceability of security concerns, which allows a system developer to know what requirement an architectural component references back to. We demonstrate our approach through the case study on a security-intensive hospital information system.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Development of a distributed multi-player computer game for scientific experimentation of team training protocols\n", "abstract": " To support research on using intelligent agents in team training, a distributed multi\u2010player game in Java that executes in real time was developed. Basing development on the game Space Fortress, which has been widely used by cognitive psychologists for studying training protocols, typical experiments involved in excess of 100 trials of the game under different training conditions.  Describes the design of this game to achieve these features and real\u2010time performance in the Java environment.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Model Checking Logical Agent Mobility\n", "abstract": " The paper presents an approach to model-checking mobile agent systems specified by LAM, which is a two-layer formal method for characterizing logical agent mobility using Predicate/Transition (PrT) nets. Based on the transformation of PrT nets into input programs of the model checker Spin, we model check a variety of properties with respect to agents, logical agent mobility, agent environments, and system interaction in a mobile agent system model. We demonstrate our approach through a case study on modeling and checking of a mobile agent\u2013based clinic information system.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Toward scalable and proactive multi-agent teams\n", "abstract": " Teamwork becomes very important in many dynamic, multi-agent environments. A multi-agent team can scale up in at least two ways: the size of the team and the complexity of the problem. In this paper, we tackle these issues through proactive information exchange to improve team effectiveness and communication efficiency, and through dynamic task assignment to improve the flexibility of team formation. We also propose a three-tier communication infrastructure to support efficient and flexible communication among team members. We have done some experiments to demonstrate the advantage of proactive information and dynamic task assignment over teamwork.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Towards a declarative semantics of inheritance with exceptions\n", "abstract": " This paper presents a declarative semantics of compositional inheritance in an object-oriented logic programming framework with explicit exceptions, based on the iterated least fixpoint semantics to normal logic programs. Taking logic objects with exceptions as a kind of non-monotonic theory, the non-monotonicity of inheritance is achieved, which is of importance for modeling incomplete knowledge and requirement specifications in both artificial intelligence and software engineering.", "num_citations": "1\n", "authors": ["358"]}
{"title": "ON OBJECT-ORIENTED LOGIC PROGRAMMING [J]\n", "abstract": " This paper describes the basic principles of object-oriented logic programming based on the comparison of object-oriented programming and logic programming. The achievements, problems and applications in recent researches are also discussed.", "num_citations": "1\n", "authors": ["358"]}
{"title": "Logical object as a basis of knowledge based systems\n", "abstract": " This paper presents a framework called logical knowledge object (LKO), which is taken as a basis of the dependable development of knowledge based systems(KBSs). LKO combines logic programming and object-oriented programming paradigms, where objects are viewed as abstractions with states, constraints, behaviors and inheritance. The operational semantics defined in the style of natural semantics is simple and clear. A hybrid knowledge representation amalgamating rule, frame, semantic network and blackboard is available for both most structured and flat knowledge. The management of knowledge bases has been formally specified. Accordingly, LKO is well suited for the formal representation of knowledge and requirements of KBSs. Based on the framework, verification techniques are also explored to enhance the analysis of requirement specifications and the validation of KBSs. In addition\u00a0\u2026", "num_citations": "1\n", "authors": ["358"]}