{"title": "Actors: A model of concurrent computation in distributed systems.\n", "abstract": " A foundational model of concurrency is developed in this thesis. It examines issues in the design of parallel systems and show why the actor model is suitable for exploiting large-scale parallelism. Concurrency in actors is constrained only by the availability of hardware resources and by the logical dependence inherent in the computation. Unlike dataflow and functional programming, however, actors are dynamically reconfigurable and can model shared resources with changing local state. Concurrency is spawned in actors using asynchronous message-passing, pipelining, and the dynamic creation of actors. The author defines an abstract actor machine and provide a minimal programming language for it. A more expressive language, which includes higher level constructs such as delayed and eager evaluation, can be defined in terms of the primitives. Examples are given to illustrate the ease with which concurrent data and control structures can be programmed. This thesis deals with some central issues in distributed computing. Specifically, problems of divergence and deadlock are addressed. Additional keywords Object oriented programming Semantics.Descriptors:", "num_citations": "4471\n", "authors": ["1581"]}
{"title": "A foundation for actor computation\n", "abstract": " We present an actor language which is an extension of a simple functional language, and provide an operational semantics for this extension. Actor configurations represent open distributed systems, by which we mean that the specification of an actor system explicitly takes into account the interface with external components. We study the composability of such systems. We define and study various notions of testing equivalence on actor expressions and configurations. The model we develop provides fairness. An important result is that the three forms of equivalence, namely, convex, must, and may equivalences, collapse to two in the presence of fairness. We further develop methods for proving laws of equivalence and provide example proofs to illustrate our methodology.", "num_citations": "683\n", "authors": ["1581"]}
{"title": "Concurrent object-oriented programming\n", "abstract": " Three significant trends have underscored the central role of concurrency in computing. First, there is increased use of interacting processes by individual users, for example, application programs running on X windows. Second, workstation networks have become a cost-effective mechanism for resource sharing and distributed problem solving. For example, loosely coupled problems, such as finding all the factors of large prime numbers, have been solved by utilizing ideal cycles on networks of hundreds of workstations. A loosely coupled problem is one which can be easily partitioned into many smaller subproblems so that interactions between the subproblems is quite limited. Finally, multiprocessor technology has advanced to the point of providing supercomputing power at a fraction of the traditional cost.At the same time, software engineering considerations such as the need for data abstraction to promote\u00a0\u2026", "num_citations": "524\n", "authors": ["1581"]}
{"title": "Structural health monitoring of a cable-stayed bridge using smart sensor technology: deployment and evaluation\n", "abstract": " Structural health monitoring (SHM) of civil infrastructure using wireless smart sensor networks (WSSNs) has received significant public attention in recent years. The benefits of WSSNs are that they are low-cost, easy to install, and provide effective data management via on-board computation. This paper reports on the deployment and evaluation of a state-of-the-art WSSN on the new Jindo Bridge, a cable-stayed bridge in South Korea with a 344-m main span and two 70-m side spans. The central components of the WSSN deployment are the Imote2 smart sensor platforms, a custom-designed multimetric sensor boards, base stations, and software provided by the Illinois Structural Health Monitoring Project (ISHMP) Services Toolsuite. In total, 70 sensor nodes and two base stations have been deployed to monitor the bridge using an autonomous SHM application with excessive wind and vibration triggering the system to initiate monitoring. Additionally, the performance of the system is evaluated in terms of hardware durability, software stability, power consumption and energy harvesting capabilities. The Jindo Bridge SHM system constitutes the largest deployment of wireless smart sensors for civil infrastructure monitoring to date. This deployment demonstrates the strong potential of WSSNs for monitoring of large scale civil infrastructure.", "num_citations": "492\n", "authors": ["1581"]}
{"title": "Apparatus and method for synchronizing execution of programs in a distributed real-time computing system\n", "abstract": " A distributed computing system including a plurality of computers, wherein the execution of programs by the computers to perform real-time tasks are synchronized with each other. Each of the computers includes a local clock which is synchronized with the local clocks of the other computers and a start time determining apparatus for determining execution time of a program to be executed by the computer. The program to be executed by the computer is executed in synchronism with programs in the other computers under timing constraints. The execution time is determined by the start time determining apparatus by negotiating with the start time determining apparatus of the other computers. Each of the computers further includes scheduling apparatus for scheduling the execution of the program to be executed by the computer based on the execution time negotiated by the start time determining apparatus, and a\u00a0\u2026", "num_citations": "286\n", "authors": ["1581"]}
{"title": "Flexible smart sensor framework for autonomous structural health monitoring\n", "abstract": " Wireless smart sensors enable new approaches to improve structural health monitoring (SHM) practices through the use of distributed data processing. Such an approach is scalable to the large number of sensor nodes required for high-fidelity modal analysis and damage detection. While much of the technology associated with smart sensors has been available for nearly a decade, there have been limited numbers of fulls-cale implementations due to the lack of critical hardware and software elements. This research develops a flexible wireless smart sensor framework for full-scale, autonomous SHM that integrates the necessary software and hardware while addressing key implementation requirements. The Imote2 smart sensor platform is employed, providing the computation and communication resources that support demanding sensor network applications such as SHM of civil infrastructure. A multi-metric Imote2 sensor board with onboard signal processing specifically designed for SHM applications has been designed and validated. The framework software is based on a service-oriented architecture that is modular, reusable and extensible, thus allowing engineers to more readily realize the potential of smart sensor technology. Flexible network management software combines a sleep/wake cycle for enhanced power efficiency with threshold detection for triggering network wide operations such as synchronized sensing or decentralized modal analysis. The framework developed in this research has been validated on a full-scale a cable-stayed bridge in South Korea.", "num_citations": "259\n", "authors": ["1581"]}
{"title": "SENS: A sensor, environment and network simulator\n", "abstract": " Recent advances in microelectromechanical systems and VLSI lithography have enabled the miniaturization of sensors and controllers. Such minitiarization facilitates the deployment of large-scale wireless sensor networks (WSNs). However, the considerable cost of deploying and maintaining large-scale WSNs for experimental purposes makes simulation useful in developing dependable and portable WSN applications. SENS is a customizable sensor network simulator for WSN applications, consisting of interchangeable and extensible components for applications, network communication, and the physical environment. Multiple component implementations in SENS offer varying degrees of realism. Users can assemble application-specific environments; such environments are modeled in SENS by their different signal propagation characteristics. The same source code that is executed on simulated sensor nodes\u00a0\u2026", "num_citations": "259\n", "authors": ["1581"]}
{"title": "Concurrent programming using actors\n", "abstract": " \u9069\u5fdc\u5316\u30b3\u30f3\u30dd\u30b8\u30b7\u30e7\u30f3-\u958b\u653e\u578b\u30b7\u30b9\u30c6\u30e0\u306b\u304a\u3051\u308b\u30b3\u30f3\u30dd\u30b8\u30b7\u30e7\u30f3\u306b\u57fa\u3065\u3044\u305f\u65b0\u3057\u3044\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u69cb\u7bc9\u624b\u6cd5", "num_citations": "257\n", "authors": ["1581"]}
{"title": "Cooperative tracking with binary-detection sensor networks\n", "abstract": " We present a novel method for tracking the movement of people or vehicles in open outdoor environments using sensor networks. Unlike other sensor network-based methods, which depend on determining distance to the target or the angle of arrival of the signal, our cooperative tracking approach requires only that a sensor be able to determine if an object is somewhere within the maximum detection range of the sensor. We propose cooperative tracking as a method for tracking moving objects and extrapolating their paths in the short term. By combining data from neighboring sensors, this approach enables tracking with a resolution higher than that of the individual sensors being used. We employ statistical estimation and approximation techniques to further increase the tracking precision, and to enable the system to exploit the tradeoff between accuracy and timeliness of the results. We analyze the behavior of\u00a0\u2026", "num_citations": "225\n", "authors": ["1581"]}
{"title": "Actor frameworks for the JVM platform: a comparative analysis\n", "abstract": " The problem of programming scalable multicore processors has renewed interest in message-passing languages and frameworks. Such languages and frameworks are typically actor-oriented, implementing some variant of the standard Actor semantics. This paper analyzes some of the more significant efforts to build actor-oriented frameworks for the JVM platform. It compares the frameworks in terms of their execution semantics, the communication and synchronization abstractions provided, and the representations used in the implementations. It analyzes the performance of actor-oriented frameworks to determine the costs of supporting different actor properties on JVM. The analysis suggests that with suitable optimizations, standard Actor semantics and some useful communication and synchronization abstractions may be supported with reasonable efficiency on the JVM platform.", "num_citations": "220\n", "authors": ["1581"]}
{"title": "Research directions in concurrent object-oriented programming\n", "abstract": " This collection of original research provides a comprehensive survey of developments at the leading edge of concurrent object-oriented programming. It documents progress\u2014from general concepts to specific descriptions\u2014in programming language design, semantic tools, systems, architectures, and applications. Chapters are written at a tutorial level and are accessible to a wide audience, including researchers, programmers, and technical managers.", "num_citations": "192\n", "authors": ["1581"]}
{"title": "An overview of actor languages\n", "abstract": " Actors are computational agents which carry out their actions in response to incoming communications. As in other object-oriented languages, actors encapsulate procedural and declarative information into a single entity. Primitive actor languages are based on a pure message-passing semantics. Higher-level actor languages incorporate the use of inheritance for conceptual organization and delegation for structuring the sharing of code between different actors. This paper provides an overview of the actor model and discusses some advantages of actor languages in exploiting large-scale concurrent architectures. The kernel of an actor language is presented and some of the higher-level control constructs are discussed.", "num_citations": "189\n", "authors": ["1581"]}
{"title": "A language framework for multi-object coordination\n", "abstract": " We have developed language support for the expression of multi-object coordination. In our language, coordination patterns can be specified abstractly, independent of the protocols needed to implement them. Coordination patterns are expressed in the form of constraints that restrict invocation of a group of objects. Constraints are defined in terms of the interface of the objects being invoked rather than their internal representation. Invocation constraints enforce properties, such as temporal ordering and atomicity, that hold when invoking objects in a group. A constraint can permanently control access to a group of objects, thereby expressing an inherent access restriction associated with the group. Furthermore, a constraint can temporarily enforce access restrictions during the activity of individual clients. In that way, constraints can express specialized access schemes required by a group of clients.", "num_citations": "176\n", "authors": ["1581"]}
{"title": "A survey of statistical model checking\n", "abstract": " Interactive, distributed, and embedded systems often behave stochastically, for example, when inputs, message delays, or failures conform to a probability distribution. However, reasoning analytically about the behavior of complex stochastic systems is generally infeasible. While simulations of systems are commonly used in engineering practice, they have not traditionally been used to reason about formal specifications. Statistical model checking (SMC) addresses this weakness by using a simulation-based approach to reason about precise properties specified in a stochastic temporal logic. A specification for a communication system may state that within some time bound, the probability that the number of messages in a queue will be greater than 5 must be less than 0.01. Using SMC, executions of a stochastic system are first sampled, after which statistical techniques are applied to determine whether such a\u00a0\u2026", "num_citations": "171\n", "authors": ["1581"]}
{"title": "ActorSpace: an open distributed programming paradigm\n", "abstract": " We present a new programming paradigm called ActorSpace. ActorSpace provides a new communication model based on destination patterns. An actorSpace is a computationally passive container of actors which acts as a context for matching patterns. Patterns are matched against listed attributes of actors and actorSpaces that are visible in the actorSpace. Both visibility and attributes are dynamic. Messages may be sent to one or all members of a group defined by a pattern. The paradigm provides powerful support for component-based construction of massively parallel and distributed applications. In particular, it supports open interfaces to servers and pattern-directed access to software repositories.", "num_citations": "169\n", "authors": ["1581"]}
{"title": "Abstraction and modularity mechanisms for concurrent computing\n", "abstract": " The Actor model programming language concept, which provides basic building blocks for a wide variety of computational structures, is reviewed. The Actor model unifies objects and concurrency. Actors are autonomous, distributed, concurrently executing objects that can send each other messages asynchronously. The Actor model's communication abstractions and object-oriented design are discussed. Three mechanisms for developing modular and reusable components for concurrent systems are also discussed. The mechanism are synchronizers, modular specifications of resource management policies, and protocol customization of dependability.< >", "num_citations": "167\n", "authors": ["1581"]}
{"title": "Actors: A conceptual foundation for concurrent object-oriented programming\n", "abstract": " Agha and Hewitt give an overview of the actor model of computation and show how it leads to an object-oriented programming style that can exploit the large-scale concurrency of modern architectures. Actors are autonomous computational agents whose actions are coordinated by message communication. The control structures of an actor language are defined as patterns of message passing. Since only message communication determines the causal connection and, hence, the execution ordering of actions, actor programs execute with maximal concurrency of causally independent actions. However, concurrency in program execution is not visible at the programming level. Actor languages thus provide the conceptual simplicity of object-oriented programming along with fine-grain concurrency in program execution. For high-level object-oriented programming, actors provide strong encapsulation of procedural\u00a0\u2026", "num_citations": "161\n", "authors": ["1581"]}
{"title": "Resilient localization for sensor networks in outdoor environments\n", "abstract": " The process of determining the physical locations of nodes in a wireless sensor network is known as localization. Self-localization is critical for large-scale sensor networks, because manual or assisted localization is often impractical due to time requirements, economic constraints, or inherent limitations of the deployment scenarios. We propose scalable solutions for reliably localizing wireless sensor networks in environments conducive to several types of ranging errors. We follow a hybrid hardware-software approach for acoustic ranging or radio interferometry to acquire internode distance measurements, and a resilient self-localization algorithm to compute the node location estimates. The acoustic ranging method improves on previous work, extending the practical measurement range up to 35 m in grassy outdoor environments, achieving a distance-invariant median measurement error of about 1% (33 cm). The\u00a0\u2026", "num_citations": "160\n", "authors": ["1581"]}
{"title": "Towards a theory of actor computation\n", "abstract": " In this paper we present preliminary results of a rigorous development of the actor model of computation. We present an actor language which is an extension of a simple functional language, and provide a precise operational semantics for this extension. Our actor systems are open distributed systems, meaning we explicitly take into account the interface with external components in the specification of an actor system. We define and study various notions of equivalence on actor expressions and systems. We show that the usual tripartite family of testing equivalence relations collapses to two in the presence of fairness. We define a notion of operational bisimulation as a tool for establishing equivalence under fairness assumptions, and illustrate its use.", "num_citations": "150\n", "authors": ["1581"]}
{"title": "High-frequency distributed sensing for structure monitoring\n", "abstract": " Structural health monitoring (SHM) involves continuous monitoring of a structure\u2019s condition with near real-time analysis of sensed data. The emerging wireless sensor network (WSN) technology enables distributed data acquisition and processing for structure monitoring applications, which currently adopt a centralized solution, using a network of intelligent sensors. We design a robust WSN-based distributed sensing system for high-frequency data acquisition in structure monitoring. The system emulates the functionality of a centralized sensing system employing analog sensors, achieving comparable performance. The resulting compatibility with existing centralized SHM algorithms will facilitate the adoption of sensor network technology for structure monitoring. The networking and sensing services comprising the system also enable in situ data processing in WSNs, providing a seamless transition from centralized to fully distributed structural health monitoring applications.", "num_citations": "147\n", "authors": ["1581"]}
{"title": "A linguistic framework for dynamic composition of dependability protocols\n", "abstract": " We present a language framework for describing dependable systems which emphasizes modularity and composition. Dependability and functionality aspects of an application may be described separately providing a separation of design concerns. Futhermore, the dependability protocols of an application may be constructed bottom-up as simple protocols that are composed into more complex protocols. Composition makes it easier to reason about dependability and supports the construction of general reusable dependability schemes. A significant aspect of our language framework is that dependability protocols may be loaded into a running application and installed dynamically. Dynamic installation makes it possible to impose additional dependability protocols on a server as clients with new dependability demands are integrated into a system. Similarly, if a given dependability protocol is only\u00a0\u2026", "num_citations": "139\n", "authors": ["1581"]}
{"title": "Design and implementation of a mobile actor platform for wireless sensor networks\n", "abstract": " Wireless sensor networks (WSNs) promise the ability to monitor physical environments and to facilitate control of cyber-physical systems. Because sensors networks can generate large amounts of data, and wireless bandwidth is both limited and energy hungry, local processing becomes necessary to minimize communication. However, for reasons of energy efficiency and production costs, embedded nodes have relatively slow processors and small memories. This makes programming sensor networks harder and requires new tools for distributed computing. We have developed ActorNet, an implementation of the Actor model of computing for sensor networks which facilitates programming by treating a sensor network as an open distributed computing platform. ActorNet provides a high-level actor programming language: users can write dynamic applications for a single cross-platform runtime environment\u00a0\u2026", "num_citations": "129\n", "authors": ["1581"]}
{"title": "Abstracting interaction patterns: A programming paradigm for open distributed systems\n", "abstract": " This paper discusses mechanisms addressing the complexity of building and maintaining Open Distributed Systems. It is argued that a new programming paradigm based on modular specification of interaction patterns is required to address the complexity of such systems. Our research is based on developing abstraction mechanisms to simplify the task of developing and maintaining open systems. We define actors as a model of concurrency for open systems. We then review a number of programming abstractions that are useful in modular specification and implementation of open systems. Such abstractions include activators, protocols, synchronizers, and actorspaces. We observe that defining such abstractions for complex interaction patterns requires a sort of system decomposition that is not supported by standard execution models of concurrent programming, including actors and process algebras\u00a0\u2026", "num_citations": "122\n", "authors": ["1581"]}
{"title": "Concurrent programming using actors: Exploiting large-scale parallelism\n", "abstract": " We argue that the ability to model shared objects with changing local states, dynamic reconfigurability, and inherent parallelism are desirable properties of any model of concurrency. The actor model addresses these issues in a uniform framework. This paper briefly describes the concurrent programming language ActS and the principles that have guided its development. ActS advances the state of the art in programming languages by combining the advantages of object-oriented programming with those of functional programming. We also discuss considerations relevant to large-scale parallelism in the context of open systems, and define an abstract model which establishes the equivalence of systems defined by actor programs.", "num_citations": "115\n", "authors": ["1581"]}
{"title": "RTsynchronizer: language support for real-time specifications in distributed systems\n", "abstract": " We argue that the specification of an object's functional behavior and the timing constraints imposed on it may be separated. Specifically, we describe RTsynchronizer, a high-level programming language construct for specifying real-time constraints between objects in a distributed concurrent system. During program execution, RTsynchronizers affect the scheduling of distributed objects to enforce real-time relations between events. Objects in our system are defined in terms of the actor model extended with timing assumptions. Separation of the functional behaviors of actors and the timing constraints on patterns of actor invocation provides at least three important advantages. First, it simplifies code development by separating design concerns. Second, multiple timing constraints can be independently specified and composed. And finally, a specification of timing constraints can be reused even if the representation of\u00a0\u2026", "num_citations": "109\n", "authors": ["1581"]}
{"title": "The structure and semantics of actor languages\n", "abstract": " The actor model is developed as a foundation for concurrent object-oriented programming. The model provides for non-interference of state changes with multiple threads, inherent concurrency, reconfigurability, encapsulation of namespace, and weak fairness. The paper provides a survey of work in actor languages and can be divided into two areas: namely, formal aspects of the actor model and the structure of actor languages. We provide an abstract view of actor computations in terms of event diagrams and the laws of concurrent computing. The event diagrams can be given a semantics in terms of power domains. We then define the necessary constructs in a minimal actor language. This provides the building blocks for constructing a rich variety of concurrent computing structures. The second part of the paper shows how these higher level structures are built in terms of the actor primitives. In particular\u00a0\u2026", "num_citations": "97\n", "authors": ["1581"]}
{"title": "Middleware\n", "abstract": " Simplifying the development and maintenance of complex distributed software. coordination mechanisms used to implement the policy. In particular, the protocols required for interactions need not be hard-coded in application code. This allows objects and protocols to be independently developed and later composed into runnable systems. For example, atomicity among a collection of objects may initially be implemented using a twophase commit. If architectural constraints later change, for example requiring stricter reliability properties, modular design allows us to replace a two-phase commit with a three-phase commit without modifying client code. Orthogonal design constraints may also force components to adhere to multiple policies. A framework for protocol composition preserves the modularity of such policies so that their implementations may be safely composed. For example, an existing encryption protocol may be safely composed with an existing primary backup protocol in order to satisfy both secrecy and fault-tolerance policies. To illustrate our approach, we describe the Distributed Interaction Language (DIL). A DIL protocol is a linguistic abstraction that encapsulates protocol behavior: each protocol describes a customized response to events within the system. Distributed interaction policies are implemented by customizing system events defining component interactions (such as the sending and receiving of messages). DIL protocols dynamically modify system behavior: for example, in response to communication events, a protocol may add or remove messages, record or replace state, or halt the execution of a component. Events\u00a0\u2026", "num_citations": "96\n", "authors": ["1581"]}
{"title": "Open heterogeneous computing in ActorSpace\n", "abstract": " A number of efforts in heterogeneous computing involve the development of basic architecture independent communication primitives. We present a new programming paradigm, called ActorSpace, which provides a new communication model based on destination patterns. An actorspace is a computationally passive container of actors which acts as a context for matching patterns. Patterns are matched against listed attributes of actors and actorspaces that are visible in the actorspace. Both visibility and attributes are dynamic. Messages may be sent to one or all members of a group defined by a pattern. The paradigm provides powerful support for component-based construction of heterogeneous scalable distributed applications. In particular, it supports open interfaces to servers and pattern-directed access to software repositories.", "num_citations": "92\n", "authors": ["1581"]}
{"title": "HAL: A high-level actor language and its distributed implementation\n", "abstract": " We describe Hal, a high-level, actor-based language which has served as a test-bed for experimenting with powerful linguistic constructs for parallel and distributed programming. Hal is an architecture independent, concurrent object-oriented language which supports inheritance, synchronization constraints, continuation capture, synchronous and asynchronous message passing, and reflection. The Hal compiler has been used to execute actor programs on a number of shared and distributed memory machines. Hal allows powerful abstractions to be defined and reused. Furthermore, Hal supports the use of synchronization constraints at a fine-grained level and the use of software pipelining. In this paper, we describe the design of Hal, using specific examples to illustrate its features. We then discuss some of the implementation issues in the run-time system.", "num_citations": "90\n", "authors": ["1581"]}
{"title": "A modular approach to programming distributed real-time systems\n", "abstract": " Conventional real-time programs associate real-time requirements with individual commands in a program. This approach has three weaknesses. First, it intermixes two different design concerns: functional correctness and temporal correctness. Second, by mixing real-time requirements with program statements it makes it harder, and in some cases infeasible, to specify constraints between objects. Third, it limits the ability to independently modify either the timing constraints or the representations of objects. We describe a new approach that separates real-time constraints from functional aspects of an application; real-time constraints are described by synchronization code between the interfaces of objects. Objects in our system are defined using a real-time variant of the Actor model. We define a high-level programming language construct calledRTsynchronizer, which specifies a collection of temporal constraints\u00a0\u2026", "num_citations": "87\n", "authors": ["1581"]}
{"title": "Enabling framework for structural health monitoring using smart sensors\n", "abstract": " Structural health monitoring (SHM) is an important tool for the ongoing maintenance of aging infrastructure. The ultimate goals of implementing an SHM system are to improve infrastructure maintenance, increase public safety, and minimize the economic impact of an extreme loading event by streamlining repair and retrofit measures. Networks of wireless smart sensors offer tremendous promise for accurate and continuous structural monitoring using a dense array of inexpensive sensors; however, hurdles still remain. Although smart sensors have been commercially available for nearly a decade, full\u2010scale implementation for civil infrastructure has been lacking, with the exception of a few short\u2010term demonstration projects. This slow progress is due in part to the fact that programming smart sensors is extremely complex, putting the use of these devices for all but the simplest tasks out of the reach of most engineers\u00a0\u2026", "num_citations": "80\n", "authors": ["1581"]}
{"title": "ARA: A robust audit to prevent free-riding in P2P networks\n", "abstract": " A number of solutions have been proposed to address the free-riding problem in peer-to-peer file sharing systems. The solutions are either imperfect-they allow some users to cheat the system with malicious behavior, or expensive-they require human intervention, require servers, or incur high mental transaction costs. The authors proposed a method to address these weaknesses. Specifically, a utility function was introduced to capture contributions made by a user and an auditing scheme to ensure the integrity of a utility function's values. The method enabled to reduce cheating by a malicious peer: it is shown that this approach can efficiently detect malicious peers with a probability over 98%.", "num_citations": "78\n", "authors": ["1581"]}
{"title": "Modular specification of interaction policies in distributed computing\n", "abstract": " Software executing on distributed systems consists of many asynchronous, autonomous components which interact in order to coordinate local activity. The need for such coordination, as well as requirements such as heterogeneity, scalability, security and availability, considerably increase the complexity of code in distributed applications. Moreover, changing requirements, as well as changes in hardware platforms, lead to software that is constantly evolving and complicates reuse. To support development and evolution of distributed applications requires techniques which allow coordination code to be specified, customized, and maintained independently of application components; goals which cannot be realized solely through object-oriented techniques.", "num_citations": "77\n", "authors": ["1581"]}
{"title": "Reliable multi-hop communication for structural health monitoring\n", "abstract": " Wireless smart sensor networks (WSSNs) have been proposed by a number of researchers to evaluate the current condition of civil infrastructure, offering improved understanding of dynamic response through dense instrumentation. As focus moves from laboratory testing to full-scale implementation, the need for multi-hop communication to address issues associated with the large size of civil infrastructure and their limited radio power has become apparent. Multi-hop communication protocols allow sensors to cooperate to reliably deliver data between nodes outside of direct communication range. However, application specific requirements, such as high sampling rates, vast amounts of data to be collected, precise internodal synchronization, and reliable communication, are quite challenging to achieve with generic multi-hop communication protocols. This paper proposes two complementary reliable multi-hop communication solutions for monitoring of civil infrastructure. In the first approach, termed herein General Purpose Multi-hop (GPMH), the wide variety of communication patterns involved in structural health monitoring, particularly in decentralized implementations, are acknowledged to develop a flexible and adaptable any-to-any communication protocol. In the second approach, termed herein Single-Sink Multi-hop (SSMH), an efficient many-to-one protocol utilizing all available RF channels is designed to minimize the time required to collect the large amounts of data generated by dense arrays of sensor nodes. Both protocols adopt the Ad-hoc On-demand Distance Vector (AODV) routing protocol, which provides any-to-any routing and\u00a0\u2026", "num_citations": "76\n", "authors": ["1581"]}
{"title": "Recent advances in wireless smart sensors for multi-scale monitoring and control of civil infrastructure\n", "abstract": " While much of the technology associated with wireless smart sensors (WSS) has been available for over a decade, only a limited number of full-scale implementations have been realized for civil infrastructure, primarily due to the lack of critical hardware and software elements. Using the Imote2, a flexible WSS framework has been developed for full-scale, autonomous structural health monitoring (SHM) that integrates the necessary software and hardware elements, while addressing key implementation requirements for civil infrastructure. This paper discusses the recent advances in the development of this WSS framework and extensions to structural control. Their successful implementations at full-scale for SHM of the 2nd Jindo Bridge in South Korea and the Government Bridge at the Rock Island Arsenal in Illinois, USA, as well as for wireless control of a lab-scale structure are presented.", "num_citations": "75\n", "authors": ["1581"]}
{"title": "Efficient support of location transparency in concurrent object-oriented programming languages\n", "abstract": " We describe the design of a runtime system for a fine-grained concurrent object-oriented (actor) language and its performance. The runtime system provides considerable flexibility to users; specifically, it supports location transparency, actor creation and dynamic placement, and migration. The runtime system includes an efficient distributed name server, a latency hiding scheme for remote actor creation, and a compiler-controlled intra-node scheduling mechanism for local messages and dynamic load balancing. Our preliminary evaluation results suggest that the efficiency that is lost by the greater flexibility of actors can be restored by an efficient runtime system which provides an open interface that can be used by a compiler to allow optimizations. On several standard algorithms, the performance results for our system are comparable to efficient C implementations.", "num_citations": "75\n", "authors": ["1581"]}
{"title": "Wireless strain sensor development for civil infrastructure\n", "abstract": " Industrialized nations have made huge investments in civil infrastructure and attention must be given to its proper maintenance. Structural Health Monitoring (SHM) and Damage Detection (DD) strategies have been developed by many researchers in support of efficient operation and maintenance of civil infrastructure. Smart wireless sensor networks are promising in that they have the potential to dramatically improve SHM/DD. The Berkeley Mote smart sensor, with its embedded microprocessor and wireless communication capability, has emerged as an important new open hardware/software platform for SHM/DD. However, available sensors are limited and not necessarily optimized for civil infrastructure applications. Strain is one of the important physical quantities used to judge the health of a structure; strain sensors are currently unavailable for the Berkeley Mote platform. In this paper, a new strain sensor board for the Berkeley Mote platform is developed, and its performance is experimentally verified.", "num_citations": "74\n", "authors": ["1581"]}
{"title": "A protocol description language for customizing failure semantics\n", "abstract": " To optimize performance in a fault-tolerant distributed system, it is often necessary to enforce different failure semantics for different components. By choosing a custom set of failure semantics for each component and then by enforcing the semantics with a minimal set of protocols for a particular architecture, performance may be maximized while ensuring the desired system behavior. We have developed DIL, a language for specifying, on a per-component basis, protocols that transparently enforce failure semantics. These protocols may be reused with arbitrary components, allowing the development of a library of protocols.< >", "num_citations": "72\n", "authors": ["1581"]}
{"title": "Towards optimizing energy costs of algorithms for shared memory architectures\n", "abstract": " Energy consumption by computer systems has emerged as an important concern. However, the energy consumed in executing an algorithm cannot be inferred from its performance alone: it must be modeled explicitly. This paper analyzes energy consumption of parallel algorithms executed on shared memory multicore processors. Specifically, we develop a methodology to evaluate how energy consumption of a given parallel algorithm changes as the number of cores and their frequency is varied. We use this analysis to establish the optimal number of cores to minimize the energy consumed by the execution of a parallel algorithm for a specific problem size while satisfying a given performance requirement. We study the sensitivity of our analysis to changes in parameters such as the ratio of the power consumed by a computation step versus the power consumed in accessing memory. The results show that the\u00a0\u2026", "num_citations": "71\n", "authors": ["1581"]}
{"title": "CHAMELEON: A Self-Evolving, Fully-Adaptive Resource Arbitrator for Storage Systems.\n", "abstract": " Enterprise applications typically depend on guaranteed performance from the storage subsystem, lest they fail. However, unregulated competition is unlikely to result in a fair, predictable apportioning of resources. Given that widespread access protocols and scheduling policies are largely best-effort, the problem of providing performance guarantees on a shared system is a very difficult one. Clients typically lack accurate information on the storage system\u2019s capabilities and on the access patterns of the workloads using it, thereby compounding the problem. CHAMELEON is an adaptive arbitrator for shared storage resources; it relies on a combination of self-refining models and constrained optimization to provide performance guarantees to clients. This process depends on minimal information from clients, and is fully adaptive; decisions are based on device and workload models automatically inferred, and continuously refined, at runtime. Corrective actions taken by CHAMELEON are only as radical as warranted by the current degree of knowledge about the system\u2019s behavior. In our experiments on a real storage system CHAMELEON identified, analyzed, and corrected performance violations in 3-14 minutes\u2014which compares very favorably with the time a human administrator would have needed. Our learningbased paradigm is a most promising way of deploying large-scale storage systems that service variable workloads on an ever-changing mix of device types.", "num_citations": "71\n", "authors": ["1581"]}
{"title": "Customization and composition of distributed objects: Middleware abstractions for policy management\n", "abstract": " Current middleware solutions such as CORBA and Java's RMI emphasize compositional design by separating functional aspects of a system (eg objects) from the mechanisms used for interaction (eg remote procedure call through stubs and skeletons). While this is an effective solution for handling distributed interactions, higher-level requirements such as heterogeneity, availability, and adaptability require policies for resource management as well as interaction. We describe the Distributed Connection Language (dcl): an architecture description language based on the Actor model of distributed objects. System components and the policies which govern an architecture are specified as encapsulated groups of actors. Composition operators are used to build connections between components as well as customize their behavior. This customization is realized using a meta-architecture. We describe the syntax and\u00a0\u2026", "num_citations": "71\n", "authors": ["1581"]}
{"title": "Realistic case studies of wireless structural control\n", "abstract": " Wireless Structural Control (WSC) systems can play a crucial role in protecting civil infrastructure in the event of earthquakes and other natural disasters. Such systems represent an exemplary class of cyber-physical systems that perform close-loop control using wireless sensor networks. Existing WSC research usually employs wireless sensors installed on small lab structures, which cannot capture realistic delays and data loss in wireless sensor networks deployed on large civil structures. The lack of realistic tools that capture both the cyber (wireless) and physical (structural) aspects of WSC systems has been a hurdle for cyber-physical systems research for civil infrastructure. This advances the state of the art through the following contributions. First, we developed the Wireless Cyber-Physical Simulator (WCPS), an integrated environment that combines realistic simulations of both wireless sensor networks and\u00a0\u2026", "num_citations": "67\n", "authors": ["1581"]}
{"title": "Maximal clique based distributed coalition formation for task allocation in large-scale multi-agent systems\n", "abstract": " We present a fully distributed algorithm for coalition formation among autonomous agents. The algorithm is based on two main ideas. One is a distributed computation of maximal cliques (of bounded sizes) in the underlying graph that captures the interconnection communication topology of the agents. Hence, given the current configuration of the agents, the coalitions that are formed are characterized by a high degree of connectivity, and therefore a high fault tolerance with respect to the subsequent node and/or link failures. The second idea is that each agent chooses its most preferable coalition based on how highly the agent values each such coalition in terms of the coalition members\u2019 combined resources or capabilities. Coalitions with sufficient resources for fulfilling are preferable to the coalitions with resources that suffice only for completing less valuable tasks. We envision variants of our distributed\u00a0\u2026", "num_citations": "66\n", "authors": ["1581"]}
{"title": "Actors: A unifying model for parallel and distributed computing\n", "abstract": " Parallel computing and distributed computing have traditionally evolved as two separate research disciplines. Parallel computing has addressed problems of communication-intensive computation on tightly-coupled processors while distributed computing has been concerned with coordination, availability, timeliness, etc., of more loosely coupled computations. Current trends, such as parallel computing on networks of conventional processors and Internet computing, suggest the advantages of unifying these two disciplines. Actors provide a flexible model of computation which supports both parallel and distributed computing. One may evaluate the utility of a programming paradigm in terms of four criteria: expressiveness, portability, efficiency, and performance predictability. We discuss how the Actor model and programming methods based on it support these goals. In particular, we provide an overview of the state\u00a0\u2026", "num_citations": "63\n", "authors": ["1581"]}
{"title": "A actor-based architecture for customizing and controlling agent ensembles\n", "abstract": " Coordinating agent behavior in agent ensembles is a key challenge for distributed AI. The authors describe a programming model that supports multiagent ensembles, and they present their Java-based prototype system, AgentFoundry.", "num_citations": "62\n", "authors": ["1581"]}
{"title": "Scalability of parallel sorting on mesh multicomputers\n", "abstract": " The paper presents two new parallel algorithms QSP1 and QSP2 based on sequential quicksort for sorting data on a mesh multicomputer, and analyzes their scalability using the isoefficiency metric. It shows that QSP2 matches the lower bound on the isoefficiency function for mesh multicomputers. The isoefficiency of QSP1 is also fairly close to optimal. Lang et al. (1985) and Schnorr et al. (1986) have developed parallel sorting algorithms for the mesh architecture that have either optimal (Schnorr) or close to optimal (Lang) run-time complexity for the one-element-per-processor case. Both QSP1 and QSP2 have worse performance than these algorithms for the one-element-per-processor case. But QSP1 and QSP2 have better scalability than the scaled-down variants of these algorithms (for the case in which there are more elements than processors). As a result, the new parallel formulations are better than these\u00a0\u2026", "num_citations": "61\n", "authors": ["1581"]}
{"title": "Scalable distributed garbage collection for systems of active objects\n", "abstract": " Automatic storage management is important in highly parallel programming environments where large numbers of objects and processes are being constantly created and discarded. Part of the difficulty with automatic garbage collection in systems of active objects, such as actors, is that an active object may not be garbage if it has references to other reachable objects, even when no other object has references to it. This is because an actor may at some point communicate its mail address to a reachable object thereby making itself reachable. Because messages may be pending in the network, the asynchrony of distributed networks makes it difficult to determine the current topology. Existing garbage collection schemes halt the computation process in order to determine if a currently inaccessible actor may be potentially active, thus precluding a real-time response by the system. We describe a generation\u00a0\u2026", "num_citations": "60\n", "authors": ["1581"]}
{"title": "Task assignment for a physical agent team via a dynamic forward/reverse auction mechanism\n", "abstract": " In the dynamic distributed task assignment (DDTA) problem, a team of agents is required to accomplish a set of tasks while maximizing the overall team utility. An effective solution to this problem needs to address two closely related questions: first, how to find a near-optimal assignment from agents to tasks under resource constraints, and second, how to efficiently maintain the optimality of the assignment over time. We address the first problem by extending an existing forward/reverse auction algorithm which was designed for bipartite maximal matching to find an initial near-optimal assignment. A difficulty with such an assignment is that the dynamicity of the environment compromises the optimality of the initial solution. We address the dynamicity problem by using swapping to locally move agents between tasks. By linking these local swaps, the current assignment is morphed into one which is closer to what would\u00a0\u2026", "num_citations": "59\n", "authors": ["1581"]}
{"title": "Adaptive middleware\n", "abstract": " Customization, policy management, coordination, and other services are available for distributed, mobile, embedded systems, increasingly assembled on the fly through the web.", "num_citations": "59\n", "authors": ["1581"]}
{"title": "Rosette: An object-oriented concurrent systems architecture\n", "abstract": " A number of concurrent computers have been designed, such as [Ametek 1988] and [NCUBE 1986]. Taking advantage of concurrency on these computers will require new languages, operating systems, and environments to support the programming, monitoring and control of applications. The Rosette project at MCC is developing a system architecture for general-purpose concurrent computation based on the Actor model [Agha 1986]. The aim of the Rosette architecture is to support the use of concurrent computers in solving computationally intensive problems whose structure is not statically determined. The architecture will support variable grain size, dynamic resource management, reflection, and heterogeneity.", "num_citations": "59\n", "authors": ["1581"]}
{"title": "Next generation wireless smart sensors toward sustainable civil infrastructure\n", "abstract": " This paper presents the recent development of a next-generation wireless smart sensor (WSS) platform to enable a more accurate, inexpensive, and greatly simplified method of instrumenting structures for structural health monitoring. The modular hardware platform features a 24-bit high-precision, analog-to-digital converter with eight differential channels of analog input, and programmable antialiasing filters. The node can measure: (i) three-axes of acceleration for global response monitoring (ii) strain for local response monitoring, (iii) temperature, and (iv) high-level voltage signals from external sensors, providing the multi-scale sensed information needed for advanced structural health monitoring (SHM). Communication with a power-optimized ZigBee radio can be achieved at distances of up to 1\u00a0km. An extensible, actor-based software framework facilitates the creation of distributed SHM applications. The\u00a0\u2026", "num_citations": "54\n", "authors": ["1581"]}
{"title": "Actors\n", "abstract": " Actors is a model of concurrent computation for developing parallel, distributed and mobile systems. Each actor is an autonomous object that operates concurrently and asynchronously, receiving and sending messages to other actors, creating new actors, and updating its own local state. An actor system consists of a collection of actors, some of whom may send messages to, or receive messages from, actors outside the system.", "num_citations": "52\n", "authors": ["1581"]}
{"title": "Analysis of parallel algorithms for energy conservation in scalable multicore architectures\n", "abstract": " This paper analyzes energy characteristics of parallel algorithms executed on scalable multicore processors. Specifically, we provide a methodology for evaluating energy scalability of parallel algorithms while satisfying performance requirements. Four parallel algorithms are analyzed to illustrate our method. We study the sensitivity of our analysis to changes in parameters such as the ratio of power required for computation versus power required for communication. The results suggest that power and performance scalability of a parallel algorithm can be quite different. Our method can be used to determine how many cores to use in order to minimize energy consumption.", "num_citations": "52\n", "authors": ["1581"]}
{"title": "12 Concurrent Programming for Distributed Artificial Intelligence\n", "abstract": " The increasing performance and decreasing cost of processors and computer networks has continued to fuel an explosion of interest in solving larger problems using concurrent computing. In particular, agent-based programming has emerged as a promising paradigm which may help realize Arti cial Intelligence through distributed problem solving. Agents are persistent and goal directed entities that may move between hosts in response to changes in requirements such as security and e ciency, and that would normally be limited in the computational resources they may employ in pursuing their goals. Such resources include processor time, memory, and network bandwidth.A key challenge in concurrent computing is the di culty of programming parallel and distributed architectures. Many models of concurrency are rather low-level. For example, shared variable models often violate data encapsulation, an essential feature for modular software development. A promising approach to address this di culty is the use of concurrent objects in a re ective architecture. In particular, actors provide a formal model for building and representing the behavior of concurrent objects and thus serve as a foundation for concurrent object-oriented programming.", "num_citations": "52\n", "authors": ["1581"]}
{"title": "Targeted test input generation using symbolic-concrete backward execution\n", "abstract": " Knowing inputs that cover a specific branch or statement in a program is useful for debugging and regression testing. Symbolic backward execution (SBE) is a natural approach to find such targeted inputs. However, SBE struggles with complicated arithmetic, external method calls, and data-dependent loops that occur in many real-world programs. We propose symcretic execution, a novel combination of SBE and concrete forward execution that can efficiently find targeted inputs despite these challenges. An evaluation of our approach on a range of test cases shows that symcretic execution finds inputs in more cases than concolic testing tools while exploring fewer path segments. Integration of our approach will allow test generation tools to fill coverage gaps and static bug detectors to verify candidate bugs with concrete test cases.", "num_citations": "51\n", "authors": ["1581"]}
{"title": "Formalizing multimedia qos constraints using actors\n", "abstract": " The vision of future information systems is that different forms of information are potentially accessible at anytime through the Internet. We describe challenges in the modeling and specification of timing related multimedia (MM) services in open distributed systems. Management of multimedia services in an open system is complicated by the heterogeneity of application requirements, multimedia information, and system components. Services and systems in this environment evolve dynamically and their components interact with an environment that is not under their control. We propose a formal specification of timing related Quality-of-Service (QoS) attributes in an actor-based distributed system and describe some techniques for informally reasoning about quantitative QoS properties.", "num_citations": "50\n", "authors": ["1581"]}
{"title": "Middleware services for structural health monitoring using smart sensors\n", "abstract": " Smart sensors densely distributed over structures can use their computational and wireless communication capabilities to provide rich information for structural health monitoring (SHM). Though smart sensor technology has seen substantial advances during recent years, implementation of smart sensors on full-scale structures has been limited. Hardware resources available on smart sensors restrict data acquisition capabilities; intrinsic to these wireless systems are packet loss, data synchronization errors, and relatively slow communication speeds. This paper addresses these issues under the hardware limitation by developing corresponding middleware services. The reliable communication service requires only a few acknowledgement packets to compensate for packet loss. The synchronized sensing service employs a resampling approach leaving the need for strict control of sensing timing. The data aggregation service makes use of application specific knowledge and distributed computing to suppress data transfer requirements. These middleware services are implemented on the Imote2 smart sensor platform, and their efficacy demonstrated experimentally.", "num_citations": "49\n", "authors": ["1581"]}
{"title": "Costless: Optimizing cost of serverless computing through function fusion and placement\n", "abstract": " Serverless computing has recently experienced significant adoption by several applications, especially Internet of Things (IoT) applications. In serverless computing, rather than deploying and managing dedicated virtual machines, users are able to deploy individual functions, and pay only for the time that their code is actually executing. However, since serverless platforms are relatively new, they have a completely different pricing model that depends on the memory, duration, and the number of executions of a sequence/workflow of functions. In this paper we present an algorithm that optimizes the price of serverless applications in AWS Lambda. We first describe the factors affecting price of serverless applications which include: (1) fusing a sequence of functions, (2) splitting functions across edge and cloud resources, and (3) allocating the memory for each function. We then present an efficient algorithm to explore\u00a0\u2026", "num_citations": "48\n", "authors": ["1581"]}
{"title": "A formal model for reasoning about adaptive qos-enabled middleware\n", "abstract": " Systems that provide distributed multimedia services are subject to constant evolution; customizable middleware is required to effectively manage this change. Middleware services for resource management execute concurrently with each other, and with application activities, and can, therefore, potentially interfere with each other. To ensure cost-effective QoS in distributed multimedia systems, safe composability of resource management services is essential. In this article, we present a meta-architectural framework, the Two-Level Actor Model (TLAM) for customizable QoS-based middleware, based on the actor model of concurrent active objects. Using TLAM, a semantic model for specifying and reasoning about components of open distributed systems, we show how a QoS brokerage service can be used to coordinate multimedia resource management services in a safe, flexible, and efficient manner. In particular\u00a0\u2026", "num_citations": "46\n", "authors": ["1581"]}
{"title": "An actor-based simulation for studying uav coordination\n", "abstract": " The effectiveness of Unmanned Aerial Vehicles (UAVs) is being increased to reduce the cost and risk of a mission [Doherty et al. 2000]. Since the advent of small sized but high performance UAVs, the use of a group of UAVs for performing a joint mission is of major interest. However, the development of a UAV is expensive, and a small error in automatic control results in a crash. Therefore, it is useful to develop and verify the coordination behavior of UAVs through software simulation prior to real testing. We describe how an actor-based simulation platform supports distributed simulators, and present three cooperation strategies: self-interested UAVs, sharing-based cooperation, and team-based coordination. Our experimental results show how communication among UAVs improves the overall performance of a collection of UAVs on a joint mission.", "num_citations": "45\n", "authors": ["1581"]}
{"title": "Efficient agent communication in multi-agent systems\n", "abstract": " In open multi-agent systems, agents are mobile and may leave or enter the system. This dynamicity results in two closely related agent communication problems, namely, efficient message passing and service agent discovery. This paper describes how these problems are addressed in the Actor Architecture (AA). Agents in AA obey the operational semantics of actors, and the architecture is designed to support large-scale open multi-agent systems. Efficient message passing is facilitated by the use of dynamic names: a part of the mobile agent name is a function of the platform that currently hosts the agent. To facilitate service agent discovery, middle agents support application agent-oriented matchmaking and brokering services. The middle agents may accept search objects to enable customization of searches; this reduces communication overhead in discovering service agents when the matching criteria\u00a0\u2026", "num_citations": "45\n", "authors": ["1581"]}
{"title": "The microelectronic wireless nitrate sensor network for environmental water monitoring\n", "abstract": " Quantitative monitoring of water conditions in a field is a critical ability for environmental science studies. We report the design, fabrication and testing of a low cost, miniaturized and sensitive electrochemical based nitrate sensor for quantitative determination of nitrate concentrations in water samples. We have presented detailed analysis for the nitrate detection results using the miniaturized sensor. We have also demonstrated the integration of the sensor to a wireless network and carried out field water testing using the sensor. We envision that the field implementation of the wireless water sensor network will enable \u201csmart farming\u201d and \u201csmart environmental monitoring\u201d.", "num_citations": "43\n", "authors": ["1581"]}
{"title": "Model-based data aggregation for structural monitoring employing smart sensors\n", "abstract": " Smart sensors densely distributed over structures can provide rich information for structural monitoring using their computational and wireless communication capabilities. One key issue in such monitoring is data aggregation. The sensors are typically sampled at high frequencies, producing large amounts of data; limited network resources (eg, battery power, storage space, bandwidth, etc.) make acquiring and processing this data quite challenging. Efficient data aggregation with data compression is needed to achieve scalable sensor networks for structural monitoring. Model-based data aggregation is proposed using both structural and network analyses. A structural analysis algorithm, the Natural Excitation Technique, motivates adaptation of correlation function estimation to smart sensor networks. The data size is reduced by a factor of 20 to 40, depending on the degree of averaging in the aggregation. This averaging also addresses the wireless communication data loss problem. The algorithm is implemented on Mica2s and experimentally validated using a scale-model building.", "num_citations": "43\n", "authors": ["1581"]}
{"title": "An algebraic theory of actors and its application to a simple object-based language\n", "abstract": " The development of Simula by Ole-Johan Dahl and Kristen Nygaard introduced a number of important programming language concepts \u2013 object which supports modularity in programming through encapsulation of data and procedures, the concept of class which organizes behavior and supports Abstract Data Types, and the concept inheritance which provides subtyping relations and reuse [6]. Peter Wegner terms programming languages which use objects as object-based languages, and reserves the term object-oriented languages for languages which also support classes and inheritance [58].", "num_citations": "43\n", "authors": ["1581"]}
{"title": "Inferring ownership transfer for efficient message passing\n", "abstract": " One of the more popular paradigms for concurrent programming is the Actor model of message passing; it has been adopted in one form or another by a number of languages and frameworks. By avoiding a shared local state and instead relying on message passing, the Actor model facilitates modular programming. An important challenge for message passing languages is to transmit messages efficiently. This requires retaining the pass-by-value semantics of messages while avoiding making a deep copy on sequential or shared memory multicore processors. A key observation is that many messages have an ownership transfer semantics; such messages can be sent efficiently using pointers without introducing shared state between concurrent objects. We propose a conservative static analysis algorithm which infers if the content of a message is compatible with an ownership transfer semantics. Our tool, called\u00a0\u2026", "num_citations": "41\n", "authors": ["1581"]}
{"title": "Computing in pervasive cyberspace\n", "abstract": " Freed from the temporal constraints of hardware, software could be the ultimate cyberorganism---a mind taking a body as needed to fulfill a particular function or mission.", "num_citations": "40\n", "authors": ["1581"]}
{"title": "Solving complex path conditions through heuristic search on induced polytopes\n", "abstract": " Test input generators using symbolic and concolic execution must solve path conditions to systematically explore a program and generate high coverage tests. However, path conditions may contain complicated arithmetic constraints that are infeasible to solve: a solver may be unavailable, solving may be computationally intractable, or the constraints may be undecidable. Existing test generators either simplify such constraints with concrete values to make them decidable, or rely on strong but incomplete constraint solvers. Unfortunately, simplification yields coarse approximations whose solutions rarely satisfy the original constraint. Moreover, constraint solvers cannot handle calls to native library methods. We show how a simple combination of linear constraint solving and heuristic search can overcome these limitations. We call this technique Concolic Walk. On a corpus of 11 programs, an instance of our Concolic\u00a0\u2026", "num_citations": "39\n", "authors": ["1581"]}
{"title": "Passive localization: Large size sensor network localization based on environmental events\n", "abstract": " We develop a localization algorithm based on global environmental events observed by a sensor network. Examples of such events include the sound of thunder, the shades of moving clouds, or the vibrations in seismic data. Because our localization method does not generate signals for distance measurements, it saves energy. In fact, the algorithm may use existing sensor recordings to determine the locations of nodes at which the recordings were taken. Moreover, the method does not accumulate errors, making it also effective for large and sparse sensor networks. The localization uses time synchronization; we provide an algorithm to compensate for clock synchronization errors. Versions for both two dimensional and three dimensional localization of the algorithm are presented. Simulation results suggest that the algorithm can provide a high degree of accuracy when many events are recorded.", "num_citations": "39\n", "authors": ["1581"]}
{"title": "Abstracting interactions based on message sets\n", "abstract": " An important requirement of programming languages for distributed systems is to provide abstractions for coordination. A common type of coordination requires reactivity in response to arbitrary communication patterns. We have developed a communication model in which concurrent objects can be activated by sets of messages. Specifically, our model allows direct and abstract expression of common interaction patterns found in concurrent systems. For example, the model captures multiple clients that collectively invoke shared servers as a single activation. Furthermore, it supports definition of individual clients that concurrently invoke multiple servers and wait for subsets of the returned reply messages. Message sets are dynamically defined using conjunctive and disjunctive combinators that may depend on the patterns of messages. The model subsumes existing models for multi-RPC and multi-party\u00a0\u2026", "num_citations": "38\n", "authors": ["1581"]}
{"title": "Distributed execution of actor programs\n", "abstract": " A number of programming language models, including actors, provide inherent concurrency. We are developing high-level language constructs using actors and studying their implementation on multiprocessor architectures. This report describes our experience with programming in actors by means of a specific example of scientific computation. We also discuss work in progress on compilation technology for efficient program execution on multiprocessors.", "num_citations": "38\n", "authors": ["1581"]}
{"title": "Linear Inequality LTL (iLTL): A Model Checker for Discrete Time Markov Chains\n", "abstract": " We develop a way of analyzing the behavior of systems modeled using Discrete Time Markov Chains (DTMC). Specifically, we define iLTL, an LTL with linear inequalities on the pmf vectors as atomic propositions. iLTL allows us to express not only properties such as the expected number of jobs or the expected energy consumption of a protocol during a time interval, but also inequalities over such values. We present an algorithm for model checking properties of DTMCs expressed in iLTL. Our model checker differs from existing probabilistic ones in that the latter do not check properties of the transitions on the probability mass function (pmf) itself. Thus, iLTLChecker can check, given an interval estimate of current pmf, whether future pmfs will always satisfy a specification. We believe such properties often arise in distributed systems and networks and may, in particular, be useful in specifying requirements for\u00a0\u2026", "num_citations": "37\n", "authors": ["1581"]}
{"title": "Crawlets: Agents for high performance web search engines\n", "abstract": " Some of the reasons for unsatisfactory performance of today\u2019s search engines are their centralized approach to web crawling and lack of explicit support from web servers. We propose a modification to conventional crawling in which a search engine uploads simple agents, called crawlets, to web sites. A crawlet crawls pages at a site locally and sends a compact summary back to the search engine. This not only reduces bandwidth requirements and network latencies, but also parallelizes crawling. Crawlets also provide an effective means for achieving the performance gains of personalized web servers, and can make up for the lack of cooperation from conventional web servers. The specialized nature of crawlets allows simple solutions to security and resource control problems, and reduces software requirements at participating web sites. In fact, we propose an implementation that requires no changes to\u00a0\u2026", "num_citations": "37\n", "authors": ["1581"]}
{"title": "LTLC: Linear temporal logic for control\n", "abstract": " Linear systems are one of the most commonly used models to represent physical systems. Yet, only few automated tools have been developed to check their behaviors over time. In this paper, we propose a linear temporal logic for specifying complex properties of discrete time linear systems. The proposed logic can also be used in a control system to generate control input in the process of model checking. Although, developing a full feedback control system is beyond the scope of this paper, authors believe that a feedback loop can be easily introduced by adopting the receding horizon scheme of predictive controllers. In this paper we explain the syntax, the semantics, a model checking algorithm, and an example application of our proposed logic.", "num_citations": "36\n", "authors": ["1581"]}
{"title": "Maximal clique based distributed group formation for autonomous agent coalitions\n", "abstract": " We present herein a fully distributed algorithm for group or coalition formation among autonomous agents. The algorithm is based on a distributed computation of maximal cliques (of up to pre-specified size) in the underlying graph that captures the interconnection topology of the agents. Hence, given the current configuration of the agents, the groups that are formed are characterized by a high degree of connectivity, and therefore high fault tolerance with respect to node and link failures. We also briefly discuss how our basic algorithm can be adapted in various ways so that the formed groups satisfy the requirements (\u201cgoodness\u201d criteria) other than mere strong inter-group communication connectivity. We envision various variants of our basic algorithm to prove themselves useful subroutines in many multi-agent system and ad hoc network applications where the agents may repeatedly need to form temporary groups or coalitions in an efficient, fully distributed and online manner.", "num_citations": "35\n", "authors": ["1581"]}
{"title": "Agent framework services to reduce agent communication overhead in large-scale agent-based simulations\n", "abstract": " Agent-based simulations are an essential tool in analyzing the behavior of real-world systems. Agent-based distributed simulations can be a useful in addressing the scale and complexity of such simulations. Because agents in such simulations intensively communicate with each other to perform their shared tasks, performance of the simulation is strongly related to the amount of inter-node message passing. In this paper, we propose two agent framework services to reduce the amount of inter-node message passing: dynamic agent distribution and search object-based middle agent services. We have implemented this framework in Java-based tool and used it to conduct simulations of up to 10,000 agents, where each agent represents a micro-UAV or a physical agent on the ground. In our experiments, the use of the dynamic agent distribution service reduces the runtime by 60%, and the use of the search object\u00a0\u2026", "num_citations": "34\n", "authors": ["1581"]}
{"title": "Semantics for an actor-based real-time language\n", "abstract": " We give formal semantics for a distributed concurrent object oriented real time programming language based on a variant of the actor model which includes an extention enabling the specification of time constraints on message invocation. Real time semantics must capture both the qualitative and quantitative aspects of the language, and provide a meaning for the real time constructs. The real time semantics of our language is given as timed graph, an existing real time specification formalism. We present the semantics by first defining an operational semantics for the untimed language, and then translating this into a timed graph which interprets the time constructs. Our semantics is formulated independently of the underlying resources needed to execute a program; the semantics of a program thus defines the set of permissible concrete implementations.", "num_citations": "34\n", "authors": ["1581"]}
{"title": "Compilation of a highly parallel actor-based language\n", "abstract": " Hal is a High-level Actor-based Language. Hal supports a number of communication mechanisms, local synchronization constraints, inheritance, and restricted forms of reflection. This paper discusses some issues in compiling Hal. Specifically, we describe three source-level transformations used by the compiler for Hal. Two of the transformations translate RPC-style message sending into asynchronous message sending. The third transformation performs code motion to optimize the implementation of replacement behavior. This optimization results in the reduction of object code size as well as execution time.", "num_citations": "34\n", "authors": ["1581"]}
{"title": "Scoped synchronization constraints for large scale actor systems\n", "abstract": " Very large scale systems of autonomous concurrent objects (Actors) require coordination models to meet two competing goals. On the one hand, the coordination models must allow Actors to dynamically modify protocols in order to adapt to requirement changes over the, likely extensive, lifetime of the system. On the other hand, the coordination models must enforce protocols on potentially uncooperative Actors, while preventing deadlocks caused by malicious or faulty Actors. To meet these competing requirements, we introduce a novel, scoped semantics for Synchronizers [7,6]\u2014a coordination model based on declarative synchronization constraints. The mechanism used to limit the scope of the synchronization constraints is based on capabilities and works without central authority. We show that the mechanism closes an attack vector in the original Synchronizer approach which allowed malicious Actors to\u00a0\u2026", "num_citations": "33\n", "authors": ["1581"]}
{"title": "Guarded Horn clause languages: are they deductive and Logical\n", "abstract": " Guarded Horn clause languages | Artificial intelligence at MIT expanding frontiers ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksArtificial intelligence at MIT expanding frontiersGuarded Horn clause languages: are they deductive and logical chapter Guarded Horn clause languages: are they deductive and logical Share on Authors: Carl E Hewitt profile image Carl Hewitt View Profile , Gul A. Agha profile image Gul Agha View Profile Authors Info & Affiliations Publication: Artificial intelligence at MIT expanding frontiersJune 1991 Pages 582\u2013593 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 \u2026", "num_citations": "31\n", "authors": ["1581"]}
{"title": "Using passive object garbage collection algorithms for garbage collection of active objects\n", "abstract": " With the increasing use of active object systems, agents and concurrent object oriented languages like Java, the problem of garbage collection (GC) of unused resources has become more complex. Since active objects are autonomous computational agents, unlike passive object systems the criterion for identifying garbage in active objects cannot be based solely on reachability from a root set. This has led to development of specialized algorithms for GC of active objects. We reduce the problem of GC of active objects to that of passive objects by providing a transformation of the active object reference graph to a passive object reference graph so that if a garbage collector for a passive object system is applied to the transformed graph, precisely those objects are collected which correspond to garbage objects in the original active object reference graph. The transformation technique enables us to reuse the\u00a0\u2026", "num_citations": "30\n", "authors": ["1581"]}
{"title": "Actor Languages for Specification of Parallel Computations.\n", "abstract": " We describe high-level language constructs for specifying parallel programs and show how they may be used to provide modular specication of communication, synchronization and placement. The high-level constructs are translated into actors which provide exible low-level primitives for interconnecting distributed components and e cient execution on concurrent computers. We argue that our linguistic constructs allow parallel program speci cations that are easier to reason about and e cient to implement.", "num_citations": "29\n", "authors": ["1581"]}
{"title": "Semantic considerations in the actor paradigm of concurrent computation\n", "abstract": " This paper discusses the theory of concurrent processing in the context of the actor paradigm. The basic precepts of the actor paradigm are explained. We develop a new formalism to describe the behavior of actors and the evolution of systems of actors. It is hoped that the structure of concurrent computation and the intuitions behind the actor paradigm will be better understood in terms of this model. In particular, we define certain relations between the configurations an actor system may be in and explain how the behavior of actor systems can be understood in terms of these relations. We also define an actor-based language, called Sal, which has a simple syntax but nevertheless embodies the concepts involved.             Several examples of simple actor systems are presented. Two kinds of actors are defined and their relevance to spawning concurrency is noted. The low level detail inherent in the transition\u00a0\u2026", "num_citations": "29\n", "authors": ["1581"]}
{"title": "Parameterized, concurrent session types for asynchronous multi-actor interactions\n", "abstract": " Session types have been proposed as a means of statically verifying implementations of communication protocols. Although prior work has been successful for some classes of protocols, it does not cope well with parameterized, multi-actor scenarios with inherent asynchrony. For example, the sliding window protocol is not expressible in previously proposed session type notations. This article defines System-A: a novel session type system, as well the associated programming language that together overcome many of the limitations of prior work. With explicit support for asynchrony and concurrency, as well as multiple forms of parameterization, we demonstrate that System-A can be used for the static verification of a large class of asynchronous communication protocols.", "num_citations": "28\n", "authors": ["1581"]}
{"title": "On computational complexity of counting fixed points in symmetric boolean graph automata\n", "abstract": " We study computational complexity of counting  the fixed point configurations (FPs)  in certain classes of graph automata viewed as discrete dynamical systems. We prove that both exact and approximate counting of FPs in Sequential  and Synchronous Dynamical Systems  (SDSs and SyDSs, respectively) are computationally intractable, even when each node is required to update according to a symmetric Boolean function. We also show that the problems of counting exactly the garden of Eden configurations (GEs),  as well as all transient configurations,  are in general intractable, as well. Moreover, exactly enumerating FPs or GEs remains hard even in some severely restricted cases, such as when the nodes of an SDS or SyDS use only two different symmetric Boolean update rules, and every node has a neighborhood size bounded by a small constant.", "num_citations": "27\n", "authors": ["1581"]}
{"title": "Characterizing configuration spaces of simple threshold cellular automata\n", "abstract": " We study herewith the simple threshold cellular automata (CA),  as perhaps the simplest broad class of CA  with non-additive (that is, non-linear and non-affine) local update rules. We characterize all possible computations of the most interesting rule for such CA, namely, the Majority (MAJ)  rule, both in the classical, parallel CA case, and in case of the corresponding sequential CA where the nodes update sequentially, one at a time. We compare and contrast the configuration spaces of arbitrary simple threshold automata in those two cases, and point out that some parallel threshold CA cannot be simulated by any of their sequential equivalents. We show that the temporal cycles exist only in case of (some) parallel simple threshold CA, but can never take place in sequential threshold CA. We also show that most threshold CA  have very few fixed point configurations and few (if any) cycle configurations, and\u00a0\u2026", "num_citations": "27\n", "authors": ["1581"]}
{"title": "Towards reusable real-time objects\n", "abstract": " Large and complex real-time systems can benefit significantly from a component-based development approach where new systems are constructed by composing reusable, documented and previously tested concurrent objects. However, reusing objects which execute under real-time constraints is problematic because application specific time and synchronization constraints are often embedded in the internals of these objects. The tight coupling of functionality and real-time constraints makes objects interdependent, and as a result difficult to reuse in another system. We propose a model which facilitates separate and modular specification of real-time constraints, and show how separation of real-time constraints and functional behavior is possible. We present our ideas using the Actor model to represent untimed objects, and the Real-time Synchronizers language to express real-time and synchronization\u00a0\u2026", "num_citations": "26\n", "authors": ["1581"]}
{"title": "Visualizing actor programs using predicate transition nets\n", "abstract": " The actor model of concurrent computation unifies the functional and object-oriented programming language paradigms. The model provides a flexible basis for concurrent programming. It supports local state, dynamic creation and configuration, and inherent parallelism. Because of the fluidity of actors, specifying and debugging actor systems is often considered difficult. We believe visual programming techniques are of fundamental importance in addressing powerful concurrent systems of this nature. Not surprisingly, a number of methods to visualize actor programs have been proposed. We give an outline of visualization techniques and their relation to actors. We then discuss one such proposal, namely the use of Predicate Transition nets, to visualize actor programs.", "num_citations": "26\n", "authors": ["1581"]}
{"title": "An actor-based framework for heterogeneous computing systems\n", "abstract": " This paper discusses a framework for supporting heterogeneous computing systems (hcs). hcs are physically distributed, potentially complex and evolving systems. hcs consist of a number of computers and interconnections which may have di ering language and system support, and sometimes distinct computational (architectural) models. By providing a large number of computational resources to the user, hcs have the potential to allow highly e cient execution of ultra large-scale applications. The paper provides a framework for addressing some of the signi cant problems in interoperability and resource management which result from the heterogeneity in hcs.", "num_citations": "26\n", "authors": ["1581"]}
{"title": "Towards a hierarchical taxonomy of autonomous agents\n", "abstract": " Autonomous agents have become an influential and powerful paradigm in a great variety of disciplines, from sociology and economics to distributed artificial intelligence and software engineering to philosophy. Given that the paradigm has been around for awhile, one would expect a broadly agreed-upon, solid understanding of what autonomous agents are and what they are not. This, however, is not the case. We therefore join the ongoing debate on what are the appropriate notions of autonomous agency. We approach agents and agent ontology from a cybernetics and general systems perspective, in contrast to the much more common in the agent literature sociology, anthropology and/or cognitive psychology based approaches. We attempt to identify the most fundamental attributes of autonomous agents, and propose a tentative hierarchy of autonomous agents based on those attributes.", "num_citations": "25\n", "authors": ["1581"]}
{"title": "A methodology for adapting to patterns of faults\n", "abstract": " In this paper, we present a language framework for describing dependable systems. Our framework emphasizes modularity and composition. The dependability and functionality aspects of an application may be described independently, providing separation of design concerns. Furthermore, the dependability protocols of an application may be constructed bottom-up as simple protocols that are composed into more complex protocols. Composition makes it easier to reason about the behavior of complex protocols and supports the construction of generic reusable dependability schemes. A significant aspect of our language framework is that dependability protocols may be loaded into a running application and installed dynamically. Dynamic installation makes it possible to impose additional dependability protocols on a server as clients with new dependability demands are integrated into a system. Similarly\u00a0\u2026", "num_citations": "25\n", "authors": ["1581"]}
{"title": "Droplet: Distributed operator placement for iot applications spanning edge and cloud resources\n", "abstract": " Internet of Things (IoT) applications generate massive amounts of real-time streaming data. IoT data owners strive to make predictions/inferences from these large streams of data often through applying machine learning, and image processing operations. A typical deployment of such applications includes edge devices to provide processing/storage operations closer to the location where the streaming data is captured. An important challenge for IoT applications is deciding which operations to execute on an edge device and which operations should be carried out in the cloud. In this paper, we propose a scalable dynamic programming algorithm called DROPLET, to partition operations in IoT applications across shared edge and cloud resources, while minimizing completion time of the end-to-end operations. We evaluate DROPLET using three real-world applications. Our results show that DROPLET finds a\u00a0\u2026", "num_citations": "24\n", "authors": ["1581"]}
{"title": "A service-oriented architecture for structural health monitoring using smart sensors\n", "abstract": " Structural Health Monitoring (SHM) can be an important tool for integrity assessment of structures after extreme loading conditions, as well for ongoing maintenance of aging infrastructure. SHM gives insight into a structures\u2019 response during an earthquake event which can in turn provide valuable information on the post-earthquake condition of the structure. The ultimate goals of implementing an SHM system are to improve infrastructure maintenance, increase public safety, and minimize the economic impact of an earthquake or other extreme loading event by streamlining repair and retrofit measures. Networks of wireless, smart sensors offer promise for accurate and continuous structural monitoring using a dense array of inexpensive sensors. Acquiring pertinent information from these networks is accomplished by leveraging the onboard processing capability of the sensor nodes to implement distributed damage detection algorithms. One of the major roadblocks to achieving such a system is the magnitude and complexity of the required software development. Service-oriented architecture (SOA) can significantly simplify this process by offering a modular, reusable and extensible approach to software development. Based on this approach, we have created an open-source toolkit for the development of SHM systems deployed on smart sensors that is available for broad use. This software facilitates the development of a variety of SHM applications using smart sensors and can be further expanded for other similar challenges.", "num_citations": "24\n", "authors": ["1581"]}
{"title": "Scalable modeling and performance evaluation of wireless sensor networks\n", "abstract": " A notable features of many proposed Wireless Sensor Networks (WSNs) deployments is their scale: hundreds to thousands of nodes linked together. In such systems, modeling the state of the entire system as a cross-product of the states of individual nodes results in the well-known state explosion problem. Instead, we represent the system state by the probability distribution on the state of each node. In other words, the system state represents the probability that a randomly picked node is in a certain state. Although such statistical abstraction of the global state loses some information, it is nevertheless useful in determining many performance metrics of systems that exhibit Markov behavior. We have previously developed a method for specifying the performance metrics of such systems in a probabilistic temporal logic called iLTL and for evaluating the behavior through a novel method for model checking iLTL\u00a0\u2026", "num_citations": "24\n", "authors": ["1581"]}
{"title": "Specification of real-time interaction constraints\n", "abstract": " We present a coordination language and its semantics for specification and implementation of object-oriented real-time systems. Real-time systems operate under real-time constraints, and our language supports expression thereof. In our language, a system is modeled by two separate but complementary descriptions: A collection of objects define the system's structure and functional behavior and a set of interaction constraints define how these objects may interact. Our language thereby supports development of real-time systems by enabling objects build in isolation or re-used from other systems to be composed via interaction constraints. We use the Actor model to describe objects and the concept of real-time synchronizers to describe interaction constraints. Our model is accompanied by a formal semantics that precisely defines what real-time constraints means, and what constitutes a program's correct real\u00a0\u2026", "num_citations": "24\n", "authors": ["1581"]}
{"title": "Foundational issues in concurrent computing\n", "abstract": " Several models of concurrency have been proposed. The most conservative of proposals, promoted by Tony Hoare and others, is built using communication between sequential processes [18]. In this model, communication is synchronous and the process topology is statically determined. The first limitation implies that it is impossible to define recursive programs: a process that is busy waiting to send a message cannot receive the message. The second limitation makes it impossible to provide for dynamic reconfiguration; this in turn implies that it is impossible to provide continuous availability in the face of changes, or to support dynamic extensibility.A more radical proposal, namely that of Functional Programming [14], has also developed a rather large following. Concurrency in Functional Programming is a result of the fact that all arguments to a function may be evaluated concurrently. However, a critical problem\u00a0\u2026", "num_citations": "24\n", "authors": ["1581"]}
{"title": "Victim localization and assessment system for emergency responders\n", "abstract": " In minor to moderate natural and man-made disasters, such as earthquakes and fires, people may be trapped inside buildings and hurt by the disaster. Considering that trapped victims may be unconscious, there is a high demand by emergency responders to get information on the locations and physical statuses of trapped victims inside a building during a disaster. In this paper, a smartphone-based, in-building emergency response assistance system, named iRescue, is presented. The system is comprised of two subsystems: a Victim Positioning System (VPS) and a Victim Assessment System (VAS). The VPS uses the received signal strength indicator of Wi-Fi signals from multiple wireless access points with referencing a pre-established Wi-Fi fingerprinting map of a building. The VAS uses patterns obtained from measured 3D acceleration changes by status of a victim. A Na\u00efve Bayes classifier is employed for\u00a0\u2026", "num_citations": "23\n", "authors": ["1581"]}
{"title": "Concurrency vs. sequential interleavings in 1-D threshold cellular automata\n", "abstract": " Summary form only given. Cellular automata (CA) are an abstract model of fine-grain parallelism: the individual node update operations are rather simple, and therefore comparable to the basic operations of the computer hardware, yet the power of the model stems from the interaction and synergy of these simple local node computations that can often generate highly complex global behavior. In classical CA, all the nodes execute their operations in parallel, that is, (logically) simultaneously. We consider herein the sequential version of CA, or SCA, and compare and contrast SCA with the classical, parallel CA. We show that there are 1D CA with simple nonlinear node state update rules that cannot be simulated by any comparable SCA, irrespective of the node update ordering. While the result is trivial if one considers a single automaton's computations, we find this property quite interesting and having important\u00a0\u2026", "num_citations": "22\n", "authors": ["1581"]}
{"title": "Supporting multiparadigm programming on actor architectures\n", "abstract": " This paper discusses some intuitions about models of concurrency. Several examples of concurrent systems are presented to illustrate different kinds of concurrent computational structures. I argue that supporting large-scale concurrent systems requires building on some surprisingly simple programming primitives. However, some models of concurrency cannot support these primitives. I describe the actor model which incorporates these primitives and illustrate its potential use in supporting different programming paradigms. Developments in concurrent computers are briefly discussed; specifically, I argue that because of their scalability, multicomputers represent the most promising development in computer architecture. Multicomputers provide a powerful realization of the actor model. Finally, I sketch the relation between different programming paradigms and actors and argue for the advantages of\u00a0\u2026", "num_citations": "22\n", "authors": ["1581"]}
{"title": "On scaling multi-agent task reallocation using market-based approach\n", "abstract": " Multi-agent systems (MAS) provide a promising technology for addressing problems such as search and rescue missions, mine sweeping, and surveillance. These problems are a form of the computationally intractable multi-depot traveling salesman problem (MDTSP). We propose a novel market-based approach, called market-based approach with look-ahead agents (MALA), to address the problem. In MALA, agents use look ahead to optimize their behavior. Each agent plans a preferred, reward-maximizing tour for itself using our proposed algorithm which is based on the universal TSP algorithm. The agent then uses the preferred tour to evaluate potential trades with other agents in linear time - a necessary prerequisite for scalability of market-based approach. We use simulations in a two dimensional world to study the performance of MALA and compare it with O-contracts and TraderBots, respectively, a\u00a0\u2026", "num_citations": "21\n", "authors": ["1581"]}
{"title": "Intertemporal speculation with a random demand in an experimental market\n", "abstract": " The behavior of three markets with speculators is studied. Each market is for commodities that can be carried forward one period by two speculators. Demand in the first period is randomly determined. The questions posed by the research is the reliability of rational expectations models relative to autarky models in explaining market behavior. The result is that the rational expectations model is more accurate.", "num_citations": "21\n", "authors": ["1581"]}
{"title": "Ambiance: adaptive object model-based platform for macroprogramming sensor networks\n", "abstract": " A pervasive computing system requires the integration of computation and communication with physical objects in the environment. The Ambiance project is building a platform for Macro-programming pervasive systems based on an Adaptive Object-Model; the platform provides a meta-level architecture to analyze the execution context and customize the services it provides.", "num_citations": "20\n", "authors": ["1581"]}
{"title": "A markov reward model for software reliability\n", "abstract": " A compositional method for estimating software reliability of many threaded programs is developed. The method uses estimates of the reliability of individual modules and the probability of transitions between the modules to estimate the reliability of a program in terms of its current state. The reliability of a program is expressed using iLTL, a probabilistic linear temporal logic whose atomic propositions are linear inequalities about transitions of the probability mass function of a discrete time Markov chain. We then use a Markov reward model to estimate software reliability. The technique is illustrated in terms of an example.", "num_citations": "19\n", "authors": ["1581"]}
{"title": "A methodology for programming scalable architectures\n", "abstract": " In scalable concurrent architectures, the performance of a parallel algorithm depends on the resource management policies used. Such policies determine, for example, how data is partitioned and distributed and how processes are scheduled. In particular, the performance of a parallel algorithm obtained by using a particular policy can be affected by increasing the size of the architecture or the input. In order to support scalability, we are developing a methodology for modular specification of partition and distribution strategies (PDSs). As a consequence, a PDS may be changed without modifying the code specifying the logic of a parallel algorithm. We illustrate our methodology for parallel algorithms that use dynamic data structures.", "num_citations": "19\n", "authors": ["1581"]}
{"title": "Actors programming for the mobile cloud\n", "abstract": " Actor programming languages provide the kind of inherent parallelism that is needed for building applications in the mobile cloud. This is because the Actor model provides encapsulation (isolation of local state), fair scheduling, location transparency, and locality of reference. These properties facilitate building secure, scalable concurrent systems. Not surprisingly, very large-scale applications such as Facebook chat service and Twitter have been written in actor languages. The paper introduces the basics of the actor model and gives a high-level overview of the problem of coordination in actor systems. It then describes several novel methods for reasoning about concurrent systems that are both effective and scalable.", "num_citations": "18\n", "authors": ["1581"]}
{"title": "The time-keeping anomaly of energy-saving sensors: Manifestation, solution, and a structural monitoring case study\n", "abstract": " Saving energy is one of the principal challenges in wireless sensor networks. Dynamic voltage and frequency scaling (DVFS) is often used to reduce energy consumption in systems where sleep is not an option. We show that changing the CPU frequency introduces sudden changes in clock behavior, thereby affecting the time-keeping functionality. This anomalous phenomenon is observed in different sensor platforms and causes a loss of time synchronization among nodes that is unacceptable to applications such as structural health monitoring that require tightly synchronized clocks over extended periods. The paper provides experimental measurements of the clock value shift anomaly in three widely used wireless sensor platforms and its impact on clock synchronization costs. A general framework balancing the need to save energy against the need to keep clocks synchronized is developed. Our system is\u00a0\u2026", "num_citations": "18\n", "authors": ["1581"]}
{"title": "Towards context-aware web applications\n", "abstract": " In order to guarantee certain levels of QoS, a Web application needs to adapt itself to different execution contexts. However, because of the lack of coordination support in Web platforms, service providers respond to the challenge by simply providing multiple versions of a Web application, one for each context. We argue this top-down approach is neither efficient nor scalable: developing a context-specific application requires considerable effort and expertise while the ever-changing Internet never stops generating interesting contexts which can be exploited for better deployment. As an alternative, we propose a three-layer, bottom-up approach to building context-aware Web applications. At the bottom layer, we characterize a context-specific Web application with a particular component distribution plan which provides details for composing individual objects. In the middle layer, recursively defined\u00a0\u2026", "num_citations": "18\n", "authors": ["1581"]}
{"title": "An Actor-Based Framework for Real-Time Coordination\n", "abstract": " Programming language research should be driven by the needs of specific application domains, such as real-time embedded systems, multimedia, distributed data-base management applications, etc. For instance, most often large real-time applications involve distributed and concurrently but asynchronously operating devices. The correctness of the integrated systems depends not only on the correct operation of each individual device, but also on the correct coordination among these devices. Furthermore, the correctness of device operation and cooperation requires that both the underlying logical computation be correct and the computation satisfy some notion of quantitative timing requirements.", "num_citations": "18\n", "authors": ["1581"]}
{"title": "High sensitivity environmental sensor board and methods for structural health monitoring\n", "abstract": " A smart sensor circuit board comprises an interface to a wireless smart sensor board platform, a multi-axis accelerometer having a measurement range and resolution set to provide sensitivity to measure ambient structural vibrations resulting from non-catastrophic routine environmental factors, an analog to digital converter (ADC) for converting signals from the multi-axis accelerometer having a plurality of individual channels including oversampling, filtering, and decimation, and each channel being individually programmable for gain, anti-aliasing, cut-off frequency, sampling, and frequency providing data to the interface, and a low noise and high sensitivity amplifier having the plurality of individual channels to receive signals from the multi-axis accelerometer.", "num_citations": "17\n", "authors": ["1581"]}
{"title": "Autonomous smart sensor network for full-scale structural health monitoring\n", "abstract": " The demands of aging infrastructure require effective methods for structural monitoring and maintenance. Wireless smart sensor networks offer the ability to enhance structural health monitoring (SHM) practices through the utilization of onboard computation to achieve distributed data management. Such an approach is scalable to the large number of sensor nodes required for high-fidelity modal analysis and damage detection. While smart sensor technology is not new, the number of full-scale SHM applications has been limited. This slow progress is due, in part, to the complex network management issues that arise when moving from a laboratory setting to a full-scale monitoring implementation. This paper presents flexible network management software that enables continuous and autonomous operation of wireless smart sensor networks for full-scale SHM applications. The software components combine sleep\u00a0\u2026", "num_citations": "17\n", "authors": ["1581"]}
{"title": "Coordination services for wireless sensor networks\n", "abstract": " Sensor readings need to be correlated in time and space and actuation needs to be synchronized to provide effective monitoring and protection of civil structures. To facilitate such coordination through self-organizing networked sensors, we are developing a range of middleware services such as time synchronization and node localization. Finally, we describe a scalable simulator that we are developing to assist application development on sensor networks. The simulator models three key aspects of a sensor network: the sensor nodes, the data network, and the environment with which the sensors interact. In the future we plan to interface the simulator with actual sensor nodes so that a variety of scenarios can be easily replayed for testing purposes.", "num_citations": "17\n", "authors": ["1581"]}
{"title": "SynchNet: a petri net based coordination language for distributed objects\n", "abstract": " We present SynchNet, a compositional meta-level language for coordination of distributed. Its design is based on the principle of separation of concerns, namely separation of the coordination from computational aspects. SynchNet can be used in combination with any object-based language capable of expressing sequential behavior of objects. SynchNet, which is inspired by Petri nets, has a simple syntax and semantics, but is expressive enough to code many of the commonly used coordination patterns. The level of abstraction that it provides allows tools and techniques developed for Petri nets to be readily applied to analysis and verification of the specified coordination patterns.", "num_citations": "17\n", "authors": ["1581"]}
{"title": "Modeling concurrent systems: Actors, nets, and the problem of abstraction and composition\n", "abstract": " This paper reviews the state of the art in building and reasoning about concurrent system using actors. We first provide a brief definition of actors and discuss the status of actor theory. We then describe a number of programming abstractions that are useful in developing and maintaining complex concurrent systems. Defining such abstractions requires a sort of system decomposition that is not supported by standard models of concurrency, including actors and nets. Rather a suitable meta-architecture is needed and its satisfactory formal definition remains elusive. We currently have only rudimentary semantics for the different programming abstractions that we have developed.", "num_citations": "17\n", "authors": ["1581"]}
{"title": "Architecture design principles to support adaptive service orchestration in WSN applications\n", "abstract": " Our goal is to facilitate the development of sensor network applications in an open system, where applications arrive and leave dynamically and execute concurrently. We identify design principles that govern the creation of these systems, such as having a network-wide programming model, late binding and global resource management. In accordance with these principles, we assume that an application is modeled as a composite service, and propose an architecture for its adaptive orchestration on a WSN. Adaptivity here refers to automatic runtime selection of service implementations and network resources to execute the application specification in a resource-efficient and context-aware manner.", "num_citations": "16\n", "authors": ["1581"]}
{"title": "Automated Verification of the Dependability of Object-Oriented Real-Time Systems\n", "abstract": " We develop an effective approach to formally specify and automatically verify the dependability of object-oriented real-time systems based on the Actor model and Real-Time Maude. Our approach decomposes an application into functional components represented as concurrent objects or actors, and separately specifies the timing constraints using RTSynchronizer. It achieves the goal of automatically verifying the dependability and timing properties of the target system by implementing the operational semantics of Actor and RTSynchronizer in Real-Time Maude, which supports executable specification and various temporal model checking analysis. We demonstrate the effectiveness of our approach by an annotated case study of the Simplex architecture.", "num_citations": "16\n", "authors": ["1581"]}
{"title": "Market-based coordination strategies for large-scale multi-agent systems\n", "abstract": " This paper studies market-based mechanisms for dynamic coordinated task assignment in large scale agent systems carrying out search and rescue missions. Specifically, the effect of different auction mechanisms and swapping are studied. The paper describes results from a large number of simulations of homogeneous agents, where by homogeneous we mean that agents in a given simulation use the same strategy. The information available to agents and their bidding strategies are used as simulation parameters. The simulations provide insight about the interaction between the strategy used by individual agents and the market mechanism. Performance is evaluated using several metrics: mission time, distance traveled, communication and computation costs, and workload distribution. Some of the results obtained include: limiting information may improve performance, different utility functions may affect the performance in non-uniform ways, and swapping may help improve the efficiency of assignments in dynamic environments.", "num_citations": "15\n", "authors": ["1581"]}
{"title": "Modeling a System of UAVs on a Mission\n", "abstract": " We outline a parametric model of a system of unmanned aerial vehicles (UAVs) on a mission. The UAVs have to accomplish their mission composed of several tasks as eciently as possible, while satisfying a heterogeneous set of physical and communication constraints. UAVs can be viewed as an example of a highly dynamic multi-agent system (MAS). These UAVs may be required to autonomously make decisions, communicate, coordinate, adapt to rapidly changing environments and eciently perform their tasks in real-time and under the limitations of local, incomplete and/or noisy knowledge of their surroundings. In particular, an individual UAV in our work can be viewed as an agent: it is autonomous, goal-driven, can aect and be aected by its environment, has its own behavior strategy, can communicate with its peers, and may nd it bene cial to cooperate and coordinate not only to avoid collisions, but also in order to accomplish its set of tasks more eectively. We focus herein on two aspects of agent-based modeling of UAVs: modeling autonomous decision-making of the individual vehicles viewed as autonomous agents, and dierent models of UAV coordination.", "num_citations": "15\n", "authors": ["1581"]}
{"title": "Modular construction and composition of distributed software architectures\n", "abstract": " A complete specification of a distributed software architecture describes two di erent aspects. First, it decomposes the software into its components and their interconnection. Second, it specifies the policies that are required to manage an architecture. Such policies are dependent on the nature of the execution environment. They are complicated by requirements such as heterogeniety, availability, and adaptability. Embedding architecture management policies in components and connectors sacrifices modularity. We describe an architecture description language, the Distributed Connection Language (dcl), for specifying distributed software architectures. Components in dcl are concurrent and distributed, and implement application functionality. Connectors specify policies governing component interactions and resource use. Thus connectors may specify load balancing or fault-tolerance policies. We base our\u00a0\u2026", "num_citations": "15\n", "authors": ["1581"]}
{"title": "Compositional development from reusable components requires connectors for managing both protocols and resources\n", "abstract": " Current component-based approaches for software architecture factor a system into a set of components, which encapsulate computation, and a set of connectors, which describe how components are integrated into the architecture. This separation of design concerns favors a compositional approach to system design; a methodology which is particularly important when specifying architectures for open (eg web-based) distributed systems. Heterogeneity, failure, and the potential for unpredictable interactions yield evolving systems which require complex management policies. Allowing architectural speci cations in which these policies are separated into abstract connectors has clear advantages for system design, veri cation and reuse. Note that policies for managing distributed systems (eg reliability protocols, load balance and placement, security constraints, coordination, etc.) not only assert properties on the connections between component interfaces, but must also enforce constraints on how resources are allocated to components. For example, a reliable server may be developed by adding a backup to an existing server and installing an instance of the primary backup protocol. In addition to recording interactions at the backup, the primary backup protocol must also ensure that the backup and server use separate, failure-independent resources (eg they must execute on separate processors). While component-based models have made great strides in recent years, we argue that the perceived gap between current middleware systems and the demands of large scale distributed applications is due in part to inadequate component models and\u00a0\u2026", "num_citations": "15\n", "authors": ["1581"]}
{"title": "Efficient algorithms for parallel sorting on mesh multicomputers\n", "abstract": " We present two new parallel algorithms QSP1 and QSP2 based on sequential quicksort for sorting data on a mesh multicomputer, and analyze their scalability using the isoefficiency metric. We show that QSP2 matches the lower bound on the isoefficiency function for mesh multicomputers, while QSP1 is fairly close to optimal. Langet al. (1) and Schnorret al. (2) have developed parallel sorting algorithms for the mesh architecture that have either optimal (Schnorr) or close to optimal (Lang) run-time complexity for the one-element-perprocessor case. Both QSP1 and QSP2 have better scalability than the scaled-down variants of these algorithms (for the case in which there are more elements than processors). We also analyze a different variant of Lang's sort which is as scalable as QSP2. We briefly discuss another metric called \u201cresource consumption.\u201d According to this metric, both QSP1 and QSP2 are\u00a0\u2026", "num_citations": "15\n", "authors": ["1581"]}
{"title": "Schedulability analysis of distributed real-time sensor network applications using actor-based model checking\n", "abstract": " Programmers often use informal worst-case analysis and debugging to ensure schedules that satisfy real-time requirements. Not only can this process be tedious and error-prone, it is inherently conservative and thus likely to lead to an inefficient use of resources. We propose to use model checking to find a schedule which optimizes the\u00a0use of resources while satisfying real-time requirements. Specifically, we represent a Wireless sensor and actuator network (WSAN) as a collection of actors whose behavior is specified using a C-based actor language extended with operators for real-time scheduling and delay representation. We show how the abstraction and compositionality properties of the actor model may be used to incrementally build a model of a WSAN\u2019s behavior from node-level and network models. We demonstrate the approach with a case study of a distributed real-time data acquisition system\u00a0\u2026", "num_citations": "14\n", "authors": ["1581"]}
{"title": "Random forest based coarse locating and kpca feature extraction for indoor positioning system\n", "abstract": " With the fast developing of mobile terminals, positioning techniques based on fingerprinting method draw attention from many researchers even world famous companies. To conquer some shortcomings of the existing fingerprinting systems and further improve the system performance, on the one hand, in the paper, we propose a coarse positioning method based on random forest, which is able to customize several subregions, and classify test point to the region with an outstanding accuracy compared with some typical clustering algorithms. On the other hand, through the mathematical analysis in engineering, the proposed kernel principal component analysis algorithm is applied for radio map processing, which may provide better robustness and adaptability compared with linear feature extraction methods and manifold learning technique. We build both theoretical model and real environment for verifying the feasibility and reliability. The experimental results show that the proposed indoor positioning system could achieve 99% coarse locating accuracy and enhance 15% fine positioning accuracy on average in a strong noisy environment compared with some typical fingerprinting based methods.", "num_citations": "14\n", "authors": ["1581"]}
{"title": "Verifying the evolution of probability distributions governed by a DTMC\n", "abstract": " We propose a new probabilistic temporal logic, iLTL, which captures properties of systems whose state can be represented by probability mass functions (pmfs). Using iLTL, we can specify reachability to a state (i.e., a pmf), as well as properties representing the aggregate (expected) behavior of a system. We then consider a class of systems whose transitions are governed by a Markov Chain-in this case, the set of states a system may be in is specified by the transitions of pmfs from all potential initial states to the final state. We then provide a model checking algorithm to check iLTL properties of such systems. Unlike existing model checking techniques, which either compute the portions of the computational paths that satisfy a specification or evaluate properties along a single path of pmf transitions, our model checking technique enables us to do a complete analysis on the expected behaviors of large-scale systems\u00a0\u2026", "num_citations": "14\n", "authors": ["1581"]}
{"title": "International collaboration to develop a structural health monitoring system utilizing wireless smart sensor network and its deployment on a cable-stayed bridge\n", "abstract": " Wireless smart sensors (WSS) equipped with on-board computation and wireless communication capabilities are expected to provide rich information for structural health monitoring (SHM). While a large number of researchers have been contributing their efforts toward the realization of wireless smart sensor networks (WSSN), full-fledged implementation of WSSN for SHM has not yet been materialized. WSSN systems for SHM involve various research fields and require understanding in respective areas. Therefore, collaboration among researchers plays an important role in pursuing this inter-disciplinary research. Recent prevalence of inexpensive telecommunication systems facilitates close collaboration among international research groups. The authors in Japan, Korea, and the US with respective research strengths have been closely collaborating in WSSN development and its deployment on a cable-stayed\u00a0\u2026", "num_citations": "14\n", "authors": ["1581"]}
{"title": "Coordination Models and Languages: 12th International Conference, COORDINATION 2010, Amsterdam, The Netherlands, June 7-9, 2010, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 12th International Conference on Coordination Models and Languages, COORDINATION 2010, held in Amsterdam, The Netherlands, in June 2010, as one of the federated conferences on Distributed Computing Techniques, DisCoTec 2010. The 12 revised full papers presented were carefully reviewed and selected from 28 submissions. The papers cover a wide range of topics including the application of coordination in wireless systems; multicore scheduling; sensor networks; event processing; data flow networks; and railway interlocking.", "num_citations": "14\n", "authors": ["1581"]}
{"title": "DecisionQoS: an adaptive, self-evolving QoS arbitration module for storage systems\n", "abstract": " As a consequence of the current trend towards consolidating computing, storage and networking infrastructures into large centralized data centers, applications compete for shared resources. Open enterprise systems are not designed to provide performance guarantees in the presence of sharing; unregulated competition is very likely to result in a free-for-all where some applications monopolize resources while others starve. Rule-based solutions to the resource arbitration problem suffer from excessive complexity, brittleness, and limitations in their expressive power. We present DecisionQoS, a novel approach for arbitrating resources among multiple competing clients while enforcing QoS guarantees. DecisionQoS requires system administrators to provide a minimal, declarative amount of information about the system and the workloads running on it. That initial input is continuously refined and augmented at run\u00a0\u2026", "num_citations": "14\n", "authors": ["1581"]}
{"title": "A formal model for reasoning about adaptive QoS-enabled middleware\n", "abstract": " Systems that provide QoS-enabled services such as multimedia are subject to constant evolution - customizable middleware is required to effectively manage this change. Middleware services for resource management such as scheduling, protocols providing security and reliability, load balancing and stream synchronization, execute concurrently with each other and with application activities and can therefore potentially interfere with each other. To ensure cost-effective QoS in distributed systems, safe composability of resource management services is essential. In this paper we present a meta-architectural framework for customizable QoS-based middleware based on the actor model of concurrent active objects. Using TLAM, a semantic model for specifying and reasoning about components of open distributed systems, we show how a QoS brokerage service can be used to coordinate multimedia resource\u00a0\u2026", "num_citations": "14\n", "authors": ["1581"]}
{"title": "Linguistic support of receptionists for shared resources\n", "abstract": " This paper addresses linguistic issues that arise in providing support for shared resources in large scale concurrent systems. Our work is based on the Actor Model of computation which unifies the lambda calculus, the sequential stored-program and the object-oriented models of computation. We show how receptionists can be used to regulate the use of shared resources by scheduling their access and providing protection against unauthorized or accidental access. A shared financial account is an example of the kind of resource that needs a receptionist. Issues involved in the implementation of scheduling policies for shared resources are also addressed. The modularity problems involved in implementing servers which multiplex the use of physical devices illustrate how delegation aids in the implementation of parallel problem solving systems for communities of actors.", "num_citations": "14\n", "authors": ["1581"]}
{"title": "Modeling and analyzing real-time wireless sensor and actuator networks using actors and model checking\n", "abstract": " Programmers often use informal worst-case analysis and debugging to ensure that schedulers satisfy real-time requirements. Not only can this process be tedious and error-prone, it is inherently conservative and thus likely to lead to an inefficient use of resources. We propose to use model checking to find a schedule which optimizes the use of resources while satisfying real-time requirements. Specifically, we represent a Wireless sensor and actuator network (WSAN) as a collection of actors whose behaviors are specified using a Java-based actor language extended with operators for real-time scheduling and delay representation. We show how the abstraction mechanism and the compositionality of actors in the actor model may be used to incrementally build a model of a WSAN\u2019s behavior from node-level and network models. We demonstrate the approach with a case study of a distributed real-time data\u00a0\u2026", "num_citations": "13\n", "authors": ["1581"]}
{"title": "How well can congestion pricing neutralize denial of service attacks?\n", "abstract": " Denial of service protection mechanisms usually require classifying malicious traffic, which can be difficult. Another approach is to price scarce resources. However, while congestion pricing has been suggested as a way to combat DoS attacks, it has not been shown quantitatively how much damage a malicious player could cause to the utility of benign participants. In this paper, we quantify the protection that congestion pricing affords against DoS attacks, even for powerful attackers that can control their packets' routes. Specifically, we model the limits on the resources available to the attackers in three different ways and, in each case, quantify the maximum amount of damage they can cause as a function of their resource bounds. In addition, we show that congestion pricing is provably superior to fair queueing in attack resilience.", "num_citations": "13\n", "authors": ["1581"]}
{"title": "Building portable middleware services for heterogeneous cyber-physical systems\n", "abstract": " Software development in wireless sensor networks has traditionally focused on stand-alone applications statically linked with the operating system code, and relying on fixed models for scheduling, synchronization, and resource allocation. Middleware services and network protocols, are usually considered to be part of the operating system. As the number of available WSN platforms and operating systems grows, and the emergence of cyber-physical systems results in the creation of networks of hetrogeneous devices (sensor nodes, microcontrollers, mobile devices, etc.), portability and interoperation emerge as major considerations in the software development process. We propose breaking the tight integration between middleware services and the operating system. We demonstrate how adopting a service-oriented computing approach to WSN middleware services improves portability and enables the creation of\u00a0\u2026", "num_citations": "13\n", "authors": ["1581"]}
{"title": "Supporting reconfigurable object distribution for customized web applications\n", "abstract": " In current practice, Web applications are tightly coupled with the platforms that a particular service provider intends to support and the execution scenario envisioned at the design time. The resulting applications do not adapt well to all clients and runtime execution contexts. The goal of our research is to develop methods and software to support recon-figurable distributed applications which can be customized to specific requirements. We view a Web application as a composition of actors, ie distributed active objects, and apply techniques of generative programming to develop a virtual application framework which separates the logic of objects from aspects relevant to object distribution on different platforms. We describe ActorSpec, a specification system allowing programmers to express desired object distribution and assisting application generators to produce highly customized versions of an application. The\u00a0\u2026", "num_citations": "13\n", "authors": ["1581"]}
{"title": "Parallel vs. Sequential Threshold Cellular Automata: Comparison and Contrast\n", "abstract": " Cellular automata (CA) are an abstract model of a distributed dynamical system, as well as of fine-grain parallelism in computing. In a classical cellular automaton, all the nodes execute their operations in parallel and in perfect synchrony. We consider herewith the sequential version of CA, called SCA, and compare those SCA with the classical, parallel CA. In particular, we show that there are 1D CA with very simple node update rules that cannot be simulated by any comparable SCA, irrespective of the node update ordering. Consequently, the granularity of the basic CA operations and, therefore, the fine-grain parallelism of the classical, synchronous CA, insofar as the \u201cinterleaving semantics\u201d is concerned, turns out to be not fine enough. We also study in some detail the properties of the cellular automata whose nodes update their states according to the Majority update rule. Finally, we share some thoughts on how to extend the presented results, and, in particular, we try to motivate the study of genuinely asynchronous cellular automata.", "num_citations": "13\n", "authors": ["1581"]}
{"title": "Adaptive agent allocation for massively multi-agent applications\n", "abstract": " Although distributed computing is necessary to execute massively multi-agent applications, the distribution of agents is challenging especially when the communication patterns among agents are continuously changing. This paper proposes two adaptive agent allocation mechanisms for massively multi-agent applications: one mechanism aims at minimizing agent communication cost, while the other mechanism attempts to prevent overloaded computer nodes from negatively affecting overall performance. We synthesize these two mechanisms in a multi-agent framework called Adaptive Actor Architecture (AAA). In AAA, each agent platform monitors the workload of its computer node and the communication patterns of agents executing on it. An agent platform periodically reallocates agents according to their communication localities. When an agent platform is overloaded, the platform migrates a set of\u00a0\u2026", "num_citations": "13\n", "authors": ["1581"]}
{"title": "iLTLChecker: a probabilistic model checker for multiple DTMCs\n", "abstract": " iLTL is a probabilistic temporal logic that can specify properties of multiple discrete time Markov chains (DTMCs). In this paper, we describe two related tools: MarkovEstimator a tool to estimate a Markov transition matrix, and iLTLChecker, a tool to model check iLTL properties of DTMCs. These tools work together to verify iLTL properties of DTMCs.", "num_citations": "12\n", "authors": ["1581"]}
{"title": "AutoLoop: automated action selection in the\" observe-analyze-act\" loop for storage systems\n", "abstract": " Enterprise applications typically depend on guaranteed performance from the storage subsystem, lest they fail. However, changes in the workload characteristics, component failures, load surges, are unlikely to result in guaranteed performance for the applications. Given that widespread access protocols and scheduling policies are largely best-effort, the problem of meeting performance goals on a shared system is a very difficult one, and currently accomplished by human administrators, using a 24 /spl times/ 7 observe-analyze-act (OAA) loop. AutoLoop is an OAA automation framework that uses a combination of self-refining models and constrained optimization techniques. This paper gives an overview of the automation process, and focuses on the analyze aspect of the loop that selects the corrective action. The process of action selection today is \"black magic\" - human administrators use their years of\u00a0\u2026", "num_citations": "12\n", "authors": ["1581"]}
{"title": "Scalable agent distribution mechanisms for large-scale UAV simulations\n", "abstract": " A cluster of computers is required to execute large-scale multi-agent. However, such execution incurs an inter-node communication overhead because agents intensively communicate with other agents to achieve common goals. Although a number of dynamic load balancing mechanisms have been developed, these mechanisms are not scalable in multi-agent applications because of the overhead involved in analyzing the communication patterns of agents. This paper proposes two scalable dynamic agent distribution mechanisms; one mechanism aims at minimizing agent communication cost, and the other mechanism attempts to move agents from overloaded agent platforms to lightly loaded platforms. Our mechanisms are fully distributed algorithms and analyze only coarse-grain communication dependencies of agents, thus providing scalability. We describe the results of applying these mechanisms to large\u00a0\u2026", "num_citations": "12\n", "authors": ["1581"]}
{"title": "A modular approach to real-time synchronization\n", "abstract": " In this paper, we discuss real-time barrier synchronization as an example of timing constraints on synchronization. Real-time barrier synchronization is constrained by two timing values: earliest release time and release time skew. Earliest release time is the delay from the time when the last object participating in barrier synchronization issues a barrier operation, till when one of the participating objects resumes its method. Release time skew is the delay between the first and the last resumption times of objects. The implementation of real-time barrier synchronization consists of a negotiation phase and a scheduling phase. In the negotiation phase, all the participating objects communicate with one another and agree on the time when they are going to resume their method execution. Local scheduling at individual nodes must then ensure that the agreement is implemented. Thus, earliest release time and release\u00a0\u2026", "num_citations": "12\n", "authors": ["1581"]}
{"title": "Avoiding energy wastage in parallel applications\n", "abstract": " We propose a methodology to analyze algorithms in order to reduce energy waste in executing applications. Our methodology is based on three observations. First, the relation between power and frequency of a single core is approximately cubic. Thus it may be possible to run an application slower on a core in order to save energy. In the case of a parallel architecture, one has to also factor the effect (on performance and energy consumption) of the interaction between cores. Second, multicore architectures which aggressively manage power consumption by allowing cores to be operated at reduced frequencies are being developed. This means that parallel applications on a multicore architecture can be executed using a variable number of cores running at different frequencies-affecting both the performance of the application and the energy required to execute it. Lastly, there is a certain benefit (positive utility) in\u00a0\u2026", "num_citations": "11\n", "authors": ["1581"]}
{"title": "Structural health monitoring for bridge structures using wireless smart sensors\n", "abstract": " Structural health monitoring (SHM) has drawn significant attention in recent decades because of its potential to reduce maintenance costs and increase the reliability of structures. An important class of structures that can potentially benefit from SHM are bridges, many of which are structurally deficient due to lack of adequate maintenance. Through condition assessment of these bridges, an effective plan of maintenance can be determined, offering the possibility to prolong service life, as well as to prevent catastrophic disasters due to sudden collapse. To date, numerous damage detection algorithms have been proposed. Still, challenges remain in applying such algorithms to monitor bridges in the field. In reality, the extent of an SHM system is limited by available budgets, which define the number of sensors that can be deployed.", "num_citations": "11\n", "authors": ["1581"]}
{"title": "Energy-performance trade-off analysis of parallel algorithms\n", "abstract": " Energy consumption by computer systems has emerged as an important concern, both at the level of individual devices (limited battery capacity in mobile systems) and at the societal level (the production of Green House Gases). In multicore architectures, applications may be executed on a variable number of cores and these cores may operate at different frequencies. The performance and energy cost of a parallel algorithm executing on a multicore architecture have different trade-offs, depending on how many cores the algorithm uses, at what frequencies these cores operate, and the structure of the algorithm. We show how algorithm designers and software developers can analyze the energy-performance trade-off in parallel algorithms. We believe that such analyses should be applied to parallel algorithms to facilitate energy conservation.", "num_citations": "11\n", "authors": ["1581"]}
{"title": "Dynamic macroprogramming of wireless sensor networks with mobile agents\n", "abstract": " Wireless Sensor Networks (WSNs) are a key enabling technology for Ambient Intelligence. Macroprogramming has been proposed as a technique for facilitating programming WSNs, but current solutions do not provide the combination of dynamicity and query specification that would be useful to domain experts. We have implemented the first query engine which provides both these features. Our system leverages AI methods such as multiagent systems and sophisticated meta-level knowledge representation techniques to keep track of the domain knowledge and to enable adaptation in query processing. Such adaptations include dynamic representations, transformations, optimizations and deployment strategies translating queries into a system of automatically generated mobile actors in a WSN.", "num_citations": "11\n", "authors": ["1581"]}
{"title": "Dynamic agent allocation for large-scale multi-agent applications\n", "abstract": " Although distributed computing is necessary to execute largescale multi-agent applications, the distribution of agents is challenging especially when the communication pattern among agents is continuously changing. This paper proposes two dynamic agent allocation mechanisms for large-scale multi-agent applications. The aim of one mechanism is to minimize agent communication cost, while that of the other mechanism is to prevent overloaded computer nodes from negatively affecting overall performance. In this paper, we synthesize these two mechanisms in a multi-agent framework called Adaptive Actor Architecture (AAA). In AAA, each agent platform monitors the workload of its computer node and the communication pattern of agents executing on it. An agent platform periodically reallocates agents according to their communication localities. When an agent platform is overloaded, the agent platform migrates a set of agents, which have more intra-group communication than inter-group or inter-node communication, to a relatively underloaded agent platform. These agent allocation mechanisms are developed as fully distributed algorithms, and they may move the selected agents as a group. In order to evaluate these mechanisms, preliminary experimental results with large-scale micro UAV (Unmanned Aerial Vehicle) simulations are described.", "num_citations": "11\n", "authors": ["1581"]}
{"title": "ATSpace: a middle agent to support application oriented matchmaking and brokering services\n", "abstract": " An important problem for agents in open multiagent systems is how to find agents that match certain criteria. A number of middle agent services - such as matchmaking and brokering services - have been proposed to address this problem. However, the search capabilities of such services are relatively limited since the match criteria they use are relatively inflexible. We propose ATSpace, a model to support application-oriented matchmaking and brokering services. Application agents in ATSpace deliver their own search algorithms to a public tuple space which holds agent property data; the tuple space executes the search algorithms on this data. We show how the ATSpace model increases the dynamicity and flexibility of a middle agent service. Unfortunately, the model also introduces security threats: the data and access control restrictions in ATSpace may be compromised, and system availability may be affected\u00a0\u2026", "num_citations": "11\n", "authors": ["1581"]}
{"title": "An adaptive programming framework for Web applications\n", "abstract": " Web applications service a gamut of users with a mix of static and dynamic resources: requests come from different devices running different Web agents (typically, Web browsers) with different capabilities. In a majority of such interactions, services are embedded in an HTML page and displayed on a Web browser. Consequently, Web application development has been tightly coupled with the platforms that a particular site intends to support; application developers have been asked to decide \"where to run what\" at design time to develop services using location-specific technologies and interweave them with static resources. Such difficulties stem from lack of adequate infrastructural support for platform-agnostic development and deployment framework. This paper presents the design and implementation of a framework for Web application development which hides the heterogeneity of the Internet and the\u00a0\u2026", "num_citations": "11\n", "authors": ["1581"]}
{"title": "Understanding and Modeling Agent Autonomy in Dynamic, Multi-Agent, Multi-Task Environments\n", "abstract": " Applications where collection of agents reside in dynamically changing environments and are required to accomplish various tasks in real time pose a number of modeling, design and analysis challenges. These challenges include finding appropriate models for coordination and cooperation among the agents, and for individual agent's adaptability and autonomy. This paper chiefly focuses on understanding and modeling individual agent's autonomy. First we try to identify those characteristics that distinguish autonomous agents from other types of agents. We consider autonomy to be a capability of goal-directed individual decision making in presence of uncertainty, incomplete knowledge and/or noise. An autonomous agent is viewed as a pro-active, goal-driven and generally selfish entity, and its autonomous decision making, together with other capabilities such as adaptability and cooperation with other agents, enables the agent to meaningfully strive to maximize its appropriately defined individual expected payoff. We illustrate the general ideas about agent autonomy with an example of autonomous unmanned aerial vehicles (UAVs) on a multi-task mission viewed as a real-time multi-agent system.", "num_citations": "11\n", "authors": ["1581"]}
{"title": "Parallel implementations of irregular problems using high-level actor language\n", "abstract": " We present our experience in implementing several irregular problems using a high-level actor language. The problems studied require dynamic computation of object placement and may result in load imbalance as the computation proceeds, thereby requiring dynamic load balancing. The algorithms are expressed as fine-grained computations providing maximal flexibility in adapting the computation load to arbitrary parallel architectures. Such an algorithm may be composed of different partitioning and distribution strategies (PDSs) to result in different performance characteristics. The PDSs are implemented for specific data structures or algorithms and are reusable for different parallel algorithms. We demonstrate how our methodology provides portability of algorithm specification, reusability and ease of expressibility.", "num_citations": "11\n", "authors": ["1581"]}
{"title": "High sensitivity environmental sensor network and network services for structural health monitoring\n", "abstract": " A high sensitivity structural health monitoring network includes a plurality of sensor nodes disposed apart from each other and communicating through one or more sensor channels. The nodes include smart sensor circuit boards with an interface to a wireless smart sensor board platform, a multi-axis accelerometer having a measurement range and resolution set to provide sensitivity to measure ambient structural vibrations an analog to digital converter for converting signals that includes a plurality of individual channels being individually programmable for signal conditioning for providing data to the interface. A network framework provides network services including a time synchronization service with network-wide global timestamps for sensor data and a unified sensing service that supports collection of data for all sensor channels from all nodes together with a single set of associated time stamps.", "num_citations": "10\n", "authors": ["1581"]}
{"title": "A novel technique for human traffic based radio map updating in Wi-Fi indoor positioning systems\n", "abstract": " With the fast-developing of mobile terminals, positioning techniques based on fingerprinting method draws attention from many researchers even world famous companies. To conquer some shortcomings of the existing fingerprinting systems and further improve its performance, we propose a radio map building and updating technique, which is able to customize the spatial and temporal dependency of radio maps. The method includes indoor propagation and penetration modeling and the analysis of human traffic. Based on the combination of Ray-Tracing Algorithm, Finite-Different Time-Domain and Rough Set Theory, the approach of indoor propagation modeling accurately represents the spatial dependency of the radio map. In terms of temporal dependency, we specifically study the factor of moving people in the interest area. With measurement and statistics, the factor of human traffic is introduced as the temporal updating component. We improve our existing indoor positioning system with the proposed building and updating method, and compare the localization accuracy. The results show that the enhanced system can conquer the influence caused by moving people, and maintain the confidence probability stable during week, which enhance the actual availability and robustness of fingerprinting-based indoor positioning system.", "num_citations": "10\n", "authors": ["1581"]}
{"title": "On the energy complexity of parallel algorithms\n", "abstract": " For a given algorithm, the energy consumed in executing the algorithm has a nonlinear relationship with performance. In case of parallel algorithms, energy use and performance are functions of the structure of the algorithm. We define the asymptotic energy complexity of algorithms which models the minimum energy required to execute a parallel algorithm for a given execution time as a function of input size. Our methodology provides us with a way of comparing the orders of (minimal) energy required for different algorithms and can be used to define energy complexity classes of parallel algorithms.", "num_citations": "10\n", "authors": ["1581"]}
{"title": "Market-based coordination strategies for physical multi-agent systems\n", "abstract": " Market-based mechanisms for real-time dynamic coordinated task assignment of physical multi-agent systems are studied. Specifically, a number of auction mechanisms and bidding strategies, as well as swapping, are considered. The physical robot experiments require addressing real-time and fault-tolerance issues in a dynamic environment. We provide a small scale validation for work with software simulations.", "num_citations": "10\n", "authors": ["1581"]}
{"title": "Security and fault-tolerance in distributed systems: an actor-based approach\n", "abstract": " The inherent complexity of real-world distributed applications makes developing and maintaining software for these systems difficult and error-prone. We describe an actor-based meta-level model to address the complexity of distributed applications. Specifically, meta-level framework allow code implementing different design concerns to be factored into separate modules-thus enabling the separate development and modification of code for different non-functional requirements such as security and fault-tolerance. This paper reviews current research based on the model and outlines some research directions.", "num_citations": "10\n", "authors": ["1581"]}
{"title": "A visualization model for concurrent systems\n", "abstract": " Concurrent systems maintain a distributed state and thus require coordination and synchronization between components to ensure consistency. To provide a coherent design approach to concurrent systems, recent work has employed an object-based methodology which emphasizes interactions through well-defined interfaces. The Actor model has provided formal reasoning about distributed object systems. Nonetheless, due to the complex interactions among components and the high volume of observable information produced, understanding and reasoning about concurrent algorithms in terms of simple interactions is a difficult task. Coordination patterns, which abstract over simple interactions, are not biased by low-level event orderings and are the appropriate mechanism for reasoning about concurrent algorithms. We outline a methodology for visualizing coordination patterns in concurrent algorithms which\u00a0\u2026", "num_citations": "10\n", "authors": ["1581"]}
{"title": "Performance evaluation of sensor networks by statistical modeling and euclidean model checking\n", "abstract": " Modeling and evaluating the performance of large-scale wireless sensor networks (WSNs) is a challenging problem. The traditional method for representing the global state of a system as a cross product of the states of individual nodes in the system results in a state space whose size is exponential in the number of nodes. We propose an alternative way of representing the global state of a system: namely, as a probability mass function (pmf) which represents the fraction of nodes in different states. A pmf corresponds to a point in a Euclidean space of possible pmf values, and the evolution of the state of a system is represented by trajectories in this Euclidean space. We propose a novel performance evaluation method that examines all pmf trajectories in a dense Euclidean space by exploring only finite relevant portions of the space. We call our method Euclidean model checking. Euclidean model checking is useful\u00a0\u2026", "num_citations": "9\n", "authors": ["1581"]}
{"title": "Energy bounded scalability analysis of parallel algorithms\n", "abstract": " The amount of energy available in some contexts is strictly limited. For example, in mobile computing, available energy is constrained by battery capacity. As multicore processors with a large number of processors, it will be possible to significantly vary the number and frequency of cores used in order to manage the performance and energy consumption of an algorithm. We develop a method to analyze the scalability of an algorithm given an energy budget. The resulting energy-bounded scalability analysis can be used to optimize performance of a parallel algorithm executed on a scalable multicore architecture given an energy budget. We illustrate our methodology by analyzing the behavior of four parallel algorithms on scalable multicore architectures: namely, parallel addition, two versions of parallel quicksort, and a parallel version of Prim\u2019s Minimum Spanning Tree algorithm. We study the sensitivity of energy-bounded scalability to changes in parameters such as the ratio of the energy required for a computational operation versus the energy required for communicating a unit message. Our results shows that changing the number and frequency of cores used in a multicore architecture could significantly improve performance under fixed energy budgets.", "num_citations": "9\n", "authors": ["1581"]}
{"title": "State aware data dissemination over structured overlays\n", "abstract": " We describe the problem of data dissemination in stream-oriented applications where the required filter is a function of the current state. We call such functions dynamic filters. A state aware data dissemination network (SA-DDN) is proposed to support dynamic filters. Two approaches single-level filtering (SF) and multilevel filter decomposition (MFD) are proposed to facilitate the data dissemination. We show how MFD improves performance over SF. We then describe a realization of SA-DDN on top of an improved bi-directional Chord overlay with a built-in multicast mechanism. An application of stock price monitoring is implemented based on SA-DDN and real life stock quotes are collected to demonstrate the feasibility of our system. Extensive simulations are performed to compare the performance of both approaches and provide insight into the advantages of MFD", "num_citations": "9\n", "authors": ["1581"]}
{"title": "Actor model and knowledge management systems: Social interaction as a framework for knowledge integration\n", "abstract": " Expertise locator systems (ELS) are a special type of knowledge management systems that are used to help locate intellectual capital. The searchable answer-generating environment (SAGE) is an expertise locator system that was developed to identify experts in the state of Florida. This presentation describes an application of the actor model of computation to the development of expertise locator systems (ELS). The actor model describes an approach to modeling intelligence in terms of a society of communicating knowledge-based problem experts where each expert may in turn be viewed as a society of primitive actors. A conceptual implementation for SAGE, and ELS in general, based on the actor model as a design paradigm is described. Practical applications for an actor-model based ELS are also discussed.", "num_citations": "9\n", "authors": ["1581"]}
{"title": "On the computational complexity of predicting dynamical evolution of large agent ensembles\n", "abstract": " We study global behavior of large ensembles of simple reactive agents. We do so by applying computational complexity tools to the analysis of formal complex systems and their dynamics. Since we are interested in the global dynamics and emerging behavior of large agent ensembles, rather than in an individual agent\u2019s deliberation, learning or other cognitive abilities, the discrete complex systems we study are based on the communicating finite state machine (CFSM) abstraction. In particular, we show that counting the number of possible evolutions of a particular class of CFSMs is computationally intractable, even when those CFSMs are very severely restricted both in terms of an individual agent\u2019s behavior (that is, the local update rules), and the inter-agent interaction pattern (that is, the underlying communication network topology). We use this abstract framework to formally prove the well-known intuition about multi-agent systems (MAS) that a complex and, in general, unpredictable global behavior may arise from coupling of rather simple local behaviors and interactions.", "num_citations": "9\n", "authors": ["1581"]}
{"title": "Efficient compilation of concurrent call/return communication in actor-based programming languages\n", "abstract": " Concurrent call/return communication (CCRC) allows programmers to conveniently express a communication pattern where a sender invokes a remote operation and uses the result to continue its computation. The blocking semantics requires context switching for efficient utilization of computation resource. We present a compilation technique which allows programmers to use CCRC with the cost of non-blocking asynchronous communication plus minimum context switch cost. The technique transforms CCRCs into non-blocking asynchronous sends and encapsulates continuations into separate objects. A data flow analysis is used to guarantee that only necessary context is cached in continuation objects.", "num_citations": "9\n", "authors": ["1581"]}
{"title": "A modular approach for programming embedded systems\n", "abstract": " A real-time system not only must generate correct results, it must generate those results on time. In embedded systems, these results include control signals, actuator reactions, etc. Traditional approaches to the design and implementation of real-time embedded applications first transfer timing requirements into machine dependent operations using low level programming languages, such as Assembly or C. By intermixing functional behavior with timing behavior, low-level programming languages reduce the modularity and reusability of software components. For example, it is difficult to incrementally modify either existing application code to meet new functionality requirements, or the scheduling to meet changing hardware or network requirements. In order to address these difficulties, we develop a high-level language approach to support a stronger separation of design concerns. We use actors as a formal\u00a0\u2026", "num_citations": "9\n", "authors": ["1581"]}
{"title": "ActorSpaces: A model for scalable heterogeneous computing\n", "abstract": " The ActorSpace model is based on message passing, but allows the user to specify a more abstract destination of messages. This decouples individual actors from each other and makes ActorSpace well suited for expressing open distributed systems, which may run on different architectures. ActorSpace supports heterogeneous computing by using the message passing facilities as an encapsulation of the individual actor's state. ActorSpace supports an open system by using a pattern as a specification of the receiving group of actors. By using the ActorSpace communication primitives, executing actors will not be aware that other actors may be executing on different architectures. The result of this is that actors can join and later leave an ongoing computation or make use of an available service without a specific connection to a set of computing actors or a server.< >", "num_citations": "9\n", "authors": ["1581"]}
{"title": "Techniques for executing and reasoning about specification diagrams\n", "abstract": " Specification Diagrams (SD) [19] are a graphical notation for specifying the message passing behavior of open distributed object systems. SDs facilitate specification of system behaviors at various levels of abstraction, ranging from high-level specifications to concrete diagrams with low-level implementation details. We investigate the theory of may testing equivalence [15] on SDs, which is a notion of process equivalence that is useful for relating diagrams at different levels of abstraction. We present a semantic characterization of the may equivalence on SDs which provides a powerful technique to relate abstract specifications and refined implementations. We also describe our prototypical implementation of SDs and of a procedure that exploits the characterization of may testing to establish equivalences between finitary diagrams (without recursion).", "num_citations": "8\n", "authors": ["1581"]}
{"title": "A theory of may testing for actors\n", "abstract": " The Actor model and \u03c0-calculus have served as the basis of a large body of research on concurrency. We represent the Actor model as a typed asynchronous \u03c0-calculus, called A\u03c0. The type system imposes a certain discipline on the use of names to capture actor properties such as uniqueness and persistence. We investigate the notion of may testing in A\u03c0 and give a trace based characterization of it. Such a characterization simplifies reasoning about actor configurations as it does not involve quantification over all environments. We compare our characterization with that of asynchronous \u03c0-calculus, and highlight the differences that arise due to actor properties.", "num_citations": "8\n", "authors": ["1581"]}
{"title": "Parallel programming and complexity analysis using actors\n", "abstract": " We describe Actors, a flexible, scalable and efficient model of computation, and develop a framework for analyzing the parallel complexity of programs written in it. Actors are asynchronous, autonomous objects which interact by message-passing. The data and process decomposition inherent in Actors simplifies modeling real-world systems. High-level concurrent programming abstractions have been developed to simplify program development using Actors; such abstractions do not compromise an efficient and portable implementation. In this paper, we define a parallel complexity model for Actors. The model we develop gives an accurate measure of performance on realistic architectures. We illustrate its use by analyzing a number of examples.", "num_citations": "8\n", "authors": ["1581"]}
{"title": "The emerging tapestry of software engineering\n", "abstract": " Editor-in-Chief Director, Open System Labs Department of Computer Science University of Illinois 1304 W. Springfield Ave. Urbana, IL 61801 agha@ cs. uiuc. edu erate proliferation of dangerous guns. England, which has long licensed guns and which sends its police to the streets without guns, has recently moved to completely ban the possession of handguns by private individuals and gun clubs. I suppose one response is, that\u2019s nothing: you should see all the kinds of safety-critical software the US permits without making any pretense of trying to validate it! However, the fact is, certain relatively mature technologies for which effective tools have become available (for example, model checking) have been gaining ground in industrial practice in much of the world, including the US. A reasonable conjecture is that when formal methods are integrated with softwareengineering tools, their acceptance is facilitated.", "num_citations": "8\n", "authors": ["1581"]}
{"title": "Space division and dimensional reduction methods for indoor positioning system\n", "abstract": " With the popularity of smart phones and the development of mobile computing, indoor positioning services have triggered large scale of technology innovation and commercial cooperation. In the field of Wi-Fi based fingerprinting positioning system, for one thing, we deploy space division method based on Random Forest for dividing the fingerprinting radio map into sub regions freely and classifying candidate points accurately. For another thing, we propose a dimension reduction method, which integrates Maximum Likelihood Estimation for estimating intrinsic dimensionality and Kernel Principal Component Analysis for feature extraction, to tremendously reduce the size of a radio map, thereby saving terminal storage and alleviating error margin. Compared with linear feature extraction methods and manifold learning techniques, the proposed method shows a better performance in low dimension. The experimental\u00a0\u2026", "num_citations": "7\n", "authors": ["1581"]}
{"title": "Integrating Encrypted Mobile Agents with Smart Spaces in a Multi-agent Simulator for Resource Management.\n", "abstract": " The existence of advanced smart devices and related technologies such as pervasive computing, mobile wireless communications, sensor networks and agent technologies have supported the proliferation of smart spaces. In this paper, we present the design of \u201cBosthan\u201d, a multi-agent-based simulation tool that manages resources consumption in multi-inhabitants smart spaces. Bosthan is built on the top of ActorNet mobile agent platform to simulate different smart space topologies with varying numbers of residents. It allows strategies for resolution of conflicts between mobile agents, and for preserving inhabitants\u2019 anonymity and untraceability inside the smart spaces, to be studied. Bosthan will help us compare the efficiency of using mobile agents to allow smart spaces to act pro-actively and maintain anonymity and data privacy in multi-inhabitants environments", "num_citations": "7\n", "authors": ["1581"]}
{"title": "Smart sensing technology: a new paradigm for structural health monitoring\n", "abstract": " The computational and wireless communication capabilities of smart sensors densely distributed over structures can provide rich information for structural monitoring. While smart sensor technology has seen substantial advances during recent years, interdisciplinary efforts to address issues in sensors, networks, and application specific algorithms are needed to realize their full potential. This paper first reports on research that addresses each of these issues and then integrates this research to provide a new structural health monitoring (SHM) system that is suitable for implementation on a network of smart sensors. Experimental verification is provided using Intel\u2019s Imote2 installed on a three-dimensional truss structure. The Imote2 is employed herein because it has the high computational and wireless communication performance required for advanced SHM applications. The efficacy of this SHM system is then demonstrated from sensing, network, and SHM algorithm perspectives.", "num_citations": "7\n", "authors": ["1581"]}
{"title": "A flexible coordination framework for application-oriented matchmaking and brokering services\n", "abstract": " An important problem for agents in open multiagent systems is how to find agents that match certain criteria. A number of middle agent services, such as matchmaking and brokering services, have been proposed to address this problem. However, the search capabilities of such services are relatively limited since the match criteria they use are relatively inflexible. We propose ATSpace, a middle agent to support application-oriented matchmaking and brokering services. Application agents in ATSpace deliver their own search algorithms to a public tuple space which holds agent property data; the tuple space executes the search algorithms on this data. We show how the ATSpace model increases the dynamicity and flexibility of middle agent services. Unfortunately, the model also introduces security threats: the data and access control restrictions in ATSpace may be compromised, and system availability may be affected. We describe some mechanisms to mitigate these security threats.", "num_citations": "7\n", "authors": ["1581"]}
{"title": "A theory of may testing for asynchronous calculi with locality and no name matching\n", "abstract": " We present a theory of may testing for asynchronous calculi with locality and no name matching. Locality is a non-interference property that is common in systems based on object-paradigm. Concurrent languages such as Join and Pict disallow name matching, which is akin to pointer comparison in imperative languages, to provide for an abstract semantics that would allow useful program transformations. May testing is widely acknowledged to be an effective notion for reasoning about safety properties. We provide a trace-based characterization of may testing for versions of asynchronous \u03c0-calculus with locality and no name matching, which greatly simplifies establishing equivalences between processes. We also exploit the characterization to provide a complete axiomatization for the finitary fragment of the calculi.", "num_citations": "7\n", "authors": ["1581"]}
{"title": "Automated inference of atomic sets for safe concurrent execution\n", "abstract": " Atomic sets are a synchronization mechanism in which the programmer specifies the groups of data that must be accessed as a unit. The compiler can check this specification for consistency, detect deadlocks, and automatically add the primitives to prevent interleaved access. Atomic sets relieve the programmer from the burden of recognizing and pruning execution paths which lead to interleaved access, thereby reducing the potential for data races. However, manually converting programs from lock-based synchronization to atomic sets requires reasoning about the program's concurrency structure, which can be a challenge even for small programs. Our analysis eliminates the challenge by automating the reasoning. Our implementation of the analysis allowed us to derive the atomic sets for large code bases such as the Java collections framework in a matter of minutes. The analysis is based on execution traces\u00a0\u2026", "num_citations": "6\n", "authors": ["1581"]}
{"title": "Cyberorgs: A model for decentralized resource control in multi-agent systems\n", "abstract": " Competition and collaboration among agents in a multi-agent system extends to consumption of computational resources. Management of resource sharing is critical to the performance of multi-agent computations. We describe CyberOrgs, a hierarchical model for resource sharing between and within multi-agent computations executing over a network of computers. We introduce programming abstractions derived from the model through a prototype implementation of CyberOrgs as an Actor program.", "num_citations": "6\n", "authors": ["1581"]}
{"title": "A Fine-Grained Adaptive Middleware Framework for Parallel Mobile Hybrid Cloud Applications\n", "abstract": " Mobile Cloud Computing (MCC) overcomes mobile device limitations by delegating tasks to more capable cloud spaces. Existing mobile offloading solutions generally rely on full virtual machine migration, which is coarse-grained and costly, or implementation of code offloading as part of the application logic, which greatly increases the application complexity and the associated software development costs. Some recent solutions implement fine-grained offloading, but pause the local mobile application while waiting for the offloaded code results. This leads to sequential execution and wastes local mobile resources and ignores the potential elasticity of the cloud environment. We have developed the IMCM framework to support parallel mobile application offloading to multiple cloud spaces. IMCM is finegrained, supporting application distribution at the granularity of individual components; it is adaptive, addressing the dynamicity in run-time conditions and end-user contexts; and it is fully parallel, supporting both parallel application model and simultaneous execution at mobile device and multiple private and public cloud spaces. Our evaluation results show that IMCM can improve the performance of computationally intensive mobile applications by a factor of over 50, while masking the underlying complexity of mobile-to-cloud code offloading.", "num_citations": "6\n", "authors": ["1581"]}
{"title": "Types for progress in actor programs\n", "abstract": " Properties in the actor model can be described in terms of the message-passing behavior of actors. In this paper, we address the problem of using a type system to capture liveness properties of actor programs. Specifically, we define a simple actor language in which demands for certain types of messages may be generated during execution, in a manner specified by the programmer. For example, we may want to require that each request to an actor eventually results in a reply. The difficulty lies in that such requests can be generated dynamically, alongside the associated requirements for replies. Such replies might be sent in response to intermediate messages that never arrive, but the property may also not hold for more trivial reasons; for instance, when the code of potential senders of the reply omit the required sending command in some branches of a conditional statement. We show that, for a\u00a0\u2026", "num_citations": "5\n", "authors": ["1581"]}
{"title": "An architecture for dynamic service-oriented computing in networked embedded systems\n", "abstract": " Software development in real-time and embedded systems has traditionally focused on stand-alone applications with static models for scheduling and resource allocation. Our goal is to facilitate the development of embedded applications in an open system, where tasks and resources arrive and leave dynamically, and their execution is concurrent. We model such applications as a dynamic composition of network services. This paper presents an enabling framework for dynamic service orchestration in cyber-physical systems, based on a modular, reusable, and extensible service-oriented architecture. By taking advantage of a network-wide programming model, adaptive global resource management, and late binding of tasks to resources, the architecture enables execution of dynamic embedded application workloads in a resource-efficient manner.", "num_citations": "5\n", "authors": ["1581"]}
{"title": "Formal Modeling: Actors; Open Systems, Biological Systems: Essays Dedicated to Carolyn Talcott on the Occasion of Her 70th Birthday\n", "abstract": " This Festschrift volume, published in honor of Carolyn Talcott on the occasion of her 70th birthday, contains a collection of papers presented at a symposium held in Menlo Park, California, USA, in November 2011. Carolyn Talcott is a leading researcher and mentor of international renown among computer scientists. She has made key contributions to a number of areas of computer science including: semantics and verification of progamming languages; foundations of actor-based systems; middleware, meta-architectures, and systems; Maude and rewriting logic; and computational biology. The 21 papers presented are organized in topical sections named: Essays on Carolyn Talcott; actors and programming languages; cyberphysical systems; middleware and meta-architectures; formal methods and reasoning tools; and computational biology.", "num_citations": "5\n", "authors": ["1581"]}
{"title": "Reflecting on aspect-oriented programming, metaprogramming, and adaptive distributed monitoring\n", "abstract": " Metaprogramming and computational reflection are two related techniques that allow the programmer to change the semantics of a program in a modular fashion. Although the concepts have been explored by researchers for some time, a form of metaprogramming, namely aspect-oriented programming, is now being used by some practitioners. This paper is an attempt to understand the limitations of different forms of computational reflection in concurrent and distributed computing. It specifically studies the use of aspect-oriented programming and reflective actor libraries, and their relation to full reflection. We choose distributed monitoring as the primary example application because its requirements nicely fit the abilities of the two systems as well as illustrate their limitations.", "num_citations": "5\n", "authors": ["1581"]}
{"title": "A theory of testing for asynchronous concurrent systems\n", "abstract": " Testing equivalence is a notion of process equivalence that is widely used for establishing semantic correspondence between concurrent systems. Testing equivalence can be used to formally establish the fact that a given system is a safe or live implementation of an abstract specification. However, since the definition of testing equivalence involves a universal quantification over all possible contexts, proving equivalences between processes is a difficult task. In this dissertation, we present a collection of proof techniques and decision procedures for establishing testing equivalences between asynchronous concurrent systems.", "num_citations": "5\n", "authors": ["1581"]}
{"title": "Systematic Customization of Middleware\n", "abstract": " The urgent need to deal with problems that are frequently met in many di erent families of application led to the evolution and standardization of a software layer that lies between the application and the underlying operating system. This layer is widely known as middleware, and provides reusable solutions to problems like heterogeneity, interoperability, security, transactions, fault tolerance etc. Middleware is typically build based on services provided by an infrastructure. Well known examples of such infrastructures are those complying to the Corba standard, Dcom, Ejb etc. Implementing software based on the reusable solutions provided by middleware infrastructures certainly reduces the cost of the overall software development process. Developers are released from implementing communication protocols, security policies, transaction models. Given a middleware infrastructure, all they have to do is combine available middleware services in a way that satis es the requirements of a particular application. Hence, their e ort is now focused on the design of a middleware architecture that satis es the application requirements.This thesis proposes using the software architecture paradigm for the systematic customization of middleware. More speci cally, it proposes using an architecture description language, together with adequate tool support for designing a middleware architecture that meets requirements of an application, integrating this middleware architecture within the application, and maintaining this middleware architecture with respect to changes in the application requirements and the availability of middleware services.", "num_citations": "5\n", "authors": ["1581"]}
{"title": "A metaobject framework for qos-based distributed resource management\n", "abstract": " Systems that provide distributed multimedia services are subject to constant evolution-customizable middleware is required to effectively manage this change. In this paper we present a meta-architectural framework for customizable QoS-based middleware using Actors, a model of concurrent active objects. Middleware services for resource management execute concurrently with each other and with application activities\u2014scheduling, protocols providing security and reliability, load balancing and stream synchronization can therefore potentially interfere with each other. To ensure cost-effective QoS in distributed multimedia systems, safe composability of resource management services is essential. For instance, system protocols and activities must not cause arbitrary delays in the presence of timing based QoS constraints. Using TLAM, a semantic model for specifying and reasoning about components of open distributed systems, we show how a QoS brokerage service can be used to coordinate multimedia resource management services in a safe, flexible and efficient manner.In the coming years, distributed multimedia servers will deployed to deliver a variety of interactive, digital multimedia (MM) services over emerging broadband (wide-area) networks [6] to form a wide-area infrastructure. Applications such as telemedicine, distance learning and electronic commerce exhibit varying requirements such as timeliness, security, reliability and availability. Many MM applications can tolerate minor, infrequent violations of their performance requirements specified as a quality-of-service (QoS) parameter, for eg, tolerable jitter in a video frame. Systems\u00a0\u2026", "num_citations": "5\n", "authors": ["1581"]}
{"title": "Implicit programming and the Logic of Constructible Duality\n", "abstract": " We present an investigation of duality in the traditional logical manner. We extend Nelson's symmetrization of intuitionistic logic, constructible falsity, to a self-dual logic--constructible duality. We develop a self-dual model by considering an interval of worlds in an intuitionistic Kripke model. The duality arises through how we judge truth and falsity. Truth is judged forward in the Kripke model, as in intuitionistic logic, while falsity is judged backwards.", "num_citations": "5\n", "authors": ["1581"]}
{"title": "Linguistic paradigms for programming complex distributed systems\n", "abstract": " Real-world systems consist of many distributed asynchronous components that are open to interaction with their environment. The functionality of such systems is not defined by evaluating an expression; instead, the relative state of the components, the timing of the results, and the nature of the interactions between components are all critical to the correctness of the system. The actor model provides a flexible method for representing computation in real-world systems. Actors extend the concept of objects to concurrent computation [Agha 1986]. Specifically, objects encapsulate a state and a set of procedures that manipulate the state; actors extend this by also encapsulating a thread of control. Each actor potentially executes in parallel with other actors and may send messages to actors of which it knows the addresses. Actor addresses may be communicated in messages, allowing dynamic interconnection. Finally\u00a0\u2026", "num_citations": "5\n", "authors": ["1581"]}
{"title": "Targeted test generation for actor systems\n", "abstract": " This paper addresses the problem of targeted test generation for actor systems. Specifically, we propose a method to support generation of system-level tests to cover a given code location in an actor system. The test generation method consists of two phases. First, static analysis is used to construct an abstraction of an entire actor system in terms of a message flow graph (MFG). An MFG captures potential actor interactions that are defined in a program. Second, a backwards symbolic execution (BSE) from a target location to an\" entry point\" of the actor system is performed. BSE uses the MFG constructed in the first phase of our targeted test generation method to guide execution across actors. Because concurrency leads to a huge search space which can potentially be explored through BSE, we prune the search space by using two heuristics combined with a feedback-directed technique. We implement our method in Tap, a tool for Java Akka programs, and evaluate Tap on the Savina benchmarks as well as four open source projects. Our evaluation shows that the Tap achieves a relatively high target coverage (78% on 1,000 targets) and detects six previously unreported bugs in the subjects.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Agere!(actors and agents reloaded) splash 2011 workshop on programming systems, languages and applications based on actors, agents and decentralized control\n", "abstract": " The fundamental turn of software into concurrency and distribution is not only a matter of performance, but also of appropriate design and abstraction. This calls for programming paradigms that would allow developers to think, design, develop, execute, debug, and profile programs exhibiting different degrees of concurrency, reactiveness, autonomy, decentralization of control, and distribution in ways that are more natural than that supported the current paradigms. This workshop aims at exploring programming approaches explicitly providing a level of abstraction that promotes a decentralized mindset in solving problems and programming systems exhibiting such features. To this end, the abstractions of actors and agents (and systems of actors/systems of agents) are taken as a natural reference: the objective of the workshop is then to foster the research in all aspects of actor-oriented programming and agent\u00a0\u2026", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Energy-performance trade-off analysis of parallel algorithms for shared memory architectures\n", "abstract": " Energy consumption by computer systems has emerged as an important concern. However, the energy consumed in executing an algorithm cannot be inferred from its performance alone; it must be modeled explicitly. This paper analyzes energy consumption of parallel algorithms executed on a model of shared memory multicore processors. Specifically, we develop a methodology to evaluate how energy consumption of a given parallel algorithm changes as the number of cores and their frequency is varied. We use this analysis to establish the optimal number of cores to minimize the energy consumed by the execution of a parallel algorithm for a specific problem size while satisfying a given performance requirement, and the optimal number of cores to maximize the performance of a parallel algorithms for a specific problem size under a given energy budget. We study the sensitivity of our analysis to changes in\u00a0\u2026", "num_citations": "4\n", "authors": ["1581"]}
{"title": "A multi-agent simulator for resource management in smart spaces\n", "abstract": " The existence of advanced smart devices and related technologies such as pervasive computing, mobile wireless communications, sensor networks and agent technologies have supported the proliferation of smart spaces. In this paper, we present the design of \u00bfBosthan\u00bf, a multi-agent-based simulation tool that manages resources consumption in multi-inhabitants smart spaces. Bosthan is built on the top of ActorNet mobile agent platform to simulate different smart space topologies with varying numbers of residents. It allows strategies for resolution of conflicts between mobile agents, and for preserving inhabitants' anonymity and untraceability inside the smart spaces, to be studied. Bosthan will help us compare the efficiency of using mobile agents to allow smart spaces to act pro-actively and maintain anonymity and data privacy in multi-inhabitants environments.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Exploiting system diversity in peer-to-peer publish-subscribe systems\n", "abstract": " This thesis presents new techniques that exploit system diversity within a particular class of peer-to-peer publish-subscribe systems. We show that by directly addressing interest and network diversity as a first class design principle, the scale and performance of such systems can be improved.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Debugging wireless sensor networks using mobile actors\n", "abstract": " Large-scale deployments of sensor networks can potentially serve as infrastructure for multiple, concurrent applications.  Realizing this potential requires tools for monitoring, debugging and repairing deployed wireless sensor networks (WSNs).  We propose an approach for post-mortem debugging of WSNs using autonomous and mobile actors.  By allowing the computation (mobile actor) to move to the nodes where the data is located, we overcome the necessity of moving the data while still providing the flexibility necessary to diagnose errors in WSNs.  We define two mechanisms for debugging--namely, forward tracking and backward tracking in which an actor, starting at an error state, tracks the causal events, respectively, forward or backward in time in order to determine the root cause of the error.  We show that mobile actors enable both forward and backward tracking, and these may be useful under different conditions.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "A study of coordinated dynamic market-based task assignment in massively multi-agent systems\n", "abstract": " This paper studies market-based mechanisms for coordinated dynamic task assignment in large-scale agent systems carrying out search and rescue missions. Specifically, the effect of different auction mechanisms and swapping are studied. The paper describes results from a large number of simulations.The information available to agents and their bidding strategies are used as simulation parameters. The simulations provide insight about the interaction between the strategy of individual agents and the market mechanism. Performance is evaluated using several metrics. Some of the results include: limiting information may improve performance, different utility functions may affect the performance in non-uniform ways, and swapping may help improve the efficiency of assignments in dynamic environments.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Decentralized resource control for multi-agent systems\n", "abstract": " In an open system, multi-agent computations must compete for resources required for satisfying their goals. We describe CyberOrgs, a hierarchical model for acquisition and control of resources for multi-agent systems in a market of resources. Programming abstractions and constructs are introduced for implementing systems of CyberOrgs. A prototype implementation of the model as an Actor program is described, and scheduling approaches for an efficient implementation are discussed.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Case studies in security and resource management for mobile object systems\n", "abstract": " Mobile objects have gained a lot of attention in research and industry in the recent past, but they also have a long history. Security is one of the key requirements of mobile objects, and one of the most researched characteristics related to mobility. Resource management has been somewhat neglected in the past, but it is being increasingly addressed, in both the context of security and QoS. In this paper we place a few systems supporting mobile objects in perspective based upon how they address security and resource management. We start with the theoretical model of Actors that supports concurrent mobile objects in a programming environment. Then we describe task migration for the Mach microkernel, a case of mobile objects supported by an operating system. Using the OMG MASIF standard as an example, we then analyze middleware support for mobile objects. Mobile Objects and Agents (MOA\u00a0\u2026", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Concurrent java\n", "abstract": " Editor-in-Chief Director, Open System Lab Department of Computer Science University of Illinois 1304 W. Springfield Ave. Urbana, Il 61801 agha@ cs. uiuc. edu right time to emerge as a standard for writing mobile code. Not too long ago, some pundits were forecasting the death of all operating systems except Windows and its incarnations. Now there is a new game is in town: the portability of Java, combined with the ease of programming and propagating code, has finally provided a competitor to the programming paradigm that relied on a specific set of operating-system calls. Some accuse Microsoft of wanting to create a flavor of Java that would keep it from being interoperable across platforms, to maintain its virtual monopoly on operating systems. Of particular interest in the emergence of Java is its implications for parallel-, distributed-, and mobile-computing systems. Such systems require careful management of\u00a0\u2026", "num_citations": "4\n", "authors": ["1581"]}
{"title": "The relation between problems in large-scale concurrent systems and distributed databases\n", "abstract": " We first describes the state of the art in models of concurrency. The models are analyzed along two dimensions: communication and computation. The paper then discusses some problems which make it difficult to realize largescale concurrent systems. Such problems in-clude compositionality, heterogeneity, debugging, resource management, and concurrency control. Some useful comparisons are drawn to problems in distributed databases and it is argued that solutions to these problems cross disciplinary boundaries. Finally, the paper discusses trends in building concurrent computers and provides some expectations for the future.", "num_citations": "4\n", "authors": ["1581"]}
{"title": "Concurrent garbage collection in the actor model\n", "abstract": " In programming languages where memory may be allocated dynamically, automatic garbage collection (GC) can improve the efficiency of program execution while preventing program errors caused by incorrectly removed memory locations. In actor systems, GC poses some challenges that make it much costlier than in the sequential setting: Besides references from reachable actors, we have to consider inverse references from potentially active actors to reachable actors. One proposal, adopted in the runtime for the actor programming language Pony, uses causal message delivery and a centralized detection algorithm. While this is efficient in a multicore setting, the solution is too expensive for a distributed actor runtime. In this work, we show how the causal order message delivery requirement may be removed. Specifically, we describe a tracing collector of distributed actor garbage with centralized and\u00a0\u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Transforming threads into actors: learning concurrency structure from execution traces\n", "abstract": " The threads and shared memory model is still the most commonly used programming model. However, programs written using threads interacting with shared memory model are notoriously bug-prone and hard to comprehend. An important reason for this lack of comprehensibility is thread based programs obscure the natural structure of concurrency in a distributed world: actors executing autonomously with their own internal logic and interacting at arms length with each other. While actors encapsulate their internal state, enabling consistency invariants of the data structures to be maintained locally, thread-based programs use control-centric synchronization primitives (such as locks) that are divorced from the concurrency structure of a program. Making the concurrency structure explicit provides useful documentation for developers. Moreover, it may be useful for refactoring thread-based object-oriented\u00a0\u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "A compositional approach for modeling and timing analysis of wireless sensor and actuator networks\n", "abstract": " Wireless sensor and actuator networks (WSAN) are created through the integration of multiple nodes which acquire data and perform reaction based on them. In a general overview, sensor nodes of WSANs are responsible for data acquisition and sending them to a central node. The central node stores all the received data and performs reactions. Timing verification of WSAN applications to ensure schedulability of tasks is a challenge, and is generally performed by worst-case analysis. This process is error-prone and inherently conservative. On the other hand, using model checking for analyzing WSAN applications results in state space explosion even for middle-sized configurations. The reason is the necessity of considering the interleaving of the large number of sensors in WSANs. In this paper, we show how to build an actor-based model of WSAN applications, starting from sensor node-level and moving\u00a0\u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Special issue on programming based on actors, agents and decentralized control\n", "abstract": " The AGERE! workshop1 has been organized with the ACM SPLASH conference since 2011. The workshop has brought together researchers in programming systems, languages, and applications based on actors, active/concurrent objects, agents, and more broadly, high-level programming paradigms which facilitate decentralized control. The goal of the workshop is to promote use of such paradigms to address the problem of developing software for complex, real-world applications. The AGERE workshop is a follow on to workshops on Object-based Concurrent Programming which were organized twenty years earlier in conjunction with OOPSLA [1], [2], [3]. In the last two decades, concurrency and distribution have become part of everyday programming. In this context, the objective of AGERE! is to foster the development and adoption of high-level programming paradigms embracing concurrency at the core of the\u00a0\u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "A service-oriented architecture for dynamic macroprogramming of sensor networks\n", "abstract": " In the late 1990s, advances in sensing and computer technology have enabled the development of tiny, inexpensive, low-power wireless sensor platforms. By integrating sensing, communication, and computational capabilities, these smart sensors were poised to revolutionize our view of the environment we inhabit by linking the physical world with the digital realm of traditional computing. Smart sensors have been available to researchers for more than a decade; however, few large-scale applications have emerged outside the laboratory setting, and the commercial potential of this technology has been limited. The principal reason for this outcome is the difficulty inherent in programming wireless sensor networks (WSNs) consisting of more than a handful of sensors: built from inexpensive components, individual nodes in this distributed system are prone to failures; interaction with the physical world imposes real\u00a0\u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Autonomous structural health monitoring using wireless smart sensors on a cable-stayed bridge\n", "abstract": " Structural health monitoring for long-span bridges using wireless smart sensor network (WSSN) has drawn significant attention. The benefits of the WSSN are low-cost, time efficiency, and post-processing-free operation. However, some drawbacks have remained with respect to implementation of WSSNs on longspan bridges, including power consumption, manual communication with the sensor network, and", "num_citations": "3\n", "authors": ["1581"]}
{"title": "A robust audit mechanism to prevent malicious behaviors in multi-robot systems\n", "abstract": " Market-based mechanisms can be used to coordinate self-interested multi-robot systems in fully distributed environments, where by self-interested we mean that each robot agent attempts to maximize a payoff function that accounts for both the resources consumed and the contribution made by the robot. In previous work, we have studied the effect of various market rules and bidding strategies on the global performance of the multi-robot system. However, rather than use a central monitoring and enforcement mechanisms, we rely on agents to self-report their actions. This assumes that the agents act honestly. In this paper, we drop the honesty assumption, raising the possibility that agents may exaggerate their contribution in order to increase their payoff. To address the problem of such malicious behavior, we propose an audit mechanism to maintain the integrity of reported payoffs. Our algorithm extends previous\u00a0\u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Localization of sparse sensor networks using layout information\n", "abstract": " Localization is the process by which sensor networks associate spatial position information with individual sensors' measurements. While manual surveying is sufficient for small-scale prototypes, it is too time-consuming and costly for the large-scale deployments anticipated in the near future. Our experiments with medium-scale outdoor sensor network deployments show that sparsity of ranging measurements is a key factor limiting the accuracy of localization; often, several solutions are equally consistent with the data. Fortunately, layout information can usually be obtained at little extra cost; for example, if it is used to guide the deployment process, or by analyzing a photograph of the network. We have developed an algorithm based on subgraph isomorphism which uses the known layout information in conjunction with ranging measurements to find a family of localization solutions for a sensor network deployment. Although subgraph isomorphism is in general NP-complete, the more specific cases that occur in real-world scenarios are usually tractable. Experiments with a 50-node network show that our algorithm is very efficient in practice.", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Formal methods for Actor systems: A progress report\n", "abstract": " This paper describes actors and summarizes current research in building formal models of actor systems. The Actor model of concurrent computation unifies functional and object-oriented programming. Inheritance is a key aspect of object-oriented programming. We review key concepts used in object-oriented programming and describe how different models of inheritance have been integrated in a single framework. We then discuss reflection and show how it provides a powerful tool for constructing large-scale complex systems. In the concluding section, we argue that a reflective, concurrent object-oriented programming framework will not only radically simplify how systems are built but simplify the task of reasoning about such systems.", "num_citations": "3\n", "authors": ["1581"]}
{"title": "OOPSLA panel on object-based concurrent programming\n", "abstract": " OOPSLA panel on object-based concurrent programming | Proceedings of the workshop on Object-based concurrent programming ACM Digital Library Logo ACM Logo Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search splash Conference Proceedings Upcoming Events Authors Affiliations Award Winners More HomeConferencesSPLASHProceedingsOOPSLA/ECOOP '90OOPSLA panel on object-based concurrent programming ARTICLE OOPSLA panel on object-based concurrent programming Share on Authors: Gul Agha Search about this author , Akinori Yonezawa Search about this author , Peter Wegner Search about this author , Samson Abramski Search about this author Authors Info & Affiliations Publication: OOPSLA/ECOOP '90: \u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Proceedings of the 1988 ACM SIGPLAN workshop on Object-based concurrent programming\n", "abstract": " Proceedings of the 1988 ACM SIGPLAN workshop on Object-based concurrent programming | ACM Conferences ACM Digital Library Logo ACM Logo Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search splash Conference Proceedings Upcoming Events Authors Affiliations Award Winners More HomeConferencesSPLASHProceedingsOOPSLA/ECOOP '88 Export Citation Select Citation format Download citation Copy citation Categories Journals Magazines Books Proceedings SIGs Conferences Collections People About About ACM Digital Library Subscription Information Author Guidelines Using ACM Digital Library All Holdings within the ACM Digital Library ACM Computing Classification System Join Join ACM Join SIGs Subscribe to \u2026", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Actors: A Model of Concurrent Computation in Distributed Systems (Parallel Processing, Semantics, Open, Programming Languages, Artificial Intelligence)\n", "abstract": " A foundational model of concurrency is developed in this thesis. We examine issues in the design of parallel systems and show why the actor model is suitable for exploiting large-scale parallelism. Concurrency in actors is constrained only by the availability of hardware resources and by the logical dependence inherent in the computation. Unlike dataflow and functional programming, however, actors are dynamically reconfigurable and can model shared resources with changing local state. Concurrency is spawned in actors using asynchronous message-passing, pipelining, and the dynamic creation of actors.", "num_citations": "3\n", "authors": ["1581"]}
{"title": "Assured Cloud Computing\n", "abstract": " Explores key challenges and solutions to assured cloud computing today and provides a provocative look at the face of cloud computing tomorrow This book offers readers a comprehensive suite of solutions for resolving many of the key challenges to achieving high levels of assurance in cloud computing. The distillation of critical research findings generated by the Assured Cloud Computing Center of Excellence (ACC-UCoE) of the University of Illinois, Urbana-Champaign, it provides unique insights into the current and future shape of robust, dependable, and secure cloud-based computing and data cyberinfrastructures. A survivable and distributed cloud-computing-based infrastructure can enable the configuration of any dynamic systems-of-systems that contain both trusted and partially trusted resources and services sourced from multiple organizations. To assure mission-critical computations and workflows that rely on such systems-of-systems it is necessary to ensure that a given configuration does not violate any security or reliability requirements. Furthermore, it is necessary to model the trustworthiness of a workflow or computation fulfillment to a high level of assurance. In presenting the substance of the work done by the ACC-UCoE, this book provides a vision for assured cloud computing illustrating how individual research contributions relate to each other and to the big picture of assured cloud computing. In addition, the book: Explores dominant themes in cloud-based systems, including design correctness, support for big data and analytics, monitoring and detection, network considerations, and performance Synthesizes heavily cited\u00a0\u2026", "num_citations": "2\n", "authors": ["1581"]}
{"title": "Distributed placement of machine learning operators for IoT applications spanning edge and cloud resources\n", "abstract": " Internet of Things (IoT) applications generate massive amounts of real-time data that are typically processed for carrying out complex tasks such as vision and speech processing. Owners of such data strive to make predictions/inference from large streams of complex data such as video feeds, often using pre-trained neural network models. A typical deployment of IoT applications includes edge devices to acquire the input data and provide processing and storage capacity closer to the location where the data is captured. This can obviate the need to move all the data/processing to a remote cloud service. However, since edge devices are limited in computational capacity, we need to determine the optimal placement of operations between edge and remote cloud resources to optimize the performance of neural network model inference. In this paper we propose an algorithm to decide the partitioning of neural network operations across edge and cloud resources. Our algorithm is linear in the number of operations (m) of the neural network model and the overall complexity is O (m\u00b7(L!)\u00b7 L), where L is the number of resources (typical deployments include one edge resource and the cloud, in which case L is 2).", "num_citations": "2\n", "authors": ["1581"]}
{"title": "Abstractions, semantic models and analysis tools for concurrent systems: Progress and open problems\n", "abstract": " The growth of mobile and cloud computing, cyberphysical systems and the internet of things has arguably made scalable concurrency the central to computing. Actor languages and frameworks have been widely adopted to address scalability. Moreover, new tools that combine static and dyamic analysis are making software safer. This presentation describes the actor programming model and reasoning tools for scalable concurrency. As we scale up cyberphysical applications and build the internet of things, a key limitation of current languages and tools becomes apparent: the difficulty of representing quantitative and probabilistic properties and reasoning about them. The paper concludes by discussing some techniques to address reasoning about the behavior of complex scalable concurrent applications.", "num_citations": "2\n", "authors": ["1581"]}
{"title": "Concurrent Objects and Beyond: Papers dedicated to Akinori Yonezawa on the Occasion of His 65th Birthday\n", "abstract": " This Festschrift volume includes a collection of papers written in honor of the accomplishments of Professor Yonezawa on the occasion of his 65th birthday in 2012. With a few exceptions, the papers in this Festschrift were presented at an international symposium celebrating this occasion. Also included are reprints of two of Professor Yonezawa's most influential papers on the programming language ABCL. The volume is a testament strong and lasting impact Professor Yonezawa's research accomplishments as well as the inspiration he has been to colleagues and students alike.", "num_citations": "2\n", "authors": ["1581"]}
{"title": "An underlay for sensor networks: Localized protocols for maintenance and usage\n", "abstract": " We propose localized and decentralized protocols to construct and maintain an underlay for sensor networks. An underlay lies in between overlay operations (e.g., data indexing, multicast, etc.) and the sensor network itself. Specifically, an underlay bridges the gap between (a) the unreliability of sensor nodes and communication and availability of only approximate location knowledge, and (b) the maintenance of a virtual geography-based naming structure that is required by several overlay operations. Our underlay creates a coarse naming scheme based on approximate location knowledge, and then maintains it in an efficient and scalable manner. The underlay naming can be used to specify arbitrary regions. The overlay operations that can be executed on the underlay include routing, aggregation, multicast, data indexing, etc. These overlay operations could be region-based. The proposed underlay\u00a0\u2026", "num_citations": "2\n", "authors": ["1581"]}
{"title": "An actor based framework for managing multimedia qos\n", "abstract": " Services and systems in a global multimedia information infrastructure evolve dynamically and their components interact with an environment that is not under their control. Many multimedia (MM) applications can tolerate relatively minor and infrequent violations of their performance requirements; the extent to which such violations are permissible is speci ed as a quality-of-service (QoS) parameter. In this paper, we discuss preliminary work on an actor-based framework for the speci cation and management of open distributed multimedia systems. QoS statements may specify constraints on timing, availability, security, and resource utilization. By developing a formal theory that models QoS features and captures the dynamicity of evolution, we facilitate the design of open systems. A formal model also allows us to reason about the composition of objects with varying QoS constraints and restrict interactions for safe compositionality.", "num_citations": "2\n", "authors": ["1581"]}
{"title": "Scalable Termination Detection for Distributed Actor Systems\n", "abstract": " Automatic garbage collection (GC) prevents certain kinds of bugs and reduces programming overhead. GC techniques for sequential programs are based on reachability analysis. However, testing reachability from a root set is inadequate for determining whether an actor is garbage because an unreachable actor may send a message to a reachable actor. Instead, it is sufficient to check termination (sometimes also called quiescence): an actor is terminated if it is not currently processing a message and cannot receive a message in the future. Moreover, many actor frameworks provide all actors with access to file I/O or external storage; without inspecting an actor's internal code, it is necessary to check that the actor has terminated to ensure that it may be garbage collected in these frameworks. Previous algorithms to detect actor garbage require coordination mechanisms such as causal message delivery or nonlocal monitoring of actors for mutation. Such coordination mechanisms adversely affect concurrency and are therefore expensive in distributed systems. We present a low-overhead reference listing technique (called DRL) for termination detection in actor systems. DRL is based on asynchronous local snapshots and message-passing between actors. This enables a decentralized implementation and transient network partition tolerance. The paper provides a formal description of DRL, shows that all actors identified as garbage have indeed terminated (safety), and that all terminated actors--under certain reasonable assumptions--will eventually be identified (liveness).", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Theoretical considerations: Inferring and enforcing use patterns for mobile cloud assurance\n", "abstract": " The mobile cloud is the integration of smart sensors, mobile devices, and cloud computers in a well-connected ecosystem. Such integration can improve the efficiency of services. However, such integration also leads to security and trust issues. For example, the security of cloud spaces has sometimes been breached through accessing of peripheral devices, such as HVAC systems. This chapter will show how mobile cloud security and trust can be improved while maintaining the benefits of efficiency by supporting fine-grained mobility. Specifically, we discuss an actor-based programming framework that can facilitate the development of mobile cloud systems in a way that improves efficiency while enforcing security and privacy. There are two key ideas here. First, by supportingfine-grained units of computation (actors), a mobile cloud can be agile in migrating components. It does so in response to a system context (including dynamic variables such as available bandwidth, processing power, and energy) while respecting constraints on information containment boundaries. Second, by specifying constraints on interaction patterns, information flow between actors can be observed and suspicious activityflagged or prevented. We introduce the concepts and discuss their realization in notations and prototypes. Finally, we will discuss open research issues such as inference of interaction patterns.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Euclidean model checking: A scalable method for verifying quantitative properties in probabilistic systems\n", "abstract": " We typically represent the global state of a concurrent system as the crossproduct of individual states of its components. This leads to an explosion of potential global states: consider a concurrent system with a thousand actors, each of which may be in one of 5 states. This leads to a possible 51000 global states. Obviously, it is not feasible to exhaustively search the state space in such systems. In fact, actors often have an even larger number of states (than say 5), although these states may be abstracted to fewer states.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Link quality estimation for data-intensive sensor network applications\n", "abstract": " The efficiency of multi-hop communication is a function of the time required for data transfer, or throughput. A key determinant of throughput is the reliability of packet transmission, as measured by the packet reception rate. We follow a data-driven statistical approach to dynamically determine a link quality estimate (LQE), which provides a good predictor of packet reception rates. Our goal is to enable efficient multi-hop communication for applications characterized by data-intensive, bursty communication in large sensor networks. Statistical analysis and experiments carried out on a network of 20 Imote2 sensors under a variety of environmental conditions show that the metric is a superior predictor of throughput for bursty data transfer workloads.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Towards energy-performance trade-off analysis of parallel applications\n", "abstract": " Energy consumption by computer systems has emerged as an important concern, both at the level of individual devices (limited battery capacity in mobile systems) and at the societal level (the production of Green House Gases). In parallel architectures, applications may be executed on a variable number of cores and these cores may operate at different frequencies. The performance and energy cost of a parallel algorithm executing on a parallel architecture have different trade-offs, depending on how many cores the algorithm uses, at what frequencies these cores operate, and the structure of the algorithm. The problem of defining metrics to quantify energy performance trade-offs was posed as an important open problem in a recent NSF workshop. Moreover, in a recent IEEE computer article, Krishna Kant argues that \u201cA formal understanding of energy and computation trade-offs will lead to significantly more\u00a0\u2026", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Reflecting on adaptive distributed monitoring\n", "abstract": " Metaprogramming and computational reflection are two related concepts that allow a program to inspect and possibly modify itself while running. Although the concepts have been explored by researchers for some time, a form of metaprogramming, namely aspect-oriented programming, is now being used by some practitioners. This paper is an attempt to understand the limitations of different forms of computational reflection in concurrent and distributed computing. It specifically studies the use of aspect-oriented programming and reflective actor libraries, and their relation to full reflection. We choose distributed monitoring as the primary example application because its requirements nicely fit the abilities of the two systems as well as illustrate their limitations.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "DiffGen: A Toolkit for Generating Distributed Protocol Code\n", "abstract": " We describe the design and implementation of a toolkit to automatically generate C code for distributed protocols derived from a subclass of differential equations. The toolkit generates compilable C code. The code can be run directly over any socket implementation, as well as within a simulator we have created for debugging and testing. The toolkit also includes functionality for rewriting to generate protocols for higher order systems and a debugging tool to analyze the behavior of the resulting protocol in a user specified computing environment. We expect the toolkit will be useful to researchers and designers of distributed protocols. The advantages would include systematically using natural analogies to design distributed systems, and cutting short the protocol design life cycle.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Multiagent Systems: A Modern Approach to Distributed Artificial...\n", "abstract": " Purpose\u2014The study of multiagent systems began in the field of distributed artificial intelligence (DAI) about 20 years", "num_citations": "1\n", "authors": ["1581"]}
{"title": "High availability in CORBA\n", "abstract": " The Common Object Request Broker Architecture (CORBA), specified by the Object Management Group (OMG), is a middleware specification of basic mechanisms for remote object invocation through an Object Request Broker (ORB). CORBA also specifies a set of services for object management, including a Persistence Service an Event Service, a Transaction Service, etc. Nevertheless, and even if there are several OMG processes under way to standardize high availability features in CORBA 3.0, neither the current ORB nor the existing CORBA services specify tools for building highly available applications. This can be considered a major limitation for many of today\u2019s application domains such as process control, telecommunications, and electronic stock exchange. In these areas, programmers must provide, besides CORBA facilities, specific features for high availability. The group paradigm was shown to be\u00a0\u2026", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Compositional software architectures\n", "abstract": " Agency. OMG, the software industry\u2019s largest consortium, focuses on \u201copen interoperable component software interface and framework technology.\u201d The workshop\u2019s goal was to deduce how one might evolve technologies to support the separation of code for-ilities from application software. Separating-ilities might be possible if-ilities are implemented in terms of services inserted as middleware\u2014that is, by software that mediates the interaction between an application and the underlying operating system and network.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Our magazine's new face\n", "abstract": " High-performance computing remains an important part of our coverage. At the same time, we are continuing to broaden our coverage to keep abreast of the changing nature of our field. In doing so, we will keep you well informed about the latest developments in an ever expanding field. In fact, it has been common wisdom for some time that the future of computing is parallel and distributed. With increasing availability of multiprocessor workstations, faster networks, and the growth of Internet computing, perhaps it is fair to say that the future is finally here. Three theme issues are planned over the next year; these issues reflect the breadth of our coverage. Here is a rundown of the issues.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "The elusive goal of intelligence\n", "abstract": " University of Illinois unfinished manuscript was published posthu-1304 W. Springfield Ave. mously. Von Neumann observed that the Urbana, IL 61801 brain\u2019s computations are incredibly reliable, agha@ cs. uiuc. edu given that the brain appears to operate with very low precision. By contrast, computers need to have high precision to avoid propagating errors that would make their calculations unreliable. He argued that the brain is essentially a \u201cstatistical\u201d instead of a digital device:\u201c... what matters are not the precise positions of definite markers, digits, but the statistical characteristics of their occurrence, ie frequencies of periodic or near periodic pulse-trains etc.\u201d Today\u2019s single-processor computers, as well as single nodes of concurrent computers, remain remarkably similar to von Neumann\u2019s design. However, the computational model we use is evolving with the rise of parallel and distributed computing. A brain, of\u00a0\u2026", "num_citations": "1\n", "authors": ["1581"]}
{"title": "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA Specification of real-time interaction constraints\n", "abstract": " We present a coordination language and its semantics for specification and implementation of object-oriented real-time systems. Real-time systems operate under real-time constraints, and our language supports expression thereof. In our language, a system is modeled by two separate but complementary descriptions: A collection of objects define the system's structure and functional behavior, and a set of interaction constraints define how these objects may inter-act. Our language thereby supports development of real-time systems by enabling objects build in isolation or reused from other systems to be composed via interaction constraints. We use the Actor model to describe objects and the concept of real-time synchronizers to describe interaction constraints.Our model is accompanied by a formal semantics that precisely defines what real-time constraints means, and what constitutes a program's correct real-time behaviors. The semantics defines how the system may evolve in the real-time domain, and what progress guarantees the lan-guage makes. We briefly discuss implementation problems", "num_citations": "1\n", "authors": ["1581"]}
{"title": "The mountains are in labor\n", "abstract": " 1304 W. Springfield Ave. commercial potential has begun to capture Urbana, IL 61801 the business imagination. There is the re-agha@ cs. uiuc. edu cent story of parallel computing in the service of entertainment. The first entirely computer-animated feature-length movie,\u201cToy Story,\u201d was produced by Pixar Animation Studios and released by Walt Disney late last year. The film was rendered on a processor farm consisting of 87 dualprocessor and 30 quad-processor loo-MHz SPARCstation 20s. Observers believe that this movie will usher in a new era of film animation.The Worldwide Web continues to attract media and stock market attention, where it is touted as both a global bazaar and an easily accessible worldwide information base. With the new requirements posed by this marriage of computer and communication, new programming languages and techniques incorporating many older concepts that never\u00a0\u2026", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Customizing Dependability with Reusable Software Components\n", "abstract": " Many large software systems have di erent components with varying requirements for robustness and performance. Moreover, dependability requirements often change throughout their software life-cycle. Thus any single dependability technique is insufcient for implementing large systems. Software developers need to be able to modify dependability code without modifying application code. We outline a methodology for the separate development and maintenance of dependability and application codes. The advantage of our methodology is that dependability of each component may be customized and the dependability techniques reused with di erent application components. We demonstrate that our approach may be implemented e ciently, providing comparable performance to applications with hand-coded dependable behavior. We discuss a run-time system to implement our techniques and some optimizations it uses.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Concurrent systems for knowledge processing\n", "abstract": " Actors have catalyzed the development of a new programming methodology and architecture for ultra-concurrent systems. This sourcebook on the development and impact of the actor paradigm brings together more than 20 milestone contributions on the actor concept and its application to knowledge processing. Each contribution is placed in its historical context and explained. This book is divided into four major areas: Foundations of Concurrent Systems covers actors, laws of concurrent systems and mathematical models. Languages takes up design principles, actor languages, meta-interpreters, and comparison with other programming languages. Systems and Architectures discusses monitoring and debugging environments, and multicomputers. Knowledge Processing examines the scientific community metaphor, open systems, and organizational semantics. Future prospects for actors and knowledge processing are discussed in the concluding section.", "num_citations": "1\n", "authors": ["1581"]}
{"title": "THE STINGY SHIFT EXPLAINED AS A~ JORITY RULE EQUILIBRIUM\n", "abstract": " Baron, Roper and Baron (1974) claim that group decisions regarding contributions to a charitable cause sometimes represent generally stingier options than the options picked by individuals when choosing alone. Their study and interpretations are consistent with a sizable social psychological literature which postulate: o; that\" choice shifts\" of various kinds occur as a result of group decision. Theories used to explain\" choice shifts\" usually rest on principles of group decision involving concepts like cultural values, responsibility, leadership, etc. In the present case, for example, the diffusion of personal responsibility for uncharitable behavior was offered as one explanation for smaller mean donations by groups.Studies such as the Baron, Roper and Baron paper are a~ ten: pts to isolate any\" major limitations to one of the most basic findings in social psychology: convergence to the average response follmving group interaction\"(p. 539). He argue below that the Baron, Roper", "num_citations": "1\n", "authors": ["1581"]}
{"title": "Partitioning and distribution strategies as first class objects\n", "abstract": " In scalable concurrent architectures, the performance of a parallel algorithm depends on the resource management policies used. Such policies determine, for example, how data is partitioned and distributed and how processes are scheduled. For di erent problem sizes or architectures, di erent policies may be more e cient. In particular, the performance of a parallel algorithm obtained by using a particular policy can beThe research described has been made possible by support from the O ce of Naval Research (ONR contract numbers N00014-90-J-1899 and N00014-93-1-0273), by an Incentives for Excellence Award from the Digital Equipment Corporation Faculty Program, and by joint support from the Defense Advanced Research Projects Agency and the National Science Foundation (NSF CCR 90-07195). yThe authors thank the referees for providing several constructive suggestions. The authors thank Daniel Sturman for his development of Broadway. Svend Fr lund, Daniel Sturman and Wooyoung Kim and other members of the Open Systems Laboratory have provided helpful suggestions and discussions.", "num_citations": "1\n", "authors": ["1581"]}