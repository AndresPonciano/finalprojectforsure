{"title": "A logic for reasoning about time and reliability\n", "abstract": " We present a logic for stating properties such as, \u201cafter a request for service there is at least a 98% probability that the service will be carried out within 2 seconds\u201d. The logic extends the temporal logic CTL by Emerson, Clarke and Sistla with time and probabilities. Formulas are interpreted over discrete time Markov chains. We give algorithms for checking that a given Markov chain satisfies a formula in the logic. The algorithms require a polynomial number of arithmetic operations, in size of both the formula and the Markov chain. A simple example is included to illustrate the algorithms.", "num_citations": "1680\n", "authors": ["1799"]}
{"title": "Analysing Real-Time Communications: Controller Area Network (CAN).\n", "abstract": " The increasing use of communication networks in time critical applications presents engineers with fundamental problems with the determination of response times of communicating distributed processes. Although there has been some work on the analysis of communication protocols, most of this is for idealised networks. Experience with single processor scheduling analysis has shown that models which abstract away from implementation details are at best very pessimistic and at worst lead to unschedulable system being deemed schedulable. In this paper, we derive idealised scheduling analysis for the CAN network, and then study two actual interface chips to see how the analysis can be applied.", "num_citations": "624\n", "authors": ["1799"]}
{"title": "Time and probability in formal design of distributed systems\n", "abstract": " Degree: Takn. drDegreeYear: 1991Institute: Uppsala Universitet (Sweden)Publisher: Department Of Computer Systems, Uppsala University, PO Box 520, S-751 20 Uppsala, Sweden.", "num_citations": "398\n", "authors": ["1799"]}
{"title": "A calculus for communicating systems with time and probabilities\n", "abstract": " A process algebra that extends R. Milner's (1983) calculus of communicating systems (CCS) with probabilities and time is presented. With this calculus it is possible to describe real-time and reliability aspects of distributed systems. A (strong) bisimulation equivalence is defined, and a corresponding complete axiomatization is given. Several examples are included.< >", "num_citations": "265\n", "authors": ["1799"]}
{"title": "Automotive communications-past, current and future\n", "abstract": " This paper presents a state-of-practice (SOP) overview of automotive communication technologies, including the latest technology developments. These networking technologies are classified in four major groups: (1) current wired, (2) multimedia, (3) upcoming wired and (4) wireless. Within these groups a few technologies stand out as strong candidates for future automotive networks. The goal of this paper is to give an overview of automotive applications relying on communications, identify the key networking technologies used in various automotive applications, present their properties and attributes, and indicate future challenges in the area of automotive communications", "num_citations": "211\n", "authors": ["1799"]}
{"title": "Worst-case execution-time analysis for embedded real-time systems\n", "abstract": " In this article we give an overview of the worst-case execution time (WCET) analysis research performed by the WCET group of the ASTEC Competence Centre at Uppsala University. Knowing the WCET of a program is necessary when designing and verifying real-time systems. The WCET depends both on the program flow, such as loop iterations and function calls, and on hardware factors, such as caches and pipelines. WCET estimates should be both safe (no underestimation allowed) and tight (as little overestimation as possible). We have defined a modular architecture for a WCET tool, used both to identify the components of the overall WCET analysis problem, and as a starting point for the development of a WCET tool prototype. Within this framework we have proposed solutions to several key problems in WCET analysis, including representation and analysis of the control flow of programs, modeling\u00a0\u2026", "num_citations": "175\n", "authors": ["1799"]}
{"title": "Improved response-time analysis calculations\n", "abstract": " Schedulability analysis of fixed priority preemptive scheduled systems can be performed by calculating the worst-case response-time of the involved processes. The system is deemed schedulable if the calculated response-time for each process is less than its corresponding deadline. It is desirable that the Response-Time Analysis (RTA) can be efficiently performed. This is particularly important in dynamic real-time systems when a fast response is needed to decide whether a new job can be accommodated, or when the RTA is extensively applied, e.g., when used to guide the heuristics in a higher level optimiser. This paper presents a set of methods to improve the efficiency of RTA calculations. The methods are proved correct, in the sense that they give the same results as traditional (non-improved) RTA. We also present an evaluation of the improvements, by applying them to the particularly time-consuming traffic\u00a0\u2026", "num_citations": "144\n", "authors": ["1799"]}
{"title": "A framework for reasoning about time and reliability\n", "abstract": " A logic is presented for stating properties such as' after a request for service there is at least a 98% probability that the service will be carried out within 2 s'. The logic extends the temporal logic CTL by EA Emerson et al.(1983) with time and probabilities. Formulas are interpreted over discrete time Markov chains. Algorithms are provided for checking that a given Markov chain satisfies a formula in the logic. An example is included to illustrate the algorithms.<>", "num_citations": "138\n", "authors": ["1799"]}
{"title": "Response time analysis under errors for CAN\n", "abstract": " The Controller Area Network (CAN) is extensively used for timely communication in automotive and other applications. As timing analysis of CAN messages is emerging into industrial practice, and as the use of CAN in safety-critical applications is increasing, there is an apparent need to include the effects of transmission errors in the analysis of message latencies. The authors provide a general fault model and extend the timing analysis of CAN messages to cater for the effects of transmission errors on message latencies. This fault model helps us in composing the effects of interferences from multiple sources and to account for them in the calculation of message response times. We illustrate our model by applying it to derive the worst case latencies of a subset of messages selected from the frequently used SAE case study. We also discuss and illustrate the implications on message latencies for some realistic fault\u00a0\u2026", "num_citations": "125\n", "authors": ["1799"]}
{"title": "Integrating reliability and timing analysis of CAN-based systems\n", "abstract": " This paper presents and illustrates a reliability analysis method developed with a focus on controller-area-network-based automotive systems. The method considers the effect of faults on schedulability analysis and its impact on the reliability estimation of the system, and attempts to integrate both to aid system developers. The authors illustrate the method by modeling a simple distributed antilock braking system, and showing that even in cases where the worst case analysis deems the system unschedulable, it may be proven to satisfy its timing requirements with a sufficiently high probability. From a reliability and cost perspective, this paper underlines the tradeoffs between timing guarantees, the level of hardware and software faults, and per-unit cost.", "num_citations": "122\n", "authors": ["1799"]}
{"title": "Probabilistic worst-case response-time analysis for the controller area network\n", "abstract": " This paper presents a novel approach for calculating a probabilistic worst-case response-time for messages in the Controller Area Network (CAN). CAN uses a bit-stuffing mechanism to exclude forbidden bit-patterns within a message frame. The added bits eliminate the forbidden patterns but cause an increase in frame length. How much the length is increased depends on the bit-pattern of the original message frame. Traditional response-time analysis methods assume that all frames have a worst-case number of stuff-bits. This introduces pessimism in the analysis. In this paper we introduce an analysis approach based on using probability distributions to model the number of stuff-bits. The new analysis additionally opens tip for making trade-offs between reliability and timeliness, in the sense that the analysis will provide a certain probability for missing deadlines, which in the reliability analysis can be treated as a\u00a0\u2026", "num_citations": "110\n", "authors": ["1799"]}
{"title": "Using deterministic replay for debugging of distributed real-time systems\n", "abstract": " Cyclic debugging is one of the most important and most commonly used activities in program development. During cyclic debugging, a program is repeatedly re-executed to track down errors when a failure has been observed. This process necessitates reproducible program executions. Applying classical debugging techniques, such as using breakpoints or single stepping, in real-time systems changes the temporal behaviour and makes reproduction of the observed failure during debugging less likely, if not impossible. Consequently, these techniques are not directly applicable to the cyclic debugging of real-time systems. In this paper, we present a novel software-based approach for the cyclic debugging of distributed real-time systems. By the online recording of significant system events, and then deterministically replaying them off-line, we can inspect a real-time system in great detail, while still preserving its\u00a0\u2026", "num_citations": "101\n", "authors": ["1799"]}
{"title": "BASEMENT: A distributed real-time architecture for vehicle applications\n", "abstract": " This paper presents BASEMENT\u2122, a distributed real-time architecture developed for vehicle internal use in the automotive industry. The Basement concept is holistic, in the sense that it covers application development, as well as the hardware and software that provide execution and communication support. The key constituents of the concept are                                 resource sharing (multiplexing) of processing and communication resources                                               a guaranteed real-time service for safety critical applications                                               a best-effort service for non-safety critical applications                                               a communication infrastructure providing efficient communication between distributed devices                                               a program development methodology allowing resource independent and application oriented development of application software\u00a0\u2026", "num_citations": "99\n", "authors": ["1799"]}
{"title": "Minimizing CAN response-time jitter by message manipulation\n", "abstract": " Delay variations (jitter) in computations and communications cause degradation of performance in applications such as control. There are many sources of jitter, including variations in execution time and bus contention. This paper presents methods to reduce the variation of frame (message) transmission time caused by the bit-stuffing mechanism in a controller area network (CAN). By introducing restrictions, such as a small reduction of available frame priorities, we are able to reduce the number of stuff-bits in the worst case. We also combine this with some of our previous work that reduces the number of stuff-bits in the data part of the frame. We show the actual penalty introduced by forbidding priorities, and show the overall improvement obtained by using these techniques together in a small case study.", "num_citations": "90\n", "authors": ["1799"]}
{"title": "Using bit-stuffing distributions in CAN analysis\n", "abstract": " This paper investigates the level of pessimism of traditional schedulability analysis for the Controller Area Network (CAN). Specifically, we investigate the effects of considering bit-stuffing distributions instead of worst case bitstuffing. This allows us to obtain bus utilisation values more close to reality. On the other hand, since our analysis is based on assumptions concerning distributions of stuffed bits, our response times will only be met with some probability. We introduce a model and a method, that relaxes the pessimism of the worst-case analysis, and we show the effect of our method by considering both an artificial traffic model and samples of real CAN traffic. Our conclusion from this investigation is that actual frame sizes, with a very high probability, is in the order of 10% smaller than the worst cases used in traditional analysis. Also, we propose a simple coding scheme, which substantially reduces the number of stuffed bits in the considered real traffic.", "num_citations": "88\n", "authors": ["1799"]}
{"title": "Real-time server-based communication with CAN\n", "abstract": " This paper investigates the concept of share-driven scheduling of networks using servers with real-time properties. Share-driven scheduling provides fairness and bandwidth isolation between predictable as well as unpredictable streams of messages on the network. The need for this kind of scheduled real-time communication network is high in applications that have requirements on flexibility, both during development for assigning communication bandwidth to different applications, and during run-time to facilitate dynamic addition and removal of system components. We illustrate the share-driven scheduling concept by applying it to the popular controller area network (CAN). We propose a scheduling mechanism that we call simple server-scheduled CAN (S/sup 3/-CAN), for which we also present an associated timing analysis. Additionally, we present a variant of S/sup 3/-CAN called periodic server-scheduled\u00a0\u2026", "num_citations": "80\n", "authors": ["1799"]}
{"title": "Using measurements to derive the worst-case execution time\n", "abstract": " Execution time analysis is used in the development of real time and embedded systems to derive the timing estimates required for schedulability analysis. The execution time of the analyzed program is typically obtained by combining results from program flow analysis (such as number of iterations in loops) with low level timing information. The paper proposes a method for low level timing analysis based on measurements of execution times of programs executing on the actual target architecture. The essence of the method is to derive a system of linear equations from a limited number of timing measurements of an instrumented version of the considered program. The solution to these equations give execution times for program fragments, from which execution time measures for the entire program can be derived. The main advantage with this approach is that architectural modeling is not needed, hence the risk of\u00a0\u2026", "num_citations": "57\n", "authors": ["1799"]}
{"title": "A survey on testing for cyber physical system\n", "abstract": " Cyber Physical Systems (CPS) bridge the cyber-world of computing and communications with the physical world and require development of secure and reliable software. It asserts a big challenge not only on testing and verifying the correctness of all physical and cyber components of such big systems, but also on integration of these components. This paper develops a categorization of multiple levels of testing required to test CPS and makes a comparison of these levels with the levels of software testing based on the V-model. It presents a detailed state-of-the-art survey on the testing approaches performed on the CPS. Further, it provides challenges in CPS testing.", "num_citations": "56\n", "authors": ["1799"]}
{"title": "An analysis of FPGA-based UDP/IP stack parallelism for embedded Ethernet connectivity\n", "abstract": " When designing FPGA-based Ethernet connected embedded systems the priority and necessity of requirements such as cost, area, flexibility etc. varies for each system. Simplified for most systems, it can be stated that no extra functionality than required is desired. Hence, when designing a UDP/IP stack in an FPGA a single UDP/IP stack \"template\" design is not suitable to effectively realize the different embedded network system requirements. We present three different UDP/IP stack cores, with different grades of parallelism and suited for various network demands. We show that the UDP/IP core area can be reduced to 1/3 of the original size with an appropriate implementation, accomplished by a trade-off between parallelism/latency and area. Furthermore guidelines are proposed on how to perform the trade-off between parallelism, area (cost), flexibility and functionality when designing an UDP/IP stack for\u00a0\u2026", "num_citations": "55\n", "authors": ["1799"]}
{"title": "Real time systems and fixed priority scheduling\n", "abstract": " 1.1 BackgroundThe rstthing mostbooks inreal-timesystemsdo isdene real-time\". Denitions don't usually help very much, but to keep the tradition we will give a denition:Real-Time System: Any system in which the time at which output is produced is signicant. This is usually because the input corresponds to some movement in the physical world, and the output has to relate to the same movement. The lag from input time to output time must be suciently small for acceptable timeliness. Oxford Dictionary of Computing", "num_citations": "55\n", "authors": ["1799"]}
{"title": "A framework for comparing efficiency, effectiveness and applicability of software testing techniques\n", "abstract": " Software testing is expensive for the industry, and always constrained by time and effort. Although there is a multitude of test techniques, there are currently no scientifically based guidelines for the selection of appropriate techniques of different domains and contexts. For large complex systems, some techniques are more efficient in finding failures than others and some are easier to apply than others are. From an industrial perspective, it is important to find the most effective and efficient test design technique that is possible to automate and apply. In this paper, we propose an experimental framework for comparison of test techniques with respect to efficiency, effectiveness and applicability. We also plan to evaluate ease of automation, which has not been addressed by previous studies. We highlight some of the problems of evaluating or comparing test techniques in an objective manner. We describe our planned\u00a0\u2026", "num_citations": "53\n", "authors": ["1799"]}
{"title": "Response-time guarantees in ATM networks\n", "abstract": " We present a method for providing response time guarantees in Asynchronous Transfer Mode (ATM) networks. The method is based on traditional real time CPU Response Time Analysis (RTA), and is intended to be used for admission control of hard real time traffic. The method determines if a new connection can be admitted without violating the strict timing requirements specified for the new as well as old connections. We illustrate the merits of our method by comparing it with Weighted Fair Queuing (WFQ) and the Calculus for Network Delays (CND). Two types of comparisons are made. In the first, we evaluate how well the associated analysis can accommodate different traffic scenarios and loads, and in the second comparison we use simulation to compare observed worst case behaviors with estimates obtained by the analysis. The comparisons clearly indicate that RTA outperforms both WFQ and CND for a\u00a0\u2026", "num_citations": "49\n", "authors": ["1799"]}
{"title": "BASEMENT: An architecture and methodology for distributed automotive real-time systems\n", "abstract": " BASEMENT/sup TM/ is a distributed real-time architecture developed for vehicle internal use in the automotive industry. BASEMENT covers application development, as well as the hardware and software that provide execution and communication support. This paper gives an overview of the BASEMENT concept, as well as presenting two system realizations. The first realization is based on the commercial real-time kernel Rubus, while the second is an ultra-dependable architecture (DACAPO) with provisions for fault tolerance at various system levels. BASEMENT is designed for the automotive systems of the future. These systems will be required to simultaneously handle multiple safety critical functions and a large number of less critical functions. All of these features are to be provided at a production cost substantially lower than that of current systems, and, at the same time, with a reliability allowing vehicles to be\u00a0\u2026", "num_citations": "48\n", "authors": ["1799"]}
{"title": "The slack method: A new method for static allocation of hard real-time tasks\n", "abstract": " This article presents and evaluates the Slack Method, a new constructive heuristic for the allocation (mapping) of periodic hard real-time tasks to multiprocessor or distributed systems. The Slack Method is based on task deadlines, in contrast with other constructive heuristics, such as List Processing. The presented evaluation shows that the Slack Method is superior to list-processing-based approaches with regard to both finding more feasible solutions as well as finding solutions with better objective function values.               In a comparative survey we evaluate the Slack Method against several alternative allocation techniques. This includes comparisons with optimal algorithms, non-guided search heuristics (e.g. Simulated Annealing), and other constructive heuristics. The main practical result of the comparison is that a combination of non-guided search and constructive approaches is shown to perform\u00a0\u2026", "num_citations": "46\n", "authors": ["1799"]}
{"title": "Testing distributed real-time systems\n", "abstract": " For testing of sequential software it is usually sufficient to provide the same input (and program state) in order to reproduce the output. For real-time systems (RTS), on the other hand, we need also to control, or observe, the timing and order of the inputs. If the system additionally is multitasking, we also need to take timing and the concurrency of the executing tasks into account.In this paper we present a method for deterministic testing of multitasking RTS, which allows explorative investigations of real-time system behavior. The method includes an analysis technique that given a set of tasks and a schedule derives all execution orderings that can occur during run-time. These orderings correspond to the possible inter-leavings of the executing tasks. The method also includes a testing strategy that using the derived execution orderings can achieve deterministic, and even reproducible, testing of RTS. Since, each\u00a0\u2026", "num_citations": "44\n", "authors": ["1799"]}
{"title": "A decomposition approach for SMT-based schedule synthesis for time-triggered networks\n", "abstract": " Real-time networks have tight communication latency and minimal jitter requirements. One way to ensure these requirements is the implementation of a static schedule, which defines the transmission points in time of time-triggered frames. Synthesizing such static schedules is known to be an NP-complete problem where the complexity is driven by the large number of constraints imposed by the network. Satisfiabily Modulo Theories (SMT) have been proven powerful tools to synthesize schedules of medium-to-large industrial networks. However, the schedules of new extremely large networks, such as integrated multi-machine factory networks, are defined by an extremely large number of constraints exceeding the capabilities of being synthesized by the tool alone. This paper presents a decomposition approach that will allow us to improve to synthesize schedules with up to two orders of magnitude in terms of the\u00a0\u2026", "num_citations": "43\n", "authors": ["1799"]}
{"title": "A Comparative Case Study of Distributed Network Architectures for Different Automotive Applications.\n", "abstract": " In recent years, networking issues have become more and more important in the design of vehicle control systems. In the beginning of the 1990s a vehicle control system was built up by \u2018simple\u2019computer nodes exchanging \u2018simple\u2019and relatively non-critical data. Today we have moved into distributed vehicle control systems with functions spanning several nodes from different vendors. These systems are running on communication architectures consisting of different types of communication busses providing different functionality, from advanced control to entertainment. The challenge is cost efficient development of these systems, with respect to business, functionality, architecture, standards and quality for the automotive industry.In this article we present three different architectures\u2013used in passenger cars, trucks, and construction equipment. Based on these case studies with different business and functionality demands, we will provide an analysis identifying commonalities, differences, and discussing how the different demands are reflected in the network architectures.", "num_citations": "42\n", "authors": ["1799"]}
{"title": "Towards systematic testing of distributed real-time systems\n", "abstract": " Reproducible and deterministic testing of sequential programs can in most cases be achieved by controlling the sequence of inputs to the program. The behavior of a distributed real-time system, on the other hand not only depends on the inputs but also on the order and timing of the concurrent tasks that execute and communicate with each other and the environment. Hence, sequential test techniques are not directly applicable, since they disregard the significance of order and timing of the tasks. In this paper we present a method for identifying all possible orderings of task starts, preemptions and completions for tasks executing in a distributed real-time system. Together with an accompanying testing strategy, this method allows test methods for sequential programs to be applied, since each identified ordering can be regarded as a sequential program. In the presented analysis and testing strategy, we consider\u00a0\u2026", "num_citations": "40\n", "authors": ["1799"]}
{"title": "Towards industry strength worst-case execution time analysis\n", "abstract": " The industrial deployment of real-time modeling and analysis techniques such as schedulability analysis creates an urgent need for methods and tools to calculate the execution time of real-time software. Recent advances in this area are promising, but there is yet no integrated solution taking into account the multitude of aspects relevant for execution time analysis in an industrial context. In this article we present an architectural framework for execution time analysis. The framework is modular and extendible, in that interfaces and data structures are clearly dened to allow new modules to be added and old ones to be replaced, eg, making it possible for analysis modules for dierent CPUs to share the same program ow analysis modules. The architecture is intended to be included in an integrated development environment for real-time programs thereby allowing engineers to integrate execution time analysis in their everyday edit-compile-test-debug cycle. In addition to presenting t...", "num_citations": "40\n", "authors": ["1799"]}
{"title": "A method to generate reusable safety case argument-fragments from compositional safety analysis\n", "abstract": " Safety-critical systems usually need to be accompanied by an explained and well-founded body of evidence to show that the system is acceptably safe. While reuse within such systems covers mainly code, reusing accompanying safety artefacts is limited due to a wide range of context dependencies that need to be satisfied for safety evidence to be valid in a different context. Currently, the most commonly used approaches that facilitate reuse lack support for systematic reuse of safety artefacts.To facilitate systematic reuse of safety artefacts we provide a method to generate reusable safety case argument-fragments that include supporting evidence related to compositional safety analysis. The generation is performed from safety contracts that capture safety-relevant behaviour of components in assumption/guarantee pairs backed up by the supporting evidence. We evaluate the feasibility of our approach in a real\u00a0\u2026", "num_citations": "38\n", "authors": ["1799"]}
{"title": "Wireless automotive communications\n", "abstract": " This paper presents an overview of wireless automotive communication technologies, with the aim of identifying the strong candidates for future in-vehicle and inter-vehicle automotive applications. The paper first gives an overview of automotive applications relying on wireless communications, with particular focus on telematics. Then, the paper identifies the key networking technologies used for in-vehicle and inter-vehicle applications, comparing their properties and indicating future challenges in the area of wireless automotive communications, with a focus on realtime aspects.", "num_citations": "38\n", "authors": ["1799"]}
{"title": "Safe cooperating cyber-physical systems using wireless communication: The SafeCOP approach\n", "abstract": " This paper presents an overview of the ECSEL project entitled \u201cSafe Cooperating Cyber-Physical Systems using Wireless Communication\u201d (SafeCOP), which runs during the period 2016\u20132019. SafeCOP targets safety-related Cooperating Cyber-Physical Systems (CO-CPS) characterised by use of wireless communication, multiple stakeholders, dynamic system definitions (openness), and unpredictable operating environments. SafeCOP will provide an approach to the safety assurance of CO-CPS, enabling thus their certification and development. The project will define a runtime manager architecture for runtime detection of abnormal behaviour, triggering if needed a safe degraded mode. SafeCOP will also develop methods and tools, which will be used to produce safety assurance evidence needed to certify cooperative functions. SafeCOP will extend current wireless technologies to ensure safe and secure\u00a0\u2026", "num_citations": "37\n", "authors": ["1799"]}
{"title": "Component testing is not enough-a study of software faults in telecom middleware\n", "abstract": " The interrelationship between software faults and failures is quite intricate and obtaining a meaningful characterization of it would definitely help the testing community in deciding on efficient and effective test strategies. Towards this objective, we have investigated and classified failures observed in a large complex telecommunication industry middleware system during 2003- 2006. In this paper, we describe the process used in our study for tracking faults from failures along with the details of failure data. We present the distribution and frequency of the failures along with some interesting findings unravelled while analyzing the origins of these failures. Firstly, though \u201csimple\u201d faults happen, together they account for only less than 10%. The majority of faults come from either missing code or path, or superfluous code, which are all faults that manifest themselves for the first time at integration/system level; not at\u00a0\u2026", "num_citations": "35\n", "authors": ["1799"]}
{"title": "Server-based scheduling of the CAN bus\n", "abstract": " In this paper we present a new share-driven server-based method for scheduling messages sent over the controller area network (CAN). Share-driven methods are useful in many applications, since they provide both fairness and bandwidth isolation among the users of the resource. Our method is the first share-driven scheduling method proposed for CAN. Our server-based scheduling is based on earliest deadline first (EDF), which allows higher utilization of the network than using CAN's native fixed-priority scheduling approach. We use simulation to show the performance and properties of server-based scheduling for CAN. The simulation results show that the bandwidth isolation property is kept, and they show that our method provides a quality-of-service (QoS), where virtually all messages are delivered within a specified time.", "num_citations": "33\n", "authors": ["1799"]}
{"title": "SMT-based synthesis of TTEthernet schedules: A performance study\n", "abstract": " Time-triggered networks, like TTEthernet, require adoption of a predefined schedule to guarantee low communication latency and minimal jitter. The synthesis of such schedules is a problem known to be NP-complete. In the past, specialized solvers have been used for synthesizing time-triggered schedules, but more recently general-purpose tools like Satisfiability Modulo Theories (SMT) solvers have reported synthesis of large network schedules in reasonable time for industrial purposes. An interesting characteristic of any general-purpose tool is that its configuration parameters can be tuned in order to fit specific problems and achieve increased performance. This paper presents a study identifying and assessing which SMT solver parameters have the highest impact on the performance when synthesizing schedules for time-triggered networks. The results show that with appropriate values of certain parameters\u00a0\u2026", "num_citations": "32\n", "authors": ["1799"]}
{"title": "Towards a dependable component technology for embedded system applications\n", "abstract": " Component-based software engineering is a technique that has proven effective to increase reusability and efficiency in development of office and Web applications. Though being promising also for development of embedded and dependable systems, the true potential in this domain has not yet been realized. In this paper, we present a prototype component technology developed with safety-critical automotive applications in mind. The technology is illustrated by a case-study, which is also used as the basis for an evaluation and a discussion of the appropriateness and applicability in the considered domain. Our study provides initial positive evidence of the suitability of our technology, but also shows that it needs to be extended to be fully applicable in an industrial context.", "num_citations": "31\n", "authors": ["1799"]}
{"title": "The saveccm language reference manual\n", "abstract": " This language reference describes the syntax and semantics of SaveCCM, a component modeling language for embedded systems designed with vehicle applications and safety concerns in focus. The SaveCCM component model was defined within the SAVE1 project. The SAVE components are influenced mainly by the Rubus component technology [8], with a switch concept similar to that in Koala [10]. The semantics is defined by a transformation into timed automata with tasks, a formalism that explicitly models timing and real-time task scheduling [6].The purpose of this document is to describe a semantics of the SAVE component modeling language, which can be used to describe timing and functional behavior of components. The model of a system is in some cases an over approximation of the actual system behavior. An implementation of a model can resolve non-determinism eg by merging tasks or assigning a scheduling policy (such as static scheduling or fixed priority, preemptive or not) that will resolve the non-determinism.", "num_citations": "31\n", "authors": ["1799"]}
{"title": "Generation of safety case argument-fragments from safety contracts\n", "abstract": " Composable safety certification envisions reuse of safety case argument-fragments together with safety-relevant components in order to reduce the cost and time needed to achieve certification. The argument-fragments could cover safety aspects relevant for different contexts in which the component can be used. Creating argument-fragments for the out-of-context components is time-consuming and currently no satisfying approach exists to facilitate their automatic generation. In this paper we propose an approach based on (semi-)automatic generation of argument-fragments from assumption/guarantee safety contracts. We use the contracts to capture the safety claims related to the component, including supporting evidence. We provide an overview of the argument-fragment architecture and rules for automatic generation, including their application in an illustrative example. The proposed approach\u00a0\u2026", "num_citations": "29\n", "authors": ["1799"]}
{"title": "Automatic generation and validation of models of legacy software\n", "abstract": " The modeling approach is not used to its full potential in maintenance of legacy systems. Often, models do not even exist. The main reasons being that the economic implications and practical hurdles in manually maintaining models of in-use legacy systems are considered too high by the industry. In this paper, we present a method for automated validation of models automatically generated from recordings of executing real-time embedded systems. This forms an essential constituent of a unified process for the automatic modeling of legacy software. We also present a study in which we automatically model a state-of-practice industrial robot control system, the results of which are clearly positive indicators of the viability of our approach", "num_citations": "26\n", "authors": ["1799"]}
{"title": "Strong and weak contract formalism for third-party component reuse\n", "abstract": " Our aim is to contribute to bridging the gap between the justified need from industry to reuse third-party components and skepticism of the safety community in integrating and reusing components developed without real knowledge of the system context. We have developed a notion of safety contract that will help to capture safety-related information for supporting the reuse of software components in and across safety-critical systems. In this paper we present our extension of the contract formalism for specifying strong and weak assumption/guarantee contracts for out-of-context reusable components. We elaborate on notion of satisfaction, including refinement, dominance and composition check. To show the usage and the expressiveness of our extended formalism, we specify strong and weak safety contracts related to a wheel braking system.", "num_citations": "25\n", "authors": ["1799"]}
{"title": "Applicability of the IEC 62443 standard in Industry 4.0/IIoT\n", "abstract": " Today's industrial automation systems are undergoing a digital transformation that implies a shift towards the Internet of Things (IoT), leading to the Industrial Internet of Things (IIoT) paradigm. Existing Industrial Automated Control Systems (IACS), enriched with a potentially large number of IoT devices are expected to make systems more efficient, flexible, provide intelligence, and ultimately enable autonomous control. In general, the majority of such systems come with high level of criticality that calls for well-established methods and approaches when achieving cybersecurity, preferably prescribed by a standard.", "num_citations": "24\n", "authors": ["1799"]}
{"title": "Implementing next generation automotive communications\n", "abstract": " In-car electronics plays an important role in many automotive applications, such as, for example, steer-by-wire and brake-by-wire, and is expected to gradually replace mechanical or hydraulic means to control these systems. The number of electronic components in a car has therefore significantly grown up, thus leading important implications on the vehicle engineering process. In particular, in-car networks used to interconnect electronics equipments are a key point. While in the past extensive use of wiring was a common design practice, nowadays, for the sake of reducing the vehicle weight and fuel consumption, in-car bus networks are largely adopted.", "num_citations": "24\n", "authors": ["1799"]}
{"title": "Guaranteeing real-time traffic through an ATM network\n", "abstract": " Presents a method for providing hard real-time guarantees for traffic through an asynchronous transfer mode (ATM) network. Guaranteed delivery also implies that we have to guarantee that no cells are lost due to over-full buffers in the network. By using priority queues in the output buffers, we allow urgent messages short end-to-end delays, while still guaranteeing end-to-end delays for low-priority messages. We can determine a priori if message deadlines will be met by calculating maximum end-to-end delays and buffer needs. The analysis is based on CPU schedulability analysis, which means that it provides a framework for analysing an entire system, including both CPU and network scheduling.", "num_citations": "24\n", "authors": ["1799"]}
{"title": "Correlating business needs and network architectures in automotive applications-a comparative case study\n", "abstract": " In recent years, networking issues have become more and more important in the design of vehicle control systems. In the beginning of the 1990s a vehicle control system was built up by 'simple' computer nodes exchanging 'simple' and relatively non-critical data. Today we have moved into distributed vehicle control systems with functions spanning several nodes from different vendors. These systems are running on communication architectures consisting of different types of communication buses providing different functionality, from advanced control to entertainment. The challenge is cost efficient development of these systems, with respect to business, functionality, architecture, standards and quality for the automotive industry. In this article we present three different architectures - used in passenger cars, trucks, and construction equipments. Based on these case studies with different business and functionality\u00a0\u2026", "num_citations": "22\n", "authors": ["1799"]}
{"title": "Analysis of mistakes as a method to improve test case design\n", "abstract": " Test Design -- how test specifications and test cases are created -- inherently determines the success of testing. However, test design techniques are not always properly applied, leading to poor testing. We have developed an analysis method based on identifying mistakes made when designing the test cases. Using an extended test case template and an expert review, the method provides a systematic categorization of mistakes in the test design. The detailed categorization of mistakes provides a basis for improvement of the Test Case Design, resulting in better tests. In developing our method we have investigated over 500 test cases created by novice testers. In a comparison with industrial test cases we could confirm that many of these mistake categories remain relevant also in an industrial context. Our contribution is a new method to improve the effectiveness of test case construction through proper application\u00a0\u2026", "num_citations": "20\n", "authors": ["1799"]}
{"title": "Modeling timeouts and unreliable media with a timed probabilistic calculus\n", "abstract": " We use an extension of Milner's Calculus of Communicating Systems (CCS) with discrete time and probabilities to model quantitative aspects of timeouts and unreliable media. As an illustration we provide a specification of the alternating-bit protocol.", "num_citations": "19\n", "authors": ["1799"]}
{"title": "Concurrency bugs in open source software: a case study\n", "abstract": " Concurrent programming puts demands on software debugging and testing, as concurrent software may exhibit problems not present in sequential software, e.g., deadlocks and race conditions. In aiming to increase efficiency and effectiveness of debugging and bug-fixing for concurrent software, a deep understanding of concurrency bugs, their frequency and fixing-times would be helpful. Similarly, to design effective tools and techniques for testing and debugging concurrent software, understanding the differences between non-concurrency and concurrency bugs in real-word software would be useful. This paper presents an empirical study focusing on understanding the differences and similarities between concurrency bugs and other bugs, as well as the differences among various concurrency bug types in terms of their severity and their fixing time, and reproducibility. Our basis is a comprehensive analysis of bug reports covering several generations of five open source software projects. The analysis involves a total of 11860 bug reports from the last decade, including 351 reports related to concurrency bugs. We found that concurrency bugs are different from other bugs in terms of their fixing time and severity while they are similar in terms of reproducibility. Our findings shed light on concurrency bugs and could thereby influence future design and development of concurrent software, their debugging and testing, as well as related tools.", "num_citations": "17\n", "authors": ["1799"]}
{"title": "Schedule reparability: Enhancing time-triggered network recovery upon link failures\n", "abstract": " The time-triggered communication paradigm has been shown to satisfy temporal isolation while providing end to end delay guarantees through the synthesis of an offline schedule. However, this paradigm has severe flexibility limitations as any unpredicted change not anticipated by the schedule, such as a component failure, might result in a loss of frames. A typical solution is to use redundancy or replace and update the schedule offline anew. With the ever increase in size of networks and the need to reduce costs, supplementary solutions that enhance the reliability of such networks are also desired. In this paper, we introduce a repair algorithm capable of reacting to unpredicted link failures. The algorithm quickly modifies the schedule such that all frames are transmitted again within their timing guarantees. We found that the success of our algorithm increases significantly with the existence of empty slots spread\u00a0\u2026", "num_citations": "16\n", "authors": ["1799"]}
{"title": "Period-aware segmented synthesis of schedules for multi-hop time-triggered networks\n", "abstract": " Time-triggered offline scheduling is a cost-efficient way to guarantee low communication end-to-end latency and minimal jitter for communication networks in real-time systems. The schedule is generated pre-runtime and indicates the transmission times of time-triggered frames such that contention is prevented. The synthesis of such offline schedules is a bin-packing problem, known to be NP-complete, with complexity driven by the constraints on frame transmissions, and the number of frames in the schedule. Satisfiability Modulo Theories combined with segmented approaches have been successfully used for synthesizing schedules of large networks. However, such synthesis did not take into account frames periods that are much shorter than the time to execute the schedule cycle. This paper presents a period-aware segmented approach that takes into account the frame periods in order to allocate various\u00a0\u2026", "num_citations": "16\n", "authors": ["1799"]}
{"title": "Towards fully automated test management for large complex systems\n", "abstract": " Development of large and complex software intensive systems with continuous builds typically generates large volumes of information with complex patterns and relations. Systematic and automated approaches are needed for efficient handling of such large quantities of data in a comprehensible way. In this paper we present an approach and tool enabling autonomous behavior in an automated test management tool to gain efficiency in concurrent software development and test. By capturing the required quality criteria in the test specifications and automating the test execution, test management can potentially be performed to a great extent without manual intervention. This work contributes towards a more autonomous behavior within a distributed remote test strategy based on metrics for decision making in automated testing. These metrics optimize management of fault corrections and retest, giving consideration\u00a0\u2026", "num_citations": "16\n", "authors": ["1799"]}
{"title": "An UPPAAL model for formal verification of master/slave clock synchronization over the controller area network\n", "abstract": " Many distributed applications require a clock synchronization service. We have previously proposed a clock synchronization service for the Controller Area Network (CAN), which we have claimed to provide highly synchronized clocks even in the occurrence of faults in the system. In this paper we substantiate this claim by providing a formal model and verification of our fault tolerant clock synchronization mechanism. We base our modeling and verification on timed automata theory as implemented by the model checking tool UPPAAL. In the modeling we introduce a novel technique for modeling drifting clocks. The verification shows that a precision in the order of 2 \u00b5s is guaranteed despite node\u2019s faults as well as consistent channel faults. It also shows that inconsistent channel faults may significantly worsen the achievable precision, but that this effect can be reduced by choosing a suitable resynchronization period.", "num_citations": "16\n", "authors": ["1799"]}
{"title": "Dependable fog computing: A systematic literature review\n", "abstract": " Fog computing has been recently introduced to bridge the gap between cloud resources and the network edge. Fog enables low latency and location awareness, which is considered instrumental for the realization of IoT, but also faces reliability and dependability issues due to node mobility and resource constraints. This paper focuses on the latter, and surveys the state of the art concerning dependability and fog computing, by means of a systematic literature review. Our findings show the growing interest in the topic but the relative immaturity of the technology, without any leading research group. Two problems have attracted special interest: guaranteeing reliable data storage/collection in systems with unreliable and untrusted nodes, and guaranteeing efficient task allocation in the presence of varying computing load. Redundancy-based techniques, both static and dynamic, dominate the architectures of such\u00a0\u2026", "num_citations": "15\n", "authors": ["1799"]}
{"title": "Towards mode switch handling in component-based multi-mode systems\n", "abstract": " Component-based software engineering (CBSE) is becoming a prominent solution to the development of complex embedded systems. Meanwhile, partitioning system behavior into different modes is an effective approach to reduce system complexity. Combining the two, we get a component-based multi-mode system, for which a key issue is its mode switch handling. The mode switch of such a system corresponds to the joint mode switches of many hierarchically organized components. Such a composable mode switch is not trivial as it amounts to coordinate the mode switches of different components. In this paper, we identify the major challenges of the composable mode switch handling and classify existing approaches with respect to how they handle these challenges. We also provide a more detailed presentation of the corresponding solutions included in our approach--the Mode Switch Logic (MSL).", "num_citations": "15\n", "authors": ["1799"]}
{"title": "Response time guarantees for ATM-networked control systems\n", "abstract": " We present the Response-Time Analysis (RTA) method for providing real time guarantees in asynchronous transfer mode (ATM) communication networks, and evaluates its suitability for use in hard real time factory type environments. RTA provides an analysis of the network traffic which can be used by an admission control mechanism to determine if the timing requirements of a new connection can be guaranteed without violating the requirements of already admitted connections. This type of admission control is required by several multimedia and almost all real time control applications. RTA is based on traditional fixed priority/rate monotonic real time CPU schedulability analysis. This makes it possible to combine communication analysis with CPU schedulability analysis, thus allowing system designers to use the same technique for assessing the timely behaviour of the entire system, including both CPU and\u00a0\u2026", "num_citations": "15\n", "authors": ["1799"]}
{"title": "A process calculus with incomparable priorities\n", "abstract": " We define an asynchronous process calculus in which priorities are associated to transitions. The calculus distinguishes between transitions originating from different processes by regarding their priorities to be incomparable. We define a prioritized bisimulation equivalence and discuss its relation to \u201cthe natural\u201d congruence relation for our calculus. We illustrate the calculus with two small examples.", "num_citations": "15\n", "authors": ["1799"]}
{"title": "Timing analysis for mode switch in component-based multi-mode systems\n", "abstract": " Component-Based Development (CBD) reduces development time and effort by allowing systems to be built from pre-developed reusable components. Partitioning the behavior into a set of major operational modes is a classical approach to reduce complexity of embedded systems design and execution. In supporting system modes in CBD, a key issue is seamless composition of pre-developed multi-mode components into systems. We have previously developed a Mode Switch Logic (MSL) for component-based multi-mode systems implementing such seamless composition. In this paper we extend our MSL to cope with atomic transactions, i.e., to handle sets of components that must not be aborted in the middle of the processing of data. This is in contrast with our original MSL, in which components are immediately aborted to perform a mode switch. Based on our extended MSL, we provide analysis of the mode\u00a0\u2026", "num_citations": "13\n", "authors": ["1799"]}
{"title": "Handling interrupts in testing of distributed real-time systems\n", "abstract": " Testing techniques for sequential software are well established. Unfortunately, these testing techniques are not directly applicable to distributed real-time systems. In previous work we have proposed a method for reproducible and deterministic testing of distributed real-time systems. This method identifies all possible orderings of task starts, preemptions and completions. Each ordering is regarded as a sequential program, and can as such be tested with standard sequential testing techniques. In this paper we extend our method to also handle interrupts. This is essential since critical parts of most real world systems are managed by interrupts.", "num_citations": "13\n", "authors": ["1799"]}
{"title": "Towards classification of concurrency bugs based on observable properties\n", "abstract": " In software engineering, classification is a way to find an organized structure of knowledge about objects. Classification serves to investigate the relationship between the items to be classified, and can be used to identify the current gaps in the field. In many cases users are able to order and relate objects by fitting them in a category. This paper presents initial work on a taxonomy for classification of errors (bugs) related to concurrent execution of application level software threads. By classifying concurrency bugs based on their corresponding observable properties, this research aims to examine and structure the state of the art in this field, as well as to provide practitioner support for testing and debugging of concurrent software. We also show how the proposed classification, and the different classes of bugs, relates to the state of the art in the field by providing a mapping of the classification to a number of recently\u00a0\u2026", "num_citations": "12\n", "authors": ["1799"]}
{"title": "Towards dynamic safety assurance for Industry 4.0\n", "abstract": " The goal of Industry 4.0 is to be faster, more efficient and more customer-centric, by enhancing the automation and digitalisation of production systems. Frequently, the production in Industry 4.0 is categorised as safety-critical, for example, due to the interactions between autonomous machines and hazardous substances that can result in human injury or death, damage to machines, property or the environment. In order to demonstrate the acceptable safety of production operations, safety cases are constructed to provide comprehensive, logical and defensible justification of the safety of a production system for a given application in a predefined operating environment. However, the construction and maintenance of safety cases in alignment with Industry 4.0 are challenging tasks. For their construction, besides the modular, dynamic and reconfigurable nature of Industry 4.0, the architectural levels of the things, fog\u00a0\u2026", "num_citations": "11\n", "authors": ["1799"]}
{"title": "A mode mapping mechanism for component-based multi-mode systems\n", "abstract": " Component-Based Development (CBD) reduces development time and effort by allowing systems to be built from pre-developed reusable components. A classical approach to reduce embedded systems design and run-time complexity is to partition the behavior into a set of major system modes. In supporting system modes in CBD, a key issue is seamless composition of multi-mode components into systems. In addressing this issue, we previously developed a Mode Switch Logic (MSL) for component-based multi-mode systems. Our MSL implements seamless coordination and synchronization of mode switch in systems composed of independently developed components. However, our original MSL is based on the, in a setting of reusable components, unrealistic assumption, that all the components of a system support the same modes. This considerably limits the feasibility of our MSL. In this paper we lift this assumption and propose a mode mapping mechanism that enables assembly of components supporting different sets of modes. We demonstrate our mode mapping mechanism by a simple example application.", "num_citations": "11\n", "authors": ["1799"]}
{"title": "Composable mode switch for component-based systems\n", "abstract": " Component based software development (CBD) reduces development time and effort by allowing systems to be built from pre-developed reusable components. A classical approach to reduce embedded systems design and run-time complexity is to partition the behavior into a set of major system modes. In supporting system modes in CBD, a key issue is seamless composition of multi-mode components into systems. In addressing this issue, we present a mode switch logic and algorithm for component-based multi-mode systems. The algorithm implements seamless coordination and synchronization of mode switch in systems composed of independently developed components. The paper provides formally defined semantics covering aspects relevant for mode switch, together with algorithms implementing mode switch rules for different types of components. The approach is illustrated by a simple example.", "num_citations": "11\n", "authors": ["1799"]}
{"title": "Evaluating the quality of models extracted from embedded real-time software\n", "abstract": " Due to the high cost of modeling, model-based techniques are yet to make their impact in the embedded systems industry, which still persist on maintaining code-oriented legacy systems. Re-engineering existing code-oriented systems to fit model-based development is a risky endeavor due to the cost and efforts required to maintain correspondence between the code and model. We aim to reduce the cost of modeling and model maintenance by automating the process, thus facilitating model-based techniques. We have previously proposed the use of automatic model extraction from recordings of existing embedded real-time systems. To estimate the quality of the extracted models of timing behavior, we need a framework for objective evaluation. In this paper, we present such a framework to empirically test and compare extracted models, and hence obtain an implicit evaluation of methods for automatic model\u00a0\u2026", "num_citations": "11\n", "authors": ["1799"]}
{"title": "Using UPPAAL to model and verify a clock synchronization protocol for the controller area network\n", "abstract": " A reported liability of the controller area network protocol is that it does not provide a clock synchronization service. Therefore, whenever a CAN-based distributed embedded system requires its nodes to have a common time base, clock synchronization has to be implemented by means of an external mechanism. In a previous work, we proposed a fault-tolerant and high-precision clock synchronization protocol for CAN. This paper shows the first steps towards the formal verification of this protocol. In particular, it presents a formal model that has been built with the UPPAAL model checker and discusses how clock drift and clock correction can be modeled with this tool", "num_citations": "11\n", "authors": ["1799"]}
{"title": "Evaluating the performance of wait-free snapshots in real-time systems\n", "abstract": " Snap-shot mechanisms are used to read a globally consistent set of variable values. Such a mechanism can be used to solve a variety of communication and synchronization problems, including system monitoring and control of real-time applications. Methods based on locking (eg using semaphores) are penalized by blocking, which typically leads to difficulties in guaranteeing deadlines of high priority tasks. Lock-free methods, which take a snap-shot and then check if it corresponds to a consistent system state, have unpredictable timing-behavior, since they may have to retry an unpredictable number of times. Clearly, a method which combines the predictability of locking-based methods with the low interference (no blocking) of lock-free methods is desirable.In this paper we present one such method, based and the concept of wait-freeness. A wait-free method is a lockfree method which is guaranteed to correctly complete in a bounded number of steps. The price to pay for this predictability in the timing domain is the need for more than one copy of the shared objects. In addition to proving our method correct, we evaluate it analytically by formulating and comparing schedulability equations for snapshots in systems using lock-based, lock-free, and our wait-free method. We also outline how the different snapshot meth-", "num_citations": "11\n", "authors": ["1799"]}
{"title": "Handling multiple mode switch scenarios in component-based multi-mode systems\n", "abstract": " The growing complexity of embedded systems software entails new development techniques. Component-Based Software Engineering is undoubtedly suitable for the development of complex systems thanks to its inherent component reuse. Another approach to reduce software complexity is by partitioning the system behavior into different operational modes. Each mode is associated with a unique behavior and the system can change behavior by switching between modes. When such a multi-mode system is developed by reusable software components, a crucial issue is how to achieve a seamless composition of multi-mode components and also how to handle mode switch properly. As an integrated solution to the challenges of multi-mode component-based software system development we have proposed the Mode Switch Logic (MSL). The current version of MSL assumes independent handling of a single\u00a0\u2026", "num_citations": "10\n", "authors": ["1799"]}
{"title": "Mode switch timing analysis for component-based multi-mode systems\n", "abstract": " The growing complexity of embedded systems software requires new techniques for their development. A common approach to reducing software complexity is to partition system behavior into different operational modes. Such a multi-mode system can change its behavior by switching between modes under certain circumstances. Another approach to simplifying software development is Component-Based Software Engineering, which allows a system to be developed by reusable components. Combining both approaches, we get component-based development of multi-mode systems, for which a key issue is the mode switch handling. Since most existing mode switch techniques do not consider component-based systems, we present in this article an approach\u2014the Mode Switch Logic (MSL)\u2014for the development of component-based multi-mode systems. Additionally, we provide a timing analysis for the mode\u00a0\u2026", "num_citations": "10\n", "authors": ["1799"]}
{"title": "Mode switch handling for the ProCom component model\n", "abstract": " Component-Based Software Engineering has been deemed a suitable technique for the development of complex embedded systems, as component reuse makes it easier to manage software complexity. Another way of reducing software complexity is by partitioning system behavior into different operational modes. Such a multi-mode system can change its behavior by switching between modes. For a multi-mode system built by components, a challenge is its mode switch handling.", "num_citations": "10\n", "authors": ["1799"]}
{"title": "Fostering reuse within safety-critical component-based systems through fine-grained contracts\n", "abstract": " Our aim is to develop a notion of safety contracts and related reasoning that supports the reuse of software components in and across safety-critical systems, including support for certification related activities such as using the contract reasoning in safety argumentation.In this paper we introduce a formalism for specifying assumption/guarantee contracts for components developed out of context. We are utilising the concepts of weak and strong assumptions and guarantees to customise fine-grained contracts for addressing a broader component context and specification of properties for specific alternative contexts. These out of context contracts can be conveniently instantiated to a specific context, thereby providing support for component reuse.", "num_citations": "10\n", "authors": ["1799"]}
{"title": "Reliability modelling of time-critical distributed systems\n", "abstract": " In cost conscious industries, such as automotive, it is imperative for designers to adhere to policies that reduce system resources to the extent feasible, even for safety-critical sub-systems. However, the overall reliability requirement, typically in the order of 10-9 faults/hour, must be both analysable and met. Faults can be hardware, software or timing faults. The latter being handled by hard-real time schedulability analysis, which is used to prove that no timing violations will occur. However, from a reliability and cost perspective there is a tradeoff between timing guarantees, the level of hardware and software faults, and the per-unit cost for meeting the overall reliability requirement.               This paper outlines a reliability analysis method that considers the effect of faults on schedulability analysis and its impact on the reliability estimation of the system. The ideas have general applicability, but the method has\u00a0\u2026", "num_citations": "10\n", "authors": ["1799"]}
{"title": "Methods for large-scale time-triggered network scheduling\n", "abstract": " Future cyber\u2013physical systems may extend over broad geographical areas, like cities or regions, thus, requiring the deployment of large real-time networks. A strategy to guarantee predictable communication over such networks is to synthesize an offline time-triggered communication schedule. However, this synthesis problem is computationally hard (NP-complete), and existing approaches do not scale satisfactorily to the required network sizes. This article presents a segmented offline synthesis method which substantially reduces this limitation, being able to generate time-triggered schedules for large hybrid (wired and wireless) networks. We also present a series of algorithms and optimizations that increase the performance and compactness of the obtained schedules while solving some of the problems inherent to segmented approaches. We evaluate our approach on a set of realistic large-size multi-hop networks, significantly larger than those considered in the existing literature. The results show that our segmentation reduces the synthesis time by up to two orders of magnitude. View Full-Text", "num_citations": "9\n", "authors": ["1799"]}
{"title": "Tool-supported safety-relevant component reuse: From specification to argumentation\n", "abstract": " Contracts are envisaged to support compositional verification of a system as well as reuse and independent development of their implementations. But reuse of safety-relevant components in safety-critical systems needs to cover more than just the implementations. As many safety-relevant artefacts related to the component as possible should be reused together with the implementation to assist the integrator in assuring that the system they are developing is acceptably safe. Furthermore, the reused assurance information related to the contracts should be structured clearly to communicate the confidence in the component. In this work we present a tool-supported methodology for contract-driven assurance and reuse. We define the variability on the contract level in the scope of a trace-based approach to contract-based design. With awareness of the hierarchical nature of systems subject to compositional\u00a0\u2026", "num_citations": "9\n", "authors": ["1799"]}
{"title": "Configuration-aware contracts\n", "abstract": " Assumption/guarantee contracts represent the basis for independent development of reusable components and their safety assurance within contract-based design. In the context of safety-critical systems, their use for reuse of safety assurance efforts has encountered some challenges: the need for evidence supporting the confidence in the contracts; and the challenge of context, where contracts need to impose different requirements on different systems.                 In this paper we propose the notion of configuration-aware contracts to address the challenge contract-based design faces with multiple contexts. Since reusable components are often developed with a set of configuration parameters that need to be configured in each context, we extend the notion of contract to distinguish between the configuration parameters and the other variables. Moreover, we define a multi-context reusable component\u00a0\u2026", "num_citations": "9\n", "authors": ["1799"]}
{"title": "A study of concurrency bugs in an open source software\n", "abstract": " Concurrent programming puts demands on software debugging and testing, as concurrent software may exhibit problems not present in sequential software, e.g., deadlocks and race conditions. In aiming to increase efficiency and effectiveness of debugging and bug-fixing for concurrent software, a deep understanding of concurrency bugs, their frequency and fixing-times would be helpful. Similarly, to design effective tools and techniques for testing and debugging concurrent software understanding the differences between non-concurrency and concurrency bugs in real-word software would be useful. This paper presents an empirical study focusing on understanding the differences and similarities between concurrency bugs and other bugs, as well as the differences among various concurrency bug types in terms of their severity and their fixing time. Our basis is a comprehensive analysis of bug reports\u00a0\u2026", "num_citations": "9\n", "authors": ["1799"]}
{"title": "Wait-free snapshots in real-time systems: algorithms and performance\n", "abstract": " Snap-shot mechanisms are used to read a globally consistent set of variable values. Methods based on locking are penalized by blocking, which typically leads to difficulties in guaranteeing deadlines of high priority tasks. A method which combines the predictability of locking-based methods with the low interference (no blocking) of lock-free methods is desirable. In this paper we present one such method, based and the concept of wait-freeness. A wait-free method is a lock-free method which is guaranteed to correctly complete in a bounded number of steps. The price to pay for this predictability in the timing domain is the need for more than one copy of the shared objects. We evaluate our method analytically by formulating and comparing schedulability equations for snapshots in systems using lock-based lock-free and our wait-free method. We also outline ideas to study the effects of using the different snapshot\u00a0\u2026", "num_citations": "9\n", "authors": ["1799"]}
{"title": "Cybersecurity Challenges in Large Industrial IoT Systems\n", "abstract": " To achieve efficient and flexible production at affordable prices, industrial automation is pushed towards a digital transformation. Such a transformation assumes an enhancement of current Industrial Automated Control Systems with a large amount of IoT-devices, forming an Industrial Internet of Things (IIoT). The aim is to enable a shift from automatic towards autonomous control in such systems. This paper discusses some of the main challenges IIoT systems are facing with respect to cybersecurity. We discuss our findings in an example of a flow-control loop, where we apply a simple threat model based on the STRIDE method to deduce cybersecurity requirements in an IIoT context. Moreover, the identified requirements are assessed in the light of current state of the art solutions, and a number of challenges are discussed with respect to a large-scale IIoT system, together with some suggestions for future work.", "num_citations": "8\n", "authors": ["1799"]}
{"title": "Using safety contracts to guide the integration of reusable safety elements within ISO 26262\n", "abstract": " Safety-critical systems usually need to comply with a domain-specific safety standard. To reduce the cost and time needed to achieve the standard compliance, reuse of safety-relevant components is not sufficient without the reuse of the accompanying artefacts. Developing reusable safety components out-of-context of a particular system is challenging, as safety is a system property, hence support is needed to capture and validate the context assumptions before integration of the reusable component and its artefacts in-context of the particular system. We have previously developed a concept of strong and weak safety contracts to facilitate systematic reuse of safety-relevant components and their accompanying artefacts. In this work we define a safety contracts development process and provide guidelines to bridge the gap between reuse of safety elements developed out-of-context of a particular system and their\u00a0\u2026", "num_citations": "8\n", "authors": ["1799"]}
{"title": "Dynamic reconfiguration of safety-critical production systems\n", "abstract": " The current trends of digitalization and Industry 4.0 are bringing ample opportunities for manufacturing industry to fine tune their products and processes at will, to meet changing market needs within short notice. However, the characteristics of advanced production systems, such as dynamic interactions between machines and reconfigurations, if not carefully orchestrated, could potentially lead to production failures or mishaps, making them safety-critical. Previous studies on hazard analysis, safety-performance tradeoffs and assurance cases have not specifically considered the dynamic reconfiguration scenarios in production systems. In this paper, for the hazard identification and mitigation/elimination, the principal characteristics of highly reconfigurable production systems have been given special consideration. Even if the hazard analysis results are incorporated in the initial designs of production systems\u00a0\u2026", "num_citations": "7\n", "authors": ["1799"]}
{"title": "Inadequate risk analysis might jeopardize the functional safety of modern systems\n", "abstract": " In the early 90s, researchers began to focus on security as an important property to address in combination with safety. Over the years, researchers have proposed approaches to harmonize activities within the safety and security disciplines. Despite the academic efforts to identify interdependencies and to propose combined approaches for safety and security, there is still a lack of integration between safety and security practices in the industrial context, as they have separate standards and independent processes often addressed and assessed by different organizational teams and authorities. Specifically, security concerns are generally not covered in any detail in safety standards potentially resulting in successfully safety-certified systems that still are open for security threats from e.g., malicious intents from internal and external personnel and hackers that may jeopardize safety. In recent years security has again received an increasing attention of being an important issue also in safety assurance, as the open interconnected nature of emerging systems makes them susceptible to security threats at a much higher degree than existing more confined products.This article presents initial ideas on how to extend safety work to include aspects of security during the context establishment and initial risk assessment procedures. The ambition of our proposal is to improve safety and increase efficiency and effectiveness of the safety work within the frames of the current safety standards, i.e., raised security awareness in compliance with the current safety standards. We believe that our proposal is useful to raise the security awareness in industrial contexts\u00a0\u2026", "num_citations": "7\n", "authors": ["1799"]}
{"title": "Managing redundancy in CAN-based networks supporting N-Version Programming\n", "abstract": " Software is a major source of reliability degradation in dependable systems. One of the classical remedies is to provide software fault tolerance by using N-Version Programming (NVP). However, due to requirements on non-standard hardware and the need for changes and additions at all levels of the system, NVP solutions are costly, and have only been used in special cases.In a previous work, a low-cost architecture for NVP execution was developed. The key features of this architecture are the use of off-the-shelf components including communication standards and that the fault tolerance functionality, including voting, error detection, fault-masking, consistency management, and recovery, is moved into a separate redundancy management circuitry (one for each redundant computing node).In this article we present an improved design of that architecture, specifically resolving some potential inconsistencies that\u00a0\u2026", "num_citations": "7\n", "authors": ["1799"]}
{"title": "SAVEComp-a Dependable Component Technology for Embedded Systems Software\n", "abstract": " Component-Based Software Engineering is a technique that has proven effective to increase reusability and efficiency in development of office and web applications. Though being promising also for development of embedded and dependable systems, the true potential in this domain has not yet been realized.In this paper we present a prototype component technology, developed with safetycritical automotive applications in mind. The technology is illustrated by a case-study, which is also used as the basis for an evaluation and a discussion of the appropriateness and applicability in the considered domain. Our study provides initial positive evidence of the suitability of our technology, but also shows that it needs to be extended to be fully applicable in an industrial context.", "num_citations": "7\n", "authors": ["1799"]}
{"title": "Schedule synthesis for next generation time-triggered networks\n", "abstract": " For handling frame transmissions in highly deterministic real-time networks, ie networks requiring low communication latency and minimal jitter, an offline time-triggered schedule indicating the dispatch times of all frames can be used. Generation of such an offline schedule is known to be a NPcomplete problem, with complexity driven by the size of the network, the number and complexity of the traffic temporal constraints, and link diversity (for instance, coexistence of wired and wireless links). As embedded applications become more complex and extend over larger geographical areas, there is a need to deploy larger real-time networks, but existing schedule synthesis mechanisms do not scale satisfactorily to the sizes of these networks, constituting a potential bottleneck for system designers. In this paper, we present an offline synthesis tool that overcomes this limitation and is capable of generating time-triggered schedules for networks with hundreds of nodes and thousands of temporal constraints, also for systems where wired and wireless links are combined. This tool models the problem with linear arithmetic constraints and solves them using a Satisfiability Modulo Theory (SMT) solver, a powerful general purpose tool successfully used in the past for synthesizing time-triggered schedules. To cope with complexity, our algorithm implements a segmented approach that divides the total problem into easily solvable smaller-size scheduling problems, whose solutions can be combined for achieving the final schedule. The paper also discusses a number of optimizations that increase the size and compactness of the solvable schedules. We\u00a0\u2026", "num_citations": "6\n", "authors": ["1799"]}
{"title": "Timing analysis for a composable mode switch\n", "abstract": " Component based software development (CBD) reduces development time and effort by allowing systems to be built from pre-developed reusable components. A classical approach to reduce embedded systems design and run-time complexity is to partition the behavior into a set of major system modes. In supporting system modes in CBD, a key issue is seamless composition of multi-mode components into systems. In addressing this issue, we have developed a mode switch logic and algorithm for component-based multi-mode systems. In this paper we introduce timing analysis for our composable mode switch.", "num_citations": "6\n", "authors": ["1799"]}
{"title": "Hierarchical scheduling of CAN using server-based techniques\n", "abstract": " Server-based scheduling of CAN has been proposed as a way of fair scheduling of the Controller Area Network (CAN). By separating streams of messages by using network access servers (N-Servers), scheduling is performed at three layers where native CAN message arbitration is the scheduling at the lowest level. On top of this is the server-based scheduling to separate different streams of messages within the system. Looking at a single N-Server, several streams might share one server. Hence, scheduling is performed at the third level every time the N-Server is being scheduled for message transmission. Here different queuing policies play a role in the scheduling performed. This paper discusses the hierarchical scheduling of CAN, as a way of fair separation of message streams while providing a flexible core mechanism, the serverbased scheduling of CAN.", "num_citations": "6\n", "authors": ["1799"]}
{"title": "Effects of varying phasings of message queuings in CAN based systems\n", "abstract": " This article presents and illustrates the effects on message response times by considering variations in phasings of message queuings in distributed system using the CAN bus. Traditional worst-case analysis is based on very pessimistic assumptions. This may be correct from a hard real-time perspective, but from a system perspective where reliability is also an issue, this may lead to an unnecessary costly and over-designed system. The worst-case analysis assumes worst-case phasings of message queuings, and that messages are constantly queued with highest possible frequency. In this paper we will investigate the level of introduced pessimism by looking into the effects of relaxing these assumptions. We will investigate the pessimism by simulating these systems, both without taking into account the effects of phasing, and with. We show the actual effect with a simple case-study. The motivation for this paper is to underline the pessimism introduced by not considering phasings. Simulation results show the pessimism by not considering phasings.", "num_citations": "6\n", "authors": ["1799"]}
{"title": "Towards deterministic testing of distributed real-time systems\n", "abstract": " Reproducible and deterministic testing of sequential programs can in most cases be achieved by controlling the sequence of inputs to the program. The behavior of a distributed real-time system, on the other hand, not only depends on the inputs but also on the order and timing of the concurrent tasks that execute and communicate with each other and the environment. Hence, sequential test techniques are not directly applicable, since they disregard the significance of order and timing. In this paper we present a method for identifying all the possible orderings of task starts, preemptions and completions for tasks executing in distributed real-time systems. Together with an accompanying testing strategy this method allows test methods for sequential programs to be used, since each identified ordering can be regarded as a sequential program. In the presented analysis, and testing strategy, we take into account the effects of interrupts, clock synchronization, and varying start and execution times of the involved tasks.", "num_citations": "6\n", "authors": ["1799"]}
{"title": "Analysing multimedia traffic in real-time ATM networks\n", "abstract": " We present a method for providing response-time guarantees for multimedia traffic in Asynchronous Transfer Mode (ATM) networks. The method extends our Response-Time Analysis (RTA) for ATM networks to better capture the behaviour of MPEG-type multimedia traffic. RTA is intended for admission control of hard real time traffic, i.e., it determines if a new connection can be admitted without violating the timing requirements of the new as well as any already admitted connection. We evaluate the extended RTA by comparing it with our original RTA, which does not consider the specific traffic patterns of MPEG-type multimedia traffic. In addition, we show how Weighted Fair Queueing (WFQ) and Calculus for Network Delays (CND) can be adopted to MPEG-type multimedia traffic, and compare the thus obtained analysis with our extended RTA. Evaluations indicate that our new method yields both higher achievable\u00a0\u2026", "num_citations": "6\n", "authors": ["1799"]}
{"title": "A logic for reasoning about time and reability\n", "abstract": " We present a logic for stating properties such as, \"after a request for service there is at least a 98\\045 probability that the service will be carried out within 2 seconds\". The logic extends the temporal logic CTL by Emerson, Clarke and Sistla with time and probabil- ities. Formulas are interpreted over discrete time Markov chains. We give algorithms for checking that a given Markov chain satis- fies a formula in the logic. The algorithms require a polynomial number of arithmetic operations, in size of both the formula and\\003This research report is a revised and extended version of a paper that has appeared under the title \"A Framework for Reasoning about Time and Reliability\" in the Proceeding of the 10thIEEE Real-time Systems Symposium, Santa Monica CA, December 1989. This work was partially supported by the Swedish Board for Technical Development (STU) as part of Esprit BRA Project SPEC, and by the\u00a0\u2026", "num_citations": "6\n", "authors": ["1799"]}
{"title": "Access Control for Smart Manufacturing Systems\n", "abstract": " In the ongoing  industrial revolution, a new paradigm of modular and flexible manufacturing factories powered by IoT devices, cloud computing, big data analytics and artificial intelligence is emerging. It promises increased cost efficiency, reduced time-to-market and extreme customization. However, there is a risk that technical assets within such systems will be targeted by cybersecurity attacks. A compromised device in a smart manufacturing system could cause a significant damage, not only economically for the factory owner, but also physically on humans, machinery and the environment. Strict and granular Access Control is one of the main protective mechanisms against compromised devices in any system. In this paper we discuss the requirements and implications of Access Control within the context of Smart Manufacturing. The contributions of this paper are twofold: first we derive requirements on an\u00a0\u2026", "num_citations": "5\n", "authors": ["1799"]}
{"title": "Better, faster, cheaper, and safer too\u2014Is this really possible?\n", "abstract": " Increased levels of automation together with increased complexity of automation systems brings increased responsibility on the system developers in terms of quality demands from the legal perspectives as well as company reputation. Component based development of software systems provides a viable and cost-effective alternative in this context provided one can address the quality and safety certification demands in an efficient manner. In this paper we present our vision, challenges and a brief outline of various research themes in which our team is engaged currently within two major projects.", "num_citations": "5\n", "authors": ["1799"]}
{"title": "Experiments with Component Test to Improve Software Quality\n", "abstract": " Testing is a costly and an important activity in the software industry today. The systems are becoming more complex and the amount of code is constantly increasing. The majority of systems need to rely on its testing to show that it works, is reliable, and performs according to user expectations and specifications.Testing is performed in a multitude of ways, using different test approaches. How testing is conducted becomes essential, when time is limited, since exhaustive testing is not an option in large complex systems, Therefore, the design of the individual test case\u2013and what part and aspect of the system it exercises, is the main focus of testing. Not only do we need to create, and execute test cases efficiently, but we also want them to expose important faults in the system. This main topic of testing has long been a focus of practitioners in industry, and there exists over 70 test techniques that aim to describe how to design a test case. Unfortunately, despite the industrial needs, research on test techniques are seldom performed in large complex systems.", "num_citations": "5\n", "authors": ["1799"]}
{"title": "Real-time in embedded systems\n", "abstract": " In this chapter we will provide an introduction to issues, techniques, and trends in real-time systems (RTSs). We will specifically discuss design of RTSs, real-time operating systems (RTOSs), real-time scheduling, real-time communication, real-time analysis, as well as testing and debugging of RTSs. For each of these areas, state-of-the-art tools and standards are presented.ABSTRACT", "num_citations": "5\n", "authors": ["1799"]}
{"title": "Integration testing of fixed priority scheduled real-time systems\n", "abstract": " In order to achieve reproducible and deterministic functional integration testing of real-time systems software it is essential to consider inputs, outputs, and the order in which the tasks communicate and synchronize with each other. In this paper we present a method for deterministic integration testing of strictly periodic fixed priority scheduled real-time systems. Essentially it is a structural white box testing method applied on the system level rather than the individual programs of the tasks. The method includes a reachability technique for deriving all possible orderings of task starts, preemptions and completions for tasks executing in a system where synchronization is resolved using the Priority Ceiling Emulation Protocol (PCEP) or offsets. The method also includes a structural testing strategy for achieving full coverage with respect to the derived execution orderings. The testing strategy also allow test methods for sequential programs to be applied, since each identified ordering can be regarded as a sequential program. In the presented analysis and testing strategy, we consider task sets with recurring release patterns, and take into account the effects of variations in start and execution times of the involved tasks, as well as the variations of the arrival and duration of the critical sections.", "num_citations": "5\n", "authors": ["1799"]}
{"title": "A runtime verification tool for detecting concurrency bugs in freertos embedded software\n", "abstract": " This article presents a runtime verification tool for embedded software executing under the open source real-time operating system FreeRTOS. The tool detects and diagnoses concurrency bugs such as deadlock, starvation, and suspension based-locking. The tool finds concurrency bugs at runtime without debugging and tracing the source code. The tool uses the Tracealyzer tool for logging relevant events. Analysing the logs, our tool can detect the concurrency bugs by applying algorithms for diagnosing each concurrency bug type individually. In this paper, we present the implementation of the tool, as well as its functional architecture, together with illustration of its use. The tool can be used during program testing to gain interesting information about embedded software executions. We present initial results of running the tool on some classical bug examples running on an AVR 32-bit board SAM4S.", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Flexible and efficient reuse of multi-mode components for building multi-mode systems\n", "abstract": " Software component reuse is deemed as an effective technique for managing the growing software complexity of large systems. Software complexity can also be reduced by partitioning the system behavior into different modes. Such a multi-mode system can change behavior by switching between modes under certain circumstances. Integrating component reuse and the multi-mode approach, we have developed the Mode Switch Logic (MSL), a framework dedicated to the development of multi-mode systems composed by reusable multi-mode components, i.e. components which can run in different modes. The mode switch handling of MSL is based on a fully distributed architecture in the sense that a system mode switch is achieved by the joint mode switches of different independently developed components. In this paper, we propose a mode transformation technique as a supplement to MSL for\u00a0\u2026", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Handling emergency mode switch for component-based systems\n", "abstract": " Software reuse is deemed as an effective technique for managing the growing software complexity of large systems. Software complexity can also be reduced by partitioning the system behavior into different modes. Such a multi-mode system is able to dynamically change its behavior by switching between different modes. When a multi-mode system is developed by reusable software components, a crucial issue is how to achieve a seamless composition of multi-mode components and handle mode switch properly. This is the motivation for the Mode Switch Logic (MSL), supporting the development of component-based multi-mode systems by providing mechanisms for mode switch handling. In this paper, MSL is extended and adapted to systems with emergency triggering of mode switches that must be handled with minimal delay. We propose an Immediate Handling with Buffering (IHB) approach to enable the\u00a0\u2026", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Automated specification and verification of functional safety in heavy-vehicles: The VeriSpec approach\n", "abstract": " ISO 26262 is the new standard for automotive functional safety. This standard identifies major process steps across a large number of system stages as well as safety-related artifacts required as input and output of these steps. The VeriSpec project intends to identify the main challenges for the adoption of ISO 26262 by the heavy-vehicle industry and to provide useful and industrially relevant \u201ccomponents\u201d (methods, tools etc.) required by the standard. The project work targets two main research goals: (i) requirement formalization support, including a usable front-end for specifying requirements by using patterns, and (ii) formal analysis of realizations in form of architectural models at various levels of abstraction, by model-checking the formal representations of the latter. In this paper, we present the current challenges facing industry and justifying VeriSpec, together with a preliminary roadmap for the research.", "num_citations": "4\n", "authors": ["1799"]}
{"title": "A UPPAAL model for timing analysis of atomic execution in component-based multi-mode systems\n", "abstract": " This report provides a complete UPPAAL model of an Atomic Execution Group (AEG) in a component-based multi-mode system (CBMMS) with pipe-and-filter architecture. The purpose of this model is to analyze the worst-case latency due to the atomic execution of this AEG during a mode switch. This worst-case latency plays a significant role in deriving the global mode switch time of a CBMMS.", "num_citations": "4\n", "authors": ["1799"]}
{"title": "A Mode Switch Logic for component-based multi-mode systems\n", "abstract": " Component-Based Development (CBD) reduces development time and effort by allowing systems to be built from pre-developed reusable components. A classical approach to reduce embedded systems design and run-time complexity is to partition the behavior into a set of major system modes. In supporting system modes in CBD, a key issue is seamless composition of multi-mode components into systems. In addressing this issue, we have developed a Mode Switch Logic (MSL) for component-based multi-mode systems, implementing seamless coordination and synchronization of mode switch in systems composed of independently developed components.", "num_citations": "4\n", "authors": ["1799"]}
{"title": "An Off-Line Scheduler and System Simulator for the Basement\u2122 Distributed Real-Time System\n", "abstract": " BASEMENT is a distributed real-time architecture developed within the Swedish Road Transport Informatics Programme. BASEMENT is intended for vehicle internal use in the automotive industry. BASEMENT is holistic in that it covers application development as well as the hardwares and softwares that provide execution and communication support. The key constituents of BASEMENT are:\u2022resource sharing (multiplexing) of processing and communication resources,\u2022a guaranteed real-time service for safety critical applications,\u2022a best-effort service for non-safety critical applications,\u2022a communication infrastructure providing efficient communication between distributed devices, and\u2022a software development method allowing resource independent and application oriented development of application software.This paper concentrates on software development. In particular, it presents two design tools: an off-line\u00a0\u2026", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Modeling real-time and reliability\n", "abstract": " We present extensions of a process algebra and a temporal logic to cater for real-time and reliability. We show how the extended formalisms can be combined into a framework where the operational behavior of a system is described in the algebra, its real-time and reliability properties are formulated in the logic, and an algorithm is used to decide if the properties hold for the system description. To illustrate the applicability of our techniques we specify and verify a simple fault tolerant system", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Guidelines for specification and verification of communication protocols\n", "abstract": " We present guidelines for the specification and verification of communication protocols and services. It is argued that specifications should be expressed formally, since formal methods enable the specifier to write unambiguous, clear, and concise specifications, and they provide a foundation for analyzing specifications for correctness so that errors can be detected early in the design process. Also, modifications, redesigns, maintenance, and reusability are facilitated when using formal methods. A simple specification method is proposed. The main characteristic of the method is immediate verification, ie verification is performed as early as possible after a design decision is made. Basic properties are verified in the course of the design process on as abstract specifications as possible. Using this method we obtain verifiable specifications. These specifications can be used as the starting point for specification in other\u00a0\u2026", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Architectural and behavioural modelling in computer communication\n", "abstract": " Architectural and Behavioural Modelling in Computer Communication - Blyth David Open Repository and Bibliography Home Other OA projects at the University Help? University of Li\u00e8ge | Library Network | Login | You are here: ORBi Detailled reference Reference : Architectural and Behavioural Modelling in Computer Communication Document type : Scientific congresses and symposiums : Paper published in a book Discipline(s) : Engineering, computing & technology : Computer science To cite this reference: http://hdl.handle.net/2268/33785 Title : Architectural and Behavioural Modelling in Computer Communication Language : English Author, co-author : Blyth, David [ > > ] Dubuis, Eric [ > > ] Hansson, Hans [ > > ] Juanole, Guy [ > > ] Kapus-Kolar, Monika [ > > ] Kerner, Helmut [ > > ] Leduc, Guy mailto [Universit\u00e9 de Li\u00e8ge - ULi\u00e8ge > D\u00e9p. d'\u00e9lectric., \u00e9lectron. et informat. (Inst.Montefiore) > R\u00e9seaux informatiques >] \u2026", "num_citations": "4\n", "authors": ["1799"]}
{"title": "Black-Box Testing for Security-Informed Safety of Automated Driving Systems\n", "abstract": " An evaluation of safety and security properties performed by an independent organisation can be an important step towards establishing trust in Automated Driving Systems (ADS), bridging the gap between the marketing portrayal and the actual performance of such systems in real operating conditions. However, due to the complexity of an ADS\u2019s behaviour and dangers involved in performing real environment security attacks, we believe assessments that can be performed with a combination of simulation and validation at test facilities is the way forward. In this paper, we outline an approach to derive test suites applicable to generic ADS feature classes, where classes would have similar capabilities and comparable assessment results. The goal is to support black box testing of such feature classes as part of an independent evaluation. By the means of cosimulation of post-attack behaviour and critical scenarios, we derive a representative set of physical certification tests, to gain an understanding of the interplay between safety and security. During the initial tests an ADS is subjected to various attacks and its reactions recorded. These reactions such as reduced functionality, fall back etc., together with relevant scenarios for the class is further analysed to check for safety implications.", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Work-in-Progress: A Hot-Patching Protocol for Repairing Time-Triggered Network Schedules\n", "abstract": " Time-Triggered communication is based on generating an offline static schedule that guarantees frame transmissions with reduced latency and low jitter. However, static schedules are not adaptive: if some unpredicted event happens, like a link failure, the schedule is not valid anymore and a new one needs to be synthesized from scratch. This paper presents a novel hot-patching protocol which seeks, after a link failure disconnecting two nodes, to find a new path to reconnect both nodes and restore during run-time the affected part of the schedule. We also introduce the concept of reparability as a desired property of the schedule, which increases the probability of our protocol to succeed. The first evaluation shows that our hot-patching protocol can recover from a link failure consistently in less than 25ms.", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Modeling and verification of master/slave clock synchronization using hybrid automata and model-checking\n", "abstract": " An accurate and reliable clock synchronization mechanism is a basic requirement for the correctness of many safety-critical systems. Establishing the correctness of such mechanisms is thus imperative. This paper addresses the modeling and formal verification of a specific fault-tolerant master/slave clock synchronization system for the Controller Area Network. It is shown that this system may be modeled with hybrid automata in a very natural way. However, the verification of the resulting hybrid automata is intractable, since the modeling requires variables that are dependent. This particularity forced us to develop some modeling techniques by which we translate the hybrid automata into single-rate timed automata verifiable with the model-checker Uppaal. These techniques are described and illustrated by means of a simple example.", "num_citations": "3\n", "authors": ["1799"]}
{"title": "A simulation based approach for estimating the reliability of distributed real-time systems\n", "abstract": " Designers of safety-critical real-time systems are often mandated by requirements on reliability as well as timing guarantees. For guaranteeing timing properties, the standard practice is to use various analysis techniques provided by hard real-time scheduling theory. The paper presents analysis based on simulation, that considers the effects of faults and timing parameter variations on schedulability analysis, and its impact on the reliability estimation of the system. We look at a wider set of scenarios than just the worst case considered in hard real-time schedulability analysis. The ideas have general applicability, but the method has been developed with modelling the effects of external interferences on the controller area network (CAN) in mind. We illustrate the method by showing that a CAN interconnected distributed system, subjected to external interference, may be proven to satisfy its timing requirements with a\u00a0\u2026", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Deriving reliability estimates of distributed real-time systems by simulation\n", "abstract": " Industrial deployment of academic real-time techniques still struggles to gain momentum due to the non-familiarity of industry with schedulability analysis, as well as the lack of appropriate commercial tools. Moreover, it is imperative that academia realises the extent of the pessimism for the proposed techniques, which often makes them less attractive to systems developers. The possible trade-offs in timing guarantees vs. reliability is one such key area which needs closer study and scrutiny. There is a need for less stringent guarantees in order to avoid costly overdesigns of systems. We present a framework and simulation based methodology for reliability analysis of distributed real-time systems. We have developed a tool which is quite versatile and can accommodate varied task models, network topologies and scheduling paradigms. The tool is illustrated by a comprehensive case-study. Since our method is based\u00a0\u2026", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Hard Real-Time in a Soft World\n", "abstract": " In cost conscious industries, such as automotive, it is imperative for designers to adhere to policies that reduce system resources to the extent feasible, even for safety-critical subsystems. However, the overall reliability requirement must be both analysable and met. Faults may be either, hardware, software or timing faults. The latter being handled by hard-real time schedulability analysis, which is used to prove that no timing violations will occur. However, from a reliability and cost perspective there is a trade-off between timing guarantees, the level of hardware and software faults, and the per-unit cost. By allowing occasional deadline misses, less costly hardware may be used, while still meeting the overall reliability requirement. Careful analysis is however needed. The main risk/problem is that this type of reasoning is highly dependent on assumptions concerning distributions and independence.This paper presents a reliability analysis method that considers the effects of faults and timing parameter distributions on schedulability analysis, and its impact on the reliability estimation of the system. In scheduling terms, we will consider a wider set of scenarios/cases than just the worst case considered in hard real-time schedulability analysis. The ideas have general applicability, but the method has been developed with modelling of external interference of automotive CAN buses in mind. We illustrate the method by showing that a CAN-bus interconnected distributed system, subjected to external interference, may be proven to satisfy its timing requirements with a sufficiently high probability, even in cases when the worst-case analysis has deemed it\u00a0\u2026", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Formal design of communication protocols\n", "abstract": " We report partial results from a project aiming at defining guidelines for the specification and verification of communica tion protocols and services. A simple specification mediod is proposed. Using this technique we obtain verifiable specifications. These specifications can be used as the starting point for specification in description techniques, such as: LOTOS, Estelle, or SDL. Guidelines for specification and verification of communication protocols and services are given. It is argued that specifications should be expressed formally and that they should be well structured in order to facilitate verification, Examples of specification and verification are included.", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Specification for verification\n", "abstract": " Specification for Verification | Proceedings of the IFIP TC/WG6.1 Second International Conference on Formal Description Techniques for Distributed Systems and Communication Protocols ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsFORTE '89Specification for Verification Article Specification for Verification Share on Authors: Hans Hansson View Profile , Bengt Jonsson View Profile , Fredrik Orava View Profile , Bj\u00f6rn Pehrson View Profile Authors Info & Affiliations Publication: FORTE '89: Proceedings of the IFIP TC/WG6.Second International Conference on Formal Description Techniques for Distributed Systems and \u2026", "num_citations": "3\n", "authors": ["1799"]}
{"title": "A framework for the taxonomy of synthesis and analysis activities in distributed system design\n", "abstract": " A Framework for the Taxonomy of Synthesis and Analysis Activities in Distributed System Design - Dubuis Eric Open Repository and Bibliography Home Other OA projects at the University Help? University of Li\u00e8ge | Library Network | Login | You are here: ORBi Detailled reference Reference : A Framework for the Taxonomy of Synthesis and Analysis Activities in Distributed Syst... Document type : Scientific congresses and symposiums : Paper published in a book Discipline(s) : Engineering, computing & technology : Computer science To cite this reference: http://hdl.handle.net/2268/33779 Title : A Framework for the Taxonomy of Synthesis and Analysis Activities in Distributed System Design Language : English Author, co-author : Dubuis, Eric [ > > ] Gotzhein [ > > ] Hansson, Hans [ > > ] Juanole, Guy [ > > ] Kerner, Helmut [ > > ] Lahtinen, P. [ > > ] Leduc, Guy mailto [Universit\u00e9 de Li\u00e8ge - ULi\u00e8ge > D\u00e9p. d'\u00e9lectric., \u00e9lectron\u2026", "num_citations": "3\n", "authors": ["1799"]}
{"title": "Fighting CPS Complexity by Component-Based Software Development of Multi-Mode Systems\n", "abstract": " Growing software complexity is an increasing challenge for the software development of modern cyber-physical systems. A classical strategy for taming this complexity is to partition system behaviors into different operational modes specified at design time. Such a multi-mode system can change behavior by switching between modes at run-time. A complementary approach for reducing software complexity is provided by component-based software engineering (CBSE), which reduces complexity by building systems from composable, reusable and independently developed software components. CBSE and the multi-mode approach are fundamentally conflicting in that component-based development conceptually is a bottom-up approach, whereas partitioning systems into operational modes is a top-down approach with its starting point from a system-wide perspective. In this article, we show that it is possible to combine and integrate these two fundamentally conflicting approaches. The key to simultaneously benefiting from the advantages of both approaches lies in the introduction of a hierarchical mode concept that provides a conceptual linkage between the bottom-up component-based approach and system level modes. As a result, systems including modes can be developed from reusable mode-aware components. The conceptual drawback of the approach\u2014the need for extensive message exchange between components to coordinate mode-switches\u2014is eliminated by an algorithm that collapses the component hierarchy and thereby eliminates the need for inter-component coordination. As this algorithm is used from the design to\u00a0\u2026", "num_citations": "2\n", "authors": ["1799"]}
{"title": "A systematic way to incorporate security in safety analysis\n", "abstract": " Today's systems are being built to connect to public or semi-public networks, are able to communicate with other systems, e.g., in the context of Internet-of-Things (IoT), involve multiple stakeholders, have dynamic system reconfigurations, and operate in increasingly unpredictable environments. In such complex systems, assuring safety and security in a continuous and joint effort is a major challenge, not the least due to the increasing number of attack surfaces arising from the increased connectivity. In this paper we present an approach that aims to bridge the gap between safety and security engineering. The potential of the approach is illustrated on the example of E-gas system, discussing the cases when unintentional faults as well as malicious attacks are taken into consideration when assuring safety of the described system.", "num_citations": "2\n", "authors": ["1799"]}
{"title": "System and method for automatic taking of fluid samples\n", "abstract": " The invention relates to automatic taking of fluid samples from a sample site (SS) of the living. A system comprises catheter means (CA, CB) having a junction (CJ) configured to be located in proximity to the sample site (SS). The junction is connected to first and second catheter means (CA, CB) and a sample-taking end (CTE). A valve (VA2) is connected to the first catheter means (CA) and has an inlet (VI) for an immiscible fluid to be aspirated into the first catheter means. Pumping means (PA, PB) are connectable to said catheter means and configured to aspirate and move said amount of said fluid (AB) to said junction. A first part (AB1) of said immiscible fluid (AB) is arranged in said second catheter means and a second part (AB2) in said first catheter means, whereby said first (AB1) and second (AB2) parts being configured to separate a taken sample (TS).", "num_citations": "2\n", "authors": ["1799"]}
{"title": "Presenting: An automated process for model synthesis\n", "abstract": " This report presents an automated process for constructing models of legacy real-time systems based on recordings.", "num_citations": "2\n", "authors": ["1799"]}
{"title": "Towards analyzing the fault-tolerant operation of Server-CAN\n", "abstract": " This work-in-progress (WIP) paper presents server-CAN and highlights its operation and possible vulnerabilities from a fault tolerance point of view. The paper extends earlier work on server-CAN by investigating the behaviour of server-CAN in faulty conditions. Different types of faults are described, and their impact on sever-CAN is discussed, which is the subject of on-going research", "num_citations": "2\n", "authors": ["1799"]}
{"title": "Server-Based Real-Time Communication on CAN\n", "abstract": " This paper presents a share-driven scheduling protocol for networks with real-time properties. The protocol provides fairness and bandwidth isolation among predictable as well as unpredictable streams of messages on the network. The need for this kind of scheduled real-time communication network is high in applications that have requirements on flexibility, both during development for assigning communication bandwidth to different applications, and during run-time to facilitate dynamic addition and removal of system components.The share-driven scheduling protocol is illustrated by applying it to the popular Controller Area Network (CAN). Two versions of the protocol are presented together with their associated timing analysis.", "num_citations": "2\n", "authors": ["1799"]}
{"title": "RTS Debugging\n", "abstract": " CiNii \u8ad6\u6587 - RTS Debugging CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092 \u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587 \u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003 \u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 [\u6a5f\u95a2\u8a8d\u8a3c] \u5229\u7528\u7d99\u7d9a\u624b\u7d9a\u304d\u306e\u3054\u6848\u5185 \u5b66\u8a8d\u8a8d\u8a3c\u306e\u4e0d\u5177\u5408 \u306b\u3064\u3044\u3066 RTS Debugging HANSSON H. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 HANSSON H. \u53ce\u9332\u520a\u884c\u7269 http://www.artes.uu.se/industry/031111/debugging-ZC-031111.pdf http://www.artes.uu.se/industry/031111/debugging-ZC-031111.pdf, 2003 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u6642\u9593/\u6a5f\u80fd\u5236\u7d04\u306b\u3088\u308b\u4ed5\u69d8\u306b\u5bfe\u3059\u308b\u5b9f\u884c\u53ef\u80fd\u306aUML/SysML\u30e2\u30c7\u30eb\u306e\u52d5\u7684\u691c\u67fb\u624b\u6cd5 \u5c0f\u91ce \u5eb7\u4e00 , \u4e2d\u6751 \u5b8f\u660e , \u77f3\u5ddd \u6d69 \u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2 27(2), 33-49, 2010-04-27 \u53c2\u8003\u6587\u732e22\u4ef6 Tweet \u5404\u7a2e \u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10026468301 \u8cc7\u6599\u7a2e\u5225 \u305d\u306e\u4ed6 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u2026", "num_citations": "2\n", "authors": ["1799"]}
{"title": "Time and probabilities in specification and verification of real-time systems\n", "abstract": " We present a framework for specification and verification of real-time and reliability in distributed systems. The framework consists of a language for describing the operational behaviour of systems, a logic for formulating system properties, and an algorithm for verifying that descriptions an the language satisfy formulas expressed in the logic. The language, TPCCS, as an extension of Miher\u2019s Calculus of Communicating Systems (CCS) with discrete tame and probabilities. The logic, TPCTL, is a branching time temporal logic, essentially extending Emerson, Clarke and Sistla\u2019s CTL with quantitative time and probabilities. The logic can be used to formulate reliability, real-time, and performance properties. A small example is used to illustrate how the operational behaviour of a system can be formulated in TPCCS, how its properties can be specified in TPCTL, and how we can verify that the TPCCS description satisfies\u00a0\u2026", "num_citations": "2\n", "authors": ["1799"]}
{"title": "Automatic implementation of formal descriptions of communication protocols\n", "abstract": " Automatic implementation of formal descriptions of communication protocols | Proceedings of the IFIP WG6.1 Fifth International Conference on Protocol Specification, Testing and Verification V ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsProceedings of the IFIP WG6.Fifth International Conference on Protocol Specification, Testing and Verification VAutomatic implementation of formal descriptions of communication protocols ARTICLE Automatic implementation of formal descriptions of communication protocols Share on Author: Hans A Hansson profile image Hans A. Hansson View Profile Authors Info & Affiliations \u2026", "num_citations": "2\n", "authors": ["1799"]}
{"title": "Using UPPAAL to verify recovery in a fault-tolerant mechanism providing persistent state at the edge\n", "abstract": " In our previous work we proposed a fault-tolerant persistent storage for container-based fog architecture. We leveraged the use of containerization to provide storage as a containerized application working along with other containers. As a fault-tolerance mechanism we introduced a replicated data structure and to solve consistency issue between the replicas distributed in the cluster of nodes, we used the RAFT consensus protocol. In this paper, we verify our proposed solution using the UPPAAL model checker. We explain how our solution is modeled in UPPAAL and present a formal verification of key properties related to persistent storage and data consistency between nodes.", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Toward an Ideal Access Control Strategy for Industry 4.0 Manufacturing Systems\n", "abstract": " Industrial control systems control and supervise our most important and critical infrastructures, such as power utilities, clean water plants and nuclear plants, as well as the manufacturing industries at the base of our economy. These systems are currently undergoing a transformation driven by the Industry 4.0 evolution, characterized by increased connectivity and flexibility. Consequently, the cybersecurity threat landscape for industrial control systems is evolving as well. Current strategies used for access control within industrial control systems are relatively rudimentary. It is evident that some of the emerging cybersecurity threats related to Industry 4.0 could be better mitigated using more fine-grained access control policies. In this article we discuss and describe a number of access control strategies that could be used within manufacturing systems. We evaluate the strategies in a simulation experiment, using a\u00a0\u2026", "num_citations": "1\n", "authors": ["1799"]}
{"title": "A Recipe-based Algorithm for Access Control in Modular Automation Systems\n", "abstract": " In the emerging trend towards modular automation, a need for adaptive, strict access control between interacting components has been identified as a key challenge. In this article we discuss the need for such a functionality, and propose a workflow-driven method for automatic access control policies generation within a modular automation system. The solution is based on recipes, formulated using Sequential Function Charts (SFC). The generated policies are expressed using Next Generation Access Control (NGAC), an Attribute Based Access Control (ABAC) standard developed by NIST. We provide (1) a definition of required policies for device-to device interactions within a modular automation system,(2) an algorithm for automatic generation of access policies,(3) a formal proof of the correctness of this algorithm, and (4) an illustration of its use.", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Timing analysis of CAN-based automotive communication systems\n", "abstract": " The controller area network (CAN) 1 is one of the major field bus technologies, used in many application domains requiring embedded communications. CAN is particularly important in the automotive domain since it provides predictable temporal (real-time) behavior on message frame transmissions. This chapter goes into detail, presenting CAN, its history, and its properties. The chapter also describes timing analysis of CAN frames.ABSTRACT", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Runtime Verification for Detecting Suspension Bugs in Multicore and Parallel Software\n", "abstract": " Multicore hardware development increases the popularity of parallel and multicore software, while testing and debugging the software become more difficult, frustrating and costly. Among all types of software bugs, concurrency bugs are both important and troublesome. This type of bugs is increasingly becoming an issue, particularly due to the growing prevalence of multicore hardware. Suspension-based-locking bug is one type of concurrency bugs. This position paper proposes a model based on runtime verification and reflection technique in the context of multicore and parallel software to monitor and detect suspension-based-locking bugs. The model is not only able to detect faults, but also diagnose and even repair them. The model is composed of four layers: Logging, Monitoring, Suspension Bug Diagnosis and Mitigation. The logging layer will observe the events and save them into a file system. The\u00a0\u2026", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Component-based software development of multi-mode systems\u2014An extended report\n", "abstract": " Growing software complexity is an increasing challenge for the software development of modern embedded systems. A classical strategy for taming the software complexity is to partition system behaviors into different operational modes specified at design time. Such a multi-mode system can change behavior by switching between modes at runtime. Component-Based Software Engineering (CBSE) is a complementary approach to the software development of complex systems that fosters reuse of independently developed software components. CBSE and the multi-mode approach are fundamentally conflicting in that component-based development conceptually is a bottom-up approach, whereas partitioning systems into operational modes is a topdown approach. In this report we show that it is possible to combine and integrate these two fundamentally conflicting approaches. The key to simultaneously benefitting from the advantages of both approaches lies in the introduction of a hierarchical mode concept that provides a conceptual linkage between the bottom-up component-based approach", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Handling emergency mode switch for componentbased systems\u2014an extended report,\u201d\n", "abstract": " Component-Based Software Engineering has been introduced as a technique for the development of complex systems. Software complexity can also be reduced by partitioning the system behavior into different modes. Such a multi-mode system is able to change its behavior at runtime by switching between different operational modes. When a multimode system is developed by reusable software components, a crucial issue is how to achieve a seamless composition of multi-mode components and also how to handle mode switch properly. This is the motivation for the Mode Switch Logic (MSL), supporting the development of component-based multi-mode systems by providing mechanisms for mode switch handling. In this report, MSL is extended and adapted to systems with emergency triggering of mode switches that must be handled with minimal delay. We propose an approach, called Immediate Handling with Buffering (IHB), to enable the responsive handling of such an emergency event in the presence of other concurrent non-emergency mode switch events. We present a model checking based verification of the IHB approach, and illustrate its benefits by a small example.", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Modeling and analysis of message-queues in multi-tasking systems\n", "abstract": " This paper presents work in progress on an analysis method for message queues in a real-time multi-tasking system. This analysis will later be compared with simulation results, in which variations/distributions of execution times, task periods etc will be considered. The intention is to evaluate the level of pessimism in the analytical worst-case analysis, compared to the execution scenarios that actually occur in the real system. We will use these results as a basis for future work in the ARTES project RATAD, which aims at developing schedulability analysis with a wider applicability, by integrating reliability into real-time scheduling theory. What we want is a method for integrating reliability into classical real-time scheduling, so that we can guarantee, up to some level, that our system is working properly. This is to be compared with the classical 0/1 results of the schedulability theory.", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Timing Analysis of CAN-Based Automotive Communication Systems\n", "abstract": " URN: urn: nbn: se: mdh: diva-7267 Scopus ID: 2-s2. 0-85052701473 ISBN: 978-0-8493-8026-6 (print) OAI: oai: DiVA. org: mdh-7267 DiVA, id: diva2: 237277", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Editorial Special Section on Factory Communication Systems\n", "abstract": " from sensors to decision making. This vertical integration includes asset optimization on all levels, and calls for standards that allows new production sites to be designed and built by equipment from various vendors, including providers of network technology, compatible controllers, devices, and machinery, and thus the vertical integration promotes industrial system growth without being dependent on vendor propriety technology.One interesting observation we can make as a community is that the automotive sector has developed considerably with respect to networking in the last 15 years and is sharing more and more technology and solutions with industrial automation. Owing to the size of the automotive sector, the cost pressure on the suppliers of shared technology has increased dramatically, and has thus made solutions cheaper also in the industrial domain. Common architectural elements can be identified between industrial automation and automotive systems. For example, a truck shows similarities with a larger production system, as it has a comparable hierarchy of networks, all the way from the low-level sensor networks to the interfaces to business systems. In both these domains, the networks are the integration platform of these highly integrated systems, and thereby have, besides being standardized, very high requirements on reliability and availability as they are the core of the integrated system. The trend is also that the requirements on reliability and availability are continuously increasing to achieve higher quality and productivity. Further, the networks must be able to handle different kinds of nonfunctional requirements such as\u00a0\u2026", "num_citations": "1\n", "authors": ["1799"]}
{"title": "A framework for realistic real-time walkthroughs in a VR distributed environment\n", "abstract": " Virtual and augmented reality (VR/AR) are increasingly being used in various business scenarios and are important driving forces in technology development. However the usage of these technologies in the home environment is restricted due to several factors including lack of low-cost (from the client point of view) highperformance solutions. In this paper we present a general client/server rendering architecture based on Real-Time concepts, including support for a wide range of client platforms and applications. The idea of focusing on the real-time behaviour of all components involved in distributed IP-based VR scenarios is new and has not been addressed before, except for simple sub-solutions. This is considered as \u201cthe most significant problem with the IP environment\u201d [1]. Thus, the most important contribution of this research will be the holistic approach, in which networking, end-systems and rendering aspects are integrated into a cost-effective infrastructure for building distributed real-time VR applications on IP-based networks.", "num_citations": "1\n", "authors": ["1799"]}
{"title": "CAN-based real-time lab environment\n", "abstract": " We present a CAN-based distributed real-time system lab environment. The hardware platform consists of MC68HC11 microcontroller boards, equipped with i82526 CAN-controllers. We use an o-the-shelf real-time kernel together with a commercial C development environment. In addition to these applications we have developed a set of tools to facilitate development and validation of distributed real-time systems. In the lab environment we have developed two sample applications for use in our undergraduate education and for evaluation of the lab environment.", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Hard Real-Time Communication in ATM Networks\n", "abstract": " We present and evaluate a method for admission control of hard real-time traffic in Asynchronous Transfer Mode (ATM) networks, ie, the method determines if a new connection with strict requirements on the timely delivery of messages can be admitted without violating the strict timing requirements specified for the new as well as old connections. This type of admission control is required by several multimedia and almost all real-time control applications. Our method, Response-Time Analysis (RTA), is based on traditional real-time CPU schedulability analysis. The only assumption RTA makes about the ATMnetwork is that the switches should be equipped with prioritized output queues, something which is true for many commercial switches. The main focus of this paper is on evaluating RTA. In the evaluation we compare RTA with Weighted Fair Queueing (WFQ) and the Calculus of Network Delays (CND). WFQ is the currently most popular method for providing performance guarantees, and CND provide...", "num_citations": "1\n", "authors": ["1799"]}
{"title": "Specification and validation of services and protocols for a public land mobile ISDN system\n", "abstract": " A public land mobile network (PLMN) proposed by CEPT is presented. A subset of the PLMN protocol architecture is described, and its formal validation (verification) is outlined. The PLMN validation illustrates that by considering validation already in the specification phase, it is possible to verify complex communication systems.< >", "num_citations": "1\n", "authors": ["1799"]}
{"title": "IEEE Industrial Electronics Society\n", "abstract": " IEEE INDUSTRIAL ELECTRONICS SOCIETY Page 1 Digital Object Identifier 10.1109/TII.2017.2676739 The Industrial Electronics Society is an organization, within the framework of the IEEE, of members with principal professional interest in electronics and electrical sciences as applied to control, treatment, and measurement of industrial processes. All members of the IEEE are eligible for membership in the Society and will receive this TRANSACTIONS upon payment of the annual Society membership fee of $9.00 plus an annual subscription fee of $15.00 (print and electronic). For information on joining, write to the IEEE at the address below. Member copies of Transactions/Journals are for personal use only. IEEE INDUSTRIAL ELECTRONICS SOCIETY IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS Editor-in-Chief REN C. LUO National Taiwan University Department of Electrical Engineering Taipei, \u2026", "num_citations": "1\n", "authors": ["1799"]}