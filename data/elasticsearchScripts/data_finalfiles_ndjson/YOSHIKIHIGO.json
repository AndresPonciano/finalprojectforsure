{"title": "Is duplicate code more frequently modified than non-duplicate code in software evolution?: an empirical study on open source software\n", "abstract": " Various kinds of research efforts have been performed on the basis that the presence of duplicate code has a negative impact on software evolution. A typical example is that, if we modify a code fragment that has been duplicated to other code fragments, it is necessary to consider whether the other code fragments have to be modified simultaneously or not. In this research, in order to investigate how much the presence of duplicate code is related to software evolution, we defined a new indicator, modification frequency. The indicator is a quantitative measure, and it allows us to objectively compare the maintainability of duplicate code and non-duplicate code. We conducted an experiment on 15 open source software systems, and the result showed that the presence of duplicate code does not have a negative impact on software evolution.", "num_citations": "119\n", "authors": ["204"]}
{"title": "Aries: Refactoring support environment based on code clone analysis\n", "abstract": " Code clone has been regarded as one of factors that make software maintenance more difficult. A code clone is a code fragment in a source code that is identical or similar to another. For example, if we modify a code fragment which has code clones, it is necessary to consider whether we have to modify each of its code clones. Hence, removal of code clones makes maintainability and comprehensibility of source code more improved. We have proposed a method that detects refactoring-oriented code clone. In this paper, in order to improve the usefulness and applicability of the method in the actual software maintenance, we have extended our refactoring support method. Concretely, we have developed a characterization of code clones by some metrics, which suggest how to remove them. Then, we have developed refactoring support tool Aries. We expect Aries can support software maintenance more effectively.", "num_citations": "96\n", "authors": ["204"]}
{"title": "Code Clone Detection on Specialized PDGs with Heuristics\n", "abstract": " PDG-based code clone detection is suitable for detecting on-contiguous code clones while other detection techniques, line-, token-, or AST-based techniques are not. However, PDG-based detection has lower performance for detecting contiguous code clones than the other techniques. Moreover, PDG-based detection is time consuming, so that application to actual software systems is not feasible. The present paper proposes PDG specializations and detection heuristics for enhancing PDG-based code clone detection. The experiment in this paper shows that the proposed methods are effective for PDG-based code clone detection by applying them to 4 open source systems.", "num_citations": "84\n", "authors": ["204"]}
{"title": "\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u3068\u305d\u306e\u95a2\u9023\u6280\u8853\n", "abstract": " \u8fd1\u5e74,\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u5bfe\u8c61\u3068\u3057\u305f\u7814\u7a76\u304c\u6d3b\u767a\u306b\u884c\u308f\u308c\u3066\u3044\u308b.\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3068\u306f,\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e2d\u306b\u5b58\u5728\u3059\u308b\u4e92\u3044\u306b\u4e00\u81f4\u307e\u305f\u306f\u985e\u4f3c\u3057\u305f\u30b3\u30fc\u30c9\u7247\u3092\u6307\u3059.\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u60c5\u5831\u3092\u9069\u5207\u306b\u5229\u7528\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fdd\u5b88\u3092\u52b9\u679c\u7684\u306b\u304b\u3064\u52b9\u7387\u7684\u306b\u884c\u3046\u3053\u3068\u304c\u53ef\u80fd\u3067\u3042\u308b.\u672c\u8ad6\u6587\u3067\u306f,\u73fe\u5728\u6ce8\u76ee\u3092\u96c6\u3081\u3066\u3044\u308b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u691c\u51fa\u3068\u305d\u306e\u95a2\u9023\u6280\u8853\u306b\u95a2\u3057\u3066,\u3053\u308c\u307e\u3067\u306e\u7814\u7a76\u6210\u679c\u3092\u7d39\u4ecb\u3059\u308b.", "num_citations": "78\n", "authors": ["204"]}
{"title": "Incremental Code Clone Detection: A PDG-based Approach\n", "abstract": " It has been noted in recent years that the presence of code clones makes software maintenance more difficult. Unintended code inconsistencies may occur due to the presence of code clones. In order to avoid problems caused by code clones, it is necessary to identify where code clones exist in a software system. Consequently, various kinds of code clone detection techniques have been proposed before now. In particular, incremental code clone detection attracts much attention in the last few years, and line-based and token-based incremental detection methods have been proposed. In incremental detections, code clone detection results or their intermediate products persist by using databases, and it is used in next code clone detection. However, no incremental detection technique has been proposed for PDG-based detection, which requires much more time to detect code clones than line-or token-based\u00a0\u2026", "num_citations": "77\n", "authors": ["204"]}
{"title": "Enhancing Quality of Code Clone Detection with Program Dependency Graph\n", "abstract": " At present, there are various kinds of code clone detection techniques. PDG-based detection is suitable to detect non-contiguous code clones meanwhile other detection techniques are not suited to detect them. However, there is a tendency that it cannot detect contiguous code clones unlike string-based or token-based technique. This paper proposes two techniques to enhance the PDG-based detection for practical usage. The software tool, Scorpio has been developed based on the techniques.", "num_citations": "40\n", "authors": ["204"]}
{"title": "How should we measure functional sameness from program source code? an exploratory study on java methods\n", "abstract": " Program source code is one of the main targets of software engineering research. A wide variety of research has been conducted on source code, and many studies have leveraged structural, vocabulary, and method signature similarities to measure the functional sameness of source code. In this research, we conducted an empirical study to ascertain how we should use three similarities to measure functional sameness. We used two large datasets and measured the three similarities between all the method pairs in the datasets, each of which included approximately 15 million Java method pairs. The relationships between the three similarities were analyzed to determine how we should use each to detect functionally similar code. The results of our study revealed the following.(1) Method names are not always useful for detecting functionally similar code. Only if there are a small number of methods having a given\u00a0\u2026", "num_citations": "27\n", "authors": ["204"]}
{"title": "A dataset of clone references with gaps\n", "abstract": " This paper introduces a new dataset of clone references, which is a set of correct clones consisting of their locational information with their gapped lines. Bellon's dataset is one of widely used clone datasets. Bellon's dataset contains many clone references, thus the dataset is useful for comparing accuracies among clone detectors. However, Bellon's dataset does not have locational information of gapped lines. Thus, Bellon's benchmark does not evaluate some Type-3 clones correctly. In order to resolve the problem, we added locational information of gapped lines to Bellon's dataset. The new dataset is available at``http://sdl. ist. osaka-u. ac. jp/~ h-murakm/2014_clone_references_with_gaps/''.", "num_citations": "25\n", "authors": ["204"]}
{"title": "How often do unintended inconsistencies happen? Deriving modification patterns and detecting overlooked code fragments\n", "abstract": " It is difficult to keep consistent source code. Unintended inconsistencies occur unless we recognize all the code fragments that need to modify in a given bug fix or functional addition. Before modifying source code, keyword-based search tools like grep or code clone detection tools can be used to prevent code fragments from being overlooked. However, once inconsistencies occur in the source code, such tools cannot help us adequately. In this paper, we propose a new method to identify unintended inconsistencies in source code automatically. The proposed method analyzes source code modifications in a repository to derive modification patterns. A modification pattern indicates what kind of code and how it was modified. The derived modification patterns are queries to identify unintended inconsistencies from the latest version of source files. We implemented the proposed method and applied it to FreeBSD and\u00a0\u2026", "num_citations": "24\n", "authors": ["204"]}
{"title": "A visualization method of program dependency graph for identifying extract method opportunity\n", "abstract": " Refactoring is important for efficient software maintenance. However, tools supports are highly required for refactoring because manual operations of refactoring are troublesome and error prone. This paper proposes a technique that suggests Extract Method candidates automatically. Extract Method refactoring is to create a new method from a code fragment in an existing method. Previous research efforts showed that the Extract Method refactoring is often performed prior to other refactorings, so that it is important to support Extract Method refactoring. Previous studies have proposed methods that suggest Extract Method candidates based on linage or complexity. However it is originally desirable to divide methods based on their functionalities. This paper uses the strength of data connection between sentences in the source code. We deem that strongly-connected data expresses a single function. This paper\u00a0\u2026", "num_citations": "22\n", "authors": ["204"]}
{"title": "Move code refactoring with dynamic analysis\n", "abstract": " In order to reduce coupling and increase cohesion, we refactor program source code. Previous research efforts for suggesting candidates of such refactorings are based on static analysis, which obtains relations among classes or methods from source code. However, these approaches cannot obtain runtime information such as repetition count of loop, dynamic dispatch and actual execution path. Therefore, previous approaches might miss some refactoring opportunities. To tackle this problem, we propose a technique to find refactoring candidates by analyzing method traces. We have implemented a prototype tool based on the proposed technique and evaluated the technique on two software systems. As a result, we confirmed that the proposed technique could detect some refactoring candidates, which increase code quality.", "num_citations": "19\n", "authors": ["204"]}
{"title": "Function point measurement from Web application source code based on screen transitions and database accesses\n", "abstract": " A function point (FP) is a unit of measurement that expresses the degree of functionality that an information system provides to a user. Many software organizations use FPs to estimate the effort required for software development. However, it is essential that the definition of 1 FP be based on the software development experience of the organization. In the present study, we propose a method by which to automatically extract data and transaction functions from Web applications under several conditions using static analysis. The proposed method is based on the International Function Point Users Group (IFPUG) method and has been developed as an FP measurement tool. We applied the proposed method to several Web applications and examined the difference between FP counts obtained by the tool and those obtained by a certified FP specialist (CFPS). The results reveal that the numbers of data and transaction\u00a0\u2026", "num_citations": "19\n", "authors": ["204"]}
{"title": "Code clone analysis methods for efficient software maintenance\n", "abstract": " Maintaining software systems becomes more difficult as the size and complexity of them increase. One factor that makes software maintenance more difficult is the presence of code clones. A code clone is a code fragment that has identical or similar code fragments to it in the source code. Code clones are introduced by various reasons such as reusing code by \u2018copy and paste\u2019. If we modify a code clone with many similar code fragments, it is necessary to consider whether or not we have to modify each of them. Especially, for large-scale software, such a process is very complicated and expensive. We tend to overlook some of code fragments which should be modified. In this study, we propose maintenance support methods for the presence of code clones. This study covers comprehensive maintenance situations that we are suffered from code clones. To sophisticate and enrich our methods as practical ones, we are promoting academic-industrial collaboration. We deliver our tools to industrial people, and they apply the tools to their software development and maintenance contexts, and they send feedback to us. We improve our methods and", "num_citations": "17\n", "authors": ["204"]}
{"title": "kgenprog: A high-performance, high-extensibility and high-portability apr system\n", "abstract": " In this paper, we introduce our tool, kGenProg, which is a new automated program repair system. kGenProg has several remarkable features. Thanks to the features, kGenProg got achieved high performance, high Extensibility, and high portability.", "num_citations": "16\n", "authors": ["204"]}
{"title": "Generating simpler ast edit scripts by considering copy-and-paste\n", "abstract": " In software development, there are many situations in which developers need to understand given source code changes in detail. Until now, a variety of techniques have been proposed to support understanding source code changes. Tree-based differencing techniques are expected to have better understandability than text-based ones, which are widely used nowadays (e.g., diff in Unix). In this paper, we propose to consider copy-and-paste as a kind of editing action forming tree-based edit script, which is an editing sequence that transforms a tree to another one. Software developers often perform copy- and-paste when they are writing source code. Introducing copy- and-paste action into edit script contributes to not only making simpler (more easily understandable) edit scripts but also making edit scripts closer to developers' actual editing sequences. We conducted experiments on an open dataset. As a result\u00a0\u2026", "num_citations": "15\n", "authors": ["204"]}
{"title": "Identifying clone removal opportunities based on co-evolution analysis\n", "abstract": " Previous research efforts have proposed various techniques for supporting code clone removal. They identify removal candidates based on the states of the source code in the latest version. However, those techniques suggest many code clones that are not suited for removal in addition to appropriate candidates. That is because the presence of code clones do not necessarily motivate developers to remove them if they are stable and do not require simultaneous modifications. In this paper, we propose a new technique that identifies removal candidates based on past records of code modifications. By using the proposed technique, we can identify code clones that actually required simultaneous modifications in the past.", "num_citations": "15\n", "authors": ["204"]}
{"title": "\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u5bfe\u8c61\u3068\u3057\u305f\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u652f\u63f4\u74b0\u5883\n", "abstract": " \u4f5c\u696d\u306e\u52b9\u7387\u3092\u60aa\u5316\u3055\u305b\u3066\u3044\u308b\u4e00\u8981\u56e0\u3068\u3057\u3066,\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u304c\u6319\u3052\u3089\u308c\u308b.\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3068\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e2d\u306b\u5b58\u5728\u3059\u308b\u540c\u4e00,\u307e\u305f\u306f\u985e\u4f3c\u3057\u305f\u30b3\u30fc\u30c9\u7247\u306e\u3053\u3068\u3067\u3042\u308b.\u4f8b\u3048\u3070,\u3042\u308b\u30b3\u30fc\u30c9\u7247\u306b\u30d0\u30b0\u304c\u542b\u307e\u308c\u3066\u3044\u305f\u5834\u5408,\u305d\u306e\u30b3\u30fc\u30c9\u7247\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3059\u3079\u3066\u306b\u3064\u3044\u3066\u4fee\u6b63\u306e\u662f\u975e\u3092\u8003\u616e\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\u3053\u306e\u3088\u3046\u306a\u7406\u7531\u306b\u3088\u308a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u304b\u3089\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u53d6\u308a\u9664\u304f\u3053\u3068\u306f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fdd\u5b88\u6027\u3084\u8907\u96d1\u5ea6\u306a\u3069\u306e\u9762\u304b\u3089\u307f\u3066\u6709\u52b9\u3067\u3042\u308b.\u3053\u308c\u307e\u3067\u306b,\u3044\u304f\u3064\u304b\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u96c6\u7d04\u624b\u6cd5\u304c\u63d0\u6848\u3055\u308c\u3066\u3044\u308b\u304c,\u89e3\u6790\u6642\u9593\u30b3\u30b9\u30c8\u304c\u9ad8\u3044\u306a\u3069\u306e\u7406\u7531\u306b\u3088\u308a,\u5927\u898f\u6a21\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306b\u5bfe\u3057\u3066\u306f\u9069\u7528\u304c\u96e3\u3057\u304b\u3063\u305f.\u672c\u8ad6\u6587\u3067\u306f,\u5927\u898f\u6a21\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306b\u5bfe\u3057\u3066\u3082\u9069\u7528\u53ef\u80fd\u306a\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u96c6\u7d04\u652f\u63f4\u624b\u6cd5\u306e\u63d0\u6848\u3092\u884c\u3046.\u5177\u4f53\u7684\u306b\u306f,\u5b9f\u7528\u7684\u306a\u6642\u9593\u3067\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e2d\u304b\u3089\u96c6\u7d04\u306b\u9069\u3057\u305f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u691c\u51fa\u3057,\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u3092\u7528\u3044\u3066\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u7279\u5fb4\u3092\u5b9a\u91cf\u5316\u3057,\u305d\u308c\u306b\u57fa\u3065\u304d\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u7d5e\u8fbc\u307f\u3092\u884c\u3046.\u672c\u624b\u6cd5\u3092\u7528\u3044\u308b\u3053\u3068\u306b\u3088\u3063\u3066,\u5404\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306b\u9069\u3057\u305f\u96c6\u7d04\u65b9\u6cd5\u3092\u63d0\u793a\u3059\u308b\u3053\u3068\u3067,\u30e6\u30fc\u30b6\u306f\u52b9\u7387\u7684\u306a\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u4f5c\u696d\u3092\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u308b.\u307e\u00a0\u2026", "num_citations": "15\n", "authors": ["204"]}
{"title": "Problematic code clones identification using multiple detection results\n", "abstract": " Most code clones are generated by copy-and paste programming. Copy-and-paste programming shortens a time required for implementation because pasted code is a template of the required functionality. However, it sometimes brings on new bugs to the source code. After copy-and-paste, pasted code is somewhat changed fitting for the context of the region surrounding the pasted code. For example, some identifiers are replaced with other identifiers or a few statements are inserted, deleted, or changed. If such modifications are incorrectly performed, bugs occur in code clones. However, not all code clones are problematic, many code clones have decent reasons for their existence. Consequently, simple code clone detection is inefficient for identifying problematic code clones. Firstly, this paper proposes a classification scheme for dividing problematic code clones from non problematic ones. Secondly, it\u00a0\u2026", "num_citations": "12\n", "authors": ["204"]}
{"title": "\u591a\u8a00\u8a9e\u5bfe\u5fdc\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u8a08\u6e2c\u30d7\u30e9\u30b0\u30a4\u30f3\u958b\u767a\u57fa\u76e4 MASU \u306e\u958b\u767a\n", "abstract": " \u7b46\u8005\u3089\u306f\u8907\u6570\u306e\u8a00\u8a9e\u306b\u5bfe\u3057\u3066\u9069\u7528\u53ef\u80fd\u306a\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u8a08\u6e2c\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u958b\u767a\u57fa\u76e4MASU\u3092\u958b\u767a\u3057\u3066\u3044\u308b.MASU\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u89e3\u6790\u3057,\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u8a08\u6e2c\u306b\u5fc5\u8981\u306a\u60c5\u5831\u3092\u30e6\u30fc\u30b6\u306b\u63d0\u4f9b\u3059\u308b.\u307e\u305f,\u8a08\u6e2c\u3059\u308b\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u306b\u5fdc\u3058\u305f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u89e3\u6790\u3084\u65b0\u898f\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u3078\u306e\u5bfe\u5fdc\u3092\u5bb9\u6613\u306b\u3059\u308b\u305f\u3081,MASU\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u304b\u3089\u62bd\u51fa\u3059\u308b\u60c5\u5831\u3092\u67d4\u8edf\u306b\u5909\u66f4\u30fb\u8ffd\u52a0\u3067\u304d\u308b\u3088\u3046\u306b\u8a2d\u8a08\u3055\u308c\u3066\u3044\u308b.\u30e6\u30fc\u30b6\u306fMASU\u304c\u63d0\u4f9b\u3059\u308b\u60c5\u5831\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u306b\u3088\u308a,\u5fc5\u8981\u6700\u4f4e\u9650\u306e\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u8a08\u6e2c\u30ed\u30b8\u30c3\u30af\u3092\u8a18\u8ff0\u3059\u308b\u3060\u3051\u3067\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u3092\u8a08\u6e2c\u3067\u304d\u308b.\u672c\u8ad6\u6587\u3067\u306fMASU\u306e\u8a73\u7d30\u306b\u3064\u3044\u3066\u8ff0\u3079\u308b.", "num_citations": "12\n", "authors": ["204"]}
{"title": "A capable crossover technique on automatic program repair\n", "abstract": " In software development, debugging is indispensable to guarantee the reliability. However, debugging is becoming more difficult because software is becoming larger and more complex. Thus, techniques for supporting debugging, especially automatic program repair techniques based on genetic programming distinguish themselves due to their capability. Genetic programming produces many modified programs by three operations: selection, mutation, and crossover. In this research, we focus on crossover that can bring a large modification at one operation, and we are conducting research on capable crossover by selecting several modified programs not randomly but using the guidance indicating their properties. In this paper, we propose a new crossover technique based on comparing modified programs' properties.", "num_citations": "11\n", "authors": ["204"]}
{"title": "\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u89e3\u6790\u306b\u57fa\u3065\u304f\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u306e\u8a66\u307f\n", "abstract": " \u8fd1\u5e74,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u5927\u898f\u6a21\u5316\u30fb\u8907\u96d1\u5316\u306b\u3068\u3082\u306a\u3044,\u4fdd\u5b88\u4f5c\u696d\u306b\u8981\u3059\u308b\u30b3\u30b9\u30c8\u306f\u5897\u5927\u3057\u3066\u3044\u308b.\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fdd\u5b88\u3092\u56f0\u96e3\u306b\u3057\u3066\u3044\u308b\u8981\u56e0\u306e1\u3064\u3068\u3057\u3066\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u304c\u3042\u3052\u3089\u308c\u308b.\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3068\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e2d\u306b\u5b58\u5728\u3059\u308b\u540c\u4e00,\u307e\u305f\u306f\u985e\u4f3c\u3057\u305f\u30b3\u30fc\u30c9\u7247\u306e\u3053\u3068\u3067\u3042\u308b.\u305f\u3068\u3048\u3070,\u3042\u308b\u30b3\u30fc\u30c9\u7247\u306b\u30d0\u30b0\u304c\u542b\u307e\u308c\u3066\u3044\u305f\u5834\u5408,\u305d\u306e\u30b3\u30fc\u30c9\u7247\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3059\u3079\u3066\u306b\u3064\u3044\u3066\u4fee\u6b63\u306e\u662f\u975e\u3092\u8003\u616e\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u652f\u63f4\u3059\u308b\u305f\u3081\u306b,\u6211\u3005\u306f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u5206\u6790\u74b0\u5883Gemini\u3092\u958b\u767a\u3057\u3066\u304d\u305f.Gemini\u3092\u3055\u307e\u3056\u307e\u306a\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u9069\u7528\u3059\u308b\u4e2d\u3067,\u3044\u304f\u3064\u304b\u306e\u554f\u984c\u70b9\u306b\u76f4\u9762\u3057\u305f.\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u306e\u76ee\u7684\u306e1\u3064\u3068\u3057\u3066\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u304c\u3042\u3052\u3089\u308c\u308b\u304c,Gemini\u306b\u3088\u3063\u3066\u30e6\u30fc\u30b6\u306b\u793a\u3055\u308c\u308b\u30af\u30ed\u30fc\u30f3\u306f\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u3092\u9069\u7528\u3067\u304d\u308b\u5358\u4f4d\u3068\u306a\u3063\u3066\u3044\u306a\u304b\u3063\u305f.\u672c\u8ad6\u6587\u3067\u306f\u3053\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3057,Gemini\u3092\u6a5f\u80fd\u62e1\u5f35\u3057\u305f.\u307e\u305f,\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306b\u5bfe\u3057\u3066\u9069\u7528\u5b9f\u9a13\u3092\u884c\u3044,\u672c\u624b\u6cd5\u306e\u6709\u7528\u6027\u3092\u78ba\u8a8d\u3059\u308b.", "num_citations": "10\n", "authors": ["204"]}
{"title": "Identifying auto-generated code by using machine learning techniques\n", "abstract": " Recently, many researchers have conducted mining source code repositories to retrieve useful information about software development. Source code repositories often include auto-generated code, and auto-generated code is usually removed in a preprocessing phase because the presence of auto-generated code is harmful to source code analysis. A usual way to remove auto-generated code is searching particular comments which exist among auto-generated code. However, we cannot identify auto-generated code automatically with such a way if comments have disappeared. In addition, it takes too much time to identify auto-generated code manually. Therefore, we propose a technique to identify auto-generated code automatically by using machine learning techniques. In our proposed technique, we can identify whether source code is auto-generated code or not by utilizing syntactic information of source\u00a0\u2026", "num_citations": "9\n", "authors": ["204"]}
{"title": "\u751f\u6210\u6291\u6b62, \u5206\u6790\u52b9\u7387\u5316, \u4e0d\u5177\u5408\u691c\u51fa\u3092\u4e2d\u5fc3\u3068\u3057\u305f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u7ba1\u7406\u652f\u63f4\u6280\u8853\u306b\u95a2\u3059\u308b\u7814\u7a76\u52d5\u5411\n", "abstract": " \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u5927\u898f\u6a21\u5316, \u8907\u96d1\u5316\u306b\u4f34\u3044, \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fdd\u5b88\u306f\u56f0\u96e3\u306a\u4f5c\u696d\u3068\u306a\u3063\u3066\u3044\u308b. \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fdd\u5b88\u3092\u56f0\u96e3\u306b\u3059\u308b\u8981\u56e0\u306e 1 \u3064\u3068\u3057\u3066\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u5b58\u5728\u304c\u6307\u6458\u3055\u308c\u3066\u304a\u308a, \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306b\u95a2\u3059\u308b\u7814\u7a76\u304c\u76db\u3093\u306b\u884c\u308f\u308c\u3066\u3044\u308b. \u3057\u304b\u3057, \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u4e3b\u306a\u751f\u6210\u8981\u56e0\u3067\u3042\u308b\u30b3\u30d4\u30fc\u30a2\u30f3\u30c9\u30da\u30fc\u30b9\u30c8\u306b\u3088\u308b\u65e2\u5b58\u30b3\u30fc\u30c9\u306e\u518d\u5229\u7528\u306b\u306f, \u65e2\u5b58\u306e\u6a5f\u80fd\u3068\u985e\u4f3c\u3059\u308b\u6a5f\u80fd\u3092\u9ad8\u901f\u306b\u5b9f\u73fe\u3067\u304d\u308b\u3068\u3044\u3046\u5229\u70b9\u304c\u3042\u308b. \u307e\u305f\u8fd1\u5e74\u306e\u8abf\u67fb\u306e\u7d50\u679c, \u3059\u3079\u3066\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u304c\u5fc5\u305a\u3057\u3082\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fdd\u5b88\u306b\u60aa\u5f71\u97ff\u3092\u4e0e\u3048\u3066\u3044\u308b\u3068\u306f\u9650\u3089\u306a\u3044\u3068\u3044\u3046\u5831\u544a\u304c\u306a\u3055\u308c\u3066\u3044\u308b. \u3053\u306e\u3088\u3046\u306a\u80cc\u666f\u304b\u3089, \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u7ba1\u7406\u3059\u308b\u6280\u8853\u304c\u6c42\u3081\u3089\u308c\u3066\u3044\u308b\u3068\u3044\u3048\u308b. \u672c\u7a3f\u3067\u306f\u3053\u308c\u307e\u3067\u306b\u5831\u544a\u3055\u308c\u3066\u3044\u308b\u7814\u7a76\u6210\u679c\u306e\u4e2d\u304b\u3089, \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u7ba1\u7406\u3092\u884c\u3046\u4e0a\u3067\u6709\u7528\u306a\u7814\u7a76\u6210\u679c\u3092\u7d39\u4ecb\u3059\u308b.", "num_citations": "9\n", "authors": ["204"]}
{"title": "Toward identifying inter-project clone sets for building useful libraries\n", "abstract": " The present paper discusses how clone sets can be generated from an very large amount of source code. The knowledge of clone sets can help to manage software asset. For example, we can figure out the state of the asset easier, or we can build more useful libraries based on the knowledge.", "num_citations": "9\n", "authors": ["204"]}
{"title": "Reordering program statements for improving readability\n", "abstract": " In order to understand source code, humans sometimes execute the program in their mind. When they illustrate the program execution in their mind, it is necessary to memorize what values all the variables are along with the execution. If there are many variables in the program, it is hard to their memorization. However, it is possible to ease to memorize them by shortening the distance between the definition of a variable and its reference if they are separated in the source code. This paper proposes a technique reordering statements in a module by considering how far the definition of a variable is from its references. We applied the proposed technique to a Java OSS and collected human evaluations for the reordered methods. As a result, we could confirm that the reordered methods had better readability than their originals. Moreover, we obtained some knowledge of human consideration about the order of\u00a0\u2026", "num_citations": "8\n", "authors": ["204"]}
{"title": "Beyond gumtree: A hybrid approach to generate edit scripts\n", "abstract": " On development using a version control system, understanding differences of source code is important. Edit scripts (in short, ES) represent differences between two versions of source code. One of the tools generating ESs is GumTree. GumTree takes two versions of source code as input and generates an ES consisting of insert, delete, update and move nodes of abstract syntax tree (in short, AST). However, the accuracy of move and update actions generated by GumTree is insufficient, which makes ESs more difficult to understand. A reason why the accuracy is insufficient is that GumTree generates ESs from only information of AST. Thus, in this research, we propose to generate easier-to-understand ESs by using not only structures of AST but also information of line differences. To evaluate our methodology, we applied it to some open source software, and we confirmed that ESs generated by our methodology are\u00a0\u2026", "num_citations": "7\n", "authors": ["204"]}
{"title": "A technique to detect multi-grained code clones\n", "abstract": " It is said that the presence of code clones makes software maintenance more difficult. For such a reason, it is important to understand how code clones are distributed in source code. A variety of code clone detection tools has been developed before now. Recently, some researchers have detected code clones from a large set of source code to find library candidates or overlooked bugs. In general, the smaller the granularity of the detection target is, the longer the detection time. On the other hand, the larger the granularity of the detection target is, the fewer detectable code clones are. In this paper, we propose a technique that detects in order from coarse code clones to fine-grained ones. In the coarse-tofine- grained-detections, code fragments detected as code clones at a certain granularity are excluded from detection targets of more fine-grained detections. Our proposed technique can detect code clones faster\u00a0\u2026", "num_citations": "7\n", "authors": ["204"]}
{"title": "Identifying refactoring opportunities for removing code clones with a metrics-based approach\n", "abstract": " Recently, code clones have attracted a great deal of attention in software engineering, and various studies of code clone-related research have been performed (Roy et al., 2009). A code clone is a code fragment that is either identical or similar to other code fragments in the source code. Code clones are generated for various reasons, including copy-and-paste programming or implementing stereotyped code (Baxter et al., 1998).The presence of code clones is generally considered to make it difficult to maintain the consistency of the code. For example, if we modify a code fragment with code clones in order to fix bugs or add new functionalities, it is necessary to determine whether the code clones should be modified simultaneously with the code fragment being modified. In addition, the presence of code clones has been reported to have a negative impact on software maintenance (Juergens et al., 2009). Monden et al. investigated the relations between code clones and the number of revisions of the source files on a very large legacy system written in COBOL (Monden et al., 2002). The results revealed that the following types of files tended to be revised more frequently than other types:(1) source files that are 80% or more duplicated, and (2) source files that includes large code clones (200 lines or more).", "num_citations": "7\n", "authors": ["204"]}
{"title": "A study on inappropriately partitioned commits: How much and what kinds of ip commits in java projects?\n", "abstract": " When we use code repositories, each commit should include code changes for only a single task and code changes for a single task should not be scattered over multiple commits. There are many studies on the former violation-often referred to as tangled commits-but the latter violation has been out of scope for MSR research. In this paper, we firstly investigate how much and what kinds of inappropriately partitioned commits in Java projects. Then, we propose a simple technique to detect such commits automatically. We also report evaluation results of the proposed technique.", "num_citations": "6\n", "authors": ["204"]}
{"title": "Toward introducing automated program repair techniques to industrial software development\n", "abstract": " Automated program repair (in short, APR) has been attracting much attention. A variety of APR techniques have been proposed, and they have been evaluated with actual bugs in open source software. Currently, the authors are trying to introduce APR techniques to industrial software development (in short, ISD) to reduce development cost drastically. However, at this moment, there are no studies that report evaluations of APR techniques on ISD. In this paper, we report our ongoing application of APR techniques to ISD and discuss some barriers that we found on the application.", "num_citations": "6\n", "authors": ["204"]}
{"title": "New strategies for selecting reuse candidates on automated program repair\n", "abstract": " Automated program repair (in short, APR) is a truly desired technique because it can reduce debugging costs drastically. A well-known technique in APR is a reuse-based approach, which inserts existing program statements in a given program to suspicious code for an exposed bug. Some reports show the reuse-based approach was able to fix many bugs in open source software. However, the existing approach often takes very long time to fix bugs. Its main factor is that so many variant programs are generated by insertions and so many test cases are executed for the variant programs before a fixed program is generated. In order to shorten fixing time with the reuse-based approach, a fixed program must be generated much more efficiently. In this paper, we propose two strategies to generate a fixed program more efficiently. We also implement the two strategies and confirm that there are real bugs which the two\u00a0\u2026", "num_citations": "6\n", "authors": ["204"]}
{"title": "Source code reuse evaluation by using real/potential copy and paste\n", "abstract": " Developers often reuse existing software by copy and paste. Source code reuse improves productivity and software quality. On the other hand, source code reuse requires several professional skills to developers. In source code reuse, developers must locate reusable code fragments, and judge whether such reusable code is adequate to copy and paste into the source file under development. This paper presents extraction and analysis methods for developers' source code reuse behavior (copy and paste). Our method extracts developers' actual source code reuse (real copy and paste). Then, by using a code clone detection tool, the method extracts code fragments for (potential reuse). Our study of real and potential copy and paste provides a quantitative assessment for source code reuse by developers.", "num_citations": "6\n", "authors": ["204"]}
{"title": "Clonepacker: A tool for clone set visualization\n", "abstract": " Programmers often copy and paste code fragments when they would like to reuse them. Although copy-and-paste operations enable programmers to realize rapid developments of software systems, it makes code clones. Some clones have negative impacts on software developments. For example, if we modify a code fragment, we have to check whether its clones need the same modification. In this case, programmers often use tools that take a code fragment as input and take its clones as output. However, when programmers use such existing tools, programmers have to open a number of source code and move up/down a scroll bar for browsing the detected clones. In order to reduce the cost of browsing the detected clones, we developed a tool that visualizes clones by using Circle Packing, named ClonePacker. As a result of an experiment with participants, we confirmed that participants using ClonePacker\u00a0\u2026", "num_citations": "6\n", "authors": ["204"]}
{"title": "MPAnalyzer: A tool for finding unintended inconsistencies in program source code\n", "abstract": " Unintended inconsistencies are caused by missing a modification task that requires code changes on multiple locations in program source code. In order to identify such inconsistencies efficiently, we proposed a new technique. It firstly learns how code fragments were changed in the past modification tasks, and then, it identifies where inconsistencies exist at the latest version. In this paper, we focus on an aspect of the tool that we developed and shows a case study that we conducted with the tool. A video of the tool is available at http://youtu. be/a7_PVVZ4-vo.", "num_citations": "6\n", "authors": ["204"]}
{"title": "Smith-waterman \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5229\u7528\u3057\u305f\u30ae\u30e3\u30c3\u30d7\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\n", "abstract": " \u8ad6\u6587\u6284\u9332\u3053\u308c\u307e\u3067\u306b\u3055\u307e\u3056\u307e\u306a\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u624b\u6cd5\u304c\u63d0\u6848\u3055\u308c\u3066\u3044\u308b. \u30ae\u30e3\u30c3\u30d7\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u691c\u51fa\u3059\u308b\u624b\u6cd5\u3068\u3057\u3066\u62bd\u8c61\u69cb\u6587\u6728\u3092\u7528\u3044\u305f\u624b\u6cd5, \u30d7\u30ed\u30b0\u30e9\u30e0\u4f9d\u5b58\u30b0\u30e9\u30d5\u3092\u7528\u3044\u305f\u624b\u6cd5, \u95a2\u6570\u30e1\u30c8\u30ea\u30af\u30b9\u3092\u7528\u3044\u305f\u624b\u6cd5, LCS \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u7528\u3044\u305f\u624b\u6cd5\u304c\u5b58\u5728\u3059\u308b. \u3057\u304b\u3057, \u3053\u308c\u3089\u306e\u65e2\u5b58\u624b\u6cd5\u306b\u306f\u691c\u51fa\u6642\u9593\u304c\u9577\u3044, \u3082\u3057\u304f\u306f\u691c\u51fa\u7cbe\u5ea6\u304c\u4f4e\u3044\u3068\u3044\u3063\u305f\u8ab2\u984c\u70b9\u304c\u3042\u308b. \u305d\u3053\u3067\u672c\u7814\u7a76\u306f Smith-Waterman \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5fdc\u7528\u3057\u3066, \u4e0a\u8ff0\u306e\u8ab2\u984c\u70b9\u3092\u6539\u5584\u3057\u305f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u624b\u6cd5\u3092\u63d0\u6848\u3059\u308b. \u63d0\u6848\u624b\u6cd5\u3092\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u30c4\u30fc\u30eb\u3068\u3057\u3066\u5b9f\u88c5\u3057, Bellon \u3089\u306e\u8a55\u4fa1\u5b9f\u9a13\u3092\u901a\u3058\u3066, \u63d0\u6848\u624b\u6cd5\u306f\u65e2\u5b58\u624b\u6cd5\u306e\u8ab2\u984c\u70b9\u3092\u6539\u5584\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u793a\u3057\u305f.", "num_citations": "6\n", "authors": ["204"]}
{"title": "\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u5024\u306e\u5909\u9077\u306b\u57fa\u3065\u3044\u305f\u6ce8\u529b\u3059\u3079\u304d\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7279\u5b9a\u3059\u308b\u624b\u6cd5\u306e\u63d0\u6848\n", "abstract": " \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u5927\u898f\u6a21\u5316\u53ca\u3073\u958b\u767a\u671f\u9593\u306e\u77ed\u7e2e\u5316\u306b\u3088\u308a,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u3059\u3079\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u540c\u69d8\u306b\u529b\u3092\u6ce8\u3050\u3053\u3068\u304c\u96e3\u3057\u304f\u306a\u3063\u3066\u304d\u3066\u3044\u308b.\u7279\u5b9a\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u529b\u3092\u6ce8\u3050\u5834\u5408\u306f,\u529b\u3092\u6ce8\u3050\u3079\u304d\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7279\u5b9a\u3057\u306a\u3051\u308c\u3070\u3089\u306a\u3044\u304c,\u624b\u52d5\u3067\u884c\u3046\u3068\u5bfe\u8c61\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u898f\u6a21\u306b\u5fdc\u3058\u3066\u81a8\u5927\u306a\u6642\u9593\u3068\u52b4\u529b\u3092\u8cbb\u3084\u3059\u3053\u3068\u306b\u306a\u308b.\u305d\u306e\u305f\u3081,\u958b\u767a\u8005\u306b\u8ca0\u62c5\u3092\u304b\u3051\u305a\u306b\u529b\u3092\u6ce8\u3050\u3079\u304d\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7279\u5b9a\u3059\u308b\u3053\u3068\u304c\u6c42\u3081\u3089\u308c\u308b.\u672c\u8ad6\u6587\u3067\u306f,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u5024\u306e\u5909\u9077\u3092\u7528\u3044\u3066\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u958b\u767a\u5c65\u6b74\u3092\u5b9a\u91cf\u5316\u3059\u308b\u3053\u3068\u306b\u3088\u308a,\u529b\u3092\u6ce8\u3050\u3079\u304d\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7279\u5b9a\u3059\u308b\u624b\u6cd5\u306e\u63d0\u6848\u3092\u884c\u3046.\u5b9f\u969b\u306b\u63d0\u6848\u624b\u6cd5\u3092\u8907\u6570\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306b\u5bfe\u3057\u3066\u9069\u7528\u3057\u305f\u7d50\u679c,\u5c06\u6765\u554f\u984c\u306e\u767a\u751f\u3057\u3084\u3059\u3044\u30e2\u30b8\u30e5\u30fc\u30eb\u3092,\u65e2\u5b58\u624b\u6cd5\u306b\u6bd4\u3079\u3066\u9ad8\u3044\u7cbe\u5ea6\u3067\u7279\u5b9a\u3059\u308b\u3053\u3068\u306b\u6210\u529f\u3057\u305f.", "num_citations": "6\n", "authors": ["204"]}
{"title": "Rearranging the order of program statements for code clone detection\n", "abstract": " A code clone is a code fragment identical or similar to another code fragment in source code. Some of code clones are considered as a factor of bug replications and make it more difficult to maintain software. Various code clone detection tools have been proposed so far. However, in most algorithms adopted by existing clone detection tools, if program statements are reordered, they are not detected as code clones. In this research, we examined how clone detection results change by rearranging the order of program statements. We performed preprocessing to rearranging the order of program statements using program dependency graph (PDG). We compared clone detection results with and without preprocessing. As a result, by rearranging the order of program statements, the number of detected code clones is almost the same in most projects. We classified newly detected or disappeared clones manually. From\u00a0\u2026", "num_citations": "5\n", "authors": ["204"]}
{"title": "Codeease: harnessing method clone structures for reuse\n", "abstract": " Searching for code examples on the Internet is commonly and frequently performed by software developers but wastes a lot of their time and reduces their productivity. To aid developers with this problem, a system is needed that can allow them to get appropriate code recommendations for reuse within the IDE. In this paper, we present our prototype tool CodeEase, developed as an Eclipse plugin, which generates method recommendations against the code of the developer. The recommendations are based on clone detection and an analysis of Method Clone Structures (MCS) - a type of structural clones- from a large repository of code.", "num_citations": "5\n", "authors": ["204"]}
{"title": "Toward refactoring evaluation with code naturalness\n", "abstract": " Refactoring evaluation is a challenging research topic because right and wrong of refactoring depend on various aspects of development context such as developers' skills, development cost, deadline and so on. Many techniques have been proposed to evaluate refactoring objectively. However, those techniques do not consider individual contexts of software development. Currently, the authors are trying to evaluate refactoring automatically and objectively with considering development contexts. In this paper, we propose to evaluate refactoring with code naturalness. Our technique is based on a hypothesis: if a given refactoring raises the naturalness of existing code, the refactoring is beneficial. In this paper, we also report our pilot study on open source software.", "num_citations": "4\n", "authors": ["204"]}
{"title": "Evaluating automated program repair using characteristics of defects\n", "abstract": " Debugging is a cost-consuming activity and reducing debugging cost is mandatory. Automated program repair (APR) is a debugging support technique which fixes a defect from a buggy program and a test suite. Recently, many APR techniques have been proposed. The performance of APR techniques are mainly evaluated by the number of fixed defects. Although the difficulties of fixing defects differ from defects, there are few evaluations using characteristics of defects. In this research, we extracted characteristics of defects from defect reports such as priority and is Reopened, and we evaluated the performance of three APR tools against 138 defects in open source Java projects. The investigation revealed that jGenProg and Nopol were able to fix defects with high priority at a high rate. In addition, we evaluated the performance of the APR tools from various viewpoints such as fixing time and fixing LOCs.", "num_citations": "4\n", "authors": ["204"]}
{"title": "Toward developer-like automated program repair\u2014Modification comparisons between genprog and developers\n", "abstract": " Automated program repair is a way to reduce costs on program debuggingto a large extent. Repair techniques using genetic programming havebeen attracting much attention. They were applied to actual softwaresystems and they were able to fix several dozen of actual faults. However, programs generated by such techniques often include some sourcecode changes not related to fixing a given fault even if they pass allgiven test cases. Furthermore, some researchers found that suchtechniques occasionally induce new faults which are not covered byexisting test cases. The reason why those problems arise is that suchtechniques consider only given test cases. On the other hand, developers consider program behaviors not covered by test cases. Thus, those problems arise less frequently in programs modified by developers. Consequently, the authors suppose that if we make automated programmodifications\u00a0\u2026", "num_citations": "4\n", "authors": ["204"]}
{"title": "How Often Is Necessary Code Missing?\u2014A Controlled Experiment\u2014\n", "abstract": " Code completion is one of the techniques used for realizing efficient code implementations. Code completion means adding the lacking code required for finishing a given task. Recently, some researchers have proposed code completion techniques that are intended to support code reuse. However, these existing techniques are designed to support the following programming steps. They cannot add necessary code in already-implemented code lines. In this research, we first investigate how often developers forget to write the necessary code in their programming tasks. We also investigate the extent to which opportunities of code reuse are increased by considering middle code completion. To investigate middle code completion, we propose a new technique that leverages type-3 clone detection techniques. We conducted a controlled experiment with nine research participants. As a result, we found that\u00a0\u2026", "num_citations": "4\n", "authors": ["204"]}
{"title": "Improving process of source code modification focusing on repeated code\n", "abstract": " There are various kinds of repeated code such as consecutive if-else statements or case entries in program source code. Such repeated code sometimes require simultaneous modifications on all of its elements. Applying the same modifications to many places on source code is a burdensome work and introduces new bugs if some places to be modified are overlooked. For these reasons, it is necessary to support modifications on repeated code. Appropriate supports for repeated code can improve process of source code modification. In this paper, as a first step for supporting modifications on repeated code, we investigate how repeated code are modified during software evolution. As a result, we revealed that, 73-89% of repeated code were modified at least once in their life and 31-58% of modifications on repeated code were simultaneous ones for all of their elements.", "num_citations": "4\n", "authors": ["204"]}
{"title": "How Compact Will My System Be? A Fully-Automated Way to Calculate LoC Reduced by Clone Refactoring\n", "abstract": " A code clone (in short, clone) is a code fragment that is identical or similar to other code fragments in source code. The presence of clone is known as bad smell, which is phenomena of source code to be refactored. A motivation of refactoring (merging) clones is to reduce the size of source code. An existing study proposed a technique to estimate reduced lines of code by merging clones; however, there are two issues in the existing technique: (1) the existing technique does not consider the refactorability of clones in spite that it is difficult or even impossible to merge some clones due to the limitation of programming languages; (2) in the case that multiple clones are overlapping, the existing technique only considers one of them can be merged. Due to the above issues, estimated reducible LoC is occasionally different from the actual number. Consequently, in this research, we propose a new technique to calculate a\u00a0\u2026", "num_citations": "3\n", "authors": ["204"]}
{"title": "Madoop: Improving Browser-Based Volunteer Computing Based on Modern Web Technologies\n", "abstract": " Browser-based volunteer computing (BBVC) is one of the distributed computing paradigms, attracting researchers' and developers' attention for its portability and extraordinary potential of computing power. However, BBVC still has two significant challenges: low programmability and performance. These challenges are a heavy burden for users and prevent BBVC from wide-spreading. In this paper, we propose a novel BBVC framework to solve the challenges by using MapReduce and WebAssembly. Our framework reduces the total execution time by 64% compared with a traditional BBVC mechanism. We also show a practical scenario and its performance.", "num_citations": "3\n", "authors": ["204"]}
{"title": "Towards automated generation of Java methods: A way of automated reuse-based programming\n", "abstract": " Automatic programming has been researched for a long time. A variety of methodologies have been proposed. However, they have limited applicability, or they can generate only a few lines of code. In this research, the authors are trying to generate source code of Java methods based on their specifications. In this paper, we propose a reuse-based code generation technique with method signature and test cases. First, our technique searches existing Java methods whose signature are the same as the one input by a user. Then, our technique reworks each of them by using test cases input by the user. Methods passing all the test cases are given to the user. At this moment, the authors have implemented a naive prototype and conducted experiments with four open source software. In total, our technique succeeded to generate 18 Java methods. In this paper, we also introduce some actual examples of generated\u00a0\u2026", "num_citations": "3\n", "authors": ["204"]}
{"title": "Revisiting capability of pdg-based clone detection\n", "abstract": " Code cloning is an active research topic in the field of software engineering over the last two decades. Recently, many research efforts have been focusing on detecting clones from very large scale source code and detecting clones incrementally from multiple versions of source code. However, PDG (Program Dependency Graph)-based detection techniques have not been researched very actively over the last several years. In this paper, we revisit capability of the PDG-based clone detection and discuss its potential and importance. Besides, we propose new techniques, which increase capability of the PDG-based clone detection. The proposed techniques have already been implemented as a software tool, SCORPIO, which is open to the public. We evaluated the proposed techniques on four open source software by using the tool. The application result showed that the proposed techniques were able to detect more clones to be detected than conventional techniques without raising the rate of false positives.", "num_citations": "3\n", "authors": ["204"]}
{"title": "\u30d7\u30ed\u30b0\u30e9\u30e0\u4f9d\u5b58\u30b0\u30e9\u30d5\u3092\u7528\u3044\u305f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306b\u5bfe\u3059\u308b\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u30e1\u30bd\u30c3\u30c9\u30d1\u30bf\u30fc\u30f3\u9069\u7528\u652f\u63f4\u624b\u6cd5\n", "abstract": " \u8fd1\u5e74,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fdd\u5b88\u6027\u3092\u4f4e\u4e0b\u3055\u305b\u308b\u8981\u56e0\u306e\u4e00\u3064\u3068\u3057\u3066\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u304c\u6ce8\u76ee\u3055\u308c\u3066\u304a\u308a,\u3053\u308c\u307e\u3067\u306b\u305d\u306e\u96c6\u7d04\u3092\u652f\u63f4\u3059\u308b\u624b\u6cd5\u304c\u591a\u6570\u63d0\u6848\u3055\u308c\u3066\u3044\u308b.\u4e2d\u3067\u3082Template Method\u30d1\u30bf\u30fc\u30f3\u9069\u7528\u306b\u3088\u308b\u96c6\u7d04\u652f\u63f4\u624b\u6cd5\u306f,\u5dee\u5206\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u96c6\u7d04\u53ef\u80fd\u3067\u3042\u308b\u3068\u3044\u3046\u7279\u9577\u304c\u3042\u308a,\u3053\u308c\u307e\u3067\u306b\u3053\u306e\u30d1\u30bf\u30fc\u30f3\u306e\u9069\u7528\u3092\u652f\u63f4\u3059\u308b\u624b\u6cd5\u304c\u63d0\u6848\u3055\u308c\u3066\u3044\u308b.\u3057\u304b\u3057\u65e2\u5b58\u624b\u6cd5\u306b\u306f,\u610f\u5473\u7684\u306b\u540c\u3058\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u308b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3067\u3042\u3063\u3066\u3082,\u6587\u306e\u9806\u5e8f\u304c\u7570\u306a\u308b,\u3042\u308b\u3044\u306f\u5b9f\u88c5\u306e\u65b9\u6cd5\u304c\u7570\u306a\u308b\u5834\u5408\u306b\u306f\u305d\u308c\u3089\u306b\u5bfe\u3059\u308b\u96c6\u7d04\u3092\u652f\u63f4\u3067\u304d\u306a\u3044\u3068\u3044\u3046\u8ab2\u984c\u70b9\u304c\u5b58\u5728\u3059\u308b.\u672c\u8ad6\u6587\u3067\u306f\u30d7\u30ed\u30b0\u30e9\u30e0\u4f9d\u5b58\u30b0\u30e9\u30d5\u3092\u7528\u3044\u308b\u3053\u3068\u3067\u65e2\u5b58\u7814\u7a76\u306e\u8ab2\u984c\u70b9\u3092\u89e3\u6c7a\u3057\u305f,Template Method\u30d1\u30bf\u30fc\u30f3\u9069\u7528\u306b\u3088\u308b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u96c6\u7d04\u652f\u63f4\u624b\u6cd5\u3092\u63d0\u6848\u3059\u308b.", "num_citations": "3\n", "authors": ["204"]}
{"title": "\u30b0\u30e9\u30d5\u30de\u30a4\u30cb\u30f3\u30b0\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u7528\u3044\u305f\u30ae\u30e3\u30c3\u30d7\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u60c5\u5831\u306e\u751f\u6210\n", "abstract": " \u3053\u308c\u307e\u3067\u306b\u69d8\u3005\u306a\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u624b\u6cd5\u304c\u63d0\u6848\u3055\u308c\u3066\u3044\u308b\u304c,\u30ae\u30e3\u30c3\u30d7(\u4e0d\u4e00\u81f4\u90e8\u5206)\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u691c\u51fa\u3067\u304d\u308b\u624b\u6cd5\u306f\u5c11\u306a\u3044.\u672c\u8ad6\u6587\u3067\u306f,\u30ae\u30e3\u30c3\u30d7\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u691c\u51fa\u3067\u304d\u306a\u3044\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u624b\u6cd5\u306e\u51fa\u529b\u7d50\u679c\u306b\u5bfe\u3057\u3066\u5f8c\u51e6\u7406\u3092\u884c\u3046\u3053\u3068\u3067,\u30ae\u30e3\u30c3\u30d7\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u60c5\u5831\u3092\u751f\u6210\u3059\u308b\u624b\u6cd5\u3092\u63d0\u6848\u3059\u308b.\u63d0\u6848\u624b\u6cd5\u306f,\u30b0\u30e9\u30d5\u30de\u30a4\u30cb\u30f3\u30b0\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u4e00\u3064\u3067\u3042\u308bAGM\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u7528\u3044\u3066\u304a\u308a,\u52b9\u7387\u7684\u306b\u30ae\u30e3\u30c3\u30d7\u3092\u542b\u3080\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u60c5\u5831\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\u63d0\u6848\u624b\u6cd5\u3092\u691c\u51fa\u30c4\u30fc\u30ebCCFinder\u306e\u30dd\u30b9\u30c8\u30d7\u30ed\u30bb\u30c3\u30b5\u3068\u3057\u3066\u5b9f\u88c5\u3057,\u8907\u6570\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306b\u5bfe\u3057\u3066\u9069\u7528\u3057\u305f\u3068\u3053\u308d,\u591a\u6570\u306e\u8208\u5473\u6df1\u3044\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u60c5\u5831\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u305f.\u3057\u304b\u3057,\u63d0\u793a\u3059\u308b\u5fc5\u8981\u304c\u306a\u3044\u3068\u601d\u308f\u308c\u308b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3082\u751f\u6210\u3057\u3066\u3057\u307e\u3046\u3053\u3068\u304c\u3042\u3063\u305f.\u672c\u8ad6\u6587\u3067\u306f,\u3053\u306e\u5b9f\u9a13\u306e\u7d50\u679c\u306b\u3064\u3044\u3066\u8ff0\u3079,\u307e\u305f,\u4e0a\u8a18\u306e\u554f\u984c\u306b\u5bfe\u3059\u308b\u89e3\u6c7a\u7b56\u306b\u3064\u3044\u3066\u3082\u8003\u5bdf\u3059\u308b.", "num_citations": "3\n", "authors": ["204"]}
{"title": "On an Automatic Function Point Measurement from Source Codes\n", "abstract": " This paper describes issues of introducing function point analysis to software organizations and then proposes a method to automatically extract data and transaction functions from Web application using static analysis.", "num_citations": "3\n", "authors": ["204"]}
{"title": "Proposal and evaluation of an approach to find bugs using difference information of code clone detection tools\n", "abstract": " (in English) Code clone has recently received a lot of attention. A code clone is a code fragment that has other similar or identical code fragments in the source code. Most code clones are generated bycopy and paste'programming. Potential bugs, which cannot be detected by compiler, are often introduced due to code clones. At present, many code clone detection tools have been developed. However, different code clones are identified from the same source code by the tools since they adopt different detection algorithms. This paper proposes a method for efficiently detecting code clones that are very likely to include bugs. A software tool has been implemented based on the proposed method, and it was applied to LINUX source code. As a result, some bugged code clones were detected within a short time frame.", "num_citations": "3\n", "authors": ["204"]}
{"title": "Effects of software industry structure on a research framework for empirical software engineering\n", "abstract": " The authors describe a new research framework for applying empirical software engineering methods in industrial practice and accomplishments in using it. The selected target for applying the framework is a governmentally funded software development project involving multiple vendors. This project involved inprocess project data measurement in real time, data sharing with industry and academia, data analysis, and feedback to the project members. Today the project is in the system integration process. This paper shows the value of this research framework and describes issues of empirical data sharing between industry and academia which have emerged while using it. This experiment raised two major issues. One is the necessity of a new research framework for project measurement called the \u201cMacro Measurement Tool\u201d. The other is effects of the software industry structure on this framework.", "num_citations": "3\n", "authors": ["204"]}
{"title": "Visualizing code genealogy: How code is evolutionarily fixed in program repair?\n", "abstract": " Automated program repair (in short, APR) techniques that utilize genetic algorithm (in short, GA) have a capability of repairing programs even if the programs require multiple code fragments to be changed. Those techniques repeat program generation, program evaluation, and program selection until a generated program passes all given test cases. Those techniques occasionally generate a large number of programs before a repaired program is generated. Thus, it is difficult to understand how an input program is evolved in the loop processing of genetic algorithm. In this paper, we are inspired by genealogy and propose a new technique to visualize program evolution in the process of automated program repair. We have implemented the proposed technique as a software tool for kGenProg, which is one of GA-based APR tools. We evaluated the proposed technique with the developers of kGenProg. In the\u00a0\u2026", "num_citations": "2\n", "authors": ["204"]}
{"title": "Correlation analysis between code clone metrics and project data on the same specification projects\n", "abstract": " The presence of code clones is pointed out as a factor that makes software maintenance more difficult. On the other hand, some research studies reported that only a small part of code clones requires simultaneous changes and their negative influences on software maintenance are limited. Besides, some other studies reported that code clones often have positive effects on software development. Currently, the authors are researching exploring the effect of clones on software development and maintenance. In this paper, the authors report their exploratory results on the relationship between clone metrics and project data such as the number of test cases and the number of found bugs. The targets of this exploration are nine web-based software systems. Interestingly, all of them were developed based on the same specification. In other words, they are functionally the same software systems. By targeting such\u00a0\u2026", "num_citations": "2\n", "authors": ["204"]}
{"title": "Reordering results of keyword-based code search for supporting simultaneous code changes\n", "abstract": " Many research studies have been conducted to help simultaneous code changes on multiple code fragments. Code clones and logical couplings are often utilized in such research studies. However, most of them have been evaluated on only open source projects or students' software. In this paper, we report our academic-industrial collaboration with a software company. The collaboration is intended to suggest multiple code fragments to be changed simultaneously when a developer specifies a keyword such as variable names on source code. In the collaboration, we propose to use code clones and logical couplings information to reorder the code fragments. We confirmed that code clones and logical couplings worked well on helping simultaneous code changes on three projects that have being developed in the company.", "num_citations": "2\n", "authors": ["204"]}
{"title": "On the level of code suggestion for reuse\n", "abstract": " Code search techniques are well-known as one of the techniques that helps code reuse. If developers input queries that represent functionality that they want, the techniques suggest code fragments that are related to the query. Generally, code search techniques suggest code at the component level of programming language such as class or file. Due to this, developers occasionally need to search necessary code in the suggested area. As a countermeasure, there is a code search technique where code is suggested based on the past reuse. The technique ignores structural code blocks, so that developers need to add some code to the pasted code or remove some code from it. That is, the advantages and disadvantages of the former technique are disadvantages and advantages of the latter one, respectively. In this research, we have conducted a comparative study to reveal which level of code suggestion is\u00a0\u2026", "num_citations": "2\n", "authors": ["204"]}
{"title": "\u30bf\u30b9\u30af\u30dc\u30fc\u30c9\u3068\u30aa\u30f3\u30e9\u30a4\u30f3\u30b9\u30c8\u30ec\u30fc\u30b8\u3092\u7528\u3044\u305f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u958b\u767a PBL \u306e\u305f\u3081\u306e\u30bf\u30b9\u30af\u8a18\u9332\u652f\u63f4\u74b0\u5883\u306e\u69cb\u7bc9\n", "abstract": " \u8ad6\u6587\u6284\u9332\u9ad8\u5ea6\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u6280\u8853\u8005\u3084\u9ad8\u5ea6 ICT (Information and Communication Technology) \u4eba\u6750\u306e\u80b2\u6210\u3092\u76ee\u7684\u3068\u3057\u3066, \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u958b\u767a\u3092\u30c6\u30fc\u30de\u3068\u3057\u305f PBL (Project Based Learning) \u3068\u547c\u3070\u308c\u308b\u6559\u80b2\u30fb\u5b66\u7fd2\u624b\u6cd5\u304c\u69d8\u3005\u306a\u5f62\u614b\u3067\u884c\u308f\u308c\u3066\u3044\u308b. PBL \u3067\u306f, \u632f\u308a\u8fd4\u308a\u3068\u547c\u3070\u308c\u308b\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u4e2d\u306b\u3042\u3063\u305f\u554f\u984c\u306e\u767a\u898b, \u539f\u56e0\u306e\u5206\u6790, \u5bfe\u7b56\u306e\u8003\u6848\u3068\u3044\u3063\u305f, \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u7d99\u7d9a\u7684\u306b\u6539\u5584\u3059\u308b\u3053\u3068\u3092\u76ee\u7684\u3068\u3057\u305f\u6d3b\u52d5\u304c\u91cd\u8981\u8996\u3055\u308c\u3066\u3044\u308b. \u3053\u3053\u3067, \u554f\u984c\u306e\u767a\u898b\u3084\u539f\u56e0\u306e\u5b9a\u91cf\u7684\u3067\u5ba2\u89b3\u7684\u306a\u5206\u6790\u3092\u884c\u3046\u305f\u3081\u306b\u306f, \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u4e2d\u306b\u8ab0\u304c\u3069\u306e\u3088\u3046\u306a\u30bf\u30b9\u30af\u3092\u3044\u3064\u5b9f\u65bd\u3057\u305f\u304b\u3068\u3044\u3063\u305f\u6b63\u78ba\u306a\u30bf\u30b9\u30af\u8a18\u9332\u304c\u5fc5\u8981\u4e0d\u53ef\u6b20\u3067\u3042\u308b. \u3057\u304b\u3057\u306a\u304c\u3089 PBL \u3067\u306f, \u30bf\u30b9\u30af\u8a18\u9332\u6642\u306b\u8a18\u8ff0\u6f0f\u308c\u3084\u5165\u529b\u8aa4\u308a\u304c\u767a\u751f\u3059\u308b\u3053\u3068\u304c\u3042\u308b. \u5b9f\u969b\u306b\u904e\u53bb\u306b\u884c\u308f\u308c\u305f\u7814\u7a76\u3067\u306f, \u8a18\u9332\u3055\u308c\u305f\u5168\u30bf\u30b9\u30af\u306e\u3046\u3061\u7d04 40% \u3082\u306e\u30c1\u30b1\u30c3\u30c8\u306b\u4f55\u3089\u304b\u306e\u8aa4\u308a\u304c\u5b58\u5728\u3057\u3066\u3044\u305f. \u3053\u306e\u554f\u984c\u306e\u539f\u56e0\u3068\u3057\u3066\u306f, \u30bf\u30b9\u30af\u8a18\u9332\u6642\u306e\u5165\u529b\u30b3\u30b9\u30c8\u3084, \u4f5c\u696d\u6642\u9593\u306e\u8a08\u6e2c\u30b3\u30b9\u30c8\u306e\u5927\u304d\u3055\u304c\u3042\u3052\u3089\u308c\u308b. \u305d\u3053\u3067\u672c\u7814\u7a76\u3067\u306f, \u30bf\u30b9\u30af\u8a18\u9332\u6642\u306e\u5165\u529b\u30b3\u30b9\u30c8\u306e\u524a\u6e1b\u3068\u4f5c\u696d\u6642\u9593\u306e\u81ea\u52d5\u8a08\u6e2c\u3092\u76ee\u7684\u3068\u3057\u3066, \u30bf\u30b9\u30af\u30dc\u30fc\u30c9\u3068\u30aa\u30f3\u30e9\u30a4\u30f3\u30b9\u30c8\u30ec\u30fc\u30b8\u3092\u7528\u3044\u305f\u30bf\u30b9\u30af\u8a18\u9332\u652f\u63f4\u30b7\u30b9\u30c6\u30e0 \u300cTixRec\u300d \u3092\u63d0\u6848\u3059\u308b. \u30bf\u30b9\u30af\u30dc\u30fc\u30c9\u306b\u3088\u3063\u3066\u3088\u308a\u76f4\u611f\u7684\u306a\u30bf\u30b9\u30af\u306e\u5909\u66f4\u3084\u8a18\u9332\u3092\u5b9f\u73fe\u3057, \u30aa\u30f3\u30e9\u30a4\u30f3\u30b9\u30c8\u30ec\u30fc\u30b8\u306b\u4fdd\u5b58\u3055\u308c\u305f\u7de8\u96c6\u5c65\u6b74\u3092\u7528\u3044\u308b\u3053\u3068\u3067, \u30c1\u30b1\u30c3\u30c8\u306b\u8a18\u9332\u3055\u308c\u305f\u30bf\u30b9\u30af\u306b\u5bfe\u5fdc\u3059\u308b\u30d5\u30a1\u30a4\u30eb\u60c5\u5831\u3092\u7528\u3044\u3066, \u4f5c\u696d\u6642\u9593\u306e\u81ea\u52d5\u8a08\u6e2c\u3092\u5b9f\u73fe\u3059\u308b. TixRec \u3092\u7528\u3044\u305f 4 \u4eba\u306e\u88ab\u9a13\u8005\u3092\u5bfe\u8c61\u3068\u3057\u305f\u8a55\u4fa1\u5b9f\u9a13\u306b\u3088\u308a, \u30bf\u30b9\u30af\u8a18\u9332\u306b\u8981\u3059\u308b\u6642\u9593\u304c 76%~ 93% \u524a\u6e1b\u3055\u308c, \u30e6\u30fc\u30b6\u30d3\u30ea\u30c6\u30a3\u8a55\u4fa1\u306b\u304a\u3044\u3066\u3082, \u65e2\u5b58\u306e\u30c1\u30b1\u30c3\u30c8\u30b7\u30b9\u30c6\u30e0\u3088\u308a\u512a\u4f4d\u3067\u3042\u308b\u3053\u3068\u304c\u78ba\u8a8d\u3055\u308c\u305f. \u4f5c\u696d\u6642\u9593\u306e\u8a08\u6e2c\u306b\u304a\u3044\u3066\u3082, \u8aa4\u5dee\u304c\u5e73\u5747 26 \u79d2, \u6700\u5927\u3067\u3082 146 \u79d2\u306b\u53ce\u307e\u3063\u3066\u3044\u305f.", "num_citations": "2\n", "authors": ["204"]}
{"title": "A study of student experience metrics for software development pbl\n", "abstract": " In recent years, the increased failure originated in the software defects, in various information systems causes a serious social problem. In order to build a high-quality software, cultivation of ICT (Information and Communication Technology) human resources like a software engineer is required. A software development PBL (Project-based Learning) is the educational technique which lets students acquire knowledge and skill spontaneously through practical software development. In PBL, on the other hand, it is difficult to evaluate not only the quality of the product but also the quality of the development process in the project. In this paper, we propose the student evaluation metrics to assess the development process in PBL. The student evaluation metrics represent LOC (Lines of Code) and development time for each product developed by a student. By using online storage, these metrics can be measured and\u00a0\u2026", "num_citations": "2\n", "authors": ["204"]}
{"title": "\u30a2\u30a4\u30c6\u30e0\u30bb\u30c3\u30c8\u30de\u30a4\u30cb\u30f3\u30b0\u3092\u5229\u7528\u3057\u305f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u5206\u6790\u4f5c\u696d\u306e\u52b9\u7387\u5411\u4e0a\n", "abstract": " \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fdd\u5b88\u3092\u56f0\u96e3\u306b\u3057\u3066\u3044\u308b\u8981\u56e0\u306e1\u3064\u306b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u304c\u3042\u308b. \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3068\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e2d\u306b\u5b58\u5728\u3059\u308b\u30b3\u30fc\u30c9\u7247\u3067, \u4ed6\u306e\u30b3\u30fc\u30c9\u7247\u3068\u540c\u4e00\u307e\u305f\u306f\u985e\u4f3c\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u6307\u3059. \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u5206\u6790\u652f\u63f4\u306e\u624b\u6cd5\u3068\u3057\u3066\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u53ef\u8996\u5316\u304c\u3042\u308b. \u6563\u5e03\u56f3\u306f\u53ef\u8996\u5316\u624b\u6cd5\u306e1\u3064\u3067, \u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u5206\u5e03\u72b6\u6cc1\u3092\u77ac\u6642\u306b\u628a\u63e1\u3067\u304d\u308b\u304c, \u500b\u3005\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u5206\u6790\u3059\u308b\u5834\u5408\u306f\u3069\u306e\u90e8\u5206\u304b\u3089\u5206\u6790\u3059\u3079\u304d\u304b\u5224\u65ad\u3057\u3065\u3089\u3044. \u3053\u308c\u306f, \u6563\u5e03\u56f3\u4e0a\u304b\u3089\u306f\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u7279\u5fb4\u3092\u53d6\u5f97\u3057\u3065\u3089\u3044\u305f\u3081\u3067\u3042\u308b. \u672c\u7814\u7a76\u3067\u306f, \u30a2\u30a4\u30c6\u30e0\u30bb\u30c3\u30c8\u30de\u30a4\u30cb\u30f3\u30b0\u624b\u6cd5\u3092\u7528\u3044\u3066\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u306e\u51fa\u73fe\u30d1\u30bf\u30fc\u30f3\u3092\u6c42\u3081, \u305d\u306e\u60c5\u5831\u3092\u6563\u5e03\u56f3\u4e0a\u306b\u4ed8\u52a0\u3059\u308b\u624b\u6cd5\u3092\u63d0\u6848\u3059\u308b. \u500b\u3005\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3067\u306f\u306a\u304f\u305d\u306e\u51fa\u73fe\u30d1\u30bf\u30fc\u30f3\u306b\u7740\u76ee\u3059\u308b\u3053\u3068\u3067, \u3088\u308a\u5de8\u8996\u7684\u306a\u8996\u70b9\u3067\u985e\u4f3c\u90e8\u5206\u3092\u77e5\u308b\u3053\u3068\u304c\u3067\u304d, \u52b9\u7387\u7684\u306a\u5206\u6790\u304c\u53ef\u80fd\u306b\u306a\u308b\u3068\u8003\u3048\u3089\u308c\u308b. \u305d\u3057\u3066, \u30c4\u30fc\u30eb\u3092\u5b9f\u88c5\u3057\u3066\u9069\u7528\u5b9f\u9a13\u3092\u884c\u3044, \u624b\u6cd5\u306e\u6709\u7528\u6027\u3092\u78ba\u8a8d\u3059\u308b.", "num_citations": "2\n", "authors": ["204"]}
{"title": "Refactoring support environment based on code clone analysis\n", "abstract": " Recently, code clone has been regarded as one of factors that make software maintenance more difficult. A code clone is a code fragment in a source code that is identical or similar to another. For example, if we modify a code fragment which has code clones, it is necessary to consider whether we have to modify each of its code clones. It is generally said that code clone is one of bad-smells to be refactored. There are two ways of maintenance support for code clones. One is to comprehend and manage code clones, and the other is to remove them. For the former support, we have developed code clone analysis environment Gemini. For the latter support, several methods have been proposed. But, it is difficult to apply them to large software because of various reasons such as high time complexity. In this paper, we propose a method that detects refactoring-oriented code clone in practical use time. And, we develop a characterization of code clones by some metrics, which suggests how to remove them. Then, we develop refactoring support environment Aries. We expect Aries can support software maintenance more effectively. keyword", "num_citations": "2\n", "authors": ["204"]}
{"title": "CLIONE: Clone Modification Support for Pull Request Based Development\n", "abstract": " A code clone (clone) is known as one of the factors that makes software maintenance difficult. Thus, in software maintenance, clone modification is essential. An existing study proposed a tool that notifies developers of information about clone changes so that the developers can modify clones efficiently. However, the existing tool is premised on regular execution and not designed to be triggered by external factors except for time. Hence, the existing tool is difficult to be executed triggered by development workflow, such as modifying source code or merging branches, and we think this causes some issues. Consequently, in this study, we propose a new clone modification support technique aimed to integrate into pull request (PR) based development for solving those issues. The proposed technique detects code fragments that need modifications by tracking clones at the time of creating PRs. Moreover, we made\u00a0\u2026", "num_citations": "1\n", "authors": ["204"]}
{"title": "GenProg Meets Cluster Computing\n", "abstract": " GenProg is an automated program repair tool that leverages genetic algorithm. In the repairing process of GenProg, a larger number of mutated programs are generated, built, and tested. If none of mutated programs passes all the test cases, GenProg redos the loop of generation, build and test. The build and test occupy over 90% of GenProg's execution. In this paper, we introduce our cluster-based GenProg, which builds and tests in parallel with many computers. We have implemented the cluster-based GenProg with Kubernetes environment and applied it to real bugs in Defects4J dataset. As a result, we confirmed that the time required for program repair is reduced according to the number of computers in the cluster.", "num_citations": "1\n", "authors": ["204"]}
{"title": "Achievements Visualization in Programming Education\n", "abstract": " Programming education focusing on the correctness of program behavior is often conducted with automated testing. However, it is difficult to instruct students about internal program quality since automated testing confirms only the external behavior of the program. Although there are a lot of quality measuring tools, results in these tools are so detailed or complicated that students cannot handle them. Besides, these tools do not give explicit criteria to judge the quality of the given program, thus students cannot figure out how high their program quality is. As a result, using these tools does not lead to improving the program quality. In this paper, we propose an educational method in which visualize the program quality by introducing a concept called achievement. We also introduce an implemented prototype system, Ave, to realize the proposed method.", "num_citations": "1\n", "authors": ["204"]}
{"title": "Impacts of daylight saving time on software development\n", "abstract": " Daylight saving time (DST) is observed in many countries and regions. DST is not considered on some software systems at the beginning of their developments, for example, software systems developed in regions where DST is not observed. However, such systems may have to consider DST at the requests of their users. Before now, there has been no study about the impacts of DST on software development. In this paper, we study the impacts of DST on software development by mining the repositories on GitHub. We analyze the date when the code related to DST is changed, and we analyze the regions where the developers applied the changes live. Furthermore, we classify the changes into some patterns.", "num_citations": "1\n", "authors": ["204"]}
{"title": "On the Naturalness of Auto-Generated Code\u2014Can We Identify Auto-Generated Code Automatically?\u2014\n", "abstract": " Recently, a variety of studies have been conducted on source code analysis. If auto-generated code is included in the target source code, it is usually removed in a preprocessing phase because the presence of auto-generated code may have negative effects on source code analysis. A straightforward way to remove auto-generated code is searching special comments that are included in the files of auto-generated code. However, it becomes impossible to identify auto-generated code with the way if such special comments have disappeared for some reasons. It is obvious that it takes too much effort to see source files one by one manually. In this paper, we propose a new technique to identify auto-generated code by using the naturalness of auto-generated code. We used a golden set that includes thousands of hand-made source files and source files generated by four kinds of compiler-compilers. Through the\u00a0\u2026", "num_citations": "1\n", "authors": ["204"]}
{"title": "Flattening Code for Metrics Measurement and Analysis\n", "abstract": " When we measure code metrics or analyze source code, code normalization is occasionally performed as a preprocessing. Code normalization means removing untargeted program elements, formatting source code, or transforming source code with specific rules. Code normalization makes measurement and analysis results more significant. Existing code normalization mainly targets program elements not influencing program behavior (e.g., code comments and blank lines) or program tokens (e.g., variable names and literals). In this paper, we propose a new code normalization technique targeting program structure. Our proposed technique transforms a complex program statement to simple ones. We call this transformation flattening. By flattening code, we can obtain source code including only simple program statements. As applications of the code flattening, we report how it changes LOC metric and clone\u00a0\u2026", "num_citations": "1\n", "authors": ["204"]}
{"title": "\u4e3b\u8981\u51e6\u7406\u306b\u7740\u76ee\u3057\u305f\u30e1\u30bd\u30c3\u30c9\u5358\u4f4d\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\n", "abstract": " \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u958b\u767a\u306b\u304a\u3044\u3066,\u591a\u304f\u306e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3067\u983b\u7e41\u306b\u5229\u7528\u3055\u308c\u308b\u6a5f\u80fd\u3092\u307e\u3068\u3081\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u5229\u7528\u306f,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fe1\u983c\u6027\u3084\u958b\u767a\u52b9\u7387\u306e\u5411\u4e0a\u306b\u6709\u7528\u3067\u3042\u308b.\u305d\u306e\u3088\u3046\u306a\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u542b\u3081\u308b\u3079\u304d\u6a5f\u80fd\u3092\u7279\u5b9a\u3059\u308b\u305f\u3081\u306b\u306f,\u5927\u898f\u6a21\u306a\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u7fa4\u306b\u5b58\u5728\u3059\u308b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u691c\u51fa\u3059\u308b\u3053\u3068\u304c\u6709\u76ca\u3067\u3042\u308b\u3068\u8003\u3048\u3089\u308c\u308b.\u305d\u306e\u305f\u3081,\u3053\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3092\u9ad8\u901f\u306b\u691c\u51fa\u3059\u308b\u3053\u3068\u3092\u76ee\u7684\u3068\u3057\u305f\u30e1\u30bd\u30c3\u30c9\u5358\u4f4d\u306e\u691c\u51fa\u624b\u6cd5\u304c\u63d0\u6848\u3055\u308c\u3066\u3044\u308b.\u3057\u304b\u3057\u65e2\u5b58\u624b\u6cd5\u3067\u306f,\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u4e3b\u8981\u51e6\u7406\u304c\u540c\u3058\u30e1\u30bd\u30c3\u30c9\u3067\u3042\u3063\u3066\u3082\u526f\u6b21\u51e6\u7406\u304c\u7570\u306a\u308b\u305f\u3081\u306b\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u3068\u3057\u3066\u691c\u51fa\u3055\u308c\u306a\u3044\u5834\u5408\u304c\u3042\u308b.\u305d\u3053\u3067,\u526f\u6b21\u51e6\u7406\u306b\u95a2\u3059\u308b\u30b3\u30fc\u30c9\u3092\u9664\u53bb\u3057\u305f\u4e0a\u3067\u30e1\u30bd\u30c3\u30c9\u5358\u4f4d\u306e\u30b3\u30fc\u30c9\u30af\u30ed\u30fc\u30f3\u691c\u51fa\u3092\u884c\u3046\u624b\u6cd5\u3092\u63d0\u6848\u3059\u308b.\u3053\u306e\u624b\u6cd5\u306b\u3088\u308a,\u30e1\u30bd\u30c3\u30c9\u306e\u4e3b\u8981\u51e6\u7406\u304c\u540c\u3058\u3067\u3042\u308c\u3070,\u305f\u3068\u3048\u305d\u306e\u4e2d\u306b\u5b58\u5728\u3057\u3066\u3044\u308b\u526f\u6b21\u51e6\u7406\u304c\u7570\u306a\u3063\u3066\u3044\u3066\u3082\u4e00\u3064\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u5316\u5019\u88dc\u3068\u3057\u3066\u691c\u51fa\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u306b\u306a\u308b.", "num_citations": "1\n", "authors": ["204"]}
{"title": "\u4fee\u6b63\u983b\u5ea6\u306e\u6bd4\u8f03\u306b\u57fa\u3065\u304f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fee\u6b63\u4f5c\u696d\u91cf\u306b\u5bfe\u3059\u308b\u91cd\u8907\u30b3\u30fc\u30c9\u306e\u5f71\u97ff\u306b\u95a2\u3059\u308b\u8abf\u67fb\n", "abstract": " \u8ad6\u6587\u6284\u9332\u8fd1\u5e74, \u91cd\u8907\u30b3\u30fc\u30c9\u3078\u306e\u95a2\u5fc3\u304c\u9ad8\u307e\u3063\u3066\u3044\u308b. \u4e00\u822c\u7684\u306b\u91cd\u8907\u30b3\u30fc\u30c9\u306f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fee\u6b63\u4f5c\u696d\u91cf\u3092\u5897\u5927\u3055\u305b\u308b\u304a\u305d\u308c\u304c\u3042\u308b\u3068\u8003\u3048\u3089\u308c\u3066\u304a\u308a, \u91cd\u8907\u30b3\u30fc\u30c9\u306e\u691c\u51fa\u3084\u96c6\u7d04\u306b\u95a2\u3059\u308b\u7814\u7a76\u304c\u3055\u304b\u3093\u306b\u884c\u308f\u308c\u3066\u3044\u308b. \u3057\u304b\u3057, \u91cd\u8907\u30b3\u30fc\u30c9\u3068\u4fee\u6b63\u4f5c\u696d\u91cf\u306e\u95a2\u4fc2\u3092\u5b9a\u91cf\u7684\u306b\u8abf\u67fb\u3057\u305f\u7814\u7a76\u306f\u3042\u307e\u308a\u884c\u308f\u308c\u3066\u3044\u306a\u3044. \u305d\u3053\u3067\u672c\u8ad6\u6587\u3067\u306f, \u91cd\u8907\u30b3\u30fc\u30c9\u304c\u975e\u91cd\u8907\u30b3\u30fc\u30c9\u3068\u6bd4\u8f03\u3057\u3066\u4fee\u6b63\u3055\u308c\u3084\u3059\u3051\u308c\u3070\u91cd\u8907\u30b3\u30fc\u30c9\u304c\u4fee\u6b63\u4f5c\u696d\u91cf\u3092\u5897\u5927\u3055\u305b\u3066\u3044\u308b\u3068\u3044\u3046\u8003\u3048\u306b\u57fa\u3065\u304d, \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306b\u52a0\u3048\u3089\u308c\u308b\u4fee\u6b63\u306e\u983b\u5ea6\u3092\u8a08\u6e2c, \u6bd4\u8f03\u3059\u308b\u3053\u3068\u3067, \u91cd\u8907\u30b3\u30fc\u30c9\u3068\u4fee\u6b63\u4f5c\u696d\u91cf\u306e\u95a2\u4fc2\u3092\u8abf\u67fb\u3057\u305f. 15 \u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306b\u5bfe\u3057\u3066\u5b9f\u9a13\u3092\u884c\u3063\u305f\u7d50\u679c, \u975e\u91cd\u8907\u30b3\u30fc\u30c9\u3068\u6bd4\u8f03\u3057\u3066\u91cd\u8907\u30b3\u30fc\u30c9\u306f\u4fee\u6b63\u3055\u308c\u306b\u304f\u304f, \u91cd\u8907\u30b3\u30fc\u30c9\u304c\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fee\u6b63\u4f5c\u696d\u91cf\u3092\u5897\u5927\u3055\u305b\u3066\u3044\u308b\u3068\u306f\u5fc5\u305a\u3057\u3082\u3044\u3048\u306a\u3044\u3068\u3044\u3046\u7d50\u679c\u3092\u5f97\u305f.", "num_citations": "1\n", "authors": ["204"]}
{"title": "Increasing Efficient Code Clone Analysis by Using Item Set Mining\n", "abstract": " (in English) One of the factors that makes software maintenance more difficult is code clone. A code clone is a code fragment that is similar or identical to other code fragments. Code clone visualization is one of the code clone analysis methods. Scatter plot is a widely used visualization, and we can figure out how code clones are distributed in the software system at once. However, it is hard to understand where to start analysis if we analyze individual code clone. This is because it is hard to get code clone features. Hence we propose a method using itemset mining to get code clone appearance patterns and adding the patterns into a scatter plot. We can identify larger or structurally similar sections of the software system, so that we can efficiently analyze code clones. We implement a tool and check usability of our method.", "num_citations": "1\n", "authors": ["204"]}
{"title": "Generating gapped code clone information using AGM algorithm\n", "abstract": " (in English) At present, there are many code clone detection methods and tools. However, only some of them can detect gapped code clones. A gapped code clone is a code clone including non-duplicated segments to its correspondant code clones. In this paper, we propose a method generating gapped code clone information from a detection result of existing code clone detection tools. The method adopts AGM (Apriori-baded Graph Mining) algorithm, and it can extract gapped code clone information efficiently. The method has already been implemented as a post-prosessor of {\\sf CCFinder}, which is a popular code clone detection tool. We applied the post-prosessor to four open source software systems, and got interesting gapped code clones.", "num_citations": "1\n", "authors": ["204"]}