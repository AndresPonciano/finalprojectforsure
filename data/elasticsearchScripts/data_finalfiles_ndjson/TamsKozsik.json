{"title": "The multi-agent modelling language and the model design interface\n", "abstract": " While computer models provide many advantages over traditional experimental methods, they also raise several problems. The process of software development is a complicated task with high potential for errors, especially when it is carried out by scientists holding their expertise in other fields than computer science. On the other hand, the process of creating computer simulations of social systems which reflect the reality of such systems requires insights considerably beyond expertise in computer science. The Multi-Agent Modelling Language (MAML) is one of the efforts to ease these difficulties.In its current version, MAML is a macro-language for Swarm (a freely distributed toolset under development at SFI), but it is also part of a larger Swarm-independent framework. Also, the design of MAML, while influenced by concepts from Swarm, is general enough to allow for later extension of the supported simulation kernels. This paper gives an overview of the mentioned larger framework, with special emphasis on MAML and its graphical CASE tool, the Model Design Interface.", "num_citations": "39\n", "authors": ["805"]}
{"title": "Extending the sparkle core language with object abstraction\n", "abstract": " Sparkle is a theorem prover specially constructed for the functional programming language Clean. In a pure functional language like Clean the variables represent constant values; variables do not change in time. Hence it seems that temporality has no meaning in functional programs. However, in certain cases (eg in interactive or distributed programs, or in ones that use I/O), a series of values computed from one another can be considered as different states of the same\" abstract object\". For this abstract object temporal properties can be proved. This paper presents a method to describe abstract objects and invariant properties in an extended version of the Sparkle Core language. The creation of such descriptions will be supported by a refactoring tool. The descriptions are completely machine processible, and provide a way to automatize the proof of temporal properties of Clean programs with the extended Sparkle system.", "num_citations": "23\n", "authors": ["805"]}
{"title": "Use cases for refactoring in erlang\n", "abstract": " Tool support for refactoring provides guarantees for the preservation of the program semantics during program transformation. This paper explains how RefactorErl, a refactoring tool for the Erlang language helps the programmer raise the quality of Erlang code or make the code suitable for further changes and improvements. Many examples illustrate the seven transformations currently implemented in RefactorErl. The paper also discusses the problems the refactor tool has to face.", "num_citations": "18\n", "authors": ["805"]}
{"title": "The use of aspect-oriented programming in scientific simulations\n", "abstract": " The Aspect-Oriented Programming paradigm is a newly introduced concept for program development. It can be seen as a technique that can co-exist with other methodologies, such as object-oriented, procedural, functional or event-driven programming. The purpose of AOP is to provide the programmer a toolset with which he or she can describe certain properties or parts of the software that cross-cut its functional structure. There are a few examples where AOP is applied in software development. Among others, aspects can be used to specify syncronization properties of distributed systems or handling optimization issues. In this paper another application domain is presented: our field of interest is the design and implementation of computer simulations. In some sciences, especially in the study of the so-called complex systems, computer programs play an important role as scientific equipments. In the case of computer simulations, the programs under use can be seen as experimental devices built in software. More precisely, they are both playing the role of the system under study and the experimental tools used to observe them. We argue that considering the two afore-mentioned roles as different aspects of the same system makes both the implementation and later the understanding of the model considerably easier. The aspect-oriented approach can make the development of computer simulations even more straightforward if it is supported by the modeling language used, as in the case with our Multi-Agent Modeling Language (or MAML for short), which is also briefly discussed by the paper.", "num_citations": "18\n", "authors": ["805"]}
{"title": "UML Model Execution via Code Generation.\n", "abstract": " Simulating design models makes early verification of the software\u2019s business logic possible. Model simulators can be implemented using an interpreter, but it provides limited runtime performance. This is only acceptable if the only use case of the tool is interactive model execution and debugging. If the model executor tool is to be used for automated regression testing, execution time becomes an important factor. In such cases generating code is a better option compared to interpretation. This paper documents our experience from an ongoing project which supports both the interactive and the automated model simulation use cases via code generation. It proposes an architecture and shows techniques we found useful in this setup, and reports on a freely available UML model simulator implemented along these lines.", "num_citations": "16\n", "authors": ["805"]}
{"title": "Refactoring in Erlang, a Dynamic Functional Language.\n", "abstract": " Refactoring in object-oriented languages has been well studied, but functional languages have received much less attention. This paper presents our ideas about refactoring in Erlang, a functional programming language developed by Ericsson for building telecommunications systems. The highlights of our work is dealing with the strong dynamic nature of Erlang and doing program manipulations using a relational database.", "num_citations": "16\n", "authors": ["805"]}
{"title": "Impact analysis of Erlang programs using behaviour dependency graphs\n", "abstract": " During the lifetime of a software product certain changes could be performed on its source code. After those changes a regression test should be performed, which is the most expensive part of the software development cycle. This paper focuses on programs written in a dynamic functional programming language Erlang, and discusses a mechanism that could select those test cases, which are affected by a change, i.e. altering the program on some point may have impact on the result/behaviour of those test cases. In the result of that analysis it is possible to reduce the number of necessary test cases, and after modifying the source code, just a subset of the test cases should be retested. The discussed approach introduces a behaviour dependency graph for Erlang programs to represent the dependencies in the source code. The impact of a change can be calculated by traversing the graph.", "num_citations": "15\n", "authors": ["805"]}
{"title": "Refactorings to enable parallelization\n", "abstract": " We propose program analyses to identify parallelizable code fragments, and program transformations to change those fragments into applications of high-level parallel patterns. The methodology has been worked out, and is presented here, in the context of the Erlang programming language, but the approach is applicable in other languages as well.", "num_citations": "14\n", "authors": ["805"]}
{"title": "Introducing records by refactoring\n", "abstract": " This paper focuses on introducing a new transformation to our existing model for refactoring Erlang programs. The goal of the transformation is to introduce a new abstraction level in data representation by substituting a group ofrelated data with a record. Using records enhances the legibility of the source code, makes further development easier, and makes programming less error-prone by providing better possibilities for both compilation time and runtime checks. There is a strong industrial demand for such a transformation in refactoring legacy code.", "num_citations": "14\n", "authors": ["805"]}
{"title": "The multi-agent modeling language\n", "abstract": " While computer models provide many advantages over traditional experimental methods, they also raise several problems. The process of software development is a complicated task with high potential for errors, especially when it is carried out by scientists holding their expertise in other fields than computer science. On the other hand, the process of creating computer simulations of social systems which reflect the reality of such systems requires insights considerably beyond expertise in computer science. The Multi-Agent Modeling Language (MAML) is one of the efforts to ease these difficulties.", "num_citations": "14\n", "authors": ["805"]}
{"title": "Verification of the Temporal Properties of Dynamic Clean Processes\n", "abstract": " The behavior of concurrent and parallel programs can be specified in a functional style. We introduced a relational model for synthesizing abstract parallel imperative programs this way earlier. In this paper we investigate the applicability of the specification and verification tools of the model for proving temporal properties of concrete programs written in a pure functional language, in Concurrent Clean. Destructive updates preserving referential transparency are possible in this language by using the so called unique types. For example Clean programs perform I/O by accessing their unique environment. Furthermore, dynamic types of Clean make it possible to load some pieces of the program during run-time. We present a methodology for proving safety and liveness properties of concurrent, interleaved Clean Object I/O processes that also use dynamic types and show simple examples for verification of correctness of such Clean programs.", "num_citations": "14\n", "authors": ["805"]}
{"title": "Building a refactoring tool for Erlang\n", "abstract": " This paper presents RefactorErl, a refactoring tool for the Erlang programming language. Based on experience obtained during a major redesign of this tool, we describe some general principles that proved to be important for developing refactoring tools\u2013not only for Erlang, but for other languages as well.", "num_citations": "13\n", "authors": ["805"]}
{"title": "Proving Invariants of Functional Programs.\n", "abstract": " In a pure functional language like Clean the values of the functional variables are constants; variables of functional programs do not change in time. Hence it seems that temporality has no meaning in functional programs. However, in certain cases (eg in interactive or distributed programs, or in ones that use IO) we would like to consider a series of values computed from each other as different states of the same \u201cabstract object\u201d. For this abstract object we can already prove temporal properties. In this paper we present the concept of object abstraction and show how to interpret and prove temporal properties of functional programs.", "num_citations": "13\n", "authors": ["805"]}
{"title": "A prototype of CPPCC-safe functional mobile code in Clean\n", "abstract": " A Prototype of CPPCC - Safe Functional Mobile Code in Clean Page 1 A Prototype of CPPCC - Safe Functional Mobile Code in Clean Daxkobler K., Horv\u00e1th Z., Kozsik T. E\u00f6tv\u00f6s Lor\u00e1nd University, Budapest, Hungary E-mails: mzperx@inf.elte.hu, hz@inf.elte.hu, kto@inf.elte.hu IFL 2002, Madrid Page 2 Daxkobler K., Horv\u00e1th Z., Kozsik T.: A Prototype of CPPCC 2 \u2022 Well-formed and well-typed code \u2022 Resource usage bounds (memory and execution time) \u2022 Termination \u2022 Has the specified functionality (safety and progress) \u2709Not malicious \u2709Non-malicious code may still contain bugs Checking applicability of mobile code Page 3 Daxkobler K., Horv\u00e1th Z., Kozsik T.: A Prototype of CPPCC 3 The Certified Proved-Property-Carrying Code (CPPCC): three main components CPPCC overview 1. Producer of the mobile code adds properties of the code and their proofs 2. Code receiver will execute the code only after all the \u2026", "num_citations": "12\n", "authors": ["805"]}
{"title": "Static rules for variable scoping in Erlang\n", "abstract": " Erlang/OTP is a functional programming environment designed for building concurrent and distributed fault-tolerant systems with soft real-time characteristics. The dynamic nature of this environment, which partly comes from concurrency and partly from dynamic language features, offers a great challange for a refactoring tool. Refactoring is a programming technique for improving the design of a program without changing its behaviour. Many refactorings are concerned with variables in some way. This paper presents variable scoping rules for Erlang that are more suitable for describing refactoring conditions and transformations than those given in the Erlang reference manual.", "num_citations": "11\n", "authors": ["805"]}
{"title": "Refactoring erlang programs\n", "abstract": " This paper presents the model, the design principles and the prototype of a refactoring toolset for Erlang programs. With this toolset one can incrementally carry out programmer-guided meaning-preserving program transformations. Erlang is a mostly dynamically typed language, and many of its semantical rules are also dynamic. Therefore the main challenge in this research is to ensure the safety of (the statically performed) refactoring steps. The paper analyses the language constructs of Erlang with respect to refactoring. A novelty of the presented approach is that programs are represented, stored and manipulated in a relational database. This feature makes it possible to express refactoring steps in a fairly compact and comprehensible way. The proposed software development environment with the integrated refactoring tool provides multiple editing modes. These editing modes support changes ranging from fully controlled (allowing only meaning-preserving transformations) to uncontrolled (editing program text freely). Transformations are performed more safely and efficiently in an editing mode with higher control.", "num_citations": "11\n", "authors": ["805"]}
{"title": "A method for job scheduling in Grid based on job execution status\n", "abstract": " The execution of data intensive Grid applications still raises several questions regarding job scheduling, data migration and replication. The optimisation techniques applied by these services significantly determine how fast a job can be executed and how quickly the user can get the execution results.", "num_citations": "11\n", "authors": ["805"]}
{"title": "Parallel Elementwise Processing\u2013A Novel Version\n", "abstract": " In this paper a parallel algorithm for computing the values of elementwise processatile functions will be presented. The main task is to prepare a dense total disjoint decomposition of the input. A relational model of sequential programs and its extension to parallel programs will be used to formalize this algorithm. By this way a programming theorem is produced. We investigate the computational and communication costs when implemented on a distributed system.", "num_citations": "11\n", "authors": ["805"]}
{"title": "Refactoring Erlang programs\n", "abstract": " Refactoring Erlang Programs Page 1 Overview of Erlang Refactoring Refactoring Erlang programs Conclusions Refactoring Erlang Programs1 Zolt\u00e1n Horv\u00e1th, L\u00e1szl\u00f3 L\u00f6vei, Zolt\u00e1n Cs\u00f6rnyei, Tam\u00e1s Kozsik, Anik\u00f3 V\u00edg, Tam\u00e1s Nagy, Roland Kir\u00e1ly, Melinda T\u00f3th, R\u00f3bert Kitlei Dept. Programming Languages and Compilers E\u00f6tv\u00f6s Lor\u00e1nd University, Budapest, Hungary Central-European Functional Programming School (CEFP 2007) 1 Supported by ELTE IKKK (GVOP-3.2.2.-2004-07-0005/3.0) and Ericsson Hungary. Horv\u00e1th, L\u00f6vei, Cs\u00f6rnyei, Kozsik, V\u00edg, Nagy, Kir\u00e1ly, T\u00f3th, Kitlei Refactoring Erlang Programs Page 2 Overview of Erlang Refactoring Refactoring Erlang programs Conclusions Contents 1 Overview of Erlang Data Evaluation Program structure Concurrency and distribution 2 Refactoring 3 Refactoring Erlang programs Transformations Case study Erlang refactorer Horv\u00e1th, L\u00f6vei, Cs\u00f6rnyei, Kozsik, V\u00edg, Nagy, \u2026", "num_citations": "11\n", "authors": ["805"]}
{"title": "Subtyping with strengthening type invariants\n", "abstract": " Our long-term research directive is the development of a programming environment, which provides support for writing safety-critical applications. The possibility to integrate the specification and verification of properties of programs with coding would decrease the existing gap between the design and implementation phases of software production, thus it would ease the development of correct software. We are aware of the fact that using a theorem prover to reason about program text is very resource consuming. Hence the application of an additional, less complex tool, which can take over some of the work of the theorem prover, would be extremely helpful. Many properties of programs can be encoded as type invariants. An appropriate type system can keep track of type invariants and it can handle their propagation throughout the code.The current paper focuses on this issue: we extend the type system of the functional programming language, Concurrent Clean, with type invariants and introduce a subtyping mechanism based on their presence and absence. A formal system is presented here, in which we can investigate the properties of this extended type system.", "num_citations": "10\n", "authors": ["805"]}
{"title": "Proving the temporal properties of the unique world\n", "abstract": " The behavior of concurrent and parallel programs can be specified in a functional style. We introduced a relational model for synthesizing abstract parallel imperative programs earlier. In this paper we investigate the applicability of the specification and verification tools of the model for proving temporal properties of concrete programs written in a pure functional language, in Concurrent Clean. Destructive updates preserving referential transparency are possible by using so called unique types. Clean programs perform I/O by accessing their unique environment. We present a methodology for proving safety and liveness properties of concurrent, interleaved Clean Object I/O processes and show examples for verification of simple Clean programs.", "num_citations": "10\n", "authors": ["805"]}
{"title": "Model Design Interface\u2013A CASE Tool for the Multi-Agent Modeling Language\n", "abstract": " In some sciences, especially in the study of the so-called complex systems, computer programs play an important role as scientific equipment. In the case of computer simulations the programs under use can be seen as experimental devices built in software. The Multi-Agent Modelling Language (MAML) is one of the efforts to ease the development of agent-based simulations for scientist holding their expertise in other fields than computer science. The Model Design Interface (MDI) takes another step along the pathway designed by MAML providing an intuitive, easy-to-use visual model building CASE tool based on MAML. This paper gives a short overview of the MDI against the background of the Multi-Agent Modeling Language and summarizes the general architecture behind it, which allows for the high versatility of further development.", "num_citations": "9\n", "authors": ["805"]}
{"title": "Layout preserving parser for refactoring in Erlang\n", "abstract": " This paper describes preprocessor and whitespace-aware tools for parsing and transforming Erlang source code. The presented tools are part of RefactorErl, a refactoring tool for Erlang programs. RefactorErl represents programs as a\u201d semantic graph\u201d that extends the AST with semantic nodes and edges for efficient information retrieval. The paper focuses on describing the construction of the AST and syntax based transformations of the semantic graph.", "num_citations": "8\n", "authors": ["805"]}
{"title": "Tutorial on subtype marks\n", "abstract": " When developing safety critical applications, the programmer might want to be able to prove his or her code correct. The integration of a proof system and a programming language of industrial strength can be fairly useful in this respect, like in the case of, for instance, the B method [1], the Java Modelling Language [5] or the functional programming languages Erlang [3,7,9,24] and Clean [11,23,25]. This paper presents the concept of subtype marks, a concept that establishes still closer links between a programming language and a proof system by letting the programmer encode certain important properties of programs within the type system of the language. Subtype marks are introduced here as part of a simple functional language. This language can be regarded as a small subset of Clean.", "num_citations": "8\n", "authors": ["805"]}
{"title": "The multi-agent simulation suite (MASS) and the functional agent-based language of simulation (FABLES)\n", "abstract": " In today\u2019s fast-paced, connected world the effects of a single business or policy decision may quickly cascade through a number of hidden links and affect remote parts of the market or the organization. To cope with such difficulties decision-makers need novel tools. This is the reason why modeling and simulation applications play an increasing role in business training and in decision-making support systems.The Multi-Agent Simulation Suite (MASS) is a solution candidate for modeling and simulation of complex social systems. It provides the means for rapid development and efficient execution of agent-based computational models. The aim of the Multi-Agent Simulation Suite project is to create a general yet efficient execution environment for versatile multi-agent based simulations. The suite consists of reusable core components that can be combined to form the base of both multi-agent and participatory multi-agent simulations. A secondary focus of the project is on providing a comfortable modeling environment for rapid simulation development. To this end, the suite will offer a high-level programming language dedicated to agent-based simulations, and a development environment with a number of interactive functions that help experimentation with and the finalization of the model.", "num_citations": "8\n", "authors": ["805"]}
{"title": "Free the Conqueror! Refactoring divide-and-conquer functions\n", "abstract": " Divide-and-conquer algorithms appear in the solution of many computationally intensive problems, and are good candidates for parallelization. A divide-and-conquer computation can be expressed in a programming language in many ways. This paper presents a set of small, semantics-preserving code transformations, and a methodology to refactor divide-and-conquer functions in a functional programming language. By applying a sequence of transformations using a refactoring tool, many divide-and-conquer functions can be restructured into a canonical form \u2013\u00a0which then can be refactored into an instance of a parallel divide-and-conquer pattern. This methodology offers an effective and safe way to parallelize HPC applications.", "num_citations": "7\n", "authors": ["805"]}
{"title": "C++ Standard Template Library by infinite iterators\n", "abstract": " The C++ Standard Template Library (STL) is an essential part of professional C++ programs. STL is a type-safe template library that is based on the generic programming paradigm and helps to avoid some possible dangerous C++ constructs. With its usage, the efficiency, safety and quality of the code is increased.However, professional C++ programmers are eager for some missing STL-related opportunities. For instance, infinite ranges are hardly supported by C++ STL. STL does not contain iterators that use a predicate during traversal. STL\u2019s design is not good at all from the view of predicates. In this paper we present some extensions of C++ STL that supports effective generic programming. We show scenarios where these extensions can be used pretty gracefully. We present the implementation of our infinite iterators.", "num_citations": "7\n", "authors": ["805"]}
{"title": "Verifying invariants of abstract functional objects-a case study\n", "abstract": " In a pure functional language like Clean the values of the functional variables are constants; variables of functional programs do not change in time. Hence it seems that temporality has no meaning in functional programs. However, in certain cases (eg in interactive or distributed programs, or in ones that use IO) we would like to consider a series of values computed from each other as different states of the same \u201cabstract object\u201d. For this abstract object we can already prove temporal properties (eg invariants). In this paper we present a case study: our example is an interactive database with some simple operations like updating, sorting, querying records. We specify an invariant property of our program and we show how to prove this property. We utilize Sparkle, a theorem prover designed for the Clean language. Since Sparkle is not capable of handling temporal logical properties, the application of certain rules of the proof system are performed by hand. This way we simulate the behaviour of a more sophisticated theorem prover, which is currently under development.", "num_citations": "7\n", "authors": ["805"]}
{"title": "Safe mobile code CPPCC: Certified Proved-Property-Carrying Code\n", "abstract": " We propose a hybrid model of safe mobile code exchange. The receiver needs a guarantee that the properties of the received code correspond to certain requirements. The safest solution is to verify run-time just before the execution of the code that the requirements are satisfied. The other extreme is to trust in the sender of the code unconditionally or, using a certificate mechanism, to check merely the identity of the code producer. The first approach is safe, but very resource-consuming, the latter, on the other hand, is fairly effective, but does not provide the required level of safety. We propose an architecture that possesses the advantages of both approaches.", "num_citations": "7\n", "authors": ["805"]}
{"title": "Automated syntax manipulation in RefactorErl\n", "abstract": " Refactorings often have to change the source code by adding, changing or replacing parts of the syntax tree. It is important to make these changes convenient and secure for the developer of refactorings. In this paper, we introduce a method that helps us create, replace and insert syntactically correct subtrees in an Erlang refactoring tool.", "num_citations": "6\n", "authors": ["805"]}
{"title": "Static Analysis for Divide-and-Conquer Pattern Discovery.\n", "abstract": " Routines implementing divide-and-conquer algorithms are good candidates for parallelization. Their identifying property is that such a routine divides its input into \u201csmaller\u201d chunks, calls itself recursively on these smaller chunks, and combines the outputs into one. We set up conditions which characterize a wide range of d&c routine definitions. These conditions can be verified by static program analysis. This way d&c routines can be found automatically in existing program texts, and their parallelization based on semi-automatic refactoring can be facilitated. We work out the details in the context of the Erlang programming language.", "num_citations": "5\n", "authors": ["805"]}
{"title": "Multicore  Standard Template Library with \n", "abstract": " Nowadays, one of the most important challenges in the programming is the efficient usage of multicore processors. Many new programming languages and libraries support multicore programming. C++0x, the proposal of the next standard of C++ also supports multithreading at low level.In this paper we argue for some extensions of C++ Standard Template Library based on the features of C++0x. These extensions enhance the standard library to be more powerful in the multicore realm. In this paper we deal with the functors and lambda expressions that are a major extension in the language. We present a technique to write effective pipelines. Speculative functors aim at the effective evaluation of composite functors. Algorithms are overloaded on the associativity of lambda expressions as well.", "num_citations": "5\n", "authors": ["805"]}
{"title": "Temporal properties of clean programs proven in sparkle-t\n", "abstract": " In a pure functional language a series of values computed from one another can be considered as different states of the same \u201cabstract object\u201d. For this abstract object temporal properties (e.g. invariants) can be formulated and proved. This paper explains how to define and prove certain kinds of temporal properties of programs written in the pure functional language Clean. Sparkle, a theorem prover designed for Clean, is applied as a tool. Since Sparkle is not capable of handling temporal logical properties, its original version has been extended to support object abstraction, certain temporal properties and a new form of theorems which includes hypotheses. The resulting system is called Sparkle-T. The examples presented in this paper illustrate how object abstraction and the definition and proof of temporal properties can be carried out in Sparkle-T. Furthermore, some novel features of the Sparkle-T system\u00a0\u2026", "num_citations": "5\n", "authors": ["805"]}
{"title": "Telemodelling-Overview of a System\n", "abstract": " As part of its objectives Systems Laboratory at Central European University, Budapest is developing a webbased, easy-to-use modeling and simulation environment to enforce the use of agent-based computer modeling in social sciences and in other scientific disciplines. The envisioned use of this toolset is that researchers all over Central Europe and the former Soviet Union would be able to reach its facilities together with the computing power located at the Systems Laboratory, CEU. The system consists of three main parts, such as the Simulation Preparing Unit (SPU), the Simulation Control Unit (SCU) and the Result Analyzing Unit (RAU). The SPU includes the Model Design Interface (MDI), that is a model building tool with an easy-to-use graphical user interface and a Parametrization Unit (PU) for exhaustive and explorative parameter space search. The SPU operates on the user's computer. The model and the\u00a0\u2026", "num_citations": "5\n", "authors": ["805"]}
{"title": "Analysis of preprocessor constructs in erlang\n", "abstract": " Program analysis and transformation tools work on source code, which-as in the case of Erlang-may contain macros and other preprocessor directives. Such preprocessor constructs have to be treated in an utterly different way than lexical and syntactical constructs. This paper presents an approach to treat preprocessor constructs in a non-invasive way that is reasonably efficient and supports code transformations and analyses in an Erlang specific framework.", "num_citations": "4\n", "authors": ["805"]}
{"title": "Commanding a robot in a safe way\n", "abstract": " Certified Proved-Property-Carrying Code is a technique for efficiently ensuring correctness of mobile code. It relies on a trusted certifying authority that statically verifies correctness proofs and certifies correctness of program components passed as mobile code from a code producer to a code receiver. This paper uses an implementation of CPPCC to enable the safe dynamic reconfiguration or reprogramming of a robot. In this implementation the B-method is used to construct programs together with machine-verifiable proofs of correctness.", "num_citations": "4\n", "authors": ["805"]}
{"title": "Comparing Specification with Proved Properties of Clean Dynamics\n", "abstract": " Clean dynamics can be used for implementing mobile code in a functional programming language. Dynamics are type safe, but other semantical properties are not checked before application of the dynamically linked code in the consumer. A language for expressing semantical requirements and an algorithm for comparing requirements with proven properties of the dynamics are presented in the current paper. Sparkle, the dedicated theorem prover of Clean is extended for dealing with open specifications. The properties of the consumer application can be proved based on the requirements are satisfied by the dynamics. New kinds of propositions and tactics are introduced in the paper for dealing with such proofs. The applicability of the new concepts and tools are demonstrated by a running example. The model of comparing properties with requirements is designed in language independent way, so the results may be applicaple for Erlang and other functional languages supporting dynamic code loading.", "num_citations": "4\n", "authors": ["805"]}
{"title": "Proving the correctness of mobile Java code\n", "abstract": " Mobile code technologies make it possible to download a piece of code from one computer and execute it on another. This paper presents a framework in which the correctness of the downloaded code can be verified before execution. The approach is based on the Certified Proved-Property-Carrying Code model [12]. In this model mobile code carries its proven properties, but no proofs. The proofs created by the code producer are checked and replaced with a certificate by a trusted certifying authority. Our implementation targets mobile Java Virtual Machine code, and supports the B-method, JML and Spark for proving correctness.", "num_citations": "4\n", "authors": ["805"]}
{"title": "Parallel programs implementing abstract data type operations\n", "abstract": " All material on this site has been provided by the respective publishers and authors. You can help correct errors and omissions. When requesting a correction, please mention this item's handle: RePEc: cmt: pumath: puma2000v011pp0293-0308. See general information about how to correct material in RePEc.For technical questions regarding this item, or to correct its authors, title, abstract, bibliographic or download information, contact:(Gyula Magyark\u00fati) The email address of this maintainer does not seem to be valid anymore. Please ask Gyula Magyark\u00fati to update the entry or send us the correct email address. General contact details of provider: http://edirc. repec. org/data/bkeeehu. html.", "num_citations": "4\n", "authors": ["805"]}
{"title": "TYPE INFERENCE FOR CORE ERLANG TO SUPPORT TEST DATA GENERATION.\n", "abstract": " Success typing is a well known technique to calculate the type of Erlang functions. Although success typing is commonly used for documentation and discrepancy analysis purposes, it results in an overapproximation of the real type. Therefore, when we want to generate arguments for a function call based on the success typing of a function, the function call may fail during execution. In this paper we introduce a new algorithm to calculate the type of Erlang functions to support accurate data generation.", "num_citations": "3\n", "authors": ["805"]}
{"title": "A C++ pearl\u2013self-referring streams\n", "abstract": " Since C++ is a multiparadigm language, experimenting with functional programming techniques in this language seems fruitful. Selfreferencing data is widely used in lazy functional languages. In the most interesting cases of self-referencing we produce infinite data. In this case it is possible to express infinite data with a finite structure. This paper makes the concept of stream-oriented programming available for the C++ programmer.", "num_citations": "3\n", "authors": ["805"]}
{"title": "High-level multicore programming with C++ 11\n", "abstract": " Nowadays, one of the most important challenges in programming is the    efficient usage of multicore processors. All modern programming languages    support multicore programming at native or library level. C++11, the next    standard of the C++ programming language, also supports multithreading at a    low level. In this paper we argue for some extensions of the C++ Standard    Template Library based on the features of C++11. These extensions enhance    the standard library to be more powerful in the multicore realm. Our    approach is based on functors and lambda expressions, which are major    extensions in the language. We contribute three case studies: how to    efficiently compose functors in pipelines, how to evaluate boolean operators    in parallel, and how to efficiently accumulate over associative functors.", "num_citations": "3\n", "authors": ["805"]}
{"title": "Pattern Candidate Discovery and Parallelization Techniques\n", "abstract": " Parallel computations in a program can be expressed conveniently, at a high level of abstraction, using parallel patterns such as task farm, pipeline or divide-and-conquer. In order to transform a sequential program into a pattern-based parallel one, the software developer may want to apply refactoring transformations on it. This tutorial explains a methodology to perform tool supported parallelization of programs by presenting how to use a specific static source code analysis and transformation system for Erlang. A key element of the approach is pattern candidate discovery, a static analysis technique to identify code fragments that can be refactored into a parallel pattern.", "num_citations": "2\n", "authors": ["805"]}
{"title": "ODF Mobile Edition\u2013Towards the development of a mobile office software\n", "abstract": " Abstract Open Document Format (ODF)[1, 2] is an increasingly popular office document format which is accepted by most of modern office suites and is the native format of OpenOffice. org. The aim of our project is to create a software suite of specialized mobile ODF schemata and editors to provide support for editing ODF-based documents on mobile devices, such as mobile phones, smartphones and PDA\u2019s. Currently editing of concurrent document formats is supported on smartphones and PDA\u2019s only. We created prototype software to test editing capabilities of a wide range of mobile devices, tested them with a variety of schema versions of different complexities and measured the resource need of different editor operations through a scripting interface. This paper presents our prototype tools, test methodology and results.", "num_citations": "2\n", "authors": ["805"]}
{"title": "Semantic model for proving properties of clean object i/o programs\n", "abstract": " The functional programming language Clean has an extensive library, the Object I/O library, to build interactive, event-driven applications with graphical user interface. Furthermore, Clean has a dedicated theorem prover, the Sparkle system, to prepare machine-verified proofs for Clean programs. Unfortunately, the Object I/O library uses some features of Clean (uniqueness typing, existential types, non-Clean code) that are currently not supported properly by Sparkle. Moreover, Sparkle is not capable to deal with the size and the complexity of Object I/O within reasonable resource bounds. For these reasons Sparkle cannot handle Object I/O programs directly. However, creating machine-verified proofs for such Clean programs might be accomplished within a model of the Object I/O library, which is already manageable by Sparkle. This paper presents such a model. In this model the properties of the Object I/O library are expressed as axioms. These axioms serve as the building blocks of proofs about interactive, event-driven Clean programs. The paper illustrates this technique with proofs on some simple properties of a small event-driven program.", "num_citations": "2\n", "authors": ["805"]}
{"title": "Data access optimization on grid systems\n", "abstract": " The execution of data intensive grid applications still raises several questions regarding job scheduling, data migration and replication. The optimization techniques applied by these services significantly determine how fast a job can be executed and how early the user can get the execution results. In this paper we present strategies for scheduling the execution of data intensive applications. We deem that by taking into account the way applications access their data, the grid middleware can achieve lower response times and earlier execution results. Therefore, we (1) monitor the execution of jobs and gather the necessary resource access information, (2) analyze the compiled information and generate a description of the behavior of the job, and (3) use the generated behavior description to implement optimized scheduling algorithms. This technique can be extremely useful in the case of parameter-sweep\u00a0\u2026", "num_citations": "2\n", "authors": ["805"]}
{"title": "Workflow Description in Cyber-Physical Systems\n", "abstract": " Cyber-physical systems (CPS) are networks of computational and physical processes, often containing human actors. In a CPS-setting, the computational processes collect information on their physical environment via sensors, and react upon via actuators in order to reach a desired state of the physical world.In the approach presented in this paper a CPS application is implemented as a hierarchical workflow of mostly independent tasks, which are executed in a distributed environment, and satisfy timing constraints. In certain cases such workflows can be defined from natural language descriptions with the use of ontologies. The structure of a workflow, as well as the constraints put on the constituting tasks, are expressed in a domainspecific programming language.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Low level conditional move optimization\n", "abstract": " The high level optimizations are becoming more and more sophisticated, the importance of low level optimizations should not be underestimated. Due to the changes in the inner architecture of modern processors, some optimization techniques may become more or less effective. Existing techniques need, from time to time, to be reconsidered, and new techniques, targeting these modern architectures, may emerge. Due to the growing instruction pipeline of modern processors, recovering after branch mis-predictions is becoming more expensive, and so avoiding that is becoming more critical. In this paper we introduce a novel approach to branch elimination using conditional move operations, namely the CMOVcc instruction group. The inappropriate use of these instructions may result in sensible performance regression, but in many cases they outperform the sequence of a conditional jump and an unconditional move instruction. Our goal is to analyze the usage of CMOVcc in different contexts on modern processors, and based on these results, propose a technique to automatically decide whether the conditional move or the sequence of a conditional jump and an unconditional move should be performed in a given situation.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Clean up the web!\n", "abstract": " Programming in Clean is much more appealing than programming in JavaScript. Therefore, solutions that can replace JavaScript with Clean in client-side web development are widely welcomed. This paper describes a technology for the cross-compilation of Clean to JavaScript and for the tight integration of the generated code into a web application. Our solution is based on the iTask framework and its extension, the so-called Tasklets. The application server approach provides simple and easy deployment, thus supporting rapid development. Examples are shown to illustrate how communication between the Clean and JavaScript code can be established.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Superoptimization in LLVM\n", "abstract": " Superoptimization is a known technique to integrate the analyses and transformations of a number of separate optimizations in order to obtain an optimization that is more expressive than the sequential and iterative application of the original optimizations. This paper describes the elaboration of this technique within the Low Level Virtual Machine (LLVM) Compiler Infrastructure. A framework supporting the integration of modular optimizations into superoptimization is presented. Some LLVM-specific implementation considerations are also discussed. Finally, a brief introduction to the use of the framework is provided.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Untangling Type Inference and Scope Analysis\n", "abstract": " Many modern functional programming languages support record types, parametric polymorphism and type inference. Allowing the same field name for two different records causes a problem in these languages. Some languages (eg Haskell) do not let you share the same field name among record types. Other languages (eg Clean) take the ambiguity of field names into account when deciding the type of a record expression. In the latter case the necessary static analysis performed by the compiler tangles type inference and scope analysis, because the scope analysis of field names needs type information and vice versa. This can result in a complex type inference algorithm and hardly maintainable code in the compiler of a language supporting namespaces and records.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Software Engineering Education in Cooperation with Industrial Partners\n", "abstract": " This paper presents our experiences on teaching software engineering in teams which are organized around different R+ D projects. These long-running, innovative projects are carried out in cooperation with industrial partners, and are supported by student exchange. While MSc and PhD students work together with faculty staff members on the projects in an industrial-like environment, the students develop skills that would be otherwise very hard for them to obtain. The methodological contributions of the paper are illustrated by, and substantiated with, the description of a concrete software engineering project.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Speculative Scheduling of Parameter Sweep Applications Using Job Behavior Descriptions\n", "abstract": " The execution of data intensive Grid applications still raises several questions regarding job scheduling, data migration and replication. This article presents new scheduling algorithms using complex job behavior descriptions that allow estimating job completion times more precisely thus improving scheduling decisions. Three approaches of using complex, re-fined job descriptions are discussed: a) single job description, b) multiple job descriptions, c) multiple job descriptions with mutation. The proposed Grid middleware components (1) monitor the execution of jobs and gather resource access information,(2) analyze the compiled information and generate a description of the behavior of the job,(3) refine the already existing job description, and (4) use the refined behavior description to schedule the submitted jobs.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Safe mobile code controlling a robot\n", "abstract": " This paper describes a technique applicable for the specification and verification of mobile components. The technique makes it possible for a system to impose requirements against mobile components and to verify that the requirements are met. A case study illustrates how the behaviour of a mobile component can be formalized and proved with respect to the formal specification of other components of the system. In the case study a programmable robot controlling system is presented: mission programs are loaded into this system, and executed only if their correctness can be verified. Certified Proved-Property-Carrying Code is a technique for efficiently ensuring correctness of mobile code. It relies on a trusted certifying authority that statically verifies correctness proofs and certifies correctness of program components passed as mobile code from a code producer to a code receiver. This paper uses an implementation of CPPCC to enable the safe dynamic reconfiguration or reprogramming of a robot. In this implementation the B-method is used to construct programs together with machine-verifiable proofs of correctness.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Towards an agent integrated speculative scheduling service\n", "abstract": " The optimization of data access will largely influence the performance of the current and next generation Data Grid systems. Job finishing times are an important factor in the characterization of Grid performance, as the earlier a newly submitted job is finished, the more the submitter is satisfied. Our focus in this paper is mainly on how the introduction of agents can improve job finishing time on the Data Grid systems. The strategy takes into account the way applications access their data and extend the Grid middleware so that earlier job finishing times can be achieved. The success of this strategy is due mainly to the following two reasons:(i) the scheduler takes into account the job\u2019s behaviour,(ii) the proposed agents deliver the necessary files earlier, so the job has to wait less before the execution.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Introducing records by refactoring in erlang programs\n", "abstract": " This paper focuses on introducing a new transformation to our existing model for refactoring Erlang programs. The goal of the transformation is to introduce a new abstraction level in data representation by substituting a group of related data with a record. Using record types enhances the legibility of the source code, makes further development easier, and makes programs less error prone by providing better possibilities for both compile time and run time checks. Erlang is a dynamically typed language, and many of its semantical rules are also dynamic. Therefore the main challenge in this research is to ensure the safety of statically performed refactoring steps. The paper analyses the possibilities of transforming tuples to records via examples. There is a strong industrial demand for such a transformation in refactoring legacy code.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Proving program properties specified with subtype marks\n", "abstract": " This paper presents a method that facilitates formal reasoning about the correctness of programs. In this method, properties of programs (e.g. pre- and postconditions of functions) are described in terms of type invariants. Subtype marks are annotations attached to types and denote type invariants. A large amount of program properties expressed with subtype marks are verifiable fully automatically by an appropriate type system; the rest can be proven with a proof system. In this paper an eager pure functional language with a type system supporting subtype marks is briefly described. By assigning an interpretation to subtype marks, a concept of program correctness is introduced. The soundness of the presented type system is investigated.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Aspect-Oriented Programming and the AspectJ\n", "abstract": " Aspect-Oriented Programming and the AspectJ Page 1 Supported by GVOP3.2.22004070005/3.0 (ELTE IKKK) AspectOriented Programming and the AspectJ Tam\u00e1s Kozsik (kto@elte.hu, http://kto.web.elte.hu/) Dept. Programming Languages and Compilers E\u00f6tv\u00f6s Lor\u00e1nd University, Budapest (Hungary) Page 2 May 21 June 1, 2007. AspectOriented Programming and the AspectJ (Tam\u00e1s Kozsik) 2/300 Contents \u2022 Need for a novel paradigm \u2022 AspectOriented Software Development \u2013 AspectOriented Design \u2013 AspectOriented Programming \u2022 AspectJ (language and tools) \u2022 Other languages and tools \u2013 Applications, examples \u2022 Related technologies Page 3 May 21 June 1, 2007. AspectOriented Programming and the AspectJ (Tam\u00e1s Kozsik) 3/300 Schedule \u2022 Need for a novel paradigm Separation of concerns AspectOriented Programming \u2022 AspectJ \u2022 AspectOriented Software Development Related technologies Page 4 \u2026", "num_citations": "1\n", "authors": ["805"]}
{"title": "The Expressive Power of Inequalities3\n", "abstract": " Inequalities are often used to express constraints in systems. For instance, inequalities in type systems can be useful for the static analysis of programs. The uniqueness type system [1, 2] is a good example. In this type system, types are annotated with so-called \u201cuniqueness attributes\u201d. Inequalities between uniqueness attribute variables let the programmer describe complex uniqueness constraints with a single (\u201cprinciple\u201d) type.A similar type system [3, 4, 5, 6] encodes certain safety properties of programs in the types. Annotations, called \u201csubtype marks\u201d are attached to types, which express type invariants: a subtype mark enforces a constraint on the value set of the type. The presence and the absence of subtype marks induce a subtype relation in this type system. Functions can be polymorphic with respect to subtypes: in a typing, a set of subtype marked types can be assigned to each function. Subtype mark variables and inequalities on such variables provide a way to eliminate the need for these type sets, and to introduce a notion of principal typing. My talk investigates how subtype mark variables and inequalities can substitute sets of subtype marked types. Furthermore, I discuss another approach to impose constraints on subtype mark variables.", "num_citations": "1\n", "authors": ["805"]}
{"title": "Assign predicates to subtype marks\u2014a case study\n", "abstract": " A type system with subtype marks enables us to reason about certain safety properties of programs in an efficient way. A significant part of the reasoning can be performed by the type system, only the remaining part has to be performed with a more resource consuming tool. This latter can be either a theorem prover, or a run-time system. The paper investigates both approaches. It summarizes what subtype marks are, and how they can be used in an appropriate type system to describe the propagation of certain properties, namely type invariants. Then it examines how the more complicated part of the reasoning can be performed. This includes the association of first-order logical predicates to subtype marks, and either the generation and compile-time proof of theorems, or the generation of assertions to be checked run-time. The advantages and drawbacks of the two approaches are also discussed.", "num_citations": "1\n", "authors": ["805"]}
{"title": "A Data Intensive Computation on a Cluster\n", "abstract": " We have investigated the applicability of PC clusters with terabyte disk-servers for data-intensive parallel computing. We used parallel element-wise processing as our testcase. We have searched for the optimal value for parameters of the algorithm running on our hardware environment. The performance of several communication frameworks has been tested, such as C/PVM, C/MPI, Distributed Haskell and socket interface in C. On large inputs with heavy operations our implementations showed considerable speedups.", "num_citations": "1\n", "authors": ["805"]}
{"title": "On Composing Problems and Parallel Programs\n", "abstract": " We introduce the basic concepts of a relational model of parallel programming. We define the concepts of a problem, an abstract program and a solution. Our approach is functional, problems are given an own semantical meaning. The abstract program is regarded as a relation generated by a set of nondeterministic conditional assignments similar to the concept of abstract program in UNITY. We introduce the behaviour relation of a parallel program which is easy to compare to the relation which is the interpretation of a problem. This paper covers only a brief summary of the model. For further information see [7].The main goal of this paper is to introduce some basic composition methods for parallel programs and problems. We define the union, extension and sequence of problems. Similarly we formalize the concept of union, superposition and sequence of parallel programs. We analyze how one can solve a compound problem using the appropriate program construct.", "num_citations": "1\n", "authors": ["805"]}