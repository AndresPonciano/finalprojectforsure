{"title": "Truly Modular (Co)datatypes for Isabelle/HOL\n", "abstract": " We extended Isabelle/HOL with a pair of definitional commands for datatypes and codatatypes. They support mutual and nested (co)recursion through well-behaved type constructors, including mixed recursion\u2013corecursion, and are complemented by syntaxes for introducing primitively (co)recursive functions and by a general proof method for reasoning coinductively. As a case study, we ported Isabelle\u2019s Coinductive library to use the new commands, eliminating the need for tedious ad hoc constructions.", "num_citations": "110\n", "authors": ["1656"]}
{"title": "Foundational, Compositional (Co)datatypes for Higher-Order Logic: Category Theory Applied to Theorem Proving\n", "abstract": " Interactive theorem provers based on higher-order logic (HOL) traditionally follow the definitional approach, reducing high-level specifications to logical primitives. This also applies to the support for datatype definitions. However, the internal datatype construction used in HOL4, HOL Light, and Isabelle/HOL is fundamentally noncompositional, limiting its efficiency and flexibility, and it does not cater for codatatypes. We present a fully modular framework for constructing (co)datatypes in HOL, with support for mixed mutual and nested (co)recursion. Mixed (co)recursion enables type definitions involving both datatypes and codatatypes, such as the type of finitely branching trees of possibly infinite depth. Our framework draws heavily from category theory. The key notion is that of a bounded natural functor---an enriched type constructor satisfying specific properties preserved by interesting categorical operations. Our\u00a0\u2026", "num_citations": "66\n", "authors": ["1656"]}
{"title": "Foundational Extensible Corecursion: A Proof Assistant Perspective\n", "abstract": " This paper presents a formalized framework for defining corecursive functions safely in a total setting, based on corecursion up-to and relational parametricity. The end product is a general corecursor that allows corecursive (and even recursive) calls under\" friendly\" operations, including constructors. Friendly corecursive functions can be registered as such, thereby increasing the corecursor's expressiveness. The metatheory is formalized in the Isabelle proof assistant and forms the core of a prototype tool. The corecursor is derived from first principles, without requiring new axioms or extensions of the logic.", "num_citations": "38\n", "authors": ["1656"]}
{"title": "Soundness and completeness proofs by coinductive methods\n", "abstract": " We show how codatatypes can be employed to produce compact, high-level proofs of key results in logic: the soundness and completeness of proof systems for variations of first-order logic. For the classical completeness result, we first establish an abstract property of possibly infinite derivation trees. The abstract proof can be instantiated for a wide range of Gentzen and tableau systems for various flavors of first-order logic. Soundness becomes interesting as soon as one allows infinite proofs of first-order formulas. This forms the subject of several cyclic proof systems for first-order logic augmented with inductive predicate definitions studied in the literature. All the discussed results are formalized using Isabelle/HOL\u2019s recently introduced support for codatatypes and corecursion. The development illustrates some unique features of Isabelle/HOL\u2019s new coinductive specification language such as nesting\u00a0\u2026", "num_citations": "30\n", "authors": ["1656"]}
{"title": "Formalizing Bachmair and Ganzinger\u2019s ordered resolution prover\n", "abstract": " We present an Isabelle/HOL formalization of the first half of Bachmair and Ganzinger\u2019s chapter on resolution theorem proving, culminating with a refutationally complete first-order prover based on ordered resolution with literal selection. We developed general infrastructure and methodology that can form the basis of completeness proofs for related calculi, including superposition. Our work clarifies fine points in the chapter, emphasizing the value of formal proofs in the field of automated reasoning.", "num_citations": "27\n", "authors": ["1656"]}
{"title": "A verified prover based on ordered resolution\n", "abstract": " The superposition calculus, which underlies first-order theorem provers such as E, SPASS, and Vampire, combines ordered resolution and equality reasoning. As a step towards verifying modern provers, we specify, using Isabelle/HOL, a purely functional first-order ordered resolution prover and establish its soundness and refutational completeness. Methodologically, we apply stepwise refinement to obtain, from an abstract nondeterministic specification, a verified deterministic program, written in a subset of Isabelle/HOL from which we extract purely functional Standard ML code that constitutes a semidecision procedure for first-order logic.", "num_citations": "25\n", "authors": ["1656"]}
{"title": "Witnessing (Co)datatypes\n", "abstract": " Datatypes and codatatypes are useful for specifying and reasoning about (possibly infinite) computational processes. The Isabelle/HOL proof assistant has recently been extended with a definitional package that supports both. We describe a complete procedure for deriving nonemptiness witnesses in the general mutually recursive, nested case\u2014nonemptiness being a proviso for introducing types in higher-order logic.", "num_citations": "24\n", "authors": ["1656"]}
{"title": "Cardinals in Isabelle/HOL\n", "abstract": " We report on a formalization of ordinals and cardinals in Isabelle/HOL. A main challenge we faced is the inability of higher-order logic to represent ordinals canonically, as transitive sets (as done in set theory). We resolved this into a \u201cdecentralized\u201d representation that identifies ordinals with wellorders, with all concepts and results proved to be invariant under order isomorphism. We also discuss two applications of this general theory in formal developments.", "num_citations": "21\n", "authors": ["1656"]}
{"title": "Foundational nonuniform (co) datatypes for higher-order logic\n", "abstract": " Nonuniform (or \u201cnested\u201d or \u201cheterogeneous\u201d) datatypes are recursively defined types in which the type arguments vary recursively. They arise in the implementation of finger trees and other efficient functional data structures. We show how to reduce a large class of nonuniform datatypes and codatatypes to uniform types in higher-order logic. We programmed this reduction in the Isabelle/HOL proof assistant, thereby enriching its specification language. Moreover, we derive (co)induction and (co)recursion principles based on a weak variant of parametricity.", "num_citations": "19\n", "authors": ["1656"]}
{"title": "A Formalized Hierarchy of Probabilistic System Types\n", "abstract": " Numerous models of probabilistic systems are studied in the literature. Coalgebra has been used to classify them into system types and compare their expressiveness. In this work, we formalize the resulting hierarchy of probabilistic system types in Isabelle/HOL by modeling the semantics of the different systems as codatatypes. This approach yields simple and concise proofs, as bisimilarity coincides with equality for codatatypes. On the way, we develop libraries of bounded sets and discrete probability distributions and integrate them with the facility for (co)datatype definitions.", "num_citations": "17\n", "authors": ["1656"]}
{"title": "Foundational (co) datatypes and (co) recursion for higher-order logic\n", "abstract": " We describe a line of work that started in 2011 towards enriching Isabelle/HOL\u2019s language with coinductive datatypes, which allow infinite values, and with a more expressive notion of inductive datatype than previously supported by any system based on higher-order logic. These (co)datatypes are complemented by definitional principles for (co)recursive functions and reasoning principles for (co)induction. In contrast with other systems offering codatatypes, no additional axioms or logic extensions are necessary with our approach.", "num_citations": "15\n", "authors": ["1656"]}
{"title": "Defining (Co) datatypes and Primitively (Co) recursive Functions in Isabelle/HOL\n", "abstract": " This tutorial describes the definitional package for datatypes and codatatypes, and for primitively recursive and corecursive functions, in Isabelle/HOL. The following commands are provided: datatype, datatype_compat, primrec, codatatype, primcorec, primcorecursive, bnf, lift_bnf, copy_bnf, bnf_axiomatization, print_bnfs, and free_constructors.", "num_citations": "11\n", "authors": ["1656"]}
{"title": "Bindings as bounded natural functors\n", "abstract": " We present a general framework for specifying and reasoning about syntax with bindings. Abstract binder types are modeled using a universe of functors on sets, subject to a number of operations that can be used to construct complex binding patterns and binding-aware datatypes, including non-well-founded and infinitely branching types, in a modular fashion. Despite not committing to any syntactic format, the framework is ``concrete'' enough to provide definitions of the fundamental operators on terms (free variables, alpha-equivalence, and capture-avoiding substitution) and reasoning and definition principles. This work is compatible with classical higher-order logic and has been formalized in the proof assistant Isabelle/HOL.", "num_citations": "11\n", "authors": ["1656"]}
{"title": "A Coalgebraic Decision Procedure for WS1S\n", "abstract": " Weak monadic second-order logic of one successor (WS1S) is a simple and natural formalism to specify regular properties. WS1S is decidable, although the decision procedure's complexity is non-elementary. Typically, decision procedures for WS1S exploit the logic-automaton connection, ie they escape the simple and natural formalism by translating formulas into equally expressive regular structures such as finite automata, regular expressions, or games. In this work, we devise a coalgebraic decision procedure for WS1S that stays within the logical world by directly operating on formulas. The key operation is the derivative of a formula, modeled after Brzozowski's derivatives of regular expressions. The presented decision procedure has been formalized and proved correct in the interactive proof assistant Isabelle.", "num_citations": "11\n", "authors": ["1656"]}
{"title": "Verified Decision Procedures for MSO on Words Based on Derivatives of Regular Expressions\n", "abstract": " Monadic second-order logic on finite words (MSO) is a decidable yet expressive logic into which many decision problems can be encoded. Since MSO formulas correspond to regular languages, equivalence of MSO formulas can be reduced to the equivalence of some regular structures (e.g. automata). This paper presents a verified functional decision procedure for MSO formulas that is not based on automata but on regular expressions. Functional languages are ideally suited for this task: regular expressions are data types and functions on them are defined by pattern matching and recursion and are verified by structural induction. Decision procedures for regular expression equivalence have been formalized before, usually based on Brzozowski derivatives. Yet, for a straightforward embedding of MSO formulas into regular expressions an extension of regular expressions with a projection operation is required\u00a0\u2026", "num_citations": "10\n", "authors": ["1656"]}
{"title": "Nested multisets, hereditary multisets, and syntactic ordinals in Isabelle/HOL\n", "abstract": " We present a collection of formalized results about finite nested multisets, developed using the Isabelle/HOL proof assistant. The nested multiset order is a generalization of the multiset order that can be used to prove termination of processes. Hereditary multisets, a variant of nested multisets, offer a convenient representation of ordinals below 0. In Isabelle/HOL, both nested and hereditary multisets can be comfortably defined as inductive datatypes. Our formal library also provides, somewhat nonstandardly, multisets with negative multiplicities and syntactic or-dinals with negative coefficients. We present applications of the library to formalizations of Goodstein's theorem and the decidability of unary PCF (programming computable functions). 1 Introduction In their seminal article on proving termination using multisets [15], Dershowitz and Manna introduced two orders of increasing strength. The multiset order lifts a base partial order on a set A to finite multisets over A. It forms the basis of the multiset path order, which has many applications in term rewriting [41] and automatic theorem proving [1]. The nested multiset order is a generalization of the multiset order that operates on multisets that can be nested in arbitrary ways. Nesting can increase the order's strength: If (A, <) has ordinal type \u03b1 < 0 , the associated multiset order has ordinal type \u03c9 \u03b1 , whereas the nested order has ordinal type 0 = \u03c9 \u03c9 \u03c9. .. . In this paper, we present formal proofs of the main properties of the nested multiset order that are useful in applications: preservation of well-foundedness and preservation of totality (linearity). The proofs are developed in the Isabelle/HOL proof\u00a0\u2026", "num_citations": "9\n", "authors": ["1656"]}
{"title": "A formally verified abstract account of G\u00f6del\u2019s incompleteness theorems\n", "abstract": " We present an abstract development of G\u00f6del\u2019s incompleteness theorems, performed with the help of the Isabelle/HOL theorem prover. We analyze sufficient conditions for the theorems\u2019 applicability to a partially specified logic. In addition to the usual benefits of generality, our abstract perspective enables a comparison between alternative approaches from the literature. These include Rosser\u2019s variation of the first theorem, Jeroslow\u2019s variation of the second theorem, and the \u015awierczkowski\u2013Paulson semantics-based approach. As part of our framework\u2019s validation, we upgrade Paulson\u2019s Isabelle proof to produce a mechanization of the second theorem that does not assume soundness in the standard model, and in fact does not rely on any notion of model or semantic interpretation.", "num_citations": "8\n", "authors": ["1656"]}
{"title": "A verified functional implementation of Bachmair and Ganzinger\u2019s ordered resolution prover\n", "abstract": " This Isabelle/HOL formalization refines the abstract ordered resolution prover presented in Section 4.3 of Bachmair and Ganzinger\u2019s \u201cResolution Theorem Proving\u201d chapter in the Handbook of Automated Reasoning. The result is a functional implementation of a first-order prover.", "num_citations": "5\n", "authors": ["1656"]}
{"title": "Formalization of Bachmair and Ganzinger\u2019s ordered resolution prover\n", "abstract": " This Isabelle/HOL formalization covers Sections 2 to 4 of Bachmair and Ganzinger\u2019s \u201cResolution Theorem Proving\u201d chapter in the Handbook of Automated Reasoning. This includes soundness and completeness of unordered and ordered variants of ground resolution with and without literal selection, the standard redundancy criterion, a general framework for refutational theorem proving, and soundness and completeness of an abstract first-order prover.", "num_citations": "4\n", "authors": ["1656"]}
{"title": "Formal languages, formally and coinductively\n", "abstract": " Traditionally, formal languages are defined as sets of words. More recently, the alternative coalgebraic or coinductive representation as infinite tries, i.e., prefix trees branching over the alphabet, has been used to obtain compact and elegant proofs of classic results in language theory. In this article, we study this representation in the Isabelle proof assistant. We define regular operations on infinite tries and prove the axioms of Kleene algebra for those operations. Thereby, we exercise corecursion and coinduction and confirm the coinductive view being profitable in formalizations, as it improves over the set-of-words view with respect to proof automation.", "num_citations": "4\n", "authors": ["1656"]}
{"title": "Conditional Parametricity in Isabelle/HOL\n", "abstract": " Parametricity [6] is a central notion in functional programming which singles out \u201ctruly\u201d polymorphic functions. Such functions behave exactly the same, no matter what concrete type they are actually used with at run-time. For example, the standard map function on lists map::(\u03b1\u2192 \u03b2)\u2192 \u03b1 list\u2192 \u03b2 list is parametric in both type variables \u03b1 and \u03b2 as map f xs merely applies the function f to all elements of xs, independent of whether xs is a list of ints or a list of strings. Parametricity has numerous theoretical and practical applications. On the theoretical side various theorems follow \u201cfor free\u201d for parametric functions [7]. On the practical side, in particular in the proof assistant Isabelle/HOL [5], parametricity is the key driving force behind data refinement [4], transfer of definitions and theorems across subtypes and quotient types [3], productivity checks for corecursive definitions [1], and nonuniform (co) datatypes [2]. Parametricity can be formally captured by theorems. For map, it looks as follows:", "num_citations": "4\n", "authors": ["1656"]}
{"title": "Verified decision procedures for MSO on words based on derivatives of regular expressions\n", "abstract": " Monadic second-order logic on finite words is a decidable yet expressive logic into which many decision problems can be encoded. Since MSO formulas correspond to regular languages, equivalence of MSO formulas can be reduced to the equivalence of some regular structures (e.g., automata). This paper presents a verified functional decision procedure for MSO formulas that is not based on automata but on regular expressions. Functional languages are ideally suited for this task: regular expressions are data types and functions on them are defined by pattern matching and recursion and are verified by structural induction. Decision procedures for regular expression equivalence have been formalized before, usually based on Brzozowski derivatives. Yet, for a straightforward embedding of MSO formulas into regular expressions, an extension of regular expressions with a projection operation is required. We\u00a0\u2026", "num_citations": "3\n", "authors": ["1656"]}
{"title": "Experience report: The next 1100 haskell programmers\n", "abstract": " We report on our experience teaching a Haskell-based functional programming course to over 1100 students for two winter terms. The syllabus was organized around selected material from various sources. Throughout the terms, we emphasized correctness through QuickCheck tests and proofs by induction. The submission architecture was coupled with automatic testing, giving students the possibility to correct mistakes before the deadline. To motivate the students, we complemented the weekly assignments with an informal competition and gave away trophies in a award ceremony.", "num_citations": "3\n", "authors": ["1656"]}
{"title": "Quotients of bounded natural functors\n", "abstract": " The functorial structure of type constructors is the foundation for many definition and proof principles in higher-order logic (HOL). For example, inductive and coinductive datatypes can be built modularly from bounded natural functors (BNFs), a class of well-behaved type constructors. Composition, fixpoints, and\u2014under certain conditions\u2014subtypes are known to preserve the BNF structure. In this paper, we tackle the preservation question for quotients, the last important principle for introducing new types in HOL. We identify sufficient conditions under which a quotient inherits the BNF structure from its underlying type. We extend the Isabelle proof assistant with a command that automates the registration of a quotient type as a BNF by lifting the underlying type\u2019s BNF structure. We demonstrate the command\u2019s usefulness through several case studies.", "num_citations": "2\n", "authors": ["1656"]}
{"title": "Generic authenticated data structures, formally\n", "abstract": " Authenticated data structures are a technique for outsourcing data storage and maintenance to an untrusted server. The server is required to produce an efficiently checkable and cryptographically secure proof that it carried out precisely the requested computation. Recently, Miller et al.[https://doi. org/10.1145/2535838.2535851] demonstrated how to support a wide range of such data structures by integrating an authentication construct as a first class citizen in a functional programming language. In this paper, we put this work to the test of formalization in the Isabelle proof assistant. With Isabelle's help, we uncover and repair several mistakes and modify the small-step semantics to perform call-by-value evaluation rather than requiring terms to be in administrative normal form.", "num_citations": "2\n", "authors": ["1656"]}
{"title": "Operations on bounded natural functors\n", "abstract": " This entry formalizes the closure property of bounded natural functors (BNFs) under seven operations. These operations and the corresponding proofs constitute the core of Isabelle\u2019s (co) datatype package. To be close to the implemented tactics, the proofs are deliberately formulated as detailed apply scripts. The (co) datatypes together with (co) induction principles and (co) recursors are byproducts of the fixpoint operations LFP and GFP. Composition of BNFs is subdivided into four simpler operations: Compose, Kill, Lift, and Permute. The N2M operation provides mutual (co) induction principles and (co) recursors for nested (co) datatypes.", "num_citations": "2\n", "authors": ["1656"]}
{"title": "Verified progress tracking for timely dataflow\n", "abstract": " Large-scale stream processing systems often follow the dataflow paradigm, which enforces a program structure that exposes a high degree of parallelism. The Timely Dataflow distributed system supports expressive cyclic dataflows for which it offers low-latency data-and pipeline-parallel stream processing. To achieve high expressiveness and performance, Timely Dataflow uses an intricate distributed protocol for tracking the computation\u2019s progress. We modeled the progress tracking protocol as a combination of two independent transition systems in the Isabelle/HOL proof assistant. We specified and verified the safety of the two components and of the combined protocol. To this end, we identified abstract assumptions on dataflow programs that are sufficient for safety and were not previously formalized.", "num_citations": "1\n", "authors": ["1656"]}
{"title": "Syntax-independent logic infrastructure\n", "abstract": " We formalize a notion of logic whose terms and formulas are kept abstract. In particular, logical connectives, substitution, free variables, and provability are not defined, but characterized by their general properties as locale assumptions. Based on this abstract characterization, we develop further reusable reasoning infrastructure. For example, we define parallel substitution (along with proving its characterizing theorems) from single-point substitution. Similarly, we develop a natural deduction style proof system starting from the abstract Hilbert-style one. These one-time efforts benefit different concrete logics satisfying our locales\u2019 assumptions. We instantiate the syntax-independent logic infrastructure to Robinson arithmetic (also known as Q) in the AFP entry Robinson_Arithmetic and to hereditarily finite set theory in the AFP entries Goedel_HFSet_Semantic and Goedel_HFSet_Semanticless, which are part of our formalization of G\u00f6del\u2019s Incompleteness Theorems described in our CADE-27 paper [1].", "num_citations": "1\n", "authors": ["1656"]}
{"title": "Robinson arithmetic\n", "abstract": " We instantiate our syntax-independent logic infrastructure developed in a separate AFP entry to the FOL theory of Robinson arithmetic (also known as Q). The latter was formalised using Nominal Isabelle by adapting Larry Paulsons formalization of the Hereditarily Finite Set theory.", "num_citations": "1\n", "authors": ["1656"]}
{"title": "From abstract to concrete G\u00f6del\u2019s incompleteness theorems\u2014part II\n", "abstract": " We validate an abstract formulation of G\u00f6dels Second Incompleteness Theorem from a separate AFP entry by instantiating it to the case of finite consistent extensions of the Hereditarily Finite (HF) Set theory, ie, consistent FOL theories extending the HF Set theory with a finite set of axioms.The instantiation draws heavily on infrastructure previously developed by Larry Paulson in his direct formalisation of the concrete result. It strengthens Paulsons formalization of G\u00f6del\u2019s Second from that entry by not assuming soundness, and in fact not relying on any notion of model or semantic interpretation. The strengthening was obtained by first replacing some of Paulsons semantic arguments with proofs within his HF calculus, and then plugging in some of Paulson\u2019s (modified) lemmas to instantiate our soundness-free G\u00f6del\u2019s Second locale.", "num_citations": "1\n", "authors": ["1656"]}
{"title": "An abstract formalization of G\u00f6del\u2019s incompleteness theorems\n", "abstract": " We present an abstract formalization of G\u00f6del\u2019s incompleteness theorems. We analyze sufficient conditions for the theorems\u2019 applicability to a partially specified logic. Our abstract perspective enables a comparison between alternative approaches from the literature. These include Rosser\u2019s variation of the first theorem, Jeroslow\u2019s variation of the second theorem, and the Swierczkowski\u2013Paulson semantics-based approach. This AFP entry is the main entry point to the results described in our CADE-27 paper [1].", "num_citations": "1\n", "authors": ["1656"]}
{"title": "Defining Nonprimitively Corecursive Functions in Isabelle/HOL\n", "abstract": " This tutorial describes the definitional package for nonprimitively corecursive functions in Isabelle/HOL. The following commands are provided: corec, corecursive, friend_of_corec, and coinduction_upto. They supplement codatatype, primcorec, and primcorecursive, which define codatatypes and primitively corecursive functions.", "num_citations": "1\n", "authors": ["1656"]}