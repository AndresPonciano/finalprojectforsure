{"title": "Ownership types for flexible alias protection\n", "abstract": " Object-oriented programming languages allow inter-object aliasing. Although necessary to construct linked data structures and networks of interacting objects, aliasing is problematic in that an aggregate object's state can change via an alias to one of its components, without the aggregate being aware of any aliasing. Ownership types form a static type system that indicates object ownership. This provides a flexible mechanism to limit the visibility of object references and restrict access paths to objects, thus controlling a system's dynamic topology. The type system is shown to be sound, and the specific aliasing properties that a system's object graph satisfies are formulated and proven invariant for well-typed programs.", "num_citations": "751\n", "authors": ["2221"]}
{"title": "The Qualitas Corpus: A curated collection of Java code for empirical studies\n", "abstract": " In order to increase our ability to use measurement to support software development practise we need to do more analysis of code. However, empirical studies of code are expensive and their results are difficult to compare. We describe the Qualitas Corpus, a large curated collection of open source Java systems. The corpus reduces the cost of performing large empirical studies of code and supports comparison of measurements of the same artifacts. We discuss its design, organisation, and issues associated with its development.", "num_citations": "431\n", "authors": ["2221"]}
{"title": "Flexible alias protection\n", "abstract": " Aliasing is endemic in object oriented programming. Because an object can be modified via any alias, object oriented programs are hard to understand, maintain, and analyse. Flexible alias protection is a conceptual model of inter-object relationships which limits the visibility of changes via aliases, allowing objects to be aliased but mitigating the undesirable effects of aliasing. Flexible alias protection can be checked statically using programmer supplied aliasing modes and imposes no runtime overhead. Using flexible alias protection, programs can incorporate mutable objects, immutable values, and updatable collections of shared objects, in a natural object oriented programming style, while avoiding the problems caused by aliasing.", "num_citations": "419\n", "authors": ["2221"]}
{"title": "A framework for implementing pluggable type systems\n", "abstract": " Pluggable types have been proposed to support multiple type systems in the same programming language. We have designed and implemented JavaCOP, a program constraint system for implementing practical pluggable type systems for Java. JavaCOP enforces user-defined typing constraints written in a declarative and expressive rule language. We have validated our design by (re) implementing a range of type systems and program checkers. By using a program constraint system to implement pluggable types, programmers are able to check that their programs will operate correctly in restricted environments, adhere to strict programming rules, avoid null pointer errors or scoped memory exceptions, and meet style guidelines, while programming language researchers can easily experiment with novel type systems.", "num_citations": "327\n", "authors": ["2221"]}
{"title": "Video game values: Human\u2013computer interaction and games\n", "abstract": " Current human\u2013computer interaction (HCI) research into video games rarely considers how they are different from other forms of software. This leads to research that, while useful concerning standard issues of interface design, does not address the nature of video games as games specifically. Unlike most software, video games are not made to support external, user-defined tasks, but instead define their own activities for players to engage in. We argue that video games contain systems of values which players perceive and adopt, and which shape the play of the game. A focus on video game values promotes a holistic view of video games as software, media, and as games specifically, which leads to a genuine video game HCI.", "num_citations": "307\n", "authors": ["2221"]}
{"title": "Scale-free geometry in OO programs\n", "abstract": " Though conventional OO design suggests programs should be built from many small objects, like Lego bricks, they are instead built from objects that are scale-free, like fractals, and unlike Lego bricks.", "num_citations": "286\n", "authors": ["2221"]}
{"title": "Understanding the shape of Java software\n", "abstract": " Large amounts of Java software have been written since the language's escape into unsuspecting software ecology more than ten years ago. Surprisingly little is known about the structure of Java programs in the wild: about the way methods are grouped into classes and then into packages, the way packages relate to each other, or the way inheritance and composition are used to put these programs together. We present the results of the first in-depth study of the structure of Java programs. We have collected a number of Java programs and measured their key structural attributes. We have found evidence that some relationships follow power-laws, while others do not. We have also observed variations that seem related to some characteristic of the application itself. This study provides important information for researchers who can investigate how and why the structural relationships we find may have originated\u00a0\u2026", "num_citations": "250\n", "authors": ["2221"]}
{"title": "Capabilities for sharing\n", "abstract": " Many languages and language extensions include annotations on pointer variables suchas \u201cread-only,\u201d \u201cunique,\u201d and \u201cborrowed\u201d; many more annotations have been proposed but not implemented. Unfortunately, all these annotations are described individually and formalised independently \u2014 assuming they are formalised at all. In this paper, we show how these annotations can be subsumed into a general capability system for pointers. This system separates mechanism (defining the semantics of sharing and exclusion) from policy (defining the invariants that are intended to be preserved). The capability system has a welldefined semantics which can be used as a reference for the correctness of various extended type systems using annotations. Furthermore, it supports researchin new less-restrictive type systems that permit a wider range of idioms to be statically checked.", "num_citations": "219\n", "authors": ["2221"]}
{"title": "Agile development iterations and UI design\n", "abstract": " Many agile projects require user interaction (UI) design, but the integration of UI design into agile development is not well understood. This is because both agile development and UI design are iterative - but while agile methods iterate on code with iterations lasting weeks, UI designs typically iterate only on the user interface using low technology prototypes with iterations lasting hours or days. Similarly, both agile development and UI design emphasise testing, but agile development involves automated code testing, while UI must done by expert inspectors or ideally potential end users. We report on a qualitative grounded theory study of real agile projects involving significant UI design. The key results from our study are that agile iterations facilitates usability testing; allows software developers to incorporate results of those tests into subsequent iterations; and crucially, can significantly improve the quality of the\u00a0\u2026", "num_citations": "173\n", "authors": ["2221"]}
{"title": "Simple ownership types for object containment\n", "abstract": " Containment of objects is a natural concept that has been poorly supported in object-oriented programming languages. For a predefined set of ownership contexts, this paper presents a type system that enforces certain containment relationships for run-time objects. A fixed ordering relationship is presumed between the owners.               The formalisation of ownership types has developed from our work with flexible alias protection together with an investigation of structural properties of object graphs based on dominator trees. Our general ownership type system permits fresh ownership contexts to be created at run-time. Here we present a simplified system in which the ownership contexts are predefined. This is powerful enough to express and enforce constraints about a system\u2019s high-level structure.               Our formal system is presented in an imperative variant of the object calculus. We present type\u00a0\u2026", "num_citations": "154\n", "authors": ["2221"]}
{"title": "Classifying relationships between object-oriented design patterns\n", "abstract": " Since the publication of the Design Patterns book (E. Gamma et al., 1994), a large number of object-oriented design patterns have been identified and codified. As part of the pattern form, object-oriented design patterns must indicate their relationships with other patterns, but these relationships are typically described very briefly, and different collections of patterns describe different relationships in different ways. In this paper, we describe and classify the common relationships between object-oriented design patterns. Practitioners can use these relationships to help them identity those patterns which may be applicable to a particular problem, and pattern writers can use these relationships to help them integrate new patterns into the body of the patterns literature.", "num_citations": "129\n", "authors": ["2221"]}
{"title": "The XP customer role in practice: Three studies\n", "abstract": " The customer is the only nondeveloper role in extreme programming (XP). The customer's explicit responsibilities are to drive the project, providing project requirements (user stories) and quality control (acceptance testing): unfortunately the customer must also shoulder a number of implicit responsibilities including liaison with external project stakeholders, especially project funders, clients, and end users, while maintaining the trust of both the development team and the wider business. In this paper, we report on a series of case studies of the customer role in XP projects. We have found that customers have a pressured and stressful role, leading to issues of sustainability.", "num_citations": "119\n", "authors": ["2221"]}
{"title": "Knowledge management in distributed agile software development\n", "abstract": " Software development teams need highly valuable knowledge to carry out knowledge-intensive development activities. Agile teams are cross-functional teams that promote sharing of project-specific knowledge through frequent faceto-face interaction, effective communication and customer collaboration. Knowledge sharing is difficult for distributed Agile teams due to spatial, temporal, and cultural barriers, which negatively affect face-to-face interaction, communication and collaboration. There seems to be very few studies that focus on knowledge management in distributed Agile teams. Through a Grounded Theory study that involved 45 participants from 28 different software companies in the USA, India and Australia, we investigate distributed software development from the specific perspective of Agile teams. In this paper, we describe how Agile teams gather, store, share and use knowledge in distributed software\u00a0\u2026", "num_citations": "100\n", "authors": ["2221"]}
{"title": "Generic ownership for generic Java\n", "abstract": " Ownership types enforce encapsulation in object-oriented programs by ensuring that objects cannot be leaked beyond object(s) that own them. Existing ownership programming languages either do not support parametric polymorphism (type genericity) or attempt to add it on top of ownership restrictions. Generic Ownership provides per-object ownership on top of a sound generic imperative language. The resulting system not only provides ownership guarantees comparable to established systems, but also requires few additional language mechanisms due to full reuse of parametric polymorphism. We formalise the core of Generic Ownership, highlighting that only restriction of this calls and owner subtype preservation are required to achieve deep ownership. Finally we describe how Ownership Generic Java (OGJ) was implemented as a minimal extension to Generic Java in the hope of bringing ownership types\u00a0\u2026", "num_citations": "97\n", "authors": ["2221"]}
{"title": "Prototype-based programming: Concepts, languages and applications\n", "abstract": " In recent years, an alternative to the traditional class-based object-oriented language model has emerged. In this prototype-based paradigm, there are no classes. Rather, new kinds of objects are formed more directly by composing concrete, full-fledged objects, which are often referred to as prototypes. When compared to class-based languages, prototype-based languages are conceptually simpler, and have many other characteristics that make them appealing, especially for the development of evolving, exploratory and/or distributed software systems. The distinction between class-based and prototype-based systems reflects a long-lasting philosophical dispute concerning the representation of abstractions. Class-based languages, such as Smalltalk, C++ and Java, explicitly use classes to represent similarity among collections of objects. Prototype-based systems, such as Self, NewtonScript and Omega, do not rely so much on advance categorization, but rather try to make the concepts in the problem domain as tangible and intuitive as possible. A typical argument in favor of prototypes is that people seem to be much better at dealing with specific examples first, then generalizing from them, than they are at absorbing general abstract principles first and later applying them in particular cases. This book presents the history and development of prototype-based programming and describes a number of prototype-based programming languages and applications. Such range from programs for portable digital appliances, graphical user-interface management systems for desktop and workstations, and cutting edge research on software visualisation\u00a0\u2026", "num_citations": "92\n", "authors": ["2221"]}
{"title": "Relationship aspects\n", "abstract": " The relationships between objects in object-oriented programs are as important as the objects themselves. Unfortunately, most object-oriented programming languages provide little support for such relationships, leaving the task of implementing them entirely to the programmer. Relationships are typically hard-coded into the participating classes, resulting in tangled code that unnecessarily couples these classes together. The classes become harder to understand and cannot be reused independently. Aspect-oriented programs can model relationships explicitly, treating them as separate concerns that cross-cut their participants. We show how relationships can be implemented as a library of aspects in Aspect/J. Aspects keep relationships independent of their participants, making the resulting programs easier to read, write and reuse, and as efficient as hand-written code.", "num_citations": "91\n", "authors": ["2221"]}
{"title": "Usage-Centered Design and Software Engineering: Models for Integration.\n", "abstract": " This paper argues for a model-driven framework for integrating human interface engineering with software engineering. The usage-centered design process, a robust and proven process grounded in software engineering, is briefly described and contrasted with traditional user-centered approaches. The connections between the core models of usage-centered design and their software engineering counterparts are outlined, and the advantages of this approach to bridging the gap are discussed.", "num_citations": "90\n", "authors": ["2221"]}
{"title": "Scoped types for real-time Java\n", "abstract": " A memory model based on scoped areas is one of the distinctive features of the Real-Time Specification for Java (RTSJ). Scoped types ensure timely reclamation of memory and predictable performance. The price to pay for these benefits is an unfamiliar programming model that, at the same time, is complex, requires checking all memory accesses, and rewards design-time errors with run-time crashes. We investigate an alternative approach, referred to as scoped types, that simplifies the task of managing memory in real-time codes. The key feature of our proposal is that the run-time partition of memory imposed by scoped areas is straightforwardly mirrored in the program text. Thus cursory inspection of a program reveals which objects inhabit the different scopes, significantly simplifying the task of understanding real-time Java programs. Moreover, we introduce a type system which ensures that no run-time errors\u00a0\u2026", "num_citations": "84\n", "authors": ["2221"]}
{"title": "How do Java programs use inheritance? An empirical study of inheritance in Java software\n", "abstract": " Inheritance is a crucial part of object-oriented programming, but its use in practice, and the resulting large-scale inheritance structures in programs, remain poorly understood. Previous studies of inheritance have been relatively small and have generally not considered issues such as Java\u2019s distinction between classes and interfaces, nor have they considered the use of external libraries.               In this paper we present the first substantial empirical study of the large-scale use of inheritance in a contemporary OO programming language. We present a suite of structured metrics for quantifying inheritance in Java programs. We present the results of performing a corpus analysis using those metrics to over 90 applications consisting of over 100,000 separate classes and interfaces. Our analysis finds higher use of inheritance than anticipated, variation in the use of inheritance between interfaces and classes\u00a0\u2026", "num_citations": "82\n", "authors": ["2221"]}
{"title": "A taxonomy of user-interface metaphors\n", "abstract": " Although metaphor is a commonly used device in the design of user-interfaces, it is not rigorously understood, and most guidance stops at the recommendation of its use. In this paper we seek to provide a systematic taxonomy of user-interface metaphors, based on and extending the framework of Lakoff and Johnson. We then suggest that some usability heuristics emerge directly from analysis of the taxonomy. We conclude that the taxonomy and heuristics may provide appreciable benefits in user-interface design and evaluation, and address some of the criticisms of metaphor use that have been made.", "num_citations": "79\n", "authors": ["2221"]}
{"title": "Persuasive interaction for collectivist cultures\n", "abstract": " Persuasive technology is defined as \u201cany interactive product designed to change attitudes or behaviours by making desired outcomes easier to achieve\u201d. It can take the form of interactive web applications, hand held devices, and games. To date there has been limited research into persuasive technology outside of America. Cross-cultural research shows that in order for persuasion to be most effective, it is often necessary to draw upon important cultural themes of the target audience. Applying this insight to persuasive technology, we claim that the set of persuasive technology strategies as described by BJ Fogg caters to a largely individualist audience. Drawing upon crosscultural psychology and sociology findings about patterns of behaviour commonly seen in collectivists, we present a principled set of collectivism-focused persuasive technology strategies. These strategies are: group opinion, group surveillance, deviation monitoring, disapproval conditioning, and group customisation. We also demonstrate how application of the strategies can support the design of a collectivist, persuasive game.", "num_citations": "78\n", "authors": ["2221"]}
{"title": "Up-front interaction design in agile development\n", "abstract": " In this paper we address how interaction design and agile development work together, with a focus on the issue of interaction design being done \u201cup-front\u201d, before software development begins. Our study method used interviews with interaction designers and software developers on several agile teams. We used the qualitative approach of grounded theory to code and interpret the results. Our interpretation includes appreciation for benefits seen for a certain amount of up-front interaction design, and benefits from some levels of interaction design continuing with the iterations of software development.", "num_citations": "77\n", "authors": ["2221"]}
{"title": "Efficient object querying for Java\n", "abstract": " Modern programming languages have little or no support for querying objects and collections. Programmers are forced to hand code such queries using nested loops, which is both cumbersome and inefficient. We demonstrate that first-class queries over objects and collections improve program readability, provide good performance and are applicable to a large number of common programming problems. We have developed a prototype extension to Java which tracks all objects in a program using AspectJ and allows first-class queries over them in the program. Our experimental findings indicate that such queries can be significantly faster than common programming idioms and within reach of hand optimised queries.", "num_citations": "76\n", "authors": ["2221"]}
{"title": "Basic relationship patterns\n", "abstract": " Relationships between objects are almost as important to designs as objects themselves. Most programming languages do not support relationships well, so programmers must implement relationships in terms of more primitive constructs. This paper presents five basic patterns which describe how objects can be used to model relationships within programs. By using these patterns, programs and designs can be made smaller, more flexible, and easier to understand and maintain.", "num_citations": "75\n", "authors": ["2221"]}
{"title": "Essential Use Cases and Responsibility in Object-Oriented Development.\n", "abstract": " 2.2 Essential Use Cases\u00a2\u00a1\u00a3\u00a1\u00a3\u00a4\u00a6\u00a5 \u00a7 \u00a9(\u00a1\u00a3\u00a4 w\u00a6\u00a1\u00a3\u00a4\u00a6\u00a1'#\u00a4 q S ('#\u00a3 \u00a7 9'CG gv\u00a1'35\u00a4! A7h\"\u00a4\u00a6\u00a5 \u00a7 \u00a4!#\u00a4 F\u00a9\u00a4\u00a6\u00a1\u00a3\u00a9 23\u00a5 g1 (\u00a1 F\u00a4\u00a6 X8\u00a4\u00a6 29 ST\u00a4 F &@ j $#\u00a3#\u00a3@ h\" 9\u00a5(\u00a1) \u00a7 0\u00a5 \u00a7 \u00a9 2\u00a5(\u00a4 i\u00a5 Fz j!@ j9 H 6\" 99F y {$| tf h\" 9\u00a5(\u00a1) \u00a7 0'\u00a5 c \u00a7 \u00a9 2\u00a5\u00a4\u00a5 FR j9 H 6\" 99F\u00a1\u00a3(S ST9#\u00a3 \u00a7 (\u00a1\u00a3\u00a4 u\u00a6\u00a1\u00a3\u00a4\u00a6\u00a1\u00a6 1Y'\u00a5 F 3'#\u00a4\u00a6\u00a4 6\u00a9 U \u00a7 4 Qx'\u00a5@\u00a6\u00a9 2Qb\u00a1 x &T9 \u00a7 x \u00a7 4 (\u00a4\u00a6\u00a9 U# FX\u00a5 \u00a7 0 3\u00a4\u00a6\u00a1\u00a6 fR 4 (\u00a4!@ d'\u00a1\u00a3 9u\u00a1\u00a3\u00a4\u00a6\u00a4 2\u00a9 2Qb\u00a9 U \u00a7 0'\u00a7 \u00a9 295\u00a5\u00a1\u00a6 x\u00a3 7 V\u00a5 S $#\u00a3 \u00a7 \u00a9!('# 1d\u00a6 9\u00a5 cX8\u00a4\u00a6\u00a5 \u00a7 \u00a9 295\u00a5'\u00a1\u00a3\u00a4'\u00a1\u00a3\u00a4\u00a6\u00a1% \u00a7 V@ BS (\u00a9 2 2 U@! 95\u00a5 \u00a7 0\u00a9 2\u00a5 \u00a7 99h Qx'\u00a5@ b & (\u00a9 U \u00a7 \u00a3 At\u00a9 2\u00a5'\u00a1\u00a3\u00a1\u00a3(QbS \u00a7 \u00a9 29\u00a5(\u00a1\u00a6 1B 9 CE \u00a7 \u00a4\u00a6\u00a5 4 (\u00a9 FF\u00a4\u00a6\u00a5 9#\u00a9 2QhA S 2\u00a9!\u00a9 2 \u00a7 1 &T9 \u00a7\u00a7 4 (\u00a4 w CW9# Q 9 CG \u00a7 4\u00a4 q (\u00a1\u00a3\u00a4!#\u00a9 2\u00a5 \u00a7 \u00a4!#\u00a3 C'\u00a6\u00a4 w \u00a7 4$ \u00a7 \u00a9\u00a1@\u00a4! \u00a7\u00a7 9p &T\u00a4 F\u00a4\u00a6\u00a1\u00a3\u00a9 235\u00a5\u00a4 Ff 4 (\u00a9 2\u00a1\u00a2\u00a9\u00a1\u00a2 SB# 95& (2\u00a4\u00a6 Qx $ \u00a7 \u00a9 2\" Ce9'#\" g% F\u00a4!\u00a1\u00a3\u00a9 3\u00a5 p &T9'\u00a7 4h &T\u00a4\u00a6'(\u00a1\u00a3\u00a4\u00a9 U \u00a7 CW9#\u00a6\u00a4!\u00a1 F\u00a4!\u00a1\u00a3\u00a9 3\u00a5 F\u00a4\u00a6!\u00a9\u00a1\u00a3\u00a9 29\u00a5(\u00a1\u00a7 9v &T\u00a4 Qx F\u00a4 X5\u00a4!#\u00a3@ p\u00a4\u00a6'# U@ 1c\u00a5 F &T\u00a4\u00a6'(\u00a1\u00a3\u00a4\u00a9 U \u00a7\u00a7 4\u00a4\u00a6\u00a5\u00a4\u00a6 Q &T\u00a4 F\u00a1 \u00a7 4\u00a4\u00a6\u00a1\u00a3\u00a4 F\u00a4\u00a6!\u00a9\u00a1\u00a3\u00a9 29\u00a5(\u00a1 v\u00a9 2\u00a5\u00a1\u00a3 ST\u00a4!\u00a6\u00a9 U $ \u00a7 \u00a9 9\u00a5(\u00a1\u00a6 1T Qx'c\u00a9\u00a5 3p \u00a7 4 (\u00a4! Q F\u00a9 U b\u00a6(U \u00a7\u00a7 9h Qb9F\u00a9 2CE@ 9#% FS \u00a7 $ \u00a7 % p'\u00a7 \u00a4!# \u00a7 \u00a9 2Qb\u00a4 5f\u00a2\u00a1\u00a3\u00a1\u00a3\u00a4\u00a6\u00a5 \u00a7 \u00a9 T\u00a1\u00a3\u00a4\u00a6\u00a1\u00a3\u00a4\u00a6\u00a1\" 6\"\u00a4!#\u00a4 F\u00a4\u00a6\u00a1\u00a3\u00a9 235\u00a5\u00a4 F \u00a7 9q 9$ X8\u00a4!#\u00a6 9 Qb\u00a4 \u00a7 4\u00a4\u00a6\u00a1\u00a3\u00a4 S# 9 & A 2\u00a4\u00a6 Qb\u00a1\u00a6 f 4 (\u00a4 b \u00a7 \u00a4!# Q\u00a3 V\u00a4\u00a6\u00a1\u00a3\u00a1\u00a3\u00a4\u00a6\u00a5 \u00a7 \u00a9#\u00a4! Ce\u00a4 H#\u00a1 \u00a7 9\u00a4\u00a6\u00a1\u00a3\u00a1\u00a3\u00a4!\u00a5 c \u00a7 \u00a9'Qb9F\u00a4\u00a6 2\u00a1 q \u00a7 4$ \u00a7 \u00a3 7'#\u00a4\u00a9 2\u00a5 \u00a7 \u00a4\u00a6\u00a5 F\u00a4 F \u00a7 9f SB \u00a7 #\u00a4 x \u00a7 4 (\u00a4\u00a4\u00a6\u00a1\u00a3\u00a1\u00a3\u00a4\u00a6\u00a5\u00a6\u00a4 9'Cv SB# 95& (2\u00a4\u00a6 Qb\u00a1 P \u00a7 4# 9 (354 \u00a7 \u00a4! H4\u00a5(95 29 3@ cADCW#\u00a4\u00a6\u00a4 51 (\u00a9 F\u00a4'\u00a9 2\u00a6\u00a4 F1T'\u00a5 F'& (\u00a1) \u00a7 \u00a3# 0'! \u00a7 F\u00a4\u00a6\u00a1\u00a3!#\u00a9 2SB \u00a7 \u00a9 9\u00a5(\u00a1 f h\" 9\u00a5 A\u00a1) \u00a7 0'\u00a5 \u00a7 \u00a9\u00a5\u00a4\u00a5 Fu j9 0 c6\" 99F F\u00a4!(\u00a5(\u00a4 x\u00a5\u00a4!\u00a1\u00a3\u00a1\u00a3\u00a4\u00a6\u00a5 \u00a7 \u00a9 E'(\u00a1\u00a3\u00a4 b\u00a6\u00a1\u00a3\u00a4 i\u00a1 Y Ce95 UA 296\u00a1\u00a6 s pHm m! pHs (tx n5} cm\u00a6 pnm! pi xem ni mt u0! t Bu\u00a3 p\u00a3 vsn uHu) ntxp pu\u00a3 pHm0m! p\u00a3 vi xes t pi} 2n sco n\u00f6p\"! $# ht (pi n% & T} xD nt x'!'sv (! 5q) n'xesf n sTv\"! $# wcm! pHuHm0 0!) u0xem\u00a0\u2026", "num_citations": "71\n", "authors": ["2221"]}
{"title": "The ins and outs of objects\n", "abstract": " Aggregation and containment are important concepts in object-oriented modeling. In component-based approaches to software development, aggregation and containment are touted as one of the primary mechanisms for component reuse. Containment relationships are typically implemented with object references in most object-oriented programming languages. This encourages the sharing of component objects between aggregates, but does not yield faithful representations of the containment relationships. We investigate structural relationships which are inherent in object graphs defined by inter-object references. For an arbitrary object graph, we construct an ownership tree determined by separability properties within the object graph. This tree provides a simple, yet clear definition of the interior and exterior for individual objects, capturing an appropriate notion of object containment. To be useful in dynamic systems, such structural properties need to be invariant across the behaviour of the system. We discuss connections between such structural invariants for object graphs with our related work on flexible aliasing protection.", "num_citations": "69\n", "authors": ["2221"]}
{"title": "Fine tuning the persuasion in persuasive games\n", "abstract": " Persuasive games are a relatively new phenomenon, and hold promise as effective vehicles for persuasion. As yet, however, there are few set rules guiding how to design persuasive games to be interesting, compelling, and effective. Furthermore, little theory exists that guides their development from a persuasive technology (PT) perspective. The results of a recent pilot test on Smoke?, our persuasive game about smoking cessation, highlighted several design issues related to persuasive games in general. In this paper we discuss some of those issues, contextualizing them in terms of B J Fogg\u2019s PT strategies, in order to both explain underlying forces, and point towards potential design solutions. The five issues we discuss are: managing player attention, balancing \u201creplayability\u201d with reality, player control vs. system control, identity issues, and target audience.", "num_citations": "68\n", "authors": ["2221"]}
{"title": "Saving the world from bad beans: Deployment-time confinement checking\n", "abstract": " The Enterprise JavaBeans (EJB) framework requires developers to preserve architectural integrity constraints when writing EJB components. Breaking these constraints allows components to violate the transaction protocol, bypass security mechanisms, disable object persistence, and be susceptible to malicious attacks from other EJBs. We present an object confinement discipline that allows static verification of components' integrity as they are deployed into an EJB server. The confinement rules are simple for developers to understand, require no annotation to the code of EJB components, and can be efficiently enforced in existing EJB servers.", "num_citations": "66\n", "authors": ["2221"]}
{"title": "UpgradeJ: Incremental typechecking for class upgrades\n", "abstract": " One of the problems facing developers is the constant evolution of components that are used to build applications. This evolution is typical of any multi-person or multi-site software project. How can we program in this environment? More precisely, how can language design address such evolution? In this paper we attack two significant issues that arise from constant component evolution: we propose language-level extensions that permit multiple, co-existing versions of classes and the ability to dynamically upgrade from one version of a class to another, whilst still maintaining type safety guarantees and requiring only lightweight extensions to the runtime infrastructure. We show how our extensions, whilst intuitive, provide a great deal of power by giving a number of examples. Given the subtlety of the problem, we formalize a core fragment of our language and prove a number of important safety properties.", "num_citations": "61\n", "authors": ["2221"]}
{"title": "Effective communication in distributed Agile software development teams\n", "abstract": " Agile methods prefer team members to be collocated to promote effective communication between team members. Effective communication is crucial for distributed Agile software development where team members are scattered across different geographic locations, and often across several time zones. We are conducting in a Grounded Theory study that explores distributed Agile software development from the perspective of Agile practitioners. We present the causes of communication challenges, and the strategies adopted by our participants to overcome communication challenges in distributed Agile teams.", "num_citations": "60\n", "authors": ["2221"]}
{"title": "Multiple dispatch in practice\n", "abstract": " Multiple dispatch uses the run time types of more than one argument to a method call to determine which method body to run. While several languages over the last 20 years have provided multiple dispatch, most object-oriented languages still support only single dispatch forcing programmers to implement multiple dispatch manually when required. This paper presents an empirical study of the use of multiple dispatch in practice, considering six languages that support multiple dispatch, and also investigating the potential for multiple dispatch in Java programs. We hope that this study will help programmers understand the uses and abuses of multiple dispatch; virtual machine implementors optimise multiple dispatch; and language designers to evaluate the choice of providing multiple dispatch in new programming languages.", "num_citations": "60\n", "authors": ["2221"]}
{"title": "Combining tiled and textual views of code\n", "abstract": " Jigsaw puzzle programming environments manipulate programs primarily by drag-and-drop. Generally these environments are based on their own special-purpose languages, meaning students must move on to another language as their programs grow. Tiled Grace is a tile-based editor for Grace, an educational programming language with a conventional textual syntax. Using Tiled Grace, programmers can move seamlessly between visualising their programs as tiles or source code, editing their programs via tiles or text, and continue on to traditional textual environments, all within the same programming language. We conducted a user experiment with Tiled Grace, and present the results of that experiment showing that users find dual views helpful.", "num_citations": "59\n", "authors": ["2221"]}
{"title": "Grace: the absence of (inessential) difficulty\n", "abstract": " We are engaged in the design of a small, simple programming language for teaching novices object-oriented programming. This turns out to be far from a small, simple task. We focus on three of the problems that we encountered, and how we believe we have solved them. The problems are (1) gracefully combining object initialization, inheritance, and immutable objects,(2) reconciling apparently irreconcilable views on type-checking, and (3) providing a family of languages, each suitable for students at different levels of mastery, while ensuring conceptual integrity of their designs. In each case our solutions are based on existing research; our contribution is, by design, consolidation rather than innovation.", "num_citations": "59\n", "authors": ["2221"]}
{"title": "Understanding team dynamics in distributed agile software development\n", "abstract": " Team dynamics are patterns of interaction among team members that determine the performance of the team. Success of Agile software development depends on team interaction. Team interactions are, however, affected in distributed teams. Through a Grounded Theory study that involved 40 Agile practitioners from 24 different software companies in the USA, India, and Australia, we investigate the key concerns of distributed Agile teams. We found Agile teams depend significantly on team interaction, and adopt six strategies that promote effective team interaction in distributed software development.", "num_citations": "59\n", "authors": ["2221"]}
{"title": "Caching and incrementalisation in the java query language\n", "abstract": " Many contemporary object-oriented programming languages support first-class queries or comprehensions. These language extensions make it easier for programmers to write queries, but are generally implemented no more efficiently than the code using collections, iterators, and loops that they replace. Crucially, whenever a query is re-executed, it is recomputed from scratch. We describe a general approach to optimising queries over mutable objects: query results are cached, and those caches are incrementally maintained whenever the collections and objects underlying those queries are updated. We hope that the performance benefits of our optimisations may encourage more general adoption of first-class queries by object-oriented programmers.", "num_citations": "56\n", "authors": ["2221"]}
{"title": "The semiotics of user interface redesign\n", "abstract": " User interface design is still more of an art than a science. Interface design and redesign is mostly based on empirical studies or prototypes but there is still surprisingly little theoretical or engineering understanding of how to go about the design process and produce good designs the first time around. We present a semiotic analysis that explains features of some user interface redesigns taken from the literature and propose that our semiotic analysis can help designers explain the changes they make to potentially help them produce user interfaces that will require less redesign.", "num_citations": "55\n", "authors": ["2221"]}
{"title": "Icons R icons\n", "abstract": " Icons are used in almost every graphical user-interface to computer software. Despite this, there is a serious lack of comprehension of what they are and how they work. The application of semiotics to user-interface icons can help to solve this problem by providing a framework for understanding icons in. This paper suggests such a semiotic approach and then applies it to real-world icons to show its effectiveness. Some hypothetical guidelines are derived from the application and a strong analytic technique results.", "num_citations": "55\n", "authors": ["2221"]}
{"title": "Supporting reusable use cases\n", "abstract": " Use cases are a part of common practice for capturing functional requirements for object-oriented software development. But, as with any artifact, there is a cost of producing them. Reusing use cases can reduce this cost. We discuss how use cases can be made reusable, in particular looking at the reusability of essential use cases. We also introduce Ukase, a web-based use case management tool that provides support for the reuse of use cases.", "num_citations": "55\n", "authors": ["2221"]}
{"title": "XP customer practices: A grounded theory\n", "abstract": " The customer is a critical role in XP, but almost all XP practices are presented for developers by developers. While XP calls for real customer involvement, it does not explain what XP customers should do, nor how they should do it. Using grounded theory, we discovered eight customer practices used by successful XP teams: customer boot camp, customerpsilas apprentice, customer pairing, and programmerpsilas holiday support the well-being and effectiveness of customers; programmer on-site and road shows support team and organization interactions; and big picture up front and re-calibration support customers steering the whole project. By adopting these processes, XP customers and teams can work faster and more sustainably.", "num_citations": "53\n", "authors": ["2221"]}
{"title": "A semiotic model of user-interface metaphor\n", "abstract": " User-interface metaphor is an extremely popular technique for creating usable user-interfaces. Although there has been considerable research into its application in practical settings, there has been little investigation into the concept itself. This paper applies Peircean semiotics to user-interface metaphor in order to provide a structured model of the concept. As an end result, a far more detailed understanding of the technique and a useful vocabulary are made available to user-interface designers and researchers.", "num_citations": "53\n", "authors": ["2221"]}
{"title": "How much up-front? A grounded theory of agile architecture\n", "abstract": " The tension between software architecture and agility is not well understood by agile practitioners or researchers. If an agile software team spends too little time designing architecture up-front then the team faces increased risk and higher chance of failure, if the team spends too much time the delivery of value to the customer is delayed, and responding to change can become extremely difficult. This paper presents a grounded theory of agile architecture that describes how agile software teams answer the question of how much upfront architecture design effort is enough. This theory, based on grounded theory research involving 44 participants, presents six forces that affect the team's context and five strategies that teams use to help them determine how much effort they should put into up-front design.", "num_citations": "52\n", "authors": ["2221"]}
{"title": "Notes on notes on postmodern programming\n", "abstract": " These notes have the status of letters written to ourselves: we wrote them down because, without doing so, we found ourselves making up new arguments over and over again. So began the abstract of our earlier paper Notes on Postmodern Programming. We now revisit the issue of postmodern programming, and attempt to address some of the questions raised by our exposition. To illustrate the nature of postmodernism we do not do this directly, but instead present a series of snapshots, parodies, and imagined conversations that we hope will help. What do you think of the abstract so far? Self-reference and a irreverent approach are part of this topic, so it's important to chill out and let things flow. We claim that computer science and software design grew up amid the unquestioned landscape of modernism, and that too often we cling to the otherwise ungrounded values, even as modernism itself is ever more\u00a0\u2026", "num_citations": "52\n", "authors": ["2221"]}
{"title": "Checking ownership and confinement\n", "abstract": " A number of proposals to manage aliasing in Java\u2010like programming languages have been advanced over the last five years. It is not clear how practical these proposals are, that is, how well they relate to the kinds of programs currently written in Java\u2010like languages. To address this problem, we analysed heap snapshots from a corpus of Java programs. Our results indicate that object\u2010oriented programs do in fact exhibit symptoms of encapsulation in practice, and that proposed models of uniqueness, ownership, and confinement can usefully describe the aliasing structures of object\u2010oriented programs. Understanding the kinds of aliasing present in programs should help us to design formalisms to make explicit the kinds of aliasing implicit in object\u2010oriented programs. Copyright \u00a9 2004 John Wiley & Sons, Ltd.", "num_citations": "50\n", "authors": ["2221"]}
{"title": "Aspects of synchronisation\n", "abstract": " Aspect oriented programming promotes the separation of the different aspects of a system into their natural form. Synchronisation is an important aspect of concurrent object-oriented systems, but treating synchronisation as a single monolithic aspect leads to inflexibility and limited possibilities for reuse. We suggest that synchronisation has a number of different aspects, and introduce the synchronisation rings model which allows the aspects of a synchronised object to be specified independently. By separating the different aspects of synchronisation we can provide flexible, generic implementations of common synchronisation constraints, which can be re-used in many different contexts.", "num_citations": "50\n", "authors": ["2221"]}
{"title": "The XP customer team: A grounded theory\n", "abstract": " The initial definition of XP resulted in many people interpreting the on-site customer to be a single person. We have conducted extensive qualitative research studying XP teams, and one of our research questions was ldquowho is the customerrdquo? We found that, rather than a single person, a customer team always exists. In this paper we outline the different roles that were typically on the team, which range from the recognized ldquoAcceptance Testerrdquo role to the less recognized roles of ldquoPolitical Advisorrdquo and ldquoSuper-Secretaryrdquo.", "num_citations": "49\n", "authors": ["2221"]}
{"title": "Factoring culture into the design of a persuasive game\n", "abstract": " Preliminary studies indicate that games can be effective vehicles for persuasion. In order to have a better chance at persuading target audiences, however, we claim that it is best to design with the background culture of the intended audience in mind. In this paper, we share our insights into the differences of perception between New Zealand (NZ) Europeans and Maori (the indigenous people of NZ), regarding smoking, smoking cessation, and social marketing. Based on our findings, we discuss how we have designed two different versions of culturallyrelevant persuasive game about smoking cessation, one aimed at a NZ European audience, the other aimed at a Maori audience.", "num_citations": "49\n", "authors": ["2221"]}
{"title": "Sourcevis: Collaborative software visualization for co-located environments\n", "abstract": " Most software development tools and applications are designed from a single-user perspective and are bound to the desktop and Integrated Development Environments (IDEs). These tools and applications make it hard for developers to analyse and interact with software artifacts collaboratively. We present SourceVisa multi-user collaborative software visualization application for use on large multi-touch tables. We describe the design and visualization features of SourceVis, present findings from a user study, and discuss the implications for building collaborative software visualization applications.", "num_citations": "47\n", "authors": ["2221"]}
{"title": "Seeking Grace: a new object-oriented language for novices\n", "abstract": " Grace is a new object-oriented language that supports a variety of approaches to teaching programming. It integrates accepted new ideas in programming languages into a simple language that allows students and teachers to focus on the essential complexities of programming rather than the accidental complexities of the language. We motivate Grace, review its design, and evaluate it against Kolling's criteria.", "num_citations": "45\n", "authors": ["2221"]}
{"title": "JavaCOP: Declarative pluggable types for Java\n", "abstract": " Pluggable types enable users to enforce multiple type systems in one programming language. We have developed a suite of tools, called the JavaCOP framework, that allows developers to create pluggable type systems for Java. JavaCOP provides a simple declarative language in which program constraints are defined over a program's abstract syntax tree. The JavaCOP compiler automatically enforces these constraints on programs during compilation. The JavaCOP framework also includes a dataflow analysis API in order to support type systems which depend on flow-sensitive information. Finally, JavaCOP includes a novel test framework which helps users gain confidence in the correctness of their pluggable type systems. We demonstrate the framework by discussing a number of pluggable type systems which have been implemented in JavaCOP in order to detect errors and enforce strong invariants in\u00a0\u2026", "num_citations": "45\n", "authors": ["2221"]}
{"title": "Game design strategies for collectivist persuasion\n", "abstract": " A fundamental feature of serious games is persuasion, an attempt to influence behaviors, feelings, or thoughts. Much of the existing research on serious games and, more generally, on persuasive technology (PT), does not address the important links between persuasion and culture. It has tended to originate from Western, individualist cultures, and has focused on how to design for these audiences. In this paper, we describe the design of one of two versions of a serious game we developed about quitting smoking titled Smoke? which is targeted at collectivist players. We show how the design was informed by persuasive strategies we identified from the cross-cultural psychology literature, intended for use in games for players of collectivist cultures: HARMONY, GROUP OPINION, MONITORING, DISESTABLISHING, and TEAM PERFORMANCE. We then discuss the results of a quantitative investigation of the effects\u00a0\u2026", "num_citations": "45\n", "authors": ["2221"]}
{"title": "Scalable visualizations of object-oriented systems with ownership trees\n", "abstract": " Executing object-oriented programs have a complex structure consisting of numerous objects connected by interobject references. This structure, called the program's object graph, is hard to understand, and this complicates learning, teaching, debugging and maintaining object-oriented programs. While visualization can be used to display object graphs, the size and complexity of typical object graphs also makes visualization difficult. We have developed ownership trees as a simple yet powerful method of extracting a program's implicit encapsulation structure from its object graph. We have developed a program visualization tool that makes use of ownership trees to display the structure of object-oriented programs. Because ownership trees are independent of scale\u2014the relationship between a whole object-oriented system and its top-level components is the same as the relationship between a low-level data\u00a0\u2026", "num_citations": "45\n", "authors": ["2221"]}
{"title": "Patterns as signs\n", "abstract": " Object-oriented design patterns have been one of the most important and successful ideas in software design over the last ten years, and have been well adopted both in industry and academia. A number of open research problems remain regarding patterns, however, including the differences between patterns, variant forms of common patterns, the naming of patterns, the organisation of collections of patterns, and the relationships between patterns. We provide a semiotic account of design patterns, treating a pattern as a sign comprised of the programmers\u2019 intent and its realisation in the program. Considering patterns as signs can address many of these common questions regarding design patterns, to assist both programmers using patterns and authors writing them.", "num_citations": "44\n", "authors": ["2221"]}
{"title": "Less extreme programming\n", "abstract": " Industrial practice in software engineering has developed in recent years from rigid heavyweight document-based development techniques, such as the Rational Unified Process, to incorporate more agile, iterative, communication-centric approaches such as Extreme Programming. This shift has created a need for a similar shift in software engineering education. We report our experience of incorporating an Extreme Programming option into an existing document-centric software project course. While students taking the option were generally positive about Extreme Programming, the projects\u2019 external clients had a more mixed experience.", "num_citations": "43\n", "authors": ["2221"]}
{"title": "Collaboration and learning through live coding (Dagstuhl Seminar 13382)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 13382\" Collaboration and learning through live coding\". Live coding is improvised interactive programming, typically to create electronic music and other digital media, done live with an audience. Our seminar was motivated by the phenomenon and experience of live coding. Our conviction was that those represent an important and broad, but seldom articulated, set of opportunities for computer science and the arts and humanities. The seminar participants included a broad range of scholars, researchers, and practitioners spanning fields from music theory to software engineering. We held live coding performances, and facilitated discussions on three main perspectives, the humanities, computing education, and software engineering. The main outcome of our seminar was better understanding of the potential of live coding for informing cross-disciplinary scholarship and practice, connecting the arts, cultural studies, and computing.", "num_citations": "42\n", "authors": ["2221"]}
{"title": "Scoped types and aspects for real-time Java\n", "abstract": " Real-time systems are notoriously difficult to design and implement, and, as many real-time problems are safety-critical, their solutions must be reliable as well as efficient and correct. While higher-level programming models (such as the Real-Time Specification for Java) permit real-time programmers to use language features that most programmers take for granted (objects, type checking, dynamic dispatch, and memory safety) the compromises required for real-time execution, especially concerning memory allocation, can create as many problems as they solve. This paper presents Scoped Types and Aspects for Real-Time Systems (STARS) a novel programming model for real-time systems. Scoped Types give programmers a clear model of their programs\u2019 memory use, and, being statically checkable, prevent the run-time memory errors that bedevil models such as RTSJ. Our Aspects build on Scoped\u00a0\u2026", "num_citations": "42\n", "authors": ["2221"]}
{"title": "Snapshot query-based debugging\n", "abstract": " Object-oriented programs, when executed, produce a complex webs of objects and references between them, generally referred to as object graphs. These object graphs are difficult to design correctly and even more difficult to debug if incorrect. Unfortunately, very subtle bugs in object-oriented programs are directly caused by object graph topologies. Snapshot query-based debuggers let programmers examine object graph snapshots of programs in detail using a specially designed query language. This provides users with an ability to debug and examine their programs in great detail at the time when the memory snapshot is taken.", "num_citations": "42\n", "authors": ["2221"]}
{"title": "Supporting self-organizing agile teams\n", "abstract": " Self-organizing Agile teams need a supportive environment to emerge and flourish. Through a Grounded Theory study of 58 Agile practitioners across 23 different software organizations in New Zealand and India, we found that senior management support is a critical environmental factor influencing self-organizing Agile teams. We describe the influence of senior management, and show how their support can create and sustain a supportive environment for self-organizing Agile teams.", "num_citations": "40\n", "authors": ["2221"]}
{"title": "Abstraction and activity in computer-mediated music production\n", "abstract": " Digital audio workstations (DAWs) such as Digidesign Pro Tools, Apple Logic, and Ableton Live are the cornerstone of composition, recording, editing, and performing activities for producers working in popular music (Th\u00e9berge 1997). Human\u2013computer interaction (HCI) research has a unique challenge in understanding the activities of professional music producers and in designing DAW user interfaces to support this work. Unlike many other user-interface design domains, in computermediated music production the user is principally engaged in the process of building and editing immensely complex digital representations (Lerdahl and Jackendoff 1983; Pope 1986; Dannenberg, Rubine, and Neuendorffer 1991; Dannenberg 1993). In this case, those representations model the intricate structure and synthesis parameters of the musical composition the producer is creating. Determining the right vocabulary of\u00a0\u2026", "num_citations": "40\n", "authors": ["2221"]}
{"title": "Our place or mine? Exploration into collectivism-focused persuasive technology design\n", "abstract": " Persuasive technologies are increasingly ubiquitous, but the strategies they utilise largely originate in America. Consumer behaviour research shows us that certain persuasion strategies will be more effective on some cultures than others. We claim that the existing strategies will be less effective on non-American audiences than they are on American audiences, and we use information from interviews to show that there exists much scope to develop persuasive technologies from a collectivism-focused perspective. To illustrate the development of such a tool, we describe the design of a collectivism-focused financial planning tool.", "num_citations": "40\n", "authors": ["2221"]}
{"title": "When XP met outsourcing\n", "abstract": " Outsourcing is common for software development, and is the context for many projects using agile development processes. This paper presents two case studies concentrating on the customer role in projects using outsourcing and extreme programming (XP). The studies follow an interpretive approach based on in-depth interviews, and suggest some tensions between some contractual arrangements in outsourcing, and the XP process. In particular, one suggests XP worked well in the context of their particular outsourcing arrangements, and the other study suggests difficulty in aligning XP with a different set of outsourcing arrangements.", "num_citations": "40\n", "authors": ["2221"]}
{"title": "Understanding lack of trust in distributed agile teams: A grounded theory study\n", "abstract": " Background: Trust fuels team performance and contributes to build an effective and cohesive team. The self-organizing and collaborative nature of Agile teams increases the importance of trust in software development teams. Trust is, however, affected in distributed teams. Aim: To investigate the emergent key concerns, particularly the impact of trust, in distributed Agile teams. Method: Through a Grounded Theory study that explores distributed software development from the specific perspective of Agile practitioners, we interviewed 45 participants from 28 different software companies in the USA, India, and Australia. Results: In this paper, we present the reasons for lack of trust and its adverse effects in distributed Agile teams that emerged from our analysis, using the causal-consequences theoretical model. Conclusion: Understanding the causes and consequences of lack of trust can develop awareness of the\u00a0\u2026", "num_citations": "39\n", "authors": ["2221"]}
{"title": "Scoped types and aspects for real-time Java memory management\n", "abstract": " Real-time systems are notoriously difficult to design and implement, and, as many real-time problems are safety-critical, their solutions must be reliable as well as efficient and correct. While higher-level programming models (such as the Real-Time Specification for Java) permit real-time programmers to use language features that most programmers take for granted (objects, type checking, dynamic dispatch, and memory safety) the compromises required for real-time execution, especially concerning memory allocation, can create as many problems as they solve. This paper presents Scoped Types and Aspects for Real-Time Systems (STARS) a novel programming model for real-time systems. Scoped Types give programmers a\u00a0clear model of their programs\u2019 memory use, and, being statically checkable, prevent the run-time memory errors that bedevil the RTSJ. Adopting the integrated Scoped Types and\u00a0\u2026", "num_citations": "39\n", "authors": ["2221"]}
{"title": "A case for iconic icons\n", "abstract": " User interface designers still have to rely on personal creativity and skill when designing computer icons for program functions that have no existing conventional representation. Further, designers often stumble upon usable icons by trial and error. We designed an Icon Intuitiveness Test to gain better insight into how users interpret icons. Our hypothesis was that users would interpret icons they do not know the functionality of as iconic signs 1 by assuming that the icon looks like the functionality it represents. Our study suggests that participants do indeed base their guesses on the visual clues they can see and interpret the unknown icon as having the functionality they think it resembles.", "num_citations": "39\n", "authors": ["2221"]}
{"title": "Metaphor and metonymy in object-oriented design patterns\n", "abstract": " The key principle of object-oriented design is that each program object should correspond to an object in the real world, that is to say, a program is a metaphor for the world. More advanced object-oriented designs, such as many of Gamma et. al.'s Design Patterns, are not directly metaphorical: State objects, Strategy objects and Visitor objects, for example, do not correspond to objects in the real world. We show how these patterns, and other similar designs, can be understood as metonymy, rather than metaphor, that is, they are based on an attribute, cause, or effect, rather than being based on something in the world, in terms of Jakobson and Lodge's typology. Understanding how both metaphor and metonymy can be used in design can illustrate how design patterns work alongside more traditional object-oriented modelling to produce designs that are accurate, flexible, and better understood.", "num_citations": "39\n", "authors": ["2221"]}
{"title": "Object ownership for dynamic alias protection\n", "abstract": " Interobject references in object-oriented programs allow arbitrary aliases between objects. By breaching objects' encapsulation boundaries, these aliases can make programs hard to understand and especially hard to debug. We propose using an explicit, run-time notion of object ownership to control aliases between objects in dynamically typed languages. Dynamically checking object ownership as a program runs ensures the program maintains the encapsulation topology intended by the programmer.", "num_citations": "39\n", "authors": ["2221"]}
{"title": "GoHotDraw: Evaluating the Go programming language with design patterns\n", "abstract": " Go, a new programming language backed by Google, has the potential for widespread use: it deserves an evaluation. Design patterns are records of idiomatic programming practice and inform programmers about good program design. In this study, we evaluate Go by implementing design patterns, and porting the\" pattern-dense\" drawing framework HotDraw into Go, producing GoHotDraw. We show how Go's language features affect the implementation of Design Patterns, identify some potential Go programming patterns, and demonstrate how studying design patterns can contribute to the evaluation of a programming language.", "num_citations": "38\n", "authors": ["2221"]}
{"title": "Towards a model of encapsulation\n", "abstract": " Encapsulation is a founding principle of object-oriented programming: to this end, there have been a number of recent of proposals to increase programming languages\u2019 support for encapsulation. While many of these proposals are similar in concept, it is often difficult to describe their effects in practice, or to evaluate clearly how related proposals differ from each other. We are developing a general topological model of encapsulation for object-oriented languages, based on a program\u2019s object graph. Using this model, we can characterise a range of confinement, ownership, and alias protection schemes in terms of their underlying encapsulation function. This analysis should help programmers understand the encapsulation provided by programming languages, assist students to better compare and contrast the features of different languages, and help language designers to craft the encapsulation schemes of forthcoming programming languages.", "num_citations": "38\n", "authors": ["2221"]}
{"title": "Bridging cultural differences: A grounded theory perspective\n", "abstract": " Cultural differences often arise in distributed software development. The impact of cultural differences on distributed teams is under-explored. The lack of knowledge of cultural differences can cause major problems to the distributed teams. We have conducted a Grounded Theory study to uncover the strategies adopted by Agile practitioners to overcome the cultural differences in distributed software development. We interviewed 18 Agile practitioners across 10 software companies in the USA and India over a period of 1.5 years. In this paper, we report that our participants adopt five effective strategies to bridge cultural differences in distributed Agile software development: engendering cultural awareness, understanding cultural differences, sharing work practices, rotating team ambassadors, and managing language barriers.", "num_citations": "37\n", "authors": ["2221"]}
{"title": "Being Jane Malkovich: A look into the world of an XP customer\n", "abstract": " One of the pivotal roles in XP is the customer, but little guidance is provided in the literature on the practicalities of succeeding in this role. We used an interpretative in-depth case study to explore a successful XP project. We obtained multiple perspectives on the implementation of the customer role, and this paper includes excerpts from interviews with the customer and other development team members. We found that the interviewees provided a consistent picture of the XP customer role and they agreed that the XP customer role, especially for larger organisations, is very demanding. It requires preparation, skills, attention to detail, and the ability to make critical decisions.", "num_citations": "36\n", "authors": ["2221"]}
{"title": "What programmers do with inheritance in Java\n", "abstract": " Inheritance is a distinguishing feature of object-oriented programming languages, but its application in practice remains poorly understood. Programmers employ inheritance for a number of different purposes: to provide subtyping, to reuse code, to allow subclasses to customise superclasses\u2019 behaviour, or just to categorise objects. We present an empirical study of 93 open-source Java software systems consisting over over 200,000 classes and interfaces, supplemented by longitudinal analyses of 43 versions of two systems. Our analysis finds inheritance is used for two main reasons: to support subtyping and to permit what we call external code reuse. This is the first empirical study to indicate what programmers do with inheritance.", "num_citations": "35\n", "authors": ["2221"]}
{"title": "User evaluation of polymetric views using a large visualization wall\n", "abstract": " There are few visualization techniques for displaying complex software systems with large numbers of packages and classes. One visualization technique is the System Hotspots View, whose effectiveness has yet to be validated by any empirical studies. We have conducted a user evaluation to see whether participants of our modified System Hotspots View using a large visualization wall can accurately identify key measurements and comparisons in the underlying software system. The results of our user evaluation indicate that participants were able to effectively use our modified System Hotspots View to explore the example domain: version 1.6 of the Java API. Our observations also indicate that there are issues around interacting with the visualization wall.", "num_citations": "35\n", "authors": ["2221"]}
{"title": "Iterators and encapsulation\n", "abstract": " Iterators are an important object oriented design pattern, providing sequential access to the state stored in other objects. Precisely because iterators need to access the state of other objects, iterators' design can be at odds with the encapsulation provided by object oriented languages. We present a range of designs for iterator objects, showing how different designs have different encapsulation properties. Studying a range of different iterators can help programmers to identify the strengths and weaknesses of particular designs, and also illustrates some of the issues in the design of encapsulation mechanisms in programming languages.", "num_citations": "35\n", "authors": ["2221"]}
{"title": "The billion-dollar fix\n", "abstract": " Programmers often need to initialise circular structures of objects. Initialisation should be safe (so that programs can never suffer null pointer exceptions or otherwise observe uninitialised values) and modular (so that each part of the circular structure can be written and compiled separately). Unfortunately, existing languages do not support modular circular initialisation: programmers in practical languages resort to Tony Hoare\u2019s \u201cBillion Dollar Mistake\u201d: initialising variables with nulls, and then hoping to fix them up afterward. While recent research languages have offered some solutions, none fully support safe modular circular initialisation.               We present placeholders, a straightforward extension to object-oriented languages that describes circular structures simply, directly, and modularly. In typed languages, placeholders can be described by placeholder types that ensure placeholders are used safely\u00a0\u2026", "num_citations": "34\n", "authors": ["2221"]}
{"title": "Investigating social software as persuasive technology\n", "abstract": " Social software (SSW), nowadays increasingly widespread, has excellent potential for use as persuasive technology. What differentiates it from many other persuasive technology platforms is that it is inherently collective, making group dynamics a powerful factor in any SSW context of persuasion. Based on the psychology of groups, persuasion, and cross-cultural theory, we discuss affiliation, access, and participation as themes that are important in understanding SSW\u2019s use as a persuasive technology platform.", "num_citations": "34\n", "authors": ["2221"]}
{"title": "Metaphors for Electronic Music Production in Reason and Live\n", "abstract": " Electronic music production was originally accomplished using a variety of electronic components and conventional analogue recording techniques. Both the electronic components and the recording equipment are now being replaced by computer software. In this paper we present a comparative study of two popular new systems, Reason and Live, concentrating on the role of user-interface metaphors. We compare the two systems, identify the key ways metaphor is used, and describe how it affects usability of the systems focusing on the role that user-interface metaphor play in their design.", "num_citations": "33\n", "authors": ["2221"]}
{"title": "A lightweight web-based case tool for UML class diagrams\n", "abstract": " Many existing UML tools are far too heavyweight for quickly producing a few simple models. These heavyweight UML tools usually contain large amounts of functionality, which can lead to usability problems and poor productivity. Lightweight web-based UML tools are designed to support quick and easy production of models. The use of the web has added benefits including portability and group collaboration. This report discusses lightweight groupware UML case tools and presents a lightweight web-based class diagram editor that requires no web browser extensions.", "num_citations": "33\n", "authors": ["2221"]}
{"title": "A lightweight web-based case tool for sequence diagrams\n", "abstract": " This paper presents a simple lightweight Case tool to support manipulation of UML sequence diagrams. The tool is intended to have high usability to facilitate communication and discussion in the early part of the design process, where sequence diagrams are frequently used to explore and explain object interaction. The tool is web-based to maximise accessibility and use by teams, and uses a simple yet effective image tiling technology to allow manipulation of the diagrams from any web browser.", "num_citations": "33\n", "authors": ["2221"]}
{"title": "A qualitative study of culture and persuasion in a smoking cessation game\n", "abstract": " To explore the issue of culture in persuasive technology, we identified strategies distinguishing individualist or collectivist audiences, and developed two versions of a prototype game. In this paper we report on a qualitative study of this game. The game concerned smoking cessation, and was set in a New Zealand context, where one version was designed for individualist New Zealand Europeans, and the other for collectivist New Zealand M\u0101ori. Our qualitative study involved people from each group playing each of the two games. Using a \u201cthink-aloud\u201d protocol, we recorded player comments and reflections that show the effect of our design on their behaviour. The results of the study show the designs were interpreted differently according to the audiences playing them, and reveal detail about culture and persuasion.", "num_citations": "32\n", "authors": ["2221"]}
{"title": "Dynamic ownership in a dynamic language\n", "abstract": " Object aliasing causes as many problems in dynamic languages as it does in static languages. Most existing work on aliasing, such as ownership types, relies on static checking based on annotations and type declarations. We introduce ConstraintedJava, a scripting language based on BeanShell that provides dynamic ownership checking. Dynamic ownership provides the encapsulation benefits of static ownership types but preserves the flexibility of dynamic languages.", "num_citations": "32\n", "authors": ["2221"]}
{"title": "Featherweight generic confinement\n", "abstract": " Existing approaches to object encapsulation either rely on ad hoc syntactic restrictions or require the use of specialised type systems. Syntactic restrictions are difficult to scale and to prove correct, while specialised type systems require extensive changes to programming languages. We demonstrate that confinement can be enforced cheaply in Featherweight Generic Java, with no essential change to the underlying language or type system. This result demonstrates that polymorphic type parameters can simultaneously act as ownership parameters and should facilitate the adoption of confinement and ownership type systems in general-purpose programming languages.", "num_citations": "32\n", "authors": ["2221"]}
{"title": "Towards a pattern language for object oriented design\n", "abstract": " Since the publication of the Design Patterns book (E. Gamma et al., 1994), a large number of design patterns have been identified and codified. Unfortunately, these patterns are mostly organised in an ad hoc fashion, making it hard for programmers to know which pattern to apply to any particular problem. We have organised a large number of existing object oriented design patterns into a pattern language, by analysing the patterns and the relationships between them. Organising patterns into languages has the potential to make large collections of patterns easier to understand and to use.", "num_citations": "32\n", "authors": ["2221"]}
{"title": "Aliasing in Object-oriented Programming: Types, Analysis and Verification\n", "abstract": " This book presents a survey of the state-of-the-art on techniques for dealing with aliasing in object-oriented programming. It marks the 20th anniversary of the paper The Geneva Convention On The Treatment of Object Aliasing by John Hogg, Doug Lea, Alan Wills, Dennis de Champeaux and Richard Holt. The 22 revised papers were carefully reviewed to ensure the highest quality. The contributions are organized in topical sections on the Geneva convention, ownership, concurrency, alias analysis, controlling effects, verification, programming languages, and visions.", "num_citations": "30\n", "authors": ["2221"]}
{"title": "Reflections on CRC cards and OO design\n", "abstract": " We recently had the opportunity to introduce object-oriented design to a number of teams, and used CRC cards as one of the key techniques. The team members had varied backgrounds, and we had the opportunity to observe many teams tackle the same design exercises. This allowed us the opportunity to observe the effectiveness of the CRC cards, and reflect on the strengths and weaknesses. This paper documents our observations and reflections, and presents our advice on the strengths of the technique, and strategies we found useful for addressing the weaknesses.", "num_citations": "30\n", "authors": ["2221"]}
{"title": "A taxonomy of sequencer user-interfaces\n", "abstract": " Sequencing tools play a central role in our ability to create computer music. Despite their importance, there has been little structured analysis of how the characteristics of sequencers impact our ability to use them effectively. This paper addresses this through a new taxonomy for classifying sequencing tools. This taxonomy can be used to help us better understand the strengths and weaknesses of current sequencer tools, and suggest novel possibilities for future sequencers.", "num_citations": "29\n", "authors": ["2221"]}
{"title": "A taxonomic analysis of user-interface metaphors in the Microsoft Office Project Gallery\n", "abstract": " User-interface metaphors are not well understood in terms of their relationships and qualities. They are, however, constantly used both consciously and unconsciously in most user-interface designs. This paper demonstrates a taxonomic classification and analysis of the user-interface metaphors in the Microsoft Office Project Gallery. The classification offers insight both into the nature of the metaphors in the user-interface investigated and more generally, and helps validate the use of the taxonomy as an assessment tool.", "num_citations": "29\n", "authors": ["2221"]}
{"title": "Activity theory for design from checklist to interview\n", "abstract": " Cultural historical activity theory has shown much promise as a framework for Human Computer Interaction, particularly for analysing complex activity and its context. However, it provides little practical methodological support tbr user intert~ace designers. This paper presents an activity interview resource which can be used by interface designers when developing new tools to support creative activity. The new activity interview is based on the excellent foundation of the activity checklist, but resolves a number of its deficiencies. In particular it provides concrete questions to fuel an activity theory analysis, rather than the more abstract and less accessible checklist. We describe how we have dealt with these problems, and reflect on our experience applying the activity interview in the domain of computer mediated music production.", "num_citations": "28\n", "authors": ["2221"]}
{"title": "Patterns as objects in Grace\n", "abstract": " Object orientation and pattern matching are often seen as conflicting approaches to program design. Object-oriented programs place type-dependent behavior inside objects and invoke it via dynamic dispatch, while pattern-matching programs place type-dependent behavior outside data structures and invoke it via multiway conditionals (case statements). Grace is a new, dynamic, object-oriented language designed to support teaching: to this end, Grace needs to support both styles. We explain how this conflict can be resolved gracefully: by modelling patterns and cases as partial functions, reifying those functions as objects, and then building up complex patterns from simpler ones using pattern combinators. We describe the implementation of this design as an object-oriented framework, and a case study of its effectiveness.", "num_citations": "27\n", "authors": ["2221"]}
{"title": "Implicit ownership types for memory management\n", "abstract": " The Real-time Specification for Java (RTSJ) introduced a range of language features for explicit memory management. While the RTSJ gives programmers fine control over memory use and allows linear allocation and constant-time deallocation, the RTSJ relies upon dynamic runtime checks for safety, making it unsuitable for safety critical applications. We introduce ScopeJ, a statically-typed, multi-threaded, object calculus in which scopes are first class constructs. Scopes reify allocation contexts and provide a safe alternative to automatic memory management. Safety follows from the use of an ownership type system that enforces a topology on run-time patterns of references. ScopeJ\u2019s type system is novel in that ownership annotations are implicit. This substantially reduces the burden for developers and increases the likelihood of adoption. The notion of implicit ownership is particularly appealing when combined\u00a0\u2026", "num_citations": "27\n", "authors": ["2221"]}
{"title": "Arguments and results\n", "abstract": " If an object-oriented program is a collection of communicating objects, then the objects' protocols define the languages the program speaks. Unfortunately, protocols are difficult to design in isolation, so many programs' protocols are not as well designed as they could be. This paper presents six patterns which describe how objects' protocols can be designed or redesigned, by considering the arguments the protocols accept and the results the protocols return. By using these patterns, programs and designs can be made simpler, more general, and easier to change.", "num_citations": "27\n", "authors": ["2221"]}
{"title": "Agile software development with distributed teams: Agility, distribution and trust\n", "abstract": " Trust among team members is imperative for blending agility with distributed software development. Little is known about how team members who are dispersed across different geographical locations, time zones and cultures can build trust while working together in Agile software development projects. Through a Grounded Theory study that involved 55 participants from 38 different software companies in the USA, India and Australia, we investigate the key concerns of distributed teams in Agile software development. We found that trust among members of a distributed team is important for bridging spatial, temporal and socio-cultural distances in order for them to work together as one team. In this paper, we present techniques for building trust in Agile software development with distributed teams.", "num_citations": "26\n", "authors": ["2221"]}
{"title": "Interaction designers on eXtreme Programming teams: Two case studies from the real world\n", "abstract": " The interaction designer role is not an acknowledged role on the core eXtreme Programming (XP) team and XP has no explicit process for dealing with interaction design. We interviewed interaction designers and other team members on two real-world XP teams and in this paper we report on how they combined interaction design activities with XP. Initial results show that having interaction designers on the team, resulted in a workflow that differed from the pure XP process in a significant way: up-front design for user interaction, as opposed to up-front code design, was considered necessary. The iterative nature of XP development required that the interaction designers have continual involvement with the development of the product, which inevitably influenced the nature of the relationship between the interaction designers and the developers.", "num_citations": "26\n", "authors": ["2221"]}
{"title": "Object oriented program visualisation in Tarraing\u00edm\n", "abstract": " Most program visualisation systems display either language level details of programs, or high level overviews of the program's algorithm. Producing high level views requires that the abstractions in the program to be visualised (the {\\it target program}) are described to the visualisation system-either by modifying the target program, or by providing the visualisation system with information about the details of the abstractions in the target program. Object Orientation can be used to organise the design of both ahe ta {get program and the architecture of an abstract program visualisation system. Such a system can produce flexible displays of the target program at multiple levels of abstraction, without any extra detailed information about the implementation of abstractions in the target program.", "num_citations": "26\n", "authors": ["2221"]}
{"title": "No name: Just notes on software reuse\n", "abstract": " In the beginning, so our myths and stories tell us, the programmer created the program from the eternal nothingness of the void. In this essay, we recognise that programs these days are like any other assemblage, and suggest that in fact programming has always been about reuse. We also explore the nature of reuse, and claim that Components themselves are not the most important consideration for reuse; it is the end product, the composition. The issues still involve value, investment, and return. But pervasive reuse promotes a change in the method of construction of the program, and in the program itself.", "num_citations": "25\n", "authors": ["2221"]}
{"title": "Visualizing the word structure of java class names\n", "abstract": " Large amounts of software have been written since the Java language was created. There is little known about the word structure Java within class names. We have created visualizations of words used in class names from the Java API specification and 91 open-source Java applications. Our visualizations will help expose which words are used in practice.", "num_citations": "24\n", "authors": ["2221"]}
{"title": "Patterns of Aspect-Oriented Design.\n", "abstract": " Aspect-oriented programming languages are becoming commonplace, and programmers are accumulating experience in building and maintaining aspect-oriented systems. This paper addresses how the use of these languages affects program design: how aspect-oriented languages change the design space, which designs should be emulated and which avoided, and the strengths and weaknesses of particular kinds of design. We identify five patterns of aspect-oriented design: Spectator, Regulator, Patch, Extension, and Heterarchical Design. For each pattern, we describe the problem it solves, show how aspect-oriented language features are used in the pattern, give characteristic examples of the pattern\u2019s use, and assess its benefits and liabilities. Our patterns provide the beginnings of a taxonomy of aspect-oriented design. We believe that they should help programmers to understand and evaluate existing aspect-oriented designs, to improve new designs, to make better use of the aspect-oriented features of new programming languages, and also guide those who wish to implement these patterns in non aspect-oriented languages.Dear Workshop: this paper already has an interesting history, and we plan to do more with it after the workshop. For EuroPLoP, we have expanded the patterns part of the paper, indeed, the first two patterns were one in the prior version. It still remains to significantly increase the depth of description and analysis in each pattern. We expect to remove much of the discussion material (into a different paper), but are including it here so you can have some idea where we\u2019re coming from. Authors\u25b6 We\u2019ve also included\u00a0\u2026", "num_citations": "24\n", "authors": ["2221"]}
{"title": "Agile software development with distributed teams: Senior management support\n", "abstract": " Agile teams advocates face-to-face conversation, frequent communication and close collaboration between team members in order to work together as one team. In distributed software development, however, separation through space, time and culture affects the ability of the members of a distributed team to work together as one team. Through a Grounded Theory study that involved 55 participants from 38 different software companies in the USA, India and Australia, we investigate key concerns of distributed teams in Agile software development. We found that distributed teams need significant support from senior management in terms of organisational culture, human resource management, financial sponsorship, infrastructure and technology, and customer liaison. In this paper, we discuss the importance of senior management support for Agile software development with distributed teams.", "num_citations": "23\n", "authors": ["2221"]}
{"title": "Diagnosis and management of the infraerupted primary molar\n", "abstract": " An infraerupted tooth is a tooth that has failed to erupt to be in line with adjacent teeth in the vertical plane of occlusion. The general dentist may be faced with this predicament which requires careful attention and thoughtful consideration in terms of long-term patient goals. It is important to diagnose infraerupted teeth and treat them in a timely fashion to help prevent unwelcome sequelae. Important interdisciplinary communication is vital between the dentist and the orthodontist to ensure that precious space and time are not lost. Here we present a review article of complications and considerations that must be taken into account when faced with a patient who has an infraerupted tooth.", "num_citations": "23\n", "authors": ["2221"]}
{"title": "Evaluating X3D for use in software visualization\n", "abstract": " There are many technologies that have varying capabilities that could be used to help understand software through visualizations. Determining which technology is best suited for the development and delivery of a particular type of software visualization can be a complex task. We have evaluated the Web3D Consortium's X3D specification--the open standard for web-based 3D graphics--against some taxonomies of the types of graphical representations for software visualization. Our evaluation shows that X3D can support the development and delivery of visualizations that people use to understand the structure and behaviour of software.", "num_citations": "23\n", "authors": ["2221"]}
{"title": "Spreadsheet visualisation to improve end-user understanding\n", "abstract": " Spreadsheets are an extremely common form of end-user programming that have many applications, from calculating student marks to accounting for global multinationals. Ways of studying the structure of a spreadsheet itself are normally constrained to the tools provided in the spreadsheet software. This paper explores new ways to visualise spreadsheets in a manner that is independent of the program they were created in, explains the technology involved, and presents examples of the visualisations that can be produced. The techniques involved in reading the spreadsheets also facilitate larger scale analysis of spreadsheets for performing corpus analysis.", "num_citations": "23\n", "authors": ["2221"]}
{"title": "Reflections on remote reflection\n", "abstract": " The Java programming language provides both reflection and remote method invocation: reflection allows a program to inspect itself and its runtime environment, remote method invocation allows methods to be invoked transparently across a network. Unfortunately, the standard Java implementations of reflection and remote method invocation are incompatible: programmers cannot reflect on a remote application. We describe how Java systems can be extended to support Remote Reflection transparently by extending the standard Java API. Remote reflection can support remote debuggers, performance monitors, programming environments, application component servers such as Enterprise JavaBeans, and any other Java system that can be distributed across a network.", "num_citations": "23\n", "authors": ["2221"]}
{"title": "Patterns for essential use cases\n", "abstract": " Essential use cases are an effective way to analyse the usability requirements for a system under development. Essential use cases are quite stylised\u2014writing good essen-tial use cases is somewhat of a secret art. This paper casts the basics of writing essential use cases into the pattern form. Readers of this paper will be able to write better essential use cases quickly, making it easier to specify usable systems.", "num_citations": "23\n", "authors": ["2221"]}
{"title": "Understanding the importance of trust in distributed Agile projects: A practical perspective\n", "abstract": " Agile methods rely on face-to-face communication but are being used in distributed projects. We have conducted grounded theory research with Agile practitioners to collate the strategies they use to overcome the challenges in distributed projects. In this paper, we argue that trust is one of the key factors in determining the success or failure of distributed Agile projects, and describe how trust can be generated and sustained by increasing effective communication and understanding cultural differences.", "num_citations": "22\n", "authors": ["2221"]}
{"title": "An ideal customer: a grounded theory of requirements elicitation, communication and acceptance on agile projects\n", "abstract": " This chapter explores the reality of the customer role \u2013 a critical, complex, and demanding role on agile teams. Despite initial difficulties, customers love agile development and would not do it any other way, but they also encountered many difficulties in their day-to-day work. In this chapter we describe the practices that have emerged to ensure the role works effectively and sustainably, and how the role has evolved from an individual to a team. We hope customers will find this chapter helpful in performing their role, and programmers will find it useful to understand the complexities of customer\u2019s role on the project.", "num_citations": "22\n", "authors": ["2221"]}
{"title": "Scalable visualisations with ownership trees\n", "abstract": " Ownership trees are a simple yet powerful method of extracting an object-oriented program's implicit aggregation structure from its object graph. The topology of a program's ownership tree is independent of scale object-oriented programs are constructed from objects, and the relationship between a whole system and its top-level components is the same as the relationship between a low-level data structure and the objects that implement it. Because of this independence, a software visualisation tool based on ownership trees is applicable at all levels of abstraction within a program's design. Visualising ownership trees can support learning and teaching about object-oriented programs, as well as debugging and maintaining them.", "num_citations": "22\n", "authors": ["2221"]}
{"title": "Agile practices in practice: towards a theory of agile adoption and process evolution\n", "abstract": " As teams and organisations make the difficult shift to agile ways of working, there has been relatively little investigation of how they adopt and use agile practices. To aid those teams looking to move to agile we should examine how others have done so and what practical value they found. We studied teams which adopted agile practices across a spectrum from taking on a whole methodology to a couple of practices at a time, and then committed to continuous assessment and improvement of their ways of working. Those teams favoured adapting agile-based, team-oriented practices suited to their particular needs over technical practices and defined methodologies.", "num_citations": "21\n", "authors": ["2221"]}
{"title": "Tribal ownership\n", "abstract": " Tribal Ownership unifies class nesting and object ownership. Tribal Ownership is based on Tribe, a language with nested classes and object families. In Tribal Ownership, a program's runtime object ownership structure is characterised by the lexical nesting structure of its classes. We build on a variant of Tribe to present a descriptive ownership system, using object nesting to describe heap partitions, but without imposing any restrictions on programming disciplines. We then demonstrate how a range of different prescriptive ownership policies can be supported on top of the descriptive Tribal Ownership mechanism; including a novel owners-as-local-dominators policy. We formalise our type system and prove soundness and several ownership invariants. The resulting system requires strikingly few annotations, and uses well-understood encapsulation techniques to create ownership systems that should be intuitive\u00a0\u2026", "num_citations": "21\n", "authors": ["2221"]}
{"title": "An empirical study of overriding in open source Java.\n", "abstract": " There is some debate about the worth of inheritance. It is often presented as being something everyone should be using, but we also have the Gang of Four exhorting us to \u201cFavor object composition over class inheritance\u201d, and articles for practitioners with titles like \u201cWhy extends is evil\u201d. An aspect of inheritance that seems to be particularly of concern is overriding, as its use causes difficult-to-see interactions between classes. In order to understand the cost of overriding we must first understand how it is actually being used, and whether its typical use is appropriate or not. In this paper we present a set of metrics to characterise implementation inheritance, particularly focusing on the use of overriding. We present the results of large empirical study on implementation inheritance investigating 100 open source Java applications. We find non-trivial use of overriding and identify two common, but unnecessary, forms of use.", "num_citations": "21\n", "authors": ["2221"]}
{"title": "A catalogue of bug patterns for exception handling in aspect-oriented programs\n", "abstract": " Aspects allow a developer to externally add new functionality to a program. This additional functionality may also throw new exceptions that will flow through the program execution until they are handled. Moreover, aspects can also be used to handle exceptions thrown by base code or even other aspects. Unfortunately, exceptions thrown by aspects---or exceptions that should be handled by them---may flow through the program execution in unexpected ways leading to failures such as uncaught exceptions or exceptions being caught by the wrong handlers. In a previous empirical study we investigated the causes of such failures in Aspect-Oriented programs. In this paper we present causes of such failures as a catalogue of bug patterns for exception handling in Aspect-Oriented programs.", "num_citations": "21\n", "authors": ["2221"]}
{"title": "XML database support for program trace visualisation\n", "abstract": " Program traces can be used to drive visualisations of reusable components, but such traces can be gigabytes in size, are very expensive to generate, and are hard to extract information from. We have developed a solution to this problem, an XML Data Storage Environment (XDSE) for storing XML based program traces in a native XML database. We use XQuery to extract information from the program traces and the results are then transformed into understandable visualisations.", "num_citations": "21\n", "authors": ["2221"]}
{"title": "From essential use cases to objects\n", "abstract": " One of the main motivations for essential use cases was the context of user interface design. We, however, have been exploring the application of essential use cases in general object-oriented system development. Our experience has been very positive, and we found advantages to essential use cases that assist in both analysis and in design. This paper outlines two techniques involving essential use cases: use of role-play in requirements analysis, and distribution of system requirements from essential use cases to objects.", "num_citations": "21\n", "authors": ["2221"]}
{"title": "Exclusion for composite objects\n", "abstract": " Designing concurrent object-oriented programs is hard. Correct programs must coordinate multiple threads accessing composite objects, using low-level mechanisms such as locks and read-write sets. Efficient programs must balance the complexity and overhead of the coordination mechanisms against the increased performance possible through concurrency. A method-level algebra of exclusion provides a succinct description of the conditions under which a thread must be excluded from a component of a composite object. Using the algebra, programmers can check whether their programs meet their exclusion requirements, can eliminate redundant exclusion controls, and can remove synchronisation overhead by reducing concurrency.", "num_citations": "21\n", "authors": ["2221"]}
{"title": "Graceful dialects\n", "abstract": " Programming languages are enormously diverse, both in their essential concepts and in their accidental aspects. This creates a problem when teaching programming. To let students experience the diversity of essential concepts, the students must also be exposed to an overwhelming variety of accidental and irrelevant detail: the accidental differences between the languages are likely to obscure the teaching point.               The dialect system of the Grace programming language allows instructors to tailor and vary the language to suit their courses, while staying within the same stylistic, syntactic and semantic framework, as well as permitting authors to define advanced internal domain-specific languages. The dialect system achieves this power though a combination of well-known language features: lexical nesting, lambda expressions, multi-part method names, optional typing, and pluggable checkers\u00a0\u2026", "num_citations": "20\n", "authors": ["2221"]}
{"title": "Industrial automation display arrangement and method\n", "abstract": " An industrial automation computer display presents cumulative or sequential messages to the user through an unobtrusive and discreet navigator and with audio-visual feedback. The messages related to fault-causing events are stored, and the last message is displayed in a space-saving manner in the navigator. A complete list of messages appears when the user requests it through a user-activated icon, allowing navigation to, and assessment of, the messages. After selection of an entry and initiation of a \u201cjump\u201d to the fault location, the list disappears and the discreet navigator is once again reduced to the original message indicator, which can also be made to disappear altogether until the next significant event occurs. That is, the user sees the complete list in a pop-up window for only as long as she/he needs to, and thus considerably more working area is made available.", "num_citations": "20\n", "authors": ["2221"]}
{"title": "Object inheritance without classes\n", "abstract": " Which comes first: the object or the class? Language designers enjoy the conceptual simplicity of object-based languages (such as Emerald or Self) while many programmers prefer the pragmatic utility of classical inheritance (as in Simula and Java). Programmers in object-based languages have a tendency to build libraries to support traditional inheritance, and language implementations are often contorted to the same end. In this paper, we revisit the relationship between classes and objects. We model various kinds of inheritance in the context of an object-oriented language whose objects are not defined by classes, and explain why class inheritance and initialisation cannot be easily modelled purely by delegation.", "num_citations": "19\n", "authors": ["2221"]}
{"title": "Generic ownership\n", "abstract": " Modern object-oriented programming languages support many techniques that simplify the work of a programmer. Among them is generic types: the ability to create generic descriptions of algorithms and object structures that will be automatically specialised by supplying the type information when they are used. At the same time, object-oriented technologies still suffer from aliasing: the case of many objects in a program\u2019s memory referring to the same object via different references. Ownership types enforce encapsulation in object-oriented programs by ensuring that objects cannot be referred to from the outside of the object (s) that own them. Existing ownership programming languages either do not support generic types or attempt to add them on top of ownership restrictions.The goal of this work is to bring object ownership into mainstream object-oriented programming languages. This thesis presents Generic Ownership which provides perobject ownership on top of a generic imperative language. Surprisingly, the resulting system not only provides ownership guarantees comparable to the established systems, but also requires few additional language mechanisms to achieve them due to full reuse of generic types.", "num_citations": "19\n", "authors": ["2221"]}
{"title": "InspectJ: Program monitoring for visualisation using AspectJ\n", "abstract": " Software is becoming increasingly complex. Visualisation, which presents a high level view of a system, can assist programmers in constructing, debugging and maintaining programs, as well as being a useful teaching aid. To create visualisations of running programs, it is necessary to have access to program run-time information. Traditional means of collecting program monitoring information suffer from a range of problems, from not being able to collect a wide enough range of information, to being too intrusive by requiring modification of existing tools and source files. We present InspectJ, which is a program visualisation system that uses AspectJ to collect program monitoring information for visualisation. AspectJ is a Java-based aspect-oriented language. Its advantages are that it is non-intrusive, and therefore does not require modification of existing tools or source files, and that it is easy to use, by virtue of\u00a0\u2026", "num_citations": "19\n", "authors": ["2221"]}
{"title": "Implementing a language with flow-sensitive and structural typing on the JVM\n", "abstract": " Dynamically typed languages are flexible and impose few burdens on the programmer. In contrast, static typing leads to software that is more efficient and has fewer errors. However, static type systems traditionally require every variable to have one type, and that relationships between types (e.g. subclassing) be declared explicitly.The Whiley language aims to hit a sweet spot between dynamic and static typing. This is achieved through structural subtyping and by typing variables in a flow-sensitive fashion. Whiley compiles to the JVM, and this presents a number of challenges. In this paper, we discuss the implementation of Whiley\u02bcs type system on the JVM.", "num_citations": "18\n", "authors": ["2221"]}
{"title": "Implementing first-class relationships in Java\n", "abstract": " Relationships have been an essential component of OO design since the 90s but OO languages still do not support firstclass relationships. Hence, programmers must implement relationships in an ad-hoc fashion which results in unnecessarily complex code. We have developed a new model for relationships in OO which distinguishes tuples and relationships (mutable sets of tuples) and supports both as first-class constructs. This paper describes the design of a library for Java which provides this model.", "num_citations": "18\n", "authors": ["2221"]}
{"title": "Efficient multimethods in a single dispatch language\n", "abstract": " Smalltalk-80 is a pure object-oriented language in which messages are dispatched according to the class of the receiver, or first argument, of a message. Object-oriented languages that support multimethods dispatch messages using all their arguments. While Smalltalk does not support multimethods, Smalltalk\u2019s reflective facilities allow programmers to efficiently add them to the language. This paper explores several ways in which this can be done, and the relative efficiency of each. Moreover, this paper can be seen as a lens through which the design issues raised by multimethods, as well as by using metaobjects to build them, can be more closely examined.", "num_citations": "18\n", "authors": ["2221"]}
{"title": "Visualising objects: Abstraction, encapsulation, aliasing, and ownership\n", "abstract": " Each object in an object-oriented program can correspond to one abstraction in the program\u2019s design. This correspondence makes visualising object-oriented programs easy: simply render each object in terms of its corresponding abstraction. Unfortunately, the endemic aliasing within object-oriented programs undermines this scheme, as an object\u2019s state can depend on the transitive state of many other objects, which may be unknown to the visualisation system. By analysing programs to determine the extent of aliasing, we can construct visualisations to display aliasing directly, and can provide support for more abstract visualisations.", "num_citations": "18\n", "authors": ["2221"]}
{"title": "Lessons in Combining Block-based and Textual Programming.\n", "abstract": " Tiled Grace is a block-based programming system backed by a conventional textual language that allows switching back and forth between block-based and textual editing of the same code at any time. We discuss the design choices of Tiled Grace in light of existing research and a user experiment conducted with it. We also examine the sorts of task preferred in each mode by users who had the choice of editing either as blocks or as text, and find both positive and cautionary notes for block-based programming in the results.", "num_citations": "17\n", "authors": ["2221"]}
{"title": "Oppositional Play\n", "abstract": " Computer games constantly promote particular values to be adopted by their players during gameplay, but there has been little research into how this takes place. Understanding value promotion in computer games is of importance for a variety of reasons, ranging from game design to criticism. This paper presents an initial method for assessing value promotion in computer games by examining what happens when we play against the promoted values, using the semiotic square to generate oppositional playings. By analysing computer games in this way we are able to gather negative evidence for the values promoted and to examine how games do or do not facilitate oppositional play.", "num_citations": "17\n", "authors": ["2221"]}
{"title": "Defaulting generic Java to ownership\n", "abstract": " Generic ownership is a mechanism for seamlessly combining ownership and genericity. Every class in Ownership Generic Java (OGJ) has an owner parameter as the last type argument. Defaulting is a way to take any Generic Java (GJ) program and translate it to an OGJ program thus making it possible to provide full backwards compatibility of OGJ with GJ programs. Since standard Java now has support for generics, defaulting lays down a path for making vanilla Java programs ownership parametric with no change to the source code.", "num_citations": "17\n", "authors": ["2221"]}
{"title": "Interactive design metric visualization: Visual metric support for user interface design\n", "abstract": " Interactive metric visualization is a novel approach providing complex, multi-dimensional feedback on the effects of layout changes in user interface designs. A graphical overlay based on the underlying rationale of quantitative design metrics, provides immediate feedback, continually guiding designers toward improved layouts. Effective visual metaphors, colour coding, and dynamic updating enable designers to interpret and utilize more complex information than from simple quantitative data or static overlays. This technique is especially suited to accelerated design and development using modern visual development tools. An experimental prototype for this approach is described and initial experience is reported.", "num_citations": "17\n", "authors": ["2221"]}
{"title": "Some patterns for relationships\n", "abstract": " Relationships between objects are almost as important to designs as objects themselves. Most programming languages do not support relationships well, so programmers must implement relationships in terms of more primitive constructs. This collection of patterns describe how objects can be used to model relationships within programs. By using these patterns, programs and designs can be smaller, more exible, and easier to understand and maintain.", "num_citations": "17\n", "authors": ["2221"]}
{"title": "From pushing buttons to play and progress: value and interaction in fable\n", "abstract": " A value can be understood as a belief that one mode of conduct is preferable to others. The user-interface of computer games mediates all player conduct in the game and is therefore key to understanding how values are expressed both by and to the player. How the interface affects player\u2019s expression and understanding of value in computer games is a relatively unknown quantity. We performed a qualitative case study of the game Fable to investigate connections between interface and value in gameplay. The concepts uncovered allow us to better address the computer game interface in both design and analysis.", "num_citations": "16\n", "authors": ["2221"]}
{"title": "A tile-based editor for a textual programming language\n", "abstract": " \u201cJigsaw puzzle\u201d programming environments manipulate programs primarily by drag-and-drop. Generally these environments are based on their own special-purpose languages, meaning students must move on to another language as their programs grow. Tiled Grace is a tile-based editor for Grace, an educational programming language with a conventional textual syntax. Using Tiled Grace, programmers can move seamlessly between visualising their programs as tiles or source code, editing their programs via tiles or text, and continuing on to traditional textual environments, all within the same programming language.", "num_citations": "15\n", "authors": ["2221"]}
{"title": "Are your incoming aliases really necessary? counting the cost of object ownership\n", "abstract": " Object ownership enforces encapsulation within object-oriented programs by forbidding incoming aliases into objects' representations. Many common data structures, such as collections with iterators, require incoming aliases, so there has been much work on relaxing ownership's encapsulation to permit multiple incoming aliases. This research asks the opposite question: Are your aliases really necessary? In this paper, we count the cost of programming with strong object encapsulation. We refactored the JDK 5.0 collection classes so that they did not use incoming aliases, following either the owner-as-dominator or the owner-as-accessor encapsulation discipline. We measured the performance time overhead the refactored collections impose on a set of microbenchmarks and on the DaCapo, SPECjbb and SPECjvm benchmark suites. While the microbenchmarks show that individual operations and iterations can\u00a0\u2026", "num_citations": "15\n", "authors": ["2221"]}
{"title": "An Analysis of Persuasive Technology Tool Strategies.\n", "abstract": " Persuasive technology is growing in popularity, yet to date, there has been limited research in this field outside of the USA This paper introduces ongoing research investigating whether the success of persuasive technology is based on how closely it matches the culture of its target audience.", "num_citations": "15\n", "authors": ["2221"]}
{"title": "System metaphor in extreme programming: A semiotic approach\n", "abstract": " System Metaphor is one of the core practices of the software development process known as \u201cExtreme Programming\u201d(XP). Unfortunately, the System Metaphor practice is poorly understood, and is the practice XP teams most commonly choose to ignore. We provide a simple, structural model of system metaphors, based upon Peircean semiotics, giving a fundamental account of the way metaphors can contribute to a software system. Using this model, we identify activities that teams can use to develop metaphors for their systems, and techniques for evaluating system metaphors. We hope this analysis will encourage XP teams not to abandon system metaphors, but rather, to continue to use metaphors to strengthen their development practices.", "num_citations": "15\n", "authors": ["2221"]}
{"title": "Brand objects for nominal typing\n", "abstract": " Combinations of structural and nominal object typing in systems such as Scala, Whiteoak, and Unity have focused on extending existing nominal, class-based systems with structural subtyping. The typical rules of nominal typing do not lend themselves to such an extension, resulting in major modifications. Adding object branding to an existing structural system integrates nominal and structural typing without excessively complicating the type system. We have implemented brand objects to explicitly type objects, using existing features of the structurally typed language Grace, along with a static type checker which treats the brands as nominal types. We demonstrate that the brands are useful in an existing implementation of Grace, and provide a formal model of the extension to the language.", "num_citations": "14\n", "authors": ["2221"]}
{"title": "How much architecture? Reducing the up-front effort\n", "abstract": " A key part of software architecture is the design of the high level structure of a software system -- an exercise in planning ahead. Agile software development methods discourage planning ahead, encapsulated by the Agile Manifesto philosophy \"[we value] responding to change over following aplan\". Development without architecture planning risks failure. This leads to an apparent paradox: how can you design an architecture while using a methodology that promotes not planning ahead? This paper introduces Grounded Theory research that is exploring the factors that affect how much architecture planning industry practitioners do up-front -- in other words, how much architecture? Early results show that the experience of the architects and predefined or template architectures both help to reduce the architectural effort required without sacrificing the benefits of a full architecture design.", "num_citations": "14\n", "authors": ["2221"]}
{"title": "From Java to UpgradeJ: an empirical study\n", "abstract": " UpgradeJ is a variant of Java that offers linguistic support for lightweight dynamic software updating (DSU), or hotswapping. UpgradeJ allows co-existing multiple versions of classes and adapts Java's type system to provide incremental typechecking.", "num_citations": "14\n", "authors": ["2221"]}
{"title": "A technology for lightweight web-based visual applications\n", "abstract": " Providing useful and usable visual interaction for Web-based applications is a challenge without requiring client-side support such as Java applets. We describe Cliki which provides Web-based lightweight support for visual systems. Cliki makes minimal assumptions about the client used to view the Web pages, meaning applications that use it are highly accessible.", "num_citations": "14\n", "authors": ["2221"]}
{"title": "Abstract Program Visualisation: Object Orientation in the Tarraingim Program Exploratorium\n", "abstract": " Program visualisation uses computer graphics and animation techniques to produce pictures illustrating the dynamic behaviour of a running computer program. Most program visualisation systems display either language-level details of programs or high-level overviews of the program's algorithm. This thesis investigates the use of abstraction in program visualisation. The goal of the project was to find techniques which could produce displays of programs at all levels of abstraction, and which would not require a large amount of information about the implementation of the program to be visualised. Based upon analyses of program visualisation and abstraction in programming, a model of abstract program visualisation is developed. This model uses object orientation to explicitly represent abstractions in the programs to be visualised. An object oriented framework for the design of an interactive program visualisation system (a program exploratorium) is developed based upon this model. This framework is used to construct Tarraingim, a prototype program exploratorium, as a proof of concept for the model. Tarraingim produces multiple views of object oriented programs at multiple levels of abstraction, by invisibly monitoring the programs' execution and using the information gathered to control graphical animations. Tarraingim is written in the SELF programming language, and visualises programs written in that language. A series of examples is presented to illustrate Tarraingim in action.", "num_citations": "14\n", "authors": ["2221"]}
{"title": "Distributing expertise in agile software development projects\n", "abstract": " The distribution of expertise in Agile teams is vital to enable team knowledge to be shared, preserved, and accessed when it is needed. Most studies emphasize knowledge sharing but a few empirical studies focus on skills. Integrating knowledge and skills is vital to leverage expertise in Agile teams. Moreover, it is not easy to leverage expertise by distributing expertise in Agile teams. Through a Grounded Theory study involving 18 Agile practitioners based in New Zealand and Australia, we revealed five approaches to distributing expertise in Agile teams: embracing a master-apprentice model, coaching and mentoring, engaging hands-on learning, establishing discussion platforms and disseminating explicit knowledge. Distributing expertise will provide insight into how Agile team members disseminate available expertise and pull new expertise into Agile teams.", "num_citations": "13\n", "authors": ["2221"]}
{"title": "Panel: designing the next educational programming language\n", "abstract": " Object-oriented programming is widely taught in introductory computer science courses, however no existing objectoriented programming language is\" the obvious choice\" for a teaching language. This makes it harder to transfer skills, techniques, and teaching materials between courses and between institutions, and leaves employers uncertain what they should expect new graduates to know. We believe that the object-oriented programming languages community should take this opportunity to work together to select, shape, or design the next educational programming language, and propose a set of principles that the language should follow. The purpose of this panel is to start a dialog with the educational community to refine these principles and to consider next steps.", "num_citations": "13\n", "authors": ["2221"]}
{"title": "First class relationships for OO languages\n", "abstract": " Relationships have been an essential component of OO design since the 90s and, although several groups have attempted to rectify this, mainstream OO languages still do not support first-class relationships. This requires programmers to implement relationships in an ad-hoc fashion which results in unnecessarily complex code. We have developed a new model for relationships in OO which provides a better abstraction than existing models provide. We believe that a language based on this model could bring the benefits of relationships to mainstream languages.", "num_citations": "13\n", "authors": ["2221"]}
{"title": "Spreadsheet structure inspection using low level access and visualisation\n", "abstract": " Spreadsheets are an extremely common form of end-user programming used for many applications from student marks to accounting for global multinationals. Ways of studying the structure of a spreadsheet itself is normally constrained to the tools provided in the spreadsheet software. We wanted to explore ways to use new visualisations for spreadsheets, and this paper documents our approach..", "num_citations": "13\n", "authors": ["2221"]}
{"title": "Visualising the structure of object-oriented systems\n", "abstract": " Executing object-oriented programs have a complex structure consisting of numerous objects connected by interobject references. This structure, called the program's object graph, is hard to understand, and this complicates learning, teaching, debugging and maintaining object-oriented programs. While visualisation can be used to display object graphs, the size and complexity of typical object graphs also makes visualisation difficult. We have developed ownership trees as a simple yet powerful method of extracting a program's implicit encapsulation structure from its object graph. We present a program visualisation tool that makes use of ownership trees to display the structure of object-oriented programs. Our prototype implementation suggests that visualisations based on ownership trees can effectively display the structure of fifty to sixty objects in a program simultaneously.", "num_citations": "13\n", "authors": ["2221"]}
{"title": "Modules as gradually-typed objects\n", "abstract": " Grace is a gradually typed, object-oriented language for use in education. Grace needs a module system for several reasons: to teach students about modular program design, to organise large programs, especially its self-hosted implementation, and to provide access to resources defined in other languages. Grace uses its basic organising construct, objects, to provide modules, and is then able to use its gradual structural typing to obtain a number of interesting features without any additional mechanisms.", "num_citations": "12\n", "authors": ["2221"]}
{"title": "Feeling strangely fine: the well-being economy in popular games\n", "abstract": " There is a growing interest in persuasive games designed to positively influence players\u2019 well-being in areas such as physical and mental health, particularly in terms of education. Designing such \u201cwell-being games\u201d is challenging because games themselves have not been sufficiently examined from this perspective. Examining the ways popular games convey messages persuasively is an important step in understanding design in this area. By studying the popular domain we can derive considerations for the design of games targeted at promoting human well-being.", "num_citations": "12\n", "authors": ["2221"]}
{"title": "A high integrity profile for memory safe programming in real-time Java\n", "abstract": " The Real-time Specification for Java (RTSJ) has been designed to cover a large spectrum of real-time applications, to achieve this goal the specification must cater to different real-time programming styles. This generality is essential for acceptance of Java by the industry but it also means that there are many error modes that application developers must deal with. The memory subsystem of the RTSJ is one particular area where the RTSJ\u2019s generality creates complexity. This complexity is a problem in high integrity systems as it can be the source of errors, and runtime overheads. The contribution of this paper is a new high integrity profile for memory safe programming in Real-time Java. This profile is notable in the sense that it does not restrict expressiveness of RTSJ programs, yet it guarantees that no memory-related programming errors will occur at runtime. The profile is machine checkable, and simple enough that errors can be readily corrected. While other profile have been put forward, this proposal is the first to have been evaluated on actual deployed software.", "num_citations": "12\n", "authors": ["2221"]}
{"title": "Towards Reusable Synchronisation for Object-Oriented Languages\n", "abstract": " The integration of concurrency and object-orientation has been the subject of much research for well over a decade. This integration has been problematic due to the conflicts that can arise between synchronisation and inheritance which limit the reuse potential of concurrent objects. The aim of our research is to provide a means for achieving flexible and reusable synchronisation within existing object-oriented languages. We have identified the different aspects of synchronisation which need to be addressed and have developed the underlying\u2265 synchronisation rings\u00a5 model for creating synchronised objects. Current work focuses on developing a synchronisation \u00b5aspectV language to allow easier use of the synchronisation rings model and to attain the reuse goal we desire.", "num_citations": "12\n", "authors": ["2221"]}
{"title": "Co-located collaborative software visualization\n", "abstract": " Most software visualization tools are designed from a single-user perspective and are bound to the desktop, IDEs, and the web. Few tools are designed with sufficient support for the social aspects of software engineering such as collaboration, communication, and awareness. Our research aims at supporting co-located collaborative software analysis using software visualization techniques with multi-touch tables. The research will be conducted via user experiments which will inform the design of multi-touch software visualization applications and further our understanding of how developers work together with co-located collaborative tools.", "num_citations": "11\n", "authors": ["2221"]}
{"title": "Towards automating class-splitting using betweenness clustering\n", "abstract": " Large, unwieldy classes are a significant maintenance problem. Programmers dislike them because the fundamental logic is often obscured, making them hard to understand and modify. This paper proposes a solution - a semi-automatic technique for splitting large classes into smaller, more cohesive ones. The core of the technique is the use of betweenness clustering to identify the best way of partitioning a class. This turned a tedious manual process into a quick and simple semi-automated one in roughly one third of the cases we examined.", "num_citations": "11\n", "authors": ["2221"]}
{"title": "Towards visual software analytics\n", "abstract": " Since its inception, a large amount of software has been written in Java and surprisingly little is known about the structure of Java programs in the wild. There are very few software visualization tools for analytical reasoning of Java software. We are creating a visual software analytics tool that will help to characterize our Java software corpus. Our tool will help to provide insight into a collection of Java programs, detect the expected, and discover the unexpected.", "num_citations": "11\n", "authors": ["2221"]}
{"title": "Change detection for aggregate objects with aliasing\n", "abstract": " Object oriented systems often need to detect when objects have changed. Due to aggregation and aliasing, programmers must explicitly identify changes to objects in most object oriented systems. We describe a program monitoring technique which takes account of aggregation and aliasing, and which can be used to detect changes automatically. Automatic change detection can simplify programming and design, so producing more reliable systems with less effort.", "num_citations": "11\n", "authors": ["2221"]}
{"title": "Tarraing\u00edm: A Program Animation Environment\n", "abstract": " Program animation is the use of computer graphics and animation techniques to visualise the behaviour of an executing program. This paper describes a program animation system being developed at Victoria University. This system (called Tarraing m from the g lic for to draw) is designed to include facilities of both graphical debuggers and algorithm animation systems; that is, Tarraing m will provide both low level views of program components and user-de ned higher level views. As well as discussing the motivation and general architecture of Tarraing m, this paper discusses some of the technical problems arising in the implementation of such a system, and our solutions to them.", "num_citations": "11\n", "authors": ["2221"]}
{"title": "Programmers are from Mars, Customers are from Venus: A practical guide for customers on XP Projects\n", "abstract": " Extreme Programming and other Agile methods have a dedicated customer role that acts as the interface between development teams and their clients, sponsors, and end-users. The customer is critical to agile projects, but there is little research, experience, or advice about effective practices required to fill that role. We present a set of patterns describing the key roles on a customer team, and the practices that enable customers to fill those roles. By adopting these roles and practices, customers and development teams can increase the velocity and reliability of their projects, and ensure all participants in a project, not just the developers, can work at a sustainable pace.", "num_citations": "10\n", "authors": ["2221"]}
{"title": "Overcoming representation exposure\n", "abstract": " Through their reliance on reference semantics, what objects gain in exibility they lose in their ability to control access to their internal implementation details| this is the problem of representation exposure. Existing approaches to achieving better encapsulation for objects, including type systems and programming models, are based on object encapsulation boundaries and constrained access across those boundaries. Our earlier work dealing with ownership types achieved a limited form of representation containment, whereby each object's representation was contained within that object, its owner. Inter-object accessibility was constrained so that owners were dominators of the objects they owned. Although achieving a clear statically expressible notion of containment, our approach lacked exibility, so that common programming techniques became overly cumbersome to implement. This paper investigates new and improved ways for expressing object structure, using path variables,...", "num_citations": "10\n", "authors": ["2221"]}
{"title": "Tinygrace: A simple, safe, and structurally typed language\n", "abstract": " Grace is a new gradually, structurally typed object-oriented programming language. Formal models of existing languages provide a rigorous base for claiming type soundness, so we have set about creating a model of a subset of Grace. While much of the formal literature of objects has used structural typing, models of popular modern languages such as Featherweight Java have had to use nominal typing to match the language they are modelling. In contrast to this, we present Tinygrace: a subset of Grace with a structural type system, feature-parity with FJ, and an accompanying proof of soundness.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Locating expertise in agile software development projects\n", "abstract": " Agile software development projects rely on the diversity of team members\u2019 expertise. It is vital to develop the meta-knowledge of the available expertise in Agile teams. However, locating the internal expertise in Agile teams is not explicitly reported in the literature. Through a Grounded Theory study involving 16 Agile practitioners based in New Zealand and Australia, we revealed four ways to identify internal expertise in Agile software development projects: communicating frequently, working closely together, declaring self-identified expertise, and using an expertise directory. The outcome of this study will provide significant insight into how Agile team members depend on each other in locating their peers\u2019 expertise, as well as quantify the level of expertise.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "The effect of complexity and value on architecture planning in agile software development\n", "abstract": " A key feature of agile software development is its prioritisation of responding to changing requirements over planning ahead. If an agile development team spends too much time planning and designing architecture then responding to change will be extremely costly, while not doing enough architectural design puts the project at risk of failure. Striking the balance depends heavily on the context of the system being built, the environment and the development teams. This Grounded Theory research into how much architecture agile teams design up-front has identified system complexity as an important factor in determining how much planning a team does up-front, while system size, although related to complexity, has a much less direct impact. Furthermore, when determining how much design to do up-front, value to the customer can be a more important factor than overall development cost. Understanding\u00a0\u2026", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Profiling field initialisation in Java\n", "abstract": " Java encourages programmers to use constructor methods to initialise objects, supports final modifiers for documenting fields which are never modified and employs static checking to ensure such fields are only ever initialised inside constructors. Unkel and Lam observed that relatively few fields are actually declared final and showed using static analysis that many more fields have final behaviour, and even more fields are stationary (i.e. all writes occur before all reads). We present results from a runtime analysis of 14 real-world Java programs which not only replicates Unkel and Lam\u2019s results, but suggests their analysis may have under-approximated the true figure. Our results indicate a remarkable 72-82% of fields are stationary, that final is poorly utilised by Java programmers, and that initialisation of immutable fields frequently occurs after constructor return. This suggests that the final modifier for fields\u00a0\u2026", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Interactive multi-touch surfaces for software visualization\n", "abstract": " Most software systems are developed by teams of people. The tools used to develop and maintain these systems are primarily designed from a single-user perspective and are bound to Integrated Development Environments (IDEs). These design decisions do not allow users to collaboratively navigate through software visualizations or to analyse software easily. We are investigating whether multi-touch table interaction techniques are more effective for co-located collaborative software visualization than existing single-user desktop interaction techniques. The implications of our research will help inform developers how to design better visualization applications for interactive multi-touch surfaces.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Problem frame patterns: an exploration of patterns in the problem space\n", "abstract": " A problem frame is a generic, abstract description of the structure of a problem. Using a problem frame requires selecting a candidate frame from a catalog and mapping the specific parts of the problem into the principal parts of the frame. In this paper we present five patterns, one for each of Jackson's original problem frames. We hope that by writing about problem frames as patterns, we can make the frames themselves and their structure more explicit, and so expose problem frames to a wider audience.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Role-play and use case cards for requirements review\n", "abstract": " This paper presents a technique that uses role-play and index cards to review use cases and to assist in making use case development more accessible and better guided. The technique is based on the established CRC card technique used for object-oriented design. In our technique, essential use cases are recorded on index cards, and role-play is used for development and review. The paper presents the technique, and outlines our experience in applying it.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Featherweight generic ownership\n", "abstract": " Object ownership is an approach to controlling aliasing in programming languages. Proposals for adding ownership to programming languages do not directly support type genericity. We present Featherweight Generic Ownership\u2014the first system to unify ownership and type polymorphism. Our type system extends Featherweight Generic Java with locations to support ownership and confinement invariants, as well as having full soundness proof. We hope that our work will help bring full support for object encapsulation to the mainstream programming world.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Software visualization tools for component reuse\n", "abstract": " This paper describes our experiences with our software visualization tools for web-based visualization of remotely executing object-oriented software. The motivation of this work is to allow developers to browse web-based software repositories to explore existing code components and frameworks by creating visual documentation. Components are test driven to capture their static and run-time information in program traces and are then transformed into useful visualizations. Visualizations can help developers understand what a component does, how it works, and whether or not it can be reused in a new program.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Patterns for essential use case bodies\n", "abstract": " Essential use cases are an effective way to analyse the usability requirements for a system under development. Essential use cases are quite stylised--writing good essential use cases is somewhat of a secret art. This paper contains patterns that describe how to write the bodies of essential use cases. Readers of this paper will be able to write good essential use cases quickly, making it easier to specify usable systems.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "Program visualisation for visual programs\n", "abstract": " The Nord Modular music synthesiser system comprises a stand-alone array of digital signal processors programmed by a dataflow visual langauage and supported by a visual programming environment that runs on commodity hardware. We have investigated applying program visualisation techniques to over 400 Nord Modular programs. Our visualisations make explicit module types and signal flows that are only implicit in the metaphorical graphical syntax adopted by the Nord Modular visual programming language. We have also analysed the programming style used in Nord Modular programs, in particular, the direction of program layouts. While we found that programs tended to arrange signal flow top down and left to right, we found much more variation than we expected, both within individual programs and across the Nord factory program corpus.", "num_citations": "9\n", "authors": ["2221"]}
{"title": "The left hand of equals\n", "abstract": " When is one object equal to another object? While object identity is fundamental to object-oriented systems, object equality, although tightly intertwined with identity, is harder to pin down. The distinction between identity and equality is reflected in object-oriented languages, almost all of which provide two variants of\" equality\", while some provide many more. Programmers can usually override at least one of these forms of equality, and can always define their own methods to distinguish their own objects.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "The essence of inheritance\n", "abstract": " Programming languages serve a dual purpose: to communicate programs to computers, and to communicate programs to humans. Indeed, it is this dual purpose that makes programming language design a constrained and challenging problem. Inheritance is an essential aspect of that second purpose: it is a tool to improve communication. Humans understand new concepts most readily by first looking at a number of concrete examples, and later abstracting over those examples. The essence of inheritance is that it mirrors this process: it provides a formal mechanism for moving from the concrete to the abstract.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Coordinating expertise outside agile teams\n", "abstract": " Agile software development projects depend upon roles located outside Agile teams such as User Experience Designers and Software Architects to support teams. As external specialists\u2019 expertise is valuable to Agile teams, further investigation is needed to explore the relationships between Agile teams and external specialists in coordinating external expertise. Through a Grounded Theory study involving 47 Agile practitioners and external specialists, we discovered five factors that Agile teams and external specialists need to consider when coordinating external expertise: Availability, Agile Mindset, Stability, Knowledge Retention and Effective Communication. We present strategies for each factor as a guideline for coordinating external expertise in teams. This study helps Agile teams to manage and utilize external expertise resources effectively.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Flow-Sensitive Types for Whiley\n", "abstract": " Modern statically typed languages require variables to be declared with a single static type, and that subtyping relationships between used-defined types be made explicit. This contrasts with dynamically typed languages, where variables are declared implicitly, can hold values of different types at different points and have no restrictions on flow (leading to ad-hoc and implicit subtyping). We present the flow-sensitive and structural type system used in the Whiley language. This permits variables to be declared implicitly, have multiple types within a function, and be retyped after runtime type tests. Furthermore, subtyping between user-defined types is implicit, based purely on structure. The result is a statically-typed language which, for the most part, has the look and feel of a dynamic language. We formalise Whiley\u2019s type system, provide proofs of termination and soundness, discuss implementation on the JVM, and report on our experiences using Whiley to develop a number of small benchmarks.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Encoding ownership types in Java\n", "abstract": " Ownership types systems organise the heap into a hierarchy which can be used to support encapsulation properties, effects, and invariants. Ownership types have many applications including parallelisation, concurrency, memory management, and security. In this paper, we show that several flavours and extensions of ownership types can be entirely encoded using the standard Java type system.             Ownership types systems usually require a sizable effort to implement and the relation of ownership types to standard type systems is poorly understood. Our encoding demonstrates the connection between ownership types and parametric and existential types. We formalise our encoding using a model for Java\u2019s type system, and prove that it is sound and enforces an ownership hierarchy. Finally, we leverage our encoding to produce lightweight compilers for Ownership Types and Universe Types \u2014 each\u00a0\u2026", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Understanding the impact of collection contracts on design\n", "abstract": " Java provides a specification for a user-defined general purpose equivalence operator for objects, but collections such as Set have more stringent requirements. This inconsistency breaks polymorphism: programmers must take care to follow Set\u2019s contract rather than the more general Object contract if their object could enter a Set. We have dynamically profiled 30 Java applications to better understand the way programmers design their objects, to determine whether they program with collections in mind. Our results indicate that objects which enter collections behave very differently to objects which do not. Our findings should help developers understand the impact of design choices they make, and guide future language designers when adding support for collections and/or equality.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Mojojojo-more ownership for multiple owners\n", "abstract": " Traditional ownership types organise the heap into a tree. Ownership types can support memory management, real-time systems, concurrency, parallelism, and general purpose reasoning about programs. Trees, however, are too restrictive to describe many real programs, limiting the usability of conventional ownership systems. Multiple ownership organises the heap into a directed acyclic graph, rather than a tree. MOJO was the first language to support multiple ownership; it featured multiple owners per object, ownerwildcards, an effect system, and a simple \u2018owners as sets\u2019 model. In this paper, we introduce Mojojojo, a successor to MOJO. Mojojojo is both simpler and more powerful than MOJO: supporting generics and existential types (which allows for more re-usable classes); a more expressive system of constraints for specifying topology, which are closely tied to the simple set-theoretic model; and a simpler formalisation. We contribute a thorough description of Mojojojo, its formalisation and soundness proof, and a discussion of how Mojojojo can be extended to incorporate prescriptive constraints, addressing the same goals as owners-as-dominators or owners-as-modifiers disciplines.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Web software visualization using extensible 3D (X3D) graphics\n", "abstract": " 3D web software visualization has always been expensive, special purpose, and hard to program. Most of the technologies used require large amounts of scripting, are not reliable on all platforms, are binary formats, or no longer maintained. We can make web software visualization of object-oriented programs cheap, portable, and easy by using Extensible (X3D) 3D Graphics, which is a free open standard. In this paper we outline our experience with X3D and discuss the suitability of X3D as an output format for software visualization.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Towards end-user web software visualization\n", "abstract": " Software visualization has always been expensive, special purpose, and hard to program. Most of the existing software visualization tools require too much time for end-user developers to learn and make effective use of. We are currently building a Web software visualization application that allows end-user to create, view, save, and share visualizations. In this abstract we introduce our software corpus visualization project and summarize our results thus far.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Introducing alloy in a software modelling course\n", "abstract": " Engineering degree programmes require courses in \u201cfoundational science\u201d but many traditional foundations\u2014calculus, chemistry, or quantum physics\u2014are not generally relevant to Software Engineering. To address this requirement, we developed a new first-year course\u2014Introduction to Software Modelling\u2014that introduces the principles and practices of Software Engineering, beginning with domain analysis, finding classes and use cases, and finishing with building models in Alloy. In this short paper, we cover the rationale for the course; outline the course structure; and describe our experience with teaching Alloy to fifty first-year engineering students with minimal backgrounds in programming or logic.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Exclusion requirements and potential concurrency for composite objects\n", "abstract": " Concurrent object-oriented systems must prevent the interference that may arise when multiple threads simultaneously access shared components. We present a simple approach for implementing flexible locking strategies in an object-oriented system, in which the components themselves may be composite objects. We express exclusion requirements as sets of conflict pairs on component interfaces. Given knowledge of the dependency between the interface of a composite object and its internal components, we show how external exclusion requirements can be calculated from internal requirements, and further, how any potential concurrent activity outside an object can be projected into potential concurrency for the internal components.With our approach we can defer the distribution of locks in the system until deployment: the placement of locks and choice of lock type for a component can depend on its\u00a0\u2026", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Using software visualisation to enhance online component markets\n", "abstract": " Online component markets can be costly for consumers to use, in terms of the time and effort spent understanding the components on offer. This cost of understanding will deter consumers from reusing the available components. Software visualisations derived from the components\u2019 run-time behaviour can lessen the cost of understanding. We have developed a prototype tool called Spider for providing this functionality to producers and consumers. We discuss some of the issues involved, along with our experiences in implementing the prototype.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Icons R Icons: User interface icons, metaphor and metonymy\n", "abstract": " Icons are used in almost every graphical user-interface to computer software. Despite this, there is a serious lack of comprehension of what they are and how they work. The application of semiotics to user-interface icons can help to solve this problem by providing a framework for understanding icons in. This paper suggests such a semiotic approach and then applies it to real-world icons to show its effectiveness. Some hypothetical guidelines are derived from the application and a strong analytic technique results.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "Sokoban: a system object case study\n", "abstract": " This report presents a case study applying the Distribution of System Responsibilities (DSR) object-oriented design technique. DSR provides a starting point for an object-oriented design by directly manipulating the requirements for that application. The case study applies DSR to the development of a small application, the game Sokoban. The case study provides evidence that DSR does allow object-oriented designs to be created, that it allows reasonable designs to be created, and that any object-oriented design can be created by it.", "num_citations": "8\n", "authors": ["2221"]}
{"title": "What programming languages do developers use? A theory of static vs dynamic language choice\n", "abstract": " We know very little about why developers do what they do. Lab studies are all very well, but often their results (e.g. that static type systems make development faster) seem contradicted by practice (e.g. developers choosing JavaScript or Python rather than Java or C#). In this paper we build a first cut of a theory of why developers do what they do with a focus on the domain of static versus dynamic programming languages. We used a qualitative research method - Grounded Theory, to interview a number of developers \\pmb(n=15) about their experience using static and dynamic languages, and constructed a Grounded Theory of their programming language choices.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Designing grace: Can an introductory programming language support the teaching of software engineering?\n", "abstract": " Many programming language constructs that support software engineering in the large - explicit variable declarations, explicit external dependencies, static types, information hiding, invariants-provide little benefit to the small programs written by novice programmers, where every extra syntactic token has to be explained and understood before novices can succeed in running even the simplest program. We are designing Grace, a new educational object-oriented language that we hope will prove useful for teaching both programming and software engineering. This paper describes some of the tradeoffs between teaching programming and teaching software engineering that we faced while designing Grace, and our attempts to address those tradeoffs.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Cloning in ownership\n", "abstract": " Cloning is an essential feature in many object-oriented programs. Unfortunately, existing techniques generally copy too little or too much. We present an object cloning technique that uses the object structure enforced by ownership types to produce the clones.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Does size matter? a preliminary investigation of the consequences of powerlaws in software\n", "abstract": " There is increasing evidence that many object-oriented software size metrics are characterised by scale-free, powerlaw distributions. This means programs will have arbitrarily large components, and the size of the largest component will increase as programs' overall size increases. This directly contradicts a crucial assumption of object-oriented design---that large programs can be build by combining many small components.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "VET3D: a tool for execution trace web 3D visualization\n", "abstract": " We are interested in finding new ways to visualize our software execution traces. An issue in visualizing our execution traces is deploying and integrating them into users' environments. We have a tool called VET3D that transforms execution traces into visualizations over the web. Our tool will help developers to understand the structure and behaviour of software.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Relationship Aspect Patterns.\n", "abstract": " Relationships between objects are almost as important to designs as the objects themselves. Most programming languages do not support relationships well, so programmers must implement relationships in terms of more primitive constructs. This paper presents a selection of proto-patterns which describe how aspects can be used to model relationships within programs. By using these patterns, programs and designs can be made smaller, more flexible, and easier to understand and maintain.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Visualising 1, 051 visual programs module choice and layout in the Nord Modular patch language\n", "abstract": " The Nord Modular music synthesiser system comprises a standalone array of digital signal processors programmed by a dataflow visual langauage and supported by a visual programming environment that runs on commodity hardware. A crucial difference between the Nord Modular and traditional modular synthesizers is that each Nord module can be positioned individually, whereas physical analogue signal processing units are typically installed in fixed racks. We have used information visualisation techniques to investigate the layouts and programming style of 1,051 Nord Modular programs. We found that although modules could be positioned freely within a program, particular types of modules were generally found in sterotypical locations.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Aliasing in object oriented systems\n", "abstract": " This chapter contains summaries of the presentations given at the Intercontinental Workshop on Aliasing in Object-Oriented Systems (IWAOOS\u201999) at the European Conference on Object-Oriented Programming (ECOOP\u201999) which was held in Lisbon, Portugal on June 15, 1999.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "The Object System Pattern.\n", "abstract": " Classical object oriented systems require every object to be an instance of a class, and all classes to be written before the program is deployed. Some programs need exible, con gurable, dynamically extensible representations of objects, which cannot be determined in advance. The Object System pattern describes how you can build your own object system from scratch. Using the Object System pattern, you can build precisely the kind of objects you need for your application, but these objects will require more memory space and execution time than the more rigid objects supported by programming languages.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Object ownership to order\n", "abstract": " Ownership types encode object ownership, capturing both the owner of an object and the owners of objects used by an object. In earlier work, we presented a static type system using ownership types for an object-based language. Well-typed programs exhibit a property called representation containment on their object graphs. This provides a strong but exible notion of containment which guarantees that an object is never accessible from outside of its owner. In this paper we present a simple order theoretic model for interpreting both static ownership types and dynamic ownership structures. This model clari es not only the key static constraints for the visibility of ownership types, but also the relationship between these constraints and the containment invariants they impose on the dynamic object graph. Our simpler presentation has allowed us to extend the ownership type system with subtyping in a natural way.", "num_citations": "7\n", "authors": ["2221"]}
{"title": "Grace's Inheritance\n", "abstract": " This article is an apologia for the design of inheritance in the Grace educational programming language: it explains how the design of Grace\u2019s inheritance draws from inheritance mechanisms in predecessor languages, and defends that design as the best of the available alternatives. For simplicity, Grace objects are generated from object constructors, like those of Emerald, Lua, and Javascript; for familiarity, the language also provides classes and inheritance, like Simula, Smalltalk and Java. The design question we address is whether or not object constructors can provide an inheritance semantics similar to classes.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "On owners-as-accessors\n", "abstract": " Prescriptive ownership systems generally impose one of two disciplines on programs: either owners-as-dominators, or owners-as-modifiers. In this paper we discuss \u201cowners-as-accessors\u201d\u2014a discipline that is stricter than ownersas-modifiers but more lenient than owners-as-dominators. We provide a concise informal definition of owners-as-accessors, discuss some existing systems that employ this discipline, and revisit an earlier study on performance. Finally we hypothesize how owners-as-accessors could potentially unify William Cook\u2019s two forms of data abstraction: abstract data types and objects.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "The semiotics of usage-centred design\n", "abstract": " User interface design is a complex activity, which makes it difficult to control and master. A well-designed user interface can be seen as one where designers have correctly mapped the application domain onto the solution domain. This mapping, or bridge, may be helped or hindered by the design methodology and the success of any software engineering methodology depending on how good a bridge it provides between the application domain and the solution domain. A good match between the requirements and the implementation reduces the risk of having to make costly and major changes to the user interface at a late stage in development. Usage-centred design (UsCD) has been a very successful user interface design methodology. Although successful, there is no underlying theory as to why this should be the case. This chapter uses semiotics to provide a better understanding of the models and the\u00a0\u2026", "num_citations": "6\n", "authors": ["2221"]}
{"title": "Playing the interface: a case study of Grand Theft Auto: San Andreas\n", "abstract": " Video games are currently not well understood from an HCI perspective. As opposed to the standard task-based view of interaction, video game interaction takes the form of play. In this paper we offer an analysis of a form of gameplay we call\" playing the interface.\" By understanding play as a kind of interaction with software, we can move toward a video game-specific HCI.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "Use case analysis with narrative semiotics\n", "abstract": " Use cases are the accepted contemporary vehicle for the capture, collection and management of functional requirements for information systems and networked e-and m-commerce environments. While employed widely, use cases lack a critical theoretical foundation. As a result, the applications of use cases vary greatly in practice. We present an analysis of use cases based on the narrative semiotics of Greimas and on structural narratology. Our analysis illustrates how these techniques can expose common weaknesses and implicit assumptions latent within use case texts, and can provide a principled basis for the systematic review and evaluation of use cases within information systems development methodologies.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "Checking ownership and confinement properties\n", "abstract": " A number of formal proposals to manage aliasing in Java-like programming languages have been advanced over the last five years. Unfortunately, it is not clear how practical these proposals are, that is, how well they relate to the kinds of programs currently written in those languages. We have analysed heap dumps from a corpus of Java programs to identify their implicit aliasing structures, including object ownership, confinement, and uniqueness. Understanding the kinds of aliasing present in programs should help us to design formalisms to make explicit the kinds of aliasing implicit in object-oriented programs.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "The Fox\u2014a tool for object graph analysis\n", "abstract": " Object-oriented programs, when executed, produce a large number of objects in memory. These objects and the references between them form an\\textit {object graph}. Object graphs are not obvious from the class structure underlying them, and thus it is important to study them to better understand what really happens to programs at run time. We present a query-based debugger called Fox that allows a detailed examination of snapshots taken of object graphs as programs run. Fox makes it easy to examine object structures, encapsulation and ownership properties, and it has proven essential both in our research and day to day programming.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "GOF patterns for GUI Design\n", "abstract": " The Design Patterns book introduced twenty-three patterns for object oriented software design. These patterns are used widely, but only in their intended domain of software design. We describe how six of these patterns can be used for the conceptual design of graphical user interfaces. By using these patterns, designers can produce interfaces which are more consistent, make good use of screen space, and are easier to use.", "num_citations": "6\n", "authors": ["2221"]}
{"title": "Abstract and concrete data types vs object capabilities\n", "abstract": " The distinctions between the two forms of procedural data abstraction\u2014abstract data types and objects\u2014are well known. An abstract data type provides an opaque type declaration, and an implementation that manipulates the modules of the abstract type, while an object uses procedural abstraction to hide an individual implementation. The object-capability model has been proposed to enable object-oriented programs to be written securely, and has been adopted by a number of practical languages including JavaScript, E, and Newspeak. This chapter addresses the questions: how can we implement abstract data types in an object-capability language? and, how can we incorporate primitive concrete data types into a primarily object-oriented system?", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Permission and Authority Revisited towards a formalisation\n", "abstract": " Miller's notions of permissions and authority are foundational to the analysis of object-capability programming. Informal definitions of these concepts were given in Miller's thesis. In this paper we propose precise definitions for permissions and authority, based on a small object-oriented calculus. We quantify their bounds (current, eventual, behavioural, topological), and delineate the relationships between these definitions.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Modules and dialects as objects in Grace\n", "abstract": " Grace is a gradually typed, object-oriented language for use in education; consonant with that use, we have tried to keep Grace as simple and straightforward as possible. Grace needs a module system for several reasons: to teach students about modular program design, to organise large programs, especially its self-hosted implementation, to provide access to resources defined in other languages, and to support different \u201cdialects\u201d\u2014language subsets, or domain specific languages, for particular parts of the curriculum. Grace already has several organising constructs; this paper describes how Grace uses two of them, objects and lexical scope, to provide modules and dialects.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Understanding ownership types with dependent types\n", "abstract": " In this paper we will explore the relationship between Ownership Types and more fundamental type systems. In particular, we show that ownership types (in both simple and embellished flavours) are dependent types by translating object calculi with object ownership to lambda calculi with dependent types. We discuss which ownership features share features in the underlying dependent type system, and which additional features require additional complexity.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "OGJ gone wild\n", "abstract": " Ownership types structure the heap, and can enforce encapsulation properties which improve security, provide more information for the programmer, and allow for better reasoning about programs. Ownership Generic Java (OGJ) implements ownership types using Java generics and some additional type checking. This allows the programmer to use generics and ownership types in the same programs with little addtional syntactic overhead. We combine Java wildcards (represented formally as existential types) with OGJ to enforce an ownership topology using only features of the Java type system. We demonstrate how the owners-as-dominators encapsulation property can be enforced by a minimal addition to the well-formedness rules for types and classes. We show that the type parameterisation of Java generics\u2014with wildcards\u2014is sufficient to enforce ownership.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "X3D software visualisation\n", "abstract": " We have a software visualisation architecture that requires tools to develop visualisations from XML execution traces and integrate the visualisations into user\u2019s web environments. Most existing web software visualisation systems create 2D visualisations and if they do use 3D they are using technologies that are outdated, not designed for the web, and hard to extend. We are building a tool that transforms XML execution traces into X3D\u2013the Web3D Consortium\u2019s open standard for web 3D graphics\u2013web enabled visualisations and exploring how suitable X3D is for use in software visualisation. Our tool and visualisations will help developers to understand the structure and behaviour of software for reuse, maintenance, re-engineering, and reverse engineering.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Well-being to \u201cwell done!\u201d: The development cycle in role-playing games\n", "abstract": " Interest in designing games to convey persuasive messages concerning human well-being is growing, but presents a number of challenges. A significant problem comes in connecting the gameplay with the persuasive intent. We show how the gameplay structure of \u201cavatar development\u201d in popular-role playing games can be applied to the design of persuasive well-being games.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Patterns as Signs: A Semiotics of Object-Oriented Design Pat-terns\n", "abstract": " Object-oriented design patterns have been one of the most important and successful ideas in software design over the last ten years, and have been well adopted both in industry and academia. We provide a semiotic account of design patterns, treating a pattern as a sign comprised of the programmers\u2019 intent and its realisation in the program. A number of open research problems remain regarding patterns, including the differences between patterns, variant forms of common patterns, the naming of patterns, the organisation of collections of patterns, the relationships between patterns, and the extent to which patterns modify the rhetoric of object-oriented design. Considering patterns as signs can address many of these common questions regarding design patterns, to assist both programmers using patterns and authors writing them.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Postmodern prospects for conceptual modelling\n", "abstract": " A number of recent developments in software engineering\u2014from agile methods to aspect-oriented programming to design patterns to good enough software\u2014share a number of common attributes. These developments avoid a unifying theme or plan, focus on negotiation between different concerns, and exhibit a high level of context sensitivity. We argue that these developments are evidence of a postmodern turn in software engineering. In this paper, we survey a number of these developments and describe their potential implications for the practice of conceptual modelling.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Extreme programming system metaphor: A semiotic approach\n", "abstract": " System Metaphor is one of the key practices of Extreme Programming (XP). Unfortunately, the System Metaphor practice is poorly understood, and is the practice XP teams most commonly choose to ignore. We provide a simple, structural model of system metaphors, based upon Peircean semiotics, giving a fundamental account of the way metaphors can contribute to a software system. Using this model, we identify activities that teams can use to develop metaphors for their systems, and techniques for evaluating system metaphors. We hope this analysis will encourage Extreme Programming teams not to abandon system metaphors, but rather, to continue to use metaphors to strengthen their development practices.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Oh! Gee! Java!\u2014Ownership Types (almost) for Free\n", "abstract": " The existing proposals for ownership types build on Java-like languages without generic types. A minimal ownership type scheme for languages with generic types could be a much smaller change to the language. Given that Java-like languages are now adopting generic types (and that several object-oriented languages already provide them) such an extension may make ownership types practical for the practising programmer.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Lightweight web-based tools for usage-centered and object-oriented design\n", "abstract": " Every kind of development needs appropriate support. Paper, pencil, and index cards are extremely fine for small examples, but will not scale up to multiple teams of distributed developers, while large-scale CASE tool suites are a rational choice for mission-critical development but require too much investment to be applicable to Agile projects. Lightweight, web-based tools can provide cheap and cheerful support for small to medium sized agile developments, being better at recording and sharing information than paper or generic software tools, but without the overheads and strictures of full-blown CASE systems. We present a range of lightweight, web-based tools for all phases of the software lifecycle, both that we have developed, and that are available over the Internet.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Experiments with generic visitors\n", "abstract": " This paper gives an overview of our work on generic visitors 12], and it gives a comparison of two implementations, in Java and Smalltalk. For object-oriented programming, the Visitor pattern 3] enables the de nition of a new operation on an object structure without changing the classes of the objects. The discovery of generic visitors is due to striking parallels with shape polymorphic 5], or polytypic 4, 10] programming. This illustrates the connections among the various programming styles. The standard way of creating a new operation on an object is to create a new method for it by editing and recompiling its class. It often happens that new methods in many classes must be created to support what is conceptually a single action, such as a search for a particular eld in a particular class of objects. This is rather tedious. Analogous problems arise in functional programming where the standard pattern-matching approach means that an operation like mapping of a function must be rede ned for each new data type. The Visitor pattern provides an alternative means of creating new operations without changing any classes. The operation is decomposed into a description of how to determine the class of an object, and the actions to be taken when the class is found. The former need only be speci ed by, once and for all, inserting accept methods into the class de nitions, while the latter vary from visitor to visitor 13]. The analogy with mapping becomes clearer, as the visitor corresponds to the function being mapped, whose application is controlled by the class. The analogous functional approach is captured in PolyP 4] which improves on the earlier work in\u00a0\u2026", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Scribble: A diagram editor with a minimal interface\n", "abstract": " Existing CASE tool diagram editors have large, complex, and sophisticated graphical user interfaces. Because of their size, these interfaces are difficult to learn and hard to use. A minimal interface for a diagram editor provides only the essential behaviour required by the user in the simplest possible manner. Minimal interfaces are smaller than traditional interfaces, and should be easier and quicker to use. To test the feasibility of a smaller and simpler interface, we designed a minimal interface for a CASE tool diagram editor, and implemented a small prototype tool using that interface.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "Found objects\n", "abstract": " To design a program, rst nd your objects. Unfortunately, the right objects are not easy to nd, and as a result most programs are not as well designed as they could be. The patterns in this language describe how objects can found within existing programs. By using these patterns, programs and designs can be made more simple, more general, and more easy to change.", "num_citations": "5\n", "authors": ["2221"]}
{"title": "UNDERSTANDING HOW AGILE TEAMS MANAGE KNOWLEDGEIN GLOBAL SOFTWARE DEVELOPMENT\n", "abstract": " Collocated Agile teams gather, store, share, and use invaluable knowledge through face-to-face interaction, frequent communication and close collaboration among team members. Several studies, however, point out that managing knowledge in global software development is difficult due to the spatial, temporal and socio-cultural distances among team members. Through a Grounded Theory study that involved 55 participants from 38 different software companies in the USA, India and Australia, we discovered the key concern of Agile teams in global software development. In this paper, we explicate how Agile teams manage knowledge in global software development.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "The Grace Programming Language Draft Specification Version 0.3. 53\n", "abstract": " This is a specification of the Grace Programming Language. This specification is notably incomplete and everything is subject to change. In particular, this version does not address the library, nested static type system, module system, metadata, immutable data and pure methods, and other areas. For discussion and rationale, see http://gracelang. org.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Exploring the inventor's paradox: applying jigsaw to software visualization\n", "abstract": " Software visualization research has typically focussed on domain specific tools and techniques. In this paper, we evaluate applying a general purpose visual analytics tool Jigsaw to visualize the JHotDraw open source software system. We describe how Jigsaw can be applied to visualize software, and show how it can support some program comprehension tasks.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "The myths of object-orientation\n", "abstract": " Object-Orientation is now over forty years old. In that time, Object-Oriented programming has moved from a Scandinavian cult to a world-wide standard. In this talk I\u2019ll revisit the essential principles \u2014 myths \u2014 of object-orientation, and discuss their role in the evolution of languages from SIMULA to Smalltalk to C+\u2009+ to Java and beyond. Only by keeping the object-oriented faith can we ensure full-spectrum object-oriented dominance for the next forty years in the project for a new object-oriented century!", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Exception handling bug patterns in aspect oriented programs\n", "abstract": " Aspects often impact the exceptional control flow of a program by signaling and handling exceptions signaled by other aspects or classes. The exceptions signaled by aspects may flow through the program execution in unexpected ways leading to failures such as uncaught exceptions and exceptions being caught by the wrong handlers. We identified a set of bug patterns via an empirical study of exception handling code in AO systems. These patterns are presented here in the form of a bug patterns catalogue containing bugs where aspects act as exception handlers, and bugs where aspects act as exception signalers.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Experience on the human side of agile\n", "abstract": " This brief paper describes an XP2008 conference workshop on the subject of experience on the human side of agile development. By this, we include such topics as the customer role, user interaction design, and the social nature of teams. The workshop will allow practitioners and researchers interested in these topics to develop a common map of resources, and a model to assist collaboration on further exposition and study.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "First-class relationships in object oriented programs\n", "abstract": " Relationships have been an essential component of OO design since the 90s, yet mainstream OO languages still do not support first-class relationships. Most programs implement relationships in an ad-hoc fashion which results in unnecessarily complex code. We examine the requirements for a good first-class relationship abstraction and compare this with existing work. These requirements serve both as a specification and a progress metric for adding first-class relationships to OO languages.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "X3d-earth in the software visualization pipeline\n", "abstract": " We need tools and new ways to visualize our software execution traces and to deploy and integrate the visualizations into users\u2019 environments. We are currently implementing existing information visualization 3D metaphors using X3D to visualize our execution traces, however most of these metaphors are principly node-link diagrams or graph structures and are not easy to interpret nor understand. We want to use real world metaphors which users can easily relate to, such as a 3D city metaphor. One tool for implementing the 3D city metaphor could be the open source X3D-Earth application. In this paper we list the requirements for an X3D-Earth application which could be used for visualizations of static and dynamic information of software.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Through a Glass, Darkly\n", "abstract": " For now we see through a glass, darkly; but then face to face: now I know in part; but then shall I know even as also I am known.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Natural Creation-a composite pattern for creating objects\n", "abstract": " Objects must be created throughout object-oriented programs. Programming languages provide special facilities to create and initialise objects, and creational design patterns allow these facilities to be used more flexibly. The Natural Creation pattern describes how these facilities can be used to create objects in ways that model the natural semantics of the program's underlying domain. By applying the Natural Creation pattern, programs and designs can be made more simple, more general, and easier to understand.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Effective synchronisation of concurrent objects: laying the inheritance anomaly at rest\n", "abstract": " The integration of concurrency and object-oriented programming has been a goal of researchers for over a decade. To date, attempts to address reuse conflicts, known as \u201cinheritance anomalies\u201d, have been limited in applicability and have not addressed all the issues that synchronisation raises. In this paper we take a detailed look at synchronisation by investigating five different aspects which must be considered. We investigate the different forms of the inheritance anomaly which can arise and look at how they can be avoided, either through the use of specific features of concurrent object-oriented languages, or common techniques of object-oriented programming. Finally we present a set of requirements for a concurrent object-oriented language to support a flexible concurrency model with an emphasis on the reuse of both synchronisation and functional code.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Prototype based user interfaces\n", "abstract": " Many graphical interfaces are based upon classes and instances. Users of these interfaces must understand the di erent r^ oles of classes and instances, and how they are related. Interface designs based on prototypes may suit many users better than class based interfaces. Prototype based user interfaces are simpler than class based interfaces, and so can be faster to learn and easier to use.", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Shaping object-oriented programs\n", "abstract": " Object-oriented programming is valued for the clarity and maintainability of its programs. However, this success is mainly con ned to smallscale phenomena, such as re-implementation of a single class: large-scale structures are as obscure and fragile as ever. We o er shape theory as a means of reasoning about program structure, and improving objectoriented design. In particular, shape analysis should improve debugging and compilation, and shape polymorphism should support greater re-use of programs, despite large-scale structural changes.Object-orientation (OO) uses classes to structure programs. During execution of a program, instances of class, called objects are manipulated within an object graph, whose edges represent interobject references or dependencies. OO has been very successful in organising programming on a small scale, at the level of one class or object, but reasoning about large programs remains as di cult as ever. For example, small changes to the class structure can necessitate changes throughout a program. These problems reduce the reliability of software, and increase the costs of program construction, testing and maintenance. We will tackle these issues by considering the whole object graph of a program, rather than its individual classes or objects, as in existing semantics 4]. The object graph has nodes given by objects, and edges given by interobject references. The key point of our approach is to divide the objects into two kinds: those that express structure, typically container objects, and those used to represent a datum that can be stored in such a structure. We call these shape objects and data objects\u00a0\u2026", "num_citations": "4\n", "authors": ["2221"]}
{"title": "Design patterns for angular hotdraw\n", "abstract": " The number of web frameworks available for use is growing. Web developers need to learn how to use them effectively and efficiently. Working through the design patterns presented in this paper for the Angular Hotdraw application assists web developers in this task. Web developers should be able to make a start with a the Angular web framework and have a foundation to learn from.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Livecoding the SynthKit: Little bits as an embodied programming language\n", "abstract": " LittleBits (little Bits.cc) is an open-source hardware library of pre-assembled analogue components that can be easily assembled into circuits, disassembled, reassembled, and re-used. In this paper, we consider littleBits - and the littleBits SynthKit in particular -- as a physically-embodied domain specific programming language. We describe the littleBits system, explain how littleBits \"programs\" are constructed as configurations of physical modules in the real world, and describe how they are typically used to control physical artefacts or constructions. We then argue that littleBits constructions essentially \"visualise themselves\". We describe how littleBits' liveness, embodiment, and plasticity assists both learning and debugging, and then evaluate littleBits configurations according to the cognitive dimensions of notations.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Technical Report 12-08: Knowledge Management in Distributed Agile Software Development\n", "abstract": " Software development teams need highly valuable knowledge to carry out knowledge-intensive development activities. Agile teams are cross-functional teams that promote sharing of projectspecific knowledge through frequent face-to-face interaction, effective communication and customer collaboration. Knowledge sharing is difficult for distributed Agile teams due to spatial, temporal, and cultural barriers, which negatively affect face-to-face interaction, communication and collaboration. There seems to be very few studies that focus on knowledge management in distributed Agile teams. Through a Grounded Theory study that involved 45 participants from 28 different software companies in the USA, India and Australia, we investigate distributed software development from the specific perspective of Agile teams. In this paper, we describe how Agile teams gather, store, share and use knowledge in distributed software development.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Application of pure aspect-oriented design patterns in the development of ao frameworks: a case study\n", "abstract": " The paper discusses results of a case study on the advantages applying pure aspect design patterns in the development of aspect-oriented (AO) application frameworks. By an AO application framework we mean a framework which, alongside with traditional object-oriented (OO) framework customization mechanisms, provides also abstract aspects as hot spots. We have tested the hypothesis that pure AO design patterns should promote the ease of designing collaborating abstract aspects representing hot spots. To this end, we studied the process of reworking of the OO simulation application framework into the AO framework. During this study, appropriate qualitative and quantitative data have been collected. The paper presents the generalization of the collected data and concludes that the above hypothesis has been proven.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "The roles of owners\n", "abstract": " Ownership types were proposed to characterize the topology of objects on the heap. They notionally organize objects into boxes, and each box belongs to an object\u2013its owner. In most ownership-based systems, the box protects the object from its environment in some way. Thus, the owner may play the owners-as-dominators role, whereby the owner restricts access to the objects in a box,(ie the \u201coutside\u201d may not access the \u201cinside\u201d), or, the owner may play the owners-as-modifiers role, whereby the owner restricts modification of the objects in a box (ie the \u201coutside\u201d may not modify the \u201cinside\u201d). We propose the dual protection, whereby the box protects the environment from the object. We suggest two further roles: in owners-as-restrictors, the owner restricts access from the object (ie the \u201cinside\u201d may not access the \u201coutside\u201d), and in owners-as-filters, the owner restricts the range of modifications from an object (ie the \u201cinside\u201d may not modify the \u201coutside\u201d). We explore the design space for possible exact meanings for the four roles. We define the meanings of these roles in terms of the guarantees they make about the heap and about executions. We sketch parts of a language which supports all four roles, and which allows any of the owner parameters to play any of these four roles. These roles may be enforced statically, dynamically, or via a combination of both.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Implementing relationships using affinity\n", "abstract": " OO languages typically provide one form of object equality, known as reference equality, where two objects are equal only if they are the same object; two objects which are structurally identical are not considered equal. Thus, programmers who require a more refined notion of equality must define their own operator. Programmer-implemented equality operators tend to rely on informal notions of partial and temporal object immutability which are prone to error. This is a particular problem for objects used in collections which depend on equality. This paper discusses Affinity: an untyped, object-oriented language with a powerful equality operator based on EGAL [2] and support for object-keying and immutability. Affinity is designed to provide coherent and elegant support for object equality, reducing programmer burden and error potential.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Aliasing, Confinement, and Ownership in Object-Oriented Programming Report on the Workshop IWACO'08 at ECOOP 2008\n", "abstract": " The power of objects lies in the flexibility of their interconnection structure. But this flexibility comes at a cost. Because an object can be modified via any alias, object-oriented programs are hard to understand, maintain, and analyze. Aliasing makes objects depend on their environment in unpredictable ways, breaking the encapsulation necessary for reliable software components, making it difficult to reason about and optimize programs, obscuring the flow of information between objects, and introducing security problems. Aliasing is a fundamental difficulty, but we accept its presence. Instead we seek techniques for describing, reasoning about, restricting, analyzing, and preventing the connections between objects and/or the flow of information between them. Promising approaches to these problems are based on ownership, confinement, information flow, sharing control, escape analysis, argument independence, read-only references, effects systems, and access control mechanisms.\u00a9 2009 Springer Berlin Heidelberg.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Web Software Visualization Via Google\u2019s Visualization API\n", "abstract": " There exist very few toolkits and libraries that make it easy for developers to create visualizations of empirical software metrics data. For this reason the use of software visualization tools is not wide-spread within the software development industry. We are exploring creating visualizations of software metrics using the Google Visualization API for the purposes of visual software analytics. We present examples illustrating what the API is capable of and give some indication as to how it might be used for software visualization in the hope it will help inform developers.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Program trace formats for software visualisation\n", "abstract": " Developers must understand a software component or piece of code before they can reuse it. Software visualisation has the potential to assist this understanding by visualising the internal structure and behaviour of components. However it is difficult to create visualisations. We create visualisations by test driving reusable components, and store the output in a formal, transportable, and filterable program trace format. Using our intermediary program trace formats, static and dynamic information of a component can be transformed into useful visualisations either at real time or in the future for developers to understand.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Using a system of tutorials and groups to increase feedback and teach user interface design\n", "abstract": " Offering a new course on user-interface design presents several problems for a Computer Science department. As well as building student competency in user interface design and user interface evaluation, the course must give timely feedback to students while ensuring that staff and student workload remains manageable. We developed a course that uses a novel system of tutorials and group work to increase feedback about design to students and control both staff and student workload. We plan to extend this approach to other courses where design and group work are important components.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Generic ownership: practical ownership control in programming languages\n", "abstract": " This research abstract outlines the work I plan to do as part of my PhD. In particular, I propose to devise a practical way of integrating ownership control into existing programming languages in a way that will help with adoption of ownership in the general programming community.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Visualisation for learning oop, using aop and eclipse\n", "abstract": " This paper outlines our project to help beginners learn to program by showing object visualisations driven by aspect-oriented programming, and presented as part of the Eclipse development platform. The aspect-oriented programming is part of the infrastructure we use to drive the visualisations that help students learn object-oriented programming. Aspect-oriented programming explicitly supports the kind of cross-cutting concerns that allows our system to drive visualisations that emphasise principles of object interaction. Our extensions to Eclipse allow us to provide this educational scaffolding to help learners, without altering the program, the programming language or the libraries.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Metaphors for electronic music production in live and reason\n", "abstract": " Electronic music production was originally accomplished using a variety of electronic components and conventional analogue recording techniques. Currently, both the electronic components and the recording equipment are being replaced by computer software. In this paper we present a comparative study of two popular systems, Reason and Live, by focusing on the role of user-interface metaphors. We compare the two systems, identify the key ways metaphor is used, and describe how it affects usability of the systems focusing on the role that userinterface metaphor play in their design.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Attack of the Clones\n", "abstract": " Self is a prototype-based programming language, often described as More Smalltalk Than Smalltalk. This paper presents implementations of a selection of the Design Patterns in Self, and investigates the differences between their implementations in Self compared with other object-oriented programming languages.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Interface Ontology: Creating a Physical World for Computer Interfaces.\n", "abstract": " Interaction patterns are often used to present existing knowledge about user-interfaces in a generalised, but well-defined manner. Such patterns provide insight into the practises and assumptions of the design community. This paper presents a small number of patterns based on the concept of physical ontology. That is, the paper puts forward patterns in which computing concepts in a program are explained to the user through basic physical metaphors. The end result is an initial foray into uncovering the physical basis of the user-interface.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Teaching the evaluation of object-oriented designs\n", "abstract": " This paper describes an approach to teaching evaluation of object-oriented designs, using well known design heuristics along with a process for heuristic evaluation. This is based on work introducing object-orientation to industry groups, and is motivated by our observations about the needs for design evaluation in industry, but we have applied the same approach in our university teaching. We have found the approach useful in explicitly addressing an undervalued step in software development, and one that deals with object-oriented design explicitly, while not involving any unproven radical elements.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Techniques for active learning of oo development\n", "abstract": " \u042f \u0437 \u0436 \u0433\u0439\u0436 \u0439\u0437 \u0433 \u0438 \u043a \u0430 \u0436\u0432 \u0432 \u0438 \u0432 \u0435\u0439 \u0437 \u0438\u0433 \u0438 \u0427\u0427 \u043a \u0430\u0433\u0434\u0431 \u0432\u0438\u041a \u042f \u043a \u043a \u0430\u0433\u0434 \u0432 \u043b \u0438 \u0432 \u0435\u0439 \u0437\u0418 \u0434\u0438 \u0436\u0433\u0431 \u042a \u0436 \u0437\u0418 \u0438\u0433 \u0438 \u0439\u0437 \u0437 \u0437 \u0433\u0436 \u0436 \u0435\u0439 \u0436 \u0431 \u0432\u0438\u0437 \u0438 \u0436\u0419 \u0432 \u041a \u042f \u043a \u0430\u0437\u0433 \u0434\u0438 \u042a \u0436 \u0437 \u0438\u0433 \u0438 \u0438 \u0434\u0436 \u0432 \u0434\u0430 \u0437 \u0433 \u0427\u0427\u041a \u0427\u0439\u0436 \u0434\u0434\u0436\u0433 \u0437 \u0432 \u0438\u0436 \u043b \u0438 \u0430 \u0436 \u0439\u0432 \u043a \u0436\u0437 \u0438\u043d \u0430 \u0437\u0437 \u0437 \u0437 \u043b \u0430\u0430 \u0437 \u0432 \u0439\u0437\u0438\u0436\u043d \u0436\u0433\u0439\u0434\u0437\u0418 \u0434\u0436\u0433 \u0436 \u0431\u0431 \u0436\u0437 \u0437 \u043b \u0430\u0430 \u0437 \u0439\u0437 \u0432 \u0437\u0437 \u0432 \u0430\u043d\u0437\u0438\u0437 \u0432 \u0431 \u0432 \u0436\u0437\u041a", "num_citations": "3\n", "authors": ["2221"]}
{"title": "A mode system for flexible alias protection\n", "abstract": " Object-oriented programming languages allow inter-object aliasing to represent linked data structures and networks of interacting objects. Aliasing complicates formal reasoning about programs, as it can occur anywhere in a program. In our mode system programs are annotated with modes that indicate object ownership and control the extent of object aliases. By localising aliases, our mode system provides a context for formal reasoning about object systems. Being statically checkable our system offers a practical target for the formal refinement of object-based specifications.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Patterns for finding objects within designs\n", "abstract": " To design a program, first find your objects. Unfortunately, the right objects are not easy to find, and as a result most programs are not as well designed as they could be. This paper presents four patterns which describe how objects can be found within the designs of existing programs. By using these patterns, programs and designs can be made more simple, more general, and more easy to change.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "Encapsulators in self\n", "abstract": " Encapsulators are objects which transparently monitor other objects. Being concerned with individual objects, encapsulators do not t well within class-based languages such as Smalltalk. They are conceptually much closer to prototype based languages, such as Self, and should be much easier to build in such a language. Examining designs for encapsulators in Self illustrates some of the strengths and weaknesses of encapsulators, the Self language design, and the prototype-based approach.", "num_citations": "3\n", "authors": ["2221"]}
{"title": "First-class dynamic types\n", "abstract": " Since LISP, dynamic languages have supported dynamically-checked type annotations. Even in dynamic languages, these annotations are typically static: tests are restricted to checking low-level features of objects and values, such as primitive types or membership of an explicit programmer-defined class.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Reforming performance appraisal for Agile software development projects\n", "abstract": " Changes in software development methods should lead to changes in an organization\u2019s performance appraisal system. Several organizations, however, have adopted Agile software development methods without reforming their performance appraisal. Performance appraisal should be aligned to Agile values, principles, and practices, which advocate interactions, collaborations, teamwork, and knowledge transfer. Through a Grounded Theory study involving 48 Agile practitioners and external specialists, we discovered two major changes to performance appraisal for Agile teams: integrating individual and team performance assessment criteria, and shifting from quantitative to qualitative measurement of performance. Our findings indicate that reforming performance appraisal tends to influence successful expertise coordination in Agile teams. This study can be a baseline in generating an Agile-compliant performance appraisal to assess Agile team members in a fair and consistent manner. This indirectly increases motivation amongst team members and tends to produce capable workforce to perform at a higher level.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Abstract data types in object-capability systems\n", "abstract": " The distinctions between the two forms of procedural data abstraction--abstract data types and objects--are well known. An abstract data type provides an opaque type declaration, and an implementation that manipulates the modules of the abstract type, while an object uses procedural abstraction to hide an individual implementation. The object-capability model has been proposed to en-able object-oriented programs to be written securely, and has been adopted by a number of practical languages including JavaScript, E, and Newspeak. This short paper addresses the question: how can we implement abstract data types in an object-capability language?", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Operators and precedence in programming languages\n", "abstract": " An incorrect understanding of operators and precedence can create bugs in programs. The purpose of this study is to explore programmers understanding, interpretation and perception of operators and precedence issues. Parentheses have the highest precedence in programming languages. So, the important of parentheses in expressions will be tested. The findings may lead to an improvement to rules for operators and precedence in programming languages. The findings will also provide both theoretical analyses and guidelines for developers and language designers.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "From APIs to languages: generalising method names\n", "abstract": " Method names with multiple separate parts are a feature of many dynamic languages derived from Smalltalk. Generalising the syntax of method names to allow parts to be repeated, optional, or alternatives, means a single definition can respond to a whole family of method requests. We show how generalising method names can support flexible APIs for domain-specific languages, complex initialisation tasks, and control structures defined in libraries. We describe how we have extended Grace to support generalised method names, and prove that such an extension can be integrated into a gradually-typed language while preserving type soundness.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Reconciling Architecture and Agility: What Matters?\n", "abstract": " A key feature of agile software development is its prioritisation of responding to changing requirements over planning ahead. If an agile development team spends too much time planning and designing architecture then responding to change will be extremely costly, while not doing enough architectural design puts the project at risk of failure. The team must therefore find a balance. This Grounded Theory research has identified four contexts that can affect that balance: unstable requirements, early value, team experience and non agile environments. Agile teams can address these contexts through the use of one or more of five strategies: use modern vendor frameworks, do no up-front planning, plan for options, address technical challenges, and do a full up-front design. System complexity is also a strong factor in how much architecture effort is required; size does not have a direct impact.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Roles for Owners\u2013Work in Progress\u2013\n", "abstract": " Ownership types were proposed to characterize the topology of objects on the heap. They notionally organize objects into boxes, and each box belongs to an object\u2013its owner. In most ownership-based systems, the box protects the object from its environment in some way. Thus, the owner may play the owners-as-dominators role, whereby the owner restricts access to the objects in a box,(ie the \u201coutside\u201d may not access the \u201cinside\u201d), or, the owner may play the owners-asmodifiers role, whereby the owner restricts modification of the objects in a box (ie the \u201coutside\u201d may not modify the \u201cinside\u201d). We propose the dual protection, whereby the box protects the environment from the object. We suggest two further roles: in owners-as-restrictors, the owner restricts access from the object (ie the \u201cinside\u201d may not access the \u201coutside\u201d), and in owners-as-filters, the owner restricts the range of modifications from an object (ie the \u201cinside\u201d may not modify the \u201coutside\u201d). We explore the design space for possible exact meanings for the four roles. We define the meanings of these roles in terms of the guarantees they make about the heap and about executions. We sketch parts of a language which supports all four roles, and which allows any of the owner parameters to play any of these four roles. These roles may be enforced statically, dynamically, or via a combination of both. 1.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Ownership meets java\n", "abstract": " Ownership Generic Java (OGJ) is a language with ownership types as an extension to Java. In this position paper we outline the state of OGJ. We hope that the other aliasing and ownership researchers would benefit from the discussion around how to add ownership into a modern generic and annotation-capable typed object-oriented language like Java.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Get Out Of My Way! Exploring Obstruction in Popular Video Games\n", "abstract": " Video games are full of obstructions. From aliens with laserguns to the architecture of a game world, obstruction is an acknowledged element of all games, but is rarely considered in isolation or in detail. It is critical to understand obstruction in video games not only abstractly, but in terms of player experience. We present qualitative data from players of five popular games to examine the role of obstruction in shaping gameplay. The resulting experience-driven understanding is relevant to both analysis and design.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Efficient multimethods in Smalltalk-80\n", "abstract": " Smalltalk-80 is a pure object-oriented language in which messages are dispatched according to the class of the receiver, or first argument, of a message. Object-oriented languages that support multimethods dispatch messages to all their arguments. While Smalltalk does not support multimethods, Smalltalk's reflective facilities allow programmers to efficiently add them to the language. This paper explores several ways in which this can be done, and the relative efficiency of each.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "A web user interface for an interactive software repository\n", "abstract": " Using tools aimed at promoting the reuse of existing components costs the user in the time and effort needed to install and understand the tool. These costs could counteract or subsume the benefits of reuse argued for by reuse practitioners, rendering the activity worthless. One approach to reducing these costs is to deploy the tools in an environment that the user is already familiar with, and has easy access to. We have chosen the web as just such an environment, and this choice can have a significant impact on the usability and utility of the tool. This paper discusses the difficulties that arise from our use of the web, and the manner in which we have partly overcome these difficulties.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "HOW DO XP, SCRUM AND ASD BUILD THE RIGHT SOFTWARE?\n", "abstract": " This position paper explores a particular area within software development: requirements analysis and management. We specifically focus on only three agile methods, XP, Scrum and ASD. These methods all highlight, in their respective books [1, 2, 3], the requirements difficulties often encountered in traditional development. The next sections cover how XP, Scrum and ASD address these difficulties.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Tool support for traceability between requirements and design\n", "abstract": " Traceability is the ability to determine relationships between different development artifacts in the software development process. Being able to automatically trace from the requirements through to the implementation allows questions such as \u201cAre all the requirements met by the implementation\u201d to be reliably answered. While answers to such questions are important for managing the quality of both the process and the product, gathering and managing the relationships that allows such automatic checking can be expensive, making it less clear that the benefit justifies the cost. The creative nature of design means that the relationships between requirements and design cannot be derived automatically, and so their management cost is high. We use a design technique that, with appropriate tool support, can significantly reduce that cost. It represents the requirements using a particular kind of use case, and develops an object-oriented design. We present", "num_citations": "2\n", "authors": ["2221"]}
{"title": "The Objects of Aliasing\n", "abstract": " Aliasing is fundamental to object-oriented systems: every object has an identity, and since by that identity an object can be referenced from anywhere within the program, then the object could be aliased from anywhere within the program. By complicating the relationship between the static program text and its dynamic execution, aliasing makes programs harder to understand, to modify, and especially to debug. In this position paper, we describe some of the objectives of studying aliasing in object-oriented programs, and attempt to outline the major options for managing aliasing.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Who's Afraid of Ownership Types?\n", "abstract": " Ownership Types prevent representation exposure-unauthorised access to the encapsulated implementation of an object. Unfortunately, existing ownership type systems are too strict, do not support subtyping, and exclude many important object-oriented idioms, such as iterators, objects with multiple interfaces, and initialisation with pre-existing objects. We develop a more flexible model of containment by abstractly modeling the two sides of object access, that is, which objects an object can access and which objects can access it. Using a variant of Abadi and Cardelli's object calculus as a vehicle, we provide an account of object ownership which supports subtyping and allows more flexible object graph structure.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Objects and constraints\n", "abstract": " An object oriented program is a set of communicating encapsulated objects, while a constraint program is a set of variables linked by constraints. This difference in underlying models makes it difficult to combine objects and constraints in the same program. Message constraints are constraints that access objects by message sending and treat objects as abstractions. Message constraints can be attached directly to existing objects in object oriented programs without modifying those objects, seemingly providing the benefits of constraint programming within object oriented programming languages.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Dynamic alias protection in prototype-based languages\n", "abstract": " One of the advantages of prototype-based languages is that they provide self-sufficient objects which do not depend on classes or other objects for their definitions. But objects can refer to other objects, and the effects of these inter-object references introduce arbitrary, uncontrolled dependencies between objects. We propose adding an explicit notion of object ownership to control dependencies and references between objects. Object ownership can also enhance object cloning and avoid the prototype corruption problem, making programs easier to write and easier to understand.", "num_citations": "2\n", "authors": ["2221"]}
{"title": "Why do programmers do what they do? a theory of influences on security practices\n", "abstract": " Technologies are continually adapting to match ever-changing trends. As this occurs, new vulnerabilities are exploited by malicious attackers and can cause significant economic damage to companies. Programmers must continually expand their knowledge and skills to protect software. Programmers make mistakes, and this is why we must interpret how they implement and adopt security practices. This paper reports on a study to understand programmer adoption of security practices. We identified a theory of inter-related influences involving programmer culture, organizational factors, and industry trends. Understanding these decisions can help inform organizational culture and education to improve software security.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Towards Gradual Checking of Reference Capabilities\n", "abstract": " Concurrent and parallel programming is difficult due to the presence of memory side-effects, which may introduce data races. Type qualifiers, such as reference capabilities, can remove data races by restricting sharing of mutable data. Unfortunately, reference capability languages are an all-in or nothing game, i.e., all the types must be annotated with reference capabilities. In this work in progress, we propose to mix the ideas from the reference capability literature with gradual typing, leading to gradual reference capabilities.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Hacking with multi-touch for java (MT4J)\n", "abstract": " Developing applications for touch devices is hard. Developing touch based applications for multi-user input is harder. The Multi-Touch for Java (MT4j) toolkit supports developing touch based applications for multiple users. In this paper, we outline our experience using MT4j for developing a number of software applications to support developers working in co-located teams. Our experience using the toolkit will help developers to understand the nuances of the toolkit and design issues that can be applied to other toolkits for developing multi-user touch based applications.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Object creation in Grace\n", "abstract": " We are engaged in the design of Grace, a new object-oriented open source programming language aimed at instructors and students in introductory programming courses. Grace aims to include features that have been found useful in software practice, while allowing multiple different teaching approaches without requiring that concepts be introduced to students before they are ready. While many aspects of Grace's design will be familiar to most object-oriented programmers, Grace cleanly separates the concepts of\" object\",\" class\", and\" type\", and so Grace offers more options for creating objects than most other languages. We have written these patterns to explain how Grace programmers should go about creating objects.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "[Demo abstract] LittleBits synth kit as a physically-embodied, domain specific functional programming language\n", "abstract": " littleBits (littleBits. cc) is an open-source hardware library of pre assembled analogue components that can be easily assembled into circuits, disassembled, reassembled, and re-used. In this demo, we consider littleBits---and the littleBits synth kit in particular---as a physically-embodied domain specific functional programming language, and how littleBits circuits can be considered as monadic programs.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "The Grace programming language, draft specification version 0.5. 1853\n", "abstract": " This is a specification of the Grace Programming Language. This specification is notably incomplete, and everything is subject to change. In particular, this version does not address:", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Should software conferences respect software?\n", "abstract": " A new trend in software engineering and programming language conferences is to investigate the reproducibility of research results. This trend has led to the creation of Artifact Evaluation Committees at several conferences, including OOPSLA this year. What is the motive behind these committees? How should they be structured? Do they help? Can they hurt? And should software be given more respect, at least at conferences devoted to the study of software, or should papers remain supreme? These are some of the questions that addressed in this panel. Shriram Krishanamurthi argues in favor of the new process and James Noble plays devil's advocate. The panel is moderated by Jan Vitek.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Graceful patterns for patterns in Grace\n", "abstract": " Grace is a new object-oriented programming language aimed at education. Here we describe patterns relating to pattern-matching in this language.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Sheep cloning with ownership types\n", "abstract": " Object-oriented programmers often need to clone objects. Mainstream languages, such as C# and Java, typically default to shallow cloning, which copies just one object and aliases references from that object. Other languages, such as Eiffel, provide deep cloning. A deep clone is a copy of the entire object graph reachable from the cloned object, which could include many unnecessary objects. Alternatively, programmers can implement their own object cloning functions, however, this is often difficult and error prone.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "ECOOP 2012--Object-Oriented Programming: 26th European Conference, Beijing, China, June 11-16, 2012, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 26th European Conference on Object-Oriented Programming, ECOOP 2012, held in Beijing, China, in June 2012. The 27 revised full papers presented together with two keynote lectures were carefully reviewed and selected from a total of 140 submissions. The papers are organized in topical sections on extensibility, language evaluation, ownership and initialisation, language features, special-purpose analyses, javascript, hardcore theory, modularity, updates and interference, general-purpose analyses.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Technical Report 12-07: Understanding lack of trust in distributed agile teams: A grounded theory study\n", "abstract": " Background: Trust fuels team performance and contributes to build an effective and cohesive team. The self-organizing and collaborative nature of Agile teams increases the importance of trust in software development teams. Trust is, however, affected in distributed teams. Aim: Through a Grounded Theory study we investigate the impact of trust in distributed Agile teams. Method: We interviewed 45 Agile practitioners from 28 different software companies in the USA, India and Australia, over a period of 3 years, using semi-structured open-ended questions. Results: In this paper, we present the reasons for lack of trust and its adverse effects in distributed Agile teams that emerged from the analysis, using the causal-consequences theoretical model. Conclusion: Understanding the causes and consequences of lack of trust can develop awareness of the importance of trust in distributed teams and pave ways for effectively building trust in project-oriented contexts.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Use Case Cards and Roleplay for Object Oriented Development\n", "abstract": " This paper presents a technique involving index cards and roleplay to assist in making use case development more accessible and better guided. The technique is based on the established CRC card technique used for object-oriented design. In our technique, essential use cases are recorded on cards, and roleplay is used for development and review. The paper presents the technique, and outlines our experience in applying it. We found the technique did achieve the expected benefits, and was especially useful in determining the system boundary. We also saw other significant benefits, some relating especially to the nature of essential use cases.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "SourceVis: a tool for multi-touch software visualization\n", "abstract": " Most software visualization systems and tools are designed from a single-user perspective and are bound to the desktop and Integrated Development Environments (IDEs). These design decisions do not allow users to easily navigate through software visualizations or to analyse software collaboratively. We have developed SourceVis, a collaborative multi-touch software visualization prototype for multi-touch tables. In this paper we describe the visualizations and interaction capabilities of our prototype.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Designing the Next Educational Programming Language\n", "abstract": " Object-oriented programming is widely taught in introductory computer science courses, however no existing objectoriented programming language is \u201cthe obvious choice\u201d for a teaching language. This makes it harder to transfer skills, techniques, and teaching materials between courses and between institutions, and leaves employers uncertain what they should expect new graduates to know. We believe that the object-oriented programming languages community should take this opportunity to work together to select, shape, or design the next educational programming language, and propose a set of principles that the language should follow. The purpose of this panel is to start a dialog with the educational community to refine these principles and to consider next steps.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Wikipublisher: a print-on-demand Wiki\n", "abstract": " Web and print exist as two solitudes: printed web pages often disappoint and converting print documents into good web pages is hard. A wiki makes it easy for authors to create rich web content, but is little help if readers wish to print the results. Wikipublisher lets readers turn wiki pages or page collections into print, with a quality better than most word processing documents. This lowers the time and cost of creating online and print versions of the same content, with no loss of quality in either medium.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "X3D web software visualization in action!\n", "abstract": " 3D web software visualization has always been expensive, special purpose, and hard to program. Most of the technologies used require large amounts of scripting, are not reliable on all platforms, are binary formats, or no longer maintained. We can make 3D software visualization of object-oriented programs cheap, portable, and easy by using X3D, which is a new open standard for web 3D graphics. In this film we show our X3D web software visualizations in action.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Point/Counterpoint\n", "abstract": " About halfway down the first page of Design Patterns, the authors ask a question:\u201cExperienced designers evidently know something inexperienced ones don\u2019t. What is it?\u201d This isn\u2019ta new question, nor is it unique to software. What do chess grandmasters know about chess that schoolchildren don\u2019t? What do old masters know that their apprentices don\u2019t? What do the engineers of the iPod, 747, or the InterCityExpress know that their unsuccessful competitors don\u2019t? The answer is more than the \u201crules of the game,\u201d the fundamental mathematical or physical principles that underlie the engineering disciplines, market research, consumer psychology, or luck. For a great design, all these are necessary but not sufficient. The extra ingredient\u2014and, of course, the answer to the question posed in Design Patterns\u2014is an understanding of past designs, past practice, which designs have succeeded, which designs have failed, and why. So, a chess grandmaster will understand the attacks, defenses, and patterns of play; aspiring artists sit in front of old masters in galleries or studios and copy their brushwork; and engineers study key innovations from existing designs and incorporate them into their own work. And, quite simply, this is what the 23 patterns in the Gang of Four\u2019s landmark book managed to do. They captured emerging \u201cbest practice\u201d for solving particular design problems. For example, Iterator, Observer, and Composite are all built into the designs of industry-standard libraries, and you can\u2019t be a competent programmer without understanding them. These patterns aren\u2019t just about extensibility; they\u2019re about object-oriented modeling. If you have to\u00a0\u2026", "num_citations": "1\n", "authors": ["2221"]}
{"title": "X3D Web Based Algorithm Animation\n", "abstract": " 3D web software visualization has always been expensive, special purpose and hard to programme. Flash requires proprietary authoring tools and involves large amounts of scripting to produce 3D effects, Java applets are slow to load and are not reliable on all platforms, and VRML is no longer maintained. We can make 3D software visualization cheap, portable and easy by using X3D, which is a lightweight open standard for web 3D graphics. We have replicated three example algorithm animations from Najork and Brown in X3D which unite multiple views, capture the history of execution, and display additional information. We outline our experience, and discuss the suitability of X3D as an output format for algorithm animation software..", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Tribe: More Types for Virtual Classes\n", "abstract": " Beginning with Beta, a range of programming language mechanisms have been developed to allow inheritance in the presence of mutually dependent classes. This paper presents Tribe, a type system which generalises and simplifies other formalisms of such mechanisms, by treating issues which are inessential for soundness, such as the precise details of dispatch and path initialisation, as orthogonal to the core formalism. Tribe can support path types dependent simultaneously on both classes and objects, which is useful for writing library code, and ubiquitous access to an objects family (= owner), which offers family polymorphism without the need to drag around family arguments. Languages based on Tribe will be both simpler and more expressive than existing designs, while having a simpler type system, serving as a useful basis for future language designs.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Clicki: A framework for light-weight web-based visual applications\n", "abstract": " Web application frameworks typically provide little support for graphical web applications such as diagram editors. This restricts applications developed using these frameworks to either very limited interactions, or using technologies that are only supported by a small subset of web browsers. Clicki is an object-oriented web application framework in the style of traditional graphical user interface frameworks, with minimal requirements on the client web browser. The Clicki framework enables the creation of nontraditional diagram-based web applications within the confines of the architectural constraints imposed by the web.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Using a System of Tutorials and Groups to Teach User Interface Design\n", "abstract": " Offering a new course on user-interface design presents several problems for a Computer Science department. As well as building student competency in user interface design and user interface evaluation, the course must give timely feedback to students while ensuring that staff and student workload remains manageable. We developed a course that uses a novel system of tutorials and group work to increase feedback about design to students and control both staff and student workload. We plan to extend this approach to other courses where design and group work are important components.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Towards a general model for assisting navigation\n", "abstract": " In this paper, we review the principles of navigation, present a general model for supporting navigation in user interface design, and show examples of how the model can be applied. The model has four different properties along which navigational scenarios can be classified. These are: dimensionality, freedom of movement, presentation and reinforcement. We show how use of the model leads to heuristics to help in the design and evaluation of user interfaces that include navigational aspects.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "From hammers to handhelds: opportunities and barriers to mobile communication in the New Zealand building industry\n", "abstract": " From hammers to handhelds: opportunities and barriers to mobile communication in the New Zealand building industry - Kent Academic Repository Skip to main content kent-logo Logo Login Admin Dashboards Help Simple search | Advanced search Home Browse Latest additions Policies Accessibility Statement From hammers to handhelds: opportunities and barriers to mobile communication in the New Zealand building industry Harrison, D., Barnes, Stuart J., Biddle, R., Yoong, P., Noble, J. (2004) From hammers to handhelds: opportunities and barriers to mobile communication in the New Zealand building industry. In: International Postgraduate Research Conference in the Built and Human Environment, Salford. (Unpublished) (The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided) (KAR id:34786) The full text of this publication is not \u2026", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Delegation diagrams: visual support for the development of object-oriented designs\n", "abstract": " Developers have long used pictures to aid design activities and there has been a lot of interest in standard notations for design. We have developed delegation diagrams, a graphical notation that provides visual support for developing object-oriented designs and that makes the relationship between the requirements and the design explicit. We describe both the notation and tool support, and evaluate delegation diagrams using the cognitive dimensions of notations framework.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Visual Program Visualization\n", "abstract": " Domain-specific dataflow visual programming languages are now commonplace throughout the world of computing. Although not the earliest form of visual language (that honor, like so many others, of course is due to Sketchpad [27]) dataflow visual languages are now by far the most common form of visual programming language used in practice. Although they have been mostly unsuccessful as general-purpose programming languages, dataflow visual languages have excelled within specialised niche domains, including information visualisation [22], programmable logic controller programming [15,1], and business process re-engineering [14]. Even in just one domain, computer music, several dataflow visual languages have been successful as products over relatively long terms, including Max [7], Bars-n-Pipes [13], and the topic of this chapter, the visual programming language underlying the Nord\u00a0\u2026", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Tool support for traceability between requirements and design\n", "abstract": " Traceability is the ability to determine relationships between different development artifacts in the software development process. Being able to automatically trace from the requirements through to the implementation allows questions such as``Are all the requirements met by the implementation''to be reliably answered. While answers to such questions are important for managing the quality of both the process and the product, gathering and managing the relationships that allows such automatic checking can be expensive, making it less clear that the benefit justifies the cost. The creative nature of design means that the relationships between requirements and design cannot be derived automatically, and so their management cost is high. We have developed a design technique that, with appropriate tool support, can significantly reduce that cost. We present Ukase, a web-based tool that provides such support.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "More than meets the eye: Explicating the essence of gerontology nursing\n", "abstract": " The purpose of this hermeneutic phenomenological study was to explore the essence of gerontology nursing. This project sought to look beyond the practical tasks and skills of gerontology nursing to reveal what is more than meets the eye and thereby explicate the essence of gerontological nursing practice. Gerontology nursing is troubled by its unpopular status and negative image that in turn has serious implications for the recruitment and retention of nurses who are both willing and able to work in this field of nursing. The purpose for doing this study was to unveil a deeper meaning and understanding of gerontology nursing, thus contributing to its value and worth as a speciality area of nursing. Conversations with four gerontology nurses were taped, transcribed and then analysed using van Manen\u2019s (1990) approach to researching lived experience. From the analysis, four cardinal elements emerged: true acceptance, personal knowing, being present, and being alive. Those four cardinal elements were reworked and further analysed to reveal three central aspects or essences of gerontology nursing. These essences were the centrality of temporality, the interconnectedness of human relationships, and the significance of the lived body. Temporality is demonstrated by nursing application of objective, or clock time, as well as subjectively in regards to the lived time of the clients. Interconnectedness is the lived human relationship between nurse and client and is represented by commitment, presencing/giving of self, connecting, and knowing the client holistically. The third essence is corporeality, which is portrayed by the gerontology nurses\u00a0\u2026", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Three Features for Component Frameworks\n", "abstract": " Component-oriented programming promises to provide many of the bene ts that object-oriented programming has arguably failed to deliver: increased productivity, reliability, and exibility via increased reuse of third-party software. Unfortunately, it is not always clear how componentoriented programming di ers from object-oriented programming, or why component-oriented programming should succeed where object-oriented programming has failed. We identify three technical features which need to be supported by component-oriented programming languages or frameworks| component containment; multiple instances of component interfaces; and interface dispatch| and give examples to show why these features may help component-oriented programming live up to its claims.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Investigating a new entubulation strategy to overcome peripheral nerve injury\n", "abstract": " A study was conducted to gain a better understanding of the important entubulation strategies for nerve regeneration and to ultimately use this strategy in the central nervous system in a spinal cord injury model. The effects of a collagen matrix, PGA guidance fibers and FGF-1 on regeneration were examined in terms of electrophysiology, histology and histomorphometry. Preliminary observations were detailed.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Integrating metric visualisation into a commercial user interface builder\n", "abstract": " Interactive Metric Visualisation gives interface designers information about the usability of their designs, by overlaying usability information into their designs. To date, visualisations have been provided by special purpose prototype software. We describe how visualisations can be integrated into a commercial interface design tool, VisualWorks Smalltalk. This integration provides the benefits of metric visualisation to the users of the tool, illustrates the effort required to support visualisation in similar tools, and will support further experiments with metrics visualisation techniques.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Organising patterns into languages: Towards a pattern language for object oriented design\n", "abstract": " Since the publication of the Design Patterns book, a large number of design patterns have been identified and codified. Unfortunately, these patterns are mostly organised in an ad hoc fashion, making it hard for programmers to know which pattern to apply to any particular problem. We have organised a large number of existing object oriented design patterns into a pattern language, by analysing the patterns and the relationships between them. Organising patterns into languages has the potential to make large collections of patterns easier to understand and to use.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Visualising alignment with adaptive gridlines\n", "abstract": " Adaptive gridlines visualise alignments in graphic designs for diagrams, documents and user interfaces. Adaptive gridlines are particularly useful for drawing the attention of users who are not trained graphic designers to the alignments in their designs.", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Prototype-based programming for abstract program visualisation\n", "abstract": " Program Visualisation uses computer graphics techniques to display com-puter programs. Visualisations can assist programmers in constructing, debugging and maintaining programs, in the same way that scientific or engineering visualisation can assist the study of scientific data or the design of engineering artifacts. Program visualisations can also be used in teaching general principles of computer science, including the design of data structures and algorithms (Brown 1988).", "num_citations": "1\n", "authors": ["2221"]}
{"title": "ECOOP'96 workshop on prototype based object oriented programming\n", "abstract": " In recent years an alternative to the traditional class based object-oriented language model has emerged. In this prototype based paradigm there are no classes. Rather, new kinds of objects are formed more directly by composing concrete, full-fledged objects, which are often referred to as prototypes. When compared to class based languages, prototype based languages are conceptually simpler, and have many other characteristics that make them appealing especially for the development of evolving, exploratory and distributed software systems. The general goal of the workshop was to examine the state-of-the-art in prototype based object-oriented programming, focusing especially on the following question: how to make the prototype based paradigm ready for the prime-time, ie, to match/exceed the requirements and expectations of larger-scale, industrial software developers. We defined several topic areas\u00a0\u2026", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Interactive Design Metric Visualization: Visual Metric Support for User Interface Design\n", "abstract": " Interactive metric visualization is a novel approach providing complex, multi-dimensional feedback on the effects of layout changes in user interface designs. A graphical overlay, based on the underlying rationale of quantitative design metrics, provides immediate feedback, continually guiding designers toward improved layouts. Effective visual metaphors, colour coding, and dynamic updating enable designers to interpret and utilize more complex informatioiv than from simple quantitative data or static overlays. This technique is especially suited to accelerated design and development using modern visual development tools. An experimental prototype for this approach is described and initial experience is reported", "num_citations": "1\n", "authors": ["2221"]}
{"title": "Studying the Language of Programming\n", "abstract": " In this paper we address the study of programming as the use of programming language, and outline how such study might be undertaken. We believe that actual programming practice needs to be studied more and in new ways. We do not suggest venerating any existing practice, but rather exposing it for further study. We believe this approach should be desirable to support in industry practice, and provide a sound basis for academic study and research", "num_citations": "1\n", "authors": ["2221"]}