{"title": "The GROOVE simulator: A tool for state space generation\n", "abstract": " The tool described here is the first part of a\u00a0tool set called GROOVE (GRaph-based Object-Oriented VErification) for software model checking of object-oriented systems. The special feature of GROOVE, which sets it apart from other model checking approaches, is that it is based on graph transformations. It uses graphs to represent state snapshots; transitions arise from the application of graph production rules. This yields so-called Graph Transition Systems (GTS\u2019s) as computational models.", "num_citations": "442\n", "authors": ["671"]}
{"title": "Modelling and analysis using GROOVE\n", "abstract": " In this paper we present case studies that describe how the graph transformation tool groove has been used to model problems from a wide variety of domains. These case studies highlight the wide applicability of groove in particular, and of graph transformation in general. They also give concrete templates for using groove in practice. Furthermore, we use the case studies to analyse the main strong and weak points of groove.", "num_citations": "185\n", "authors": ["671"]}
{"title": "Representing first-order logic using graphs\n", "abstract": " We show how edge-labelled graphs can be used to represent first-order logic formulae. This gives rise to recursively nested structures, in which each level of nesting corresponds to the negation of a set of existentials. The model is a direct generalisation of the negative application conditions used in graph rewriting, which count a single level of nesting and are thereby shown to correspond to the fragment \u2203\u2009\u00ac\u2009\u2203 of first-order logic. Vice versa, this generalisation may be used to strengthen the notion of application conditions. We then proceed to show how these nested models may be flattened to (sets of) plain graphs, by allowing some structure on the labels. The resulting formulae-as-graphs may form the basis of a unification of the theories of graph transformation and predicate transformation.", "num_citations": "165\n", "authors": ["671"]}
{"title": "Fair testing\n", "abstract": " In this paper we present a solution to the long-standing problem of characterising the coarsest liveness-preserving pre-congruence with respect to a full (TCSP-inspired) process algebra. In fact, we present two distinct characterisations, which give rise to the same relation: an operational one based on a De Nicola\u2013Hennessy-like testing modality which we call should-testing, and a denotational one based on a refined notion of failures. One of the distinguishing characteristics of the should-testing pre-congruence is that it abstracts from divergences in the same way as Milner\u2019s observation congruence, and as a consequence is strictly coarser than observation congruence. In other words, should-testing has a built-in fairness assumption. This is in itself a property long sought-after; it is in notable contrast to the well-known must-testing of De Nicola and Hennessy (denotationally characterised by a combination of failures\u00a0\u2026", "num_citations": "162\n", "authors": ["671"]}
{"title": "Model checking graph transformations: A comparison of two approaches\n", "abstract": " Model checking is increasingly popular for hardware and, more recently, software verification. In this paper we describe two different approaches to extend the benefits of model checking to systems whose behavior is specified by graph transformation systems. One approach is to encode the graphs into the fixed state vectors and the transformation rules into guarded commands that modify these state vectors appropriately to enjoy all the benefits of the years of experience incorporated in existing model checking tools. The other approach is to simulate the graph production rules directly and build the state space directly from the resultant graphs and derivations. This avoids the preprocessing phase, and makes additional abstraction techniques available to handle symmetries and dynamic allocation.               In this paper we compare these approaches on the basis of three case studies elaborated in both of\u00a0\u2026", "num_citations": "153\n", "authors": ["671"]}
{"title": "Model checking dynamic states in GROOVE\n", "abstract": " Much research has been done in the field of model-checking complex systems (either hardware or software). Approaches that use explicit state modelling mostly use bit vectors to represent the states of such systems. Unfortunately, that kind of representation does not extend smoothly to systems in which the states contain values from a domain other than primitive types, such as reference values commonly used in object-oriented systems.               In this paper we report preliminary results on applying CTL model checking on state spaces generated using graph transformations. The states of such state spaces have an internal graph structure which makes it possible to represent complex system states without the need to know the exact structure beforehand as when using bit vectors.", "num_citations": "144\n", "authors": ["671"]}
{"title": "Fair testing\n", "abstract": " We investigate the notion of fair testing, a formal testing theory in the style of De Nicola and Hennessy, where divergences are disregarded as long as there are visible outgoing transitions. The usual testing theories, such as the standard model of failure pre-order, do not allow such fair interpretations because of the way in which they ensure their compositionality with respect to abstraction from observable actions. This feature is usually present in the form of a hiding-operator (CSP, ACP, LOTOS) or part of parallel composition (CCS). Its application can introduce new divergences causing semantic complications. In this paper we present a testing scenario that captures the intended notion of fairness and induces a pre-congruence for abstraction.In the presence of a sufficiently strong synchronisation feature it is shown to be the coarsest pre-congruence contained in the (non-congruent) fair version of failure\u00a0\u2026", "num_citations": "119\n", "authors": ["671"]}
{"title": "Action refinement\n", "abstract": " In this chapter, we give a comprehensive overview of the research results in the field of action refinement during the past 12 years. The different approaches that have been followed are outlined in detail and contrasted to each other in a uniform framework. We use two running examples to discuss their effects, benefits and disadvantages. The chapter contains results only; appropriate references are given to the original papers containing the proofs.", "num_citations": "100\n", "authors": ["671"]}
{"title": "Canonical graph shapes\n", "abstract": " Graphs are an intuitive model for states of a (software) system that include pointer structures | for instance, object-oriented programs. However, a naive encoding results in large individual states and large, or even unbounded, state spaces. As usual, some form of abstraction is necessary in order to arrive at a tractable model. In this paper we propose a decidable fragment of first-order graph logic that we call local shape logic               LSL as a possible abstraction mechanism, inspired by previous work of Sagiv, Reps and Wilhelm. An LSL formula constrains the multiplicities of nodes and edges in state graphs; abstraction is achieved by reasoning not about individual, concrete state graphs but about their characteristic shape properties. We go on to define the concept of the canonical shape of a state graph, which is expressed in a monomorphic sub-fragment of LSL, for which we define a graphical\u00a0\u2026", "num_citations": "92\n", "authors": ["671"]}
{"title": "Model checking graph grammars\n", "abstract": " We sketch a setup in which transition systems are generated from graph grammars and subsequently checked for properties expressed in a temporal logic on graphs. We envisage this as part of an approach where graph grammars are used to express the behavioural semantics of object-oriented programs, thus enabling automatic verification of those programs. This paper describes work in progress.", "num_citations": "90\n", "authors": ["671"]}
{"title": "Ensuring structural constraints in graph-based models with type inheritance\n", "abstract": " Graphs are a common means to represent structures in models and meta-models of software systems. In this context, the description of model domains by classifying the domain entities and their relations using class diagrams or type graphs has emerged as a very valuable principle. The constraints that can be imposed by pure typing are, however, relatively weak; it is therefore common practice to enrich type information with structural properties (such as local invariants or multiplicity conditions) or inheritance.               In this paper, we show how to formulate structural properties using graph constraints in type graphs with inheritance, and we show how to translate constrained type graphs with inheritance to equivalent constrained simple type graphs. From existing theory it then follows that graph constraints can be translated into pre-conditions for productions of a typed graph transformation system which\u00a0\u2026", "num_citations": "85\n", "authors": ["671"]}
{"title": "Weakest preconditions for high-level programs\n", "abstract": " In proof theory, a standard method for showing the correctness of a program w.r.t. given pre- and postconditions is to construct a weakest precondition and to show that the precondition implies the weakest precondition. In this paper, graph programs in the sense of Habel and Plump 2001 are extended to programs over high-level rules with application conditions, a formal definition of weakest preconditions for high-level programs in the sense of Dijkstra 1975 is given, and a construction of weakest preconditions is presented.", "num_citations": "64\n", "authors": ["671"]}
{"title": "Defining object-oriented execution semantics using graph transformations\n", "abstract": " In this paper we describe an application of the theory of graph transformations to the practise of language design. In particular, we have defined the static and dynamic semantics of a small but realistic object-oriented language (called TAAL) by mapping the language constructs to graphs (the static semantics) and modelling their effect by graph transformation rules (the dynamic semantics). This gives rise to execution models for all TAAL-programs, which can be used as the basis for formal verification.               This work constitutes a first step towards a method for defining all aspects of software languages, besides their concrete syntax, in a consistent and rigorous manner. Such a method facilitates the integration of formal correctness in the software development trajectory.", "num_citations": "60\n", "authors": ["671"]}
{"title": "Repotting the geraniums: on nested graph transformation rules\n", "abstract": " We propose a scheme for rule amalgamation based on nested graph predicates. Essentially, we extend all the graphs in such a predicate with right hand sides. Whenever such an enriched nested predicate matches (ie, is satisfied by) a given", "num_citations": "55\n", "authors": ["671"]}
{"title": "Explicit state model checking for graph grammars\n", "abstract": " In this paper we present the philosophy behind the GROOVE project, in which graph transformation is used as a modelling formalism on top of which a model checking approach to software verification is being built. We describe the basic formalism, the current state of the project, and (current and future) challenges.", "num_citations": "53\n", "authors": ["671"]}
{"title": "Models and methods for action refinement.\n", "abstract": " Degree: Dr.DegreeYear: 1993Institute: Universiteit Twente (The Netherlands)We address a principle in the functional design of distributed systems called action refinement. This is loosely understood as the principle of implementing abstract actions by way of more complex concrete behaviour. There are many design problems that easily and naturally let themselves be thought of in terms of this kind of implementation. We establish a formal notion of design by action refinement to capture this intuition. This notion is based on so-called vertical implementation relations, which are ternary relations expressing that a given system implements another under a given refinement function. We work out the concept of vertical implementation relations in general and we define two actual relations, one based on testing and one on bisimulation. We apply this approach to some existing examples from the literature. Especially the\u00a0\u2026", "num_citations": "50\n", "authors": ["671"]}
{"title": "Isomorphism checking in GROOVE\n", "abstract": " In this paper we show how isomorphism checking can be used as an effective technique for symmetry reduction in graph-based state spaces, despite the inherent complexity of the isomorphism problem. In particular, we show how one can use/element-based graph certificate mappings/to help in recognising non-isomorphic graphs. These are mappings that assign to all elements (edges and nodes) of a given graph a number that is invariant under isomorphism, in the sense that any isomorphism between graphs is sure to preserve this number. The individual element certificates of a graph give rise to a certificate for the entire graph, which can be used as a hash key for the graph; hence, this yields a heuristic to decide whether a graph has an isomorphic representative in a previously computed set of graphs. We report some experiments that show the viability of this method.", "num_citations": "47\n", "authors": ["671"]}
{"title": "Bisimilarity of open terms\n", "abstract": " Traditionally, in process calculi, relations over open terms, i.e., terms with free process variables, are defined as extensions of closed-term relations: two open terms are related if and only if all their closed instantiations are related. Working in the context of bisimulation, in this paper we study a different approach; we define semantic models for open terms, so-called conditional transition systems, and define bisimulation directly on those models. It turns out that this can be done in at least two different ways, one giving rise to De Simone's formal hypothesis bisimilarity and the other to a variation which we call hypothesis-preserving bisimilarity (denoted \u223cfh and \u223chp, respectively). For open terms, we have (strict) inclusions \u223cfh\u2282\u223chp\u2282\u223cci (the latter denoting the standard \u201cclosed instance\u201d extension); for closed terms, the three coincide. Each of these relations is a congruence in the usual sense. We also give an\u00a0\u2026", "num_citations": "45\n", "authors": ["671"]}
{"title": "Weak sequential composition in process algebras\n", "abstract": " In this paper we study a special operator for sequential composition, which is defined relative to a dependency relation over the actions of a given system. The idea is that actions which are not dependent (intuitively because they share no common resources) do not have to wait for one another to proceed, even if they are composed sequentially. Such a notion has been studied before in a linear-time setting, but until recently there has been no systematic investigation in the context of process algebras.             We give a structural operational semantics for a process algebraic language containing such a sequential composition operator, which shows some interesting interplay with choice. We give a complete axiomatisation of strong bisimilarity and we show consistency of the operational semantics with an event-based denotational semantics developed recently by the second author. The axiom system allows\u00a0\u2026", "num_citations": "45\n", "authors": ["671"]}
{"title": "Graph transformation tool contest 2008\n", "abstract": " This special section is the outcome of the graph transformation tool contest organised during the Graph-Based Tools (GraBaTs) 2008 workshop, which took place as a satellite event of the International Conference on Graph Transformation (ICGT) 2008. The contest involved two parts: three \u201coff-line case studies\u201d which were published before the contest, and to which solutions were submitted and reviewed; and a \u201clive contest\u201d for which the case description was only handed out during the event, and to which solutions had to be constructed during a single afternoon session. Here we briefly sketch the off-line cases, and the setup and topic of the live contest in somewhat more detail. We also evaluate the results of the workshop, and give some recommendations for future editions. Finally, we introduce the research papers appearing in this special section.", "num_citations": "37\n", "authors": ["671"]}
{"title": "A modal-logic based graph abstraction\n", "abstract": " Infinite or very large state spaces often prohibit the successful verification of graph transformation systems. Abstract graph transformation is an approach that tackles this problem by abstracting graphs to abstract graphs of bounded size and by lifting application of productions to abstract graphs. In this work, we present a new framework of abstractions unifying and generalising existing takes on abstract graph transformation. The precision of the abstraction can be adjusted according to the properties to be verified facilitating abstraction refinement. We present a modal logic defined on graphs, which is preserved and reflected by our abstractions. Finally, we demonstrate the usability of the framework by verifying a graph transformation model of a firewall.", "num_citations": "37\n", "authors": ["671"]}
{"title": "Showing full semantics preservation in model transformation-a comparison of techniques\n", "abstract": " Model transformation is a prime technique in modern, model-driven software design. One of the most challenging issues is to show that the semantics of the models is not affected by the transformation. So far, there is hardly any research into this issue, in particular in those cases where the source and target languages are different.             In this paper, we are using two different state-of-the-art proof techniques (explicit bisimulation construction versus borrowed contexts) to show bisimilarity preservation of a given model transformation between two simple (self-defined) languages, both of which are equipped with a graph transformation-based operational semantics. The contrast between these proof techniques is interesting because they are based on different model transformation strategies: triple graph grammars versus in situ transformation. We proceed to compare the proofs and discuss scalability to a\u00a0\u2026", "num_citations": "36\n", "authors": ["671"]}
{"title": "Vertical implementation\n", "abstract": " We investigate criteria to relate specifications and implementations belonging to conceptually different levels of abstraction. For this purpose, we introduce the generic concept of a vertical implementation relation, which is a family of binary relations indexed by a refinement function that maps abstract actions onto concrete processes and thus determines the basic connection between the abstraction levels. If the refinement function is the identity, the vertical implementation relation collapses to a standard (horizontal) implementation relation. As desiderata for vertical implementation relations we formulate a number of congruence-like proof rules (notably a structural rule for recursion) that offer a powerful, compositional proof technique for vertical implementation. As a candidate vertical implementation relation we propose vertical bisimulation. Vertical bisimulation is compatible with the standard interleaving semantics\u00a0\u2026", "num_citations": "36\n", "authors": ["671"]}
{"title": "Modelling mobile health systems: an application of augmented MDA for the extended healthcare enterprise\n", "abstract": " Mobile health systems can extend the enterprise computing system of the healthcare provider by bringing services to the patient any time and anywhere. We propose a model-driven design and development methodology for the development of the m-health components in such extended enterprise computing systems. The methodology applies a model-driven design and development approach augmented with formal validation and verification to address quality and correctness and to support model transformation. Work on modelling applications from the healthcare domain is reported. One objective of this work is to explore and elaborate the proposed methodology. At the University of Twente we are developing m-health systems based on body area networks (BANs). One specialization of the generic BAN is the health BAN, which incorporates a set of devices and associated software components to provide some\u00a0\u2026", "num_citations": "35\n", "authors": ["671"]}
{"title": "Nested quantification in graph transformation rules\n", "abstract": " In this paper we describe a way to integrate Taentzer\u2019s rule amalgamation with the recently proposed notions of nested graph conditions. The resulting so-called quantified graph transformation rules include (universally and existentially) quantified sub-structures in a flexible way. This can be used for instance to specify a larger-step operational semantics, thus improving the scalability of graph transformation as a technique for software verification.", "num_citations": "34\n", "authors": ["671"]}
{"title": "User manual for the groove tool set\n", "abstract": " GROOVE is a project centered around the use of simple graphs for modelling the design-time, compile-time, and run-time structure of object-oriented systems, and graph transformations as a basis for model transformation and operational semantics. This entails a formal foundation for model transformation and dynamic semantics, and the ability to verify model transformation and dynamic semantics through an (automatic) analysis of the resulting graph transformation systems, for instance using model checking. This manual constsis of some download and installation instructions and a manual for using the tools included in the GROOVE tool set. The latter also explains the format used for graphs and graph transformations. Together with some examples, this should allow you to get started with GROOVE.", "num_citations": "32\n", "authors": ["671"]}
{"title": "From UML activities to TAAL-towards behaviour-preserving model transformations\n", "abstract": " Model transformations support a model-driven design by providing an automatic translation of abstract models into more concrete ones, and eventually program code. Crucial to a successful application of model transformations is their correctness, in the sense that the meaning (semantics) of the models is preserved. This is especially important if the models not only describe the structure but also the intended behaviour of the systems. Reasoning about and showing correctness is, however, often impossible as the source and target models typically lack a precise definition of their semantics.                 In this paper, we take a first step towards provably correct behavioural model transformations. In particular, we develop transformations from UML Activities (which are visual models) to programs in TAAL, which is a textual Java-like programming language. Both languages come equipped with formal\u00a0\u2026", "num_citations": "32\n", "authors": ["671"]}
{"title": "Posets for configurations!\n", "abstract": " We define families of posets, ordered by prefixes, as the counterpart of the usual families of configurations ordered by subsets. On these objects we define two types of morphism: event and order morphisms, resulting in categories FPos and FPos               \u2291. We then show the following:                                    Families of posets, in contrast to families of configurations, are always prime algebraic; in fact the category FPos                     \u2291 is equivalent to the category of prime algebraic domains;                                                     On the level of events, FPos is equivalent to the category of prime algebraic domains with an additional relation encoding event identity.                                                     The (abstract) event identity relation can be used to characterize concrete relations between events such as binary conflict and causal flow;                                                     One can characterize a wide range of event-based models\u00a0\u2026", "num_citations": "32\n", "authors": ["671"]}
{"title": "Comparing syntactic and semantic action refinement\n", "abstract": " The semantic definition of action refinement on labelled configuration structures is compared with the notion ofsyntactic substitution, which can be used as another notion of action refinement in a process algebraic setting. The comparison is done by studying a process algebra equipped with sequential composition, parallel composition with an explicit synchronisation set, and an operator for action refinement. On the one hand, the language (including the refinement operator) is given a configuration structure semantics. On the other hand, a reduction procedure transforms a process termPinto aflatterm (i.e., with the refinement operator not occurring in it)red(P) by means of syntactic substitution, defined in a structural inductive way. The main aim of the paper is to investigate general conditions under which the termsPandred(P) have the same semantics. The results we present are essentially dependent on the\u00a0\u2026", "num_citations": "30\n", "authors": ["671"]}
{"title": "Fault trees on a diet: automated reduction by graph rewriting\n", "abstract": " Fault trees are a popular industrial technique for reliability modelling and analysis. Their extension with common reliability patterns, such as spare management, functional dependencies, and sequencing\u2014known as dynamic fault trees (DFTs)\u2014has an adverse effect on scalability, prohibiting the analysis of complex, industrial cases. This paper presents a novel, fully automated reduction technique for DFTs. The key idea is to interpret DFTs as directed graphs and exploit graph rewriting to simplify them. We present a collection of rewrite rules, address their correctness, and give a simple heuristic to determine the order of rewriting. Experiments on a large set of benchmarks show substantial DFT simplifications, yielding state space reductions and timing gains of up to two orders of magnitude.", "num_citations": "29\n", "authors": ["671"]}
{"title": "Action refinement as an implementation relation\n", "abstract": " We propose a theory of process refinement which relates behavioural descriptions belonging to conceptually different abstraction levels, through a so-called vertical implementation relation. The theory is based on action refinement, which permits to relate abstract actions of the implementation to concrete computations of the implementation; it is developed in the standard interleaving approach. A number of proof rules is shown to be sound for the particular vertical implementation relation (based on observation congruence) we study in this paper. We give an illustrative example.", "num_citations": "29\n", "authors": ["671"]}
{"title": "On syntactic and semantic action refinement\n", "abstract": " The semantic definition of action refinement on labelled event structures is compared with the notion of syntactic substitution, which can be used as another notion of action refinement in a process algebraic setting. This is done by studying a process algebra equipped with the ACP sequential composition, parallel composition with an explicit synchronisation set, and an operator for action refinement. On the one hand, the language (including the refinement operator) is given a flow event structure semantics. On the other hand, a reduction procedure transforms a process term P into a flat term (i.e., with the refinement operator not occurring in it) red(P) by means of syntactic substitution, defined in a structural inductive way.             The main aim of the paper is to find general conditions under which the terms P and red(P) have the same semantics. The results we present are essentially dependent on the question\u00a0\u2026", "num_citations": "28\n", "authors": ["671"]}
{"title": "A tutorial on graph transformation\n", "abstract": " Graph transformation or graph rewriting has been developed for nearly 50 years and has become a mature and manifold formal technique. Basically, rewrite rules are used to manipulate graphs. These rules are given by a left-hand side and a right-hand side graph and the application comprises matching the left-hand side and replacing it with the right-hand side of the rule.               In this contribution we give a tutorial on graph transformation that explains the so-called double-pushout approach to graph transformation in a rigorous, but non-categorical way, using a gluing construction. We explicate the definitions with several small examples.               We also introduce attributes and attributed graph transformation in a lightweight form. The paper is concluded by a more extensive example on a leader election protocol, the description of tool support and pointers to related work.", "num_citations": "26\n", "authors": ["671"]}
{"title": "On a graph-based semantics for UML class and object diagrams\n", "abstract": " In this paper we propose a formal extension of type graphs with notions that are commonplace in the UML and have long proven their worth in that context: namely, inheritance, multiplicity, containment and the like. We believe the absence of a comprehensive and commonly agreed upon formalisation of these notions to be an important and, unfortunately, often ignored omission. Since our eventual aim (shared by many researchers) is to give unambiguous, formal semantics to the UML using the theory of graphs and graph transformation, in this report we propose a set of definitions to repair this omission. With respect to previous work in this direction, our aim is to arrive at more comprehensive and at the same time simpler definitions.", "num_citations": "26\n", "authors": ["671"]}
{"title": "An algebraic semantics for message sequence chart documents\n", "abstract": " Message Sequence Charts (MSCs) are a graphical and textual language for the specification of message passing systems, in particular telecommunication systems. MSCs are standardised by the Internal Telecommunication Union in standard Z.120. Included in the standard is a formal semantics for MSCs by means of a process algebra. This semantics covers the complete language of single MSCs but lacks an interpretation for conditions which are used as continuation points of MSCs within an MSC document (a collection of MSCs). In this paper, we give a process algebraic semantics for basic MSCs including conditions, enabling the formal interpretation of entire MSC documents.", "num_citations": "25\n", "authors": ["671"]}
{"title": "Effective analysis of attack trees: A model-driven approach\n", "abstract": " Attack trees (ATs) are a popular formalism for security analysis, and numerous variations and tools have been developed around them. These were mostly developed independently, and offer little interoperability or ability to combine various AT features. We present ATTop, a software bridging tool that enables automated analysis of ATs using a model-driven engineering approach. ATTop fulfills two purposes: 1. It facilitates interoperation between several AT analysis methodologies and resulting tools (eg, ATE, ATCalc, ADTool 2.0), 2. it can perform a comprehensive analysis of attack trees by translating them into timed automata and analyzing them using the popular model checker Uppaal, and translating the analysis results back to the original ATs. Technically, our approach uses various metamodels to provide a unified description of AT variants. Based on these metamodels, we perform model transformations that allow to apply various analysis methods to an AT and trace the results back to the AT domain. We illustrate our approach on the basis of a case study from the AT literature.", "num_citations": "24\n", "authors": ["671"]}
{"title": "Model checking quantified computation tree logic\n", "abstract": " Propositional temporal logic is not suitable for expressing properties on the evolution of dynamically allocated entities over time. In particular, it is not possible to trace such entities through computation steps, since this requires the ability to freely mix quantification and temporal operators.               In this paper we study Quantified Computation Tree Logic                         (QCTL                         ), which extends the well-known propositional computation tree logic, PCTL, with first and (monadic) second order quantification. The semantics of QCTL is expressed on algebra automata, which are automata enriched with abstract algebras at each state, and with reallocations at each transition that express an injective renaming of the algebra elements from one state to the next. The reallocations enable minimization of the automata modulo bisimilarity, essentially through symmetry reduction. Our main result is to show that\u00a0\u2026", "num_citations": "24\n", "authors": ["671"]}
{"title": "A formal MDA approach for mobile health systems\n", "abstract": " M-health systems are safety critical systems intended for use by the public and are therefore characterized by especially strict requirements relating to safety, security, correctness, reliability, adaptability and user friendliness. This position paper proposes a methodology which realizes the MDA approach by utilizing formal methods to support verification, validation and transformation. The objective is to investigate the use of MDA enriched by formal methods to define a generic, evolvable architecture for m-health services which facilitates the rapid development and deployment of high quality adaptable m-health services.", "num_citations": "23\n", "authors": ["671"]}
{"title": "Pattern-based graph abstraction\n", "abstract": " We present a new abstraction technique for the exploration of graph transformation systems with infinite state spaces. This technique is based on patterns, simple graphs describing structures of interest that should be preserved by the abstraction. Patterns are collected into pattern graphs, layered graphs that capture the hierarchical composition of smaller patterns into larger ones. Pattern graphs are then abstracted to a finite universe of pattern shapes by collapsing equivalent patterns. This paper shows how the application of production rules can be lifted to pattern shapes, resulting in an over-approximation of the original system behaviour and thus enabling verification on the abstract level.", "num_citations": "22\n", "authors": ["671"]}
{"title": "Applications of fair testing\n", "abstract": " In this paper we present the application of the fair testing pre-order introduced in a previous paper, to the specification and analysis of distributed systems. This pre-order combines some features of the standard testing pre-orders, viz. the possibility to refine a specification by the resolution of nondeterminism with a powerful feature of standard observation congruence, viz. the fair abstraction from divergences. Moreover, it is a pre-congruence with respect to all standard process-algebraic combinators, thus allowing for the standard algebraic proof techniques by substitution and rewriting. In this paper we will demonstrate advantages of the fair testing pre-order by the application to a number of examples, including a scheduling problem, a version of the Alternating Bit-protocol, and fair communication channels.", "num_citations": "22\n", "authors": ["671"]}
{"title": "Summary 2: Graph grammar verification through abstraction\n", "abstract": " Until now there have been few contributions concerning the verification of graph grammars, specifically of infinite-state graph grammars. This paper compares two existing approaches, based on abstractions of graph transformation systems. While in the unfolding approach graph grammars are approximated by Petri nets, in the partitioning approach graphs are abstracted according to their local structure. We describe differences and similarities of the two approaches and explain the underlying ideas.", "num_citations": "21\n", "authors": ["671"]}
{"title": "Incremental pattern matching in graph-based state space exploration\n", "abstract": " Graph pattern matching is among the most costly operations in any graph transformation system. Incremental pattern matching aims at reducing this cost by incrementally updating, as opposed to totally recalculating, the possible matches of rules in the graph grammar at each step of the transformation. In this paper an implementation of one such algorithm is discussed with respect to the GROOVE", "num_citations": "20\n", "authors": ["671"]}
{"title": "Engineering object-oriented semantics using graph transformations\n", "abstract": " In this paper we describe the application of the theory of graph transformations to the practise of language design. We have defined the semantics of a small but realistic objectoriented language (called TAAL) by mapping the language constructs to graphs and their operational semantics to graph transformation rules. In the process we establish a mapping between UML models and graphs.TAAL was developed for the purpose of this paper, as an extensive case study in engineering object-oriented language semantics using graph transformation. It incorporates the basic aspects of many commonly used object-oriented programming languages: apart from essential imperative programming constructs, it includes inheritance, object creation and method overriding. The language specification is based on a number of meta-models written in UML. Both the static and dynamic semantics are defined using graph rewriting rules. In the course of the case study, we have built an Eclipse plug-in that automatically transforms arbitrary TAAL programs into graphs, in a graph format readable by another tool. This second tool is called Groove, and it is able to execute graph transformations. By combining both tools we are able to visually simulate the execution of any TAAL program.", "num_citations": "20\n", "authors": ["671"]}
{"title": "Graph abstraction and abstract graph transformation\n", "abstract": " Many important systems like concurrent heap-manipulating programs, communication networks, or distributed algorithms are hard to verify due to their inherent dynamics and unboundedness. Graphs are an intuitive representation of states of these systems, where transitions can be conveniently described by graph transformation rules.We present a framework for the abstraction of graphs supporting abstract graph transformation. The abstraction method naturally generalises previous approaches to abstract graph transformation. The set of possible abstract graphs is finite. This has the pleasant consequence of generating a finite transition system for any start graph and any finite set of transformation rules. Moreover, abstraction preserves a simple logic for expressing properties on graph nodes. The precision of the abstraction can be adjusted according to properties expressed in this logic to be verified.", "num_citations": "19\n", "authors": ["671"]}
{"title": "Graph transformation semantics for a QVT language\n", "abstract": " It has been claimed by many in the graph transformation community that model transformation, as understood in the context of Model Driven Architecture, can be seen as an application of graph transformation. In this paper we substantiate this claim by giving a graph transformation-based semantics to one of the original QVT language proposals; that is, we define a mechanism that will translate any model transformation definition in the QVT language to a graph production system whose effect is to apply that model transformation. The translation has been fully implemented.", "num_citations": "17\n", "authors": ["671"]}
{"title": "BenchmarX\n", "abstract": " Bidirectional transformation (BX) is a very active area of research interest. There is not only a growing body of theory, but also a rich set of tools supporting BX. The problem now arises that there is no commonly agreed-upon suite of tests or benchmarks that shows either the conformance of tools to theory, or the performance of tools in particular BX scenarios. This paper sets out to improve the state of affairs in this respect, by proposing a template and a set of required criteria for benchmark descriptions, as well as guidelines for the artifacts that should be provided for each included test. As a proof of concept, the paper additionally provides a detailed description of one concrete benchmark.", "num_citations": "15\n", "authors": ["671"]}
{"title": "Neighbourhood abstraction in GROOVE\n", "abstract": " Important classes of graph grammars have infinite state spaces and therefore cannot be verified with traditional model checking techniques. One way to address this problem is to perform graph abstraction, which allows us to generate a finite abstract state space that over-approximates the original one. In previous work we developed the theory of neighbourhood abstraction. In this paper, we present the implementation of this theory in GROOVE and illustrate its use with a small grammar that models operations on a single-linked list.", "num_citations": "15\n", "authors": ["671"]}
{"title": "Time and space issues in the generation of graph transition systems\n", "abstract": " GROOVE is a tool for the automatic generation of graph transition systems from graph grammars. In this type of tool, both memory and time performance are of prime importance. In this paper we discuss the implementation techniques used for optimising the tool in this regard, and we list possible future improvements.", "num_citations": "15\n", "authors": ["671"]}
{"title": "Subjects, models, languages, transformations\n", "abstract": " Discussions about model-driven approaches tend to be hampered by terminological confusion. This is at least partially caused by a lack of formal precision in defining the basic concepts, including that of\\model\" and\\thing being modelled\"| which we call subject in this paper. We propose a minimal criterion that a model should fulfill: essentially, it should come equipped with a clear and unambiguous membership test; in other words, a notion of which subjects it models. We then go on to discuss a certain class of models of models that we call languages, which apart from defining their own membership test also determine membership of their members. Finally, we introduce transformations on each of these layers: a subject transformation is essentially a pair of subjects, a model transformation is both a pair of models and a model of pairs (namely, subject transformations), and a language transformation is both a pair of languages and a language of model transformations. We argue that our framework has the benefits of formal precision (there can be no doubt about whether something satifies our criteria for being a model, a language or a transformation) and minimality (it is hard to imagine a case of modelling or transformation not having the characterstics that we propose).", "num_citations": "15\n", "authors": ["671"]}
{"title": "An event-based SOS for a language with refinement\n", "abstract": " The notion of action refinement has been studied intensively in the past few years. It is usually introduced in the form of an operator in a process algebraic language, for which a denotational semantics in a suitable model is then given. In this paper we complement this approach by defining a corresponding operational semantics for refinement, in the form of derivation rules for a transition relation. Because of the (well-known) fact that ordinary transition systems are not expressive enough to capture the effects of refinement, we use an event-based transition system model described elsewhere in the literature. The operational semantics of refinement thus defined is equivalent (in fact event isomorphic) to the usual denotational semantics.", "num_citations": "15\n", "authors": ["671"]}
{"title": "How to efficiently build a front-end tool for UPPAAL: a model-driven approach\n", "abstract": " We propose a model-driven engineering approach that facilitates the production of tool chains that use the popular model checker Uppaal as a back-end analysis tool. In this approach, we introduce a metamodel for Uppaal \u2019s input model, containing both timed-automata concepts and syntax-related elements for C-like expressions. We also introduce a metamodel for Uppaal \u2019s query language to specify temporal properties; as well as a metamodel for traces to interpret Uppaal \u2019s counterexamples and witnesses. The approach provides a systematic way to build software bridging tools (i.e., tools that translate from a domain-specific language to Uppaal \u2019s input language) such that these tools become easier to debug, extend, reuse and maintain. We demonstrate our approach on five different domains: cyber-physical systems, hardware-software co-design, cyber-security, reliability engineering and software\u00a0\u2026", "num_citations": "14\n", "authors": ["671"]}
{"title": "The edge of graph transformation\u2014graphs for behavioural specification\n", "abstract": " The title of this paper, besides being a pun, can be taken to mean either the frontier of research in graph transformation, or the advantage of using graph transformation. To focus on the latter: Why should anyone not already educated in the field adopt graph transformation-based methods, rather than a mainstream modelling language or a process algebra; or vice versa, what is holding potential users back? These questions can be further refined by focusing on particular aspects like usability (available tools) or power (available theory).               In this paper, we take a fresh and honest look at these issues. Our perspective is the use of graph transformation as a formalism for the specification and analysis of system behaviour. There is no question that the general nature of graphs is at once their prime selling point (essentially everything can be specified in terms of graphs) and their main drawback (the\u00a0\u2026", "num_citations": "14\n", "authors": ["671"]}
{"title": "Dynamic partial order reduction using probe sets\n", "abstract": " We present an algorithm for partial order reduction in the context of a countable universe of deterministic actions, of which finitely many are enabled at any given state. This means that the algorithm is suited for a setting in which resources, such as processes or objects, are dynamically created and destroyed, without an a priori bound. The algorithm relies on abstract enabling and disabling relations among actions, rather than associated sets of concurrent processes. It works by selecting so-called probe sets at every state, and backtracking in case the probe is later discovered to have missed some possible continuation.               We show that this improves the potential reduction with respect to persistent sets. We then instantiate the framework by assuming that states are essentially sets of entities (out of a countable universe) and actions test, delete and create such entities. Typical examples of systems that\u00a0\u2026", "num_citations": "14\n", "authors": ["671"]}
{"title": "Ludo: A case study for graph transformation tools\n", "abstract": " In this paper we describe the Ludo case, one of the case studies of the AGTIVE 2007 Tool Contest (see [22]). After summarising the case description, we give an overview of the submitted solutions. In particular, we propose a number of dimensions along which choices had to be made when solving the case, essentially setting up a solution space; we then plot the spectrum of solutions actually encountered into this solution space. In addition, there is a brief description of the special features of each of the submissions, to do justice to those aspects that are not distinguished in the general solution space.", "num_citations": "14\n", "authors": ["671"]}
{"title": "Towards a formal specification of multi-paradigm modelling\n", "abstract": " The notion of a programming paradigm is used to classify programming languages and their accompanying workflows based on their salient features. Similarly, the notion of a modelling paradigm can be used to characterise the plethora of modelling approaches used to engineer complex Cyber-Physical Systems (CPS). Modelling paradigms encompass formalisms, abstractions, workflows and supporting tool(chain) s. A precise definition of this modelling paradigm notion is lacking however. Such a definition will increase insight, will allow for formal reasoning about the consistency of modelling frameworks and may serve as the basis for the construction of new modelling, simulation, verification, synthesis, ...environments to support design of CPS . We present a formal framework aimed at capturing the notion of modelling paradigm, as a first step towards a comprehensive formalisation of multi-paradigm modelling\u00a0\u2026", "num_citations": "13\n", "authors": ["671"]}
{"title": "Simulating multigraph transformations using simple graphs\n", "abstract": " Application of graph transformations for software verification and model transformation is an emergent field of research. In particular, graph transformation approaches provide a natural way of modelling object oriented systems and semantics of object-oriented languages.", "num_citations": "13\n", "authors": ["671"]}
{"title": "Specification and construction of control flow semantics\n", "abstract": " In this paper we propose a visual language CFSL for specifying control flow semantics of programming languages. We also present a translation from CFSL to graph production systems (GPS) for flow graph construction; that is, any CFSL specification, say for a language L, gives rise to a GPS that constructs from any L-program (represented as an abstract syntax graph) the corresponding flow graph. The specification language is rich enough to capture complex language constructs, including all of Java", "num_citations": "13\n", "authors": ["671"]}
{"title": "Using graph transformations and graph abstractions for software verification\n", "abstract": " In this abstract we present an overview of our intended approach for the verification of software written in imperative programming languages. This approach is based on model checking of graph transition systems (GTS), where each program state is modeled as a graph and the exploration engine is specified by graph transformation rules. We believe that graph transformation [13] is a very suitable technique to model the execution semantics of languages with dynamic memory allocation. Furthermore, such representation provides a clean setting to investigate the use of graph abstractions, which can mitigate the space state explosion problem that is inherent to model checking techniques.", "num_citations": "12\n", "authors": ["671"]}
{"title": "AGTIVE 2007 graph transformation tool contest\n", "abstract": " In this short paper we describe the setup and results of a new initiative to compare graph transformation tools, carried out as part of the AGTIVE 2007 symposium on \u201cApplications of Graph Transformation with Industrial Relevance\u201d. The initiative took the form of a contest, consisting of two rounds: the first round was a call for cases, the second round a call for solutions. The response to both rounds was very good, leading to the conclusion that this is an initiative worth repeating. There are, however, a number of lessons to be learned; these are summarised here, in order to improve the organisation and the eventual benefits of this type of contest.", "num_citations": "12\n", "authors": ["671"]}
{"title": "State space abstraction using shape graphs\n", "abstract": " To represent the individual states of software systems we propose to use edge-labelled graphs: nodes will stand for dynamically allocated entities (eg, objects or method frames) and edges for relations between those entities (eg, arising from associations or variables). Obviously, as these graphs may in principle grow unboundedly, the state space is generally infinite. In this paper we present a technique to automatically obtain finite approximations of arbitrary state spaces, by recording only the local structure of the individual graphs: essentially, for each node we only store the approximate number of its neighbours according to each edge label. This gives rise to a variant of shape graphs described elsewhere.", "num_citations": "12\n", "authors": ["671"]}
{"title": "Bisimilarity of open terms\n", "abstract": " The standard way of lifting a binary relation, R, from closed terms of an algebra to open terms is to define its closed-instance extension, Rci, which holds for a given pair of open terms if and only if R holds for all their closed instantiations. In this paper, we study alternatives for the case of (strong) bisimulation: we define semantic models for open terms, so-called conditional transition systems, and define bisimulation directly on those models. It turns out that this can be done in at least two different ways, giving rise to formal hypothesis bisimulation \u223cfh (due to De Simone) and hypothesis-preserving bisimilarity \u223chp. For open terms, we have (strict) inclusions \u223cfh\u221e\u223chp\u221e\u223cci; for closed terms, the three relations coincide. We show that each of these relations is a congruence in the usual sense, and we give an alternative characterisation of \u223chp in terms of non-conditional transitions. Finally, we study the issue of\u00a0\u2026", "num_citations": "12\n", "authors": ["671"]}
{"title": "Methodological Aspects of Action Refinement.\n", "abstract": " The principle of action re nement refers to the implementation of abstract actions through more complex, concrete processes. In this paper we study the fundamental question how to use this principle in process algebraic system design. We formulate a methodological framework to express design under action refinement, and present two applications of this framework. The first application corresponds to the well-known interpretation of action refinement as an operator in the algebra, requiring a non-interleaving semantics the second application is new, and results in a much more flexible notion of design, which is moreover compatible with the standard interleaving semantics.", "num_citations": "12\n", "authors": ["671"]}
{"title": "A type graph model for Java programs\n", "abstract": " In this work we present a type graph that models all executable constructs of the Java programming language. Such a model is useful for any graph-based technique that relies on a representation of Java programs as graphs. The model can be regarded as a common representation to which all Java syntax graphs must adhere. We also present the systematic approach that is being taken to generate syntax graphs from Java code. Since the type graph model is comprehensive, i.e., covers the whole language specification, the technique is guaranteed to generate a corresponding graph for any valid Java program. In particular, we want to extract such syntax graphs in order to perform static analysis and model checking of programs written in Java. Although we focus on Java, this same approach could be adapted for other programming languages.", "num_citations": "11\n", "authors": ["671"]}
{"title": "Towards compliance verification between global and local process models\n", "abstract": " This paper addresses the question how to verify that the local workflow of an organisation participating in a cross-organisational collaboration is in compliance with the globally specified rules of that collaboration. We assume that the collaborative workflow is specified as a BPMN Collaboration Diagram and the local workflows as BPMN Process Diagrams. We then employ existing LTL semantics of the former and token semantics of the latter to verify conformance. We use the graph transformation tool GROOVE to automate the verification, and exemplify our approach with a case study from the financial markets domain.", "num_citations": "10\n", "authors": ["671"]}
{"title": "Graph Transformations: 5th International Conference, ICGT 2010, Twente, The Netherlands, September 27--October 2, 2010, Proceedings\n", "abstract": " Graphs are among the simplest and most universal models for a variety of s-tems, not just in computer science, but throughout engineering and the life sciences. When systems evolve we are interested in the way they change, to p-dict, support, or react to their evolution. Graph transformation combines the idea of graphs as a universal modelling paradigm with a rule-based approach to specify their evolution. The area is concerned with both the theory of graph transformation and their application to a variety of domains. The biannual International Conferences on Graph Transformation aim at bringingtogetherresearchersandpractitionersinterestedin the foundations and applicationsof graphtransformation. The? fth conference, ICGT 2010, was held at the University of Twente (The Netherlands) in September/October 2010, alongwith severalsatellite events. It continuedthe line ofconferences previously held in Barcelona (Spain) in 2002, Rome (Italy) 2004, Natal (Brazil) in 2006 and Leicester (UK) in 2008, as well as a series of six International Workshops on Graph Transformation with Applications in Computer Science from 1978 to 1998. Also, ICGT alternates with the workshop series on Application of Graph Transformation with Industrial Relevance (AGTIVE). The conference was held under the auspices of EATCS and EASST.", "num_citations": "10\n", "authors": ["671"]}
{"title": "Full semantics preservation in model transformation\u2013a comparison of proof techniques\n", "abstract": " Model transformation is a prime technique in modern, model-driven software design. One of the most challenging issues is to show that the semantics of the models is not affected by the transformation. So far, there is hardly any research into this issue, in particular in those cases where the source and target languages are different.In this paper, we are using two different state-of-the-art proof techniques (explicit bisimulation construction versus borrowed contexts) to show bisimilarity preservation of a given model transformation between two simple (self-defined) languages, both of which are equipped with a graph transformation-based operational semantics. The contrast between these proof techniques is interesting because they are based on different model transformation strategies: triple graph grammars versus in situ transformation. We proceed to compare the proofs and discuss scalability to a more realistic setting.", "num_citations": "10\n", "authors": ["671"]}
{"title": "Model Driven Architecture-Foundations and Applications\n", "abstract": " Model-Driven Architecture, including model-driven approaches in general, holds the big promise of moving software development towards a higher level of abstraction. Given the challenges in the software industry of delivering more complex functionality with less effort, I am convinced that it isn\u2019ta question of whether model-driven development will succeed, but rather a question of when it will break through. However, before this can happen, we have many challenging problems to conquer. There are both theoretical and pragmatic problems to solve and therefore we need a close collaboration between industry and the academic world. The goal of the European Conference on Model-Driven Architecture\u2014Foundations and Applications (ECMDA-FA) is to bring together industry and academia to tackle the problems in model-driven development. This volume includes 18 foundation papers and 12 application papers, which is a fine balance between both worlds. ECMDA-FA 2006 also hosted six workshops on both theoretical and practical aspects of MDA. Furthermore, the keynote speakers, David Frankel and Bran Selic, from some of the world\u2019s largest IT companies proved that industry is very much involved in MDA. This second ECMDA-FA conference is the result of the work of the authors who submitted a total of 78 papers, the Program Committee members who took the effort to review the papers, the people organizing the workshops, and of course the Steering Committee. All in all, several hundreds of people have worked hard to make this conference a success. I have the honor of speaking for all these people in this preface and I would like to\u00a0\u2026", "num_citations": "10\n", "authors": ["671"]}
{"title": "Process algebra with action dependencies\n", "abstract": " In this paper, we present a process algebra with a minimal form of semantics for actions given by dependencies. Action dependencies are interpreted in the Mazurkiewicz sense: independent actions should be able to commute, or (from a different perspective) should be unordered, whereas dependent actions are always ordered. In this approach, the process algebra operators are used to describe the conceptual behavioural structure of the system, and the action dependencies determine the minimal necessary orderings and thereby the additionally possible parallelism within this structure.               In previous work on the semantics of specifications using Mazurkiewicz dependencies, the main interest has been on linear time. We present in this paper a branching time semantics, both operationally and denotationally. For this purpose, we introduce a process algebra that incorporates, besides some\u00a0\u2026", "num_citations": "10\n", "authors": ["671"]}
{"title": "Rewriting abstract structures: materialization explained categorically\n", "abstract": " The paper develops an abstract (over-approximating) semantics for double-pushout rewriting of graphs and graph-like objects. The focus is on the so-called materialization of left-hand sides from abstract graphs, a central concept in previous work. The first contribution is an accessible, general explanation of how materializations arise from universal properties and categorical constructions, in particular partial map classifiers, in a topos. Second, we introduce an extension by enriching objects with annotations and give a precise characterization of strongest post-conditions, which are effectively computable under certain assumptions.", "num_citations": "9\n", "authors": ["671"]}
{"title": "Graph subsumption in abstract state space exploration\n", "abstract": " In this paper we present the extension of an existing method for abstract graph-based state space exploration, called neighbourhood abstraction, with a reduction technique based on subsumption. Basically, one abstract state subsumes another when it covers more concrete states; in such a case, the subsumed state need not be included in the state space, thus giving a reduction. We explain the theory and especially also report on a number of experiments, which show that subsumption indeed drastically reduces both the state space and the resources (time and memory) needed to compute it.", "num_citations": "9\n", "authors": ["671"]}
{"title": "Graph abstraction and abstract graph transformations (amended version)\n", "abstract": " Many important systems such as concurrent heap-manipulating programs, communication networks, or distributed algorithms, are hard to verify due to their inherent dynamics and unboundedness. Graphs are an intuitive representation for the states of these systems, where transitions can be conveniently described by graph transformation rules. We present a framework for the abstraction of graphs supporting abstract graph transformation. The abstraction method naturally generalises previous approaches to abstract graph transformation. The set of possible abstract graphs is finite. This has the pleasant consequence of generating a finite transition system for any start graph and any finite set of transformation rules. Moreover, abstraction preserves a simple logic for expressing properties on graph nodes. The precision of the abstraction can be adjusted according to the properties expressed in this logic that are to be verified.\u22c6 The main purpose of this amended version is to correct typos, errors and omissions from previous versions of this technical report. We also tried to make the text more clear by rewriting some sentences and adding new figures. There is one major change in terminology: In the previous version of the report the term shaping was used to denote a morphism between a graph and a shape, and the term abstraction morphism to denote a morphism between two shapes. The usage of these terms were usually misleading and led to confusion. Therefore we swapped their definitions. In the current version of this report we use the term abstraction morphism to denote a morphism between a graph and a shape and we write shape\u00a0\u2026", "num_citations": "9\n", "authors": ["671"]}
{"title": "Dependency-based action refinement\n", "abstract": " Action refinement in process algebras has been widely studied in the last few years as a means to support top-down design of systems. A specific notion of refinement arises when a dependency relation on the actions (in the Mazurkiewicz sense) is used to control the inheritance of orderings from the abstract level. In this paper we present a rather simple operational semantics for dependency-based action refinement. We show the consistency of the operational with a (previously published) denotational semantics. We moreover show that bisimulation is a congruence for dependency-based refinement. Finally, we give an illustrative example.", "num_citations": "9\n", "authors": ["671"]}
{"title": "Algebra and theory of order-deterministic pomsets\n", "abstract": " This paper is about partially ordered multisets (pomsets for short). We investigate a particular class of pomsets that we call order-deterministic, properly including all partially ordered sets, which satisfies a number of interesting properties: among other things, it forms a distributive lattice under pomset prefix (hence prefix closed sets of order-deterministic pomsets are prime algebraic), and it constitutes a reflective subcategory of the category of all pomsets. For the order-deterministic pomsets we develop an algebra with a sound and (-) complete equational theory. The operators in the algebra are concatenation and join, the latter being a variation on the more usual disjoint union of pomsets. This theory is then extended in order to capture refinement of pomsets by incorporating homomorphisms between models as objects in the algebra and homomorphism application as a new operator.", "num_citations": "9\n", "authors": ["671"]}
{"title": "Finite Petri nets as models for recursive causal behaviour\n", "abstract": " Goltz (1988) discussed whether or not there exist finite Petri nets (with unbounded capacities) modelling the causal behaviour of certain recursive CCS terms. As a representative example, the following term is considered: B=(a. nil\u2223 bB)+ c. nil. We will show that the answer depends on the chosen notion of behaviour. It was already known that the interleaving behaviour and the branching structure of terms as B can be modelled as long as causality is not taken into account. We now show that also the causal behaviour of B can be modelled as long as the branching structure is not taken into account. However, it is not possible to represent both causal dependencies and the behaviour with respect to choices between alternatives in a finite net. We prove that there exists no finite Petri net modelling B with respect to both pomset trace equivalence and failure equivalence.", "num_citations": "9\n", "authors": ["671"]}
{"title": "Uniform analysis of fault trees through model transformations\n", "abstract": " As the critical systems we rely on every day, such as nuclear power plants and airplanes, become ever more complex, the need to rigorously verify the safety and dependability of these systems is becoming very clear. Furthermore, deliberate attacks have become a prominent cause of concern for safety and reliability. One of the most prominent techniques for analyzing such systems is fault tree analysis (FTA), and a whole forest of variants, extensions, and analysis tools have been developed. In the security field, FTA was the inspiration for attack trees, used to analyze systems for vulnerability to malicious attacks. These formalisms are rarely compatible, making it difficult to exploit their different strengths in analyzing the same system. The key contribution of this paper is a meta-model describing many varieties of fault and attack trees, and well as combined attack-fault trees. We provide translations to and from\u00a0\u2026", "num_citations": "8\n", "authors": ["671"]}
{"title": "Solving the N-Queens problem with GROOVE-towards a compendium of best practices\n", "abstract": " We present a detailed solution to the N-queens puzzle using GROOVE, a graph transformation tool especially designed for state space exploration and analysis. While GROOVE has been freely available for more than a decade and has attracted a reasonable number of users, it is safe to say that only a few of these users fully exploit the tool features. To improve this situation, using the N-queens puzzle as a case study, in this paper we provide an in-depth discussion about problem solving with GROOVE, at the same time highlighting some of the tool's more advanced features. This leads to a list of best-practice guidelines, which we believe to be useful to new and expert users alike.", "num_citations": "8\n", "authors": ["671"]}
{"title": "Editorial for special section on dependencies and interactions with aspects\n", "abstract": " As the use of aspects spreads, it is becoming common to weave multiple aspects into a system, treating different concerns. In this special section, we present three papers that deal with the issue of how aspects may interact, and in particular how they may interfere with each other. Aspect interactions can arise at all stages of software development, including requirements, design, and implementation. The issues somewhat differ at each stage, and in fact for interference itself several definitions are in use.", "num_citations": "8\n", "authors": ["671"]}
{"title": "An object-oriented framework for explicit-state model checking\n", "abstract": " This paper presents a conceptual architecture for an object-oriented framework to support the development of formal verification tools (ie model checkers). The objective of the architecture is to support the reuse of algorithms and to encourage a modular design of tools. The conceptual framework is accompanied by a C++ implementation which provides reusable algorithms for the simulation and verification of explicit-state models as well as a model representation for simple models based on guard-based process descriptions. The framework has been successfully used to develop a model checker for a subset of PROMELA.", "num_citations": "8\n", "authors": ["671"]}
{"title": "The joys of graph transformation\n", "abstract": " We believe that the technique of graph transformation offers a very natural way to specify semantics for languages that have dynamic allocation and linking structure; for instance, object-oriented programming languages, but also languages for mobility. In this note we expose, on a rather informal level, the reasons for this belief. Our hope in doing this is to raise interest in this technique and so generate more interest in the fascinating possibilities and open questions of this area.", "num_citations": "8\n", "authors": ["671"]}
{"title": "Denotational, causal, and operational determinism in event structures\n", "abstract": " Determinism of labelled transition systems and trees is a concept of theoretical and practical importance. We study its generalisation to event structures. It turns out that the result depends on what characterising property of tree determinism one sets out to generalise. We present three distinct notions of event structure determinism, and show that none of them shares all the pleasant properties of the one concept for trees.", "num_citations": "8\n", "authors": ["671"]}
{"title": "Vertical bisimulation\n", "abstract": " We investigate criteria to relate specifications and implementations belonging to conceptually different abstraction levels, and propose vertical bisimulation as a candidate relation for this purpose. Vertical bisimulation is indexed by a function mapping abstract actions onto concrete processes, which lays down the basic connection between the levels. Vertical bisimulation is compatible with the standard interleaving semantics; in fact, if the refinement function is the identity, then vertical bisimulation collapses to the standard notion of rooted bisimulation. We prove that vertical bisimulation satisfies a number of congruence-like proof rules (notably a structural one for recursion) that offer a powerful, compositional proof technique to verify whether a certain process is an implementation for some specification. We give a number of small examples to demonstrate the advantages of this approach.", "num_citations": "8\n", "authors": ["671"]}
{"title": "Incremental pattern matching for regular expressions\n", "abstract": " Graph pattern matching lies at the heart of any graph transformation-based system. Incremental pattern matching is one approach proposed for reducingthe overall cost of pattern matching over successive transformations by preserving the matches that stay relevant after a rule application. An important issue in any matching scheme, is the ability to properly and consistently deal with various facilities that add to the expressiveness of a GT-tool\u2019s rule language. One such feature is the support for regular path expressions, which would let two nodes to be consideredas a \u201cmatch\u201d, if a certain path of edges exists between them. In this paper, the incorporation of regular expression support into incremental pattern matching is discussed within the context of the GROOVE tool set. This includes laying down a formal foundation for incremental pattern matching for regular expressions which is then used to justify the extension proposed to add regular expression support to a well-known pattern matching algorithm.", "num_citations": "7\n", "authors": ["671"]}
{"title": "A graph-transformation-based semantics for analysing aspect interference\n", "abstract": " AOP is widely accepted as a language concept to improve separation of concerns. However, the separate development of aspects may introduce semantic problems in the composition of the aspects and the base system. We propose a modular and graph-based verification approach. An aspect-oriented program is represented by a graph. A graph production system specifying the semantics of the language allows us to generate a transition system of the execution of the program. This can be used to analyse and verify different properties of the system. We show that, currently, it allows the detection of semantic differences between advice orderings on shared joinpoints, which is one of the semantic problems referred to above.", "num_citations": "7\n", "authors": ["671"]}
{"title": "Action contraction\n", "abstract": " The question we consider in this paper is: \u201cWhen can a combination of fine-grain execution steps be contracted into an atomic action execution\u201d? Our answer is basically: \u201cWhen no observer can see the difference.\u201d This is worked out in detail by defining a notion of coupled split/atomic simulation refinement between systems which differ in the atomicity of their actions, and proving that this collapses to Parrow and Sj\u00f6din\u2019s coupled similarity when the systems are composed with an observer.", "num_citations": "7\n", "authors": ["671"]}
{"title": "Graph attribution through sub-graphs\n", "abstract": " We offer an alternative to the standard way of formalising attributed graphs. We propose to represent them as graphs with a marked sub-graph that represents the data domain, rather than as tuples of graph and algebra. This is a general construction which can be shown to preserve adhesiveness of categories; it has the advantage of uniformity and gives more flexibility in defining data abstractions. We show equivalence of our formalisation with the standard one, under a suitable encoding of algebras as graphs.", "num_citations": "6\n", "authors": ["671"]}
{"title": "On a graph formalism for ordered edges\n", "abstract": " Though graphs are flexible enough to model any kind of data structure in principle, for some structures this results in a rather large overhead. This is for instance true for lists, ie, edges that are meant to point to an ordered collection of nodes. Such structures are frequently encountered, for instance as ordered associations in UML diagrams. Several options exist to model lists using standard graphs, but all of them need auxiliary structure, and even so their manipulation in graph transformation rules is not trivial.", "num_citations": "6\n", "authors": ["671"]}
{"title": "On a graph-based semantics for uml class and object diagrams\n", "abstract": " In this paper we propose a formal extension of type graphs with notions that are commonplace in the UML and have long proven their worth in that context: namely, inheritance, multiplicity, containment and the like. We believe the absence of a comprehensive and commonly agreed upon formalisation of these notions to be an important and, unfortunately, often ignored omission. Since our eventual aim (shared by many researchers) is to give unambiguous, formal semantics to the UML using the theory of graphs and graph transformation, in this paper we propose a set of definitions to repair this omission. With respect to previous work in this direction, our aim is to arrive at more comprehensive and at the same time simpler definitions.", "num_citations": "6\n", "authors": ["671"]}
{"title": "Weakest Preconditions for High-level Programs:(long Version)\n", "abstract": " In proof theory, a standard method for showing the correctness of a program wrt given pre-and postconditions is to construct a weakest precondition and to show that the precondition implies the weakest precondition. In this paper, graph programs in the sense of Habel and Plump 2001 are extended to programs over high-level rules with application conditions, a formal definition of weakest preconditions for high-level programs in the sense of Dijkstra 1975 is given, and a construction of weakest preconditions is presented.", "num_citations": "6\n", "authors": ["671"]}
{"title": "Process creation and full sequential composition in a name-passing calculus\n", "abstract": " This paper presents the underlying theory for a process calculus featuring process creation, and sequential composition, instead of the more usual parallel composition, and action prefixing, in a setting where mobility is achieved by communicating channel names. We discuss the questions of scope and name binding, raised by the interaction of mobility and sequential composition. Substitution of names is integrated as a syntactic operator in the calculus. We present an axiomatic theory for the calculus and show its soundness and completeness w.r.t. bisimulation equivalence.", "num_citations": "6\n", "authors": ["671"]}
{"title": "Multi-paradigm modelling for cyber\u2013physical systems: a descriptive framework\n", "abstract": " The complexity of cyber\u2013physical systems (CPSs) is commonly addressed through complex workflows, involving models in a plethora of different formalisms, each with their own methods, techniques, and tools. Some workflow patterns, combined with particular types of formalisms and operations on models in these formalisms, are used successfully in engineering practice. To identify and reuse them, we refer to these combinations of workflow and formalism patterns as modelling paradigms. This paper proposes a unifying (Descriptive) Framework to describe these paradigms, as well as their combinations. This work is set in the context of Multi-Paradigm Modelling (MPM), which is based on the principle to model every part and aspect of a system explicitly, at the most appropriate level (s) of abstraction, using the most appropriate modelling formalism (s) and workflows. The purpose of the Descriptive Framework\u00a0\u2026", "num_citations": "5\n", "authors": ["671"]}
{"title": "A model-driven framework for hardware-software co-design of dataflow applications\n", "abstract": " Hardware-software (HW-SW) co-design allows to meet system-level objectives by exploiting the synergy of hardware and software. Current tools and approaches for HW-SW co-design face difficulties coping with the increasing complexity of modern-day application due to, e.g., concurrency and energy constraints. Therefore, an automated modeling approach is needed which satisfies modularity, extensibility and interoperability requirements. Model-Driven Engineering (MDE) is a prominent paradigm that, by treating models as first-class citizens, helps to fulfill these requirements. This paper presents a state-of-the-art MDE-based framework for HW-SW co-design of dataflow applications, based on synchronous dataflow (SDF) graph formalism. In the framework, we introduce a reusable set of three coherent metamodels for creating HW-SW co-design models concerning SDF graphs, hardware platforms and\u00a0\u2026", "num_citations": "5\n", "authors": ["671"]}
{"title": "Software and systems modeling with graph transformations theme issue of the Journal on Software and Systems Modeling\n", "abstract": " Over the years model-based development has rapidly gained popularity in various engineering disciplines. Numerous efforts have resulted in the invention of an abundance of appropriate modeling concepts, languages, and tools. Today modeling activities often span multiple disciplines and have to be addressed by collaborative efforts across disciplines such as industrial automation, business engineering, hardware/software co-design, real-time system development, Web 2.0 application design, and so forth. As a consequence, model-based development techniques related to the analysis, synchronization, and execution of families of models that are concurrently developed by different engineers on different levels of abstraction play a major role in many software and systems development projects. Graphs, on the other hand, are among the simplest and most universal models for a variety of systems, not just in\u00a0\u2026", "num_citations": "5\n", "authors": ["671"]}
{"title": "Graph transforming Java data\n", "abstract": " This paper introduces an approach for adding graph transformation-based functionality to existing Java programs. The approach relies on a set of annotations to identify the intended graph structure, as well as on user methods to manipulate that structure, within the user\u2019s own Java class declarations. Other ingredients are a custom transformation language, called Chart, and a compiler from Chart to Java. The generated Java code runs against the pre-existing, annotated code. The advantage of the approach is that it allows any Java program to be enhanced, non invasively, with declarative graph rules, improving clarity, conciseness and verifiability.", "num_citations": "5\n", "authors": ["671"]}
{"title": "Showing full semantics preservation in model transformation\u2013a comparison of techniques\n", "abstract": " Model transformation is a prime technique in modern, model-driven software design. One of the most challenging issues is to show that the semantics of the models is not affected by the transformation. So far, there is hardly any research into this issue, in particular in those cases where the source and target languages are different.In this paper, we are using two different state-of-the-art proof techniques (explicit bisimulation construction versus borrowed contexts) to show bisimilarity preservation of a given model transformation between two simple (self-de\ufb01ned) languages, both of which are equipped with a graph transformation-based operational semantics. The contrast between these proof techniques is interesting because they are based on different model transformation strategies: triple graph grammars versus in situ transformation. We proceed to compare the proofs and discuss scalability to a more realistic setting.", "num_citations": "5\n", "authors": ["671"]}
{"title": "Graph-based tools: The contest\n", "abstract": " This event is the second instance of the contest for graph transformation-based tools, which was first held as part of the AGTIVE workshop. The aim is to stimulate tool development by providing a sense of competitiveness, as well as the chance to get to know and learn from the features of other, related tools.", "num_citations": "5\n", "authors": ["671"]}
{"title": "Deterministic pomsets\n", "abstract": " This paper is about partially ordered multisets (pomsets for short). We investigate a particular class of pomsets that we call deterministic, properly including all partially ordered sets, which satisfies a number of interesting properties: among other things, it forms a distributive lattice under pomset prefix (hence prefix closed sets of deterministic pomsets are prime algebraic), and it constitutes a reflective subcategory of the category of all pomsets. For the deterministic pomsets we develop an algebra with a sound and (#-) complete equational theory. The operators in the algebra are concatenation and join, the latter being a variation on the more usual disjoint union of pomsets with the special property that it yields the least upper bound with respect to pomset prefix. This theory is then extended in several ways. We capture refinement of pomsets by incorporating homomorphisms between models as objects in the algebra and homomorphism application as a new operator. This in turn...", "num_citations": "5\n", "authors": ["671"]}
{"title": "LOCKS: a property specification language for security goals\n", "abstract": " We introduce a formal specification language LOCKS, that allow security practitioners to express as well as compose security goals in a convenient manner. LOCKS supports the specification of the most common security properties over generic attributes, both for qualitative and quantitative goals. To make our language independent of a specific security framework, we evaluate LOCKS over a generic attack model, namely the structural attack model (SAM), which over-arches the most prominent graphical threat models. Furthermore, we equip our language with a concise grammar, type rules and denotational semantics, thus laying the foundations of an automated tool. We take a number of informal security goals from the literature and show how they can be formally expressed in our language.", "num_citations": "4\n", "authors": ["671"]}
{"title": "Graph-versus vector-based analysis of a consensus protocol\n", "abstract": " The Paxos distributed consensus algorithm is a challenging case-study for standard, vector-based model checking techniques. Due to asynchronous communication, exhaustive analysis may generate very large state spaces already for small model instances. In this paper, we show the advantages of graph transformation as an alternative modelling technique. We model Paxos in a rich declarative transformation language, featuring (among other things) nested quantifiers, and we validate our model using the GROOVE model checker, a graph-based tool that exploits isomorphism as a natural way to prune the state space via symmetry reductions. We compare the results with those obtained by the standard model checker Spin on the basis of a vector-based encoding of the algorithm.", "num_citations": "4\n", "authors": ["671"]}
{"title": "Class diagram restructuring with GROOVE\n", "abstract": " This paper describes the GROOVE solution to the \"Class Diagram Restructuring\" case study of the Tool Transformation Contest 2013. We show that the visual rule formalism enables the required restructuring to be formulated in a very concise manner. Moreover, the GROOVE functionality for state space exploration allows checking confluence. Performance-wise, however, the solution does not scale well.", "num_citations": "4\n", "authors": ["671"]}
{"title": "Formal Methods for Open Object-Based Distributed Systems V: IFIP TC6/WG6. 1 Fifth International Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS\u00a0\u2026\n", "abstract": " Formal Methods for Open Object-Based Distributed Systems V brings together research in three important and related fields: Formal methods; Distributed systems; Object-based technology. Such a convergence is representative of recent advances in the field of distributed systems, and provides links between several scientific and technological communities. The wide scope of topics covered in this volume range in subject from UML to object-based languages and calculi and security, and in approach from specification to case studies and verification. This volume comprises the proceedings of the Fifth International Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 2002), which was sponsored by the International Federation for Information Processing (IFIP) and held in Enschede, The Netherlands in March 2002.", "num_citations": "4\n", "authors": ["671"]}
{"title": "A first study of compositionality in graph transformation\n", "abstract": " Graph transformation works under a whole-world assumption. In modelling realistic systems, this typically makes for large graphs and sometimes also large, hard to understand rules. From process algebra, on the other hand, we know the principle of reactivity, meaning that the system being modelled is embedded in an environment with which it continually interacts. This has the advantage of allowing modular system specifications and correspondingly smaller descriptions of individual components. Reactivity can alternatively be understood as enabling compositionality: the specification of components and subsystems are composed to obtain the complete model.In this work we show a way to ingest graph transformation with compositionality, reaping the same benefits from modularity as enjoyed by process algebra. In particular, using the existing concept of graph interface, we show under what circumstances rules can be decomposed into smaller subrules, each working on a subgraph of the complete, whole-world graph, in such a way that the effect of the original rule is precisely captured by the synchronisation of subrules.", "num_citations": "4\n", "authors": ["671"]}
{"title": "Live challenge problem\n", "abstract": " The destination-coded vehicle (DCV) is a metal cart with wheels on the bottom and a plastic tub on top. Its only electronic device is a passive radio-frequency circuit that broadcasts a unique number identifying that particular car. The job of the DCV is to move your bag quickly to an off-ramp at the gate. DCVs are used at airports because the distance from the main terminal to the passenger terminals is quite long, and passengers make the commute fairly quickly by train. The DCV can travel up to five times faster than a conveyor at 20 mph.A conveyor belt is a device that conveys (carries) large quantities of material from place to place. It consists of an endless belt that is looped over two pulleys. One of the pulleys is called the drive pulley, and supplies the power that keeps the belt moving. Most conveyor belts are powered by an electric motor. Its speed is 4 mph.", "num_citations": "4\n", "authors": ["671"]}
{"title": "A logic of local graph shapes\n", "abstract": " Graphs are an intuitive model for states of a (software) system that involve dynamic resource allocation or pointer structures, such as, for instance, object-oriented programs. However, a straightforward encoding results in large individual states and large, or even unbounded, state spaces. As usual, some form of abstraction is necessary in order to arrive at a tractable model. In this paper we propose a fragment of first-order graph logic that we call local shape logic (LSL) as a possible abstraction mechanism. LSL is inspired by previous work of Sagiv, Reps and Wilhelm. An LSL formula constrains the multiplicities of nodes and edges in state graphs; abstraction is achieved by reasoning not about individual, concrete state graphs but about their characteristic shape properties. We show that the expressiveness of LSL is equal to integer programming, and as a consequence, LSL is decidable.(This is a slight generalisation of the decidability of two-variable first order logic.)We go on to define the concept of the canonical shape of a state graph, which is expressed in a monomorphic sub-fragment of LSL, for which we define a graphical representation. We show that the canonical shapes give rise to a finite abstraction of the state space of a software system, and we give an upper bound to the size of this abstract state space.", "num_citations": "4\n", "authors": ["671"]}
{"title": "A complete theory of deterministic event structures\n", "abstract": " We present an \u03c9-complete algebra of a class of deterministic event structures, which are labelled prime event structures where the labelling function satisfies a certain distinctness condition. The operators of the algebra are summation, sequential composition and join. Each of these gives rise to a monoid; in addition a number of distributivity properties hold. Summation loosely corresponds to choice and join to parallel composition, with however some nonstandard aspects.             The space of models is a complete partial order (in fact a complete lattice) in which all operators are continuous; hence minimal fixpoints can be defined inductively. Moreover, the submodel relation can be captured within the algebra by summation (x\u2291y iff x+y=y); therefore the effect of fixpoints can be captured by an infinitary proof rule, yielding a complete proof system for recursively defined deterministic event structures.", "num_citations": "4\n", "authors": ["671"]}
{"title": "Generalised compositionality in graph transformation\n", "abstract": " We present a notion of composition applying both to graphs and to rules, based on graph and rule interfaces along which they are glued. The current paper generalises a previous result in two different ways. Firstly, rules do not have to form pullbacks with their interfaces; this enables graph passing between components, meaning that components may \u201clearn\u201d and \u201cforget\u201d subgraphs through communication with other components. Secondly, composition is no longer binary; instead, it can be repeated for an arbitrary number of components.", "num_citations": "3\n", "authors": ["671"]}
{"title": "Distributed graph-based state space generation\n", "abstract": " LTSMIN provides a framework in which state space generation can be distributed easily over many cores on a single compute node, as well as over multiple compute nodes. The tool works on the basis of a vector representation of the states; the individual cores are assigned the task of computing all successors of states that are sent to them. In this paper we show how this framework can be applied in the case where states are essentially graphs interpreted up to isomorphism, such as the ones we have been studying for GROOVE. This involves developing a suitable vector representation for a canonical form of those graphs. The canonical forms are computed using a third tool called BLISS. We combined the three tools to form a system for distributed state space generation based on graph grammars.", "num_citations": "3\n", "authors": ["671"]}
{"title": "Isomorphism Checking for Symmetry Reduction\n", "abstract": " In this paper, we show how isomorphism checking can be used as an effective technique for symmetry reduction. Reduced state spaces are equivalent to the original ones under a strong notion of bisimilarity which preserves the multiplicity of outgoing transitions, and therefore also preserves stochastic temporal logics. We have implemented this in a setting where states are arbitrary graphs. Since no efficiently computable canonical representation is known for arbitrary graphs modulo isomorphism, we define an isomorphism-predicting hash function on the basis of an existing partition refinement algorithm. As an example, we report a factorial state space reduction on a model of an ad-hoc network connectivity protocol.", "num_citations": "3\n", "authors": ["671"]}
{"title": "A process algebra semantics for Message Sequence Charts including conditions\n", "abstract": " Message Sequence Charts (MSCs) are a graphical and textual language for the speci cation of message passing systems, in particular telecommunication systems. MSCs are standardised by the Internal Telecommunication Union in standard Z. 120. Included in the standard is a formal semantics for MSCs by means of a process algebra. This semantics covers the complete language of single MSCs but lacks an interpretation for conditions which are used as continuation points of MSCs within an MSC document (a collection of MSCs). In this paper, we give a process algebraic semantics for basic MSCs including conditions, enabling the formal interpretation of entire MSC documents.", "num_citations": "3\n", "authors": ["671"]}
{"title": "Causal traces\n", "abstract": " Causal traces are strings over caused actions, which do not only tell what has happened (the action) but also on which actions in the past this was dependent (the causes). The latter information is provided by a set of backpointers along the trace, in the form of positive natural numbers. Thus, causal traces are the linear time counterpart of the well-known model of causal trees. We develop a complete algebra of causal traces, in which it is allowed to swap subtraces that are causally independent. Care has to be taken that such swapping is congruent with respect to trace composition; in particular, caused actions that occur later in the trace may have to be adjusted to take swapping into account. The objects of the algebra are therefore not simply traces, but traces combined with a causal adjustment which retains the necessary information to make concatenation well-defined. We show how adjusted causal traces can be used to implement Mazurkiewicz traces, and how they may be used as morphisms in a symmetric strict monoidal category very similar to that of concatenable (Petri net) processes.", "num_citations": "3\n", "authors": ["671"]}
{"title": "A model-driven framework for hardware-software co-design of dataflow applications (extended version)\n", "abstract": " Hardware-software (HW-SW) co-design allows to meet systemlevel objectives by exploiting the synergy of hardware and software. Current tools and approaches for HW-SW co-design face difficulties coping with the increasing complexity of modern-day application due to, eg, concurrency and energy constraints. Therefore, an automated modeling approach is needed which satisfies modularity, extensibility, and interoperability requirements. Model-Driven Engineering (MDE) is a prominent paradigm that, by treating models and model transformations as firstclass citizens, helps to fulfill these requirements. This paper presents a state-of-the-art MDE-based framework for HW-SW co-design of dataflow applications, based on synchronous dataflow (SDF) graph formalism. In the framework, we introduce a reusable set of three coherent metamodels for creating HW-SW co-design models concerning SDF graphs, hardware platforms and allocation of SDF tasks to hardware. The framework also contains model transformations that cast these models into priced timedautomata models, the input language of the well-known model checker UPPAAl CoRA. We demonstrate how our framework satisfies the requirements of modularity, extensibility, and interoperability in an industrial case study.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Model Patterns\n", "abstract": " We know by now that evolution in software is inevitable. Given that is so, we should not just allow for but accommodate for change throughout the software lifecycle. The claim of this paper is that, in order to accommodate for change effectively, we need a modelling discipline with a built-in notion of refinement, so that domain concepts can be defined and understood on their appropriate level of abstraction, and change can be captured on that same level. Refinement serves to connect levels of abstraction within the same model, enabling a simultaneous understanding of that same model on different levels. We propose the term model pattern for the central concept in such a modelling discipline.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Conflict detection and analysis for single-pushout high-level replacement\n", "abstract": " In many graph transformation systems (local) confluence is a desired property. For instance, if graph transformation is used for model transformation, then confluence and termination ensure that the order in which rules are applied does not matter, in other words, the final result will always be the same. In this research we investigate su cient conditions for local confluence of high-level replacement (HLR) systems. Using the single-pushout high-level replacement approach we de ne critical pairs (minimal conflicting situations). Our su cient condition for local confluence is based on the analysis of critical pairs. We provide our proofs on a categorical level, therefore our theory cannot only be applied to the category of graphs: we formulate requirements for the categories for which our theorems hold, and we show that our theory is also applicable to attributed graphs. We also present some of the foundations for confluence analysis for HLR systems with negative application conditions (NACs). In order to show local confluence for a HLR system with NACs we will show that stricter conditions must hold for the critical pairs with NACs (compared to the situation without NACs). We show that HLR systems without NACs are locally confluent. Further analysis of HLR systems with NACs is future work. Our theory has been implemented in the graph transformation tool groove. Using our implementation we can  nd all critical pairs for a graph transformation system, and analyse if these pairs are locally confluent. Using this implementation we have performed some experiments on existing graph transformation systems.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Saying Hello World with GROOVE-A Solution to the TTC 2011 Instructive Case\n", "abstract": " This report presents a solution to the Hello World case study of TTC 2011 using GROOVE. We provide and explain the grammar that we used to solve the case study. Every requested question of the case study was solved by a single rule application.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Neighbourhood Abstraction in GROOVE-Tool Paper\n", "abstract": " In this paper we discuss the implementation of neighbourhood graph abstraction in the GROOVE tool set. Important classes of graph grammars may have unbounded state spaces and therefore cannot be verified with traditional model checking techniques. One way to address this problem is to perform graph abstraction, which allows us to generate a finite abstract state space that over-approximates the original one. In previous work we presented the theory of neighbourhood abstraction. In this paper, we present the implementation of this theory in GROOVE and illustrate its applicability with a case study that models a single-linked list.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Towards model structuring based on flow diagram decomposition\n", "abstract": " The key challenge of model transformations in model-driven development is in transforming higher-level abstract models into more concrete ones that can be used to generate implementation level models, including executable business process representations and program code. Many of the modelling languages (like UML Activity Diagrams or BPMN) use unstructured flow graphs to describe the operation sequence of a business process. If a structured language is chosen as the executable representation, it is difficult to compile the unstructured flows into structured statements. Even if a target language structure contains goto-like statements it is often simpler and more efficient to deal with programs that have structured control flow to make the executable representation more understandable.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Graph-based specification and simulation of featherweight java with around advice\n", "abstract": " In this paper we specify an operational run-time semantics of Assignment Featherweight Java--a minimal subset of Java with assignments--with around advice, using graph transformations. We introduce a notion of correctness of our specification with respect to an existing semantics and claim a number of advantages over traditional mathematical notations, that come forth from the executable nature of graph-transformation-based semantics.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Action refinement for vertical implementation\n", "abstract": " Action Refinement for Vertical Implementation (1997) | www.narcis.nl KNAW KNAW Narcis Back to search results University of Twente Publication Action Refinement for Vertical Implementation (1997) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Action Refinement for Vertical Implementation Published in Formale Beschreibungstechniken f\u00fcr verteilte Systeme: GI/ITG-Fachgespr\u00e4ch, 19.-20. Juni 1997 in Berlin, 69 - 78 Series GMD Studien, 315. GMD-Forschungszentrum Informationstechnik GmbH Author Rensink, Arend; Gorrieri, Roberto Editor Wolisz, A.; Schieferdecker, I.; Rennoch, A. Date issued 1997 Access Restricted Access Language English Type Conference Paper Publisher GMD-Forschungszentrum Informationstechnik GmbH Publication https://research.utwente.nl/en/publications/action-refinemen... OpenURL Search this publication \u2026", "num_citations": "2\n", "authors": ["671"]}
{"title": "Abstraction and refinement in configuration structures\n", "abstract": " An abstraction operator for configuration structures is defined and it is proven that it is left inverse to the traditional refinement operator. The abstraction operator describes how concrete behaviour looks when observed from a more abstract level, where the difference between concrete and abstract is given by a transformation mapping. This generates a notion of implementation: L is said to implement H iff L is mapped to H by the abstraction operator. The implementation relation generated by the abstraction operator is strictly more general than the implementation function defined by a refinement operator, thus allowing a more flexible design process for distributed systems.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Selection structures\n", "abstract": " Selection Structures \u2014 University of Twente Research Information Skip to main navigation Skip to search Skip to main content University of Twente Research Information Logo Home Profiles Research Units Research Output Datasets Activities Prizes Press / Media Search by expertise, name or affiliation Selection Structures Arend Rensink Research output: Book/Report \u203a Report \u203a Other research output Overview Original language Undefined Place of Publication Enschede Publisher University of Twente, Department of Computer Science Number of pages 32 Publication status Published - 1990 Keywords EWI-7565 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Rensink, A. (1990). Selection Structures. University of Twente, Department of Computer Science. Rensink, Arend. / Selection Structures. Enschede : University of Twente, Department of Computer Science, 1990. 32 p. Rensink, A 1990, Selection \u2026", "num_citations": "2\n", "authors": ["671"]}
{"title": "CTL model checking in groove\n", "abstract": " Much research has been done in the field of model-checking complex systems (either hardware or software). Approaches that use explicit state modelling mostly use bit vectors to represent the states of such systems. Unfortunately, that kind of representation does not extend smoothly to systems in which the states contain values from a domain other than primitive types, such as reference values commonly used in object-oriented systems.In this paper we report preliminary results on applying CTL model checking on state spaces generated using graph transformations. The states of such state spaces have an internal graph structure which makes it possible to represent complex system states without the need to know the exact structure beforehand as when using bit vectors.", "num_citations": "2\n", "authors": ["671"]}
{"title": "Recipes for Coffee: Compositional Construction of JAVA Control Flow Graphs in GROOVE\n", "abstract": " The graph transformation tool GROOVE supports so-called recipes, which allow the elaboration of composite rules by gluing simple rules via a control language. This paper shows how recipes can be used to provide a complete formalization (construction) of the control flow semantics of JAVA 6. This construction covers not only basic language elements such as branches and loops, but also abrupt termination commands, such as exceptions. By handling the whole JAVA 6 language, it is shown that the method scales and can be used in real-life settings. Our implementation has two major strengths. First, all rule sequencing is handled by recipes, avoiding the need to include extraneous elements in the graphs for this purpose. Second, the approach provides rules modularization: related rules are grouped in recipes, which in turn can be used again to form larger, more elaborated recipes. This gives rise to an\u00a0\u2026", "num_citations": "1\n", "authors": ["671"]}
{"title": "Publishing your prototype tool on the web: PUPTOL, a framework\n", "abstract": " We describe an approach to reduce the effort involved in disseminating prototype academic (command-line) tools for wider use and inspection. This helps in preserving the effort involved in the development of such tools, and in raising the standards in computer science for conducting repeatable experiments. For this purpose we propose a light-weight, flexible framework to make such tools available via web forms.", "num_citations": "1\n", "authors": ["671"]}
{"title": "Graph passing in graph transformation\n", "abstract": " Graph transformation works under the whole world assumption. Therefore, in realistic systems, both the individual graphs and the set of all such graphs can grow very large. In reactive formalisms such as process algebra, on the other hand, each system is split into smaller components which continually interact; the interactions pass information such as names or locations between components. The state spaces for the separate components are typically much smaller, and much efficiency can be gained by analysing system behaviour on this level.", "num_citations": "1\n", "authors": ["671"]}
{"title": "Formal semantics of the CHART transformation language\n", "abstract": " This document describes the formal semantics of CHART, which is a custom transformation language developed for the RDT in the CHARTER project. The purpose of the semantics is to unambiguously determine, on the mathematical level, what the output is when a given transformation is applied to a given input graph. The semantics allows desirable properties of the transformation, such as preservation of semantics or termination, to be expressed formally, and subsequently allows criteria to be established which ensure that these properties actually hold in practice. This document presents the semantics only, and is written completely on a theoretical, mathematical level. Although no advanced concepts are used, and all definitions are also explained informally, a basic understanding of the core concepts of formal mathematics and logic is still recommended for reading this deliverable. Moreover, knowledge about the RDT and its transformation language CHART is also required.The remainder of this document is structured as follows. Chapter 2 introduces several preliminary notations that are used throughout this document. Chapters 3 and 4 define the mathematical data structures for graphs (and type graphs) and transformations, respectively. Chapters 5 and 6, finally, describe the behavior of transformations, in terms of mathematical functions that operate on the formalized data structures.", "num_citations": "1\n", "authors": ["671"]}
{"title": "Extending the Groove Control Language with Variables\n", "abstract": " Graphs can be used to model a variety of things, not only in computers but also in real-world settings. What we model with graphs, we would then like to check in some capacity, verifying its correctness. We do this with graph transformation tools, of which there are many and each has its own unique features. Groove is the graph transformation tool developed by the Formal Methods and Tools group of the University of Twente, and this project focuses on extending Groove with additional functionality. Groove currently supports the scheduling of graph transformation rules using an imperative control language. In this Master\u2019s Thesis we theoretically work out a method to further control not only when graph transformation rules are scheduled but also where, by parameterising the rules in order to both get information from the host graph into the control structure as well as vice versa, telling Groove where to apply rules. We have also done the theory of letting users input constants directly from the control language, instead of having to write rules with hardcoded attributes in them. Both of these ideas have been implemented into the tool.Using these new features, we reduce the amount of meta-information required in the rules as well as the underlying graph, instead keeping it where we think it belongs-together with the other control information. We show a number of examples which benefit from each of these new features.", "num_citations": "1\n", "authors": ["671"]}
{"title": "Verifying Full Semantic Preservation of Model Transformation is Hard\n", "abstract": " Model transformation is a prime technique in modern, model-driven software design. One of the most challenging issues is to show that the semantics of the models is not affected by the transformation. So far, there is virtually no research into this issue, in particular in those cases where the source and target languages are different.In this paper, we are using two different state-of-the-art proof techniques (explicit bisimulation construction versus borrowed contexts) to show bisimilarity preservation of a given model transformation between two simple (self-defined) languages, both of which are equipped with a graph transformation-based operational semantics. The contrast between these proof techniques is interesting because they are based on different model transformation strategies: triple graph grammars versus in situ transformation. We proceed to compare the proofs, concluding that, though the approaches\u00a0\u2026", "num_citations": "1\n", "authors": ["671"]}
{"title": "Graph transformation for concurrency and verification-preface\n", "abstract": " Graph Transformation for Concurrency and Verification - Preface \u2014 University of Twente Research Information Skip to main navigation Skip to search Skip to main content University of Twente Research Information Logo Home Profiles Research Units Projects Research output Datasets Activities Prizes Press / Media Search by expertise, name or affiliation Graph Transformation for Concurrency and Verification - Preface Arend Rensink, Reiko Heckel, Barbara K\u00f6nig Research output: Chapter in Book/Report/Conference proceeding \u203a Conference contribution \u203a Academic Overview Original language Undefined Title of host publication Proceedings of the Workshop on Graph Transformation for Concurrency and Verification (GT-VC) Place of Publication Amsterdam Publisher Elsevier Pages 1-2 Number of pages 2 DOIs https://doi.org/10.1016/j.entcs..Publication status Published - Jul 2007 Event Workshop on Graph \u2026", "num_citations": "1\n", "authors": ["671"]}
{"title": "Representing First-Order Logic Using Graphs\n", "abstract": " We show how edge-labelled graphs can be used to represent first-order logic formulae. This gives rise to recursively nested structures, in which each level of nesting corresponds to the negation of a set of existentials. The model is a direct generalisation of the negative application conditions used in graph rewriting, which count a single level of nesting and are thereby shown to correspond to the fragment\u2203\u00ac\u2203 of first-order logic. Vice versa, this generalisation may be used to strengthen the notion of application conditions. We then proceed to show how these nested models may be flattened to (sets of) plain graphs, by allowing some structure on the labels. The resulting formulae-as-graphs may form the basis of a unification of the theories of graph transformation and predicate transformation.", "num_citations": "1\n", "authors": ["671"]}
{"title": "AGTIVE\u201903: Summary from the Outside In\n", "abstract": " Occasionally it happens that, while researching a\u00a0particular subject, one encounters a\u00a0previously unfamiliar field that turns out to be surprisingly appropriate and applicable. This is what occurred to me when, in investigating techniques for capturing the semantics of object-oriented programs, I came across graph transformations.", "num_citations": "1\n", "authors": ["671"]}
{"title": "Formal foundations for reasoning about evolution\n", "abstract": " Designing software systems is difficult. Designing systems that are capable of evolving is even more difficult. Often the system evolves in an unforeseen direction. Practice shows that software systems grow in small evolutionary steps. An evolution usually influences the behavior and the structure of the system. However, it is not desired that the evolution influences one or more modules of the system that are functionally or logically not related to the evolution; the behavior and structure of these modules should be preserved.In this position paper, we introduce an algebra as a formal foundation for reasoning about evolution. The algebra can be used to express changes in the behavior and structure of the design when it evolves. The aim is to eventually use the algebra to give decision support to the developer during the evolution of a software system.", "num_citations": "1\n", "authors": ["671"]}
{"title": "A Mobile Calculus with Data\n", "abstract": " A Mobile Calculus with Data (1999) | www.narcis.nl KNAW KNAW Narcis Back to search results University of Twente Publication A Mobile Calculus with Data (1999) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title A Mobile Calculus with Data Series Informatik-Bericht. Technical University of Braunschweig Author Gehrke, Thomas; Rensink, Arend Date issued 1999 Access Open Access Language English Type Report Publisher Technical University of Braunschweig Publication https://research.utwente.nl/en/publications/a-mobile-calculu... Persistent Identifier urn:nbn:nl:ui:28-66678 Metadata XML Source University of Twente Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer \u2026", "num_citations": "1\n", "authors": ["671"]}
{"title": "CALIBAN-Esprit Basic Research WG 6067\n", "abstract": " This paper describes the results of the Esprit Basic Research Working Group 6067 CALIBAN (Causal Calculi Based on Nets).", "num_citations": "1\n", "authors": ["671"]}
{"title": "Order isomorphism does not preserve global event independence\n", "abstract": " We report a negative result on the characterisation of partial order equivalence relations over models which feature a global notion of event independence. We show an example of two systems which are equivalent in a very strong sense, viz. give rise to isomorphic domains of computations, but which do not admit any independence-preserving relation between their respective event sets.", "num_citations": "1\n", "authors": ["671"]}
{"title": "Pattern sets\n", "abstract": " Pattern Sets \u2014 University of Twente Research Information Skip to main navigation Skip to search Skip to main content University of Twente Research Information Logo Home Profiles Research Units Research Output Datasets Activities Prizes Press / Media Search by expertise, name or affiliation Pattern Sets Arend Rensink Research output: Book/Report \u203a Report \u203a Other research output Overview Original language Undefined Place of Publication Enschede Publisher University of Twente, Department of Computer Science Number of pages 22 Publication status Published - 1991 Keywords EWI-7566 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Rensink, A. (1991). Pattern Sets. University of Twente, Department of Computer Science. Rensink, Arend. / Pattern Sets. Enschede : University of Twente, Department of Computer Science, 1991. 22 p. Rensink, A 1991, Pattern Sets. University of Twente, \u2026", "num_citations": "1\n", "authors": ["671"]}
{"title": "Elementary structures of non-atomic events\n", "abstract": " Elementary Structures of Non-Atomic Events \u2014 University of Twente Research Information Skip to main navigation Skip to search Skip to main content University of Twente Research Information Logo Home Profiles Research Units Research Output Datasets Activities Prizes Press / Media Search by expertise, name or affiliation Elementary Structures of Non-Atomic Events Arend Rensink Research output: Book/Report \u203a Report \u203a Other research output Overview Original language Undefined Place of Publication Enschede Publisher University of Twente, Department of Computer Science Number of pages 25 Publication status Published - 1989 Keywords EWI-7039 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Rensink, A. (1989). Elementary Structures of Non-Atomic Events. University of Twente, Department of Computer Science. Rensink, Arend. / Elementary Structures of Non-Atomic Events. Enschede \u2026", "num_citations": "1\n", "authors": ["671"]}