{"title": "The VIVIDE programming environment: connecting run-time information with programmers' system knowledge\n", "abstract": " Programmers benefit from concrete program run-time information during code-centric comprehension activities. Unfortunately, state-of-the-art programming environments distract programmers from their task-oriented thinking by forcing them to cope with (1) tool-driven run-time information access and with (2) tool-driven changing information views. However, current research projects address these problems with new concepts for capturing run-time behavior as needed and for organizing all information on-screen according to the programmers' mental model.", "num_citations": "14\n", "authors": ["2172"]}
{"title": "Gramada: Immediacy in programming language development\n", "abstract": " Domain-specific languages (DSLs) improve software maintainability and programmer productivity by making domain concepts more explicit in the code. However, developing syntax and semantics of DSLs is often challenging and as a result developers seldom take advantage of the benefits of DSLs. One way to lower the entry barrier to DSL development is to give developers immediate and continuous feedback on modifications to a language. We propose Gramada, an environment for developing DSLs in Squeak/Smalltalk which is designed to provide such a live programming experience. It is based on a language development framework with additional support for incremental compilation to improve system response times and a set of tools which creates a steady frame and allows programmers to quickly explore changes to the syntax of a language. Our benchmarks and discussion illustrate how Gramada can\u00a0\u2026", "num_citations": "9\n", "authors": ["2172"]}
{"title": "Codetalk conversations about code\n", "abstract": " Contemporary development environments do not directly and explicitly support developers in having a conversation about the code they write and maintain. This problem is aggravated when geographically dispersed teams need to collaborate on development artifacts. CodeTalk allows developers to have conversations about source code elements. They can mark code sections they are concerned about and annotate them. These annotations provide entry points for an informal discourse about the strengths and weaknesses of these sections and developers can work towards a conclusion on how to proceed on the raised issues. A Squeak/Smalltalk implementation of CodeTalk was evaluated by several small development teams, indicating improvement in the informal assessment of code.", "num_citations": "9\n", "authors": ["2172"]}
{"title": "Unravel programming sessions with thresher: Identifying coherent and complete sets of fine-granular source code changes\n", "abstract": " Development teams benefit from version control systems, which manage shared access to code repositories and persist entire project histories for analysis or recovery. Such systems will be efficient if developers commit coherent and complete change sets. These best practices, however, are difficult to follow because multiple activities often interleave without notice and existing tools impede unraveling changes before committing them. We propose an interactive, graphical tool, called Thresher, that employs adaptable scripts to support developers to group and commit changes\u2014especially for fine-granular change tracking where numerous changes are logged even in short programming sessions. We implemented our tool in Squeak/Smalltalk and derived a foundation of scripts from five refactoring sessions. We evaluated those scripts\u2019 precision and recall, which indicate a reduced manual effort because developers can focus on project-specific adjustments. Having such an interactive approach, they can easily intervene to accurately reconstruct activities and thus follow best practices.", "num_citations": "7\n", "authors": ["2172"]}
{"title": "Applying data-driven tool development to context-oriented languages\n", "abstract": " There are numerous implementations of context-oriented programming on host languages that come with graphical programming environments. However, comprehensive tool support is often missing because building and integrating graphical tools is still laborious; many programmers cannot afford to be both tool user and tool builder. We present a novel, data-driven approach on programming tools to alleviate this problem. We implemented a framework in Squeak/Smalltalk and show how programmers can use it to create and adapt integrated tools for ContextS2.", "num_citations": "7\n", "authors": ["2172"]}
{"title": "Adopting design practices for programming\n", "abstract": " Developers continuously design their programs. For example, developers strive for simplicity and consistency in their constructions like practitioners in most design fields. A simple program design supports working on current and future development tasks. While many problems addressed by developers have characteristics similar to design problems, developers typically do not use principles and practices dedicated to such problems. In this chapter we report on the adoption of design practices for programming. First, we propose a new concept for integrated programming environments that encourages developers to work with concrete representations of abstract thoughts within a flexible canvas. Second, we present continuous versioning as our approach to support the need for withdrawing changes during program design activities.", "num_citations": "7\n", "authors": ["2172"]}
{"title": "Evolving User Interfaces From Within Self-supporting Programming Environments: Exploring the Project Concept of Squeak/Smalltalk to Bootstrap UIs\n", "abstract": " It is common practice to create new technologies with the existing ones and eventually replace them. We investigate the domain of user interfaces (UIs) in self-supporting programming environments. The Squeak/Smalltalk programming system has a history of almost 20 years of replacing Smalltalk-80's model-view-controller (MVC) with Self's Morphic, a direct manipulation interface. In the course of this transition, we think it is likely that Squeak managed to provide an abstraction for arbitrary UI frameworks, called projects. In this paper, we describe plain Squeak without its user interface, considering object collaboration, code execution, and extension points in the virtual machine. We implemented a command-line interface, the Squeak Shell, to emphasize the simplicity of adding a new UI to Squeak using this project concept. We believe that self-supporting programming environments can benefit from multiple user\u00a0\u2026", "num_citations": "4\n", "authors": ["2172"]}
{"title": "Live Multi-language Development and Runtime Environments\n", "abstract": " Context: Software development tools should work and behave consistently across different programming languages, so that developers do not have to familiarize themselves with new tooling for new languages. Also, being able to combine multiple programming languages in a program increases reusability, as developers do not have to recreate software frameworks and libraries in the language they develop in and can reuse existing software instead. Inquiry: However, developers often have a broad choice of tools, some of which are designed for only one specific programming language. Various Integrated Development Environments have support for multiple languages, but are usually unable to provide a consistent programming experience due to different language-specific runtime features. With regard to language integrations, common mechanisms usually use abstraction layers, such as the operating system or a network connection, which are often boundaries for tools and hence negatively affect the programming experience. Approach: In this paper, we present a novel approach for tool reuse that aims to improve the experience with regard to working with multiple high-level dynamic, object-oriented programming languages. As part of this, we build a multi-language virtual execution environment and reuse Smalltalk's live programming tools for other languages. Knowledge: An important part of our approach is to retrofit and align runtime capabilities for different languages as it is a requirement for providing consistent tools. Furthermore, it provides convenient means to reuse and even mix software libraries and frameworks written in\u00a0\u2026", "num_citations": "3\n", "authors": ["2172"]}
{"title": "Designing a live development experience for web-components\n", "abstract": " Explorative and live development environments flourish when they can impose restrictions. Forcing a specific programming language or framework, the environment can better enhance the experience of editing code with immediate feedback or direct manipulation. Lively Kernel's user interface (UI) framework Morphic provides such a development experience when working with graphical objects in direct way giving immediate feedback during development. Our new development environment Lively4 achieves a similar development experience, but targeting general HTML elements. Web Components as a new Web standard provide a very powerful abstraction mechanism. Plain HTML elements provide direct building blocks for tools and applications. Unfortunately, Web Components miss proper capabilities to support run-time development. To address this issue, we use object migration to provide immediate\u00a0\u2026", "num_citations": "3\n", "authors": ["2172"]}
{"title": "Towards Gaze Control in Programming Environments\n", "abstract": " Elaborated gaze tracking devices are hitting the consumer market. This gives an existing human-computer interaction technique the chance to be widely applied in software applications. Programmers can benefit from this development. They tend to work on multiple or large screens to interact with diverse tools in parallel. When programmers switch between reading and typing, the keyboard focus might not be where expected. Such distractions leave the programmer dissatisfied. Gaze information can help to determine which tool a programmer focusses on.", "num_citations": "3\n", "authors": ["2172"]}
{"title": "Data-driven tool construction in exploratory programming environments\n", "abstract": " This work presents a new design for programming environments that promote the exploration of domain-specific software artifacts and the construction of graphical tools for such program comprehension tasks. In complex software projects, tool building is essential because domain- or task-specific tools can support decision making by representing concerns concisely with low cognitive effort. In contrast, generic tools can only support anticipated scenarios, which usually align with programming language concepts or well-known project domains.  However, the creation and modification of interactive tools is expensive because the glue that connects data to graphics is hard to find, change, and test. Even if valuable data is available in a common format and even if promising visualizations could be populated, programmers have to invest many resources to make changes in the programming environment. Consequently\u00a0\u2026", "num_citations": "2\n", "authors": ["2172"]}
{"title": "Towards empirical evidence on the comprehensibility of natural language versus programming language\n", "abstract": " In software design teams, communication between programmers and non-programming domain experts is an ongoing challenge. In this communication, source code documents could be a valuable artifact as they describe domain logic in an unambiguous way. Some programming languages, such as the Smalltalk programming language, try to make source code accessible. Its concise syntax and message-passing semantics are so close to basic English, that it is likely to appeal to even non-programming domain experts. However, the inherent obscurity of technical programming details still poses a significant burden for text comprehension. We conducted a code-reading study in form of a questionnaire through Amazon Mechanical Turk and SurveyMonkey. The results indicate that even in simple problem domains, a simple English text is more comprehensive than a simple Smalltalk program\u00a0\u2026", "num_citations": "2\n", "authors": ["2172"]}
{"title": "Towards exploratory software design environments for the multi-disciplinary team\n", "abstract": " The creation of a new software system can be a wicked problem. Consequently, it is important for such projects to have a collaborating team of experts from multiple disciplines. While agile development processes foster such a collaboration on the social level, the tools used by individual experts still prevent team members from seeing the overall result of their collective modifications on the resulting system. Roles in the process, such as content designers and user experience designers, only get feedback on the impact of their changes on their artifacts. Based on the concept of exploratory programming environments, we propose a new perspective on the environments used in software development, called exploratory software design environments. We describe the properties of such an environment and illustrate the perspective with existing related tools and environments.", "num_citations": "2\n", "authors": ["2172"]}
{"title": "Exploratory Development of Data-intensive Applications: Sampling and Streaming of Large Data Sets in Live Programming Environments\n", "abstract": " Business applications are usually data-intensive. The process of designing and implementing such applications benefits from working with realistic data to sharpen requirements and discover pitfalls. However, such data is usually quite extensive and the feedback cycles during programming and design activities can become long and distracting. As a result, programmers might prefer abstract thinking and mental simulations over working with concrete, realistic data. We propose a new approach supporting live programming, with immediate feedback and explorable runtime data, for the domain of data-intensive business applications on top of relational databases. With the integration of streamed access to sampled data, we can employ productive traits of a live programming environment such as Squeak/Smalltalk, which is not optimized for the processing of huge amounts of data and is hence not well-suited for such\u00a0\u2026", "num_citations": "2\n", "authors": ["2172"]}
{"title": "Cross-cutting Commentary: Narratives for Multi-party Mechanisms and Concerns\n", "abstract": " Cross-cutting concerns are an inherent property of the implementation of non-trivial software systems. Their study led to the development of advanced modularity constructs, usually supported by meta-level frameworks and programming language constructs, to improve comprehensibility. Because of their invasive nature, systems need to be refactored or rewritten to take advantage of these constructs. However, practical considerations such as organizational or economical constraints often do not allow for such reengineering efforts, leaving those systems without explicit representations of their cross-cutting concerns.", "num_citations": "1\n", "authors": ["2172"]}
{"title": "smalltalkCI: A Continuous Integration Framework for Smalltalk Projects\n", "abstract": " Continuous integration (CI) is a programming practice that reduces the risk of project failure by integrating code changes multiple times a day. This has always been important to the Smalltalk community, so custom integration infrastructures are operated that allow CI testing for Smalltalk projects shared in Monticello repositories or traditional changesets.", "num_citations": "1\n", "authors": ["2172"]}
{"title": "Making Examples Tangible: Tool Building for Program Comprehension\n", "abstract": " Best practices in design thinking suggest creating and working with tangible prototypes. In software engineering, programmers interact with source code more than with customers. Their intent is to understand the effects of abstract source code on programs in execution. Existing tools for program exploration, however, are tailored to general programming language concepts instead of domain-specific characteristics and programmer\u2019s system knowledge. In this chapter, we establish the need for adapting programming tools in use when navigating, viewing, and collecting examples to increase tangibility, that is, clarity of a concept or idea based on what can be experienced on screen. We present our Vivide tool-building environment, which is a data-driven, scriptable approach to constructing graphical tools with low effort. By exploring common programming scenarios, we conclude that tool building does not\u00a0\u2026", "num_citations": "1\n", "authors": ["2172"]}