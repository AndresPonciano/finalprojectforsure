{"title": "Software change impact analysis\n", "abstract": " From the Publisher: As software systems become increasingly large and complex, the need increases to predict and control the effects of software changes. Software Change Impact Analysis captures the latest information on the science and art of determining what software parts affect each other. It provides a battery of ideas for doing impact analysis better, presents a framework for the field, and focuses attention on important results. You will gain a healthy respect for the strengths and limitations of impact analysis technology and a solid background that will prove valuable for years to come. The book identifies key impact analysis definitions and themes and illustrates the important themes to give you a solid understanding for tackling impact analysis problems. It includes reports on software source code dependency analysis and software traceability analysis and shows how results from both areas can more\u00a0\u2026", "num_citations": "1119\n", "authors": ["73"]}
{"title": "Impact analysis-towards a framework for comparison\n", "abstract": " The term impact analysis is used with many meanings. A three-part framework for characterizing and comparing diverse impact analysis approaches is defined. The parts correspond to how an approach is used to accomplish impact analysis, how an approach does impact analysis internally, and the effectiveness of the impact analysis approach. To illustrate the framework's application, five impact analysis approaches are illustrated according to it.< >", "num_citations": "407\n", "authors": ["73"]}
{"title": "The impact of agile methods on software project management\n", "abstract": " As more and more software projects engage agile methods, there are emerging patterns of success and failure. With growing adoption of agile methods, project managers increasingly need to understand the applicability to their projects and factors that drive key project performance characteristics. While some organizations affirm that agile methods solve all their problems, few have shown consistent success over a range of typical software projects. Agile methods have advantages, especially in accommodating change due to volatile requirements. However, they also present concomitant risks with managing the many dependent pieces of work distributed across a large project. Use of agile methods therefore presents a set of tradeoffs. This paper examines the impact of agile methods on the people involved in a project, the process under which a project is developed, and on the project itself in an attempt to allow\u00a0\u2026", "num_citations": "280\n", "authors": ["73"]}
{"title": "A disciplined approach to adopting agile practices: the agile adoption framework\n", "abstract": " Many organizations aspire to adopt agile processes to take advantage of the numerous benefits that they offer to an organization. Those benefits include, but are not limited to, quicker return on investment, better software quality, and higher customer satisfaction. To date, however, there is no structured process (at least that is published in the public domain) that guides organizations in adopting agile practices. To address this situation, we present the agile adoption framework and the innovative approach we have used to implement it. The framework consists of two components: an agile measurement index, and a four-stage process, that together guide and assist the agile adoption efforts of organizations. More specifically, the Sidky Agile Measurement Index (SAMI) encompasses five agile levels that are used to identify the agile potential of projects and organizations. The four-stage process, on the other\u00a0\u2026", "num_citations": "228\n", "authors": ["73"]}
{"title": "Software change impacts-an evolving perspective\n", "abstract": " As software engineering practice evolves to respond to demands for distributed applications on heterogeneous platforms, software change is increasingly influenced by middleware and components. Interoperability dependency relationships now point to more relevant impacts of software change and necessarily drive the analysis. Software changes to software systems that incorporate middleware components like Web services expose these systems and the organizations they serve to unforeseen ripple effects that frequently result in failures. Current software change impact analysis models have not adequately addressed this trend. Moreover, as software systems grow in size and complexity, the dependency webs of information extend beyond most software engineers ability to comprehend them. This paper examines preliminary research for extending current software change impact analysis to incorporate\u00a0\u2026", "num_citations": "182\n", "authors": ["73"]}
{"title": "A framework for software maintenance metrics\n", "abstract": " The authors introduce a software maintenance process model that emphasizes impact analysis and forms a framework for software maintenance metrics support. Schedule, resource, and other constraints frequently subvert efforts to build and maintain a software product. using direct graphs, the authors suggest traditional process and product metrics, as well as new impact analysis metrics that address software work-product traceability and inter-work-product dependencies. Management can use these and other metrics to understand and control the maintenance process dynamically. As changes are requested, measurements can be made, impact assessed, and implementation decisions made. Moreover, the more the impact is understood, the better the change can be controlled; hence risks are minimized.< >", "num_citations": "182\n", "authors": ["73"]}
{"title": "Impact analysis in the software change process: a year 2000 perspective.\n", "abstract": " Software change impact analysis has gained considerable attention with recent challenges of the Year 2000 Date situation. As the software community recognizes the growing need to identify consequences of these changes, impact analysis is making its way into the software process. Dependencies between software life cycle objects are becoming more numerous and complex as many software systems grow beyond a million of lines of code. Software change efforts are plagued with widely varying estimates for implementing software changes, since the impacts of the change are not readily known in advance. The introduction of software change impact analysis into the software process adds more fidelity to software change visibility, enabling more accurate software change estimates. The paper examines where impact analysis is applied during software changes and describes how impact analysis can be\u00a0\u2026", "num_citations": "164\n", "authors": ["73"]}
{"title": "Extending software change impact analysis into COTS components\n", "abstract": " As software components and middleware occupy more and more of the software engineering landscape, interoperability relationships point to increasingly relevant software change impacts. Packaged software now represents over thirty-two percent of the software in most organizations. While traceability and dependency analysis frameworks have effectively supported software impact analysis in the past, they do not adequately addressed this trend. As software systems grow in size and complexity, their dependency webs of information also extend beyond most software engineers ability to comprehend them. We examine research for extending current software change impact analysis to incorporate interoperability dependency relationships for addressing distributed applications and explores three dimensional (3D) visualization techniques for more effective navigation of software changes.", "num_citations": "96\n", "authors": ["73"]}
{"title": "The project manager's guide to software engineering's best practices\n", "abstract": " Since the earliest days of the computer industry, managing a software project has been a complex and demanding activity. While the technical content of software products and the technical methods used to build them have changed over time, the fundamental issues that determine the success or failure of software projects have remained fairly constant. The contents of this original book, together with the underlying IEEE Standards, are focused toward helping you with your work: an ongoing quest to produce quality software products in a predictable manner.552 pages. April 2002. ISBN 0-7695-1199-6 Catalog# BP01199, $55.00 Members/$65.00 List", "num_citations": "72\n", "authors": ["73"]}
{"title": "A graph traceability approach for software change impact analysis\n", "abstract": " This dissertation presents a graph traceability approach for analyzing software changes. Impact analysis identifies the consequences or ripple-effects of proposed software changes during development and maintenance. Evaluating software change impacts entails\" impact analysis\" to identify what will be affected by a change and on the\" impact assessment\" to determine quantitatively what the impact represents. Impact analysis and assessment are labor-intensive, manual processes with few formal methods or tools.", "num_citations": "48\n", "authors": ["73"]}
{"title": "Project management for the 21st century: supporting collaborative design through risk analysis\n", "abstract": " Managing software project teams is a complex task further complicated by a continued increase in the size and complexity of software-intensive systems and the distribution of project teams. Given limited project resources, distributed teams require appropriate team processes and adequate tool support to help them remain focused on the most critical design tasks, thereby structuring the design process and improving team coordination. However, existing project management tools typically fall short. Software project management as a discipline is not unlike human-computer interaction (HCI) in that both combine technical concerns with human psychological concerns. Both could benefit from a more systematic approach to applying theory to practice. One proposed approach to the science of design involves constructing a record of design rationale by leveraging design knowledge from previous projects. Extending\u00a0\u2026", "num_citations": "40\n", "authors": ["73"]}
{"title": "Model based process assessments\n", "abstract": " The authors present an approach that combines process modeling with process assessments. They use the structured analysis and design technique (SADT) modeling notation (D.A. Marca and C.L. McGowan, 1988). The DoD CIM Initiative has standardized on a subset of SADT, called IDEF0, to model business processes. A SADT (IDEF0) model was created of a large software maintenance process and the model led to process improvements that might have been missed otherwise. This model based process assessment approach is described as a process in its own right.< >", "num_citations": "38\n", "authors": ["73"]}
{"title": "Towards a model-driven architecture for autonomic systems\n", "abstract": " Agent based systems and architectures provide a firm foundation for design and development of an autonomic system. The key challenge is the selection and efficient use of effective agent architecture. A model-driven approach accommodates the underlying architecture to automate, as much as possible, the development process. The Cognitive Agent Architecture (COUGAAR) is a distributed agent architecture that provides the primary components and an implementation platform for this research. COUGAAR has been developed primarily for very large-scale, distributed applications that are characterized by hierarchical task decompositions and as such is well suited for autonomic systems. We propose a framework for the agent-based, model-driven architecture for autonomic applications development. The framework consists of two main parts, General COUGAAR application model (GCAM) and general domain\u00a0\u2026", "num_citations": "35\n", "authors": ["73"]}
{"title": "Software change impact analysis for design evolution\n", "abstract": " Studies have shown that software system designs frequently experience degradation from continued changes during software maintenance activities. Much of this is caused by the change extent not being apparent or discernible with the tools and methods available to the software maintainer. Software change impact analysis offers considerable improvement to this situation. Since software maintenance process models have not fully addressed impact analysis and its potential for enhancing the productivity of software maintainers, this paper introduces a software maintenance process model that emphasizes impact analysis. Using directed graphs, this paper suggests traditional process and product metrics as well as new impact analysis metrics that address software workproduct traceability and interworkproduct dependencies. Software staff can use these and other metrics to understand and control the changes to the software system design. As changes are requested, measurements can be made, impact assessed, and clarified design decisions made.", "num_citations": "33\n", "authors": ["73"]}
{"title": "Design Productivity for Configurable Computing.\n", "abstract": " Like design productivity for ASIC design, design productivity for FPGA design suffers from the well-known design productivity gap [1]\u2014silicon densities continue to double every 1.5 to 2 years while design capabilities are growing at a much slower rate. Just to keep from falling behind in the future, design productivity must improve according to Moore\u2019s Law. However, based on the historical pace of design methods and tools for hardware design, this is highly unlikely without significant focused effort by the research community.Productivity issues related to both software development and hardware development have been studied for many years, yet the solution for addressing the productivity issues for FPGA design has unique characteristics compared to contemporary hardware and software solutions. The focus of this paper is to propose the outlines of a research agenda to help address the challenges associated\u00a0\u2026", "num_citations": "32\n", "authors": ["73"]}
{"title": "Goal-oriented, B-based formal derivation of security design specifications from security requirements\n", "abstract": " This paper proposes a requirements-driven security engineering approach for modeling, specifying, and analyzing application-specific security requirements that are formally derived into security design specifications preserving security requirements properties. The approach adopts and non-trivially extends the goal-oriented KAOS (Knowledge Acquisition in automated Specifications) framework developed by Lamsweerde to formally construct a complete, consistent, and clear security requirements model. The resulting model is then extended using the B method to produce security design specifications and further implementation while preserving requirements properties. In our approach, we firstly transform the KAOS requirements model to an abstract B model and secondly, we refine the model using B refinement mechanism to generate design specifications and implementation. This unique treatment of secure\u00a0\u2026", "num_citations": "21\n", "authors": ["73"]}
{"title": "Model-driven architecture for agent-based systems\n", "abstract": " The Model Driven Architecture (MDA) approach uses a platform-independent model to define system functionality, or requirements, using some specification language. The requirements are then translated to a platform-specific model for implementation. An agent architecture based on the human cognitive model of planning, the Cognitive Agent Architecture (Cougaar) is selected for the implementation platform. The resulting Cougaar MDA prescribes certain kinds of models to be used, how those models may be prepared and the relationships of the different kinds of models. Using the existing Cougaar architecture, the level of application composition is elevated from individual components to domain level model specifications in order to generate software artifacts. The software artifacts generation is based on a metamodel. Each component maps to a UML structured component which is then converted into\u00a0\u2026", "num_citations": "19\n", "authors": ["73"]}
{"title": "Model-based engineering of software: Three productivity perspectives\n", "abstract": " Evolving software products is a tricky business, especially when the domain is complex and changing rapidly. Like other fields of engineering, software engineering productivity advances have come about largely through abstraction, reuse, process, and automation (e.g., moving from assembly language to third generation languages offered increased productivity through better abstraction). For canonical or domain applications, model-based engineering (MBE) of software provides a systematic approach for producing software systems that leverage all of these avenues of productivity. Specifying or modeling software at higher levels of abstraction and connecting these representations with previously developed (reusable) components provides a repeatable assembly and transformation process that can often be automated. Since 2004, we have explored MBE for generating software from the high-level for\u00a0\u2026", "num_citations": "18\n", "authors": ["73"]}
{"title": "Software impact analysis in a virtual environment\n", "abstract": " With the relentless growth in software, automated support for visualizing and navigating software artifacts is no longer a luxury. As packaged software components and middleware occupy more and more of the software landscape, interoperability relationships point to increasingly relevant software change impacts. Packaged software now represents over thirty-two percent of the software portfolio in most organizations benchmark (Rubin, 2001). While traceability and dependency analysis has effectively supported impact analysis in the past, they fall short today as their webs of dependency information extend beyond most software engineers ability to comprehend them. This paper describes research for extending current software change impact analysis to incorporate software architecture dependency relationships. We discuss how we address the extensive dependency information involved, extending impact\u00a0\u2026", "num_citations": "18\n", "authors": ["73"]}
{"title": "Integrating formal analysis and design to preserve security properties\n", "abstract": " The use of formal methods has long been advocated in the development of secure systems. Yet, methods for deriving design from requirements that guarantee retention of the intended security properties remain largely unrealized on a repeatable and consistent basis. We present the FADES (Formal Analysis and Design approach for Engineering Security) that integrates KAOS (Knowledge Acquisition in automated Specifications) with the B specification language to derive security design specifications and further implementation from security requirements. We demonstrate the capability of the approach to handle changes to security requirements by introducing corrective changes to the security requirements of a case study, the spy network system. The objective is to bridge the gap between formal requirements and design for security requirements. Our initial results show promise with FADES in preserving security\u00a0\u2026", "num_citations": "16\n", "authors": ["73"]}