{"title": "The SOUL tool suite for querying programs in symbiosis with Eclipse\n", "abstract": " Program queries can answer important software engineering questions that range from\" which expressions are cast to this type?\" over\" does my program attempt to read from a closed file?\" to\" does my code follow the prescribed design?\". In this paper, we present a comprehensive tool suite for querying Java programs. It consists of the logic program query language Soul, the Cava library of predicates for quantifying over an Eclipse workspace and the Eclipse plugin Barista for launching queries and inspecting their results. Barista allows other Eclipse plugins to peruse program query results which is facilitated by the symbiosis of Soul with Java--setting Soul apart from other program query languages. This symbiosis enables the Cava library to forego the predominant transcription to logic facts of the queried program. Instead, the library queries the actual AST nodes used by Eclipse itself, making it trivial for any\u00a0\u2026", "num_citations": "68\n", "authors": ["2151"]}
{"title": "Aspectmaps: A scalable visualization of join point shadows\n", "abstract": " When using Aspect-Oriented Programming, it is sometimes difficult to determine at which join point an aspect executes. Similarly, when considering one join point, knowing which aspects will execute there and in what order is non-trivial. This makes it difficult to understand how the application will behave. A number of visualizations have been proposed that attempt to provide support for such program understanding. However, they neither scale up to large code bases nor scale down to understanding what happens at a single join point. In this paper, we present Aspect Maps -- a visualization that scales in both directions, thanks to a multi-level selective structural zoom. We show how the use of Aspect Maps allows for program understanding of code with aspects, revealing both a wealth of information of what can happen at one particular join point as well as allowing to see the \"big picture\" on a larger code base. We\u00a0\u2026", "num_citations": "37\n", "authors": ["2151"]}
{"title": "Experiences with identifying aspects in smalltalk using\u2019unique methods\u2019\n", "abstract": " Now that Aspect-Oriented Software Development has matured, the techniques developed in this field may be used to cleanly modularize the crosscutting concerns in legacy applications. Due to the complexity and size of these applications it is important that the identification of crosscutting concerns and the transformation into aspects is automated as much as possible. In this paper we present a simple heuristic named Unique Methods which can be used to detect crosscutting concerns in an application. We demonstrate the use of this technique on the code of an entire VisualWorks Smalltalk image and discuss the benefits and disadvantages of our approach.", "num_citations": "37\n", "authors": ["2151"]}
{"title": "An experiment in using inductive logic programming to uncover pointcuts\n", "abstract": " The subject of this paper is the transformation from pre-AOP legacy software to aspect-oriented software. To factor out crosscutting concerns from such software we propose the use of techniques to automate the task of uncovering pointcuts. We discuss problems inherent in this task and propose the use of inductive reasoning techniques for the automation. We apply such a technique to one kind of aspects: unique methods which can be found in a standard Smalltalk image.", "num_citations": "30\n", "authors": ["2151"]}
{"title": "Inductively generated pointcuts to support refactoring to aspects\n", "abstract": " In this paper, we show that the basic pointcut languages offered by current aspect-oriented programming languages impact important software engineering properties, such as evolvability and comprehensibility, in a negative way. We discuss this impact by means of detailed examples, and propose an advanced pointcut managing environment, based on machine learning techniques, to overcome the problem.", "num_citations": "28\n", "authors": ["2151"]}
{"title": "Time warp, an approach for reasoning over system histories\n", "abstract": " The version history of a software system contains a wealth of information that can assist developers in their daily implementation and maintenance tasks. By reasoning over the role of certain code entities in previous versions of the system, developers can better understand their current state, assess the required maintenance and avoid making the same mistakes over and over again. Unfortunately, current approaches do not offer a means to easily extract specific information about the source code from such a version history.", "num_citations": "21\n", "authors": ["2151"]}
{"title": "Induced intentional software views\n", "abstract": " Evolving and maintaining software requires adequate documentation of its implementation. However, due to the software's constant evolution, the documentation and implementation do not remain synchronised. Intentional software views have been proposed as a documentation technique to alleviate this problem. Creating such views is not at all a trivial task, however. In this paper, we propose to use a learning algorithm that derives such intentional software views from extensional software views, which are much easier to build. The resulting approach combines the advantages of intentional software views with the ease of constructing extensional views.", "num_citations": "18\n", "authors": ["2151"]}
{"title": "Reasoning over the evolution of source code using quantified regular path expressions\n", "abstract": " Version control systems (VCS) have become indispensable to develop software. Next to their immediate advantages, they also offer information about the evolution of software and its development process. Despite this wealth of information, it has only been leveraged by tools that are dedicated to a specific software engineering task such as predicting bugs or identifying hotspots. General-purpose tool support for reasoning about the information contained in a version control system is limited. In this paper, we introduce the logic-based program query language ABSINTHE. It supports querying versioned software systems using logic queries in which quantified regular path expressions are embedded. These expressions lend themselves to specifying the properties that each individual version in a sequence of successive software versions ought to exhibit.", "num_citations": "17\n", "authors": ["2151"]}
{"title": "Experiences in modularizing business rules into aspects\n", "abstract": " This paper provides an experience report on the use of aspect-oriented technology as a means to modularize the implementation of business rules in an object-oriented, large scale case study. The goal of this refactoring of the system was to provide a proof-of-concept implementation of how such an aspect-oriented solution can improve the modularity and the extensibility of the business rule implementation. This paper focusses on the approach taken in refactoring the system and the difficulties of integrating the aspect solution into the build process.", "num_citations": "17\n", "authors": ["2151"]}
{"title": "AspectMaps: Extending Moose to visualize AOP software\n", "abstract": " When using aspect-oriented programming the application implicitly invokes the functionality contained in the aspects. Consequently program comprehension of such a software is more intricate. To alleviate this difficulty we developed the AspectMaps visualization and tool. AspectMaps extends the Moose program comprehension and reverse engineering platform with support for aspects, and is implemented using facilities provided by Moose. In this paper we present the AspectMaps tool, and show how it can be used by performing an exploration of a fairly large aspect-oriented application. We then show how we extended the FAMIX meta-model family that underpins Moose to also provide support for aspects. This extension is called ASPIX, and thanks to this enhancement Moose can now also treat aspect-oriented software. Finally, we report on our experiences using some of the tools in Moose; Mondrian to\u00a0\u2026", "num_citations": "15\n", "authors": ["2151"]}
{"title": "Enforcing structural regularities in software using IntensiVE\n", "abstract": " The design and implementation of a software system is often governed by a variety of coding conventions, design patterns, architectural guidelines, design rules, and other so-called structural regularities. To prevent a deterioration of the system\u2019s source code, it is important that these regularities are verified and enforced upon evolution of the system. The Intensional Views Environment (IntensiVE), presented in this article, is a tool suite for specifying relevant structural regularities in an (object-oriented) software system and verifying them against the current and later versions of the system. At the heart of the IntensiVE tool suite are (logic) program queries and the model of intensional views and relations, through which regularities are expressed. Upon verification of these regularities in the source code of the system, IntensiVE reports the code entities (i.e. classes, methods, variables, statements, etc.) that violate these\u00a0\u2026", "num_citations": "14\n", "authors": ["2151"]}
{"title": "Maintaining causality between design regularities and source code\n", "abstract": " One of the techniques developers use to deal with the inherent complexity of software systems is to systematically introduce regularities in the source code of a system. These regularities express different conventions, idioms and patterns that are used to communicate the developers\u2019 design intent or to regulate the implementation of a particular concern by relying on a proven solution. However, since these regularities are neither explicitly documented in the source code nor are they first-class entities of the development process, the causal connection between the regularities and the implementation can be severed during development. Consequently, changes to either the regularities or the source code can result in mismatches which might lead to an inconsistent or incorrect implementation. In this dissertation we advance an approach that emphasizes this causality between regularities and source code by turning regularities into an integral and explicit part of the development process. We attain this integration by offering a formalism and a methodology which enables the co-design and co-evolution of regularities and the source code by making the regularities and the causal connection with the implementation explicit and verifiable. Furthermore, our approach strives at maintaining this causal link throughout the development cycle.", "num_citations": "14\n", "authors": ["2151"]}
{"title": "Co-evolving annotations and source code through smart annotations\n", "abstract": " Annotations are a means to attach additional meta data to the source code of a system. Nowadays, more and more technologies rely on the presence of such annotations in the source code: beyond their use for documentation purposes, annotations impact the behaviour of the system. Since there exists little or no support to make sure that upon evolution of the system, the source code remains correctly annotated, source code can become miss-annotated. This in turn, can result in erroneous behaviour. In this paper we present Smart Annotations, an approach for co-evolving source code and annotations. Our approach enables developers to constrain the use of annotations in the source code and offers tool support to identify conflicts between source code and annotations. To illustrate the use of our approach, we demonstrate its applicability using examples from the domain of aspect-oriented programming and\u00a0\u2026", "num_citations": "12\n", "authors": ["2151"]}
{"title": "Supporting streams of changes during branch integration\n", "abstract": " When developing large applications, integrators face the problem of integrating changes between branches or forks. While version control systems provide support for merging changes, this support is mostly text-based, and does not take the program entities into account. Furthermore, there exists no support for assessing which other changes a particular change depends on have to be integrated. Consequently, integrators are left to perform a manual and tedious comparison of the changes within the sequence of their branch and to successfully integrate them.In this paper, we present an approach that analyzes changes within a sequence of changes (stream of changes): such analysis identifies and characterizes dependencies between the changes. The approach identifies changes as autonomous, only used by others, only using other changes, or both. Such a characterization aims at easing the integrator's work\u00a0\u2026", "num_citations": "10\n", "authors": ["2151"]}
{"title": "Cognac: A framework for documenting and verifying the design of cobol systems\n", "abstract": " For any non-trivial software project, architectural drift is a well-known problem. Over time, the design rules and guidelines governing the software project are no longer obeyed, resulting in that the software becomes more difficult to maintain. While there exist numerous tools - such as code checkers, architecture and design checkers, and source code query languages - that aid in alleviating this problem none of these approaches are tailored towards supporting one of the main languages still in use today in industry, namely Cobol. In this paper we present Cognac, an extension of the Intensive tool that allows for documenting and verifying design rules in Cobol systems. Next to discussing the architecture of Cognac, we present a validation of our tool on an industrial, large-scale Cobol system.", "num_citations": "10\n", "authors": ["2151"]}
{"title": "Automated pattern-based pointcut generation\n", "abstract": " One of the main problems in Aspect-Oriented Software Development is the so-called fragile pointcut problem. Uncovering and specifying a good robust pointcut is not an easy task. In this paper we propose to use Inductive Logic Programming, and more specifically the FOIL algorithm, to automatically identify intensional (or \u201cpattern-based\u201d) pointcuts. We present the tool chain we implemented to induce a pointcut given a set of identified joinpoints. Using several realistic medium-scale experiments, we show that our approach is able to automatically induce robust pointcuts for a set of joinpoints.", "num_citations": "9\n", "authors": ["2151"]}
{"title": "Program querying with a SOUL: the barista tool suite\n", "abstract": " Extracting information from the source code of a program is an important step in the way to program understanding, manipulation, development and maintenance. To this end, logic-based query languages provide a declarative manner in which to identify program elements of interest. In this paper we present BARISTA, a tool-suite for querying Java programs based on the Smalltalk Open Unification Language (SOUL). BARISTA offers programmers an advanced IDE to write queries and navigate their results. Tool builders can benefit from SOUL querying facilities by exploiting the on demand code querying and query scheduling services offered by BARISTA.", "num_citations": "8\n", "authors": ["2151"]}
{"title": "Inducing evolution-robust pointcuts\n", "abstract": " One of the problems in Aspect-Oriented Software Development is specifying pointcuts that are robust with respect to evolution of the base program. We propose to use Inductive Logic Programming, and more specifically the FOIL algorithm, to automatically discover intensional pattern-based pointcuts. In this paper we demonstrate this approach using several experiments in Java, where we successfully induce a pointcut from a given set of joinpoints. Furthermore, we present the tool chain and IDE that supports our approach.", "num_citations": "8\n", "authors": ["2151"]}
{"title": "Issues in performing and automating the \u2018extract method calls\u2019 refactoring\n", "abstract": " A large part of converting a pre-AOP application into an aspect-oriented one consists, next to aspect mining, out of aspect refactoring. One such aspect refactoring named \u201cExtract Method Calls\u201d refactoring [11, 17] transforms certain crosscutting concerns which are implemented by calls to a single method into an aspect by turning the called method into an advice and all the calls to that method into a crosscut.In this paper we present the Joinpoint Choice Problem and the Flattened Expression Problem. Both problems are inherent to the joinpoint models as used by current-day weavers and can have a negative impact on the maintainability and evolvability of the crosscuts resulting from performing the \u201cExtract Method Calls\u201d refactoring either by hand or automatically. As a solution to the Joinpoint Choice Problem, we propose an algorithm for calculating the appropriate crosscut. In order to solve the Flattened Expression Problem, we introduce a new language construct named the \u201cstatement joinpoint\u201d.", "num_citations": "8\n", "authors": ["2151"]}
{"title": "Mentor: Mining entities to rules\n", "abstract": " MEntoR is a source code analysis tool that is integrated into the development environment (IDE) to suggest implementation improvements. MEntoR is a front-end for Prospector. Prospector extracts properties of source code entities of an application, and calculates association rules which indicate which properties tend to occur together. The purpose of MEntoR is to identify missing properties in the source code entity that is being browsed in the IDE based on other properties that the entity has. For instance, showing whenever a source code entity violates an idiom.", "num_citations": "7\n", "authors": ["2151"]}
{"title": "A logic foundation for a general-purpose history querying tool\n", "abstract": " Version control systems (VCS) have become indispensable software development tools. The version snapshots they store to provide support for change coordination and release management, effectively track the evolution of the versioned software and its development process. Despite this wealth of historical information, it has only been leveraged by tools that are dedicated to a specific task such as empirical validation of software engineering practices or fault prediction. General-purpose tool support for reasoning about the historical information stored in a version control system is limited. This paper provides a comprehensive description of a logic-based, general-purpose history query tool called Absinthe. Absinthe supports querying versioned Smalltalk system using logic queries in which quantified regular path expressions are embedded. These expressions lend themselves to specifying the properties that\u00a0\u2026", "num_citations": "7\n", "authors": ["2151"]}
{"title": "Tackling pointcut fragility with dynamic annotations\n", "abstract": " Within the aspect-oriented software development community, the use of annotation-based pointcuts has been proposed as a means to alleviate the fragile pointcut problem. Expressing pointcuts in terms of source-code annotations instead of the structure of the source code, decouples them from the source code of the base system and makes them more robust with respect to evolution. In this paper we demonstrate that, while annotations are suitable to capture static domain knowledge that can be leveraged by pointcut expressions, these annotations are ill-suited to capture dynamic domain knowledge. Consequently, pointcuts that rely on such dynamic knowledge still need to be defined in terms of actual source-code entities, thereby rendering them fragile again. As a means to alleviate this problem we propose Dynamic Annotations, an extension to Java annotations where the dynamic conditions under which the\u00a0\u2026", "num_citations": "7\n", "authors": ["2151"]}
{"title": "Refactoring in the presence of annotations\n", "abstract": " Current-day programming languages include constructs to embed meta-data in a program's source code in the form of annotations. More than mere documentation, these annotations are used in modern frameworks to map source-level entities to domain-specific ones. A common example being the Hibernate Object-Relational Mapping framework that relies on annotations to declare persistence configurations. While the presence of annotations extends the base semantics of the language, it also imposes restrictions on the annotated program. In this paper we consider the manner in which annotations affect automated refactorings, and in particular how they break their behavior preservation. As refactorings, during their condition checking phase, ignore the annotation's restrictions they can no longer guarantee the preservation of the domain-specific mappings. To address this problem, we propose to make the\u00a0\u2026", "num_citations": "6\n", "authors": ["2151"]}
{"title": "Code querying by UML\n", "abstract": " The need to identify source code that exhibits particular characteristics is essential to program comprehension. In this paper we introduce Arabica, a tool for querying Java code using UML class and sequence diagrams. Our use of UML diagrams avoids the need for developers to familiarize themselves with yet another language. In contrast to tools that rely on dedicated query languages, Arabica encodes querying semantics in a dedicated, minimal UML profile. Stereotyped class and sequence diagrams, characterizing structural and behavioral properties respectively, are translated into logic program queries. Using examples from the JHotDraw framework, we illustrate the utility of Arabica in validating design invariants, finding design pattern implementations and exploring extension points. We present a pre/post-test quasi experiment as a preliminary assessment of our approach.", "num_citations": "4\n", "authors": ["2151"]}
{"title": "Using inductive logic programming to derive software views\n", "abstract": " During its lifetime software has to evolve to meet new requirements or to work with new technology. It is important for a developer who has to change the implementation of a piece of software to have good insights into the application. To this extent, having high-quality documentation is invaluable. This documentation can also be a source of problems: in many cases it happens that the documentation is no longer synchronized with the implementation which renders it useless to a developer who has to make adaptations to the implementation. We can situate the cause of this problem with modern day development environments: they do not o# er support for easily creating documentation that is robust when the implementation changes. In this dissertation we propose the Software Views Inducer, a tool for creating documentation from Smalltalk code. Our tool does not only allow to easily create this documentation by simple drag", "num_citations": "4\n", "authors": ["2151"]}
{"title": "Experiments with pro-active declarative meta-programming\n", "abstract": " Program querying has become a valuable asset in the programmer's toolbox. Using dedicated querying languages, developers can reason about their source code in order to find errors, refactoring opportunities and so on. Within Smalltalk, the SOUL language has been proposed as one such language that offers a declarative and expressive means to query the source code of object-oriented programs.", "num_citations": "1\n", "authors": ["2151"]}