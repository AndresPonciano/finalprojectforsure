{"title": "Going big: a large-scale study on what big data developers ask\n", "abstract": " Software developers are increasingly required to write big data code. However, they find big data software development challenging. To help these developers it is necessary to understand big data topics that they are interested in and the difficulty of finding answers for questions in these topics. In this work, we conduct a large-scale study on Stackoverflow to understand the interest and difficulties of big data developers. To conduct the study, we develop a set of big data tags to extract big data posts from Stackoverflow; use topic modeling to group these posts into big data topics; group similar topics into categories to construct a topic hierarchy; analyze popularity and difficulty of topics and their correlations; and discuss implications of our findings for practice, research and education of big data software development and investigate their coincidence with the findings of previous work.", "num_citations": "35\n", "authors": ["822"]}
{"title": "Pointcut rejuvenation: Recovering pointcut expressions in evolving aspect-oriented software\n", "abstract": " Pointcut fragility is a well-documented problem in Aspect-Oriented Programming; changes to the base code can lead to join points incorrectly falling in or out of the scope of pointcuts. In this paper, we present an automated approach that limits fragility problems by providing mechanical assistance in pointcut maintenance. The approach is based on harnessing arbitrarily deep structural commonalities between program elements corresponding to join points selected by a pointcut. The extracted patterns are then applied to later versions to offer suggestions of new join points that may require inclusion. To illustrate that the motivation behind our proposal is well founded, we first empirically establish that join points captured by a single pointcut typically portray a significant amount of unique structural commonality by analyzing patterns extracted from 23 AspectJ programs. Then, we demonstrate the usefulness of our\u00a0\u2026", "num_citations": "32\n", "authors": ["822"]}
{"title": "Automated refactoring of legacy Java software to enumerated types\n", "abstract": " Java 1.5 introduces several new features that offer significant improvements over older Java technology. In this paper we consider the new enum construct, which provides language support for enumerated types. Prior to Java 1.5, programmers needed to employ various patterns (e.g., the weak enum pattern) to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly-desirable properties of the enum construct, most notably, type safety. We present a novel fully-automated approach for transforming legacy Java code to use the new enumeration construct. This semantics-preserving approach increases type safety, produces code that is easier to comprehend, removes unnecessary complexity, and eliminates brittleness problems due to separate compilation. At the core of the proposed approach is an interprocedural type inferencing algorithm which\u00a0\u2026", "num_citations": "32\n", "authors": ["822"]}
{"title": "The Stolen Forests: Inside the Covert War on Illegal Logging\n", "abstract": " The town of Suifenhe, a former Russian imperial outpost on the Trans-Siberian Railway, has belonged to China since the nineteen-forties, and occupies a broad valley in northern Manchuria. From a distance, its homes and factories appear to cling to a rail yard, with tracks fanning out into a vast latticework of iron as they emerge from the Russian border. Suifenhe is a place of singular purpose. Nearly every train from Russia brings in just one commodity: wood\u2014oak, ash, linden, and other high-value species. There is also poplar, aspen, and larch, and occasionally great trunks of Korean pine, a species that was logged by the Soviets until there was almost none left to cut down. In a year, more than five billion pounds of wood cross over from Primorski Krai, the neighboring province in the Russian Far East. Hundreds of railcars enter Suifenhe every day, many loaded beyond capacity with logs. The wood is shuttled\u00a0\u2026", "num_citations": "31\n", "authors": ["822"]}
{"title": "Enforcing behavioral constraints in evolving aspect-oriented programs\n", "abstract": " Reasoning, specification, and verification of Aspect-Oriented (AO) programs presents unique challenges especially as such programs evolve over time. Components, base-code and aspects alike, may be easily added, removed, interchanged, or presently unavailable at unpredictable frequencies. Consequently, modular reasoning of such programs is highly attractive as it enables tractable evolution, otherwise necessitating that the entire program be reexamined each time a component is changed. It is well known, however, that modular reasoning about AO programs is difficult. In this paper, we present our ongoing work in constructing a relyguarantee style reasoning system for the Aspect-Oriented Programming (AOP) paradigm, adopting a trace-based approach to deal with the plug-n-play nature inherent to these programs, thus easing AOP evolution.", "num_citations": "30\n", "authors": ["822"]}
{"title": "Safe automated refactoring for intelligent parallelization of Java 8 streams\n", "abstract": " Streaming APIs are becoming more pervasive in mainstream Object-Oriented programming languages and platforms. For example, the Stream API introduced in Java 8 allows for functional-like, MapReduce-style operations in processing both finite, e.g., collections, and infinite data structures. However, using this API efficiently involves subtle considerations such as determining when it is best for stream operations to run in parallel, when running operations in parallel can be less efficient, and when it is safe to run in parallel due to possible lambda expression side-effects. In this paper, we present an automated refactoring approach that assists developers in writing efficient stream code in a semantics-preserving fashion. The approach, based on a novel data ordering and typestate analysis, consists of preconditions and transformations for automatically determining when it is safe and possibly advantageous to\u00a0\u2026", "num_citations": "24\n", "authors": ["822"]}
{"title": "Automated refactoring of legacy java software to default methods\n", "abstract": " Java 8 default methods, which allow interfaces to contain (instance) method implementations, are useful for the skeletal implementation software design pattern. However, it is not easy to transform existing software to exploit default methods as it requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods to preserve type-correctness and confirm semantics preservation. In this paper, we present an efficient, fully-automated, type constraint-based refactoring approach that assists developers in taking advantage of enhanced interfaces for their legacy Java software. The approach features an extensive rule set that covers various corner-cases where default methods cannot be used. To demonstrate applicability, we implemented our\u00a0\u2026", "num_citations": "22\n", "authors": ["822"]}
{"title": "Rely-guarantee approach to reasoning about aspect-oriented programs\n", "abstract": " Over the last few years, the question of reasoning about aspect-oriented programs has been addressed by a number of authors. In this paper, we present a rely-guarantee approach to such reasoning. The rely-guarantee approach has proven extremely successful in reasoning about concurrent and distributed programs. We show that some of the key problems encountered in reasoning about aspectoriented programs are similar to those encountered in reasoning about concurrent programs; and that the rely-guarantee approach, appropriately modified, helps address these problems. We illustrate our approach with a simple example.", "num_citations": "14\n", "authors": ["822"]}
{"title": "An Empirical Study on the Use and Misuse of Java 8 Streams.\n", "abstract": " Streaming APIs allow for big data processing of native data structures by providing MapReduce-like operations over these structures. However, unlike traditional big data systems, these data structures typically reside in shared memory accessed by multiple cores. Although popular, this emerging hybrid paradigm opens the door to possibly detrimental behavior, such as thread contention and bugs related to non-execution and non-determinism. This study explores the use and misuse of a popular streaming API, namely, Java 8 Streams. The focus is on how developers decide whether or not to run these operations sequentially or in parallel and bugs both specific and tangential to this paradigm. Our study involved analyzing 34 Java projects and 5. 53 million lines of code, along with 719 manually examined code patches. Various automated, including interprocedural static analysis, and manual methodologies were employed. The results indicate that streams are pervasive, parallelization is not widely used, and performance is a crosscutting concern that accounted for the majority of fixes. We also present coincidences that both confirm and contradict the results of related studies. The study advances our understanding of streams, as well as benefits practitioners, programming language and API designers, tool developers, and educators alike.", "num_citations": "9\n", "authors": ["822"]}
{"title": "Detecting broken pointcuts using structural commonality and degree of interest\n", "abstract": " Pointcut fragility is a well-documented problem in Aspect-Oriented Programming; changes to the base-code can lead to join points incorrectly falling in or out of the scope of pointcuts. Deciding which pointcuts have broken due to base-code changes is a daunting venture, especially in large and complex systems. We present an automated approach that recommends pointcuts that are likely to require modification due to a particular base-code change, as well as ones that do not. Our hypothesis is that join points selected by a pointcut exhibit common structural characteristics. Patterns describing such commonality are used to recommend pointcuts that have potentially broken with a degree of confidence as the developer is typing. The approach is implemented as an extension to the popular Mylyn Eclipse IDE plug-in, which maintains focused contexts of entities relevant to the task at hand using a Degree of Interest\u00a0\u2026", "num_citations": "9\n", "authors": ["822"]}
{"title": "A Tool for Optimizing Java 8 Stream Software via Automated Refactoring\n", "abstract": " Streaming APIs are pervasive in mainstream Object-Oriented languages and platforms. For example, the Java 8 Stream API allows for functional-like, MapReduce-style operations in processing both finite, e.g., collections, and infinite data structures. However, using this API efficiently involves subtle considerations like determining when it is best for stream operations to run in parallel, when running operations in parallel can be less efficient, and when it is safe to run in parallel due to possible lambda expression side-effects. In this paper, we describe the engineering aspects of an open source automated refactoring tool called Optimize Streams that assists developers in writing optimal stream software in a semantics-preserving fashion. Based on a novel ordering and typestate analysis, the tool is implemented as a plug-in to the popular Eclipse IDE, using both the WALA and SAFE frameworks. The tool was\u00a0\u2026", "num_citations": "8\n", "authors": ["822"]}
{"title": "Towards safe refactoring for intelligent parallelization of Java 8 streams\n", "abstract": " The Java 8 Stream API sets forth a promising new programming model that incorporates functional-like, MapReduce-style features into a mainstream programming language. However, using streams correctly and efficiently may involve subtle considerations. In this poster, we present our ongoing work and preliminary results towards an automated refactoring approach that assists developers in writing optimal stream code. The approach, based on ordering and typestate analysis, determines when it is safe and advantageous to convert streams to parallel and optimize parallel streams.", "num_citations": "8\n", "authors": ["822"]}
{"title": "Defaultification refactoring: A tool for automatically converting Java methods to default\n", "abstract": " Enabling interfaces to declare (instance) method implementations, Java 8 default methods can be used as a substitute for the ubiquitous skeletal implementation software design pattern. Performing this transformation on legacy software manually, though, may be non-trivial. The refactoring requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods. All of this is necessary to preserve type-correctness and confirm semantics preservation. We demonstrate an automated refactoring tool called MIGRATE Skeletal Implementation to Interface for transforming legacy Java code to use the new default construct. The tool, implemented as an Eclipse plug-in, is driven by an efficient, fully-automated, type constraint-based refactoring approach. It\u00a0\u2026", "num_citations": "6\n", "authors": ["822"]}
{"title": "Proactive Empirical Assessment of New Language Feature Adoption via Automated Refactoring: The Case of Java 8 Default Methods\n", "abstract": " Programming languages and platforms improve over time, sometimes resulting in new language features that offer many benefits. However, despite these benefits, developers may not always be willing to adopt them in their projects for various reasons. In this paper, we describe an empirical study where we assess the adoption of a particular new language feature. Studying how developers use (or do not use) new language features is important in programming language research and engineering because it gives designers insight into the usability of the language to create meaning programs in that language. This knowledge, in turn, can drive future innovations in the area. Here, we explore Java 8 default methods, which allow interfaces to contain (instance) method implementations.", "num_citations": "5\n", "authors": ["822"]}
{"title": "Porting the NetBeans Java 8 enhanced for loop lambda expression refactoring to eclipse\n", "abstract": " Java 8 is one of the largest upgrades to the popular language and framework in over a decade. However, the Eclipse IDE is missing several key refactorings that could help developers take advantage of new features in Java 8 more easily. In this paper, we discuss our ongoing work in porting the enhanced for loop to lambda expression refactoring from the NetBeans IDE to Eclipse. We also discuss future plans for new Java 8 refactorings not found in any current IDE.", "num_citations": "5\n", "authors": ["822"]}
{"title": "Specifying reusable aspects\n", "abstract": " Aspect-Oriented Programming enables developers to manage, in a more modular fashion, implementations of crosscutting concerns that might be scattered or tangled if aspect-oriented techniques were not utilized. Our interest in this paper is in considering techniques for specifying precise properties of aspects. In particular, we are interested in specifying reusable aspects; ie, aspects that correspond to crosscutting concerns that occur in many systems. These abstract aspects can be reused in various systems where a particular concern is applicable. Although there has been work on issues related to reasoning about aspects and the behaviors of aspect-oriented systems, specifying reusable abstract aspects seems to have received little attention. We adopt the following approach to specifying reusable aspects and how they are specialized in individual systems. We specify a reusable aspect in terms of a contract; the contract is written in terms of abstraction concepts that will correspond to portions that are left abstract in the reusable aspect. This contract will be specialized by a subcontract corresponding to the subaspect that defines how the abstract aspect is specialized for use in a given system. While the aspect contract is applicable to all systems built using the reusable aspect, the contract plus the subcontract define the behavior corresponding to the given system. We illustrate the approach by applying it to a simple example.", "num_citations": "5\n", "authors": ["822"]}
{"title": "Reasoning about the behavior of aspect-oriented programs\n", "abstract": " Aspect-oriented programming (AOP) has become increasingly popular over the last few years. At the same time, reasoning about the behavior of these programs poses serious challenges. In this paper, we present a rely-guarantee approach to such reasoning. The rely-guarantee approach has proven useful in reasoning about concurrent and distributed programs. We show that some of the key problems encountered in reasoning about aspect-oriented programs are similar to those encountered in reasoning about concurrent programs; and that the rely-guarantee approach, appropriately modified, helps address these problems. We illustrate our approach with a simple example.", "num_citations": "5\n", "authors": ["822"]}
{"title": "Actor concurrency bugs: a comprehensive study on symptoms, root causes, API usages, and differences\n", "abstract": " Actor concurrency is becoming increasingly important in the development of real-world software systems. Although actor concurrency may be less susceptible to some multithreaded concurrency bugs, such as low-level data races and deadlocks, it comes with its own bugs that may be different. However, the fundamental characteristics of actor concurrency bugs, including their symptoms, root causes, API usages, examples, and differences when they come from different sources are still largely unknown. Actor software development can significantly benefit from a comprehensive qualitative and quantitative understanding of these characteristics, which is the focus of this work, to foster better API documentation, development practices, testing, debugging, repairing, and verification frameworks. To conduct this study, we take the following major steps. First, we construct a set of 186 real-world Akka actor bugs from Stack\u00a0\u2026", "num_citations": "4\n", "authors": ["822"]}
{"title": "Contributing factors to pointcut fragility\n", "abstract": " Pointcut fragility is a well-documented problem of Aspect-Oriented Programming with changes to the base-code causing join points to incorrectly fall in or out of scope. In order to combat this problem a tool was developed that provides mechanical assistance to pointcut maintenance. This tool relied on the deep structural commonalities between program elements to detect when pointcut fragility occurs. During the assessment of this tool a number of common practices were uncovered that were employed both in the aspect and base-code that contributed to or prevented pointcut fragility. This paper documents the practices uncovered and describes how they can affect pointcut fragility and design stability in general.", "num_citations": "4\n", "authors": ["822"]}
{"title": "Aspects of AOP: An exploration of the aspect-oriented paradigm\n", "abstract": " As software becomes increasingly complex, the need for abstraction and modularization of system functionality grows harmoniously. Limiting scope to certain aspects of functionality and building upon previous functional analyses compositionally can alleviate complexities associated with building large, sophisticated software systems. Leveraging functional decomposition, design by contract, data abstraction, and other design mechanisms can help separate concerns of system functionality into encapsulated, yet related units. Unfortunately, these traditional techniques may not be powerful enough to solidify common, global concerns that may encompass multiple aspects of functionality. The Aspect-oriented paradigm attempts to solve this problem by modularizing functionality that commonly pertains to multiple functional units, also called cross-cutting concerns. This paper explores the intricacies of the Aspect-oriented paradigm, discussing its nature, motivation, open issues, and relationship to traditional software development approaches and disciplines.", "num_citations": "4\n", "authors": ["822"]}
{"title": "An Empirical Study of Refactorings and Technical Debt in Machine Learning Systems\n", "abstract": " Machine Learning (ML), including Deep Learning (DL), systems, i.e., those with ML capabilities, are pervasive in today\u2019s data-driven society. Such systems are complex; they are comprised of ML models and many subsystems that support learning processes. As with other complex systems, ML systems are prone to classic technical debt issues, especially when such systems are long-lived, but they also exhibit debt specific to these systems. Unfortunately, there is a gap of knowledge in how ML systems actually evolve and are maintained. In this paper, we fill this gap by studying refactorings, i.e., source-to-source semantics-preserving program transformations, performed in real-world, open-source software, and the technical debt issues they alleviate. We analyzed 26 projects, consisting of 4.2 MLOC, along with 327 manually examined code patches. The results indicate that developers refactor these systems for a\u00a0\u2026", "num_citations": "3\n", "authors": ["822"]}
{"title": "Towards improving interface modularity in legacy java software through automated refactoring\n", "abstract": " The skeletal implementation pattern is a software design pattern consisting of defining an abstract class that provides a partial interface implementation. However, since Java allows only single class inheritance, if implementers decide to extend a skeletal implementation, they will not be allowed to extend any other class. Also, discovering the skeletal implementation may require a global analysis. Java 8 enhanced interfaces alleviate these problems by allowing interfaces to contain (default) method implementations, which implementers inherit. Java classes are then free to extend a different class, and a separate abstract class is no longer needed; developers considering implementing an interface need only examine the interface itself. We argue that both these benefits improve software modularity, and discuss our ongoing work in developing an automated refactoring tool that would assist developers in taking\u00a0\u2026", "num_citations": "3\n", "authors": ["822"]}
{"title": "Controlling use of shared content items based on client device\n", "abstract": " User accounts can be linked together to form a group of linked user accounts that can access content items assigned to the other user accounts in the group. A user can download content items assigned to their user account, as well as shared content items assigned to one of the other user accounts in the group of linked user accounts. Use of shared content items can be restricted to client devices running specified versions of an operating system. The key ID tagged to a shared content item can be altered such that the key ID no longer correctly identifies the corresponding DRM key that enables use of the shared content item. Client devices authorized to use shared content items can be configured to recognize that a content item is a shared content item and generate the original key ID form the altered key ID.", "num_citations": "3\n", "authors": ["822"]}
{"title": "Rejuvenate pointcut: A tool for pointcut expression recovery in evolving aspect-oriented software\n", "abstract": " Aspect-oriented programming (AOP) strives to localize the scattered and tangled implementations of crosscutting concerns (CCCs) by allowing developers to declare that certain actions (advice) should be taken at specific points (join points) during the execution of software where a CCC (an aspect) is applicable. However, it is non-trivial to construct optimal pointcut expressions (a collection of join points) that capture the true intentions of the programmer and, upon evolution, maintain these intentions. We demonstrate an AspectJ source-level inferencing tool called rejuvenate pointcut which helps developers maintain pointcut expressions over the lifetime of a software product. A key insight into the tool's construction is that the problem of maintaining pointcut expressions bears strong similarity to the requirements traceability problem in software engineering; hence, the underlying algorithm was devised by adapting\u00a0\u2026", "num_citations": "3\n", "authors": ["822"]}
{"title": "Object Databases: an Analytical Approach\n", "abstract": " Object-oriented techniques have accrued popularity as the preferred paradigm of modern programming. Despite this, relational database management systems, with their underlying relational model, remain the top choice for persistence and retrieval of large quantities of data. Persistence mechanisms of data have not experienced the paradigm shift that the mechanisms of manipulation of data have. This paper explores reasons as to why object databases, exhibiting the object model, have not gained as much popularity as their programming counterpart while examining issues in definition, motivation, alternatives, performance, benefits, and drawbacks of these systems.", "num_citations": "3\n", "authors": ["822"]}
{"title": "On the assessment of pointcut design in evolving aspect-oriented software\n", "abstract": " The pointcut expression (PCE) is a key mechanism in enabling Aspect-Oriented Programming (AOP)(Kiczales et al. 1997) to improve the localization of crosscutting concerns. PCEs quantify over well-defined points in the execution of the program called join points. A join point shadow, on the other hand, refers to base-code corresponding to a join point (Xu and Rountev 2008), ie, a point in the code where the compiler may perform the weaving (Masuhara et al. 2003). Advice joins at these points to allow the crosscutting concerns to be composed in an appropriate manner. PCEs need to be well-designed to ensure that they are correct in terms of identifying relevant join points to make certain the crosscutting concerns are composed correctly. Furthermore, PCEs should be robust in the midsts of base-code alterations. That is, changes to the base-code can lead to join points incorrectly falling in our out of scope of the\u00a0\u2026", "num_citations": "2\n", "authors": ["822"]}
{"title": "Automated evolution of feature logging statement levels using Git histories and degree of interest\n", "abstract": " Logging\u2014used for system events and security breaches to describe more informational yet essential aspects of software features\u2014is pervasive. Given the high transactionality of today's software, logging effectiveness can be reduced by information overload. Log levels help alleviate this problem by correlating a priority to logs that can be later filtered. As software evolves, however, levels of logs documenting surrounding feature implementations may also require modification as features once deemed important may have decreased in urgency and vice-versa. We present an automated approach that assists developers in evolving levels of such (feature) logs. The approach, based on mining Git histories and manipulating a degree of interest (DOI) model, 1 transforms source code to revitalize feature log levels based on the \u201cinterestingness\u201d of the surrounding code. Built upon JGit and Mylyn, the approach is\u00a0\u2026", "num_citations": "1\n", "authors": ["822"]}
{"title": "Fraglight: Shedding light on broken pointcuts in evolving aspect-oriented software\n", "abstract": " Pointcut fragility is a well-documented problem in Aspect-Oriented Programming; changes to the base-code can lead to join points incorrectly falling in or out of the scope of pointcuts. Deciding which pointcuts have broken due to base-code changes is a daunting venture, especially in large and complex systems. We demonstrate an automated tool called FRAGLIGHT that recommends a set of pointcuts that are likely to require modification due to a particular base-code change. The underlying approach is rooted in harnessing unique and arbitrarily deep structural commonality between program elements corresponding to join points selected by a pointcut in a particular software version. Patterns describing such commonality are used to recommend pointcuts that have potentially broken with a degree of confidence as the developer is typing. Our tool is implemented as an extension to the Mylyn Eclipse IDE plug-in\u00a0\u2026", "num_citations": "1\n", "authors": ["822"]}
{"title": "Formalizing Reusable Aspect-Oriented Concurrency Control.\n", "abstract": " Java and its library provide concurrency control mechanisms that allow a designer to implement various concurrency control schemes. However, use of these facilities often results in complex code with similar synchronization code being scattered across multiple classes, and synchronization code and functional code being tangled together. Moreover, similar code is often duplicated in different applications. Aspect-oriented (AO) programming makes it possible to address these problems. The precise behavior of systems built using AO techniques can, however, be di cult to understand. We propose a specification approach that allows us to precisely express key concurrency and synchronization properties of such systems. The specifications are based on a rich model that accounts for important capabilities of aspects such as that the applicability of a piece of advice at a give point may depend on the dynamic sequence of method calls prior to that point. We illustrate the approach by applying it to a simple abstract aspect, an example system and the corresponding subaspect.", "num_citations": "1\n", "authors": ["822"]}
{"title": "Enumeration refactoring: a tool for automatically converting java constants to enumerated types\n", "abstract": " Java 5 introduces several new features that offer significant improvements over older Java technology. We consider the new enum construct, which provides language support for enumerated types. Before Java 5, programmers needed to employ various patterns to compensate for the absence of enumerated types in Java. Unfortunately, these compensation patterns lack several highly desirable properties of the enum construct, most notably, type-safety. We demonstrate an automated refactoring tool called Convert Constants to Enum for transforming legacy Java code to use the new enumeration construct. An interprocedural type inferencing algorithm that tracks the flow of enumerated values drives the approach, and the tool is implemented as a seamless extension to existing refactoring support in Eclipse. The resulting code is semantically equivalent to the original, increasingly type-safe, easier to comprehend\u00a0\u2026", "num_citations": "1\n", "authors": ["822"]}