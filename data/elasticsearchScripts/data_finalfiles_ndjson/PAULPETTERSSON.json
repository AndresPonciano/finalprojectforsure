{"title": "Testing real-time systems using UPPAAL\n", "abstract": " This chapter presents principles and techniques for model-based black-box conformance testing of real-time systems using the Uppaal model-checking tool-suite. The basis for testing is given as a network of concurrent timed automata specified by the test engineer. Relativized input/output conformance serves as the notion of implementation correctness, essentially timed trace inclusion taking environment assumptions into account. Test cases can be generated offline and later executed, or they can be generated and executed online. For both approaches this chapter discusses how to specify test objectives, derive test sequences, apply these to the system under test, and assign a verdict.", "num_citations": "324\n", "authors": ["312"]}
{"title": "Efficient Verification of Real-Time Systems: Compact Data Structures and State-Space Reduction\n", "abstract": " During the past few years, a number of verification tools have been developed for real-time systems in the framework of timed automata (e.g. KRONOS and UPPAAL). One of the major problems in applying these tools to industrial-size systems is the huge memory-usage for the exploration of the state-space of a network (or product) of timed automata, as the model-checkers must keep information on not only the control structure of the automata but also the clock values specified by clock constraints. In this paper, we present a compact data structure for representing clock constraints. The data structure is based on an O(n/sup 3/) algorithm which, given a constraint system over real-valued variables consisting of bounds on differences, constructs an equivalent system with a minimal number of constraints. In addition, we have developed an on-the-fly, reduction technique to minimize the space-usage. Based on static\u00a0\u2026", "num_citations": "204\n", "authors": ["312"]}
{"title": "Compositional and symbolic model-checking of real-time systems\n", "abstract": " Efficient automatic model-checking algorithms for real-time systems have been obtained in recent years based on the state-region graph technique of Alur, Courcoubetis and Dill (1990). However, these algorithms are faced with two potential types of explosion arising from parallel composition: explosion in the space of control nodes, and explosion in the region space over clock-variables. In this paper we attack these explosion problems by developing and combining compositional and symbolic model-checking techniques. The presented techniques provide the foundation for a new automatic verification tool UPPAAL. Experimental results indicate that UPPAAL performs time- and space-wise favorably compared with other real-time verification tools.", "num_citations": "184\n", "authors": ["312"]}
{"title": "Efficient guiding towards cost-optimality in UPPAAL\n", "abstract": " In this paper we present an algorithm for efficiently computing the minimum cost of reaching a goal state in the model of Uniformly Priced Timed Automata (UPTA). This model can be seen as a submodel of the recently suggested model of linearly priced timed automata, which extends timed automata with prices on both locations and transitions. The presented algorithm is based on a symbolic semantics of UTPA, and an efficient representation and operations based on difference bound matrices. In analogy with Dijkstra\u2019s shortest path algorithm, we show that the search order of the algorithm can be chosen such that the number of symbolic states explored by the algorithm is optimal, in the sense that the number of explored states can not be reduced by any other search order. We also present a number of techniques inspired by branch-and-bound algorithms which can be used for limiting the search space\u00a0\u2026", "num_citations": "179\n", "authors": ["312"]}
{"title": "TIMES b\u2014A tool for modelling and implementation of embedded systems\n", "abstract": " T imes is a modelling and schedulability analysis tool for embedded real-time systems, developed at Uppsala University in 2001. It is appropriate for systems that can be described as a set of preemptive or non-preemptive tasks which are triggered periodically or sporadically by time or external events. It provides a graphical interface for editing and simulation, and an engine for schedulability analysis. The main features of Times are: A graphical editor for timed automata extended with tasks [1], which allows the user to model a system and the abstract behaviour of its environment In addition the user may specify a set of preemptive or non-preemtive tasks with parameters such as (relative) deadline, execution time, priority, etc. A simulator, in which the user can validate the dynamic behaviour of the system and see how the tasks execute according to the task parameters and a given scheduling policy. The simulator\u00a0\u2026", "num_citations": "170\n", "authors": ["312"]}
{"title": "As cheap as possible: effcient cost-optimal reachability for priced timed automata\n", "abstract": " In this paper we present an algorithm for efficiently computing optimal cost of reaching a goal state in the model of Linearly Priced Timed Automata (LPTA). The central contribution of this paper is a priced extension of so-called zones. This, together with a notion of facets of a zone, allows the entire machinery for symbolic reachability for timed automata in terms of zones to be lifted to cost-optimal reachability using priced zones. We report on experiments with a cost-optimizing extension of Uppaal on a number of examples.", "num_citations": "165\n", "authors": ["312"]}
{"title": "Time-optimal real-time test case generation using UPPAAL\n", "abstract": " Testing is the primary software validation technique used by industry today, but remains ad hoc, error prone, and very expensive. A promising improvement is to automatically generate test cases from formal models of the system under test.               We demonstrate how to automatically generate real-time conformance test cases from timed automata specifications. Specifically we demonstrate how to efficiently generate real-time test cases with optimal execution time i.e test cases that are the fastest possible to execute. Our technique allows time optimal test cases to be generated using manually formulated test purposes or generated automatically from various coverage criteria of the model.", "num_citations": "147\n", "authors": ["312"]}
{"title": "Guided Synthesis of Control Programs Using UPPAAL.\n", "abstract": " In this paper we address the problem of scheduling and synthesizing distributed control programs for a batch production plant. We use a timed automata model of the batch plant and the verification tool \u00cd\u00d4\u00d4 \u00d0 to solve the scheduling problem.In modeling the plant, we aim at a level of abstraction which is sufficiently accurate in order that synthesis of control programs from generated timed traces is possible. Consequently, the models quickly become too detailed and complicated for immediate automatic synthesis. In fact, only models of plants producing two batches can be analyzed directly! To overcome this problem, we present a general method allowing the user to guide the model-checker according to heuristically chosen strategies. The guidance is specified by augmenting the model with additional guidance variables and by decorating transitions with extra guards on these. Applying this method have made synthesis of control programs feasible for a plant producing as many as 60 batches.", "num_citations": "97\n", "authors": ["312"]}
{"title": "Specifying and generating test cases using observer automata\n", "abstract": " We present a technique for specifying coverage criteria and a method for generating test suites for systems whose behaviours can be described as extended finite state machines (EFSM). To specify coverage criteria we use observer automata with parameters, which monitor and accept traces that cover a given test criterion of an EFSM. The flexibility of the technique is demonstrated by specifying a number of well-known coverage criteria based on control- and data-flow information using observer automata with parameters. We also develop a method for generating test cases from coverage criteria specified as observers. It is based on transforming a given observer automata into a bitvector analysis problem that can be efficiently implemented as an extension to an existing state-space exploration such as, e.g. SPIN or Uppaal.", "num_citations": "95\n", "authors": ["312"]}
{"title": "Towards WCET analysis of multicore architectures using UPPAAL\n", "abstract": " To take full advantage of the increasingly used shared-memory multicore architectures, software algorithms will need to be parallelized over multiple threads. This means that threads will have to share resources (eg some level of cache) and communicate and synchronize with each other. There already exist software libraries (eg OpenMP) used to explicitly parallelize available sequential C/C++ and Fortran code, which means that parallel code could be easily obtained. To be able to use parallel software running on multicore architectures in embedded systems with hard real-time constraints, new WCET (Worst-Case Execution Time) analysis methods and tools must be developed. This paper investigates a method based on model-checking a system of timed automata using the UPPAAL tool box. It is found that it is possible to perform WCET analysis on (small) parallel systems using UPPAAL. We also show how to model thread synchronization using spinlock-like primitives.", "num_citations": "94\n", "authors": ["312"]}
{"title": "Formal verification of a TDMA protocol start-up mechanism\n", "abstract": " This paper presents a formal verification of the start-up algorithm of the DACAPO protocol. The protocol uses TDMA (Time Division Multiple Access) bus arbitration. It was verified that an ensemble of four communicating stations becomes synchronized and operational within a bounded time from an arbitrary initial state. The system model included a clock drift corresponding to /spl plusmn/10/sup -3/. The protocol was modeled using a network of timed automata, and verification was performed using the symbolic model checker UPPAAL.", "num_citations": "86\n", "authors": ["312"]}
{"title": "Modelling and verification of real-time systems using timed automata: theory and practice\n", "abstract": " During the last decade, model-checking techniques for the verification of timed system have been developed based on the theory of timed automata. The practical limitation in applying these techniques to industrial-size systems is the huge amount of time and memory needed to explore and store the state-space of the system model. In this thesis, we improve the current status of model-checking techniques for timed systems by developing symbolic, on-the-fly and compositional verification techniques for timed automata. A common characteristics of the model-checking techniques presented is that they use efficient constraint-solving techniques to symbolically represent and manipulate the state-space. To avoid construction of the full state-space of the system model two techniques are used: on-the-fly generation of the state-space and a compositional model-checking technique. The memory-usage is further reduced by developing a minimal and canonical data structure for the class of constraints used in the model-checking algorithm, which reduces the size of each individual state. Two other techniques to reduce the total number of states explored and stored during verification are also presented. The developed techniques have been implemented in the verification tool Uppaal. To demonstrate the potential applications of our model-checking techniques, we present three industrial-size case studies where the Uppaal tool is applied.", "num_citations": "85\n", "authors": ["312"]}
{"title": "Uppaal\n", "abstract": " Verifikation af realtids systemer i UPPAAL Page 1 UCb Verifikation af realtids systemer i UPPAAL Kim G. Larsen BRICS@Aalborg Page 2 2 MII\u2019\u20192001 Kim G. Larsen UCb Research Profile Distributed Systems & Semantics Unit Semantic Models concurrency, mobility, objects real-time, hybrid systems Validation & Verification algorithms & tools Construction real-time & network systems Page 3 3 MII\u2019\u20192001 Kim G. Larsen UCb BRICS Machine Basic Research in Computer Science 30+40+40 Millkr 100 100 Aalborg Aarhus Tools Other revelvant projects UPPAAL, VHS, VVS, WOODDES Page 4 4 MII\u2019\u20192001 Kim G. Larsen UCb Tools and BRICS Logic \u2022 Temporal Logic \u2022 Modal Logic \u2022 MSOL \u2022 \u2022 Algorithmic \u2022 (Timed) Automata Theory \u2022 Graph Theory \u2022 BDDs \u2022 Polyhedra Manipulation \u2022 \u2022 Semantics \u2022 Concurrency Theory \u2022 Abstract Interpretation \u2022 Compositionality \u2022 Models for real-time & hybrid systems \u2022 \u2022 HOL TLP Applications 5 \u2019\u2026", "num_citations": "79\n", "authors": ["312"]}
{"title": "Model-checking real-time control programs: verifying LEGO MINDSTORMSTM systems using UPPAAL\n", "abstract": " The authors present a method for automatic verification of real time control programs running on LEGO(R) RCX TM  bricks using the verification tool UPPAAL. The control programs, consisting of a number of tasks running concurrently, are automatically translated into the timed automata model of UPPAAL. The fixed scheduling algorithm used by the LEGO(R) RCX TM  processor is modeled in UPPAAL, and supply of similar (sufficient) timed automata models for the environment allows analysis of the overall real time system using the tools of UPPAAL. To illustrate our techniques, we have constructed, modeled and verified a machine for sorting LEGO(R) bricks by color.", "num_citations": "78\n", "authors": ["312"]}
{"title": "Remes: A resource model for embedded systems\n", "abstract": " In this paper, we introduce the model REMES for formal modeling and analysis of embedded resources such as storage,energy, communication, and computation. The model is a state-machine based behavioral language with support for hierarchical modeling, resource annotations, continuous time, and notions of explicit entry and exit points that make it suitable for component-based modeling of embedded systems.The analysis of REMES-based systems is centered around a weighted sum in which the variables represent the amounts of consumed resources. We describe a number of important resource related analysis problems, including feasibility, trade-off, and optimal resource-utilization analysis.To formalize these problems and provide a basis for rigorous analysis, we show how to analyze REMES models using the framework of priced timed automata and weighted CTL. To illustrate the approach, we\u00a0\u2026", "num_citations": "73\n", "authors": ["312"]}
{"title": "SaveCCM: An analysable component model for real-time systems\n", "abstract": " Component based development is a promising approach for embedded systems. Typical for embedded software is the presence of resource constraints in multiple dimensions. An essential dimension is time, since many embedded systems have real-time requirements. We define a formal semantics of a component language for embedded systems, SaveCCM, a language designed with vehicle applications and safety concerns in focus. The semantics is defined by a transformation into timed automata with tasks, a formalism that explicitly models timing and real-time task scheduling. A simple SaveCCM system with a PI controller is used as a case study. Temporal properties of the PI controller have been successfully verified using the timed automata model checker Uppaal.", "num_citations": "66\n", "authors": ["312"]}
{"title": "Model-based test suite generation for function block diagrams using the UPPAAL model checker\n", "abstract": " A method for model-based test generation of safety-critical embedded applications using Programmable Logic Controllers and implemented in a programming language such as Function Block Diagram (FBD) is described. The FBD component model is based on the IEC 1131 standard and it is used primarily for embedded systems, in which timeliness is an important property to be tested. Our method involves the transformation of FBD programs with timed annotations into timed automata models which are used to automatically generate test suites. Specifically we demonstrate how to use model transformation for formalization and model-checking of FBD programs using the UPPAAL tool. Many benefits emerge from this method, including the ability to automatically generate test suites from a formal model in order to ensure compliance to strict quality requirements including unit testing and specific coverage\u00a0\u2026", "num_citations": "58\n", "authors": ["312"]}
{"title": "A global algorithm for model-based test suite generation\n", "abstract": " Model-based testing has been proposed as a technique to automatically verify that a system conforms to its specification. A popular approach is to use a model-checker to produce a set of test cases by formulating the test generation problem as a reachability problem. To guide the selection of test cases, a coverage criterion is often used. A coverage criterion can be seen as a set of items to be covered, called coverage items. We propose an on-the-fly algorithm that generates a test suite that covers all feasible coverage items. The algorithm returns a set of traces that includes a path fulfilling each item, without including redundant paths. The reachability algorithm explores a state only if it might increase the total coverage. The decision is global in the sense that it does not only regard each individual local search branch in isolation, but the total coverage in all branches together. For simpler coverage criteria as location\u00a0\u2026", "num_citations": "53\n", "authors": ["312"]}
{"title": "Inference of event-recording automata using timed decision trees\n", "abstract": " We present an algorithm for inferring a timed-automaton model of a system from information obtained by observing its external behavior. Since timed automata can not in general be determinized, we restrict our attention to systems that can be described by deterministic event-recording automata. In previous work we have presented algorithms for event-recording automata that satisfy the restriction that there is at most one transition per alphabet symbol from each state. This restriction was lifted in subsequent work by an algorithm based on the region graph.               In this paper, we extend previous work by considering the full class of event-recording automata, while still avoiding to base it on the (usually prohibitively large) region graph. Our construction deviates from previous work on inference of automata in that it first constructs a so called timed decision tree from observations of system behavior, which is\u00a0\u2026", "num_citations": "51\n", "authors": ["312"]}
{"title": "Partial order reduction for verification of real-time components\n", "abstract": " We describe a partial order reduction technique for a real-time component model. Components are described as timed automata with data ports, which can be composed in static structures of unidirectional control and data flow. Compositions can be encapsulated as components and used in other compositions to form hierarchical models. The proposed partial order reduction technique uses a local time semantics for timed automata, in which time may progress independently in parallel automata which are resynchronized when needed. To increase the number of independent transitions and to reduce the problem of re-synchronizing parallel automata we propose, and show how, to use information derived from the composition structure of an analyzed model. Based on these ideas, we present a reachability analysis algorithm that uses an ample set construction to select which symbolic transitions to explore\u00a0\u2026", "num_citations": "47\n", "authors": ["312"]}
{"title": "Verifying MARTE/CCSL mode behaviors using UPPAAL\n", "abstract": " In the development of safety-critical embedded systems, the ability to formally analyze system behavior models, based on timing and causality, helps the designer to get insight into the systems overall timing behavior. To support the design and analysis of real-time embedded systems, the UML modeling profile MARTE provides CCSL \u2013 a time model and a clock constraint specification language. CCSL is an expressive language that supports specification of both logical and chronometric constraints for MARTE models. On the other hand, semantic frameworks such as timed automata provide verification support for real-time systems. To address the challenge of verifying CCSL-based behavior models, in this paper, we propose a technique for transforming MARTE/CCSL mode behaviors into Timed Automata for model-checking using the UPPAAL tool. This enables verification of both logical and chronometric\u00a0\u2026", "num_citations": "46\n", "authors": ["312"]}
{"title": "Component-based design and analysis of embedded systems with uppaal port\n", "abstract": " uppaalport is a new tool for component-based design and analysis of embedded systems. It operates on the hierarchically structured continuous time component modeling language SaveCCM and provides efficient model-checking by using partial-order reduction techniques that exploits the structure and the component behavior of the model. uppaalport is implemented as an extension of the verification engine in the uppaal tool. The tool can be used as back-end in to the Eclipse based SaveCCM integrated development environment, which supports user friendly editing, simulation, and verification of models.", "num_citations": "44\n", "authors": ["312"]}
{"title": "Model-based testing of a wap gateway: an industrial case-study\n", "abstract": " We present experiences from a case study where a model-based approach to black-box testing is applied to verify that aWireless Application Protocol (WAP) gateway conforms to its specification. TheWAP gateway is developed by Ericsson and used in mobile telephone networks to connect mobile phones with the Internet. We focus on testing the software implementing the session (WSP) and transaction (WTP) layers of the WAP protocol. These layers, and their surrounding environment, are described as a network of timed automata. To model the many sequence numbers (from a large domain) used in the protocol, we introduce an abstraction technique. We believe the suggested abstraction technique will prove useful to model and analyse other similar protocols with sequence numbers, in particular in the context of model-based testing.               A complete test bed is presented, which includes generation\u00a0\u2026", "num_citations": "44\n", "authors": ["312"]}
{"title": "A test case generation algorithm for real-time systems\n", "abstract": " We describe how the real-time verification tool UPPAAL has been extended to support automatic generation of time-optimal test suites for conformance testing. Such test suites are derived from a network of timed automata specifying the expected behaviour of the system under test and its environment. To select test cases, we use coverage criteria specifying structural criteria to be fulfilled by the test suite. The result is optimal in the sense that the set of test cases in the test suite requires the shortest possible accumulated time to cover the given coverage criterion. The main contributions of This work are: (i) a modified reachability analysis algorithm in which the coverage of given criteria is calculated in an on-the-fly manner, (ii) a technique for efficiently manipulating the sets of covered elements that arise during the analysis, and (iii) an extension to the requirement specification language used in UPPAAL, making it\u00a0\u2026", "num_citations": "44\n", "authors": ["312"]}
{"title": "A methodology for formal analysis and verification of EAST-ADL models\n", "abstract": " The architectural design of embedded software has a direct impact on the final implementation, with respect to performance and other quality attributes. Therefore, guaranteeing that an architectural model meets the specified requirements is beneficial for detecting software flaws early in the development process. In this paper, we present a formal modeling and verification methodology for safety-critical automotive products that are originally described in the domain-specific architectural language East-adl. We propose a model-based approach that integrates the architectural models with component-aware model checking, and describe its tool support called ViTAL. The functional and timing behavior of each function block in the East-adl model, as well as the interactions between function blocks are formally captured and expressed as Timed Automata models, which have precise semantics and can be formally\u00a0\u2026", "num_citations": "41\n", "authors": ["312"]}
{"title": "Automated verification of AADL-specifications using UPPAAL\n", "abstract": " The Architecture Analysis and Design Language (AADL) is used to represent architecture design decisions of safety-critical and real-time embedded systems. Due to the far-reaching effects these decisions have on the development process, an architecture design fault is likely to have a significant deteriorating impact through the complete process. Automated fault avoidance of architecture design decisions therefore has the potential to significantly reduce the cost of the development while increasing the dependability of the end product. To provide means for automated fault avoidance when developing systems specified in AADL, a formal verification technique has been developed to ensure completeness and consistency of an AADL specification as well as its conformity with the end product. The approach requires the semantics of AADL to be formalized and implemented. We use the methodology of semantic\u00a0\u2026", "num_citations": "41\n", "authors": ["312"]}
{"title": "COVER \u2013 A Real-Time Test Case Generation Tool\n", "abstract": " CO/ER is new test-case generation tool for timed systems. It generates test cases from a timed automata model of a system to be tested, and a coverage criteria expressed in an observer language. In this paper, we describe the current architecture of the tool, its input languages, and a case study in which tool has been applied in an industrial setting to test that a WAP gateway conform to its specification.", "num_citations": "39\n", "authors": ["312"]}
{"title": "Time-optimal test cases for real-time systems\n", "abstract": " Testing is the primary software validation technique used by industry today, but remains ad hoc, error prone, and very expensive. A promising improvement is to automatically generate test cases from formal models of the system under test.             We demonstrate how to automatically generate real-time conformance test cases from timed automata specifications. Specifically we demonstrate how to efficiently generate real-time test cases with optimal execution time i.e test cases that are the fastest possible to execute. Our technique allows time optimal test cases to be generated using manually formulated test purposes or automatically from various coverage criteria of the model.", "num_citations": "39\n", "authors": ["312"]}
{"title": "Formal semantics of the ProCom real-time component model\n", "abstract": " ProCom is a new component model for real-time and embedded systems, targeting the domains of vehicular and telecommunication systems. In this paper, we describe how the architectural elements of the ProCom component model have been given a formal semantics. The semantics is given in a small but powerful finite state machine formalism,with notions of urgency, timing, and priorities. By defining the semantics in this way, we (i) provide a rigorous and compact description of the modeling elements of ProCom, (ii) seethe ground for formal analysis using other formalisms, and(iii) provide an intuitive and useful description for both practitioners and researchers. To illustrate the approach,we exemplify with a number of particularly interesting cases, ranging from ports and services to components and component hierarchies.", "num_citations": "35\n", "authors": ["312"]}
{"title": "Vital: A verification tool for east-adl models using uppaal port\n", "abstract": " The influence of the systems architecture on the functions and other properties of embedded systems makes its high level analysis and verification very desirable. EASTADL is an architecture description language dedicated to automotive embedded system design with focus on structural and functional modeling. The behavioral description is not integrated within the execution semantics, which makes it harder to transform, analyze, and verify EAST-ADL models. Model-based techniques help to address this issue by enabling automated transformation between different design models, and providing means for simulation and verification. We present a way of integrating architectural models and verification techniques, which has been implemented in a tool called ViTAL. Consequently, ViTAL provides the possibility to express the functional EAST-ADL behavior as timed automata models, which have precise semantics\u00a0\u2026", "num_citations": "34\n", "authors": ["312"]}
{"title": "Verifying functional behaviors of automotive products in EAST-ADL2 using UPPAAL-PORT\n", "abstract": " We study the use of formal modeling and verification techniques at an early stage in the development of safety-critical automotive products which are originally described in the domain specific architectural language EAST-ADL2. This architectural language only focuses on the structural definition of functional blocks. However, the behavior inside each functional block is not specified and that limits formal modeling and analysis of systems behaviors as well as efficient verification of safety properties. In this paper, we tackle this problem by proposing one modeling approach, which formally captures the behavioral execution inside each functional block and their interactions, and helps to improve the formal modeling and verification capability of EAST-ADL2: the behavior of each elementary function of EAST-ADL2 is specified in UPPAAL Timed Automata. The formal syntax and semantics are defined in order to\u00a0\u2026", "num_citations": "34\n", "authors": ["312"]}
{"title": "A research overview of tool-supported model-based testing of requirements-based designs\n", "abstract": " Software testing aims at gaining confidence in software products through fault detection, by observing the differences between the behavior of the implementation and the expected behavior described in the specification. Nowadays, testing is the main verification technique used in industry, being a time and resource consuming activity. This has boosted the development of potentially more efficient testing techniques, like model-based testing, where test creation and execution can be automated, using an abstract system model as input. In this chapter, we provide an overview of the state-of-the-art in tool-supported model-based testing that starts from requirements-based models, by presenting and classifying some of the most mature tools available at this moment. Our goal is to get a deeper insight into the state-of-the-art in this area, as well as to form a position with respect to possible needs and gaps in the current\u00a0\u2026", "num_citations": "31\n", "authors": ["312"]}
{"title": "A model-based testing framework for automotive embedded systems\n", "abstract": " Architectural models, such as those described in the east language, represent convenient abstractions to reason about automotive embedded software systems. To enjoy the fully-fledged advantages of reasoning, EAST-ADL models could benefit from a component-aware analysis framework that provides, ideally, both verification and model-based test-case generation capabilities. While different verification techniques have been developed for architectural models, only a few target EAST-ADL. In this paper, we present a methodology for code validation, starting from EAST-ADL artifacts. The methodology relies on: (i) automated model-based test-case generation for functional requirements criteria based on the EAST-ADL model extended with timed automata semantics, and (ii) validation of system implementation by generating Python test scripts based on the abstract test-cases. The scripts represent concrete test\u00a0\u2026", "num_citations": "29\n", "authors": ["312"]}
{"title": "The saveccm language reference manual\n", "abstract": " This language reference describes the syntax and semantics of SaveCCM, acomponent modeling language for embedded systems designed with vehicle applications and safety concerns in focus. The SaveCCM component model wasdefined within the SAVE project. The SAVE components are influenced mainlyby the Rubus component technology, with a switch concept similar to thatin Koala. The semantics is defined by a transformation into timed automatawith tasks, a formalism that explicitly models timing and real-time task scheduling.The purpose of this document is to describe a semantics of the SAVE component modeling language, which can be used to describe timing and functional behavior of components. The model of a system is in some cases an over approximation of the actual system behavior. An implementation of a model can resolve non-determinism e.g. by merging tasks or assigning a\u00a0\u2026", "num_citations": "25\n", "authors": ["312"]}
{"title": "A controlled experiment in testing of safety-critical embedded software\n", "abstract": " In engineering of safety critical systems, regulatory standards often put requirements on both traceable specification-based testing, and structural coverage on program units. Automated test generation techniques can be used to generate inputs to cover the structural aspects of a program. However, there is no conclusive evidence on how automated test generation compares to manual test design, or how testing based on the program implementation relates to specification-based testing. In this paper, we investigate specification -- and implementation-based testing of embedded software written in the IEC 61131-3 language, a programming standard used in many embedded safety critical software systems. Further, we measure the efficiency and effectiveness in terms of fault detection. For this purpose, a controlled experiment was conducted, comparing tests created by a total of twenty-three software engineering\u00a0\u2026", "num_citations": "23\n", "authors": ["312"]}
{"title": "Modelling, verification and synthesis of two-tier hierarchical fixed-priority preemptive scheduling\n", "abstract": " Hierarchical scheduling has major benefits when it comes to integrating hard real-time applications. One of those benefits is that it gives a clear runtime separation of applications in the time domain. This in turn gives a protection against timing error propagation in between applications. However, these benefits rely on the assumption that the scheduler itself schedules applications correctly according to the scheduling parameters and the chosen scheduling policy. A faulty scheduler can affect all applications in a negative way. Hence, being able to guarantee that the scheduler is correct is of great importance. Therefore, in this paper, we study how properties of hierarchical scheduling can be verified. We model a hierarchically scheduled system using task automata, and we conduct verification with model checking using the Times tool. Further, we generate C-code from the model and we execute the hierarchical\u00a0\u2026", "num_citations": "22\n", "authors": ["312"]}
{"title": "Verification of COMDES-II systems using UPPAAL with model transformation\n", "abstract": " COMDES-II is a component-based software framework intended for model-integrated development of embedded control systems with hard real-time constraints. It provides various kinds of component models to address critical domain-specific issues, such as real-time concurrency and communication in a timed multitasking environment, modal continuous operation combining reactive control behavior with continuous data processing, etc., by following the principle of separation-of-concerns. In the paper we present a transformational approach to the formal verification of both timing and reactive behaviors of COMDES-II systems using UPPAAL, based on a semantic anchoring methodology. The proposed approach adopts UPPAAL timed automata as the semantic units, to which different behavioral concerns of COMDES-II are anchored, such that a COMDES-II system can be precisely specified in UPPAAL, and\u00a0\u2026", "num_citations": "21\n", "authors": ["312"]}
{"title": "A comparative study of manual and automated testing for industrial control software\n", "abstract": " Automated test generation has been suggested as a way of creating tests at a lower cost. Nonetheless, it is not very well studied how such tests compare to manually written ones in terms of cost and effectiveness. This is particularly true for industrial control software, where strict requirements on both specification-based testing and code coverage typically are met with rigorous manual testing. To address this issue, we conducted a case study in which we compared manually and automatically created tests. We used recently developed real-world industrial programs written in the IEC 61131-3, a popular programming language for developing industrial control systems using programmable logic controllers. The results show that automatically generated tests achieve similar code coverage as manually created tests, but in a fraction of the time (an average improvement of roughly 90%). We also found that the use of an\u00a0\u2026", "num_citations": "19\n", "authors": ["312"]}
{"title": "Seamless formal verification of complex event processing applications\n", "abstract": " Despite proven successful in previous projects, the use of formal methods for enhancing quality of software is still not used in its full potential in industry. We argue that seamless support for formal verification in a high-level specification tool enhances the attractiveness of using a formal approach for increasing software quality.", "num_citations": "19\n", "authors": ["312"]}
{"title": "Modeling and reasoning about service behaviors and their compositions\n", "abstract": " Service-oriented systems have recently emerged as context-indepen-dent component-based systems. Unlike components, services can be created, invoked, composed, and destroyed at run-time. Consequently, all services need a way of advertising their capabilities to the entities that will use them, and service-oriented modeling should cater for various kinds of service composition. In this paper, we show how services can be formally described by the resource-aware timed behavioral language Remes, which we extend with service-specific information, such as type, capacity, time-to-serve, etc., as well as boolean constraints on inputs, and output guarantees. Assuming a Hoare-triple model of service correctness, we show how to check it by using the strongest postcondition semantics. To provide means for connecting Remes services, we propose a hierarchical language for service composition, which\u00a0\u2026", "num_citations": "18\n", "authors": ["312"]}
{"title": "Abv-a verifier for the architecture analysis and design language (aadl)\n", "abstract": " Designing and developing mission-critical embedded systems is challenging, especially due to additional platform constraints regarding timing and computational resources. The development process of embedded systems should include verification techniques already at the architecture design phase, to provide evidence that a system's architecture fulfills its requirements. The Architecture Analysis and Design Language (AADL) is used to model the system's architecture. Among others, the language contains a Behavior Annex, for describing the behavior of an AADL model, at an abstract level. In this paper, we present a verification tool, called ABV, tailored for AADL models with a behavioral annex. Given an architecture defined in AADL and its behavior specified in the associated language, our tool model-checks the latter against the requirements specified in Computation Tree Logic (CTL). ABV is based on\u00a0\u2026", "num_citations": "17\n", "authors": ["312"]}
{"title": "Analyzing a pattern-based model of a real-time turntable system\n", "abstract": " Designers of industrial real-time systems are commonly faced with the problem of complex system modeling and analysis, even if a component-based design paradigm is employed. In this paper, we present a case-study in formal modeling and analysis of a turntable system, for which the components are described in the SaveCCM language. The search for general principles underlying the internal structure of our real-time system has motivated us to propose three modeling patterns of common behaviors of real-time components, which can be instantiated in appropriate design contexts. The benefits of such reusable patterns are shown in the case-study, by allowing us to produce easy-to-read and manageable models for the real-time components of the turntable system. Moreover, we believe that the patterns may pave the way toward a generic pattern-based modeling framework targeting real-time systems in\u00a0\u2026", "num_citations": "16\n", "authors": ["312"]}
{"title": "Prototyping and code synthesis of hierarchically scheduled systems using times\n", "abstract": " In hierarchical scheduling a system is organized as a tree of nodes, where each node schedules its child nodes. A node contains tasks and/or subsystems, where a subsystem is typically developed by a development team. Given a system where each part is subcontracted to different developers, they can benefit from hierarchical scheduling by parallel development and simplified integration of subsystems. Each team should have the possibility to test their system before integration. Hence, we show how a node, in a hierarchical scheduling tree, can be analyzed in the Times tool by replacing all interference from nodes with a small set of higher priority tasks. We show an algorithm that can generate these tasks, including their parameters. Further, we use the Times code-generator, in combination with operating system extensions, to generate source code that emulates the scheduling environment for a subsystem, in an arbitrary level in the tree. Our experiments include two example systems. In the first case we generate source code for an industrial oriented platform (VxWorks) and conduct a performance evaluation. In the second example we generate source code that emulates the scheduling environment for a video application, running in Linux, and we perform a frame-rate evaluation.", "num_citations": "14\n", "authors": ["312"]}
{"title": "Cover-a test-case generation tool for timed systems\n", "abstract": " CO/ER is a new test-case generation tool for timed systems. It generates test cases from a timed automata model of a system to be tested, and a coverage criteria expressed in an observer language. In this paper, we describe the current architecture of the tool, its input languages, and a case study in which the tool has been applied in an industrial setting to test that a WAP gateway conform to its specification.", "num_citations": "14\n", "authors": ["312"]}
{"title": "MOS: an integrated model-based and search-based testing tool for function block diagrams\n", "abstract": " In this paper we present a new testing tool for safety critical applications described in Function Block Diagram (FBD) language aimed to support both a model and a search-based approach. Many benefits emerge from this tool, including the ability to automatically generate test suites from an FBD program in order to comply to quality requirements such as component testing and specific coverage measurements. Search-based testing methods are used to generate test data based on executable code rather than the FBD program, alleviating any problems that may arise from the ambiguities that occur while creating FBD programs. Test cases generated by both approaches are executed and used as a way of cross validation. In the current work, we describe the architecture of the tool, its workflow process, and a case study in which the tool has been applied in a real industrial setting to test a train control management\u00a0\u2026", "num_citations": "13\n", "authors": ["312"]}
{"title": "Analyzing a wind turbine system: From simulation to formal verification\n", "abstract": " Many industrial systems are hybrid by nature, most often being made of a discrete controller that senses and regulates the execution of a plant characterized by continuous dynamics. Examples of such systems include wind turbines that convert wind energy into electrical energy. Designing industrial control systems is challenging, due to the mixed nature of requirements (functional, timing, etc.) as well as due to the complexity stemming from the interaction of the controller with the plant. Model-based techniques help in tackling the design challenges, whereas methods such as simulation with tools like MATLAB/Simulink can be employed for analysis. Although practical, these methods alone cannot ensure full predictability, due to the fact that they cannot guarantee system properties for all possible executions of the system model. In order to ensure that the system will behave as expected under any operational\u00a0\u2026", "num_citations": "12\n", "authors": ["312"]}
{"title": "Using mutation to design tests for aspect-oriented models\n", "abstract": " Context: Testing for properties such as robustness or security is complicated because their concerns are often repeated in many locations and muddled with the normal code. Such \u201ccross-cutting concerns\u201d include things like interrupt events, exception handling, and security protocols. Aspect-oriented (AO) modeling allows developers to model the cross-cutting behavior independently of the normal behavior, thus supporting model-based testing of cross-cutting concerns. However, mutation operators defined for AO programs (source code) are usually not applicable to AO models (AOMs) and operators defined for models do not target the AO features.Objective: We present a method to design abstract tests at the aspect-oriented model level. We define mutation operators for aspect-oriented models and evaluate the generated mutants for an example system.Method: AOMs are mutated with novel operators that\u00a0\u2026", "num_citations": "12\n", "authors": ["312"]}
{"title": "Mutating aspect-oriented models to test cross-cutting concerns\n", "abstract": " Aspect-oriented (AO) modeling is used to separate normal behaviors of software from specific behaviors that affect many parts of the software. These are called \u201ccross-cutting concerns,\u201d and include things such as interrupt events, exception handling, and security protocols. AO modeling allow developers to model the behaviors of cross-cutting concerns independently of the normal behavior. Aspect-oriented models (AOM) are then transformed into code by \u201cweaving\u201d the aspects (modeling the cross-cutting concerns) into all locations in the code where they are needed. Testing at this level is unnecessarily complicated because the concerns are often repeated in many locations and because the concerns are muddled with the normal code. This paper presents a method to design robustness tests at the abstract, or model, level. The models are mutated with novel operators that specifically target the features of AOM\u00a0\u2026", "num_citations": "12\n", "authors": ["312"]}
{"title": "An architecture-based verification technique for AADL specifications\n", "abstract": " Quality assurance processes of software-intensive systems are an increasing challenge as the complexity of these systems dramatically increases. The use of Architecture Description Languages (ADLs) provide an important basis for evaluation. The Architecture Analysis and Design Language (AADL) is an ADL developed for designing software-intensive systems. In this paper, we propose an architecture-based verification technique covering the entire development process by adapting a combination of model-checking and model-based testing approaches to AADL specifications. The technique reveals inconsistencies of early design decisions and ensures a system\u2019s conformity with its AADL specification. The objective and criteria (test-selection) of the verification technique is derived from traditional integration testing.", "num_citations": "12\n", "authors": ["312"]}
{"title": "Guiding and cost-optimality in UPPAAL\n", "abstract": " In this paper we present an algorithm for efficiently computing the minimum cost of reaching a goal state in the model of Uniformly Priced Timed Automata (UPTA). This model can be seen as a submodel of the recently suggested model of linearly priced timed automata, which extends timed automata with prices on both locations and transitions. The presented algorithm is based on a symbolic semantics of UTPA, and an efficient representation and operations based on difference bound matrices. In analogy with Dijkstra\u2019s shortest path algorithm, we show that the search order of the algorithm can be chosen such that the number of symbolic states explored by the algorithm is optimal, to be optimal, in the sense that the number of explored states can not be reduced by any other search order. We also present a number of techniques inspired by branch-and-bound algorithms which can be used for limiting the search space and for quickly finding near-optimal solutions.", "num_citations": "12\n", "authors": ["312"]}
{"title": "Guided synthesis of control programs using UPPAAL for VHS case study 5\n", "abstract": " In this paper we address the problem of synthesizing control programs for a physical plant, such as the steel production plant of SIDMAR, from a timed automata model of the plant. We present a model of the plant that faithfully reflects the level of abstraction required for synthesizing control programs. As this very detailed model quickly becomes too complicated for automatic synthesis, we also present a guided model. We present a general way of adding guidance to a model by augmenting the model with additional guide variables and decorating the transitions with extra guards. We have successfully applied the method to our models, making automatic synthesis feasible for larger models.", "num_citations": "10\n", "authors": ["312"]}
{"title": "ProCom: Formal semantics\n", "abstract": " The goal of PROGRESS is to provide theories, methods and tools to increase predictability, and reuse in the development of embedded systems in particular those in the vehicular domain. For reusability a component based approach is adopted for the overall development process. In order to cover the whole development process of these systems and address the different concerns that exist on different levels of granularity ie both the design of a complete system and of the low-level control-based functionalities, ProCom component model is designed in a layered manner. Accordingly, ProCom is a two-layered component model that is introduced in [3],[4] and [6]. The top layer in ProCom is called ProSys, in which a system is modelled as a collection of concurrent, communicating subsystems. The components on this level are often meant to be allocated to different nodes in a distributed system. Even a single subsystem may consists of parts that end up on different nodes (the distribution is however specified by a separate deployment model). The modeling constructs of ProSys layer are: systems, subsystems, connections, and message channels.The lower layer in ProCom is called ProSave, which defines a componentbased design language for modelling subsystems with complex control functionality. A subsystem is constructed by hierarchically structured, interconnected components. These components are design-time entities that are typically not distinguishable as individual units in the final executing system. The modeling constructs of ProSave layer are: components (basic, composite, services, ports (data, trigger), connections, and\u00a0\u2026", "num_citations": "9\n", "authors": ["312"]}
{"title": "Verification of an industrial rule-based manufacturing system using REX\n", "abstract": " Formal methods are not used in their full potential for enhancing software quality in industry. We argue that seamless support in a high-level specification tool is a viable way to provide system designers with powerful and paradigm specific formal verification techniques. Event condition action (ECA) rules can be used to model and implement reactive behavior in, for example, the semantic web. Independently of target system, the behavior of rule-based systems are known to be hard to analyze. The REX tool is a rule-based front-end to the timed automata CASE-tool Uppaal. The model-checker in Uppaal is used by REX enabling seamless support for model-checking rule-based specifications. This paper presents experiences from modeling and verifying a system of industrial complexity as interacting rules using REX. We conclude that repeatedly performing formal analysis when constructing a system with interacting rules is a viable way of coping with the complexity of the model. Additionally, we present an implemented algorithm for optimizing the model to reduce the effect of state-space explosion.", "num_citations": "9\n", "authors": ["312"]}
{"title": "Risk-based decision-making fallacies: Why present functional safety standards are not enough\n", "abstract": " Functional safety of a system is the part of its overall safety that depends on the system operating correctly in response to its inputs. Safety is defined as the absence of unacceptable/unreasonable risk by functional safety standards, which enforce safety requirements in each phase of the development process of safety-critical software and hardware systems. Acceptability of risks is judged within a framework of analysis with contextual and cultural aspects by individuals who may introduce subjectivity and misconceptions in the assessment. While functional safety standards elaborate much on the avoidance of unreasonable risk in the development of safety-critical software and hardware systems, little is addressed on the issue of avoiding unreasonable judgments of risk. Through the studies of common fallacies in risk perception and ethics, we present a moral-psychological analysis of functional safety standards and\u00a0\u2026", "num_citations": "8\n", "authors": ["312"]}
{"title": "Applying model checking for verifying the functional requirements of a Scania\u2019s vehicle control system\n", "abstract": " Model based development is one of the most significant areas in recent research and development activities in the field of automotive industry. As the field of software engineering is evolving, model based development is gaining more and more importance in academia and industry. Therefore it is desirable to have techniques that are able to identify anomalies in the system models during analysis and design phase instead of identifying them in development phase where it\u2019s difficult to locate them and require a lot of time, effort and resources to fix them. Model checking is a formal verification technique that facilitates to identify the defects in system model at the early stages of system development. There are a lot of tool in academia and industry that provide the automated support for model checking.In this master thesis one of Scania\u2019s vehicle control system called Fuel Level Display System is modeled in two\u00a0\u2026", "num_citations": "8\n", "authors": ["312"]}
{"title": "Dilemma-an instant lexicographer\n", "abstract": " Dilemma is intended to enhance quality and increase productivity of expert human translators by presenting to the writer relevant lexical information mechanically extracted from comparable existing translations, thus replacing - or compensating for the absence of - a lexicographer and stand-by terminologist rather than the translator. Using statistics and crude surface analysis and a minimum of prior information, Dilemma identifies instances and suggests their counterparts in parallel source and target texts, on all levels down to individual words. Dilemma forms part of a tool kit for translation where focus is on text structure and over-all consistency in large text volumes rather than on framing sentences, on interaction between many actors in a large project rather than on retrieval of machine-stored data and on decision making rather than on application of given rules. In particular, the system has been tuned to the needs of the ongoing translation of European Community legislation into the languages of candidate member countries. The system has been demonstrated to and used by professional translators with promising results.", "num_citations": "8\n", "authors": ["312"]}
{"title": "AQAF: an architecture quality assurance framework for systems modeled in AADL\n", "abstract": " Architecture engineering is essential to achieve dependability of critical embedded systems and affects large parts of the system life cycle. There is consequently little room for faults, which may cause substantial costs and devastating harm. Verification in architecture engineering should therefore be holistically and systematically managed in the development of critical embedded systems, from requirements analysis and design to implementation and maintenance. In this paper, we address this problem by presenting AQAF: an Architecture Quality Assurance Framework for critical embedded systems modeled in the Architecture Analysis and Design Language (AADL). The framework provides a holistic set of verification techniques with a common formalism and semantic domain, architecture flow graphs and timed automata, enabling completely formal and automated verification processes covering virtually the entire\u00a0\u2026", "num_citations": "7\n", "authors": ["312"]}
{"title": "Wind turbine system: An industrial case study in formal modeling and verification\n", "abstract": " In the development of embedded systems, the formal analysis of system artifacts, such as structural and behavioral models, helps the system engineers to understand the overall functional and timing behavior of the system. In this case study paper, we present our experience in applying formal verification and validation (V&V) techniques, we had earlier proposed, for an industrial wind turbine system (WTS). We demonstrate the complementary benefits of formal verification in the context of existing V&V practices largely based on simulation and testing. We also discuss some modeling trade-offs and challenges we have identified with the case-study, which are worth being emphasized. One issue is related, for instance, to the expressiveness of the system artifacts, in view of the known limitations of rigorous verification, e.g. model-checking, of industrial systems.", "num_citations": "7\n", "authors": ["312"]}
{"title": "Experience report: Evaluating fault detection effectiveness and resource efficiency of the architecture quality assurance framework and tool\n", "abstract": " The Architecture Quality Assurance Framework (AQAF) is a theory developed to provide a holistic and formal verification process for architectural engineering of critical embedded systems. AQAF encompasses integrated architectural model checking, model-based testing, and selective regression verification techniques to achieve this goal. The Architecture Quality Assurance Tool (AQAT) implements the theory of AQAF and enables automated application of the framework. In this paper, we present an evaluation of AQAT and the underlying AQAF theory by means of an industrial case study, where resource efficiency and fault detection effectiveness are the targeted properties of evaluation. The method of fault injection is utilized to guarantee coverage of fault types and to generate a data sample size adequate for statistical analysis. We discovered important areas of improvement in this study, which required further\u00a0\u2026", "num_citations": "6\n", "authors": ["312"]}
{"title": "Distributed energy management case study: A formal approach to analyzing utility functions\n", "abstract": " The service-oriented paradigm has been established to enable quicker development of new applications from already existing services. Service negotiation is a key technique to provide a way of deciding and choosing the most suitable service, out of possibly many services delivering similar functionality but having different response times, resource usages, prices, etc. In this paper, we present a formal approach to the clients-providers negotiation of distributed energy management. The models are described in our recently introduced Remes                 Hdcl language, with timed automata semantics that allows us to apply\u00a0Uppaal-based tools for model-checking various scenarios of service negotiation. Our target is to compute ways of reaching the price- and reliability-optimal values of the utility function, at the end of the service negotiation.", "num_citations": "6\n", "authors": ["312"]}
{"title": "Regression verification of AADL models through slicing of system dependence graphs\n", "abstract": " Design artifacts of embedded systems are subjected to a number of modifications during the development process. Verified artifacts that subsequently are modified must necessarily be re-verified to ensure that no faults have been introduced in response to the modification. We collectively call this type of verification as regression verification. In this paper, we contribute with a technique for selective regression verification of embedded systems modeled in the Architecture Analysis and Design Language (AADL). The technique can be used with any AADL-based verification technique to efficiently perform regression verification by only selecting verification sequences that cover parts that are affected by the modification for re-execution. This allows for the avoidance of unnecessary re-verification, and thereby unnecessary costs. The selection is based on the concept of specification slicing through system dependence\u00a0\u2026", "num_citations": "6\n", "authors": ["312"]}
{"title": "Using logic coverage to improve testing function block diagrams\n", "abstract": " In model-driven development, testers are often focusing on functional model-level testing, enabling verification of design models against their specifications. In addition, in safety-critical software development, testers are required to show that tests cover the structure of the implementation. Testing cost and time savings could be achieved if the process of deriving test cases for logic coverage is automated and provided test cases are ready to be executed. The logic coverage artifacts, i.e., predicates and clauses, are required for different logic coverage, e.g., MC/DC. One way of dealing with test case generation for ensuring logic coverage is to approach it as a model-checking problem, such that model-checking tools automatically create test cases. We show how logic coverage criteria can be formalized and used by a model-checker to provide test cases for ensuring coverage on safety-critical software\u00a0\u2026", "num_citations": "6\n", "authors": ["312"]}
{"title": "East-adl tailored testing: From system models to executable test cases\n", "abstract": " Architectural models, such as those described in the Eastadl language, represent convenient abstractions to reason about embedded software systems. To enjoy the fully-fledged advantages of reasoning, East-adl models require a component-aware analysis framework that provide, ideally, both verification and model-based test-case generation capabilities. In this paper, we extend ViTAL, our recently developed toolsupported framework for model-checking East-adl models in Uppaal Port, with automated model-based test-case generation for functional requirements criteria. To validate the actual system implementation and exercise the feasibility of the abstract test-cases, we also show how to generate Python test scripts, from the ViTAL generated abstract testcases. The scripts define the concrete test-cases that are executable on the system implementation, within the Farkle testing environment. Tool interoperability between ViTAL and Farkle is ensured by implementing a corresponding interface, compliant with the Open Services for Lifecycle collaboration (OSLC) standard. We apply our methodology to validate the ABS function implementation of a Brake-by-Wire system prototype.", "num_citations": "6\n", "authors": ["312"]}
{"title": "Bridging the semantic gap between abstract models of embedded systems\n", "abstract": " In the development of embedded software, modeling languages used within or across development phases e.g., requirements, specification, design, etc are based on different paradigms and an approach for relating these is needed. In this paper, we present a formal framework for relating specification and design models of embedded systems. We have chosen UML statemachines as specification models and ProCom component language for design models. While the specification is event-driven, the design is based on time triggering and data flow. To relate these abstractions, through the execution trajectories of corresponding models, formal semantics for both kinds of models and a set of inference rules are defined. The approach is applied on an autonomous truck case-study.", "num_citations": "6\n", "authors": ["312"]}
{"title": "Modelling and analysis of a steam generator using UPPAAL\n", "abstract": " We present the modelling and analysis of a steam generator using the automatic verification tool uppaal. The physical parts of the steam generator as well as the control software are modelled in the language of timed automata. Requirements to the system are stated in a real--time logic allowing for expessing safety properties such as' the waterlevel in the drum must never go below nor above certain critical values'. Also the logic allows for expressing bounded liveness properties, eg'steam must be produced within a certain timelimit'. The automatic modelchecker in uppaal is used to investigate system behaviour with respect to logical properties. Introduction In a steam generator water is let into a drum where it gets heated by a burner with the aim of producing steam to be used for example in the production of electric power. The drum and the burner are controlled and monitored by two control programs, whose job is to ensure thet fresh water is let into the drum when needed and to...", "num_citations": "6\n", "authors": ["312"]}
{"title": "The architecture analysis and design language and the behavior annex: A denotational semantics\n", "abstract": " We present a denotational semantics for the Architecture Analysis and Design Language with Behavior Annex and the Computational Tree logic. We also present tool support as an OSATE plug-in as well as the Production Cell case study.", "num_citations": "5\n", "authors": ["312"]}
{"title": "An integrated tool for trade-off analysis of quality-of-service attributes\n", "abstract": " In this paper, we present a tool for performing trade-off analysis of Quality-of-Service attributes of design solutions resulted from architectural, behavioral, or deployment changes in service-oriented systems. The tool allows for comparing the performance, reliability, and maintainability of such solutions, in an attempt to compute the optimal one with respect to the weighted sum of the considered quality attributes. Our tool uses the Analytic Hierarchy Process for computing these trade-offs and is integrated into the Quality Impact Prediction for Evolving Service-Oriented Software IDE. Consequently, architects and system analysts now have an easy to use tool set for making trade-offs for these system qualities.", "num_citations": "5\n", "authors": ["312"]}
{"title": "Formal reasoning of resource-aware services\n", "abstract": " Service-oriented systems have recently emerged as context-independent component-based systems. Unlike components, services can be created, invoked, composed, and destroyed at run-time. Consequently, all services should have a way of advertising their capabilities to the entities that will use them, and service-oriented modeling should cater for various kinds of service composition. In this paper, we show how services can be formally described by the resource-aware timed behavioral language REMES, which we extend with service-specific information, such as type, capacity, time-to-serve, etc., as well as boolean constraints on inputs, and output guarantees. Assuming a Hoare-triple model of service correctness, we show how to check it by using the strongest postcondition semantics. To provide means for connecting REMES services, we propose a hierarchical language for service composition, which allows for verifying the latter s correctness. The approach is applied on an abstracted version of an intelligent shuttle system, for which we also compute resource-efficient behaviors, and energy-time trade-offs, by model-checking the system s underlying Priced Timed Automata semantic representation.", "num_citations": "5\n", "authors": ["312"]}
{"title": "Experimental Batch Plant: VHS Case Study 1 using Timed Automata and UPPAAL\n", "abstract": " Experimental Batch Plant: VHS Case Study 1 using Timed Automata and UPPAAL \u2014 Aalborg University's Research Portal Skip to main navigation Skip to search Skip to main content Aalborg University's Research Portal Logo Dansk English Home Profiles Projects Publications Activities Research Units Facilities Press / Media Prizes Datasets Impacts Search by keywords, name or affiliation Experimental Batch Plant: VHS Case Study 1 using Timed Automata and UPPAAL K. Kristoffersen, Kim Guldstrand Larsen, P. Pettersson, C. Weise Department of Computer Science Research output: Book/Report \u203a Book \u203a Research Overview Original language English Publication status Published - 1999 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Kristoffersen, K., Larsen, KG, Pettersson, P., & Weise, C. (1999). Experimental Batch Plant: VHS Case Study 1 using Timed Automata and UPPAAL. Kristoffersen, K. ; , .\u2026", "num_citations": "5\n", "authors": ["312"]}
{"title": "Checking correctness of services modeled as priced timed automata\n", "abstract": " Service-Oriented Systems (SOS) have gained importance in different application domains thanks to their ability to enable reusable functionality provided via well-defined interfaces, and the increased opportunities to compose existing units, called services, into various configurations. Developing applications in such a setup, by reusing existing services, brings some concerns regarding the assurance of the expected Quality-of-Service (QoS), and correctness of the employed services. In this paper, we describe a formal mechanism of computing service guarantees, automatically. We assume service models annotated with pre- and postconditions, with their semantics given as Priced Timed Automata (PTA), and the forward analysis method for checking the service correctness w.r.t. given requirements. Under these assumptions, we show how to compute the strongest postcondition of the corresponding\u00a0\u2026", "num_citations": "4\n", "authors": ["312"]}
{"title": "Adaptive task automata: A framework for verifying adaptive embedded systems\n", "abstract": " We present a framework for modeling and analysis of adaptive embedded systems, based on the model of timed automata with tasks. The model is extended with primitives allowing modeling of adaptivity, by testing the potential schedulability of a given task, in the context of the set of currently enqueued tasks. This makes it possible to describe adaptive embedded systems, in which decisions to admit further tasks or take other measures of adaptivity is based on available CPU resources, external, or internal events. We show that this model can be encoded in the framework of timed automata, and hence that the problem is decidable. We also validate the framework, by using the Uppaal tool.", "num_citations": "4\n", "authors": ["312"]}
{"title": "Validation of embedded systems behavioral models on a component-based ericsson nikola tesla demonstrator\n", "abstract": " Embedded systems are challenging to design, due to the implementation platform constraints that have to be considered, preferably from early stages of design, next-by system functionality. Hence, embedded system models need to be timing and resource-aware, to make formal verification of extra functional properties applicable at high levels of abstraction. In most cases, a frequent obstacle to the successful application of such rigorous techniques is the lack of the proposed models'validation against real-world application measurements. In this paper, we show how to model extra-functional behavior, and verify the resulted behavioral models of a component-based Ericsson Nikola Tesla prototype telecommunications system. The models are described in our recently introduced REMES language, with Priced Timed Automata semantics that allows us to apply UPPAAL -based tools for model-checking the system\u00a0\u2026", "num_citations": "4\n", "authors": ["312"]}
{"title": "Pattern-driven support for designing component-based architectural models\n", "abstract": " The development of embedded systems often requires the use of various models such as requirements specification, architectural (component-based), and deployment models, across different phases. However, there exists little design support for obtaining suitable component-based designs that satisfy specified requirements and timing constraints. In order to provide guided support for the design process of embedded systems, we introduce several component templates, referred as patterns, which we also formally verify against relevant properties. To illustrate the usefulness of the approach, we have applied the proposed patterns to obtain a component-based design of a temperature control system.", "num_citations": "4\n", "authors": ["312"]}
{"title": "A formal analysis framework for AADL\n", "abstract": " As system failure of mission-critical embedded systems may result in serious consequences, the development process should include verification techniques already at the architectural design stage, in order to provide evidence that the architecture fulfils its requirements. The Architecture Analysis and Design Language (AADL) is a language designed for modeling embedded systems, and its Behavior Annex defines the behavior of the system. However, even though it is an internationally used industry standard, AADL still lacks a formal semantics and is not executable, which limits the possibility to perform formal verification. In this paper, we introduce a formal analysis framework for a subset of AADL and its Behavior Annex, which includes the following: a denotational semantics, its implementation in Standard ML, and a graphical Eclipse-based tool encapsulating the implementation. We also show how to perform model checking of AADL properties defined in the Computation Tree Logic (CTL).", "num_citations": "4\n", "authors": ["312"]}
{"title": "Formal methods applied in industry-on the commercialisation of the uppaal tool\n", "abstract": " UPPAAL is a model-checking tool primarily aimed for real-time and embedded systems in which timing plays an important role. It has existed for over 16 years and has become very popular among formal method scientists in academia. In recent years, licenses of the tool have also been offered and sold on commercial basis. In this paper, the characteristics of the tool, its domains of application, as well as some lessons learned from commercializing the tool are described.", "num_citations": "3\n", "authors": ["312"]}
{"title": "Prototyping hierarchically scheduled systems using task automata and times\n", "abstract": " In hierarchical scheduling, a system is organized into multiple levels of individually scheduled subsystems (hierarchical scheduling tree), which provides several benefits for developers including possibilities for parallel development of subsystems. In this paper, we study how the model of task automata and the Times tool can be applied to provide support for rapid and early prototyping of hierarchically scheduled embedded systems. As a main result, we show how a single node, in an arbitrary level in a hierarchical scheduling tree (scheduled with fixed-priority preemptive scheduling), can easily be analyzed in Times by replacing all interfering nodes with a small set of higher priority (dummy) tasks. We show with an algorithm how these dummy tasks are generated (including task-parameters such as period, offset etc.). Further, we generate executable source code, with the Times code-generator, that emulates the\u00a0\u2026", "num_citations": "3\n", "authors": ["312"]}
{"title": "UPPAAL2k\n", "abstract": " UPPAAL2k \u2014 Aalborg University's Research Portal Skip to main navigation Skip to search Skip to main content Aalborg University's Research Portal Logo Dansk English Home Profiles Projects Publications Activities Research Units Facilities Press / Media Prizes Datasets Impacts Search by keywords, name or affiliation UPPAAL2k Kim Guldstrand Larsen, P. Pettersson Department of Computer Science Research output: Contribution to journal \u203a Journal article \u203a Research \u203a peer-review Overview Original language English Journal Bulletin of the European Association for Theoretical Computer Science Volume No. 70 ISSN 0252-9742 Publication status Published - 1999 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Larsen, KG, & Pettersson, P. (1999). UPPAAL2k. Bulletin of the European Association for Theoretical Computer Science, No. 70. Larsen, Kim Guldstrand ; Pettersson, P. / UPPAAL2k. In: of . ; \u2026", "num_citations": "3\n", "authors": ["312"]}
{"title": "A tool for rapid manual translation\n", "abstract": " There have been several attempts to realize the idea of a fully automatic translation system for text translation to replace human translators. By contrast, little work has been put into building tools to aid human translators. This report describes the ideas behind such a tool. The tool is intended to aid human translators in achieving higher productivity and better quality, by presenting terminological information extracted from previous translations. The report documents the implementation and evaluation of a prototype. The prototype has been demonstrated to and used by professional translators with promising results.", "num_citations": "3\n", "authors": ["312"]}
{"title": "A comparative study of manual and automated testing in industrial embedded software\n", "abstract": " Automated test generation has been suggested as a way of creating tests at a lower cost. Nonetheless, it is not very well studied how such tests compare to manually written ones in terms of cost and effectiveness. This is particularly true for industrial control software, where strict requirements on both specification-based testing and code coverage typically are met with rigorous manual testing. To address this issue, we conducted a case study in which we compared manually and automatically created tests. We used recently developed real-world industrial programs written in the IEC 61131-3, a popular programming language for developing industrial control systems using programmable logic controllers. The results show that automatically generated tests achieve similar code coverage as manually created tests, but in a fraction of the time (an average improvement of roughly 90%). We also found that the use of an automated test generation tool does not result in better fault detection in terms of mutation score compared to manual testing. Specifically, manual tests more effectively detect logical, timer and negation type of faults, compared to automatically generated tests. The results underscore the need to further study how manual testing is performed in industrial practice and the extent to which automated test generation can be used in the development of reliable systems.", "num_citations": "2\n", "authors": ["312"]}
{"title": "Modeling and analysis of adaptive embedded systems using adaptive task automata\n", "abstract": " Most embedded systems need to continually function in unpredictable environments. One way to achieve high dependability is to make the system adaptive to changes, if possible, without sacrificing maintainability. To be able to reason about adaptivity, one needs a modeling and analysis framework suitable for adaptive systems. Recently, we have introduced Adaptive Task Automata, to meet this goal. In this paper, we overview the current functionality implemented in the Adaptive Task Automata framework (ATA), as well as some of the challenges encountered during the development. In the end, we enumerate possible future extensions of ATA.", "num_citations": "2\n", "authors": ["312"]}
{"title": "Towards the analysis and verification of east-adl models using uppaal port\n", "abstract": " A system\u2019s architecture influence on the functions and other properties of embedded systems makes its highlevel analysis and verification very desirable. EAST-ADL is an architecture description language dedicated to automotive embedded system design with focus on structural and functional modeling. The behavioral description is not integrated within the execution semantics, which makes it harder to transform, analyze, and verify EAST-ADL models. Model-based techniques help address this issue by enabling automated transformation between different design models, and providing means for simulation and verification. We present a verification tool, called ViTAL, which provides the possibility to express the functional EAST-ADL behavior as timed automata models, which have precise semantics and can be formally verified. The ViTAL tool enables the transformation of EAST-ADL functional models to the UPPAAL PORT tool for model checking. This method improves the verification of functional and timing requirements in EAST-ADL, and makes it possible to identify dependencies and potential conflicts between different vehicle functions before the actual AUTOSAR implementation.", "num_citations": "2\n", "authors": ["312"]}
{"title": "Analyzing resource-usage impact on component-based systems performance and reliability\n", "abstract": " An early prediction of resource utilization and its impact on system performance and reliability can reduce the overall system cost, by allowing early correction of detected problems, or changes in development plans with minimized overhead. Nowadays, researchers are using both academic and commercial models to predict such attributes, by measuring them at earliest stages of system development. In this paper, we give a short overview of existing prediction models for performance and reliability, targeting popular component-based frameworks. Next, we describe our own approach for tackling such predictions, through an illustration on a small example that deals with estimations of energy consumption.", "num_citations": "2\n", "authors": ["312"]}
{"title": "Remes: A resource model for embedded systems\n", "abstract": " In this paper, we introduce the model REMES for formal modeling and analysis of embedded resources such as storage, energy, communication, and computation. The model is a state-machine based behavioral language with support for hierarchical modeling, resource annotations, continuous time, and notions of explicit entry and exit points that make it suitable for component-based modeling of embedded systems.The analysis of REMES-based systems is centered around a weighted sum in which the variables represent the amounts of consumed resources. We describe a number of important resource related analysis problems, including feasibility, trade-off, and optimal resource-utilization analysis. To formalize these problems and provide a basis for rigorous analysis, we show how to analyze REMES models using the framework of priced timed automata and weighted CTL. To illustrate the approach, we describe a case study in which it has been applied to model and analyze resourceusage of a temperature control system.", "num_citations": "2\n", "authors": ["312"]}
{"title": "Online testing of real-time systems using uppaal\n", "abstract": " This chapter presents principles and techniques for modelbased black-box conformance testing of real-time systems using the Uppaal model-checking tool-suite. The basis for testing is given as a network of concurrent timed automata specified by the test engineer. Relativized input/output conformance serves as the notion of implementation correctness, essentially timed trace inclusion taking environment assumptions into account. Test cases can be generated offline and later executed, or they can be generated and executed online. For both approaches this chapter discusses how to specify test objectives, derive test sequences, apply these to the system under test, and assign a verdict.", "num_citations": "2\n", "authors": ["312"]}
{"title": "Guided synthesis of control programs for a batch plant using uppaal\n", "abstract": " In this paper we address the problem of scheduling and synthesizing distributed control programs for a batch production plant. We use a timed automata model of the batch plant and the verification tool Uppaal to solve the scheduling problem. In modeling the plant, we aim at a level of abstraction which is sufficiently accurate in order that synthesis of control programs from generated timed traces is possible. Consequently, the models quickly become too detailed and complicated for immediate automatic synthesis. In fact, only models of plants producing two batches can be analyzed directly! To overcome this problem, we present a general method allowing the user to guide the model-checker according to heuristically chosen strategies. The guidance is specified by augmenting the model with additional guidance variables and by decorating transitions with extra guards on these. Applying this method have made synthesis of control programs feasible for a plant producing as many as 60 batches. The synthesized control programs have been executed in a physical plant. Besides proving useful in validating the plant model and in finding some modeling errors, we view this final step as the ultimate litmus test of our methodology\u2019s ability to generate executable (and executing) code from basic plant models.", "num_citations": "2\n", "authors": ["312"]}
{"title": "A Denotational Semantics for the Architecture Analysis and Design Language (AADL)\n", "abstract": " As system failure of mission-critical embedded systems may result in serious consequences, the development process should include verification techniques in order to provide evidence that the architecture fulfils its requirements. The Architecture Analysis and Design Language (AADL) is an internationally used industry standard. However, it still lacks a formal semantics and is not executable, which limits the possibility to perform formal verification. In this paper, we present a formal denotational semantics that defines a subset of AADL and its Behavior Annex. We also show a method to perform model checking of properties defined in the Computational Tree Logic (CTL). We have validated the semantics by implementing a verification tool tailored for AADL models based on the formal denotational semantics. We provide evidence the our approach is valid by presenting a case study.", "num_citations": "2\n", "authors": ["312"]}
{"title": "AQAT: The Architecture Quality Assurance Tool for Critical Embedded Systems\n", "abstract": " Architectural engineering of embedded systems comprehensively affects both the development processes and the abilities of the systems. Verification of architectural engineering is consequently essential in the development of safety- and missioncritical embedded system to avoid costly and hazardous faults. In this paper, we present the Architecture Quality Assurance Tool (AQAT), an application program developed to provide a holistic, formal, and automatic verification process for architectural engineering of critical embedded systems. AQAT includes architectural model checking, model-based testing, and selective regression verification features to effectively and efficiently detect design faults, implementation faults, and faults created by maintenance modifications. Furthermore, the tool includes a feature that analyzes architectural dependencies, which in addition to providing essential information for impact\u00a0\u2026", "num_citations": "1\n", "authors": ["312"]}
{"title": "An analyzable model of automated service negotiation\n", "abstract": " Negotiation is a key aspect of Service-Oriented Systems, which is rarely supported by formal models and tools for analysis. Often, service negotiation proceeds with timing, cost and resource constraints, under which the users and providers exchange information on their respective goals, until reaching a consensus. Consequently, a mathematically driven technique to analyze various ways to achieve such goals is beneficial. In this paper, we propose an analyzable negotiation model between service clients and providers, in our recently introduced language REMES and its corresponding textual service composition language HDCL. The model can be viewed as a negotiation interface for different negotiation strategies and protocols, which iterates until an agreement is reached. We show how to analyze the negotiation model against timing, cost and utility constraints, by transforming it into the Timed Automata formal\u00a0\u2026", "num_citations": "1\n", "authors": ["312"]}
{"title": "Verification and controller synthesis for resource-constrained real-time systems: Case study of an autonomous truck\n", "abstract": " An embedded system is often subject to timing constraints, resource constraints, and it should operate properly no matter how its environment behaves. This paper proposes to use timed game automata to characterize the timed behaviors and the environment uncertainties, and use piece-wise constant integer functions to approximate the continuous resources in real-time embedded systems. Based on these formal models and techniques, we employ the realtime model checker UPPAAL to verify a system against a given functional and/or timing requirement. Furthermore, we employ the timed game solver UPPAAL-TIGA to check whether a given control objective can be enforced, and if so, we synthesize a controller for the system. We carry out a case study of this approach on a battery-powered autonomous truck. Experimental results indicate that the method is effective and computationally feasible.", "num_citations": "1\n", "authors": ["312"]}
{"title": "Project Avatar\u2014Developing a Distributed Mobile Phone Game\n", "abstract": " Team Avatar, as the members of Project Avatar have come to be known by, is a group of 4th year computer science students at Uppsala University that have been developing a distributed mobile phone game during the fall of 2005. In this paper we describe the general design and environment of the result of Project Avatar\u2014the game Three Crowns.", "num_citations": "1\n", "authors": ["312"]}
{"title": "Minimal dbm substraction\n", "abstract": " Minimal DBM substraction \u2014 Aalborg University's Research Portal Skip to main navigation Skip to search Skip to main content Aalborg University's Research Portal Logo Dansk English Home Profiles Projects Publications Activities Research Units Facilities Press / Media Prizes Datasets Impacts Search by keywords, name or affiliation Minimal DBM substraction Kim Guldstrand Larsen, Alexandre David, John H\u00e5kansson, Paul Pettersson Department of Computer Science Research output: Contribution to book/anthology/report/conference proceeding \u203a Article in proceeding \u203a Research Overview Original language English Title of host publication Proceedings of 16th Nordic Workshop on Programming Theory : Uppsala Technical Report Editors Paul Pettersson, Wang Yi Number of pages 5 Publication date 2004 Edition 2004-041 Pages 17-21 Publication status Published - 2004 Event Nordic Workshop on Programming /\u2026", "num_citations": "1\n", "authors": ["312"]}
{"title": "Dilemma: a tool for rapid manual translation\n", "abstract": " Dilemma is a tool built to aid human translators in achieving higher productivity and better quality, by presenting lexical information which is automatically extracted from previous translations. The design decisions have been based on analyses of the human translation process. We present the ideas behind the tool, and outline the functionality. The system described has been used by professional translators with good results.", "num_citations": "1\n", "authors": ["312"]}
{"title": "Dilemma-A Tool To Ensure Quality Of New Translations By Using Previous Ones\n", "abstract": " Dilemma is a tool built to aid human translators in achieving higher productivity and better quality, by presenting lexical information which is automatically extracted from previous translations. The design decisions have been based on analyses of the human translation process. We present the ideas behind the tool, and outline the functionality. The system described has been evaluated by professional translators with good results, and is now being developed further.", "num_citations": "1\n", "authors": ["312"]}