{"title": "Maintaining and evolving GUI-directed test scripts\n", "abstract": " Since manual black-box testing of GUI-based applications (GAPs) is tedious and laborious, test engineers create test scripts to automate the testing process. These test scripts interact with GAPs by performing actions on their GUI objects. An extra effort that test engineers put in writing test scripts is paid off when these scripts are run repeatedly. Unfortunately, releasing new versions of GAPs with modified GUIs breaks their corresponding test scripts thereby obliterating benefits of test automation. We offer a novel approach for maintaining and evolving test scripts so that they can test new versions of their respective GAPs. We built a tool to implement our approach, and we conducted a case study with forty five professional programmers and test engineers to evaluate this tool. The results show with strong statistical significance that users find more failures and report fewer false positives (p < 0.02) in test scripts with our\u00a0\u2026", "num_citations": "200\n", "authors": ["70"]}
{"title": "Automatically finding performance problems with feedback-directed learning software testing\n", "abstract": " A goal of performance testing is to find situations when applications unexpectedly exhibit worsened characteristics for certain combinations of input values. A fundamental question of performance testing is how to select a manageable subset of the input data faster to find performance problems in applications automatically. We offer a novel solution for finding performance problems in applications automatically using black-box software testing. Our solution is an adaptive, feedback-directed learning testing system that learns rules from execution traces of applications and then uses these rules to select test input data automatically for these applications to find more performance problems when compared with exploratory random testing. We have implemented our solution and applied it to a medium-size application at a major insurance company and to an open-source application. Performance problems were found\u00a0\u2026", "num_citations": "129\n", "authors": ["70"]}
{"title": "Test script transformation architecture\n", "abstract": " A test script transformation architecture helps generate accurate test scripts for evolving applications. Applications often have complex graphical user interfaces for which the permutations and combinations of GUI elements give rise to an enormous field of potential commands and command sequences to be tested. Furthermore, these applications change over time, rendering prior test scripts unworkable. The architecture facilitates the automatic generation of new test scripts to reliably test subsequent application versions, while greatly reducing the time, cost, and resource expenditures needed to arrive at new test scripts.", "num_citations": "102\n", "authors": ["70"]}
{"title": "Test script transformation analyzer with change guide engine\n", "abstract": " A script analyzer with change guide generates accurate test scripts for evolving applications. Applications often have complex graphical user interfaces for which the permutations and combinations of GUI elements give rise to an enormous field of potential commands and command sequences to be tested. Furthermore, these applications change over time, rendering prior test scripts unworkable. The script analyzer automatically generates new test scripts to reliably test subsequent application versions, while greatly reducing the time, cost, and resource expenditures needed to arrive at subsequent application versions.", "num_citations": "68\n", "authors": ["70"]}
{"title": "Adaptive fault diagnosis\n", "abstract": " According to an example, an adaptive fault diagnosis system may include a memory storing machine readable instructions to receive metrics and events from an enterprise system, and use a substitution graph to determine if a received metric or a received event belongs to a cluster that includes one or more correlated metrics and/or events grouped based on similarity. If the received metric or the received event belongs to the cluster, the memory may further store machine readable instructions to use a detection graph to determine if the received metric or the received event is identifiable to form a fault pattern by traversing a fault path of the detection graph. Further, the memory may further store machine readable instructions to diagnose a fault based on the traversal of the fault path of the detection graph. The system may include a processor to implement the machine readable instructions.", "num_citations": "65\n", "authors": ["70"]}
{"title": "Is data privacy always good for software testing?\n", "abstract": " Database-centric applications (DCAs) are common in enterprise computing, and they use nontrivial databases. Testing of DCAs is increasingly outsourced to test centers in order to achieve lower cost and higher quality. When releasing proprietary DCAs, its databases should also be made available to test engineers, so that they can test using real data. Testing with real data is important, since fake data lacks many of the intricate semantic connections among the original data elements. However, different data privacy laws prevent organizations from sharing these data with test centers because databases contain sensitive information. Currently, testing is performed with fake data that often leads to worse code coverage and fewer uncovered bugs, thereby reducing the quality of DCAs and obliterating benefits of test outsourcing. We show that a popular data anonymization algorithm called k-anonymity seriously\u00a0\u2026", "num_citations": "65\n", "authors": ["70"]}
{"title": "Creating GUI testing tools using accessibility technologies\n", "abstract": " Since manual black-box testing of GUI-based applications(GAPs) is tedious and laborious, and existing tools do not fully address different aspects of the testing process, test engineers create custom testing tools to automate the testing process. These tools interact with GAPs by performing actions on their GUI objects. An extra effort that test engineers put in writing test tools is paid off when these tools are run repeatedly on different GAPs. Unfortunately, creating custom GUI testing tools is a laborious and intellectually intensive process, during which test engineers use platform-specific libraries and techniques. As a result, these tools are expensive, difficult to maintain and evolve, and they often run only on specific platforms.We offer a universal approach for creating custom testing GUI tools. This approach is lightweight, portable, nonintrusive, universal, and cheap, and it combines a nonstandard use of accessibility\u00a0\u2026", "num_citations": "60\n", "authors": ["70"]}
{"title": "Developing cost-effective model-based techniques for GUI testing\n", "abstract": " Most of today's software users interact with the software through a graphical user interface (GUI). While GUIs have become ubiquitous, testing of GUIs has remained until recently, a neglected research area. Existing GUI testing techniques are extremely resource intensive primarily because GUIs have very large input spaces. This research proposes to advance the state-of-the-art in GUI testing by empirically studying GUI faults, interactions between GUI events, why certain event interactions lead to faults, and use the results of these studies to develop cost-effective model-based GUI testing techniques. The novel feature of this research will be a reduced model of the GUI's event-interaction space. The model will be derived automatically from the GUI; it will be used to automatically generate specialized GUI test cases that are effective at detecting GUI faults. The model will be extended to develop new test oracles, new\u00a0\u2026", "num_citations": "60\n", "authors": ["70"]}