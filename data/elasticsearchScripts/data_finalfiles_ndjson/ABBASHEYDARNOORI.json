{"title": "Microservices architecture enables devops: Migration to a cloud-native architecture\n", "abstract": " This article reports on experiences and lessons learned during incremental migration and architectural refactoring of a commercial mobile back end as a service to microservices architecture. It explains how the researchers adopted DevOps and how this facilitated a smooth migration.", "num_citations": "654\n", "authors": ["233"]}
{"title": "A fast vision system for middle size robots in robocup\n", "abstract": " A mobile robot should be able to analyze what it is seeing in real time rate and decide accordingly. Fast and reliable analysis of image data is one of the key points in soccer robot performance. In this paper we suggest a very fast method for object finding which uses the concept of perspective view. In our method, we introduce a set of jump points in perspective on which we search for objects. An object is estimated by a rectangle surrounding it. A vector based calculation is introduced to find the distance and angle of a robot from objects in the field. In addition we present a new color model which takes its components from different color models. The proposed method can detect all objects in each frame and their distance and angle in one scan on the jump points in that frame. This process takes about 1/50 of a second. Our vision system uses a commercially available frame grabber and is implemented only\u00a0\u2026", "num_citations": "65\n", "authors": ["233"]}
{"title": "Two studies of framework-usage templates extracted from dynamic traces\n", "abstract": " Object-oriented frameworks are widely used to develop new applications. They provide reusable concepts that are instantiated in application code through potentially complex implementation steps such as subclassing, implementing interfaces, and calling framework operations. Unfortunately, many modern frameworks are difficult to use because of their large and complex APIs and frequently incomplete user documentation. To cope with these problems, developers often use existing framework applications as a guide. However, locating concept implementations in those sample applications is typically challenging due to code tangling and scattering. To address this challenge, we introduce the notion of concept-implementation templates, which summarize the necessary concept-implementation steps and identify them in the sample application code, and a technique, named FUDA, to automatically extract such\u00a0\u2026", "num_citations": "28\n", "authors": ["233"]}
{"title": "Towards an automated deployment planner for composition of web services as software components\n", "abstract": " In this paper, we present our work-in-progress on developing an automated deployment planner for the composition of Web services as software components using the Reo coordination middleware in a distributed environment. Web services refer to accessing services over the Web. Reo is an exogenous coordination model for compositional construction of component connectors based on a calculus of mobile channels that has been developed at CWI (the Netherlands). Reo has a strong theoretical underpinning which makes it a good candidate model for coordinating the work of Web services participating in a composition. Suppose a new Web application has been developed by composing a number of Web services with different requirements and constraints. To run the application, it is required to deploy it on a number of hosts with different computational capabilities available to the application in the distributed\u00a0\u2026", "num_citations": "22\n", "authors": ["233"]}
{"title": "Visualizing and exploring profiles with calling context ring charts\n", "abstract": " Calling context profiling is an important technique for analyzing the performance of object\u2010oriented software with complex inter\u2010procedural control flow. The Calling Context Tree (CCT) is a common data structure that stores dynamic metrics, such as CPU time, separately for each calling context. As CCTs may comprise millions of nodes, there is a need for a condensed visualization that eases the localization of performance bottlenecks. In this article, we discuss Calling Context Ring Charts (CCRCs), a compact visualization for CCTs, where callee methods are represented in ring segments surrounding the caller's ring segment. In order to reveal hot methods, their callers, and callees, the ring segments can be sized according to a chosen dynamic metric. We describe two case studies where CCRCs help us to detect and fix performance problems in applications. A performance evaluation also confirms that our\u00a0\u2026", "num_citations": "21\n", "authors": ["233"]}
{"title": "Cross-project code clones in GitHub\n", "abstract": " Code reuse has well-known benefits on code quality, coding efficiency, and maintenance. Open Source Software (OSS) programmers gladly share their own code and they happily reuse others\u2019. Social programming platforms like GitHub have normalized code foraging via their common platforms, enabling code search and reuse across different projects. Removing project borders may facilitate more efficient code foraging, and consequently faster programming. But looking for code across projects takes longer and, once found, may be more challenging to tailor to one\u2019s needs. Learning how much code reuse goes on across projects, and identifying emerging patterns in past cross-project search behavior may help future foraging efforts. Our contribution is two fold. First, to understand cross-project code reuse, here we present an in-depth empirical study of cloning in GitHub. Using Deckard, a popular clone\u00a0\u2026", "num_citations": "14\n", "authors": ["233"]}
{"title": "Crowdsummarizer: Automated generation of code summaries for java programs through crowdsourcing\n", "abstract": " To perform software maintenance, developers must have a relatively good understanding of the program's source code, which is often written by other developers. Code summaries, which describe a program's entities (for example, its methods), help developers better comprehend code more quickly. However, generating code summaries can be challenging. To mitigate this problem, CrowdSummarizer exploits crowdsourcing, gamification, and natural-language processing to automatically generate high-level summaries of Java program methods. Researchers have implemented it as an Eclipse plug-in together with a Web-based code summarization game that can be played by the crowd. Two empirical studies determined that CrowdSummarizer generates quality results. This article is part of a special issue on Crowdsourcing for Software Engineering.", "num_citations": "14\n", "authors": ["233"]}
{"title": "Reliable deployment of component-based applications into distributed environments\n", "abstract": " Software deployment process is a sequence of related activities for installing an already developed application into its target environment, and bringing it into an executing state. For complex component-based applications that should be deployed into a large distributed environment, several deployment configurations are typically possible. These deployment configurations can have significant impacts on the application's quality of service properties such as reliability. In distributed systems, the reliability of the application is highly dependent on the reliability of its network, and network failures can have adverse effects on the application's reliability. Thus, one possible way to increase the reliability of a distributed component-based application is to deploy it so that the communications among its components are done as local as possible. In this paper, a graph-based deployment planning approach is proposed for this\u00a0\u2026", "num_citations": "14\n", "authors": ["233"]}
{"title": "Robocup-2001: The fifth robotic soccer world championships\n", "abstract": " RoboCup-2001 was the Fifth International RoboCup Competition and Conference. It was held for the first time in the United States, following RoboCup-2000 in Melbourne, Australia; RoboCup-99 in Stockholm; RoboCup-98 in Paris; and RoboCup-97 in Osaka. This article discusses in detail each one of the events at RoboCup-2001, focusing on the competition leagues.", "num_citations": "14\n", "authors": ["233"]}
{"title": "A Graph-based Approach for Deploying Component-based Applications into Channel-based Distributed Environments.\n", "abstract": " With significant advances in software development technologies, it is now possible to have complex software applications, which include a large number of heterogeneous software components distributed over a large network of computers with different computational capabilities. To run such applications, their components must be instantiated on proper hardware resources in their target environments so that user requirements and constraints are also met. This process is called software deployment. However, this process is often challenging for large, distributed, component-based applications with many constraints and requirements. This article presents a graph-based deployment approach that does the deployment with respect to the communication resources required by application components and communication resources available on the hosts in the target environment. In our approach, component-based applications and distributed environments are modeled with the help of graphs. Deployment of an application is then defined as the mapping of the application graph to the target environment graph. This article further discusses how this mapping could be done to minimize the cost and to maximize the reliability of deployments.", "num_citations": "13\n", "authors": ["233"]}
{"title": "Deploying component\u2013based applications: Tools and techniques\n", "abstract": " Software deployment comprises activities for placing an already developed application into its operational environment and making it ready for use. For complex component-based applications that constitute many heterogeneous components with various hardware and software requirements, this deployment process can become one of the most burning challenges. In this situation, it is difficult to manually identify a valid deployment configuration that satisfies all constraints. Thus, automated tools and techniques are required to do the complex process of software deployment. To address this requirement, a variety of tools and techniques that support different activities of the deployment process have been introduced in both industry and academia. This paper aims to provide an overview of these tools and techniques.", "num_citations": "13\n", "authors": ["233"]}
{"title": "Coaching a soccer simulation team in RoboCup environment\n", "abstract": " Constructing soccer robots is an attempt in development of AI researches, done by defining a standard problem and solving it by many researchers all over the world. In this field, every year a formal federation holds international competitions, called RoboCup [1]. The Simulation League is one of the branches of the RoboCup.               We have designed and implemented an online coach for a soccer simulation team, which is able to analyze the simulated match similar to a coach in a real football match, and sends commands to the players to improve their behaviors and get a better result from the match process. This coach is able to exchange the roles between players during the match. Also, it has the capability of recognizing the opponent formation and improving the playing style of the team. This coach got the 1st place of Seattle\u20192001 RoboCup world championship in the field of online coaches.", "num_citations": "12\n", "authors": ["233"]}
{"title": "ExceptionTracer: A solution recommender for exceptions in an integrated development environment\n", "abstract": " Exceptions are an indispensable part of the software development process. However, developers usually rely on imprecise results from a web search to resolve exceptions. More specifically, they should personally take into account the context of an exception, then, choose and adapt a relevant solution to solve the problem. In this paper, we present Exception Tracer, an Eclipse plug in that helps developers to resolve exceptions with respect to the stack trace in Java programs. In particular, Exception Tracer automatically provides candidate solutions to an exception by mining software systems in the Source Forge, as well as listing relevant discussions about the problem from the Stack Overflow.", "num_citations": "11\n", "authors": ["233"]}
{"title": "EXAF: A search engine for sample applications of object-oriented framework-provided concepts\n", "abstract": " Context: Object-oriented application frameworks, such as Java Swing, provide reusable code and design for implementing domain-specific concepts, such as Context Menu, in software applications. Hence, use of such frameworks not only can decrease the time and the cost of developing new software applications, but also can increase their maintainability. However, the main problems of using object-oriented application frameworks are their large and complex APIs, and often incomplete user manuals. To mitigate these problems, developers often try to learn how to implement their desired concepts from available sample applications. Nonetheless, this introduces another hard and time-consuming challenge which is finding proper sample applications.Objective: To address this difficulty, we introduce EXAF (EXample Applications Finder) that helps developers find sample applications which implement their desired\u00a0\u2026", "num_citations": "8\n", "authors": ["233"]}
{"title": "Exception fault localization in android applications\n", "abstract": " In software programs, most of the time, there is a chance of error, even though they are tested carefully. Finding error-related pieces of code is one of the most complicated tasks and it can make incorrect results if done manually. Semi-automated and fully-automated methods have been introduced to overcome this issue. The rapid growth of developing Smart Mobile Applications (SMAs) in recent years, competition among the development teams and many other factors have increased the chance of errors, and hence, the quality of these applications have reduced. There are two approaches to test SMAs in order to reach a high degree of quality: (i) using existing traditional methods and adapting them to SMA environments and (ii) introducing new special methods for SMAs. In this paper, we introduce a semi-automated hybrid method to localize exception errors in Android applications. The proposed approach\u00a0\u2026", "num_citations": "7\n", "authors": ["233"]}
{"title": "Deferred methods: accelerating dynamic program analysis on multicores\n", "abstract": " Parallelization is attractive for speeding up dynamic program analysis on multicores. However, inter-thread communication overhead may outweigh any benefit from parallel execution. We propose deferred methods, a high-level Java framework to accelerate dynamic analysis on multicores. To minimize inter-thread communication overhead, invocations to analysis methods are automatically aggregated in thread-local buffers that are processed when full. In contrast to other approaches, our framework supports custom buffer processing strategies, eases pre-processing of buffers to reduce contention on shared data structures, and offers a synchronization mechanism to wait for the completion of previously invoked deferred methods. We also present a novel adaptive buffer processing strategy that parallelizes the analysis only when the observed workload leaves some CPU cores under-utilized. Using a profiler as\u00a0\u2026", "num_citations": "7\n", "authors": ["233"]}
{"title": "Improving the quality of code snippets in stack overflow\n", "abstract": " Question and answer (Q&A) websites like Stack Overflow are one of the important sources of code examples in which developers can ask their questions and leave their answers about programming issues. Since the number of programmers who use these websites are increasing and a large number of questions and answers are being posted there by them, verifying the quality of all the answers and particularly the code snippets in them is impossible. Consequently, some code snippets might be of low quality and/or with faults. To mitigate this issue, we introduce ExRec (Ex ampleRec ommender), an Eclipse plugin with which programmers can contribute in improving the quality of code snippets in the answers to questions in the Stack Overow website. Using ExRec, a programmer can transfer a code snippet in the answer to a desired question in Stack Overow to her own program, apply her desired modifications to\u00a0\u2026", "num_citations": "6\n", "authors": ["233"]}
{"title": "Towards a Tactic-Based Evaluation of Self-Adaptive Software Architecture Availability.\n", "abstract": " nowadays, several non-automatic or semi-automatic software architecture evaluation methods have been proposed to evaluate their quality attributes as availability. In spite of their applicability, they are not effective in self-adaptive software architectures due to their off-line properties; eg, scenario-based methods. Since the architectural tactics provide a bridge between architectural designs and quality attributes, they have sufficient potential to resolve this problem. In this paper, we assume that the software architecture is completely composed of some architectural patterns. Then we propose an automated evaluation method which composes the architectural tactics and the patterns to measure the availability of software architectures. In this method, the composition of a few availability tactics and patterns are simulated with appropriate probability distribution functions. To predict the availability of patterns, a data mining approach is applied to these simulated models to generate training models for each combination of tactics and patterns. Furthermore, a utility function is defined to compute the availability of systems by these models in O (n) where n is the number of patterns of systems. This method improves the data gathering and analysis activities of the SASSY (Self-Architecting Software SYstems) framework. To validate our method, we have applied it to the Rapidminer case study.", "num_citations": "6\n", "authors": ["233"]}
{"title": "Deploying loosely coupled, component-based applications into distributed environments\n", "abstract": " With significant advances in software development technologies in recent years, it is now possible to have complex software applications, which include a large number of heterogeneous software components distributed over a large network of computers with different computational capabilities. To run such applications, their components must be instantiated on proper hardware resources in their target environments so that some requirements and constraints are met. This process is called software deployment. For large, distributed, component-based applications with many constraints and requirements, it is difficult to do the deployment process manually, and some automated tools and techniques are required. This paper presents a graph-based approach for this purpose that is not dependent on any specific component technology and does the deployment planning with respect to the communication resources\u00a0\u2026", "num_citations": "4\n", "authors": ["233"]}
{"title": "Generating summaries for methods of event-driven programs: An Android case study\n", "abstract": " The lack of proper documentation makes program comprehension a cumbersome process for developers. Source code summarization is one of the existing solutions to this problem. Many approaches have been proposed to summarize source code in recent years. A prevalent weakness of these solutions is that they do not pay much attention to interactions among elements of software. An element is simply a callable code snippet such as a method or even a clickable button. As a result, these approaches cannot be applied to event-driven programs, such as Android applications, because they have specific features such as numerous interactions between their elements. To tackle this problem, we propose a novel approach based on deep neural networks and dynamic call graphs to generate summaries for methods of event-driven programs. First, we collect a set of comment/code pairs from Github and train a deep\u00a0\u2026", "num_citations": "3\n", "authors": ["233"]}
{"title": "A safe stopping protocol to enable reliable reconfiguration for component-based distributed systems\n", "abstract": " Despite the need for change, highly available software systems cannot be stopped to perform changes because disruption in their services may consequent irrecoverable losses. Current work on runtime evolution are either too disruptive, e.g., \u201cblackouts\u201d in unnecessary components in the quiescence criterion approach or presume restrictive assumptions such as the \u201cblack-box design\u201d in the tranquility approach. In this paper, an architecture-based approach, called SAFER, is proposed which provides a better timeliness by relaxing any precondition required to start reconfiguration. We demonstrate the validity of the SAFER through model checking and a realization of the approach on a component model.", "num_citations": "3\n", "authors": ["233"]}
{"title": "Partial scalability to ensure reliable dynamic reconfiguration\n", "abstract": " In order to be adapted to changes in user requirements and/or the environment, many software systems need to run continuously while they evolve. Most current approaches for such dynamic reconfiguration assume that the evolved system will behave as expected and thus will be reliable if the reconfiguration is consistent. This assumption may not correspond to reality because the delivered quality estimated previously could vary due to parameter changes at runtime. To ensure that the system acts correctly in the field after the reconfiguration, reliability of changes has to be checked at runtime. Existing approaches, however, are not applicable in highly available systems due to the possibility of imposing disruption to their running services. This paper aims to address this problem via improving the reliability of dynamic reconfiguration of component-based systems. To achieve this goal, our approach ensures\u00a0\u2026", "num_citations": "3\n", "authors": ["233"]}
{"title": "Using the opponent pass modeling method to improve defending ability of a (robo) soccer simulation team\n", "abstract": " Modeling agents\u2019 behavior has always been a challenge in multiagent systems. In a competitive environment, predicting future behaviors of opponents helps to make plans to confront their actions properly. We have used the RoboCup soccer server environment [1] to design a coach, capable of analyzing simulated soccer games and making decisions to improve teammate players\u2019 behavior during the games. We will introduce our \u201cOpponent Pass Modeling\u201d method which makes a model of opponent team\u2019s passing behavior to guard opponent players and as a result, to improve the defending behavior of our team. We will also describe a new approach to evaluate coach algorithms using soccer server log-files and LogCoach tool.", "num_citations": "3\n", "authors": ["233"]}
{"title": "Towards a visualized code recommendation for APIs enriched with specification mining\n", "abstract": " This paper positions an idea for an interactive code recommendation system. In this work, candidate recommendations are abstracted as a graph-based visualization of the API usages that are decorated with the API specifications and the usage rules mined from the unit test cases of the given API and its usage examples. The user can then progressively explore this graph to obtain her desired code without delving into the implementation details.", "num_citations": "2\n", "authors": ["233"]}
{"title": "Tool demonstration: effective runtime exploration of the inter-procedural control flow in Java applications\n", "abstract": " Statically exploring the inter-procedural control flow of object-oriented applications is often difficult because of the use of abstraction, polymorphism, and dynamic binding. To ease this problem, in this tool demonstration, we present a new profiler that dynamically explores the inter-procedural control flow of Java applications while they are executing. Our profiler visualizes the complete Calling Context Tree (CCT) with various dynamic metrics, such as method invocations, executed bytecodes, or allocated objects, and enables efficient navigation in large CCTs comprising up to several millions of nodes. We show that our tool can render data quite fast with response times in the range of 14--204ms upon user interactions. Thanks to a carefully tuned incremental data representation, the profiling data produced by a running application can be updated several times per second on a standard laptop. The visualization can\u00a0\u2026", "num_citations": "2\n", "authors": ["233"]}
{"title": "Mining implementation recipes of framework-provided concepts in dynamic framework API interaction traces\n", "abstract": " Application developers often apply the Monkey See/Monkey Do rule for framework-based application development, ie, they use existing applications as a guide to understand how to implement a desired framework-provided concept (eg, a context menu in an Eclipse view). However, the code that implements the concept of interest might be scattered across and tangled with code implementing other concepts. To address this issue, we introduce a novel framework comprehension technique called FUDA (F rameworkAPIU nderstandingthroughD ynamicA nalysis). The main idea of this technique is to extract the implementation recipes of a given framework-provided concept from dynamic traces with the help of a dynamic slicing approach integrated with clustering and data mining techniques. In this demonstration, we present the prototype implementation of FUDA as two Eclipse plug-ins, and use them to generate the\u00a0\u2026", "num_citations": "2\n", "authors": ["233"]}
{"title": "Caspian: A QoS-aware deployment approach for channel-based component-based applications\n", "abstract": " With significant advances in software development technologies in recent years, it is now possible to have complex software applications that include a large number of heterogeneous software components distributed over a large network of computers with different computational capabilities. To run such applications, their components must be instantiated on proper hardware resources in their target environments so that requirements and constraints are met. This process is called software deployment. For large, distributed, component-based applications with many constraints and requirements, it is difficult to do the deployment process manually and automated tools and techniques are required. This report presents a graph-based approach for this purpose that is not dependent on any specific component technology and does the deployment planning with respect to the communication resources, ie channels, required by application components and communication resources available on the hosts in the target environment. In our approach, component-based applications and distributed environments are modeled with the help of graphs. Deployment of an application is then defined as the mapping of the application graph to the target environment graph.", "num_citations": "2\n", "authors": ["233"]}
{"title": "Topic recommendation for software repositories using multi-label classification algorithms\n", "abstract": " Many platforms exploit collaborative tagging to provide their users with faster and more accurate results while searching or navigating. Tags can communicate different concepts such as the main features, technologies, functionality, and the goal of a software repository. Recently, GitHub has enabled users to annotate repositories with topic tags. It has also provided a set of featured topics, and their possible aliases, carefully curated with the help of the community. This creates the opportunity to use this initial seed of topics to automatically annotate all remaining repositories, by training models that recommend high-quality topic tags to developers. In this work, we study the application of multi-label classification techniques to predict software repositories\u2019 topics. First, we map the large-space of user-defined topics to those featured by GitHub. The core idea is to derive more information from projects\u2019 available\u00a0\u2026", "num_citations": "1\n", "authors": ["233"]}
{"title": "An Analysis of Python's Topics, Trends, and Technologies Through Mining Stack Overflow Discussions\n", "abstract": " Python is a popular, widely used, and general-purpose programming language. In spite of its ever-growing community, researchers have not performed much analysis on Python's topics, trends, and technologies which provides insights for developers about Python community trends and main issues. In this article, we examine the main topics related to this language being discussed by developers on one of the most popular Q\\&A websites, Stack Overflow, as well as temporal trends through mining 2461876 posts. To be more useful for the software engineers, we study what Python provides as the alternative to popular technologies offered by common programming languages like Java. Our results indicate that discussions about Python standard features, web programming, and scientific programming. Programming in areas such as mathematics, data science, statistics, machine learning, natural language processing (NLP), and so forth. are the most popular areas in the Python community. At the same time, areas related to scientific programming are steadily receiving more attention from the Python developers.", "num_citations": "1\n", "authors": ["233"]}