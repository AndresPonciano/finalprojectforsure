{"title": "Robotml, a domain-specific language to design, simulate and deploy robotic applications\n", "abstract": " A large number of robotic software have been developed but cannot or can hardly interoperate with each other because of their dependencies on specific hardware or software platform is hard-wired into the code. Consequently, robotic software is hard and expensive to develop because there is little opportunity of reuse and because low-level details must be taken into account in early phases. Moreover, robotic experts can hardly develop their application without programming knowledge or the help of programming experts and robotic software is difficult to adapt to hardware or target-platform changes. In this paper we report on the development of RobotML, a Robotic Modeling Language that eases the design of robotic applications, their simulation and their deployment to multiple target execution platforms.", "num_citations": "167\n", "authors": ["1528"]}
{"title": "Feature identification from the source code of product variants\n", "abstract": " In order to migrate software products which are deemed similar into a product line, it is essential to identify the common features and the variations between the product variants. This can however be tedious and error-prone as it may involve browsing complex software and a lot of more or less similar variants. Fortunately, if arte facts of the product variants (source code files and/or models) are available, feature identification can be at least partially automated. In this paper, we thus propose a three-step approach to feature identification from source code of which the first two steps are automated.", "num_citations": "111\n", "authors": ["1528"]}
{"title": "A fully dynamic approach to the reverse engineering of UML sequence diagrams\n", "abstract": " The reverse engineering of behavioral models consists in extracting high-level models that help understand the behavior of existing software systems. In the context of reverse engineering of sequence diagrams, most approaches strongly depend on the static analysis and instrumentation of the source code to produce correct diagrams that take into account control flow structures such as alternative blocks (\"if\"s) and repeated blocks (\"loop\"s). This approach is not possible with systems for which no source code is available anymore (e.g. some legacy systems). In this paper, we propose an approach for the reverse engineering of sequence diagrams from the analysis of execution traces produced dynamically by an object-oriented application. Our approach is fully based on dynamic analysis and reuses the k-tail merging algorithm to produce a Labeled Transition System (LTS) that merges the collected traces. This\u00a0\u2026", "num_citations": "69\n", "authors": ["1528"]}
{"title": "ESPLA: A catalog of Extractive SPL Adoption case studies\n", "abstract": " Building Software Product Lines (SPLs) from existing artefacts is known as the extractive approach for SPL adoption. The traditional case is that variants are created with ad-hoc reuse (eg, copy-paste-modify to quickly respond to different customer needs) and practitioners want to reengineer them to an SPL. Several industrial cases have been presented in the literature to motivate the interest of the extraction and many case studies are used to validate methods and techniques for different activities during this adoption process.", "num_citations": "61\n", "authors": ["1528"]}
{"title": "Manipulation de Lignes de Produits en UML\n", "abstract": " Une ligne de produits (LdP) regroupe un ensemble de logiciels appartenant \u00e0 un m\u00eame domaine et qui prend en compte des facteurs de variation. Cette th\u00e8se se situe dans le contexte de la manipulation de lignes de produits en UML et s' articule autour de trois contributions. Nous \u00e9tendons UML pour permettre la sp\u00e9cification de la variabilit\u00e9 dans les diagrammes de classes et dans les diagrammes de s\u00e9quence d'UML. Nous identifions deux types de contraintes dans les LdP et nous proposons de les sp\u00e9cifier comme des contraintes OCL. Nous formalisons la d\u00e9rivation de produits en utilisant la transformation de mod\u00e8les. Pour r\u00e9aliser la d\u00e9rivation de comportements, nous avons \u00e9tudi\u00e9 la probl\u00e9matique de la synth\u00e8se automatique de machines \u00e0 \u00e9tats \u00e0 partir des sc\u00e9narios. Nous proposons de revisiter le probl\u00e8me de la synth\u00e8se dans le contexte d'UML2. 0 par une approche alg\u00e9brique.", "num_citations": "50\n", "authors": ["1528"]}
{"title": "DSLFORGE: Textual Modeling on the Web.\n", "abstract": " The use of Model-Driven Engineering in software development is increasingly growing in industrial applications as the technologies are becoming more mature. In particular, domain-specific languages bring to end-users simplicity of use and productivity by means of various artifacts generators. However, end-users still need to cope with heavy modeling infrastructures and complex deployment procedures, before being able to work on models. In this paper, we propose a centralized lightweight approach for performing textual modeling through web browsers. DSLFORGE is a generator of online text editors. Given a language grammar, the tool allows to generate lightweight web editors, supporting syntax highlighting, syntax validation, scoping, and code completion. DSLFORGE allows also automatic integration of existing code generators into the generated web editor providing a complete online modeling user experience.", "num_citations": "12\n", "authors": ["1528"]}
{"title": "Software product line extraction from variability-rich systems: the robocode case study\n", "abstract": " The engineering of a Software Product Line (SPL), either by creating it from scratch or through the re-engineering of existing variants, it uses to be a project that spans several years with a high investment. It is often hard to analyse and quantify this investment, especially in the context of extractive SPL adoption when the related software variants are independently created by different developers following different system architectures and implementation conventions. This paper reports an experience on the creation of an SPL by re-engineering system variants implemented around an educational game called Robocode. The objective of this game is to program a bot (a battle tank) that battles against the bots of other developers. The world-wide Robocode community creates and maintains a large base of knowledge and implementations that are mainly organized in terms of features, although not presented as an\u00a0\u2026", "num_citations": "11\n", "authors": ["1528"]}
{"title": "CARE: a platform for reliable Comparison and Analysis of Reverse-Engineering techniques\n", "abstract": " Reverse engineering of behavior models has received a lot of attention over the last few years. However, no standard benchmark exists for the comparison and analysis of published miners. Evaluation is usually performed on few case studies, which fails to demonstrate effectiveness in a broad context. This paper proposes a general, approach-independent, platform for the intensive evaluation of behavior miners. Its goals are essentially: provide a benchmark mechanism for reverse engineering; allow analysis of miners w.r.t. a class of programs and/or behaviors; help users in choosing the best suited approach for their objective.", "num_citations": "8\n", "authors": ["1528"]}
{"title": "Software product line extraction from bytecode based applications\n", "abstract": " This paper presents a Software Product Line (SPL) extraction approach to handle legacy software systems running on the Java Virtual Machine (JVM), for which the source code is unavailable, and factor in all input programming languages for the JVM. The approach extracts from the bytecode of a collection of software variants created using the Clone-And-Own approach a full SPL with its feature model. We provide a full implementation and integration in the BUT4Reuse framework. An early experiment was carried out on the ArgoUML case study and preliminary results are discussed.", "num_citations": "6\n", "authors": ["1528"]}
{"title": "Utilizing automatic query reformulations as genetic operations to improve feature location in software models\n", "abstract": " In the combination of Model-Driven Engineering (MDE) and Search-Based Software Engineering (SBSE), genetic operations are one of the key ingredients. Our work proposes a novel adaptation of automatic query reformulations as genetic operations that leverage the latent semantics of software models (the cornerstone artefact of MDE). We analyze the impact of these reformulation operations in a real-world industrial case study of feature location in models. As baselines, we use: 1) the widespread single-point crossover plus random mutation; and 2) mask crossover plus random mutation, which is the best performer for feature location in models. We also perform a statistical analysis to provide quantitative evidence of the impact of the results and to show that this impact is significant. Our reformulation operations improve the results of the best baseline by 37.73% in recall and 14.08% in precision. These results\u00a0\u2026", "num_citations": "5\n", "authors": ["1528"]}
{"title": "Meduse: An approach for tailoring software development process\n", "abstract": " Software processes, as software products, are variable across projects and thus a one-size-fits-all approach does not work out for development processes. We propose Meduse, an approach for tailoring development processes according to project needs. Such an approach, which is based on software product line and method engineering techniques, takes into account processes similarities (i.e. commonalities) and differences (i.e. variabilities), as well as reusable process fragments. Having processes tailored on demand according to the project needs shall reduce project risks, rise best practices adoption by the development team, support project planning and budget managing, among other benefits.", "num_citations": "4\n", "authors": ["1528"]}
{"title": "Exact and efficient temporal steering of software behavioral model inference\n", "abstract": " Behavior Model Inference techniques aim at mining behavior models from execution traces. While most of approaches usually ground on local similarities in traces, recent work, referred to as behavior mining with temporal steering, propose to include long term dependencies in the mining process. Such dependencies correspond to temporal implications between events in execution traces, whose consideration allows to ensure a better consistency of the extracted model. Nevertheless, the existing approaches are usually limited by their high computational complexity and the approximations to reduce the cost of temporal rules checking. This paper revisits behavior mining with temporal steering by defining an efficient algorithm that performs an exact consideration of the observed dependencies: in our experiments, greatly reduced processing times (from exponential to quasi-linear) for exact mining with temporal\u00a0\u2026", "num_citations": "4\n", "authors": ["1528"]}
{"title": "REVAMP: Challenges and innovation roadmap for variability management in round-trip engineering of software-intensive systems\n", "abstract": " The Software Intensive Systems (SIS) has become dominant in industry. The Product Lines (PL) approach offers significant cost reductions in customization and rapid development of products targeting various market segments. However, Product Lines Engineering often times requires a complex modeling and coevolution of multiple assets. That hinders the proliferation of the PL approach and constrains its accessibility for SMEs and larger community of system developers. The ITEA 3 project REVaMP\u00b2 aims to conceive, develop and evaluate the first comprehensive automation tool-chain and associated executable process to support round-trip engineering of SIS Product Lines and thereby helping to profitably engineer mass customized products and services.", "num_citations": "3\n", "authors": ["1528"]}
{"title": "The CARE platform for the analysis of behavior model inference techniques\n", "abstract": " ContextFinite State Machine (FSM) inference from execution traces has received a lot of attention over the past few years. Various approaches have been explored, each holding different properties for the resulting models, but the lack of standard benchmarks limits the ability of comparing the proposed techniques. Evaluation is usually performed on a few case studies, which is useful for assessing the feasibility of the algorithm on particular cases, but fails to demonstrate effectiveness in a broad context. Consequently, understanding the strengths and weaknesses of inference techniques remains a challenging task.ObjectiveThis paper proposes CARE, a general, approach-independent, platform for the intensive evaluation of FSM inference techniques.MethodGrounded in a program specification scheme that provides a good control on the expected program structures, it allows the production of large benchmarks\u00a0\u2026", "num_citations": "3\n", "authors": ["1528"]}
{"title": "Towards analysing feature locations through testing traces with {BUT4R} euse\n", "abstract": " Towards analysing feature locations through testing traces with {BUT4R}euse - Archive ouverte HAL Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01215893, version 1 Communication dans un congr\u00e8s Towards analysing feature locations through testing traces with {BUT4R}euse Jabier Martinez 1 Jan Malburg Tewfik Ziadi 1 G\u00f6rschwin Fey D\u00e9tails 1 MoVe - Mod\u00e9lisation et V\u00e9rification LIP6 - Laboratoire d'Informatique de Paris 6 Type de document : Communication dans un congr\u00e8s Domaine : \u2026", "num_citations": "3\n", "authors": ["1528"]}
{"title": "A top-down approach to managing variability in robotics algorithms\n", "abstract": " One of the defining features of the field of robotics is its breadth and heterogeneity. Unfortunately, despite the availability of several robotics middleware services, robotics software still fails to smoothly handle at least two kinds of variability: algorithmic variability and lower-level variability. The consequence is that implementations of algorithms are hard to understand and impacted by changes to lower-level details such as the choice or configuration of sensors or actuators. Moreover, when several algorithms or algorithmic variants are available it is difficult to compare and combine them. In order to alleviate these problems we propose a top-down approach to express and implement robotics algorithms and families of algorithms so that they are both less dependent on lower-level details and easier to understand and combine. This approach goes top-down from the algorithms and shields them from lower-level details by introducing very high level abstractions atop the intermediate abstractions of robotics middleware. This approach is illustrated on 7 variants of the Bug family that were implemented using both laser and infra-red sensors.", "num_citations": "3\n", "authors": ["1528"]}
{"title": "A multi-view model-driven approach for packaging software components\n", "abstract": " Tool support in chemical process modeling evolved towards using more complex and more integrated systems, often made by combining smaller sub-systems, coming from different vendors. The increasingly growing heterogeneity of these systems led to the emergence of interoperability standards such as CAPE-OPEN. However, the component-based architecture imposed by this standard made the development and maintenance of process modelling components more complex. Indeed, it requires accurate knowledge about three interconnected domains: the process itself, the standard specification, and the middleware (eg COM or .NET). Consequently, both development and maintenance tasks require the collaboration of several experts throughout the entire component lifecycle. Tools that assist experts in performing these tasks are thus required. This paper presents an iterative model-driven approach that\u00a0\u2026", "num_citations": "3\n", "authors": ["1528"]}
{"title": "Towards a mas product line engineering approach\n", "abstract": " It is our claim that the adoption of software engineering reuse techniques can leverage MAS development, mostly when we consider similar applications belonging to the same domain. MAS-Product Line (MAS-PL) raises as an interesting approach that uses Software Product Line Engineering (SPLE) techniques and AOSE to manage the commonalities (similarities) and variabilities (differences) of such MAS applications. Although MAS present specific characteristics that could be considered when describing the system variability, existing work on MAS-PL is devoted to deal with MAS variability considering only domain-specific issues. Moreover, the adoption of variability models such as feature models should be considered for describing both Generic and Specific MAS variability. We propose a MAS-PL approach to address the aforementioned issues by representing Generic MAS variability according to\u00a0\u2026", "num_citations": "2\n", "authors": ["1528"]}
{"title": "Expanding the Number of Reviewers in Open-Source Projects by Recommending Appropriate Developers\n", "abstract": " Code review is an important part of the development of any software project. Recently, many open source projects have begun practicing lightweight and tool-based code review (a.k.a modern code review) to make the process simpler and more efficient. However, those practices still require reviewers, of which there may not be sufficiently many to ensure timely decisions. In this paper, we propose a recommender-based approach to be used by open-source projects to increase the number of reviewers from among the appropriate developers. We first motivate our approach by an exploratory study of nine projects hosted on GitHub and Gerrit. Secondly, we build the recommender system itself, which, given a code change, initially searches for relevant reviewers based on similarities between the reviewing history and the files affected by the change, and then augments this set with developers who have a similar\u00a0\u2026", "num_citations": "1\n", "authors": ["1528"]}
{"title": "Understanding Source Code Variability in Cloned Android Families: an Empirical Study on 75 Families\n", "abstract": " Software developers rely on the clone-and-own approach to rapidly develop software product variants (PVs) that meet variability in market needs. To improve the comprehension of how PVs are evolved and varied, we analyze the clone-and-own practices applied by developers of these PVs. We perform an empirical study on 75 android families to gain insights about observable phenomena related to the commonality and variability between the source code of PVs of these families. In particular, we study three research questions to identify the commonality and variability related to the organization of source code files, cloning Java methods, and configuration parameters of AndroidManifest.xml files. The results show that cloning packages, Java files and Java methods is a common practice used by developers of all android families. Maintainers should put efforts for managing the diverse implementations (bodies) of\u00a0\u2026", "num_citations": "1\n", "authors": ["1528"]}
{"title": "A Toolset to Address Variability in Mobile Robotics\n", "abstract": " Dealing with variability may be the most serious issue when developing and maintaining robotic systems: it jeopardizes communication between the stakeholders of a robotic system and interoperability between its components. This paper reports on an approach and a toolset to improve both communication and interoperability. The approach relies on an ontology of mobile robotics and on a Domain-Specific Language (DSL) to describe robotic systems with missing parts that are problems that can be completed by third-party solutions. The domain model of the DSL is derived from the conceptual framework of the ontology. Models of robotic systems and scenarios can be defined using a graphical modeling environment and code can be generated for open-source as well as commercial middleware and simulators. A key advantage of the approach is that code can be generated for both simulation platforms and real-world robots. The validation of the approach is illustrated with a landmark-search case study.", "num_citations": "1\n", "authors": ["1528"]}
{"title": "Vers une approche d'ing\u00e9nierie multiagent \u00e0 base de ligne de produits logiciels\n", "abstract": " Bien que plusieurs m\u00e9thodes et outils aient \u00e9t\u00e9 propos\u00e9s pour l'ing\u00e9nierie des SMA durant les deux derni\u00e8res d\u00e9cennies, passer des mod\u00e8les SMA au code reste une t\u00e2che difficile. La majorit\u00e9 de ces m\u00e9thodes ne parvient pas \u00e0 proposer une solution pour la r\u00e9utilisation des impl\u00e9mentations existantes telles que les processus incr\u00e9mentaux. Notre proposition r\u00e9pond \u00e0 deux probl\u00e8mes : combler le foss\u00e9 entre la mod\u00e9lisation des SMA et l\u2019impl\u00e9mentation d\u2019une part, et fournir une approche incr\u00e9mentale de d\u00e9veloppement de SMA en s\u2019appuyant sur les lignes de produits logiciels d\u2019autre part. Cette approche se base sur une description de la variabilit\u00e9 gr\u00e2ce \u00e0 des mod\u00e8les de caract\u00e9ristiques et utilise un framework de ligne de produits logiciels pour la g\u00e9n\u00e9ration des diff\u00e9rentes variantes de l\u2019application.", "num_citations": "1\n", "authors": ["1528"]}
{"title": "G\u00e9n\u00e9ration de code pour les syst\u00e8me r\u00e9actifs \u00e0 partir de mod\u00e8les UML2-Application \u00e0 AIBO\n", "abstract": " Dans cet article nous pr\u00e9sentons une approche de g\u00e9n\u00e9ration compl\u00e8te de code pour les syst\u00e8mes r\u00e9actifs effectu\u00e9e \u00e0 partir de sp\u00e9cifications compos\u00e9es de diagrammes de classes et de diagramme de s\u00e9quence UML2.0. Notre approche se d\u00e9coupe en deux phases : la g\u00e9n\u00e9ration d\u2019une machine \u00e0 \u00e9tats \u00e0 partir des diagrammes de s\u00e9quence puis la g\u00e9n\u00e9ration du code \u00e0 partir de la machine \u00e0 \u00e9tvats g\u00e9n\u00e9r\u00e9e. Cette approche a \u00e9t\u00e9 mise en \u0153uvre pour g\u00e9n\u00e9rer le code de robot AIBO (robot chien vendu par SONY). Nous pr\u00e9sentons ici les r\u00e9sultats de notre travail qui permettent de mesurer les avantages et les inconv\u00e9nients de UML2.0 pour la g\u00e9n\u00e9ration compl\u00e8te de code.", "num_citations": "1\n", "authors": ["1528"]}