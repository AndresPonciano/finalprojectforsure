{"title": "Bandera: Extracting finite-state models from Java source code\n", "abstract": " Finite-state verification techniques, such as model checking, have shown promise as a cost-effective means for finding defects in hardware designs. To date, the application of these techniques to software has been hindered by several obstacles. Chief among these is the problem of constructing a finite-state model that approximates the executable behavior of the software system of interest. Current best-practice involves hand construction of models which is expensive (prohibitive for all but the smallest systems), prone to errors (which can result in misleading verification results), and difficult to optimize (which is necessary to combat the exponential complexity of verification algorithms). The authors describe an integrated collection of program analysis and transformation components, called Bandera, that enables the automatic extraction of safe, compact finite-state models from program source code. Bandera takes\u00a0\u2026", "num_citations": "1531\n", "authors": ["1637"]}
{"title": "Amandroid: A precise and general inter-component data flow analysis framework for security vetting of android apps\n", "abstract": " We propose a new approach to conduct static analysis for security vetting of Android apps, and built a general framework, called Amandroid for determining points-to information for all objects in an Android app in a flow-and context-sensitive way across Android apps components. We show that:(a) this type of comprehensive analysis is completely feasible in terms of computing resources needed with modern hardware,(b) one can easily leverage the results from this general analysis to build various types of specialized security analyses--in many cases the amount of additional coding needed is around 100 lines of code, and (c) the result of those specialized analyses leveraging Amandroid is at least on par and often exceeds prior works designed for the specific problems, which we demonstrate by comparing Amandroid's results with those of prior works whenever we can obtain the executable of those tools. Since\u00a0\u2026", "num_citations": "364\n", "authors": ["1637"]}
{"title": "Bogor: an extensible and highly-modular software model checking framework\n", "abstract": " Model checking is emerging as a popular technology for reasoning about behavioral properties of a wide variety of software artifacts including: requirements models, architectural descriptions, designs, implementations, and process models. The complexity of model checking is well-known, yet cost-effective analyses have been achieved by exploiting, for example, naturally occurring abstractions and semantic properties of a target software artifact. semantic properties of target software artifacts. Adapting a model checking tool to exploit this kind of domain knowledge often requires in-depth knowledge of the tool's implementation.We believe that with appropriate tool support, domain experts will be able to develop efficient model checking-based analyses for a variety of software-related models. To explore this hypothesis, we have developed Bogor, a model checking framework with an extensible input language for\u00a0\u2026", "num_citations": "343\n", "authors": ["1637"]}
{"title": "O-MaSE: a customizable approach to developing multiagent development processes\n", "abstract": " This paper describes the Organization-based Multiagent System Engineering (O-MaSE) Process Framework, which helps process engineers define custom multiagent systems development processes. O-MaSE builds off the MaSE methodology and is adapted from the OPEN Process Framework (OPF). OPF implements a Method Engineering approach to process construction. The goal of O-MaSE is to allow designers to create customized agent-oriented software development processes. O-MaSE consists of three basic structures: (1) a metamodel, (2) a set of methods fragments, and (3) a set of guidelines. The O-MaSE metamodel defines the key concepts needed to design and implement multiagent systems. The method fragments are operations or tasks that are executed to produce a set of work products, which may include models, documents, or code. The guidelines define how the method fragments are\u00a0\u2026", "num_citations": "116\n", "authors": ["1637"]}
{"title": "A language framework for expressing checkable properties of dynamic software\n", "abstract": " Research on how to reason about correctness properties of software systems using model checking is advancing rapidly. Work on extracting finite-state models from program source code and on abstracting those models is focused on enabling the tractable checking of program properties such as freedom from deadlock and assertion violations. For the most part, the problem of specifying more general program properties has not been considered.               In this paper, we report on the support for specifying properties of dynamic multi-threaded Java programs that we have built into the Bandera system. Bandera extracts finite-state models, in the input format of several existing model checkers, from Java code based on the property to be checked. The Bandera Specification Language (BSL) provides a language for defining general assertions and pre/post conditions on methods. It also supports the definition\u00a0\u2026", "num_citations": "109\n", "authors": ["1637"]}
{"title": "Expressing checkable properties of dynamic systems: the Bandera Specification Language\n", "abstract": " Research on how to reason about correctness properties of software systems using model checking is advancing rapidly. Work on extracting finite-state models from program source code and on abstracting those models is focused on enabling the tractable checking of program properties such as freedom from deadlock and assertion violations. For the most part, the problem of specifying more general program properties has not been considered. In this paper, we report on the support for specifying properties of dynamic multi-threaded Java programs that we have built into the Bandera system. Bandera extracts finite-state models, in the input format of several existing model checkers, from Java code based on the property to be checked. The Bandera Specification Language (BSL) provides a language for defining general assertions and pre/post conditions on methods. It also supports the definition of\u00a0\u2026", "num_citations": "97\n", "authors": ["1637"]}
{"title": "Exploiting object escape and locking information in partial-order reductions for concurrent object-oriented programs\n", "abstract": " Explicit-state model checking tools often incorporate partial-order reductions to reduce the number of system states explored (and thus the time and memory required) for verification. As model checking techniques are scaled up to software systems, it is important to develop and assess partial-order reduction strategies that are effective for addressing the complex structures found in software and for reducing the tremendous cost of model checking software systems.               In this paper, we consider a number of reduction strategies for model checking concurrent object-oriented software. We investigate a range of techniques that have been proposed in the literature, improve on those in several ways, and develop five novel reduction techniques that advance the state of the art in partial-order reduction for concurrent object-oriented systems. These reduction strategies are based on (a) detecting heap objects\u00a0\u2026", "num_citations": "92\n", "authors": ["1637"]}
{"title": "Verifying atomicity specifications for concurrent object-oriented software using model-checking\n", "abstract": " In recent work, Flanagan and Qadeer proposed atomicity declarations as a light-weight mechanism for specifying non-interference properties in concurrent programming languages such as Java, and they provided a type and effect system to verify atomicity properties. While verification of atomicity specifications via a static type system has several advantages (scalability, compositional checking), we show that verification via model-checking also has several advantages (fewer unchecked annotations, greater coverage of Java idioms, stronger verification). In particular, we show that by adapting the Bogor model-checker, we naturally address several properties that are difficult to check with a static type system.", "num_citations": "85\n", "authors": ["1637"]}
{"title": "Evaluating the effectiveness of slicing for model reduction of concurrent object-oriented programs\n", "abstract": " Model checking techniques have proven effective for checking a number of non-trivial concurrent object-oriented software systems. However, due to the high computational and memory costs, a variety of model reduction techniques are needed to overcome current limitations on applicability and scalability. Conventional wisdom holds that static program slicing can be an effective model reduction technique, yet anecdotal evidence is mixed, and there has been no work that has systematically studied the costs/benefits of slicing for model reduction in the context of model checking source code for realistic systems.               In this paper, we present an overview of the sophisticated Indus program slicer that is capable of handling full Java and is readily applicable to interesting off-the-shelf concurrent Java programs. Using the Indus program slicer as part of the next generation of the Bandera model checking\u00a0\u2026", "num_citations": "73\n", "authors": ["1637"]}
{"title": "Bandera: A source-level interface for model checking java programs\n", "abstract": " Despite emerging tool support for assertion-checking and testing of object-oriented programs, providing convincing evidence of program correctness remains a difficult challenge. This is especially true for multi-threaded programs. Techniques for reasoning about finite-state systems have been developing rapidly over the past decade and have the potential to form the basis of powerful software validation technologies. We have developed the Bandera toolset to harness the power of existing model checking tools to apply them to reason about correctness requirements of Java programs. Bandera provides tool support for defining and managing collections of requirements for a program, for extracting compact finite-state models of the program to enable tractable analysis, and for displaying analysis results to the user through a debugger-like interface. This paper describes and illustrates the use of Bandera's source\u00a0\u2026", "num_citations": "69\n", "authors": ["1637"]}
{"title": "Building your own software model checker using the bogor extensible model checking framework\n", "abstract": " Model checking has proven to be an effective technology for verification and debugging in hardware and more recently in software domains. We believe that recent trends in both the requirements for software systems and the processes by which systems are developed suggest that domain-specific model checking engines may be more effective than general purpose model checking tools. To overcome limitations of existing tools which tend to be monolithic and non-extensible, we have developed an extensible and customizable model checking framework called Bogor. In this tool paper, we summarize (a) Bogor\u2019s direct support for modeling object-oriented designs and implementations, (b) its facilities for extending and customizing its modeling language and algorithms to create domain-specific model checking engines, and (c) pedagogical materials that we have developed to describe the construction of\u00a0\u2026", "num_citations": "67\n", "authors": ["1637"]}
{"title": "Model-checking middleware-based event-driven real-time embedded software\n", "abstract": " Component frameworks such as the CORBA Component Model (CCM) and middleware services such as the CORBA Event Service are increasingly being used to build safety / mission-critical distributed real-time embedded (DRE) systems. In this paper, we present a novel model-checking infrastructure for checking global temporal properties of DRE systems built on top of a Real-Time CORBA Event Service using CCM architectures. We describe how (a) building support for OO structures and communication layers directly in an extensible model-checker and (b) leveraging domain properties related to priorities, scheduling, and timing can dramatically reduce the costs of checking realistic systems.", "num_citations": "58\n", "authors": ["1637"]}
{"title": "Space-reduction strategies for model checking dynamic software\n", "abstract": " E# ective model-checking of modern object-oriented software systems requires providing support for program features such as dynamically created threads, heapallocated objects and garbage collection. These features have often proven problematic to treat using many previous model-checking frameworks that do not provide sophisticated heap representations and optimizations.", "num_citations": "51\n", "authors": ["1637"]}
{"title": "agentTool process editor: supporting the design of tailored agent-based processes\n", "abstract": " This paper describes the agentTool Process Editor (APE), an Eclipse plug-in based on the Eclipse Process Framework. The aim of APE is to facilitate the design, verification, and management of custom agent-oriented software development processes. APE provides five basic structures. The Library is a repository of agent-oriented method fragments. A Process Editor allows the management of tailored processes. Task Constraints help process engineers specify guidelines to constrain how tasks can be assembled, while a Process Consistency mechanism verifies the consistency of tailored processes against those constraints. Finally, the Process Management integrates APE with the agentTool III development environment and provides a way to measure project progress using Earned Value Analysis.", "num_citations": "46\n", "authors": ["1637"]}
{"title": "Amandroid: A Precise and General Inter-component Data Flow Analysis Framework for Security Vetting of Android Apps\n", "abstract": " We present a new approach to static analysis for security vetting of Android apps and a general framework called Amandroid. Amandroid determines points-to information for all objects in an Android app component in a flow and context-sensitive (user-configurable) way and performs data flow and data dependence analysis for the component. Amandroid also tracks inter-component communication activities. It can stitch the component-level information into the app-level information to perform intra-app or inter-app analysis. In this article, (a) we show that the aforementioned type of comprehensive app analysis is completely feasible in terms of computing resources with modern hardware, (b) we demonstrate that one can easily leverage the results from this general analysis to build various types of specialized security analyses\u2014in many cases the amount of additional coding needed is around 100 lines of code, and\u00a0\u2026", "num_citations": "45\n", "authors": ["1637"]}
{"title": "Kiasan/KUnit: Automatic test case generation and analysis feedback for open object-oriented systems\n", "abstract": " We demonstrate how a static analysis feedback and unit test case generation framework, KUnit, built on the Bogor/Kiasan symbolic execution engine provides an effective unit test case generation for sequential heap-intensive Java programs (whose computation structures are incomplete - open systems). KUnit leverages method contract information to better deal with open object-oriented systems and to support automatic mock object creation. To facilitate application to realistic software, KUnit allows the scope/cost of the analysis and test case generation to be controlled via notions of heap configuration coverage. In a broad experimental study on 23 Java data structure modules, we show that it is able to: (a) achieve 100% feasible branch coverage on almost all methods by using only small heap configurations; (b) improve on competing tools for coverage achieved; size of test suites; and time to generate test suites.", "num_citations": "41\n", "authors": ["1637"]}
{"title": "Specification and checking of software contracts for conditional information flow\n", "abstract": " Information assurance applications built according to the multiple independent levels of security (MILS) architecture often contain information flow policies that are conditional in the sense that data is allowed to flow between system components only when the system satisfies certain state predicates. However, existing specification and verification environments, such as SPARK Ada, used to develop MILS applications can only capture unconditional information flows. Motivated by the need to better formally specify and certify MILS applications in industrial contexts, we present an enhancement of the SPARK information flow annotation language that enables specification, inferring, and compositional checking of conditional information flow contracts. A precondition generation algorithm is defined that automates the compositional checking and inference of conditional informational flow contracts. We report on\u00a0\u2026", "num_citations": "35\n", "authors": ["1637"]}
{"title": "agentTool III: from process definition to code generation\n", "abstract": " The agentTool III (aT 3) development environment is built on the Eclipse platform and provides traditional model creation tools to support the analysis, design, and implementation of multiagent systems following the Organization-based Multiagent Systems Engineering (O-MaSE) methodology. It also provides the ability to compose, verify, and maintain customized O-MaSE complaint processes. Additionally, aT 3 provides a verification framework which helps designers to maintain consistency between their O-MaSE models.", "num_citations": "34\n", "authors": ["1637"]}
{"title": "Checking JML specifications using an extensible software model checking framework\n", "abstract": " The use of assertions to express correctness properties of programs is growing in practice. Assertions provide a form of lightweight checkable specification that can be very effective in finding defects in programs and in guiding developers to the cause of a problem. A wide variety of assertion languages and associated validation techniques have been developed, but run-time monitoring is commonly thought to be the only practical solution. In this paper, we describe how specifications written in the Java Modeling Language (JML), a general purpose behavioral specification and assertional language for Java, can be validated using a customized model checker built on top of the Bogor model checking framework. Our experience illustrates the need for customized state-space representations and reduction strategies in model checking frameworks in order to effectively check the kind of strong behavioral\u00a0\u2026", "num_citations": "27\n", "authors": ["1637"]}
{"title": "Foundations of the Bandera abstraction tools\n", "abstract": " Current research is demonstrating that model-checking and other forms of automated finite-state verification can be effective for checking properties of software systems. Due to the exponential costs associated with model-checking, multiple forms of abstraction are often necessary to obtain system models that are tractable for automated checking.               The Bandera Tool Set provides multiple forms of automated support for compiling concurrent Java software systems to models that can be supplied to several different model-checking tools. In this paper, we describe the foundations of Bandera\u2019s data abstraction mechanism which is used to reduce the cardinality (and the program\u2019s state-space) of data domains in software to be model-checked. From a technical standpoint, the form of data abstraction used in Bandera is simple, and it is based on classical presentations of abstract interpretation. We describe\u00a0\u2026", "num_citations": "27\n", "authors": ["1637"]}
{"title": "Sireum/Topi LDP: a lightweight semi-decision procedure for optimizing symbolic execution-based analyses\n", "abstract": " Automated theorem proving techniques such as Satisfiability Modulo Theory (SMT) solvers have seen significant advances in the past several years. These advancements, coupled with vast hardware improvements, have drastic impact on, for example, program verification techniques and tools. The general availability of robust general purpose solvers have reduced a significant engineering overhead when designing and developing program verifiers. However, most solver implementations are designed to be used as a black box, and due to their aim as general purpose solvers, they often miss optimization opportunities that can be done by leveraging domain-specific knowledge.", "num_citations": "23\n", "authors": ["1637"]}
{"title": "Space reductions for model checking quasi-cyclic systems\n", "abstract": " Despite significant research on state-space reductions, the poor scalability of model checking for reasoning about behavioral models of large, complex systems remains the chief obstacle to its broad acceptance. One strategy for making further progress is to exploit characteristics of classes of systems to develop domain-specific reductions.               In this paper, we identify a structural property of system state-spaces, which we call quasi-cyclic structure, that can be leveraged to significantly reduce the space requirements of model checking. We give a formal characterization of quasi-cyclic state-spaces and describe a state-space exploration algorithm for exploiting that structure. In addition, we describe a class of real-time embedded systems that are quasi-cyclic, we outline how we customized an existing model checking framework to implement space-efficient search of quasi-cyclic systems, and we present\u00a0\u2026", "num_citations": "18\n", "authors": ["1637"]}
{"title": "Bakar Kiasan: Flexible contract checking for critical systems using symbolic execution\n", "abstract": " Spark, a subset of Ada for engineering safety and security-critical systems, is designed for verification and includes a software contract language for specifying functional properties of procedures. Even though Spark and its static analysis components are beneficial and easy to use, its contract language is almost never used due to the burdens the associated tool support imposes on developers. In this paper, we present: (a) SymExe techniques for checking software contracts in embedded critical systems, and (b) Bakar Kiasan, a tool that implements these techniques in an integrated development environment for Spark. We describe a methodology for using Bakar Kiasan that provides significant increases in automation, usability, and functionality over existing Spark tools, and we present results from experiments on its application to industrial examples.", "num_citations": "16\n", "authors": ["1637"]}
{"title": "Kiasan: A verification and test-case generation framework for Java based on symbolic execution\n", "abstract": " Best program practices in software engineering emphasize software components that are loosely coupled and can be independently developed by different vendors. While these approaches improve the process of software development, however, they present a number of challenges involving reasoning about the correctness of individual components as well as their integration. Design-by-contract reasoning offers a promising approach to reason about software components by requiring software contracts that describe the behaviors of the components. This allows one to focus at satisfying the contract of each component, i.e., it allows compositional reasoning. In this paper, we present Kiasan, a technique that combines symbolic execution, model checking, theorem proving, and constraint solving to support design-by-contract reasoning of object-oriented software. There are a number of interesting tradeoffs between\u00a0\u2026", "num_citations": "16\n", "authors": ["1637"]}
{"title": "Trace-Based Specification of Law and Guidance Policies for Multi-Agent Systems\n", "abstract": " Policies have traditionally been a way to specify properties of a system. In this paper, we show how policies can be applied to the Organization Model for Adaptive Computational Systems (OMACS). In OMACS, policies may constrain assignments of agents to roles, the structure of the goal model for the organization, or how an agent may play a particular role. In this paper, we focus on policies limiting system traces; this is done to leverage the work already done for specification and verification of properties in concurrent programs. We show how traditional policies can be characterized as law policies; that is, they must always be followed by a system. In the context of multiagent systems, law policies limit the flexibility of the system. Thus, in order to preserve the system flexibility while still being able to guide the system into preferring certain behaviors, we introduce the concept of guidance policies. These\u00a0\u2026", "num_citations": "15\n", "authors": ["1637"]}
{"title": "Leveraging Organizational Guidance Policies with Learning to Self-Tune Multiagent Systems\n", "abstract": " As organization-based multiagent systems are applied to more complex problems, configuring and tuning the systems can become nearly as complex as the original problem a system was designed to solve. A robust system should be able to adapt. It should be able to self-configure and self-tune. To this end, we propose a method for self-tuning using the concept of guidance policies, that is policies that are designed to guide the system without sacrificing its flexibility. Guidance policies allow us to apply traditional learning techniques online without many of the drawbacks associated with a system falling into a local optimum. They also help simplify the learning process. We examine the impact of this learning on various multiagent systems.", "num_citations": "13\n", "authors": ["1637"]}
{"title": "Towards A Case-Optimal Symbolic Execution Algorithm for Analyzing Strong Properties of Object-Oriented Programs.\n", "abstract": " Recent work has demonstrated that symbolic execution techniques can serve as a basis for formal analysis capable of automatically checking heap-manipulating software components against strong interface specifications. In this paper, we present an enhancement to existing symbolic execution algorithms for object-oriented programs that significantly improves upon the algorithms currently implemented in Bogor/Kiasan and JPF. To motivate and justify the new strategy for handling heap data in our enhanced approach, we present a significant empirical study of the performance of related algorithms and an interesting case counting analysis of the heap shapes that can appear in several widely used Java data structure packages.", "num_citations": "13\n", "authors": ["1637"]}
{"title": "Towards an AADL-based definition of app architectures for medical application platforms\n", "abstract": " There is a growing trend of developing software applications that integrate and coordinate the actions of medical devices. Unfortunately, these applications are being built in an ad-hoc manner without proper regard for established distributed systems engineering techniques. We present a tool prototype based on the OSATE2 distribution of the Eclipse IDE that targets the development of Medical Application Platform (MAP) apps. Our toolset provides an editing environment and translator for app architectures, i.e., their components and connections. The toolset generates interface definitions and glue code for the underlying MAP middleware, and it supports development of the business logic which the developer must write to complete the application within the same Eclipse-based environment. We also present a clinical scenario as a motivating example, trace its development through the toolset, and evaluate\u00a0\u2026", "num_citations": "11\n", "authors": ["1637"]}
{"title": "Explicating symbolic execution (xSymExe): An evidence-based verification framework\n", "abstract": " Previous applications of symbolic execution (Sym-Exe) have focused on bug-finding and test-case generation. However, SymExe has the potential to significantly improve usability and automation when applied to verification of software contracts in safety-critical systems. Due to the lack of support for processing software contracts and ad hoc approaches for introducing a variety of over/under-approximations and optimizations, most SymExe implementations cannot precisely characterize the verification status of contracts. Moreover, these tools do not provide explicit justifications for their conclusions, and thus they are not aligned with trends toward evidence-based verification and certification. We introduce the concept of explicating symbolic execution (xSymExe) that builds on a strong semantic foundation, supports full verification of rich software contracts, explicitly tracks where over/under-approximations are\u00a0\u2026", "num_citations": "10\n", "authors": ["1637"]}
{"title": "Communication patterns for interconnecting and composing medical systems.\n", "abstract": " This paper proposes a set of communication patterns to enable the construction of medical systems by composing devices and apps in Integrated Clinical Environments (ICE). These patterns abstract away the details of communication tasks, reduce engineering overhead, and ease compositional reasoning of the system. The proposed patterns have been successfully implemented on top of two distinct platforms (i.e., RTI Connext and Vert.x) to allow for experimentation.", "num_citations": "8\n", "authors": ["1637"]}
{"title": "A flexible framework for the estimation of coverage metrics in explicit state software model checking\n", "abstract": " Explicit-State Model Checking is a well-studied technique for the verification of concurrent programs. Due to exponential costs associated with model checking, researchers often focus on applying model checking to software units rather than whole programs. Recently, we have introduced a framework that allows developers to specify and model check rich properties of Java software units using the Java Modeling Language (JML). An often overlooked problem in research on model checking software units is the problem of environment generation: how does one develop code for a test harness (representing the behaviors of contexts in which a unit may eventually be deployed) for the purpose of driving the unit being checked along relevant execution paths?             In this paper, we build on previous work in the testing community and we focus on the use of coverage information to assess the appropriateness\u00a0\u2026", "num_citations": "8\n", "authors": ["1637"]}
{"title": "Ecosphere Principles for Medical Application Platforms\n", "abstract": " A Medical Application Platform (MAP) enables multi-vendor heterogeneous medical devices to be integrated via network infrastructure and provides an application hosting facility that supports a wide range of clinical applications for data fusion, decision support, multi-device safety interlocks, workflow automations, and closed-loop control of actuating medical devices. The assurance of MAP components and systems is distributed across a broad group of stakeholders including medical device manufacturers, platform infrastructure providers, application vendors, third-party certification organizations, and regulatory agencies. Realization of the MAP vision requires that all stakeholders involved in developing, testing, certifying, regulating, purchasing, and using medical devices and applications operate and cooperate within a well-defined ecosphere. This paper presents a high-level overview of the organization of such\u00a0\u2026", "num_citations": "7\n", "authors": ["1637"]}
{"title": "Bakar Alir: Supporting Developers in Construction of Information Flow Contracts in SPARK\n", "abstract": " This tool paper describes the design and implementation of an interactive environment for discovering and browsing information flow in SPARK programs. SPARK is a subset of Ada that has been used in a number of industrial contexts for implementing certified safety and security critical systems. SPARK requires explicit specification of information flow properties in the form of procedure contracts. To write such contracts, developers need to understand the data and control dependencies in the program. Our tool Bakar Alir, implemented as an Eclipse Plug-in, utilizes classic slicing and chopping techniques to assist developers in writing information flow contracts.", "num_citations": "7\n", "authors": ["1637"]}
{"title": "Abstract Requirement Analysis in Multiagent System Design\n", "abstract": " Good, fast, or cheap, pick two. What drives designers to make decisions on how to architect a system? The stake-holder has certain abstract qualities in mind: efficiency, quality, reliability, and so forth. How do we make sure our system is guided by these qualities? What happens when the system cannot always provide all the qualities? We describe a framework for analyzing a design allowing decisions about what qualities are more important to be made at design-time.", "num_citations": "6\n", "authors": ["1637"]}
{"title": "A case study in domain-customized model checking for real-time component software\n", "abstract": " Despite a decade of intensive research on general techniques for reducing the complexity of model checking, scalability remains the chief obstacle to its widespread adoption. Past experience has shown that domain-specific information can often be leveraged to obtain state-space reductions that go beyond general purpose reductions by customizing existing model checker implementations or by building new model-checking engines dedicated to a particular domain. Unfortunately, these strategies limit the dissemination of model checking across a number of domains since it is often infeasible for domain experts to build their own dedicated model checkers or to modify existing model checking engines.             To enable researchers to more easily tailor a model checking engine to a particular software-related domain, we have constructed an extensible and highly explicit-state software model checking\u00a0\u2026", "num_citations": "6\n", "authors": ["1637"]}
{"title": "Using static and dynamic escape analysis to enable model reductions in model-checking concurrent object-oriented programs\n", "abstract": " This paper proposes several partial order reduction strategies for model-checking concurrent object-oriented software that are based on detecting heap objects that are thread-local, ie, reachable from a single thread only. We show how thread-local information appropriate for driving these reductions can be obtained by static analysis (using adaptations of existing escape analyses). However, we show that in many cases, existing static analyses targetted to compiler optimizations fail to detect thread-local information that can lead to significant savings in model-checking. In fact, we show that a novel dynamic analysis carried out during model-checking is actually simpler to implement, and is more effective at reducing verification costs. These reduction strategies showing upwards of 20 times reduction on realistic programs, and can be easily incorporated into existing explicit-state software model-checkers. 1", "num_citations": "6\n", "authors": ["1637"]}
{"title": "A Unified Approach for Modeling, Developing, and Assuring Critical Systems\n", "abstract": " Developing and assuring safety- and security-critical real-time embedded systems is a challenging endeavor that requires many activities applied at multiple levels of abstraction. For these activities to be effective and trustworthy, they must be grounded in a common understanding of the system architecture and behavior.                 We believe that these activities are best addressed in a unified framework of modeling and programming that enables developers, analysts, and auditors to freely move up and down layers of abstraction, shifting their viewpoints to suit the activities at hand, while maintaining strong traceability across the different layers and views. In this approach, the distinction between \u201cmodels\u201d, \u201cspecifications\u201d, and \u201cprograms\u201d is often blurred.                 In this paper, we summarize an architecture-centric approach to critical system development and assurance that emphasizes the use of formally\u00a0\u2026", "num_citations": "4\n", "authors": ["1637"]}
{"title": "Towards the formalization of SPARK 2014 semantics with explicit run-time checks using coq\n", "abstract": " We present the first steps of a broad effort to develop a formal representation of SPARK 2014 suitable for supporting machine-verified static analyses and translations. In our initial work, we have developed technology for translating the GNAT compiler's abstract syntax trees into the Coq proof assistant, and we have formalized in Coq the dynamic semantics for a toy subset of the SPARK 2014 language. SPARK 2014 programs must ensure the absence of certain run-time errors (for example, those arising while performing division by zero, accessing non existing array cells, overflow on integer computation). The main novelty in our semantics is the encoding of (a small part of) the run-time checks performed by the compiler to ensure that any well-formed terminating SPARK programs do not lead to erroneous execution. This and other results are mechanically proved using the Coq proof assistant. The modeling of on\u00a0\u2026", "num_citations": "4\n", "authors": ["1637"]}
{"title": "Focused Certification of an Industrial Compilation and Static Verification Toolchain\n", "abstract": " SPARK 2014 is a subset of the Ada 2012 programming language that is supported by the GNAT compilation toolchain and multiple open source static analysis and verification tools. These tools can be used to verify that a SPARK 2014 program does not raise language-defined run-time exceptions and that it complies with formal specifications expressed as subprogram contracts. The results of analyses at source code level are valid for the final executable only if it can be shown that compilation/verification tools comply with a common deterministic programming language semantics.               In this paper, we present: (a) a mechanized formal semantics for a large subset of SPARK 2014, (b) an architecture for creating certified/certifying analysis and verification tools for SPARK, and (c) tools and mechanized proofs that instantiate that architecture to demonstrate that SPARK-relevant Ada run-time checks\u00a0\u2026", "num_citations": "3\n", "authors": ["1637"]}
{"title": "Supporting model checking education using BOGOR/Eclipse\n", "abstract": " This paper describes our effort on developing educational materials on model checking to help foster the adoption of software model checking. We describe the course materials that provide an in-depth theoretical background of model checking algorithms, coupled with a tool support to apply them that is built around the Eclipse platform. The educational materials presented here have been used to teach graduate-level model checking courses in a number of North American and European institutions.", "num_citations": "3\n", "authors": ["1637"]}
{"title": "HAMR: An AADL Multi-platform Code Generation Toolset\n", "abstract": " This paper describes the High-Assurance Model-based Rapid engineering for embedded systems (HAMR) tool-kit that generates high-assurance software from standards-based system architecture models for embedded cyber-physical systems. HAMR\u2019s computational model is based on standardized run-time services and communication models that together provide an abstract platform-independent realization which can be instantiated by back-end translations for different platforms. HAMR currently targets multiple platforms, including rapid prototyping targets such as Java Virtual Machines, Linux, as well as the formally verified seL4 space partitioned micro-kernel.                 HAMR bridges the gap between architecture models and the system implementation by generating high assurance infrastructure components that satisfy the requirements specified in the model and preserving rigorous execution\u00a0\u2026", "num_citations": "2\n", "authors": ["1637"]}
{"title": "Efficient symbolic execution of value-based data structures for critical systems\n", "abstract": " Symbolic execution shows promise for increasing the automation of verification tasks in certified safety/security-critical systems, where use of statically allocated value-based data structures is mandated. In fact Spark/Ada, a subset of Ada designed for verification and used for building critical systems, only permits data structures that are statically allocated. This paper describes a novel and efficient graph-based representation for programs making use of value-based data structures and procedure contracts. We show that our graph-based representation offers performance superior to a logic-based representation that is used in many approaches that delegate array reasoning to a decision procedure.", "num_citations": "2\n", "authors": ["1637"]}
{"title": "Slicing and partial evaluation of CORBA component model designs for avionics system\n", "abstract": " The use of component models such as Enterprise Java Beans and the CORBA Component Model (CCM) in application development is expanding rapidly. Even in real-time safety-critical and mission-critical domains, component-based development is beginning to take hold as a mechanism for in-corporating non-functional aspects such as real-time, quality-of-service, and distribution.", "num_citations": "2\n", "authors": ["1637"]}
{"title": "Enhancing spark's contract checking facilities using symbolic execution\n", "abstract": " Spark, a subset of Ada for engineering safety and security-critical systems, is one of the best commercially available frameworks for formal-methods-supported development of critical software. Spark is designed for verification and includes a software contract language for specifying functional properties of procedures. Even though Spark and its static analysis components are beneficial and easy to use, its contract language is rarely used for stating properties beyond simple constraints on scalar values due to the burdens the associated tool support imposes on developers. Symbolic execution (SymExe) techniques have made significant strides in automating reasoning about deep semantic properties of source code. However, most work on SymExe has focused on bug-finding and test case generation as opposed to tasks that are more verification-oriented such as contract checking. In previous work we have\u00a0\u2026", "num_citations": "1\n", "authors": ["1637"]}