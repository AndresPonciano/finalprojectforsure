{"title": "Adaptation in current e-learning systems\n", "abstract": " One key element to consider when developing e-learning systems is the adaptation of the system to the cognitive characteristics of the students. However, making this adaptation is not a simple process; it implies the study and conjunction of technical and pedagogical aspects.This article was written from the point of view of a designer who, without being an expert on the cognitive elements, tries to design e-learning systems that include an adaptation for them. This article attempts to provide the answers to some design questions as a starting point to further develop e-learning platforms.", "num_citations": "100\n", "authors": ["2139"]}
{"title": "Efficient virtual machine support of runtime structural reflection\n", "abstract": " Increasing trends towards adaptive, distributed, generative and pervasive software have made object-oriented dynamically typed languages become increasingly popular. These languages offer dynamic software evolution by means of reflection, facilitating the development of dynamic systems. Unfortunately, this dynamism commonly imposes a runtime performance penalty. In this paper, we describe how to extend a production JIT-compiler virtual machine to support runtime object-oriented structural reflection offered by many dynamic languages. Our approach improves runtime performance of dynamic languages running on statically typed virtual machines. At the same time, existing statically typed languages are still supported by the virtual machine.We have extended the .Net platform with runtime structural reflection adding prototype-based object-oriented semantics to the statically typed class-based model of\u00a0\u2026", "num_citations": "43\n", "authors": ["2139"]}
{"title": "Dynamic adaptation of application aspects\n", "abstract": " In today\u2019s fast changing environments, adaptability has become an important feature in modern computing systems, programming languages and software engineering methods. Different approaches and techniques are used to achieve the development of adaptable systems. Following the principle of separation of concerns, aspect-oriented programming (AOP) distinguishes application functional code from specific concerns that cut across the system, creating the final application by weaving the program\u2019s main code and its specific aspects. In many cases, dynamic application adaptation is needed, but few existing AOP tools offer it in a limited way. Moreover, these tools use a fixed programming language: aspects cannot be implemented regardless of its programming language.We identify reflection as a mechanism capable of overcoming the deficiencies previously mentioned. We have developed a non-restrictive\u00a0\u2026", "num_citations": "42\n", "authors": ["2139"]}
{"title": "Including both static and dynamic typing in the same programming language\n", "abstract": " Dynamic languages are becoming increasingly popular for different software development scenarios such as Web engineering, rapid prototyping or the construction of applications that require runtime adaptiveness. These languages are built on the idea of supporting reasoning about (and customising) program structure, behaviour and environment at runtime. The dynamism offered by dynamic languages is, however, counteracted by two main limitations: no early type error detection and fewer opportunities for compiler optimisations. To obtain the benefits of both dynamically and statically typed languages, the authors have designed the StaDyn programming language that provides both approaches. StaDyn keeps gathering-type information at compile time, even when dynamic variables are used. This type information is used to offer early type error detection, direct interoperation between static and dynamic codes\u00a0\u2026", "num_citations": "37\n", "authors": ["2139"]}
{"title": "Optimizing reflective primitives of dynamic languages\n", "abstract": " Dynamic languages are becoming widely used in software engineering due to the flexibility needs of specific software systems. Different example scenarios are the development of dynamic aspect oriented software, Web applications, adaptable and adaptive software or application frameworks. One important lack of these languages is compile-time error detection offered by static languages. However, runtime performance is the most serious limitation to use them in commercial software development. Although JIT optimizing compilation is a widely used technique to speed up intermediate code execution, this has not been successfully applied to dynamically adaptive platforms yet.         We present an approach to improve the structural reflective primitives offered by dynamic languages. Looking for a language-neutral platform with a good JIT-based runtime performance, we have used the Microsoft shared source\u00a0\u2026", "num_citations": "35\n", "authors": ["2139"]}
{"title": "Design patterns for teaching type checking in a compiler construction course\n", "abstract": " A course in compiler construction seeks to develop an understanding of well-defined fundamental theory and typically involves the production of a language processor. In a graduate degree in software engineering, the development of a compiler contributes significantly to the developer's comprehension of the practical application of theoretical concepts. Different formal notations are commonly used to define type systems, and some of them are used to teach the semantic analysis phase of language processing. In the traditional approach, attribute grammars are probably the most widely used ones. This paper shows how object-oriented design patterns represented in unified modeling language (UML) can be used to both teach type systems and develop the semantic analysis phase of a compiler. The main benefit of this approach is two-fold: better comprehension of theoretical concepts because of the use of\u00a0\u2026", "num_citations": "35\n", "authors": ["2139"]}
{"title": "Separating adaptable persistence attributes through computational reflection\n", "abstract": " To receive persistence capabilities, applications usually must explicitly access database management systems, such as object-oriented databases or object-relational mapping products. The usual way of building an application is tangling its functional code with explicit structured query language (SQL) or object query language (OQL) persistence statements. This tangling has several drawbacks: deficiencies in source code legibility, maintainability, and portability; lack of persistence functionality reuse; and low adaptability of persistence attributes. Separating crosscutting concerns such as persistence from the main application code can reduce software complexity and facilitate concerns reuse. A prototype persistence system shows how to use computational reflection to completely separate and adapt application persistence attribute at runtime.", "num_citations": "29\n", "authors": ["2139"]}
{"title": "A comprehensive evaluation of common python implementations\n", "abstract": " Python is a widely used general-purpose dynamic language. Owing to its popularity, many implementations exist for the two distinct Python 2 and Python 3 language versions. Researchers evaluated seven implementations of both language versions to facilitate the selection of one of them. For this purpose, they carefully selected 523 programs to execute in each implementation. They evaluated run-time performance and memory consumption and investigated each implementation's important qualitative characteristics.", "num_citations": "28\n", "authors": ["2139"]}
{"title": "The runtime performance of invokedynamic: An evaluation with a Java library\n", "abstract": " The Java 7 platform includes the invokedynamic opcode in its virtual machine, a feature that lets programmers define-and dynamically change-the linkage of method call sites, thereby maintaining platform optimizations. A comprehensive evaluation of a new library's performance includes a description of how to optimize real Java applications.", "num_citations": "27\n", "authors": ["2139"]}
{"title": "Union and intersection types to support both dynamic and static typing\n", "abstract": " Although static typing provides undeniable benefits for the development of applications, dynamically typed languages have become increasingly popular for specific scenarios. Since each approach offers different benefits, the StaDyn programming language has been designed to support both dynamic and static typing. This paper describes the minimal core of the StaDyn programming language. Its type system performs type reconstruction over both dynamic and static implicitly typed references. A new interpretation of union and intersection types allows statically gathering the type information of dynamic references, which improves runtime performance and robustness. The evaluation of the generated code has shown how our approach offers an important runtime performance benefit.", "num_citations": "25\n", "authors": ["2139"]}
{"title": "Dimag: a framework for automatic generation of mobile applications for multiple platforms\n", "abstract": " Device Independence is a concept based on the idea of making services, applications and contents available to users regardless of the device used to enjoy them. One of the problems for developers of mobile applications is the number of different mobile platforms in the market. Therefore, a software platform to generate an application for as many platforms as possible would increase enormously the number of potential users. We propose a framework (DIMAG: Device Independent Mobile Application Generation framework) to generate mobile applications for multiple software platforms by means of a declarative description of the application. Besides, the generation of an application with this framework takes into account additional requirements like the need of mobile applications to consume and provide data from and to remote machines, or the dynamic load of the classes for code generation for a given mobile\u00a0\u2026", "num_citations": "24\n", "authors": ["2139"]}
{"title": "A hybrid class-and prototype-based object model to support language-neutral structural intercession\n", "abstract": " Context Dynamic languages have turned out to be suitable for developing specific applications where runtime adaptability is an important issue. Although. Net and Java platforms have gradually incorporated features to improve their support of dynamic languages, they do not provide intercession for every object or class. This limitation is mainly caused by the rigid class-based object model these platforms implement, in contrast to the flexible prototype-based model used by most dynamic languages. Objective Our approach is to provide intercession for any object or class by defining a hybrid class-and prototype-based object model that efficiently incorporates structural intercession into the object model implemented by the widespread. Net and Java platforms. Method In a previous work, we developed and evaluated an extension of a shared-source implementation of the. Net platform. In this work, we define the\u00a0\u2026", "num_citations": "23\n", "authors": ["2139"]}
{"title": "Efficient support of dynamic inheritance for class-and prototype-based languages\n", "abstract": " Dynamically typed languages are becoming increasingly popular for different software development scenarios where runtime adaptability is important. Therefore, existing class-based platforms such as Java and. Net have been gradually incorporating dynamic features to support the execution of these languages. The implementations of dynamic languages on these platforms commonly generate an extra layer of software over the virtual machine, which reproduces the reflective prototype-based object model provided by most dynamic languages. Simulating this model frequently involves a runtime performance penalty, and makes the interoperation between class-and prototype-based languages difficult. Instead of simulating the reflective model of dynamic languages, our approach has been to extend the object-model of an efficient class-based virtual machine with prototype-based semantics, so that it can directly\u00a0\u2026", "num_citations": "22\n", "authors": ["2139"]}
{"title": "Type inference to optimize a hybrid statically and dynamically typed language\n", "abstract": " Dynamically typed languages are becoming increasingly popular for different software development scenarios such as Web engineering, rapid prototyping or the construction of applications that require runtime adaptiveness. In contrast, statically typed languages have undeniable advantages such as early type error detection and more opportunities for compiler optimizations. Since both approaches offer different benefits, hybrid statically and dynamically typed programming languages have emerged, and some statically typed languages have also incorporated dynamic typing capabilities. In this paper, we present the minimal core of StaDyn, a hybrid typing language that performs static type inference of both statically and dynamically typed references. The type information gathered by the compiler is used to generate efficient .NET code, obtaining a significant runtime performance improvement compared with C# 4\u00a0\u2026", "num_citations": "22\n", "authors": ["2139"]}
{"title": "The DSAW aspect-oriented software development platform\n", "abstract": " Aspect-Oriented Software Development (AOSD) provides systematic means to modularize crosscutting concerns in software development. Common AOSD benefits are a higher level of abstraction, concern reuse, better legibility, and software maintainability improvement. In AOSD, static weaving implementations commonly obtain better runtime performance, whereas dynamic weaving provides runtime application adaptiveness and a valuable aid in software development. Since both approaches provide benefits, we have developed a Dynamic and Static Aspect Weaving (DSAW) platform that supports both kinds of weavers: a full dynamic one to offer high dynamic adaptiveness and a static one to obtain better runtime performance when the application is deployed. Furthermore, both weaving techniques can even be used simultaneously in the same application. Depending on the adaptiveness requirements and the\u00a0\u2026", "num_citations": "20\n", "authors": ["2139"]}
{"title": "Designing an adaptable heterogeneous abstract machine by means of reflection\n", "abstract": " The concepts of abstract and virtual machines have been used for many different purposes to obtain diverse benefits such as code portability, compiler simplification, interoperability, distribution and direct support of specific paradigms. Despite of these benefits, the main drawback of virtual machines has always been execution performance. Consequently, there has been considerable research aimed at improving the performance of virtual machine's application execution compared to its native counterparts. Techniques like adaptive Just In Time compilation or efficient and complex garbage collection algorithms have reached such a point that Microsoft and Sun Microsystems identify this kind of platforms as appropriate to implement commercial applications.What we have noticed in our research work is that these platforms have heterogeneity, extensibility, platform porting and adaptability limitations caused by their\u00a0\u2026", "num_citations": "19\n", "authors": ["2139"]}
{"title": "On the suitability of dynamic languages for hot\u2010reprogramming a robotics framework: a Python case study\n", "abstract": " The development of service robots has gained more attention over the last years. Advanced robots have to cope with many different situations emerging at runtime, while executing complex tasks. They should be programmed as dynamically adaptive systems, capable of adapting themselves to the execution environment, including the computing, user, and physical environment. Recently, dynamic languages are becoming widely used because of the high runtime adaptability they offer. Therefore, we have analyzed the suitability of these languages to implement robotic systems with high runtime adaptability requirements, using Python as case study because of its maturity. To evaluate their suitability, we have implemented a reflective robotics framework that can be programmed in both Java and any dynamic language supported by the standard Java Scripting API. An example scenario has been developed using\u00a0\u2026", "num_citations": "17\n", "authors": ["2139"]}
{"title": "Non-restrictive computational reflection\n", "abstract": " Adaptable software systems and architectures give the programmer the ability to create applications that might customize themselves to runtime-emerging requirements. Computational reflection is a programming language technique that is commonly used to achieve the development of this kind of systems. Most runtime reflective systems use Meta-Object Protocols (MOPs). However, MOPs restrict the amount of features an application can customize, and the way they can express its own adaptation. Furthermore, this kind of systems uses a fixed programming language: they develop an interpreter, not a whole language-independent platform.What we present in this paper a non-restrictive reflective platform, called nitrO, that achieves a real computational-environment jump, making every application and language feature adaptable at runtime\u2014without any previously defined restriction. Moreover, the platform has\u00a0\u2026", "num_citations": "17\n", "authors": ["2139"]}
{"title": "Applying dynamic separation of aspects to distributed systems security: a case study\n", "abstract": " Distributed systems are commonly required to be flexible and scalable, as the number and arrangement of their (potentially mobile) devices may easily change. Security in distributed systems is a complex issue which can produce several problems such as eavesdropping, phishing or denial of service. To overcome these problems, there are various security measures that can be applied. This study proposes the use of dynamic aspect-oriented software development (AOSD) to implement security mechanisms in distributed systems. By applying dynamic separation of concerns using AOSD, it becomes possible to adapt the security measures of distributed systems, even when their sizes and arrangements change, without compromising global security. These changes can be applied when a distributed system is running, without requiring its execution to be stopped or interrupted. Using the dynamic and static aspect\u00a0\u2026", "num_citations": "16\n", "authors": ["2139"]}
{"title": "Implementing a real computational-environment jump in order to develop a runtime-adaptable reflective platform\n", "abstract": " Different techniques are emerging in order to build adaptable computing systems and software engineering methods. Two examples in the software engineering field are aspect-oriented programming and multi-dimensional separation of concerns. They distinguish functional code from reusable crosscutting aspects, creating the final application by weaving the program and its specific aspects. They lack runtime adaptability, simply offering design-time adaptation.Dynamic adaptability is offered by MOP-based reflective systems. However, meta-object protocols (MOPs) restrict the amount of features an application may customize, and the way they can express this customization. Furthermore, this kind of systems uses a fixed programming language.What we present in this paper is a non-restrictive reflective system that achieves a real computational jump, making every application and language feature adaptable at\u00a0\u2026", "num_citations": "16\n", "authors": ["2139"]}
{"title": "Generating native user interfaces for multiple devices by means of model transformation\n", "abstract": " In the last years, the types of devices used to access information systems have notably increased using different operating systems, screen sizes, interaction mechanisms, and software features. This device fragmentation is an important issue to tackle when developing native mobile service front-end applications. To address this issue, we propose the generation of native user interfaces (UIs) by means of model transformations, following the modelbased user interface (MBUI) paradigm. The resulting MBUI framework, called LIZARD, generates applications for multiple target platforms. LIZARD allows the definition of applications at a high level of abstraction, and applies model transformations to generate the target native UI considering the specific features of target platforms. The generated applications follow the UI design guidelines and the architectural and design patterns specified by the corresponding\u00a0\u2026", "num_citations": "14\n", "authors": ["2139"]}
{"title": "Attaining multiple dispatch in widespread object-oriented languages\n", "abstract": " Multiple dispatch allows determining the actual method to be executed, depending on the dynamic types of its arguments. Although some programming languages provide multiple dispatch, most widespread object-oriented languages lack this feature. Therefore, different implementation techniques are commonly used to obtain multiple dispatch in these languages. We evaluate the existing approaches, presenting a new one based on hybrid dynamic and static typing. A qualitative evaluation is presented, considering factors such as software maintainability and readability, code size, parameter generalization, and compile-time type checking. We also perform a quantitative assessment of runtime performance and memory consumption.", "num_citations": "14\n", "authors": ["2139"]}
{"title": "Heterogeneous tree structure classification to label Java programmers according to their expertise level\n", "abstract": " Open-source code repositories are a valuable asset to creating different kinds of tools and services, utilizing machine learning and probabilistic reasoning. Syntactic models process Abstract Syntax Trees (AST) of source code to build systems capable of predicting different software properties. The main difficulty of building such models comes from the heterogeneous and compound structures of ASTs, and that traditional machine learning algorithms require instances to be represented as n-dimensional vectors rather than trees. In this article, we propose a new approach to classify ASTs using traditional supervised-learning algorithms, where a feature learning process selects the most representative syntax patterns for the child subtrees of different syntax constructs. Those syntax patterns are used to enrich the context information of each AST, allowing the classification of compound heterogeneous tree structures\u00a0\u2026", "num_citations": "13\n", "authors": ["2139"]}
{"title": "Framework for the declarative implementation of native mobile applications\n", "abstract": " The development of connected mobile applications for a broad audience is a complex task because of the existing device diversity. In order to soothe this situation, device-independent approaches are aimed at implementing platform-independent applications, hiding the differences among the diverse families and models of mobile devices. Most of the existing approaches are based on the imperative definition of applications, which are either compiled to a native application, or executed in a Web browser. The client and server sides of applications are implemented separately, using different mechanisms for data synchronisation. In this study, the authors propose device-independent mobile application generation (DIMAG), a framework for defining native device-independent client-server applications based on the declarative specification of application workflow, state and data synchronisation, user interface and\u00a0\u2026", "num_citations": "12\n", "authors": ["2139"]}
{"title": "Visual Zero: A persistent and interactive object-oriented programming environment\n", "abstract": " In this article, an ongoing research project held in the Computer Science department of the University of Vigo is described. Its main objective is to develop an interactive object-oriented environment, serving as a vehicle for learning object-oriented programming. It currently consists of a virtual machine, an assembler, compilers for two high-level programming languages, and an educational visual programming environment. Its main characteristics are (a) the support of prototype-based object orientation, which is a model of object orientation that actually wraps the class-based model; (b) the support for object persistence, which simplifies all input/output issues to the minimum, and (c) the availability of a new visual programming environment is an invaluable help. We the authors think that the combination of all of these possibilities, will lead to an interesting, useful tool that would be recommended for object-oriented\u00a0\u2026", "num_citations": "12\n", "authors": ["2139"]}
{"title": "JINDY: a Java library to support invokedynamic\n", "abstract": " Java 7 has included the new invokedynamic opcode in the Java virtual machine.    This new instruction allows the user to define method linkage at runtime.    Once the link is established, the virtual machine performs its common    optimizations, providing better runtime performance than reflection. However,    this feature has not been offered at the abstraction level of the Java    programming language. Since the functionality of the new opcode is not    provided as a library, the existing languages in the Java platform can only    use it at the assembly level. For this reason, we have developed the JINDY    library that offers invokedynamic to any programming language in the Java    platform. JINDY supports three modes of use, establishing a trade-off between    runtime performance and flexibility. A runtime performance and memory    consumption evaluation is presented. We analyze the efficiency of JINDY    compared to reflection, the MethodHandle class in Java 7 and the Dynalink    library. The memory and performance costs compared to the invokedynamic    opcode are also measured.", "num_citations": "11\n", "authors": ["2139"]}
{"title": "Massive LMS log data analysis for the early prediction of course-agnostic student performance\n", "abstract": " The early prediction of students' performance is a valuable resource to improve their learning. If we are able to detect at-risk students in the initial stages of the course, we will have more time to improve their performance. Likewise, excellent students could be motivated with customized additional activities. This is why there are research works aimed to early detect students\u2019 performance. Some of them try to achieve it with the analysis of LMS log files, which store information about student interaction with the LMS. Many works create predictive models with the log files generated for the whole course, but those models are not useful for early prediction because the actual log information used for predicting is different to the one used to train the models. Other works do create predictive models with the log information retrieved at the early stages of courses, but they are just focused on a particular type of course.In this\u00a0\u2026", "num_citations": "10\n", "authors": ["2139"]}
{"title": "An efficient and scalable platform for Java source code analysis using overlaid graph representations\n", "abstract": " Although source code programs are commonly written as textual information, they enclose syntactic and semantic information that is usually represented as graphs. This information is used for many different purposes, such as static program analysis, advanced code search, coding guideline checking, software metrics computation, and extraction of semantic and syntactic information to create predictive models. Most of the existing systems that provide these kinds of services are designed ad hoc for the particular purpose they are aimed at. For this reason, we created ProgQuery, a platform to allow users to write their own Java program analyses in a declarative fashion, using graph representations. We modify the Java compiler to compute seven syntactic and semantic representations, and store them in a Neo4j graph database. Such representations are overlaid, meaning that syntactic and semantic nodes of the\u00a0\u2026", "num_citations": "10\n", "authors": ["2139"]}
{"title": "Big Code: New Opportunities for Improving Software Construction.\n", "abstract": " An emerging research topic called big code has recently appeared. Big code is based on the idea that open source code repositories can be used to create new kind of programming tools and services to improve software reliability and construction. We discuss different fields of application of big code, and the key issues to implement tools aimed at improving software construction following this approach. We describe the existing works that have already used this idea to build tools for vulnerability detection, software deobfuscation, automatic code completion for API usage, and efficient querying using detailed source-code information. Then, we propose different fields of application and the key issues found. We identify eight different fields where big code may be applied, and describe different examples for each field. We also detect seven different issues that must be tackled when creating tools based on the big code approach.", "num_citations": "10\n", "authors": ["2139"]}
{"title": "Design and implementation of an efficient hybrid dynamic and static typing language\n", "abstract": " Dynamic languages are suitable for developing specific applications where runtime adaptability is an important issue. On the contrary, statically typed languages commonly provide better compile\u2010time type error detection and more opportunities for compiler optimizations. Because both approaches offer different benefits, there exist programming languages that support hybrid dynamic and static typing. However, the existing hybrid typing languages commonly do not gather type information of dynamic references at compile time, missing opportunities for improving compile\u2010time error detection and runtime performance. Therefore, we propose some design principles to implement hybrid typing languages that continue gathering type information of dynamically typed references. This type information is used to perform compile\u2010time type checking of the dynamically typed code and improve its runtime performance. As\u00a0\u2026", "num_citations": "10\n", "authors": ["2139"]}
{"title": "An efficient platform for the automatic extraction of patterns in native code\n", "abstract": " Different software tools, such as decompilers, code quality analyzers, recognizers of packed executable files, authorship analyzers, and malware detectors, search for patterns in binary code. The use of machine learning algorithms, trained with programs taken from the huge number of applications in the existing open source code repositories, allows finding patterns not detected with the manual approach. To this end, we have created a versatile platform for the automatic extraction of patterns from native code, capable of processing big binary files. Its implementation has been parallelized, providing important runtime performance benefits for multicore architectures. Compared to the single-processor execution, the average performance improvement obtained with the best configuration is 3.5 factors over the maximum theoretical gain of 4 factors.", "num_citations": "9\n", "authors": ["2139"]}
{"title": "Supporting dynamic and static typing by means of union and intersection types\n", "abstract": " Although static typing provides early type error detection, better legibility and abstraction, and more opportunities for compiler optimizations, dynamic typing supplies a high degree of runtime adaptiveness, providing an agile and interactive development suitable for rapid prototyping. In this article, the minimal core type system of a programming language which main aim is to provide the benefits of both dynamic and static typing is presented. Keeping explicit typing, implicit type inference is introduced to combine dynamic and static typing in the same programming language. Union and intersection types are customized to express the dynamism of implicitly typed references. The main benefits of our work are an early type error detection in dynamic code, the integration of dynamic and static code in the same programming language, and a notable optimization of the generated code.", "num_citations": "9\n", "authors": ["2139"]}
{"title": "Towards an object\u2010oriented programming system for education\n", "abstract": " In this article, an ongoing research project conducted in the Computer Science department of the University of Vigo is described. Its main objective is to serve as a vehicle for learning object\u2010oriented programming. Although it is still in development, it has been successfully employed in a number of different courses. Its main characteristics are (a) support of prototype\u2010based object orientation, which is a model of object orientation that actually wraps the class\u2010based model; (b) future support for object persistence, which simplifies to the minimum all input/output issues; and (c) support of multiple platforms, through a portable bytecode. We think that the combination of all of these possibilities, the obtained results in its first use, and the further development of this project will lead to an interesting, useful tool which would be recommended for object\u2010oriented teaching. The simplicity of the prototype\u2010based model of object\u00a0\u2026", "num_citations": "9\n", "authors": ["2139"]}
{"title": "The nitro reflective platform\n", "abstract": " Adaptable software systems and architectures give the programmer the ability to create applications that might customize themselves to runtime-emerging requirements. Computational reflection is a programming language technique that is commonly used to achieve the development of this kind of systems. Most of runtime reflective systems use metaobject protocols (MOPs). However, MOPs restrict the amount of features an application may customize, and the way they can express its own adaptation. Furthermore, this kind of systems uses a fixed programming language: they develop an interpreter, not a whole language-independent platform.What we present in this paper is nitrO, a nonrestrictive reflective platform that achieves a real computational-environment jump, making every application and language feature adaptable at runtime\u2013without any previously defined restriction. Moreover, the platform has been\u00a0\u2026", "num_citations": "8\n", "authors": ["2139"]}
{"title": "Design and evaluation of an alternative programming paradigms course\n", "abstract": " The knowledge of the most common programming paradigms, and the basic abstractions provided by each paradigm, are competencies to be attained by Software Engineering undergraduate students. These abstractions also include the basis of concurrent and parallel programming, present in different programming paradigms. In an existing Software Engineering degree, these competencies were assigned to the Programming Technology and Paradigms course. We present the approach followed in the design of that course to teach object-oriented, functional, concurrent and parallel programming to second year undergraduate students with basic knowledge of Java. The time limitations of the course prevented us from using various programming languages. After analyzing different alternatives, we chose C# to teach the course. We describe the most important challenges faced and how we addressed them. The\u00a0\u2026", "num_citations": "7\n", "authors": ["2139"]}
{"title": "A SaaS framework for credit risk analysis services\n", "abstract": " Credit Risk Analysis (CRA) software services are becoming very important nowadays due to the financial crisis. Adapting the existing Enterprise Resource Planning (ERP) systems to include CRA services commonly involves a high cost, mainly caused by particular requirements of each company. On contrary, the CRA systems not included in the company ERP still require the ERP data. In this paper we describe OneRate, a Software as a Service (SaaS) CRA solution. OneRate frees the companies from the cost of adapting their current ERPs and from maintaining a separate CRA product. Our solution is highly customizable to the particular needs of each client company, so that customers benefit from the existing CRA capabilities while they also have a personalized product. OneRate is currently supporting more than 300 users of 32 different companies.", "num_citations": "7\n", "authors": ["2139"]}
{"title": "Aspect-Oriented Programming to Improve Modularity of Object-Oriented Applications.\n", "abstract": " The separation of concerns design principle improves software reutilization, understandability, extensibility and maintainability. By using the objectoriented paradigm, it is not always possible to separate into independent modules the different concerns of an application. The result is that the source code of crosscutting concerns are tangled and scattered across the whole application. Aspect-oriented programming offers a higher level of modularity, providing a solution for the code tangling and scattering problem. To show how aspectoriented programming can be used as a suitable mechanism to improve the modularity of object-oriented applications, this divulgative article presents the implementation of a typical design pattern following both the object-and aspectoriented paradigms. The two approaches are compared from the modularity perspective, establishing a discussion on the benefits provided and is current use.", "num_citations": "7\n", "authors": ["2139"]}
{"title": "Achieving multiple dispatch in hybrid statically and dynamically typed languages\n", "abstract": " Multiple dispatch is a feature provided by some programming languages, in which the actual method to be executed is dynamically determined by the runtime types of its arguments. Although some programming languages such as CLOS, Xtend and Dylan provide this feature, many widespread languages such as Java, C# and C++ only support single dispatch by means of dynamic binding. Therefore, different implementation techniques are commonly used to obtain multiple dispatch from within these single-dispatch languages. We propose a new approach to obtain multiple dispatch in single-dispatch hybrid static and dynamic typing languages. Using C# as an example, the proposed approach is compared with the existing ones, considering factors such as software maintainability and readability, code size, parameter generalization, compile-time type checking, and runtime performance. The example\u00a0\u2026", "num_citations": "7\n", "authors": ["2139"]}
{"title": "Efficient runtime metaprogramming services for Java\n", "abstract": " The Java programming language and platform provide many optimizations to execute statically typed code efficiently. Although Java has gradually incorporated more dynamic features across its versions, it does not provide several metaprogramming features supported by most dynamic languages, such as structural intercession (the ability to dynamically modify the structure of classes) and dynamic code generation. Therefore, we propose a method to add those metaprogramming features to Java in order to increase its runtime adaptiveness, while taking advantage of the robustness of its static type system and the performance of its virtual machine. We support the dynamic addition, deletion and replacement of class methods and fields, and dynamic code generation. The metaprogramming services are provided as a library, so neither the Java language nor its virtual machine are modified. We evaluate our system\u00a0\u2026", "num_citations": "6\n", "authors": ["2139"]}
{"title": "Optimizing runtime performance of hybrid dynamically and statically typed languages for the. Net platform\n", "abstract": " Dynamically typed languages have become popular in scenarios where high flexibility and adaptability are important issues. On the other hand, statically typed languages provide important benefits such as earlier type error detection and, usually, better runtime performance. The main objective of hybrid statically and dynamically typed languages is to provide the benefits of both approaches, combining the adaptability of dynamic typing and the robustness and performance of static typing. The dynamically typed code of hybrid languages for the .Net platform typically use the introspection services provided by the platform, incurring a significant performance penalty. We propose a set of transformation rules to replace the use of introspection with optimized code that uses the services of the Dynamic Language Runtime. These rules have been implemented as a binary optimization tool, and included as part of an\u00a0\u2026", "num_citations": "6\n", "authors": ["2139"]}
{"title": "Towards a static type checker for python\n", "abstract": " We present the preliminary stage of stypy, a static type checker for Python. stypy translates each Python program into Python code that type-checks the original program. The generated code replaces each variable with a type variable, evaluating expression types instead of their values. The generated type checker detects type errors in different tricky Python idioms, and ensures termination.", "num_citations": "6\n", "authors": ["2139"]}
{"title": "Modularizing different responsibilities into separate parallel hierarchies\n", "abstract": " When tangled inheritance hierarchies lead to code duplication, the Tease Apart Inheritance \"big\" refactoring is commonly used to create two parallel hierarchies, using delegation to invoke one from the other. Under these circumstances, the root class of the refactored hierarchy must be general enough to provide all its services to the other hierarchy, leading to meaningless interfaces that violate the Liskov substitution principle. In order to avoid this limitation, we propose a behavioral design pattern that allows the modularization of different responsibilities in separate hierarchies that collaborate to achieve a common goal. With this design, it is possible to use the specific interface of each class in the parallel hierarchy, without needing to define all the methods provided by every class in the hierarchy, and hence not violating the Liskov substitution principle. The proposed design is type safe and avoids the use\u00a0\u2026", "num_citations": "6\n", "authors": ["2139"]}
{"title": "A dynamic aspect weaver over the. net platform\n", "abstract": " Since Aspect Oriented Software Development (AOSD) has appeared, a set of tools have been developed that enable its use at software development. On many occasions, applications must be capable of adapting to runtime emerging requirements. This is possible through the use of dynamic weaving tools. However, these tools are subject to limitations such as language dependency or a limited set of join points, which limit their utility.             This paper shows the research we are carrying out in the dynamic weaving field. We apply computational reflection at the virtual machine computational level in order to achieve dynamic weaving regardless of the language. We have selected the .NET system as the platform to develop our dynamic weaver, making possible the dynamic adaptation of platform-independent applications.", "num_citations": "6\n", "authors": ["2139"]}
{"title": "A performance cost evaluation of aspect weaving\n", "abstract": " Aspect-Oriented Software Development (AOSD) facilitates the modularisation of different crosscutting concerns in software development. In AOSD, aspect weaving is the composition mechanism that combines aspects and components in an aspect-oriented application. Aspect weaving can be performed statically, at load time or at runtime. These different kinds of weavers may entail a runtime performance and a memory consumption cost, compared to the classical object-oriented approach. Using the Dynamic and Static Aspect Weaving (DSAW) AOSD platform, we have implemented three different scenarios of security issues in distributed systems (access control/data flow, encryption of transmissions, and FTP clientserver). These scenarios were developed in both the aspect-oriented and object-oriented paradigms in order to evaluate the cost introduced by static and dynamic aspect weavers. A detailed quantitative evaluation of runtime performance and memory consumption is presented.", "num_citations": "5\n", "authors": ["2139"]}
{"title": "A Type Safe Design to Allow the Separation of Different Responsibilities into Parallel Hierarchies.\n", "abstract": " The Tease Apart Inheritance refactoring is used to avoid tangled inheritance hierarchies that lead to code duplication. This big refactoring creates two parallel hierarchies and uses delegation to invoke one from the other. One of the drawbacks of this approach is that the root class of the new refactored hierarchy should be general enough to provide all its services. This weakness commonly leads to meaningless interfaces that violate the Liskov substitution principle. This paper describes a behavioral design pattern that allows modularization of different responsibilities in separate hierarchies that collaborate to achieve a common goal. It allows using the specific interface of each class in the parallel hierarchy, without imposing a meaningless interface to its root class. The proposed design is type safe, meaning that the compile-time type checking ensures that no type error will be produced at runtime, avoiding the use of dynamic type checking and reflection.", "num_citations": "5\n", "authors": ["2139"]}
{"title": "IDE support to facilitate the transition from rapid prototyping to robust software production\n", "abstract": " Dynamic languages are becoming increasingly popular for different software development scenarios such as rapid prototyping because of the flexibility and agile interactive development they offer. The benefits of dynamic languages are, however, counteracted by many limitations produced by the lack of static typing. In order to obtain the benefits of both approaches, some programming languages offer a hybrid dynamic and static type system. The existing IDEs for these hybrid typing languages do not provide any type-based feature when dynamic typing is used, lacking important IDE facilities offered for statically typed code. We have implemented a constraint-based type inference system that gathers type information of dynamic references at compile time. Using this type information, we have extended a professional IDE to offer those type-based features missed for dynamically typed code. Following the Separation\u00a0\u2026", "num_citations": "5\n", "authors": ["2139"]}
{"title": "Adding structural reflection to the SSCLI\n", "abstract": " Although dynamic languages are becoming widely used due to the flexibility needs of specific software products, their major drawback is their runtime performance. Compiling the source program to an abstract machine\u2019s intermediate language is the current technique used to obtain the best performance results. This intermediate code is then executed by a virtual machine developed as an interpreter. Although JIT adaptive optimizing compilation is currently used to speed up Java and. net intermediate code execution, this practice has not been employed successfully in the implementation of dynamically adaptive platforms yet. We present an approach to improve the runtime performance of a specific set of structural reflective primitives, extensively used in adaptive software development. Looking for a better performance, as well as interaction with other languages, we have employed the Microsoft Shared Source CLI platform, making use of its JIT compiler. The SSCLI computational model has been enhanced with semantics of the prototype-based object-oriented computational model. This model is much more suitable for reflective environments. The initial assessment of performance results reveals that augmenting the semantics of the SSCLI model, together with JIT generation of native code, produces better runtime performance than the existing implementations.", "num_citations": "5\n", "authors": ["2139"]}
{"title": "The reflective nitrO abstract machine\n", "abstract": " Abstract machines have been widely employed in computing systems in order to obtain different aims. Compiler simplification, platform neutrality, code distribution, interoperability, and direct support for specific paradigms are examples of the benefits they offer. Although performance has been its main drawback, the use of modern techniques like adaptive (hotspot) just in time compilation has overcome this weakness. Nowadays, well-known platforms based on abstract machines such as Java\u2122 or Microsoft .NET are commercially used.With the purpose of supporting any programming-language computational-model in heterogeneous environments, we have noticed that most abstract machines have extensibility, adaptability and heterogeneously lacks. We have designed an abstract machine that, using reflection as the main design principle, overcomes the limitations discovered. In this paper, we describe its\u00a0\u2026", "num_citations": "5\n", "authors": ["2139"]}
{"title": "An Infrastructure to Deliver Synchronous Remote Programming Labs\n", "abstract": " With the abrupt nationwide lockdown caused by the COVID-19 pandemic, many universities suspended face-to-face activities. Some of them decided to continue their academic courses, adapting traditional approaches to online learning. An important challenge was to deliver programming labs over the Internet without important methodological changes, which might imply modifications of the learning outcomes. Most of the existing approaches to remote programming labs are based on asynchronous learning, where students work autonomously and contact the lecturers if they have any issues. The existing systems to provide synchronous programming labs are restricted to a single programming language or application type, and show significant interaction limitations. Therefore, we defined an infrastructure that allowed us to deliver synchronous programming labs over the Internet during the COVID-19 lockdown\u00a0\u2026", "num_citations": "4\n", "authors": ["2139"]}
{"title": "SSA transformations to facilitate type inference in dynamically typed code\n", "abstract": " In most dynamically typed languages, variables are created without declaring their type. This way of programming allows variable reuse, so that variables sometimes hold different dynamic types in the same scope. Besides, it is also common to use the same variable to hold different dynamic types, depending on the execution flow of the program. When dynamically typed code is compiled into Java and .Net, the dynamic variables are usually generated as Object references. The approach of declaring variables with the top type (e.g. Object in Java and .Net) requires unsafe and inefficient type casts and, sometimes, the use of reflection. We propose the use of SSA (Static Single Assignment) transformations to facilitate inferring the type of dynamically typed local variables. The approach has been included in an existing compiler for the .Net framework. The result is that dynamically typed code performs significantly\u00a0\u2026", "num_citations": "4\n", "authors": ["2139"]}
{"title": "Modularizing application and database evolution\u2013an aspect\u2010oriented framework for orthogonal persistence\n", "abstract": " In the maintenance of software applications, database evolution is one common difficulty. In object\u2010oriented databases, this process comprises schema evolution and instance adaptation. Both tasks usually require significant effort from programmers and database administrators. In this paper, we propose orthogonal persistence and aspect\u2010oriented programming to support semi\u2010transparent database evolution. A default mechanism for instance evolution is defined, but the user may provide modularized solutions using the aspect\u2010oriented paradigm. We present our framework AOF4OOP to test the feasibility of our proposed approach. This prototype allows programmes to transparently access data in other versions of the database schema. We evaluate our framework, comparing it to related approaches using two real applications and measuring the improvement of the productivity of the programmer. Copyright \u00a9\u00a0\u2026", "num_citations": "4\n", "authors": ["2139"]}
{"title": "Automatic generation of object-oriented type checkers\n", "abstract": " Type systems are aimed at preventing programming language constructions from having wrong behavior at runtime. Different formalisms are used to guarantee that a type system is well defined. However, the type systems implemented in commercial language processors (type checkers) do not commonly use tools that translate these formalisms into code. We propose a framework to facilitate the implementation of object-oriented type checkers, following widespread design patterns. A tool generates the specific implementation of a type checker, receiving a specification of the type system as its input. The generated code interacts with an API, accessible from the rest of the language processor implementation.", "num_citations": "4\n", "authors": ["2139"]}
{"title": "Using standards to build the DIMAG connected mobile applications framework\n", "abstract": " The development of connected mobile applications is a complex task due to device diversity. Therefore, device-independent approaches are aimed at hiding the differences among the distinct mobile devices in the market. This work proposes DIMAG, a software framework to generate connected mobile applications for multiple software platforms, following a declarative approach. DIMAG provides transparent data and state synchronization between the server and the client side applications. The proposed platform has been designed making use of existing standards, extending them when a required functionality is not provided.", "num_citations": "4\n", "authors": ["2139"]}
{"title": "INCORPORATING AN OBJECT\u25a1 ORIENTED DBMS INTO AN INTEGRAL OBJECT\u25a1 ORIENTED SYSTEM\n", "abstract": " The aim of this paper is to show an object-oriented database management system, named BDOviedo3, which is highly integrated with a persistent object-oriented abstract machine and with an object-oriented operating system. It is being developed within a research project named Oviedo31, which tries to build an experimental integral object-oriented system where all the components share the same object-oriented paradigm.", "num_citations": "4\n", "authors": ["2139"]}
{"title": "Improving type information inferred by decompilers with supervised machine learning\n", "abstract": " In software reverse engineering, decompilation is the process of recovering source code from binary files. Decompilers are used when it is necessary to understand or analyze software for which the source code is not available. Although existing decompilers commonly obtain source code with the same behavior as the binaries, that source code is usually hard to interpret and certainly differs from the original code written by the programmer. Massive codebases could be used to build supervised machine learning models aimed at improving existing decompilers. In this article, we build different classification models capable of inferring the high-level type returned by functions, with significantly higher accuracy than existing decompilers. We automatically instrument C source code to allow the association of binary patterns with their corresponding high-level constructs. A dataset is created with a collection of real open-source applications plus a huge number of synthetic programs. Our system is able to predict function return types with a 79.1% F1-measure, whereas the best decompiler obtains a 30% F1-measure. Moreover, we document the binary patterns used by our classifier to allow their addition in the implementation of existing decompilers.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "A didactic object-oriented, prototype-based visual programming environment\n", "abstract": " Object-oriented programming is widely used in both the industry and the education areas. The most-common model of object-oriented programming is the class-based one. However, popular languages not implementing this model are gaining traction as time goes by. This alternative model is the prototype-based one, with one key characteristic: there are no classes. In this paper, a visual tool is proposed as a vehicle for learning the prototype-based object-oriented programming, present, for instance, in Self, Lua, or JavaScript. This software has been in use for three years in a subject of the Computer Science Engineering degree, at the University of Vigo.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "A virtualized test automation framework: A DellEMC case study of test automation practice\n", "abstract": " As software development life\u2010cycles continue to shorten, the need for reliable, maintainable and scalable test automation solutions becomes more and more important. This importance arises as software, test and automation activities occur earlier in the development life cycle with the aim of providing accelerated feedback on the code and software produced. In this environment, infrastructure and development environments are made available earlier to test teams, the demand of which can create environment bottlenecks as software and automation teams also require the same resources at the same time. To help maximize the use of the underlying resources virtualization and cloud based solutions have been proposed. However, at present there is no guidance on how to design and implement a test automation solution that leverages an underlying virtualized infrastructure. In this paper a virtualized test\u00a0\u2026", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Towards an Easily Programmable IoT Framework Based on Microservices.\n", "abstract": " The number of devices connected to the Internet of Things (IoT) is increasing so rapidly that end-users with no programming background will demand the implementation of their own IoT services and applications. However, IoT programming is still a difficult task because of device heterogeneity, dynamic changes in the physical environment, and scalability, security, accessibility and availability issues. Many of these liabilities are also present in distributed systems, where microservice architectures are successfully used. Therefore, in this article we propose an IoT framework based on microservices to ease the development of IoT software. Visual programming is proposed to permit end-users to build simple services and applications. Visual dataflow abstractions declaratively identify the \u201cthings\u201d and services in the network, creating a new level of indirection to create applications capable of adapting to changes in the IoT network. The devices connected to the network must provide a semantic self-description in order to support a global discovery service. End-users could describe the domain logic with existing visual programming abstractions previously proven to be suitable for non-programmers. The visual programs will be transparently compiled and deployed as microservices in a cloud-based environment, optimizing network traffic and runtime performance, while ensuring scalability, accessibility and availability. Software container technologies will be utilized to provide self-deployment of microservices.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Design of a programming paradigms course using one single programming language\n", "abstract": " Undergraduate students of a Software Engineering degree must be able to select the appropriate paradigm to solve a problem. They must also be able to know the foundations of concurrent and parallel programming. In the Software Engineering degree taught in the University of Oviedo, both competencies were assigned to the Programming Technology and Paradigms course. In this article, we present the approach we followed in the design of that course to teach object-oriented, functional, concurrent and parallel programming to second year undergraduate students with basic knowledge of Java. Due to the time limitations of the course, the proposed design uses one single programming language besides Java. We describe the most important challenges we faced and how we addressed them.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Efficient Aspect Weaver for the. Net Platform\n", "abstract": " Aspect-oriented programming provides better modularization of applications by encapsulating crosscutting concerns into aspects, solving the code scattering and tangling problems. However, the additional code added to achieve static and dynamic aspect weaving commonly involves runtime performance and memory consumption penalties. Consequently, we propose different techniques to optimize both static and dynamic aspect weaving, implementing those techniques in the .NET platform, which does not support the runtime replacement of class implementations. To evaluate the efficiency of our approach, we measure the execution time and memory consumption of four different aspect-oriented applications. Our platform provides the best performance for both static and dynamic weaving, and its weaving cost is the lowest one. Moreover, the proposed optimizations consume less memory resources than the\u00a0\u2026", "num_citations": "3\n", "authors": ["2139"]}
{"title": "TyS-A Framework to Facilitate the Implementation of Object-Oriented Type Checkers.\n", "abstract": " Type systems are mainly aimed at providing the absence of erroneous behaviors. Their formalization is commonly used to prove specific safety properties, but those formal specifications are not usually used to implement the language. Once a type system has been proven to be sound, a type checker must be developed in the implementation of the language processor. In this article we present TyS, a framework to facilitate the implementation of type checkers, following widely known object-oriented design patterns. TyS processes a type system specification file, generating the implementation of the corresponding type checker. The generated code relies on an API provided by the framework, and it can be reutilized by the rest of components and tools used in the language implementation. TyS has been used with different lexer and parser tools, developing both dynamic and static type systems.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Separating different responsibilities into parallel hierarchies\n", "abstract": " The Tease Apart Inheritance is a big refactoring technique used to separate different responsibilities tangled along a class hierarchy. This refactorization associates two parallel hierarchies through their roots in order to use one from the other. The interface of the root class in the used hierarchy is commonly too general to be employed by the classes below in the parallel hierarchy, where a more specific behavior is needed. This paper describes a design that, using two parallel class hierarchies, allows recovering the specific interface of each corresponding class in the parallel hierarchy, improving the collaboration between both hierarchies. Although different implementations of the proposed design are discussed, the use of generics offers the robustness of static type checking and better runtime performance.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Computational Reflection in order to support Context-Awareness in a Robotics Framework\n", "abstract": " The development of service robots has gained more and more attention over the last years. Advanced robots have to cope with many different emerging at runtime situations, while executing complex tasks. They should be programmed as contextaware systems, capable of adapting themselves to the execution environment, including the computing, user and physical environment. Since computational reflection is a programming language technique that offers a high level of runtime adaptability, we have analyzed the suitability of this language feature to fulfill the dynamism requirements of context-aware robotic systems. In order to evaluate their appropriateness, we have implemented an example scenario in a dynamic reflective language and compared it with Java.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "A Programming Language to Facilitate the Transition from Rapid Prototyping to Efficient Software Production.\n", "abstract": " Dynamic languages are becoming increasingly popular for developing different kinds of applications, being rapid prototyping one of the scenarios where they are widely used. The dynamism offered by dynamic languages is, however, counteracted by two main limitations: no early type error detection and fewer opportunities for compiler optimizations. To obtain the benefits of both dynamically and statically typed languages, we have designed the StaDyn programming language to provide both approaches. Our language implementation keeps gathering type information at compile time, even when dynamic references are used. This type information is used to offer compile-time type error detection, direct interoperation between static and dynamic code, and better runtime performance. Following the Separation of Concerns principle, dynamically typed references can be easily turned into statically typed ones without changing the application source code, facilitating the transition from rapid prototyping to efficient software production. This paper describes the key techniques used in the implementation of StaDyn to obtain these benefits.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "The StaDyn core type system\n", "abstract": " Although static typing provides early type error detection, better legibility and abstraction, and more opportunities for compiler optimizations, dynamic typing supplies a high degree of runtime adaptiveness, providing an agile and interactive development suitable for rapid prototyping. In this article, the minimal core type system of a programming language which main aim is to provide the benefits of both dynamic and static typing is presented. Keeping explicit typing, implicit type inference is introduced to combine dynamic and static typing in the same programming language. Union and intersection types are customized to express the dynamism of implicitly typed references. The main benefits of our work are early type error detection even in dynamic code, the integration of dynamic and static code in the same programming language, and a notable optimization of the generated code.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Applying lightweight flexible virtual machines to extensible embedded systems\n", "abstract": " Virtual Machines are spreading from the desktop to other domains. Embedded Systems is a domain where the benefits of Virtual Machines such as portability or software-based isolation can be of much help. However, for highly dynamical, extensible systems we believe that the key features needed in a VM to succeed in the domain are flexibility and lightweightness, and that reflection and a VM reduced instruction set are the means to achieve this. In this paper we briefly describe two VMs built in our research group with the before mentioned properties that could be evolved for the embedded systems domain: The Carbayonia and the nitrO Abstract Machines.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Supporting both static and dynamic typing\n", "abstract": " Dynamic languages are becoming increasingly popular for developing different kinds of applications such as adaptable and adaptive software, Web development, application frameworks, game engines, interactive programming, rapid prototyping, and dynamic aspect-oriented programming. These languages are built on the Smalltalk idea of supporting reasoning about (and customizing) program structure, behavior and environment at runtime. That is the reason why this trend is commonly referred to as the revival of dynamic languages.Dynamism obtained by dynamic typing is, however, counteracted by two main limitations: early type error detection and runtime performance. To obtain the benefits of both dynamic and static typing, we have designed a programming language that provides both approaches. Following the Separation of Concerns principle, our programming language provides both dynamic and static typing. It is possible to customize the trade-off between runtime flexibility of dynamic typing and safety, performance and robustness of static typing. Moreover, the source code of the application stays unchanged. This paper presents an overview of the StaDyn programming language.", "num_citations": "3\n", "authors": ["2139"]}
{"title": "Cnerator: A Python application for the controlled stochastic generation of standard C source code\n", "abstract": " The Big Code and Mining Software Repositories research lines analyze large amounts of source code to improve software engineering practices. Massive codebases are used to train machine learning models aimed at improving the software development process. One example is decompilation, where C code and its compiled binaries can be used to train machine learning models to improve decompilation. However, obtaining massive codebases of portable C code is not an easy task, since most applications use particular libraries, operating systems, or language extensions. In this paper, we present Cnerator, a Python application that provides the stochastic generation of large amounts of standard C code. It is highly configurable, allowing the user to specify the probability distributions of each language construct, properties of the generated code, and post-processing modifications of the output programs\u00a0\u2026", "num_citations": "2\n", "authors": ["2139"]}
{"title": "Towards the Integration of Metaprogramming Services into Java.\n", "abstract": " Dynamic languages are widely used in scenarios where runtime adaptability is a strong requirement. The metaprogramming features provided by these languages allow the dynamic adaptation of the structure of classes and objects, together with the evaluation of dynamically generated code. These features are used to build software capable of adapting to runtime changing environments. However, this flexibility is counteracted with the lack of static type checking provided by statically typed languages such as Java. Static type checking supports the earlier detection of type errors, involving a valuable tool in software development. In this position paper, we describe the steps we are following to add some runtime metaprogramming services to Java. We intend to provide the runtime flexibility of structural intercession and dynamic code evaluation provided by most dynamic languages, without losing the robustness of the compile-time type checking of Java. The metaprogramming services are provided as a library so, unlike other existing systems, any standard virtual machine and language compiler could be used.", "num_citations": "2\n", "authors": ["2139"]}
{"title": "Towards a java library to support runtime metaprogramming\n", "abstract": " Statically typed languages such as Java offer two key advantages: robustness increase due to compile time error detection, and better runtime performance caused by the reduction of runtime type checking. However, dynamic languages are sometimes preferred in scenarios where runtime adaptability is a strong requirement, such as building software capable of adapting to runtime changing environments. The metaprogramming features of dynamic languages allow the runtime adaptation of class and object structures, modifying inheritance relationships, and the evaluation of dynamically generated code. In this position paper, we describe the steps we are following to add to Java some of the metaprogramming services provided by most dynamic languages. The objective is to provide the runtime flexibility of structural intercession, dynamic inheritance and dynamic code evaluation, without losing the\u00a0\u2026", "num_citations": "2\n", "authors": ["2139"]}
{"title": "Static type information to improve the IDE features of hybrid dynamically and statically typed languages\n", "abstract": " The flexibility offered by dynamically typed programming languages has been appropriately used to develop specific scenarios where dynamic adaptability is an important issue. This has made some existing statically typed languages gradually incorporate more dynamic features to their implementations. As a result, there are some programming languages considered hybrid dynamically and statically typed. However, these languages do not perform static type inference on a dynamically typed code, lacking those common features provided when a statically typed code is used. This lack is also present in the corresponding IDEs that, when a dynamically typed code is used, do not provide the services offered for static typing. We have customized an IDE for a hybrid language that statically infers type information of dynamically typed code. By using this type information, we show how the IDE can provide a set of\u00a0\u2026", "num_citations": "2\n", "authors": ["2139"]}
{"title": "A programming tool to ease modular programming with C++\n", "abstract": " Module management support is very rough in the C and C++ programming languages. Modules must be separated in interface and implementation files, which will store declarations and definitions, respectively. Ultimately, only text substitution tools are available, by means of the C/C++ preprocessor, which is able to insert an interface file in a given point of a translation unit. This way of managing modules does not take into account aspects like duplicated inclusions, or proper separation of declarations and definitions, just to name a few. While the seasoned programmer will find this characteristic of the language annoying and error-prone, students will find it not less than challenging. In this document, a tool specially designed for improving the support of modules in C++ is presented. Its main advantage is that it makes it easier to manage large, module-based projects, while still allowing to use classic translation\u00a0\u2026", "num_citations": "2\n", "authors": ["2139"]}
{"title": "Diseno de primitivas de reflexi\u00f3n estructural eficientes integradas en SSCLI\n", "abstract": " Los lenguajes din\u00e1micos permiten a los programas una mayor flexibilidad y adaptabilidad en tiempo de ejecuci\u00f3n, siendo cada vez m\u00e1s utilizados en el desarrollo de aplicaciones Web entre otros escenarios. No obstante su aplicaci\u00f3n a otros contextos suele verse relegada principalmente por sus carencias de rendimiento. La compilaci\u00f3n bajo demanda sobre m\u00e1quinas virtuales es una t\u00e9cnica ampliamente utilizada actualmente, pero no en entornos de procesamiento de lenguajes din\u00e1micos. Hemos usado esta t\u00e9cnica junto a la plataforma. Net para poder ejecutar lenguajes din\u00e1micos de forma nativa, obteniendo buenos resultados de rendimiento que abren una v\u00eda para poder aplicar estos lenguajes en nuevos escenarios de ingenier\u00eda del software.", "num_citations": "2\n", "authors": ["2139"]}
{"title": "BDOviedo3: Data XML storage and management\n", "abstract": " OOBDMS provide a good solution for the management of XML documents. This article shows the different approach (specific and generic) of coupling an object model with XML and emphasizes the possibilities offered by BDOviedo3 system. It is an object-oriented database built over an integral object- oriented system. The flexibility provided by its object-oriented construction and the extensibility of its mechanisms (such as indexing) can transform it into a XML document manager.", "num_citations": "2\n", "authors": ["2139"]}
{"title": "Sistema computacional de programaci\u00f3n flexible dise\u00f1ado sobre una m\u00e1quina abstracta reflectiva no restrictiva\n", "abstract": " Este tesis describe el modo en el que distintas t\u00e9cnicas de reflectividad pueden ser empleadas para el desarrollo de un sistema computacional de programaci\u00f3n extensible y adaptable din\u00e1micamente, sin sufrir dependencia alguna de un lenguaje de programaci\u00f3n espec\u00edfico, y empleando para ello una plataforma virtual heterog\u00e9nea. Se dise\u00f1a una m\u00e1quina abstracta, de tama\u00f1o y complejidad sem\u00e1ntica reducida, como la ra\u00edz computacional del sistema, que otorgue primitivas b\u00e1sicas de reflectividad. Tanto su tama\u00f1o restringido como su capacidad introspectiva, la hacen susceptible de ser implantada en entornos computacionales heterog\u00e9neos, constituyendo adem\u00e1s un entorno computacional independiente de la plataforma. Haciendo uso de las facultades reflectivas ofrecidas por la m\u00e1quina abstracta, su nivel de abstraci\u00f3n computacional podr\u00e1 ser extendido en su propio lenguaje de programaci\u00f3n, sin necesidad de modificar la implementaci\u00f3n reducida de la m\u00e1quina virtual, y sin perder as\u00ed la portabilidad de su c\u00f3digo. El empleo de su capacidad extensible se utilizar\u00e1, a modo de ejemplo, en el dise\u00f1o de abstracciones propias de persistencia, distribuci\u00f3n, planficaci\u00f3n controlada de hilos y recolecci\u00f3n de basura. Todas las abstracciones ofrecidas mediante la extensi\u00f3n de la plataforma en su propio lenguaje, son adaptables para cualquier aplicaci\u00f3n, en tiempo de ejecuci\u00f3n. Un sistema de procesamiento gen\u00e9rico de lenguajes es dise\u00f1ado disponiendo de las caracter\u00edsticas reflectivas de la plataforma, dando lugar a una independencia global del lenguaje de programaci\u00f3n seleccionado por el programador. Cualquier aplicaci\u00f3n\u00a0\u2026", "num_citations": "2\n", "authors": ["2139"]}
{"title": "Association rules obtained from the dataset described in Improving type information inferred by decompilers with supervised machine learning\n", "abstract": " This technical report is a support document for the article Improving type information inferred by decompilers with supervised machine learning, written by Javier Escalada, Ted Scully and Francisco Ortin [1].This document shows a complete set of valid association rules that correlate RET and POST CALL patterns (Section 4.3. 1 of [1]) with the high-level return type of functions (Section 6.2 of [1]). The rules analyzed in Section 7 of [1]) are a condensed version of some of these rules.", "num_citations": "1\n", "authors": ["2139"]}
{"title": "Graph Representations used in the design of ProgQuery\n", "abstract": " This technical report is a support document for the article Efficient and Scalable Platform for Java Source Code Analysis using Overlaid Graph Representations, written by Oscar Rodriguez- Prieto, Alan Mycroft and Francisco Ortin.", "num_citations": "1\n", "authors": ["2139"]}
{"title": "Rule-based program specialization to optimize gradually typed code\n", "abstract": " Both static and dynamic typing provide different benefits to the programmer. Statically typed languages support earlier type error detection and more opportunities for compiler optimizations. Dynamically typed languages facilitate the development of runtime adaptable applications and rapid prototyping. Since both approaches provide benefits, gradually typed languages support both typing approaches in the very same programming language. Gradual typing has been an active research field in the last years, turning out to be a strong influence on commercial languages. However, one important drawback of gradual typing is the runtime performance cost of the additional type checks performed at runtime.In this article, we propose a rule-based program specialization mechanism to provide significant performance optimizations of gradually typed code. Our system gathers dynamic type information of the application by\u00a0\u2026", "num_citations": "1\n", "authors": ["2139"]}
{"title": "Efficient runtime aspect weaving for java applications\n", "abstract": " ContextThe aspect-oriented paradigm is aimed at solving the code scattering and tangling problem, providing new mechanisms to support better separation of concerns. For specific scenarios where high runtime adaptability is an important requirement, dynamic Aspect-Oriented Programming (AOP) represents a useful tool. With dynamic AOP, components and aspects can be woven and unwoven at runtime, enabling applications greater responsiveness when dealing with different or changing requirements. However, this responsiveness typically incurs a cost in terms of runtime performance and memory consumption.ObjectiveBuild an efficient dynamic aspect weaver for Java that provides the best runtime performance compared to the existing approaches, minimum memory overhead consumption, and similar functionalities to the widespread runtime weavers.MethodWe design and implement weaveJ, a dynamic\u00a0\u2026", "num_citations": "1\n", "authors": ["2139"]}
{"title": "Int\u00e9rpretes y Dise\u00f1o de Lenguajes de Programaci\u00f3n\n", "abstract": " Los compiladores, a diferencia de los int\u00e9rpretes, transforman el programa a un programa equivalente en un c\u00f3digo objeto (fase de compilaci\u00f3n), y en un segundo paso generan los resultados a partir de los datos de entrada (fase de ejecuci\u00f3n).", "num_citations": "1\n", "authors": ["2139"]}
{"title": "Building a Completely Adaptable Reflective System\n", "abstract": " Reflection is one of the main techniques used to develop adaptable systems and, currently, different kinds of reflective systems exist. Compile-time reflection systems provide the ability to customize their language but they are not adaptable at runtime. On the other hand, runtime reflection systems define metaobject protocols to customize the system semantics at runtime. However, these meta-object protocols restrict the way a system may be adapted before its execution, and they do not permit the customization of its language.Our system implements a non-restrictive reflection mechanism over a virtual machine, in which every feature may be adapted at runtime. No meta-object protocol is used and, therefore, it is not needed to specify previously what may be reflected. With our reflective system, the programming language may be also customized at runtime.", "num_citations": "1\n", "authors": ["2139"]}
{"title": "BDOviedo3 an Object-Oriented DBMS Incorporated to an Integral Object-Oriented System\n", "abstract": " The aim of this paper is to show the work in the field of databases within the Oviedo31 research project. The scope is the construction of an object-oriented database management system (OODBMS), called BDOviedo3, that is highly integrated with a persistent object-oriented abstract machine and an object-oriented operating system. We describe the major modules in which the OODBMS has been structured: engine, languages and tools. Besides, the indexing in OODBMS is analyzed and some features for the indexing mechanism of BDOviedo3 system are presented.", "num_citations": "1\n", "authors": ["2139"]}
{"title": "APLICACI\u00d3N DE UNA VARIANTE DEL APRENDIZAJE BASADO EN PROYECTOS EN UN CURSO INTRODUCTORIO DE INGENIER\u00cdA ELECTR\u00d3NICA\n", "abstract": " Este trabajo describe la implementaci\u00f3n de una variante del m\u00e9todo de ense\u00f1anza conocido con el nombre de Aprendizaje Basado en Proyectos (ABP o PBL, por sus siglas en ingl\u00e9s) en un curso introductorio de ingenier\u00eda electr\u00f3nica. Mediante este m\u00e9todo los estudiantes aprenden a trabajar en equipo para dise\u00f1ar un proyecto integrador, tomando decisiones y colaborando entre ellos. En la variante del m\u00e9todo presentada en este trabajo se han incorporado adicionalmente m\u00f3dulos independientes en forma de trabajos pr\u00e1cticos, que permiten a los estudiantes ir aprendiendo de manera ordenada y sistem\u00e1tica. Los resultados han mostrado ser alentadores tanto respecto del entusiasmo de los estudiantes como de su aprendizaje.", "num_citations": "1\n", "authors": ["2139"]}