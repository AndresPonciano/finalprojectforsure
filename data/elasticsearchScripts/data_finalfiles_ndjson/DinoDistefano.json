{"title": "jStar: Towards practical verification for Java\n", "abstract": " In this paper we introduce a novel methodology for verifying a large set of Java programs which builds on recent theoretical developments in program verification: it combines the idea of abstract predicate families and the idea of symbolic execution and abstraction using separation logic. The proposed technology has been implemented in a new automatic verification system, called jStar, which combines theorem proving and abstract interpretation techniques. We demonstrate the effectiveness of our methodology by using jStar to verify example programs implementing four popular design patterns (subject/observer, visitor, factory, and pooling). Although these patterns are extensively used by object-oriented developers in real-world applications, so far they have been highly challenging for existing object-oriented verification techniques.", "num_citations": "326\n", "authors": ["672"]}
{"title": "Infer: An automatic program verifier for memory safety of C programs\n", "abstract": " Infer is a new automatic program verification tool aimed at proving memory safety of C programs. It attempts to build a compositional proof of the program at hand by composing proofs of its constituent modules (functions/procedures). Bugs are extracted from failures of proof attempts. We describe the main features of Infer and some of the main ideas behind it.", "num_citations": "173\n", "authors": ["672"]}
{"title": "Bi-abductive resource invariant synthesis\n", "abstract": " We describe an algorithm for synthesizing resource invariants that are used in the verification of concurrent programs. This synthesis employs bi-abductive inference to identify the footprints of different parts of the program and decide what invariant each lock protects. We demonstrate our algorithm on several small (yet intricate) examples which are out of the reach of other automatic analyses in the literature.", "num_citations": "46\n", "authors": ["672"]}
{"title": "Runtime verification based on register automata\n", "abstract": " We propose TOPL automata as a new method for runtime verification of systems with unbounded resource generation. Paradigmatic such systems are object-oriented programs which can dynamically generate an unbounded number of fresh object identities during their execution. Our formalism is based on register automata, a particularly successful approach in automata over infinite alphabets which administers a finite-state machine with boundedly many input-storing registers. We show that TOPL automata are equally expressive to register automata and yet suitable to express properties of programs. Compared to other runtime verification methods, our technique can handle a class of properties beyond the reach of current tools. We show in particular that properties which require value updates are not expressible with current techniques yet are naturally captured by TOPL machines. On the practical side\u00a0\u2026", "num_citations": "41\n", "authors": ["672"]}
{"title": "System and method for display of software quality\n", "abstract": " A method for code analysis comprising steps of inputting program code to an analyzer, assigning an objective quality measure to components of the analyzed code; and displaying graphically the objective quality measures.", "num_citations": "36\n", "authors": ["672"]}
{"title": "coreStar: The core of jStar\n", "abstract": " Separation logic is a promising approach to program verification. However, currently there is no shared infrastructure for building verification tools. This increases the time to build and experiment with new ideas. In this paper, we outline coreStar, the verification framework underlying jStar. Our aim is to provide basic support for developing separation logic tools. This paper shows how a language can be encoded into coreStar, and gives details of how coreStar works to enable extensions.", "num_citations": "33\n", "authors": ["672"]}
{"title": "Memory leaks detection in java by bi-abductive inference\n", "abstract": " This paper describes a compositional analysis algorithm for statically detecting leaks in Java programs. The algorithm is based on separation logic and exploits the concept of bi-abductive inference for identifying the objects which are reachable but no longer used by the program.", "num_citations": "24\n", "authors": ["672"]}
{"title": "On model checking the dynamics of object-based software\n", "abstract": " Software verification aims to prove that a given software artifact behaves according to the original intentions of its designer. If we exclude some classical toy examples such as \u201cHello world\u201d or some very specific and well-studied routines reported in every introductory book to programming, such as binary search or sorting algorithms, it is well-known that every software product has bugs and therefore misbehaves. This statement seems to be valid regardless from the programming paradigm used. It was true at the time when assembly languages were employed, and it is still valid nowadays where the object-oriented paradigm is manifestly dominating the world software development scene. The object-oriented methodology has undoubtedly contributed with remarkable improvements in the software development process, but unfortunately it does not represent the ultimate solution. Also object-oriented software is buggy. This is of course not because of a weakness of the object-oriented methodology itself, it is simply a natural consequence of the fact that humans make mistakes. The work carried out in this thesis lies in this rather general context: verification of object-oriented systems. Among the different methodologies studied for software verification, we follow model checking [29], a formal technique which has been shown very successful in other fields such as hardware verification. The application of model checking technology consists of three major phases: modelling, property specification, and verification. In the modelling phase, one constructs a formal model of the system\u2014either manually or automatically", "num_citations": "22\n", "authors": ["672"]}
{"title": "Attacking large industrial code with bi-abductive inference\n", "abstract": " In joint work with Cristiano Calcagno, Peter O\u2019Hearn, and Hongseok Yang, we have introduced bi-abductive inference and its use in reasoning about heap manipulating programs [5]. This extended abstract briefly surveys the key concepts and describes our experience in the application of bi-abduction to real-world applications and systems programs of over one million lines of code.", "num_citations": "14\n", "authors": ["672"]}
{"title": "A parametric model for the analysis of mobile ambients\n", "abstract": " In this paper we propose a new parametric abstract finite model of Mobile Ambients able to express several properties on processes. The model can be used for the analysis of these properties by means of model checking techniques. The precision of the model can be increased by modifying certain numeric parameters increasingly avoiding thereby the occurrences of false counterexamples in the analysis.", "num_citations": "8\n", "authors": ["672"]}
{"title": "jStar-Eclipse: an IDE for automated verification of Java programs\n", "abstract": " jStar is a tool for automatically verifying Java programs. It uses separation logic to support abstract reasoning about object specifications. jStar can verify a number of challenging design patterns, including Subject/Observer, Visitor, Factory and Pooling. However, to use jStar one has to deal with a family of command-line tools that expect specifications in separate files and diagnose the errors by inspecting the text output from these tools.", "num_citations": "5\n", "authors": ["672"]}
{"title": "TOPL: A language for specifying safety temporal properties of object-oriented programs\n", "abstract": " In this paper we present ongoing work related to a new specification language for temporal safety properties aimed at object-oriented software. The language naturally captures relationships between objects and it is designed with the goal of performing dynamic and static analysis. We present its formal semantics as well as several examples showing its expressivity.", "num_citations": "4\n", "authors": ["672"]}
{"title": "How to verify java program with jstar: a tutorial\n", "abstract": " In this tutorial we describe how to use the tool jStar to verify Java programs. The document is meant to be an informal and basic introduction to jStar and many of the key notions behind this tool.", "num_citations": "3\n", "authors": ["672"]}
{"title": "Static Resource Analysis at Scale\n", "abstract": " Programs inevitably contain bugs. Fortunately, recent research and engineering efforts across the industry and academia made significant advances in static analysis techniques allowing automatic detection of bugs that cause a program to crash or to produce an unintended result. In many settings, it is not enough for a program to execute without errors. Programs must also finish executing within expected resource bounds and adhere to a sensible resource usage. At the very least, we expect the resource usage of programs to not deteriorate significantly as the source code evolves, hurting the experience of the users or even making the program unusable.There are many static analysis techniques for estimating and verifying the resource usage of a program, ranging from static worst-case execution time (WCET) analyses (see [13] for a detailed survey) to typed-based approaches and program logics [2, 5\u20137, 10\u201312\u00a0\u2026", "num_citations": "1\n", "authors": ["672"]}