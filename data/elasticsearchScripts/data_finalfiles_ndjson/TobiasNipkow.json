{"title": "Isabelle/HOL: a proof assistant for higher-order logic\n", "abstract": " This volume is a self-contained introduction to interactive proof in high-order logic (HOL), using the proof assistant Isabelle 2002. Compared with existing Isabelle documentation, it provides a direct route into higher-order logic, which most people prefer these days. It bypasses? rst-order logic and minimizes discussion of meta-theory. It is written for potential users rather than for our colleagues in the research world. Another departure from previous documentation is that we describe Markus Wenzel\u2019s proof script notation instead of ML tactic scripts. The l-ter make it easier to introduce new tactics on the? y, but hardly anybody does that. Wenzel\u2019s dedicated syntax is elegant, replacing for example eight simpli? cation tactics with a single method, namely simp, with associated-tions. The book has three parts.\u2013The? rst part, Elementary Techniques, shows how to model functional programs in higher-order logic. Early examples involve lists and the natural numbers. Most proofs are two steps long, consisting of induction on a chosen variable followed by the auto tactic. But even this elementary part covers such advanced topics as nested and mutual recursion.\u2013The second part, Logic and Sets, presents a collection of lower-level tactics that you can use to apply rules selectively. It also describes I-belle/HOL\u2019s treatment of sets, functions, and relations and explains how to de? ne sets inductively. One of the examples concerns the theory of model checking, and another is drawn from a classic textbook on formal languages.", "num_citations": "4252\n", "authors": ["1784"]}
{"title": "Term rewriting and all that\n", "abstract": " This textbook offers a unified, self-contained introduction to the field of term rewriting. Baader and Nipkow cover all the basic material--abstract reduction systems, termination, confluence, completion, and combination problems--but also some important and closely connected subjects: universal algebra, unification theory, Gr\u00f6bner bases, and Buchberger's algorithm. They present the main algorithms both informally and as programs in the functional language Standard ML (An appendix contains a quick and easy introduction to ML). Key chapters cover crucial algorithms such as unification and congruence closure in more depth and develop efficient Pascal programs. The book contains many examples and over 170 exercises. This is also an ideal reference book for professional researchers: results spread over many conference and journal articles are collected here in a unified notation, detailed proofs of almost all theorems are provided, and each chapter closes with a guide to the literature.", "num_citations": "3841\n", "authors": ["1784"]}
{"title": "Higher-order critical pairs\n", "abstract": " We consider rewrite systems over simply typed \u03bb-terms with restricted left-hand sides. This gives rise to a one-step reduction relation whose transitive, reflexive and symmetric closure coincides with equality. The main result of this paper is a decidable confluence criterion which extends the well-known critical pairs to a higher-order setting. Several applications to typed \u03bb-calculi and proof theory are shown.", "num_citations": "398\n", "authors": ["1784"]}
{"title": "Nitpick: A counterexample generator for higher-order logic based on a relational model finder\n", "abstract": " Nitpick is a counterexample generator for Isabelle/HOL that builds on Kodkod, a SAT-based first-order relational model finder. Nitpick supports unbounded quantification, (co)inductive predicates and datatypes, and (co)recursive functions. Fundamentally a finite model finder, it approximates infinite types by finite subsets. As case studies, we consider a security type system and a hotel key card system. Our experimental results on Isabelle theories and the TPTP library indicate that Nitpick generates more counterexamples than other model finders for higher-order logic, without restrictions on the form of the formulas to falsify.", "num_citations": "286\n", "authors": ["1784"]}
{"title": "Code generation via higher-order rewrite systems\n", "abstract": " We present the meta-theory behind the code generation facilities of Isabelle/HOL. To bridge the gap between the source (higher-order logic with type classes) and the many possible targets (functional programming languages), we introduce an intermediate language, Mini-Haskell. To relate the source and the intermediate language, both are given a semantics in terms of higher-order rewrite systems (HRSs). In a second step, type classes are removed from Mini-Haskell programs by means of a dictionary translation; we prove the correctness of this step. Building on equational logic also directly supports a simple but powerful algorithm and data refinement concept.", "num_citations": "284\n", "authors": ["1784"]}
{"title": "Java light is type-safe\u2014definitely\n", "abstract": " Java light is a large sequential sublanguage of Java. We formalize its abstract syntax, type system, well-formedness conditions, and an operational evaluation semantics. Based on this formalization, we can express and prove type soundness. All definitions and proofs have been done formally in the theorem prover Isabelle/HOL. Thus this paper demonstrates that machine-checking the design of non-trivial programming languages has become a reality.", "num_citations": "258\n", "authors": ["1784"]}
{"title": "Higher-order rewrite systems and their confluence\n", "abstract": " We study higher-order rewrite systems (HRSs) which extend term rewriting to \u03bb-terms. HRSs can describe computations over terms with bound variables. We show that rewriting with HRSs is closely related to undirected equational reasoning. We define pattern rewrite systems (PRSs) as a special case of HRSs and extend three confluence results from term rewriting to PRSs: the critical pair lemma by Knuth and Bendix, confluence of rewriting modulo equations \u00e0 la Huet, and confluence of orthogonal PRSs.", "num_citations": "253\n", "authors": ["1784"]}
{"title": "Functional unification of higher-order patterns\n", "abstract": " The complete development of a unification algorithm for so-called higher-order patterns, a subclass of lambda -terms, is presented. The starting point is a formulation of unification by transformation, and the result a directly executable functional program. In a final development step, the result is adapted to lambda -terms in de Bruijn's (1972) notation. The algorithms work for both simply typed and untyped terms.< >", "num_citations": "174\n", "authors": ["1784"]}
{"title": "The isabelle framework\n", "abstract": " Isabelle, which is available from                                         http://isabelle.in.tum.de                                                       , is a generic framework for interactive theorem proving. The Isabelle/Pure meta-logic allows the formalization of the syntax and inference rules of a broad range of object-logics following the general idea of natural deduction [32,33]. The logical core is implemented according to the well-known \u201cLCF approach\u201d of secure inferences as abstract datatype constructors in ML [16]; explicit proof terms are also available [8]. Isabelle/Isar provides sophisticated extra-logical infrastructure supporting structured proofs and specifications, including concepts for modular theory development. Isabelle/HOL is a large application within the generic framework, with plenty of logic-specific add-on tools and a large theory library. Other notable object-logics are Isabelle/ZF (Zermelo-Fraenkel set-theory, see [34,36] and\u00a0\u2026", "num_citations": "173\n", "authors": ["1784"]}
{"title": "Machine-checking the Java specification: Proving type-safety\n", "abstract": " In this article we present Bali, the formalization of a large (hitherto sequential) sublanguage of Java. We give its abstract syntax, type system, well-formedness conditions, and an operational evaluation semantics. Based on these definitions, we can express soundness of the type system, an important design goal claimed to be reached by the designers of Java, and prove that Bali is indeed type-safe.               All definitions and proofs have been done formally in the theorem prover Isabelle/HOL. Thus this article demonstrates that machine-checking the design of non-trivial programming languages has become a reality.", "num_citations": "153\n", "authors": ["1784"]}
{"title": "Sledgehammer: judgement day\n", "abstract": " Sledgehammer, a component of the interactive theorem prover Isabelle, finds proofs in higher-order logic by calling the automated provers for first-order logic E, SPASS and Vampire. This paper is the largest and most detailed empirical evaluation of such a link to date. Our test data consists of 1240 proof goals arising in 7 diverse Isabelle theories, thus representing typical Isabelle proof obligations. We measure the effectiveness of Sledgehammer and many other parameters such as run time and complexity of proofs. A facility for minimizing the number of facts needed to prove a goal is presented and analyzed.", "num_citations": "143\n", "authors": ["1784"]}
{"title": "Structured proofs in Isar/HOL\n", "abstract": " Isar is an extension of the theorem prover Isabelle with a language for writing human-readable structured proofs. This paper is an introduction to the basic constructs of this language.", "num_citations": "136\n", "authors": ["1784"]}
{"title": "Executing higher order logic\n", "abstract": " We report on the design of a prototyping component for the theorem prover Isabelle/HOL. Specifications consisting of datatypes, recursive functions and inductive definitions are compiled into a functional program. Functions and inductively defined relations can be mixed. Inductive definitions must be such that they can be executed in Prolog style but requiring only matching rather than unification. This restriction is enforced by a mode analysis. Tail recursive partial functions can be defined and executed with the help of a while combinator.", "num_citations": "136\n", "authors": ["1784"]}
{"title": "Boolean unification-the story so far\n", "abstract": " Boolean unification - The story so far | Journal of Symbolic Computation ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Journal of Symbolic Computation Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsJournal of Symbolic ComputationVol. , No. -4Boolean unification - The story so far article Boolean unification - The story so far Share on Authors: Ursula Martin profile image Urusula Martin Department of Computer Science, RHBNC, University of LondonEgham, Surrey TW20 0EX, UK and MIT Laboratory for Computer Science, 545 Technology Square, Cambridge MA 02139, USA Department of Computer Science, RHBNC, University of \u2026", "num_citations": "135\n", "authors": ["1784"]}
{"title": "Non-deterministic data types: Models and implementations\n", "abstract": " The model theoretic basis for (abstract) data types is generalized from algebras to multi-algebr as in order to cope with non-deterministic operations. A programming oriented definition and a model theoretic criterion (called simulation) for implementation of data types are given. To justify the criterion w.r.t. the definition, an abstract framework linking denotational semantics of programming languages and model theory of data types is set up. A set of constraints on a programming language semantics are derived which guarantee that simulation implies implementation. It is argued that any language supporting data abstraction does fulfill these constraints. As an example a simple but expressive language L is defined and it is formally proved that L does conform to these restrictions.", "num_citations": "130\n", "authors": ["1784"]}
{"title": "Hoare logic for NanoJava: Auxiliary variables, side effects, and virtual methods revisited\n", "abstract": " We define NanoJava, a kernel of Java tailored to the investigation of Hoare logics. We then introduce a Hoare logic for this language featuring an elegant approach for expressing auxiliary variables: by universal quantification on the outer logical level. Furthermore, we give simple means of handling side-effecting expressions and dynamic binding within method calls. The logic is proved sound and (relatively) complete using Isabelle/HOL.", "num_citations": "126\n", "authors": ["1784"]}
{"title": "Automatic proof and disproof in Isabelle/HOL\n", "abstract": " Isabelle/HOL is a popular interactive theorem prover based on higher-order logic. It owes its success to its ease of use and powerful automation. Much of the automation is performed by external tools: The metaprover Sledgehammer relies on resolution provers and SMT solvers for its proof search, the counterexample generator Quickcheck uses the ML compiler as a fast evaluator for ground formulas, and its rival Nitpick is based on the model finder Kodkod, which performs a reduction to SAT. Together with the Isar structured proof format and a new asynchronous user interface, these tools have radically transformed the Isabelle user experience. This paper provides an overview of the main automatic proof and disproof tools.", "num_citations": "118\n", "authors": ["1784"]}
{"title": "Random testing in Isabelle/HOL\n", "abstract": " When developing non-trivial formalizations in a theorem prover, a considerable amount of time is devoted to \u201cdebugging\u201d specifications and conjectures by failed proof attempts. To detect such problems early in the proof and save development time, we have extended the Isabelle theorem prover with a tool for testing specifications by evaluating propositions under an assignment of random values to free variables. Distribution of the test data is optimized via mutation testing. The technical contributions are an extension of earlier work with inductive definitions and a generic method for randomly generating elements of recursive datatypes.", "num_citations": "114\n", "authors": ["1784"]}
{"title": "Winskel is (almost) right: Towards a mechanized semantics textbook\n", "abstract": " We present a formalization of the first 100 pages of Winskel's textbook The Formal Semantics of Programming Languages in the theorem prover Isabelle/HOL: 2 operational, 2 denotational, 2 axiomatic semantics, a verification condition generator, and the necessary soundness, completeness and equivalence proofs, all for a simple imperative programming language.", "num_citations": "114\n", "authors": ["1784"]}
{"title": "Holcf= hol+ lcf\n", "abstract": " HOLCF is the definitional extension of Church's Higher-Order Logic with Scott's Logic for Computable Functions that has been implemented in the theorem prover Isabelle. This results in a flexible setup for reasoning about functional programs. HOLCF supports standard domain theory (in particular fixpoint reasoning and recursive domain equations), but also coinductive arguments about lazy datatypes. This paper describes in detail how domain theory is embedded in HOL, and presents applications from functional programming, concurrency and denotational semantics.", "num_citations": "101\n", "authors": ["1784"]}
{"title": "Isabelle tutorial and user\u2019s manual\n", "abstract": " This (obsolete!) manual describes how to use the theorem prover Isabelle. For beginners, it explains how to perform simple single-step proofs in the built-in logics. These include first-order logic, a classical sequent calculus, ZF set theory, Constructie Type Theory, and higher-order logic. Each of these logics is described. The manual then explains how to develop advanced tactics and tacticals and how to derive rules. Finally, it describes how to define new logics within Isabelle.", "num_citations": "99\n", "authors": ["1784"]}
{"title": "Proving pointer programs in higher-order logic\n", "abstract": " This paper develops sound modelling and reasoning methods for imperative programs with pointers: heaps are modelled as mappings from addresses to values, and pointer structures are mapped to higher-level data types for verification. The programming language is embedded in higher-order logic, its Hoare logic is derived. The whole development is purely definitional and thus sound. The viability of this approach is demonstrated with a non-trivial case study. We show the correctness of the Schorr-Waite graph marking algorithm and present part of the readable proof in Isabelle/HOL.", "num_citations": "96\n", "authors": ["1784"]}
{"title": "Proving pointer programs in higher-order logic\n", "abstract": " Building on the work of Burstall, this paper develops sound modelling and reasoning methods for imperative programs with pointers: heaps are modelled as mappings from addresses to values, and pointer structures are mapped to higher-level data types for verification. The programming language is embedded in higher-order logic. Its Hoare logic is derived. The whole development is purely definitional and thus sound. Apart from some smaller examples, the viability of this approach is demonstrated with a non-trivial case study. We show the correctness of the Schorr\u2013Waite graph marking algorithm and present part of its readable proof in Isabelle/HOL.", "num_citations": "95\n", "authors": ["1784"]}
{"title": "Ordered rewriting and confluence\n", "abstract": " One of the major problems in term rewriting theory is what to do with an equation which cannot be ordered into a rule. Many solutions have been proposed, including the use of special unification algorithms or of unfailing completion procedures.             If an equation cannot be ordered we can still use any instances of it which can be ordered for rewriting. Thus for example x\u00d7y=y\u00d7x cannot be ordered, but if a,b are constants with b\u00d7a>a\u00d7b we may rewrite b\u00d7a \u2192 a\u00d7b. This idea is used in unfailing completion, and also appears in the Boyer-Moore system. In this paper we define and investigate completeness with respect to this notion of rewriting and show that many familiar systems are complete rewriting systems in this sense. This allows us to decide equality without the use of special unification algorithms. We prove completeness by proving termination and local confluence. We describe a confluence test\u00a0\u2026", "num_citations": "92\n", "authors": ["1784"]}
{"title": "Combining model checking and deduction for I/O-automata\n", "abstract": " We propose a combination of model checking and interactive theorem proving where the theorem prover is used to represent finite and infinite state systems, reason about them compositionally and reduce them to small finite systems by verified abstractions. As an example we verify a version of the Alternating Bit Protocol with unbounded lossy and duplicating channels: the channels are abstracted by interactive proof and the resulting finite state system is model checked.", "num_citations": "89\n", "authors": ["1784"]}
{"title": "Certifying machine code safety: Shallow versus deep embedding\n", "abstract": " We formalise a simple assembly language with procedures and a safety policy for arithmetic overflow in Isabelle/HOL. To verify individual programs we use a safety logic. Such a logic can be realised in Isabelle/HOL either as shallow or deep embedding. In a shallow embedding logical formulas are written as HOL predicates, whereas a deep embedding models formulas as a datatype. This paper presents and discusses both variants pointing out their specific strengths and weaknesses.", "num_citations": "85\n", "authors": ["1784"]}
{"title": "Type classes and overloading resolution via order-sorted unification\n", "abstract": " We present a type inference algorithm for a Haskell-like language based on order-sorted unification. The language features polymorphism, overloading, type classes and multiple inheritance. Class and instance declarations give rise to an order-sorted algebra of types. Type inference essentially reduces to the Hindley/Milner algorithm where unification takes place in this order-sorted algebra of types. The theory of order-sorted unification provides simple sufficient conditions which ensure the existence of principal types. The semantics of the language is given by a translation into ordinary \u03bb-calculus. We prove the correctness of our type inference algorithm with respect to this semantics.", "num_citations": "80\n", "authors": ["1784"]}
{"title": "Type inference verified: Algorithm W in Isabelle/HOL\n", "abstract": " This paper presents the first machine-checked verification of Milner's type inference algorithm W for computing the most general type of an untyped \u03bb-term enriched with let-expressions. This term language is the core of most typed functional programming languages and is also known as Mini-ML. We show how to model all the concepts involved, in particular types and type schemes, substitutions, and the thorny issue of \u201cnew\u201d variables. Only a few key proofs are discussed in detail. The theories and proofs are developed in Isabelle/HOL, the HOL instantiation of the generic theorem prover Isabelle.", "num_citations": "78\n", "authors": ["1784"]}
{"title": "Hoare logics in Isabelle/HOL\n", "abstract": " This paper describes Hoare logics for a number of imperative language constructs, from while-loops via exceptions to mutually recursive procedures. Both partial and total correctness are treated. In particular a proof system for total correctness of recursive procedures in the presence of unbounded nondeterminism is presented. All systems are formalized and shown to be sound and complete in the theorem prover Isabelle/HOL.", "num_citations": "75\n", "authors": ["1784"]}
{"title": "Hoare logics for recursive procedures and unbounded nondeterminism\n", "abstract": " This paper presents sound and complete Hoare logics for partial and total correctness of recursive parameterless procedures in the context of unbounded nondeterminism. For total correctness, the literature so far has either restricted recursive procedures to be deterministic or has studied unbounded nondeterminism only in conjunction with loops rather than procedures. We consider both single procedures and systems of mutually recursive procedures. All proofs have been checked with the theorem prover Isabelle/HOL.", "num_citations": "75\n", "authors": ["1784"]}
{"title": "Orthogonal higher-order rewrite systems are confluent\n", "abstract": " The results about higher-order critical pairs and the confluence of OHRSs provide a firm foundation for the further study of higher-order rewrite systems. It should now be interesting to lift more results and techniques both from term-rewriting and \u03bb-calculus to the level of HRSs. For example termination proof techniques are much studied for TRSs and are urgently needed for HRSs; similarly the extension of our result to weakly orthogonal HRSs or even to Huet's \u201cparallel closed\u201d systems is highly desirable. Conversely, a large body of \u03bb-calculus reduction theory has been lifted to CRSs [10] already and should be easy to carry over to HRSs.             Finally there is the need to extend the notion of an HRS to more general left-hand sides. For example the eta-rule for the case-construct on disjoint unions [15] case(U,\u03bbx.F(inl(x)),\u03bby.G(inr(y))) \u2192 F(U) is outside our framework, whichever way it is oriented.", "num_citations": "75\n", "authors": ["1784"]}
{"title": "Data refinement in Isabelle/HOL\n", "abstract": " The paper shows how the code generator of Isabelle/HOL supports data refinement, i.e., providing efficient code for operations on abstract types, e.g., sets or numbers. This allows all tools that employ code generation, e.g., Quickcheck or proof by evaluation, to compute with these abstract types. At the core is an extension of the code generator to deal with data type invariants. In order to automate the process of setting up specific data refinements, two packages for transferring definitions and theorems between types are exploited.", "num_citations": "74\n", "authors": ["1784"]}
{"title": "Proof terms for simply typed higher order logic\n", "abstract": " This paper presents proof terms for simply typed, intuitionistic higher order logic, a popular logical framework. Unification-based algorithms for the compression and reconstruction of proof terms are described and have been implemented in the theorem prover Isabelle. Experimental results confirm the effectiveness of the compression scheme.", "num_citations": "73\n", "authors": ["1784"]}
{"title": "Isabelle-91\n", "abstract": " Isabelle is a generic theorem prover. Object-logics are formalized within higher-order logic, which is Isabelle's meta-logic. Proofs are performed by a generalization of resolution, using higher-order unification. The latest incarnation of Isabelle, Isabelle-91, features a type system based on order-sorted unification; this supports polymorphism and overloading in logic definitions.", "num_citations": "70\n", "authors": ["1784"]}
{"title": "Type reconstruction for type classes\n", "abstract": " We study the type inference problem for a system with type classes as in the functional programming language Haskell. Type classes are an extension of ML-style polymorphism with overloading. We generalize Milner's work on polymorphism by introducing a separate context constraining the type variables in a typing judgement. This leads to simple type inference systems and algorithms which closely resemble those for ML. In particular, we present a new unification algorithm which is an extension of syntactic unification with constraint solving. The existence of principal types follows from an analysis of this unification algorithm.", "num_citations": "68\n", "authors": ["1784"]}
{"title": "I/O automata in Isabelle/HOL\n", "abstract": " We have embedded the meta-theory of I/O automata, a model for describing and reasoning about distributed systems, in Isabelle's version of higher order logic. On top of that, we have specified and verified a recent network transmission protocol which achieves reliable communication using single-bit-header packets over a medium which may reorder packets arbitrarily.", "num_citations": "68\n", "authors": ["1784"]}
{"title": "Type checking type classes\n", "abstract": " We study the type inference problem for a system with type classes as in the functional programming language Haskell. Type classes are an extension of ML-style polymorphism with overloading. We generalize Milner's work on polymorphism by introducing a separate context constraining the type variables in a typing judgement. This lead to simple type inference systems and algorithms which closely resemble those for ML. In particular we present a new unification algorithm which is an extension of syntactic unification with constraint solving. The existence of principal types follows from an analysis of this unification algorithm.", "num_citations": "68\n", "authors": ["1784"]}
{"title": "Order-sorted polymorphism in Isabelle\n", "abstract": " ML-style polymorphism can be generalized from a single-sorted algebra of types to an order-sorted one by adding a partially ordered layer of \u201csorts\u201d on top of the types. Type inference proceeds as in the Hindley/Milner system, except that order-sorted unification of types is used. The resulting system has been implemented in Isabelle to permit type variables to range over user-definable subsets of all types. Order-sorted polymorphism allows a simple specification of type restrictions in many logical systems. It accommodates user-defined parametric overloading and allows for a limited form of abstract axiomatic reasoning. It can also explain type inference with Standard ML's equality types and Haskell's type classes.", "num_citations": "65\n", "authors": ["1784"]}
{"title": "Flyspeck i: Tame graphs\n", "abstract": " We present a verified enumeration of tame graphs as defined in Hales\u2019 proof of the Kepler Conjecture and confirm the completeness of Hales\u2019 list of all tame graphs while reducing it from 5128 to 2771 graphs.", "num_citations": "64\n", "authors": ["1784"]}
{"title": "Proof pearl: Regular expression equivalence and relation algebra\n", "abstract": " We describe and verify an elegant equivalence checker for regular expressions. It works by constructing a bisimulation relation between (derivatives of) regular expressions. By mapping regular expressions to binary relations, an automatic and complete proof method for (in)equalities of binary relations over union, composition and (reflexive) transitive closure is obtained. The verification is carried out in the theorem prover Isabelle/HOL, yielding a practically useful decision procedure.", "num_citations": "63\n", "authors": ["1784"]}
{"title": "More Church\u2013Rosser Proofs\n", "abstract": " The proofs of the Church\u2013Rosser theorems for \u03b2, \u03b7, and \u03b2 \u222a \u03b7 reduction in untyped \u03bb-calculus are formalized in Isabelle/HOL, an implementation of Higher Order Logic in the generic theorem prover Isabelle. For \u03b2-reduction, both the standard proof and Takahashi's are given and compared. All proofs are based on a general theory of commutating relations that supports an almost geometric style of reasoning about confluence diagrams.", "num_citations": "60\n", "authors": ["1784"]}
{"title": "Verified bytecode verifiers\n", "abstract": " Using the theorem prover Isabelle/HOL we have formalized and proved correct an executable bytecode verifier in the style of Kildall\u2019s algorithm for a significant subset of the Java Virtual Machine. First an abstract framework for proving correctness of data flow based type inference algorithms for assembly languages is formalized. It is shown that under certain conditions Kildall\u2019s algorithm yields a correct bytecode verifier. Then the framework is instantiated with a model of the JVM.", "num_citations": "58\n", "authors": ["1784"]}
{"title": "Advances in probabilistic model checking\n", "abstract": " Probabilistic model checking is an automated verification method that aims to establish the correctness of probabilistic systems. Probability may arise, for example, due to failures of unreliable components, communication across lossy media, or through the use of randomisation in distributed protocols. Probabilistic model checking enables a range of exhaustive, quantitative analyses of properties such as \u201cthe probability of a message being delivered within 5ms is at least 0.89\u201d. In the last ten years, probabilistic model checking has been successfully applied to numerous real-world case studies, and is now a highly active field of research. This tutorial gives an introduction to probabilistic model checking, as well as presenting material on selected recent advances. The first half of the tutorial concerns two classical probabilistic models, discrete-time Markov chains and Markov decision processes, explaining the underlying theory and model checking algorithms for the temporal logic PCTL. The second half discusses two advanced topics: quantitative abstraction refinement and model checking for probabilistic timed automata. We also briefly summarise the functionality of the probabilistic model checker PRISM, the leading tool in the area.", "num_citations": "56\n", "authors": ["1784"]}
{"title": "An operational semantics and type safety prooffor multiple inheritance in C++\n", "abstract": " We present an operational semantics and type safety proof for multiple inheritance in C++. The semantics models the behaviour of method calls, field accesses, and two forms of casts in C++ class hierarchies exactly, and the type safety proof was formalized and machine-checked in Isabelle/HOL. Our semantics enables one, for the first time, to understand the behaviour of operations on C++ class hierarchies without referring to implementation-level artifacts such as virtual function tables. Moreover, it can-as the semantics is executable-act as a reference for compilers, and it can form the basis for more advanced correctness proofs of, eg, automated program transformations. The paper presents the semantics and type safety proof, and a discussion of the many subtleties that we encountered in modeling the intricate multiple inheritance model of C++.", "num_citations": "53\n", "authors": ["1784"]}
{"title": "A code generator framework for Isabelle/HOL\n", "abstract": " We present a code generator framework for Isabelle/HOL. It formalizes the intermediate stages between the purely logical description in terms of equational theorems and a programming language. Correctness of the translation is established by giving the intermediate languages (a subset of Haskell) an equational semantics and relating it back to the logical level. To allow code generation for SML, we present and prove correct a (dictionary-based) translation eliminating type classes. The design of our framework covers different functional target languages.", "num_citations": "52\n", "authors": ["1784"]}
{"title": "Verifying and reflecting quantifier elimination for Presburger arithmetic\n", "abstract": " We present an implementation and verification in higher-order logic of Cooper\u2019s quantifier elimination for Presburger arithmetic. Reflection, i.e. the direct execution in ML, yields a speed-up of a factor of 200 over an LCF-style implementation and performs as well as a decision procedure hand-coded in ML.", "num_citations": "51\n", "authors": ["1784"]}
{"title": "Higher-order rewriting and equational reasoning\n", "abstract": " In 1972, Knuth and Bendix published their seminal paper (Knuth and Bendix, 1970) which introduced the notion of a critical pair and showed that con uence of terminating term-rewriting systems is decidable. This was the birth of what is now known as term rewriting. Much e ort has since gone into the study of term rewriting systems and as a result there is a large body of knowledge about their properties. The study of term rewriting proceeded in parallel and mostly independently of research in-calculus. A rst attempt to bridge this gap is due to Klop (Klop, 1980), but it was not until the early nineties that a mixture of typed-calculus and term rewriting was proposed (Nipkow, 1991; Wolfram, 1993), called higher-order rewrite systems. They allow higher-order functions and their rules are pairs of simply typed-terms (as opposed to rst-order terms).", "num_citations": "51\n", "authors": ["1784"]}
{"title": "Isabelle\u2019s logics: HOL\n", "abstract": " This manual describes Isabelle\u2019s formalization of Higher-Order Logic, a polymorphic version of Church\u2019s Simple Theory of Types. HOL can be best understood as a simply-typed version of classical set theory. See also Isabelle/HOL\u2014The Tutorial for a gentle introduction on using Isabelle/HOL, and the Isabelle Reference Manual for general Isabelle commands.", "num_citations": "50\n", "authors": ["1784"]}
{"title": "Social choice theory in HOL\n", "abstract": " This article presents formalizations in higher-order logic of two proofs of Arrow\u2019s impossibility theorem due to Geanakoplos. The Gibbard-Satterthwaite theorem is derived as a corollary. Lacunae found in the literature are discussed.", "num_citations": "50\n", "authors": ["1784"]}
{"title": "Verified lexical analysis\n", "abstract": " This paper presents the development and verification of a (very simple) lexical analyzer generator that takes a regular expression and yields a functional lexical analyzer. The emphasis is on simplicity and executability. The work was carried out with the help of the theorem prover Isabelle/HOL.", "num_citations": "49\n", "authors": ["1784"]}
{"title": "Owicki/Gries in Isabelle/HOL\n", "abstract": " We present a formalization of the Gries/Owicki method for correctness proofs of concurrent imperative programs with shared variables in the theorem prover Isabelle/HOL. Syntax, semantics and proof rules are defined in higher-order logic. The correctness of the proof rules w.r.t. the semantics is proved. The verification of some typical example programs like producer/consumer is presented.", "num_citations": "48\n", "authors": ["1784"]}
{"title": "Mining the archive of formal proofs\n", "abstract": " The Archive of Formal Proofs is a vast collection of computer-checked proofs developed using the proof assistant Isabelle. We perform an in-depth analysis of the archive, looking at various properties of the proof developments, including size, dependencies, and proof style. This gives some insights into the nature of formal proofs.", "num_citations": "46\n", "authors": ["1784"]}
{"title": "Winskel is (almost) Right--Towards Mechanized Semantics textbook\n", "abstract": " We present a formalization of the first 100 pages of Winskel's The Formal Semantics of Programming Languages in the theorem prover Isabelle/HOL: 2 operational, 2 denotational, 1 axiomatic semantics, a verification condition generator, and the necessary soundness, completeness and equivalence proofs, all for a simple imperative language.", "num_citations": "46\n", "authors": ["1784"]}
{"title": "A decidability result about sufficient-completeness of axiomatically specified abstract data types\n", "abstract": " The problem of deciding whether an axiomatic specification of an abstract data type is sufficiently-complete is known to be in general unsolvable. Regarding axioms as directed rewrite rules instead of symmetric equations a specification defines a reduction relation on terms. It is proved that in the subclass of left-linear axiomatic specifications the property of sufficient-completeness is decidable, if the corresponding reduction relation is normalizing and confluent. The presented algorithm can also be used to determine a set of constructors for a specified data type.", "num_citations": "46\n", "authors": ["1784"]}
{"title": "More Church-Rosser proofs (in isabelle/hol)\n", "abstract": " The proofs of the Church-Rosser theorems for \u03b2, \u03b7 and \u03b2 \u222a \u03b7 reduction in untyped \u03bb-calculus are formalized in Isabelle/HOL, an implementation of Higher Order Logic in the generic theorem prover Isabelle. For \u03b2-reduction, both the standard proof and the variation by Takahashi are given and compared. All proofs are based on a general theory of commutating relations which supports an almost geometric style of confluence proofs.", "num_citations": "45\n", "authors": ["1784"]}
{"title": "Finding lexicographic orders for termination proofs in Isabelle/HOL\n", "abstract": " We present a simple method to formally prove termination of recursive functions by searching for lexicographic combinations of size measures. Despite its simplicity, the method turns out to be powerful enough to solve a large majority of termination problems encountered in daily theorem proving practice.", "num_citations": "43\n", "authors": ["1784"]}
{"title": "A verified compiler from Isabelle/HOL to CakeML\n", "abstract": " Many theorem provers can generate functional programs from definitions or proofs. However, this code generation needs to be trusted. Except for the HOL4 system, which has a proof producing code generator for a subset of ML. We go one step further and provide a verified compiler from Isabelle/HOL to CakeML. More precisely we combine a simple proof producing translation of recursion equations in Isabelle/HOL into a deeply embedded term language with a fully verified compilation chain\u00a0to the target language CakeML.", "num_citations": "42\n", "authors": ["1784"]}
{"title": "Combining matching algorithms: The regular case+\n", "abstract": " The problem of combining matching algorithms for equational theories with disjoint signatures is studied. It is shown that the combined matching problem is in general undecidable but that it becomes decidable if all theories are regular. For the case of regular theories an efficient combination algorithm is developed. As part of that development we present a simple algorithm for solving the word problem in the combination of arbitrary equational theories with disjoint signatures.", "num_citations": "42\n", "authors": ["1784"]}
{"title": "Proof transformations for equational theories\n", "abstract": " This study contrasts two kinds of proof systems for equational theories: the standard ones obtained by combining the axioms with the laws of equational logic, and alternative systems designed to yield decision procedures for equational problems. Novel matching algorithms for (among other theories) associativity, associativity plus commutativity, and associativity plus commutativity plus identity are presented, but the emphasis is not so much on individual theories but on the general method of proof transformation as a tool for showing the equivalence of different proof systems. After a study of proof translations defined by rewriting systems, equivalence tests based on the notion of resolvent theories are used to derive novel matching and, in some cases unification procedures for a number of equational theories. The combination of resolvent systems is investigated.< >", "num_citations": "42\n", "authors": ["1784"]}
{"title": "Flyspeck II: the basic linear programs\n", "abstract": " This thesis is the second major contribution to the Flyspeck project which has as its goal the complete machine-verified formalization of the proof of the Kepler conjecture that Thomas Hales has given in 1998. We specify, generate and bound what Hales loosely calls the basic linear programs. We do this within the interactive proof assistant Isabelle. There are two major aspects of this work: Logical reasoning and trusted computing. Of course trusted computing can be considered as a special case of logical reasoning but requirements regarding the speed of computing demand a special treatment. Our solution to this problem is the HOL Computing Library. A substantial part of this work is dedicated to the design and implementation of this library. We then apply the library to show that 92.5% of all tame graphs give raise to basic linear programs which are inconsistent.", "num_citations": "40\n", "authors": ["1784"]}
{"title": "Higher-order unification, polymorphism, and subsorts\n", "abstract": " This paper analyzes the problems that arise in extending Huet's higher-order unification algorithm from the simply typed \u03bb-calculus to one with type variables. A simple, incomplete, but in practice very useful extension to Huet's algorithm is discussed. This extension takes an abstract view of types. As a particular instance we explore a type system with ml-style polymorphism enriched with a notion of sorts. Sorts are partially ordered and classify types, thus giving rise to an order-sorted algebra of types. Type classes in the functional language Haskell can be understood as sorts in this sense. Sufficient conditions on the sort structure to ensure the existence of principal types are discussed. Finally we suggest a new type system for the \u03bb-calculus which may pave the way to a complete unification algorithm for polymorphic terms.", "num_citations": "40\n", "authors": ["1784"]}
{"title": "Equational reasoning in Isabelle\n", "abstract": " This paper reports on a case study carried out with the generic theorem prover Isabelle. The purpose of this study was to investigate the process of instantiating a generic system like Isabelle for a particular logic (equational logic in this case). Isabelle is like a compiler-compiler, except that it compiles a logic definition into an LCF-style theorem prover for that logic. To make that theorem prover usable, a number of logic-specific \u201ctactics\u201d, embodying useful theorem proving techniques in that logic, must be built on top. Equational logic was chosen as a test case because it comes with a large body of well-tried algorithms. It will be shown how a variety of different algorithms in the area of equational reasoning can be implemented in a unified way using a powerful tactic language. The problems tackled are term rewriting, unification and inductive theorem proving and the tactic language is ML. The main advantages of this\u00a0\u2026", "num_citations": "40\n", "authors": ["1784"]}
{"title": "Proof synthesis and reflection for linear arithmetic\n", "abstract": " This article presents detailed implementations of quantifier elimination for both integer and real linear arithmetic for theorem provers. The underlying algorithms are those by Cooper (for Z) and by Ferrante and Rackoff (for \u211d). Both algorithms are realized in two entirely different ways: once in tactic style, i.e. by a proof-producing functional program, and once by reflection, i.e. by computations inside the logic rather than in the meta-language. Both formalizations are generic because they make only minimal assumptions w.r.t. the underlying logical system and theorem prover. An implementation in Isabelle/HOL shows that the reflective approach is between one and two orders of magnitude faster.", "num_citations": "38\n", "authors": ["1784"]}
{"title": "Unification in primal algebras, their powers and their varieties\n", "abstract": " This paper examines the unification problem in the class of primal algebras and the varieties they generate. An algebra is called primal if every function on its carrier can be expressed just in terms of the basic operations of the algebra. The two-element Boolean algebra is the simplest nontrivial example: Every truth-function can be realized in terms of the basic connectives, for example, negation and conjunction. It is shown that unification in primal algebras is unitary, that is, if an equation has a solution, it has a single most general one. Two unification algorithms, based on equation-solving techniques for Boolean algebras due to Boole and Lo\u00a8wenheim, are studied in detail. Applications include certain finite Post algebras and matrix rings over   finite fields. The former are algebraic models for many-valued logics, the latter cover in particular modular arithmetic. Then unification is extended from primal algebras to their\u00a0\u2026", "num_citations": "38\n", "authors": ["1784"]}
{"title": "Jinja: Towards a comprehensive formal semantics for a Java-like language\n", "abstract": " Jinja is a Java-like programming language with a formal semantics designed to exhibit core features of Java. It is a compromise between realism of the language and tractability and clarity of the formal semantics. A big and a small step operational semantics are defined and shown equivalent. A type system and a definite initialization analysis are defined and type safety of the small step semantics is shown. The whole development has been carried out in the theorem prover Isabelle/HOL.", "num_citations": "36\n", "authors": ["1784"]}
{"title": "Term rewriting and beyond\u2014theorem proving in Isabelle\n", "abstract": " The subject of this paper is theorem proving based on rewriting and induction. Both principles are implemented as tactics within the generic theorem prover Isabelle. Isabelle's higher-order features enable us to go beyond first-order rewriting and express rewriting with conditionals, induction schemata, higher-order functions and program transformers. Applications include the verification and transformation of functional versions of insertion sort and quicksort.", "num_citations": "36\n", "authors": ["1784"]}
{"title": "Unification in boolean rings\n", "abstract": " A simple unification algorithm for terms containing variables, constants and the set operators intersection and symmetric difference is presented. The solution is straightforward because the algebraic structure under consideration is a boolean ring. The main part of the algorithm is finding a particular solution which is then substituted into a general formula to yield a single most general unifier. The combination with other equational theories is briefly considered but even for simple cases the extension seems non-trivial.", "num_citations": "36\n", "authors": ["1784"]}
{"title": "Amortized complexity verified\n", "abstract": " A framework for the analysis of the amortized complexity of (functional) data structures is formalized in Isabelle/HOL and applied to a number of standard examples and to three famous non-trivial ones: skew heaps, splay trees and splay heaps.", "num_citations": "35\n", "authors": ["1784"]}
{"title": "Linear quantifier elimination\n", "abstract": " This paper presents verified quantifier elimination procedures for dense linear orders (DLO), for real and for integer linear arithmetic. The DLO procedures are new. All procedures are defined and verified in the theorem prover Isabelle/HOL, are executable and can be applied to HOL formulae themselves (by reflection).", "num_citations": "35\n", "authors": ["1784"]}
{"title": "Unification in Boolean rings\n", "abstract": " We show that two Boolean terms which are unifiable have a most general unifier, which can be described using the terms themselves and a single unifier. Techniques for finding a single unifier are given.", "num_citations": "35\n", "authors": ["1784"]}
{"title": "Bytecode analysis for proof carrying code\n", "abstract": " Out of annotated programs proof carrying code systems construct and prove verification conditions that guarantee a given safety policy. The annotations may come from various program analyzers and must not be trusted as they need to be verified. A generic verification condition generator can be utilized such that a combination of annotations is verified incrementally. New annotations may be verified by using previously verified ones as trusted facts. We show how results from a trusted type analyzer may be combined with untrusted interval analysis to automatically verify that bytecode programs do not overflow. All trusted components are formalized and verified in Isabelle/HOL.", "num_citations": "31\n", "authors": ["1784"]}
{"title": "Programming and proving in Isabelle/HOL\n", "abstract": " Isabelle is a generic system for implementing logical formalisms, and Isabelle/HOL is the specialization of Isabelle for HOL, which abbreviates Higher-Order Logic. We introduce HOL step by step following the equation", "num_citations": "30\n", "authors": ["1784"]}
{"title": "Modular higher-order E-unification\n", "abstract": " The combination of higher-order and first-order unification algorithms is studied. We present algorithms to compute a complete set of unifiers of two simply typed \u03bb-terms w.r.t. the union of \u03b1, \u03b2 and \u03b7 conversion and a first-order equational theory E. The algorithms are extensions of Huet's work and assume that a complete unification algorithm for E is given. Our completeness proofs require E to be at least regular.", "num_citations": "30\n", "authors": ["1784"]}
{"title": "Combining matching algorithms: The regular case\n", "abstract": " The problem of combining matching algorithms for equational theories with disjoint signatures is studied. It is shown that the combined matching problem is in general undecidable but that it becomes decidable if all theories are regular. For the case of regular theories an efficient combination algorithm is developed. As part of that development we present a simple algorithm for solving the word problem in the combination of arbitrary equational theories with disjoint signatures.", "num_citations": "30\n", "authors": ["1784"]}
{"title": "Traces of I/O-automata in Isabelle/HOLCF\n", "abstract": " This paper presents a formalization of finite and infinite sequences in domain theory carried out in the theorem prover Isabelle. The results are used to model the metatheory of I/O automata; they are, however, applicable to any trace based model of parallelism which distinguishes internal and external actions. We make use of the logic HOLCF, an extension of HOL with domain theory and show how to move between HOL and HOLCF. This allows us to restrict the use of HOLCF to metatheoretic arguments while actual refinement proofs between I/O automata are carried out within the simpler logic HOL. In order to evaluate the formalization we prove the correctness of a generalized refinement concept in I/O automata.", "num_citations": "27\n", "authors": ["1784"]}
{"title": "Behavioural implementation concepts for nondeterministic data types\n", "abstract": " British Library EThOS: Behavioural implementation concepts for nondeterministic data types New search | Advanced search | Search results Login / Register | About | Help | FAQ | Follow dividing line Use this URL to cite or link to this record in EThOS: https://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.377738 Title: Behavioural implementation concepts for nondeterministic data types Author: Nipkow, TN ISNI: 0000 0001 1006 0849 Awarding Body: University of Manchester Current Institution: University of Manchester Date of Award: 1986 Availability of Full Text: Access from EThOS: Immediate download. Please login to continue. Abstract: No abstract available Supervisor: Not available Sponsor: Not available Qualification Name: Thesis (Ph.D.) Qualification Level: Doctoral EThOS ID: uk.bl.ethos.377738 DOI: Not available Keywords: Software data determination Share: Terms and Conditions | Notice and Takedown \u2026", "num_citations": "27\n", "authors": ["1784"]}
{"title": "Formal verification of data type refinement\u2014theory and practice\n", "abstract": " This paper develops two theories of data abstraction and refinement: one for applicative types, as they are found in functional programming languages, and one for state-based types found in imperative languages. The former are modelled by algebraic structures, the latter by automata. The automaton-theoretic model covers not just data types but distributed systems in general. Within each theory two examples of data refinement are presented and formally verified with the theorem prover Isabelle. The examples are an abstract specification and two implementations of a memory system, and a mutual exclusion algorithm.", "num_citations": "26\n", "authors": ["1784"]}
{"title": "Asserting bytecode safety\n", "abstract": " We instantiate an Isabelle/HOL framework for proof carrying code to Jinja bytecode, a downsized variant of Java bytecode featuring objects, inheritance, method calls and exceptions. Bytecode annotated in a first order expression language can be certified not to produce arithmetic overflows. For this purpose we use a generic verification condition generator, which we have proven correct and relatively complete.", "num_citations": "25\n", "authors": ["1784"]}
{"title": "The 5 colour theorem in Isabelle/Isar\n", "abstract": " Based on an inductive definition of triangulations, a theory of undirected planar graphs is developed in Isabelle/HOL. The proof of the 5 colour theorem is discussed in some detail, emphasizing the readability of the computer assisted proofs.", "num_citations": "25\n", "authors": ["1784"]}
{"title": "Formal verification of algorithm W: The monomorphic case\n", "abstract": " A formal verification of the soundness and completeness of Milner\u2019s type inference algorithm W for simply typed lambda-terms is presented. Particular attention is paid to the notorious issue of \u201cnew\u201d variables. The proofs are carried out in Isabelle/HOL, the HOL instantiation of the generic theorem prover Isabelle.", "num_citations": "25\n", "authors": ["1784"]}
{"title": "Automatic functional correctness proofs for functional search trees\n", "abstract": " In a new approach, functional correctness specifications of insert/update and delete operations on search trees are expressed on the level of lists by means of an inorder traversal function that projects trees to lists. With the help of a small lemma library, functional correctness and preservation of the search tree property are proved automatically (in Isabelle/HOL) for a range of data structures: unbalanced binary trees, AVL trees, red-black trees, 2-3 and 2-3-4 trees, 1-2 brother trees, AA trees and splay trees.", "num_citations": "24\n", "authors": ["1784"]}
{"title": "A compiled implementation of normalization by evaluation\n", "abstract": " We present a novel compiled approach to Normalization by Evaluation (NBE) for ML-like languages. It supports efficient normalization of open \u03bb-terms w.r.t. \u03b2-reduction and rewrite rules. We have implemented NBE and show both a detailed formal model of our implementation and its verification in Isabelle. Finally we discuss how NBE is turned into a proof rule in Isabelle.", "num_citations": "23\n", "authors": ["1784"]}
{"title": "Teaching semantics with a proof assistant: No more LSD trip proofs\n", "abstract": " We describe a course on the semantics of a simple imperative programming language and on applications to compilers, type systems, static analyses and Hoare logic. The course is entirely based on the proof assistant Isabelle and includes a compact introduction to Isabelle. The overall aim is to teach the students how to write correct and readable proofs.", "num_citations": "22\n", "authors": ["1784"]}
{"title": "Linear quantifier elimination\n", "abstract": " This paper presents verified quantifier elimination procedures for dense linear orders (two of them novel), for real and for integer linear arithmetic. All procedures are defined and verified in the theorem prover Isabelle/HOL, are executable and can be applied to HOL formulae themselves (by reflection). The formalization of the different theories is highly modular.", "num_citations": "22\n", "authors": ["1784"]}
{"title": "Verifying a hotel key card system\n", "abstract": " Two models of an electronic hotel key card system are contrasted: a state based and a trace based one. Both are defined, verified, and proved equivalent in the theorem prover Isabelle/HOL. It is shown that if a guest follows a certain safety policy regarding her key cards, she can be sure that nobody but her can enter her room.", "num_citations": "22\n", "authors": ["1784"]}
{"title": "Java bytecode verification\n", "abstract": " This special issue is dedicated to Java bytecode verification. One of the innovative features of the Java language architecture is the definition of a typed assembly language (the Java Virtual Machine Language, JVML) together with a type checker. The purpose of the type checker is to rule out programs that violate Java safety policies, for example, illegal type conversions. However, it turned out that the type system for the JVML is highly nontrivial. Starting with the seminal paper by Stata and Abadi in 1998, research on this type system has led to the publication of around 30 papers and several Ph. D. theses. It is only now that the mathematics is completely understood. Therefore this issue collects together articles by the leading experts in this area that present fully formal treatments of the type system, type checking algorithms, and correctness proofs. The emphasis is very much on precise specifications and proofs.The\u00a0\u2026", "num_citations": "22\n", "authors": ["1784"]}
{"title": "Proving concurrent noninterference\n", "abstract": " We perform a formal analysis of compositionality techniques for proving possibilistic noninterference for a while language with parallel composition. We develop a uniform framework where we express a wide range of noninterference variants from the literature and compare them w.r.t.\u00a0their contracts: the strength of the security properties they ensure weighed against the harshness of the syntactic conditions they enforce. This results in a simple implementable algorithm for proving that a program has a specific noninterference property, using only compositionality, which captures uniformly several security type-system results from the literature and suggests a further improved type system. All formalism and theorems have been mechanically verified in Isabelle/HOL.", "num_citations": "21\n", "authors": ["1784"]}
{"title": "Proof pearl: Defining functions over finite sets\n", "abstract": " Structural recursion over sets is meaningful only if the result is independent of the order in which the set\u2019s elements are enumerated. This paper outlines a theory of function definition for finite sets, based on the fold functionals often used with lists. The fold functional is introduced as a relation, which is then shown to denote a function under certain conditions. Applications include summation and maximum. The theory has been formalized using Isabelle/HOL .", "num_citations": "20\n", "authors": ["1784"]}