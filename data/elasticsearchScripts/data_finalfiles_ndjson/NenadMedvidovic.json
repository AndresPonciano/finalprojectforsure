{"title": "A classification and comparison framework for software architecture description languages\n", "abstract": " Software architectures shift the focus of developers from lines-of-code to coarser-grained architectural elements and their overall interconnection structure. Architecture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which of several possible ADLs is best suited for a particular problem. Furthermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modeling\u00a0\u2026", "num_citations": "3078\n", "authors": ["627"]}
{"title": "Towards a taxonomy of software connectors\n", "abstract": " Software systems of today are frequently composed from prefabricated, heterogeneous components that provide complex functionality and engage in complex interactions. Existing research on component-based development has mostly focused on component structure, interfaces, and functionality. Recently, software architecture has emerged as an area that also places significant importance on component interactions, embodied in the notion of software connectors. However, the current level of understanding and support for connectors has been insufficient. This has resulted in their inconsistent treatment and a notable lack of understanding of what the fundamental building blocks of software interaction are and how they can be composed into more complex interactions. This paper attempts to address this problem. It presents a comprehensive classification framework and taxonomy of software connectors. The\u00a0\u2026", "num_citations": "629\n", "authors": ["627"]}
{"title": "A framework for classifying and comparing architecture description languages\n", "abstract": " Software architectures shift developers' focus from lines-of-code to coarser-grained architectural elements and their interconnection structure. Architecture description languages (ADLs) have been proposed as modeling notations to support architecture-based development. There is, however, little consensus in the research community on what is an ADL, what aspects of an architecture should be modeled in an ADL, and which ADL is best suited for a particular problem. Furthermore, the distinction is rarely made between ADLs on one hand and formal specification, module interconnection, simulation, and programming languages on the other. This paper attempts to provide an answer to these questions. It motivates and presents a definition and a classification framework for ADLs. The utility of the definition is demonstrated by using it to differentiate ADLs from other modeling notations. The framework is used\u00a0\u2026", "num_citations": "443\n", "authors": ["627"]}
{"title": "ADLs and dynamic architecture changes\n", "abstract": " Existing ADLs typically support only static architecture specification and do not provide facilities for the support of dynamically changing architectures. This paper presents a possible solution to this problem: in order to adequately support dynamic architecture changes, ADLs can leverage techniques used in dynamic programming languages. In particular, changes to ADL specifications should be interpreted. To enable interpretation, an ADL should have an architecture construction component that supports explicit and incremental specification of architectural changes, in addition to the traditional architecture description facilities. This will allow software architects to specify the changes to an architecture after it has been built. The paper expands upon the results from an ongoing project--building a development environment for CZstyle architectures.\u2019", "num_citations": "214\n", "authors": ["627"]}
{"title": "Early prediction of software component reliability\n", "abstract": " The ability to predict the reliability of a software system early in its development, eg, during architectural design, can help to improve the system's quality in a cost-effective manner. Existing architecture-level reliability prediction approaches focus on system-level reliability and assume that the reliabilities of individual components are known. In general, this assumption is unreasonable, making component reliability prediction an important missing ingredient in the current literature. Early prediction of component reliability is a challenging problem because of many uncertainties associated with components under development. In this paper we address these challenges in developing a software component reliability prediction framework. We do this by exploiting architectural models and associated analysis techniques, stochastic modeling approaches, and information sources available early in the development\u00a0\u2026", "num_citations": "211\n", "authors": ["627"]}
{"title": "Moving architectural description from under the technology lamppost\n", "abstract": " In 2000, we published an extensive study of existing software architecture description languages (ADLs), which has served as a useful reference to software architecture researchers and practitioners. Since then, circumstances have changed. The Unified Modeling Language (UML) has gained popularity and wide adoption, and many of the ADLs we studied have been pushed into obscurity. We argue that this progression can be attributed to early ADLs\u2019 nearly exclusive focus on technological aspects of architecture, ignoring application domain and business contexts within which software systems and development organizations exist. These three concerns \u2013 technology, domain, and business \u2013 constitute three \u201clampposts\u201d needed to appropriately \u201cilluminate\u201d software architecture and architectural description.", "num_citations": "168\n", "authors": ["627"]}
{"title": "Reuse of off-the-shelf components in C2-style architectures\n", "abstract": " Reuse of large-grain software components offers the potential for significant savings in application development cost and time. Successful comuonent reuse and substitutability depends both on qualities of the &mponents reused as well as the sofiware context in which the reuse is attempted. Disciplined approaches to the structure and design of software applications offers the potential of providing a hospitable setting for such reuse+ We present the results of a series of exercises designed to determine how well \u201coff-the-shelf\u201d components could be reused in applications designed in accordance with the C2 software architectural style. The exercises involved the reuse of two user-interface constraint solvers, two graphics toolkits, a World Wide Web browser, and a persistent object manager. A subset of these components was used to construct numemus variations of a single application (thus an application family). The\u00a0\u2026", "num_citations": "156\n", "authors": ["627"]}
{"title": "Mae---a system model and environment for managing architectural evolution\n", "abstract": " As with any other artifact produced as part of the software life cycle, software architectures evolve and this evolution must be managed. One approach to doing so would be to apply any of a host of existing configuration management systems, which have long been used successfully at the level of source code. Unfortunately, such an approach leads to many problems that prevent effective management of architectural evolution. To overcome these problems, we have developed an alternative approach centered on the use of an integrated architectural and configuration management system model. Because the system model combines architectural and configuration management concepts in a single representation, it has the distinct benefit that all architectural changes can be precisely captured and clearly related to each other---both at the fine-grained level of individual architectural elements and at the coarse\u00a0\u2026", "num_citations": "138\n", "authors": ["627"]}
{"title": "Using off-the-shelf middleware to implement connectors in distributed software architectures\n", "abstract": " Software architectures promote development focused on modular building blocks and their interconnections. Since architecture-level components often contain complex functionality, it is reasonable to expect that their interactions will also be complex. Modeling and implementing software connectors thus becomes a key aspect of architecture-based development. Software interconnection and middleware technologies such as RMI, CORBA, ILU, and ActiveX provide a valuable service in building applications from components. The relation of such services to software connectors in the context of software architectures, however, is not well understood. To understand the tradeoffs among these technologies with respect to architectures, we have evaluated several off-the-shelf middleware technologies and identified key techniques for utilizing them in implementing software connectors. Our platform for investigation was\u00a0\u2026", "num_citations": "118\n", "authors": ["627"]}
{"title": "A software architecture-based framework for highly distributed and data intensive scientific applications\n", "abstract": " Modern scientific research is increasingly conducted by virtual communities of scientists distributed around the world. The data volumes created by these communities are extremely large, and growing rapidly. The management of the resulting highly distributed, virtual data systems is a complex task, characterized by a number of formidable technical challenges, many of which are of a software engineering nature. In this paper we describe our experience over the past seven years in constructing and deploying OODT, a software framework that supports large, distributed, virtual scientific communities. We outline the key software engineering challenges that we faced, and addressed, along the way. We argue that a major contributor to the success of OODT was its explicit focus on software architecture. We describe several large-scale, real-world deployments of OODT, and the manner in which OODT helped us to\u00a0\u2026", "num_citations": "115\n", "authors": ["627"]}
{"title": "The role of middleware in architecture-based software development\n", "abstract": " Software architectures promote development focused on modular  functional building blocks (components), their interconnections  (configurations), and their interactions (connectors). Since  architecture-level components often contain complex functionality, it  is reasonable to expect that their interactions will be complex as  well. Middleware technologies such as CORBA, COM, and RMI provide a  set of predefined services for enabling component composition and  interaction. However, the potential role of such services in the  implementations of software architectures is not well understood. In  practice, middleware can resolve various types of component  heterogeneity \u2014 across platform and language boundaries, for  instance \u2014 but also can induce unwanted architectural constraints  on application development. We present an approach in which components  communicate through architecture-level software\u00a0\u2026", "num_citations": "113\n", "authors": ["627"]}
{"title": "Taming architectural evolution\n", "abstract": " In the world of software development everything evolves. So, then, do software architectures. Unlike source code, for which the use of a configuration management (CM) system is the predominant approach to capturing and managing evolution, approaches to capturing and managing architectural evolution span a wide range of disconnected alternatives. This paper contributes a novel architecture evolution environment, called Mae, which brings together a number of these alternatives. The environment facilitates an incremental design process in which all changes to all architectural elements are integrally captured and related. Key to the environment is a rich system model that combines architectural concepts with those from the field of CM. Not only does this system model form the basis for Mae, but in precisely capturing architectural evolution it also facilitates automated support for several innovative capabilities\u00a0\u2026", "num_citations": "99\n", "authors": ["627"]}
{"title": "Using software evolution to focus architectural recovery\n", "abstract": " Ideally, a software project commences with requirements gathering and specification, reaches its major milestone with system implementation and delivery, and then continues, possibly indefinitely, into an operation and maintenance phase. The software system's architecture is in many ways the linchpin of this process: it is supposed to be an effective reification of the system's technical requirements and to be faithfully reflected in the system's implementation. Furthermore, the architecture is meant to guide system evolution, while also being updated in the process. However, in reality developers frequently deviate from the architecture, causing architectural erosion, a phenomenon in which the initial, \u201cas documented'' architecture of an application is (arbitrarily) modified to the point where its key properties no longer hold. Architectural recovery is a process frequently used to cope with architectural erosion\u00a0\u2026", "num_citations": "98\n", "authors": ["627"]}
{"title": "Composing architectural styles from architectural primitives\n", "abstract": " Architectural styles are named collections of constraints on configurations of architectural elements, and are believed to bring economies of scale in applying software architecture techniques to software development. Existing research on architectural styles provides little guidance for the systematic design and construction of architectural style elements. This paper proposes a framework, Alfa, for systematically and constructively composing \"architectural primitives\" to obtain elements of architectural styles. This is based on our observation that architectural styles share many underlying concepts that lead to architectural primitives. We have identified eight forms and nine functions as architectural primitives that reflect the syntactic and semantic characteristics of architectural styles and are expressive enough to compose their elements. Our approach is also illustrated using a familiar style -- pipe-and-filter.", "num_citations": "90\n", "authors": ["627"]}
{"title": "Automatic mining of specifications from invocation traces and method invariants\n", "abstract": " Software library documentation often describes individual methods' APIs, but not the intended protocols and method interactions. This can lead to library misuse, and restrict runtime detection of protocol violations and automated verification of software that uses the library. Specification mining, if accurate, can help mitigate these issues, which has led to significant research into new model-inference techniques that produce FSM-based models from program invariants and execution traces. However, there is currently a lack of empirical studies that, in a principled way, measure the impact of the inference strategies on model quality. To this end, we identify four such strategies and systematically study the quality of the models they produce for nine off-the-shelf libraries. We find that (1) using invariants to infer an initial model significantly improves model quality, increasing precision by 4% and recall by 41%, on average\u00a0\u2026", "num_citations": "88\n", "authors": ["627"]}
{"title": "A Bayesian model for predicting reliability of software systems at the architectural level\n", "abstract": " Modern society relies heavily on complex software systems for everyday activities. Dependability of these systems thus has become a critical feature that determines which products are going to be successfully and widely adopted. In this paper, we present an approach to modeling reliability of software systems at the architectural level. Dynamic Bayesian Networks are used to build a stochastic reliability model that relies on standard models of software architecture, and does not require implementation-level artifacts. Reliability values obtained via this approach can aid the architect in evaluating design alternatives. The approach is evaluated using sensitivity and uncertainty analysis.", "num_citations": "88\n", "authors": ["627"]}
{"title": "Architectural style requirements for self-healing systems\n", "abstract": " This paper argues for a set of requirements that an architectural style for self-healing systems should satisfy: adaptability, dynamicity, awareness, autonomy, robustness, distributability, mobility, and traceability. Support for these requirements is discussed along five dimensions we have identified as distinguishing characteristics of architectural styles: external structure, topology rules, behavior, interaction, and data flow. As an illustration, these requirements are used to assess an existing architectural style. While this initial formulation of the requirements appears to have utility, much further work remains to be done in order to apply it in evaluating and comparing architectural styles for self-healing systems.", "num_citations": "86\n", "authors": ["627"]}
{"title": "Architecture-level support for software component deployment in resource constrained environments\n", "abstract": " Software deployment comprises activities for installing or updating an already implemented software system. These activities include (1) deployment of a system onto a new host, (2) component upgrade in an existing system, (3) static analysis of the proposed system configuration, and (4) dynamic analysis of the configuration after the deployment. In this paper, we describe an approach that supports all four of these activities. The approach is specifically intended to support software deployment onto networks of distributed, mobile, highly resource constrained devices. Our approach is based on the principles of software architectures. In particular, we leverage our lightweight architectural implementation infrastructure to natively support deployment in resource constrained environments.", "num_citations": "83\n", "authors": ["627"]}
{"title": "Increasing the confidence in off-the-shelf components: A software connector-based approach\n", "abstract": " The promise of component-based software development is that larger, more complex systems can be built reasonably quickly and reliably from pre-fabricated (\u201c off-the-shelf\u201d) building blocks. Additionally, such systems can be upgraded incrementally, simply by replacing individual components with their new versions. However, practice has shown that while it may improve certain aspects of an existing component, a new component version frequently introduces unforeseen problems. These problems include less efficient utilization of system resources, errors in the newly introduced functionality, and even new errors in the functionality carried over from the old version. This paper presents an approach intended to alleviate such problems. Our approach is based on explicit software architectures and leverages flexible software connectors in  ensuring that component versions can be added and removed in the\u00a0\u2026", "num_citations": "77\n", "authors": ["627"]}
{"title": "Using service utilization metrics to assess the structure of product line architectures\n", "abstract": " Metrics have long been used to measure and evaluate software products and processes. Many metrics have been developed that have lead to different degrees of success. Software architecture is a discipline in which few metrics have been applied, a surprising fact given the critical role of software architecture in software development. Software product line architectures represent one area of software architecture in which we believe metrics can be of especially great use. The critical importance of the structure defined by a product line architecture requires that its properties be meaningfully assessed and that informed architectural decisions be made to guide its evolution. To begin addressing this issue, we have developed a class of closely related metrics that specifically target product line architectures. The metrics are based on the concept of service utilization and explicitly take into account the context in which\u00a0\u2026", "num_citations": "76\n", "authors": ["627"]}
{"title": "Focus: A light-weight, incremental approach to software architecture recovery and evolution\n", "abstract": " During the past decade (1991-2001), object-orientation (OO) has become the dominant software development methodology, accompanied by a number of modeling notations, programming languages, and development environments. OO applications of today are increasingly complex and user driven. They are also developed more rapidly and evolved more frequently than was the case with software systems of the past. All of these factors contribute to a plethora of potential problems when maintaining and evolving an OO application. These problems are caused by architectural erosion, where the initial architecture of an application is (arbitrarily) modified to the point where its key properties no longer hold. We propose an approach, called Focus, whose goal is to enable effective evolution of such an application with minimal effort, by recovering its architecture and using it as the basis of evolution. Focus allows\u00a0\u2026", "num_citations": "70\n", "authors": ["627"]}
{"title": "An empirical study of architectural decay in open-source software\n", "abstract": " Architecture is the set of principal design decisions about a software system. In practice, new architectural decisions are added and existing ones reversed or modified throughout a system's lifetime. Frequently, these decisions deviate from the architect's well-considered intent, and software systems regularly exhibit increased architectural decay as they evolve. The manifestations of such ill-considered design decisions are seen as \u201carchitectural smells\u201d. To date, there has been no in-depth study of the characteristics or trends involving this phenomenon. Instead, when referring to architectural smells and their negative effects, both researchers and practitioners had to rely on folklore and their personal, inherently limited experience. In this paper, we report on the systematic step we have taken in investigating the nature and impact of architectural smells. We have selected a set of representative architectural smells\u00a0\u2026", "num_citations": "60\n", "authors": ["627"]}
{"title": "Exploiting architectural style to develop a family of applications\n", "abstract": " Reuse of large-grain software components offers the potential for significant savings in application development cost and time. Successful reuse of components and component substitutability depend both on the qualities of the components reused as well as the software context in which the reuse is attempted. Disciplined approaches to the structure and design of software applications offer the potential of providing a hospitable setting for such reuse. The authors present the results of a series of exercises designed to determine how well off-the-shelf constraint solvers could be reused in applications designed in accordance with the C2 software architectural style. The exercises involved the reuse of SkyBlue and Amulet's one-way formula constraint solver. The authors constructed numerous variations of a single application, i.e. an application family. The paper summarises the style and presents the results from the\u00a0\u2026", "num_citations": "59\n", "authors": ["627"]}
{"title": "Synthesizing partial component-level behavior models from system specifications\n", "abstract": " Initial system specifications, such as use-case scenarios and properties, only partially specify the future system. We posit that synthesizing partial component-level behavior models from these early specifications can improve software development practices. In this paper, we provide a novel algorithm for deriving a Modal Transition System (MTS) for individual system components from system-level scenario and property specifications. The generated MTSs capture the possible component implementations that (1) necessarily provide the behavior required by the scenarios,(2) restrict behavior forbidden by the properties, and (3) leave the behavior that is neither explicitly required nor forbidden as undefined. We also show how our algorithm helps to discover potential design flaws.", "num_citations": "56\n", "authors": ["627"]}
{"title": "Recovering architectural design decisions\n", "abstract": " Designing and maintaining a software system's architecture typically involve making numerous design decisions, each potentially affecting the system's functional and nonfunctional properties. Understanding these design decisions can help inform future decisions and implementation choices and can avoid introducing regressions and architectural inefficiencies later. Unfortunately, design decisions are rarely well documented and are typically a lost artifact of the architecture creation and maintenance process. The loss of this information can thus hurt development. To address this shortcoming, we develop RecovAr, a technique for automatically recovering design decisions from the project's readily available history artifacts, such as an issue tracker and version control repository. RecovAr uses state-of-the-art architectural recovery techniques on a series of version control commits and maps those commits to issues\u00a0\u2026", "num_citations": "54\n", "authors": ["627"]}
{"title": "Smart redundancy for distributed computation\n", "abstract": " Many distributed software systems allow participation by large numbers of untrusted, potentially faulty components on an open network. As faults are inevitable in this setting, these systems utilize redundancy and replication to achieve fault tolerance. In this paper, we present a novel \"smart\" redundancy technique called iterative redundancy, which ensures efficient replication of computation and data given finite processing and storage resources, even when facing Byzantine faults. Iterative redundancy is more efficient and more adaptive than comparable state-of-the-art techniques that operate in environments with unknown system resource reliability. We show how systems that solve computational problems using a network of independent nodes can benefit from iterative redundancy. We present a formal analytical analysis and an empirical analysis, demonstrate iterative redundancy on a real-world volunteer\u00a0\u2026", "num_citations": "53\n", "authors": ["627"]}
{"title": "Adaptable architectural middleware for programming-in-the-small-and-many\n", "abstract": " A recent emergence of small, resource-constrained, and highly-mobile computing platforms presents numerous new challenges for software developers. We refer to development in this new setting as programming-in-the-small-and-many (Prism). This paper provides a description and evaluation of a middleware intended to support software architecture-based development in the Prism setting. The middleware, called Prism-MW, provides highly efficient and scalable implementation-level support for the key aspects of Prism application architectures. Additionally, Prism-MW is easily extensible to support different application requirements suitable for the Prism setting. Prism-MW is accompanied with design, analysis, deployment, and run-time monitoring tool support. It has been applied in a number of applications and used as an educational tool in a graduate-level embedded systems course. Recently, Prism\u00a0\u2026", "num_citations": "52\n", "authors": ["627"]}
{"title": "A formal approach to heterogeneous software modeling\n", "abstract": " The problem of consistently engineering large, complex software systems of today is often addressed by introducing new, \u201cimproved\u201d models. Examples of such models are architectural, design, structural, behavioral, and so forth. Each software model is intended to highlight a particular view of a desired system. A combination of multiple models is needed to represent and understand the entire system. Ensuring that the various models used in development are consistent relative to each other thus becomes a critical concern. This paper presents an approach that integrates and ensures the consistency across an architectural and a number of design models. The goal of this work is to combine the respective strengths of a powerful, specialized (architecture-based) modeling approach with a widely used, general (design-based) approach. We have formally addressed the various details of our approach, which\u00a0\u2026", "num_citations": "51\n", "authors": ["627"]}
{"title": "Multimodal sensing for pediatric obesity applications\n", "abstract": " In this paper, a wireless body area network comprised of heterogeneous sensors is developed for wearable health monitoring applications. The ultimate application space is in the context of pediatric obesity. The specific task examined herein is activity detection based on heart rate monitor and accelerometer data. Based on statistical analysis of experimental data for different key states (lying down, sitting, standing, walking and running), a multimodal detection strategy is proposed. The resulting detector can achieve 85-95% accuracy in state detection. It is observed that the accelerometer is more informative for the active states, while the heart rate monitor is more informative for the passive states.", "num_citations": "50\n", "authors": ["627"]}
{"title": "Enabling the Refinement of a Software Architecture into a Design\n", "abstract": " Software architecture research has thus far mainly addressed formal specification and analysis of coarse-grained software models. The formality of architectural descriptions, their lack of support for downstream development activities, and their poor integration with mainstream approaches have made them unattractive to a large segment of the development community. This paper demonstrates how a mainstream design notation, the Unified Modeling Language (UML), can help address these concerns. We describe a semiautomated approach developed to assist in refining a high-level architecture specified in an architecture description language (ADL) into a design described with UML. To this end, we have integrated DRADEL, an environment for architecture modeling and analysis, with Rational Rose\u00ae, a commercial off-the-shelf (COTS) UML modeling tool. We have defined a set of rules to transform an\u00a0\u2026", "num_citations": "50\n", "authors": ["627"]}
{"title": "Leveraging architectural models to inject trust into software systems\n", "abstract": " Existing software systems have become increasingly durable and their lifetimes have significantly lengthened. They are increasingly distributed and decentralized. Our dependence on them has grown tremendously. As such, the issues of trustworthiness and security have become prime concerns in designing, constructing, and evolving software systems. However, the exact meanings of these concepts are not universally agreed upon, nor is their role in the different phases of the software development lifecycle. In this paper, we argue that trustworthiness is a more broadly encompassing term than security, and that the two are often interdependent. We then identify a set of dimensions of trustworthiness. Finally, we analyze how the key elements of a software system's architecture can be leveraged in support of those trustworthiness dimensions. Our ultimate goal is to apply these ideas in the context of a concrete\u00a0\u2026", "num_citations": "48\n", "authors": ["627"]}
{"title": "Component-based perspective on software mismatch detection and resolution\n", "abstract": " Existing approaches to modelling software systems all too often neglect the issue of component-mismatch identification and resolution. The traditional view of software development over-emphasises synthesis at the expense of analysis \u2013 the latter frequently being seen as a problem which only needs to be dealt with during the integration stage towards the end of a development project. The paper discusses two software modelling and analysis techniques, all tool supported, and emphasises the vital role analysis can play in identifying and resolving risks early on. This work also combines model-based development (e.g. architectural modelling) with component-based development (e.g. COTS and legacy systems), and shows how their mismatch-detection capabilities complement one another to provide a more comprehensive coverage of development risks.", "num_citations": "48\n", "authors": ["627"]}
{"title": "Extending architectural representation in UML with view integration\n", "abstract": " UML has established itself as the leading OO analysis and design methodology. Recently, it has also been increasingly used as a foundation for representing numerous (diagrammatic) views that are outside the standardized set of UML views. An example are architecture description languages. The main advantages of representing other types of views in UML are 1) a common data model and 2) a common set of tools that can be used to manipulate that model. However, attempts at representing additional views in UML usually fall short of their full integration with existing views. Integration extends representation by also describing interactions among multiple views, thus capturing the inter-view relationships. Those inter-view relationships are essential to enable automated identification of consistency and conformance mismatches. This work describes a view integration framework and demonstrates how\u00a0\u2026", "num_citations": "48\n", "authors": ["627"]}
{"title": "Separating fact from fiction in software architecture\n", "abstract": " Explicit focus on architecture has shown tremendous potential to improve the current state-of-the-art in software development. Relatively quickly, software architecture research has produced credible results. However, some of this initial success has also resulted in unrealistic expectations and failure to recognize the limits of this line of research, which can result in backlash when the unrealistic expectations are not met. One solution is to attempt to clearly delineate the boundaries of applicability and effectiveness of software architectures. This paper represents a step in that direction: it dispels some common misconceptions about architectures and discusses problem areas for which architecture is well suited and those for which it is not.\u2019", "num_citations": "48\n", "authors": ["627"]}
{"title": "A family of software architecture implementation frameworks\n", "abstract": " Software architectures provide high-level abstractions for representing the structure, behavior, and key properties of software systems. Various architecture description languages, styles, tools, and technologies have emerged over the past decade. At the same time, there has been comparatively little focus on techniques and technologies for transforming architectural models into running systems. This often results in significant differences between conceptual and concrete architectures, rendering system evolution and maintenance difficult. Furthermore, it calls into question the ability of developers to consistently transfer the key architectural properties into system implementations. One solution to this problem is to employ architectural frameworks. Architectural frameworks provide support for implementing, deploying, executing, and evolving software architectures. This paper describes the design of and our\u00a0\u2026", "num_citations": "47\n", "authors": ["627"]}
{"title": "A methodology and framework for creating domain-specific development infrastructures\n", "abstract": " Domain-specific architectures, middleware platforms, and analysis techniques leverage domain knowledge to help engineers build systems more effectively. An integrated set of these elements is called a domain-specific development infrastructure (DSDI). DSDIs are commonly created in a costly, ad-hoc fashion because current model-driven engineering (MDE) technologies lack sufficient mechanisms for capturing the semantics of domain concepts. In this paper, we propose a methodology for incorporating semantics within MDE frameworks to simplify and automate DSDI integration. We also present and evaluate a framework, called XTEAM, that implements our approach, resulting in structured processes and enforceable guidelines for DSDI integration. We have applied our approach to several DSDIs, and report on the benefits accrued.", "num_citations": "43\n", "authors": ["627"]}
{"title": "Support for disconnected operation via architectural self-reconfiguration\n", "abstract": " In distributed and mobile environments, the connections among the hosts on which a software system is running are often unstable. As a result of connectivity losses, the overall availability of the system decreases. The distribution of software components onto hardware nodes (i.e., deployment architecture) may be ill-suited for the given state of the target hardware environment and may need to be altered to improve the software system's availability. In this paper, we present a flexible, software architecture-based solution for disconnected operation that increases the availability of a system during disconnection by allowing the system to monitor and automatically redeploy itself.", "num_citations": "40\n", "authors": ["627"]}
{"title": "A sealant for inter-app security holes in android\n", "abstract": " Android's communication model has a major security weakness: malicious apps can manipulate other apps into performing unintended operations and can steal end-user data, while appearing ordinary and harmless. This paper presents SEALANT, a technique that combines static analysis of app code, which infers vulnerable communication channels, with runtime monitoring of inter-app communication through those channels, which helps to prevent attacks. SEALANT's extensive evaluation demonstrates that (1) it detects and blocks inter-app attacks with high accuracy in a corpus of over 1,100 real-world apps, (2) it suffers from fewer false alarms than existing techniques in several representative scenarios, (3) its performance overhead is negligible, and (4) end-users do not find it challenging to adopt.", "num_citations": "39\n", "authors": ["627"]}
{"title": "An architectural style for solving computationally intensive problems on large networks\n", "abstract": " Large networks, such as the Internet, pose an ideal medium for solving computationally intensive problems, such as NP-complete problems, yet no well-scaling architecture for computational Internet-sized systems exists. We propose a software architectural style for large networks, based on a formal mathematical study of crystal growth that will exhibit properties of (1) discreetness (nodes on the network cannot learn the algorithm or input of the computation), (2) fault-tolerance (malicious, faulty, and unstable nodes may not break the computation), and (3) scalability (communication among the nodes does not increase with network or problem size).", "num_citations": "39\n", "authors": ["627"]}
{"title": "Estimating software component reliability by leveraging architectural models\n", "abstract": " Software reliability techniques are aimed at reducing or eliminat-ing failures in software systems. Reliability in software systems istypically measured during or after system implementation. How-ever, software engineering methodology lays stress on doing the\" correct things\" early on in the software development lifecycle inorder to curb development and maintenance costs. In this paper, wepropose a framework for reliability estimation of software compo-nents at the level of software architecture.", "num_citations": "38\n", "authors": ["627"]}
{"title": "Fault and adversary tolerance as an emergent property of distributed systems' software architectures\n", "abstract": " Fault and adversary tolerance have become not only desirable but required properties of software systems because mission-critical systems are commonly distributed on large networks of insecure nodes. In this paper, we describe how the tile style, an architectural style designed to distribute computation, can inject fault and adversary tolerance. The result is a notion of tolerance that is entirely abstracted away from the functional properties of the software system. The client may specify what fraction of the network is faulty or malicious (eg, 25%) and the acceptable system failure rate (eg, 2-10), and the system's architecture adjusts automatically to ensure a failure rate no higher than the one specified. The technique is entirely automated and consists of a\" smart redundancy\" mechanism that brings the failure rate exponentially close to 0 by slowing down the execution speed linearly.", "num_citations": "37\n", "authors": ["627"]}
{"title": "Consistent architectural refinement and evolution using the unified modeling language\n", "abstract": " Architecture Description Languages (ADLs) comprise a sizeable set of modeling techniques that are aimed at bridging the gap between requirements engineering and low-level design and code. ADLs excel in their ability to model high-level functional and non-functional aspects of software systems and have demonstrated increasing support for trade-off analyses (ie, requirements feasibility) and simulation. On the downside, ADLs are highly specialized and tend to rely on abstract notions such as roles and responsibilities. This creates problems when it comes to refining software artifacts into platform-specific programming constructs and combining solutions derived via different ADLs. Over the last years, we have devised mechanisms for transforming architecture models into implementation code by leveraging the Unified Modeling Language (UML). This paper presents an overview of our approach which is accompanied by extensive tool support.", "num_citations": "37\n", "authors": ["627"]}
{"title": "Scientific software as workflows: From discovery to distribution\n", "abstract": " Scientific workflows-models of computation that capture the orchestration of scientific codes to conduct in silico research-are gaining recognition as an attractive alternative to script-based orchestration. Even so, researchers developing scientific workflow technologies still face fundamental challenges, including developing the underlying science of scientific workflows. You can classify scientific-workflow environments according to three major phases of in silico research: discovery, production, and distribution. On the basis of this classification, scientists can make more-informed decisions regarding the adoption of particular workflow environments.", "num_citations": "35\n", "authors": ["627"]}
{"title": "Software architectures and embedded systems: a match made in heaven?\n", "abstract": " One area from which we might gain leverage in the ubiquitous- and embedded-systems domain is software architecture, which has emerged over the past decade as an area of intense interest among researchers and practitioners. Such interest has resulted in many approaches to dealing with architectural description and analysis, architectural styles, domain-specific and application family architectures, and architecture-based dynamic system adaptation. By and large, however, these approaches share assumptions that make them suited specifically to the domain of traditional, desktop-based development platforms. Those comparatively few architecture-based solutions that have focused on software systems for embedded devices have faced some traditional development challenges (such as applying solutions across an application family) but have also had different priorities (for example, ensuring efficient\u00a0\u2026", "num_citations": "34\n", "authors": ["627"]}
{"title": "Multi-view software component modeling for dependability\n", "abstract": " Modeling software components from multiple perspectives provides complementary views of a software system and enables sophisticated analyses of its functionality. A software component is traditionally modeled from one or more of four functional aspects: interface, static behavior, dynamic behavior, and interaction protocol. Each of these aspects helps to ensure different levels of component compatibility and interoperability. Existing approaches to component modeling have either focused on only one of the aspects (e.g., interfaces in various IDLs) or on well-understood combinations of pairs of aspects (e.g., interfaces and their associated pre- and post-conditions in static behavior models). We advocate that, in order to accrue the true benefits of component-based software development, one needs to model all four aspects of components. In such a case, ensuring the consistency among the multiple views\u00a0\u2026", "num_citations": "34\n", "authors": ["627"]}
{"title": "Software architecture and mobility: A roadmap\n", "abstract": " Modern software-intensive systems are characterized not only by the movement of data, as has been the case in traditional distributed systems, but also by the movement of users, devices, and code. Developing effective, efficient, and dependable systems in the mobile setting is challenging. Existing architectural principles need to be adapted and novel architectural paradigms devised. In this paper, we give an overview of the intersection of the areas of software architecture and mobility. We consider mobility from two related perspectives: (1) mobile software, which represents the computing functionality designed to migrate across hardware devices at runtime and execute on mobile hardware platforms, and (2) mobile systems, which are computing applications that include mobile software and hardware elements. We study the advances in both these areas, highlight representative existing solutions, and identify\u00a0\u2026", "num_citations": "33\n", "authors": ["627"]}
{"title": "Keeping data private while computing in the cloud\n", "abstract": " The cloud offers unprecedented access to computation. However, ensuring the privacy of that computation remains a significant challenge. In this paper, we address the problem of distributing computation onto the cloud in a way that preserves the privacy of the computation's data even from the cloud nodes themselves. The approach, called sTile, separates the computation into small subcomputations and distributes them in a way that makes it prohibitively hard to reconstruct the data. We evaluate sTile theoretically and empirically: First, we formally prove that sTile systems preserve privacy. Second, we deploy a prototype implementation on three different networks, including the globally-distributed PlanetLab testbed, to show that sTile is robust to network delay and efficient enough to significantly outperform existing privacy-preserving approaches.", "num_citations": "31\n", "authors": ["627"]}
{"title": "Toward architecture-based reliability estimation\n", "abstract": " Over 30 years of research have gone into software reliability engineering during testing. With today\u2019s complex software systems however, reliability has to be built into the early phases of development, including architectural design. We present a software architecture-based approach to estimating component reliability. Our stochastic reliability model is applicable to early stages of development when the implementation artifacts are unavailable and the exact execution profile is unknown.", "num_citations": "31\n", "authors": ["627"]}
{"title": "Formal definition of the chiron-2 software architectural style\n", "abstract": " The Chiron-2 style is a new software architectural style designed to support the particular needs of applications with a graphical user interface aspect. Several experimental systems have been built to demonstrate its intended goals. The conceptual architectures of those systems were depicted by \"boxes and arrows.\" This notation is too ambiguous and a more formal definition is needed.This paper presents a formal specification of the C2 style. In particular, C2 components and connectors, their rules of composition, and communication between them are defined. This definition is evaluated with a set of independently devised requirements. Its utility and future uses are discussed.", "num_citations": "31\n", "authors": ["627"]}
{"title": "Model interpreter frameworks: A foundation for the analysis of domain-specific software architectures.\n", "abstract": " Prediction of the quality attributes of software architectures requires technologies that enable the application of analytic theories to component models. However, available analytic techniques generally operate on formal models specified in notations that cannot flexibly and intuitively capture the architectures of large-scale distributed systems. The construction of model interpreters that transform architectural models into analysis models has proved to be a complex and difficult task. This paper (1) describes a methodology for performing automated analysis of architectural models that simplifies the development of model interpreters and enables effective reuse of interpreter logic, and (2) demonstrates how a framework that utilizes the methodology can be designed, implemented, utilized, and evaluated. 1", "num_citations": "30\n", "authors": ["627"]}
{"title": "Software connectors and refinement in family architectures\n", "abstract": " Product families promote reuse of software artifacts such as architectures, designs and implementations. Product family architectures are difficult to create due to the need to support variations. Traditional approaches emphasize the identification and description of generic components, which makes it difficult to support variations among products. This paper presents an approach to modeling family architectures using generic software connectors that provide bounded ambiguity and support flexible product families. The paper also proposes an approach for transforming a family architecture to a product design through a four-way refinement and evolution process.", "num_citations": "28\n", "authors": ["627"]}
{"title": "Measuring product line architectures\n", "abstract": " Software application families and their accompanying architectures (also referred to as product line architectures or PLAs) are a promising area in which the potential of software component reuse can be fully realized. Evolving such application families necessitates making informed architectural decisions. Among industry and research communities, it is recognized that software metrics can provide guidance during the making of such decisions. In this paper, we introduce metrics that are specifically geared to assess product line architectures and help in maintaining their quality.", "num_citations": "27\n", "authors": ["627"]}
{"title": "A comprehensive exploration of challenges in architecture-based reliability estimation\n", "abstract": " Architecture-based reliability estimation is challenging: modern software is complex with numerous factors affecting a system\u2019s reliability. In this article, we address three core challenges for architecture-based estimation of a system\u2019s reliability: (1) defining an appropriate failure model based on characteristics of the system being analyzed, (2) dealing with uncertainties of the reliability-related parameters, due to the lack of system implementation, and (3) overcoming the barriers of complexity and scale inherent in modern software. For each challenge, we identify the essential elements of the problem space, outline promising solutions, and illustrate the problems and solutions using a robotics case study. First, we show how a failure model can be derived from the system requirements and architecture. Second, we suggest how information sources available during architectural design can be combined to\u00a0\u2026", "num_citations": "25\n", "authors": ["627"]}
{"title": "Self-adapting reliability in distributed software systems\n", "abstract": " Developing modern distributed software systems is difficult in part because they have little control over the environments in which they execute. For example, hardware and software resources on which these systems rely may fail or become compromised and malicious. Redundancy can help manage such failures and compromises, but when faced with dynamic, unpredictable resources and attackers, the system reliability can still fluctuate greatly. Empowering the system with self-adaptive and self-managing reliability facilities can significantly improve the quality of the software system and reduce reliance on the developer predicting all possible failure conditions. We present iterative redundancy, a novel approach to improving software system reliability by automatically injecting redundancy into the system's deployment. Iterative redundancy self-adapts in three ways: (1) by automatically detecting when the\u00a0\u2026", "num_citations": "24\n", "authors": ["627"]}
{"title": "Understanding software connector compatibilites using a connector taxonomy\n", "abstract": " Software systems of today are frequently composed from prefabricated, heterogeneous components that provide complex functionality and engage in complex interactions. Software architecture research has revealed the importance of component interactions on our ability to perform software composition. Various development organizations have found interaction mismatches to be both difficult and a core issue behind failed software integration efforts. This paper is aimed at improving the understanding of component interactions, embodied in the notion of software connectors, in order to prevent such failures. Our previous work has resulted in a four-level classification framework for studying the characteristics of connectors. This paper presents a comprehensive taxonomy of software connectors based on the previously published connector classification framework. This taxonomy is used to explain various existing software connectors and study compatibility of connector characteristics, intended to prevent component interaction mismatches.", "num_citations": "22\n", "authors": ["627"]}
{"title": "Exploiting software architecture implementation infrastructure in facilitating component mobility\n", "abstract": " To address the need for highly configurable and customizable distributed systems, researchers and practitioners are investigating various innovative approaches. One of the promising techniques emerging from this area of study is mobile computing. In this paper we present a software architecture-based approach to supporting code mobility. We exploit the modeling and implementation infrastructure for an architectural style that supports distributed and heterogeneous applications. Our approach leverages the style\u2019s highly decoupled components via explicit software connectors in providing the ability to move both data and code across the network in essentially the same manner. The approach has been successfully applied on networks of small, mobile, resource constrained devices (ie, hand-held computers). We illustrate our approach with the help of an example application.", "num_citations": "22\n", "authors": ["627"]}
{"title": "Unlocking the grid\n", "abstract": " The grid has emerged as a novel paradigm that supports seamless cooperation of distributed, heterogeneous computing resources in addressing highly complex computing and data management tasks. A number of software technologies have emerged to enable \u201dgrid computing\u201d. However, their exact nature, underlying principles, requirements, and architecture are still not fully understood and remain under-specified. In this paper, we present the results of a study whose goal was to try to identify the key underlying requirements and shared architectural traits of grid technologies. We then used these requirements and architecture in assessing five existing, representative grid technologies. Our studies show a fair amount of deviation by the individual technologies from the widely cited baseline grid architecture. Our studies also suggest a core set of critical requirements that must be satisfied by grid\u00a0\u2026", "num_citations": "21\n", "authors": ["627"]}
{"title": "Architectural support for programming-in-the-many\n", "abstract": " Over the past several decades software researchers and practitioners have proposed various approaches, techniques, and tools for developing large-scale software systems. The results of these efforts have been characterized as programming-in-the-large (PitL). A new set of challenges has arisen with the emergence of inexpensive, small, heterogeneous, resource-constrained, possibly embedded, highly-distributed, and highly-mobile computing platforms. We refer to software development in this new setting as programming-in-the-many (PitM). This paper presents an approach intended to address the challenges of PitM. The centerpiece of our approach is a software architectural style with explicit support for the needs of PitM applications: selfawareness, distribution, heterogeneity, dynamism, mobility, and disconnected operation. The style is accompanied by a set of implementation, deployment, and runtime evolution tools targeted to a variety of traditional (ie, desktop) and mobile computing platforms. Our approach has been successfully applied on a number of applications. While several issues pertaining to PitM remain areas of future work, our experience to date has been very positive.", "num_citations": "20\n", "authors": ["627"]}
{"title": "A classification of disconnected operation techniques\n", "abstract": " Distributed, decentralized, and mobile systems are highly dependent on the underlying network. Due to network failures, these systems must address the problem of disconnected operation, i.e., continued functioning in the (near) absence of network accessibility. A number of approaches provide support for disconnected operation by employing different techniques. What is currently missing, however, is a general understanding of the applicability of these techniques to different kinds of software systems, and the manner in which they affect the overall system dependability. This paper strives to improve that understanding. We present a framework for classifying disconnected operation solutions and assess several representative approaches according to the proposed classification. This study highlights several pertinent areas that are currently not supported, that can help to motivate future work on this subject", "num_citations": "19\n", "authors": ["627"]}
{"title": "Leveraging program analysis to reduce user-perceived latency in mobile applications\n", "abstract": " Reducing network latency in mobile applications is an effective way of improving the mobile user experience and has tangible economic benefits. This paper presents PALOMA, a novel client-centric technique for reducing the network latency by prefetching HTTP requests in Android apps. Our work leverages string analysis and callback control-flow analysis to automatically instrument apps using PALOMA's rigorous formulation of scenarios that address\" what\" and\" when\" to prefetch. PALOMA has been shown to incur significant runtime savings (several hundred milliseconds per prefetchable HTTP request), both when applied on a reusable evaluation benchmark we have developed and on real applications.", "num_citations": "18\n", "authors": ["627"]}
{"title": "Architectural-based speculative analysis to predict bugs in a software system\n", "abstract": " Over time, a software system's code and its underlying design tend to decay steadily and, in turn, to complicate the system's maintenance. In order to address that phenomenon, many researchers tried to help engineers predict parts of a system that are most likely to create problems while or even before they are modifying the system. Problems that creep into a system may manifest themselves as bugs, in which case engineers have no choice but to fix them or develop workarounds. However, these problems may also be more subtle, such as code clones, circular dependencies among system elements, very large APIs, individual elements that implement multiple diffuse concerns, etc. Even though such architectural and code\" smells\" may not crash a system outright, they impose real costs in terms of engineers' time and effort, as well as system correctness and performance. Along the time, implicit problems may be\u00a0\u2026", "num_citations": "18\n", "authors": ["627"]}
{"title": "Automated analysis and code generation for domain-specific models\n", "abstract": " Domain-specific languages (DSLs) concisely express the essential features of system designs. However, using a DSL for automated analysis and code generation requires developing specialized tools. We describe how to create model analysis and code generation tools that can be applied to a large family of DSLs, and show how we created the LIGHT platform, a suite of such tools for the family of software architecture-based DSLs. These tools can be easily reused off-the-shelf with new DSLs, freeing engineers from having to custom-develop them. The key innovation underlying our strategy is to enhance DSL metamodels with additional semantics, and then automatically synthesize configurations and plug-ins for flexible analysis and code generation frameworks. Our evaluation shows that, for a DSL of typical size, using our strategy relieves software engineers of developing approximately 17,500 lines of code\u00a0\u2026", "num_citations": "18\n", "authors": ["627"]}
{"title": "Improving system understanding via interactive, tailorable, source code analysis\n", "abstract": " In situations in which developers are not familiar with a system or its documentation is inadequate, the system\u2019s source code becomes the only reliable source of information. Unfortunately, source code has much more detail than is needed to understand the system, and it disperses or obscures high-level constructs that would ease the system\u2019s understanding. Automated tools can aid system understanding by identifying recurring program features, classifying the system modules based on their purpose and usage patterns, and analyzing dependencies across the modules. This paper presents an iterative, user-guided approach to program understanding based on a framework for analyzing and visualizing software systems. The framework is built around a pluggable and extensible set of clues about a given problem domain, execution environment, and/or programming language. We evaluate our approach\u00a0\u2026", "num_citations": "18\n", "authors": ["627"]}
{"title": "Modeling multiple aspects of software components\n", "abstract": " A software component is typically modeled from one or more of four functional aspects: interface, static behavior, dynamic behavior, and interaction protocol. Each of these aspects helps to ensure different levels of component compatibility and interoperability. Existing approaches to component modeling have either focused on only one of the aspects (eg, interfaces in various IDLs) or on well-understood combinations of two of the aspects (eg, interfaces and their associated pre-and post-conditions in static behavioral modeling approaches). This paper argues that, in order to accrue the true benefits of componentbased software development, one may need to model all four aspects of components. However, this requires that consistency among the multiple aspects be maintained. We offer an approach to modeling components using the four-view perspective (called the Quartet) and identify the points at which the consistency among the models must be maintained.", "num_citations": "17\n", "authors": ["627"]}
{"title": "A framework for the assessment and selection of software components and connectors in cots-based architectures\n", "abstract": " Software systems today are composed from prefabricated commercial components and connectors that provide complex functionality and engage in complex interactions. Unfortunately, because of the distinct assumptions made by developers of these products, successfully integrating them into a software system can be complicated, often causing budget and schedule overruns. A number of integration risks can often be resolved by selecting the 'right' set of COTS components and connectors that can be integrated with minimal effort. In this paper we describe a framework for selecting COTS software components and connectors ensuring their interoperability in software-intensive systems. Our framework is built upon standard definitions of both COTS components and connectors and is intended for use by architects and developers during the design phase of a software system. We highlight the utility of our\u00a0\u2026", "num_citations": "16\n", "authors": ["627"]}
{"title": "Probabilistic automata for architecture-based reliability assessment\n", "abstract": " Non-functional properties, such as reliability and performance, should be assessed as early as possible in a system's life cycle for cost effectiveness reasons. Hence, several software architecture-based reliability assessment techniques have been proposed. These techniques quantitatively analyze a system's or a component's behavior, which is typically represented using probabilistic generative automata. However, we demonstrate that generative automata do not appropriately capture information available in an operational profile. Furthermore, we overview other existing probabilistic automata formalisms; we identify their features and shortcomings when capturing an operational profile. As a way to circumvent the identified deficiencies, we introduce probabilistic component interface protocols, a new probabilistic automata formalism that supports intuitive and direct mapping of an operational profile. Finally, we\u00a0\u2026", "num_citations": "15\n", "authors": ["627"]}
{"title": "Unmanned and autonomous systems of systems test and evaluation: Challenges and opportunities\n", "abstract": " The introduction of Unmanned and Autonomous Systems (UAS) brings substantial, interesting, and in many cases, new challenges to the Department of Defense\u2019s Test and Evaluation community. The test and evaluation of UASs becomes significantly more complicated than traditional systems, especially as we approach more fully autonomous systems and need to test integrated systems of systems in joint military operational testing environments. Compounding the multi-faceted considerations involved in test and evaluation, systems have continuously increasing complexity and capabilities and can be at different maturity levels. Emergent properties, particularly those that are unplanned and undesired, also need to be considered. Challenges identified by the Unmanned and Autonomous Systems Test community and related to the test and evaluation of the UASs are discussed. This paper presents various approaches for addressing these challenges including an innovative Prescriptive and Adaptive Testing Framework and decision support system, PATFrame.", "num_citations": "15\n", "authors": ["627"]}
{"title": "From system specifications to component behavioral models\n", "abstract": " Early system specifications, such as use-case scenarios and properties, rarely completely specify the system. Partial models of system-level behavior, derived from these specifications, have proven useful in early system analysis. We believe that the scope of possible analyses can be enhanced by utilizing component-level partial models. In this paper, we outline an algorithm for deriving a component-level Modal Transition System (MTS) from system-level scenario and property specifications. The generated MTSs capture the possible component implementations that (1) necessarily provide the behavior required by the scenarios, (2) restrict behavior forbidden by the properties, and (3) leave the behavior that is neither explicitly required nor forbidden as undefined. We discuss how these generated models can help discover system-design flaws, support requirements elicitation, and help select off-the-shelf\u00a0\u2026", "num_citations": "14\n", "authors": ["627"]}
{"title": "Software architectural support for disconnected operation in highly distributed environments\n", "abstract": " In distributed and mobile environments, the connections among the hosts on which a software system is running are often unstable. As a result of connectivity losses, the overall availability of the system decreases. The distribution of software components onto hardware nodes (i.e., deployment architecture) may be ill-suited for the given target hardware environment and may need to be altered to improve the software system\u2019s availability. The critical difficulty in achieving this task lies in the fact that determining a software system\u2019s deployment that will maximize its availability is an exponentially complex problem. In this paper, we present an automated, flexible, software architecture-based solution for disconnected operation that increases the availability of the system during disconnection. We provide a fast approximative solution for the exponentially complex redeployment problem, and assess its performance.", "num_citations": "14\n", "authors": ["627"]}
{"title": "Toward predicting architectural significance of implementation issues\n", "abstract": " In a software system's development lifecycle, engineers make numerous design decisions that subsequently cause architectural change in the system. Previous studies have shown that, more often than not, these architectural changes are unintentional by-products of continual software maintenance tasks. The result of inadvertent architectural changes is accumulation of technical debt and deterioration of software quality. Despite their important implications, there is a relative shortage of techniques, tools, and empirical studies pertaining to architectural design decisions. In this paper, we take a step toward addressing that scarcity by using the information in the issue and code repositories of open-source software systems to investigate the cause and frequency of such architectural design decisions. Furthermore, building on these results, we develop a predictive model that is able to identify the architectural\u00a0\u2026", "num_citations": "13\n", "authors": ["627"]}
{"title": "Component-aware triggered scenarios\n", "abstract": " Use-case scenarios, with notations such as UML sequence diagrams, are widely used to specify software system behavior. Although intuitive, these notations allow engineers to specify behaviors with unintended semantic side-effects. To address these inconsistencies, one class of languages targets triggered scenario specifications for expressing a system's reactive behaviors. However, these languages lack adequate facilities for modeling the intended behavior of the individual system components. This runs the risks of sacrificing the expressive power required to model component behaviors, misinterpreting the stakeholder intent, and misspecifying the component behaviors. The risks are particularly prominent when the requirements specification and software architecture specification are refined iteratively and in parallel. To remedy these problems, we propose component-aware Triggered Scenarios (caTS), an\u00a0\u2026", "num_citations": "13\n", "authors": ["627"]}
{"title": "Architecting data-intensive software systems\n", "abstract": " Data-intensive software is increasingly prominent in today\u2019s world, where the collection, processing, and dissemination of ever-larger volumes of data has become a driving force behind innovation in the early twenty-first century. The trend towards massive data manipulation is broad-based, and case studies can be examined in domains from politics, to intelligence gathering, to scientific and medical research. The scientific domain in particular provides a rich array of case studies that offer ready insight into many of the modern software engineering, and software architecture challenges associated with data-intensive systems.", "num_citations": "13\n", "authors": ["627"]}
{"title": "Toward a framework for classifying disconnected operation techniques\n", "abstract": " Distributed, decentralized, and mobile systems are highly dependent on the underlying network. Due to network connectivity failures, these systems must address the problem of disconnected operation, ie, continued functioning in the absence or near-absence of network accessibility. A number of existing approaches provide support for disconnected operation by employing different techniques. What is currently missing, however, is a general understanding of the applicability of these techniques to different kinds of software systems, and the manner in which they affect the overall system dependability. This paper strives to improve that understanding. We present a framework for classifying disconnected operation solutions and assess several representative approaches according to the proposed classification. This study highlights several pertinent areas that are currently not supported, helping to motivate our future work.", "num_citations": "13\n", "authors": ["627"]}
{"title": "Eva: A tool for visualizing software architectural evolution\n", "abstract": " EVA is a tool for visualizing and exploring architectures of evolving, long-lived software systems. EVA enables its users to assess the impact of architectural design decisions and their systems' overall architectural stability.(Demo Video: https://youtu. be/Q3bnIQz13Eo)", "num_citations": "12\n", "authors": ["627"]}
{"title": "How software architects collaborate: Insights from collaborative software design in practice\n", "abstract": " The increasingly complex software systems are developed by globally distributed engineering teams consisting of a number of members who collaborate to gather the requirements, as well as design, implement, and test the system. Unlike other development activities, collaborative software design has not yet been studied extensively, and thus it is not fully understood how it is conducted in practice. We have commenced a series of studies to address this. As the first step, we have interviewed architects at a global software solutions provider to observe how collaborative software design works in practice. In this paper, we report the observations and insights we gained from the interviews related to (1) the various roles of software architects in collaborative software design, (2) the project-specific networks of software architects, (3) the impacts of geographic distribution, and (4) the collaboration cost drivers. We also\u00a0\u2026", "num_citations": "12\n", "authors": ["627"]}
{"title": "Entrusting private computation and data to untrusted networks\n", "abstract": " We present sTile, a technique for distributing trust-needing computation onto insecure networks, while providing probabilistic guarantees that malicious agents that compromise parts of the network cannot learn private data. With sTile, we explore the fundamental cost of achieving privacy through data distribution and bound how much less efficient a privacy-preserving system is than a nonprivate one. This paper focuses specifically on NP-complete problems and demonstrates how sTile-based systems can solve important real-world problems, such as protein folding, image recognition, and resource allocation. We present the algorithms involved in sTile and formally prove that sTile-based systems preserve privacy. We develop a reference sTile-based implementation and empirically evaluate it on several physical networks of varying sizes, including the globally distributed PlanetLab testbed. Our analysis\u00a0\u2026", "num_citations": "12\n", "authors": ["627"]}
{"title": "Architecture-based software reliability estimation: Problem space, challenges, and strategies\n", "abstract": " In modern software-intensive systems, reliability is considered to be one of the most critical non-functional properties. To build software in a cost-efficient manner, reliability should be analyzed at architecture design time. In this paper, we consider the problem space of, challenges in, and strategies for architecture-based estimation of a software system\u2019s reliability. Architecture-based reliability estimation is challenging\u2013\u2013during early design phases, architects lack information necessary for precisely determining a system\u2019s reliability, such as the system\u2019s operational profile and failure and recovery information. Thus, we explore how such information can be obtained from alternative sources. Finally, we present a critical overview of existing approaches to architecture-based reliability estimation, in order to indicate directions for future research.", "num_citations": "12\n", "authors": ["627"]}
{"title": "Identifying and addressing uncertainty in architecture-level software reliability modeling\n", "abstract": " Assessing reliability at early stages of software development, such as at the level of software architecture, is desirable and can provide a cost-effective way of improving a software system's quality. However, predicting a component's reliability at the architectural level is challenging because of uncertainties associated with the system and its individual components due to the lack of information. This paper discusses representative uncertainties which we have identified at the level of a system's components, and illustrates how to represent them in our reliability modeling framework. Our preliminary evaluation indicates promising results in our framework's ability to handle such uncertainties.", "num_citations": "12\n", "authors": ["627"]}
{"title": "Distilling software architectural primitives from architectural styles\n", "abstract": " Architectural styles codify commonly used idioms in system structures, organizations, and interactions. Existing classifications of architectural styles provide empirical guidelines for style selection, but fail to systematically characterize styles or reveal their foundations. Moreover, the mapping between architectural styles and their implementations is generally poorly understood. This paper introduces an approach towards a systematic understanding of architectural styles based on a small set of recurring architectural primitives. Also proposed is an extensible composition framework for architectural styles based on these primitives, which is, in turn, used as the basis of style implementation. This framework, called Alfa, has been applied successfully to four different architectural styles to date. Lightweight compositional models of the styles have been created using the Alloy formal modeling notation, whereas implementation infrastructures for these styles have been developed in Java. While it would be premature to claim that Alfa is sufficiently expressive to represent any arbitrary architectural style, our experience to date suggests that we have converged on a set of primitives that effectively captures the characteristics of a large number of styles. As such, we feel that Alfa already presents a unique contribution and is worthy of careful further study.", "num_citations": "12\n", "authors": ["627"]}
{"title": "Modeling behavior in compositions of software architectural primitives\n", "abstract": " Software architectures and architectural styles are increasingly used for designing large-scale software systems. Alfa is a framework for the composition of style-based software architectures from a small set of primitives. It models the behavior of architectural components and connectors as orderings among events at their inputs and outputs. Formalizing such behavior is useful for checking conformance of architectures to their styles. We therefore propose a formal approach that uses data-abstract constraint automata to model the behavior of Alfa's compositions, and to verify their behavioral style conformance. We have also developed an automated conformance analyzer for Alfa.", "num_citations": "11\n", "authors": ["627"]}
{"title": "An end-to-end domain specific modeling and analysis platform\n", "abstract": " Software architecture models are specifications of the principal design decisions about a software system that primarily govern its structure, behavior, and quality. They serve as a basis for experimentation and rationalization of design decisions. While many techniques utilize and support software architecture modeling and analysis, a recurring obstacle is that often advances in one area (eg, architecture-based modeling) tend to be disconnected from those in another area (eg, simulation). In this work we aim to provide an end-to-end model-driven engineering approach, called DoMAINPro, that bridges this gap and supports engineers throughout the software modeling, analysis, and implementation process by automatically synthesizing a range of model interpreters (MI). DomainPro is also available to download at https://goo. gl/4sRT9B. You can also watch the demo video describing DomainPro's prominent features\u00a0\u2026", "num_citations": "10\n", "authors": ["627"]}
{"title": "Architecture-level reliability prediction of concurrent systems\n", "abstract": " Stringent requirements on modern software systems dictate evaluation of dependability qualities, such as reliability, as early as possible in a system's life cycle. A primary shortcoming of the existing design-time reliability prediction approaches is their lack of support for modeling and analyzing concurrency in a scalable way. To address the scalability challenge, we propose SHARP, an architecture-level reliability prediction framework that analyzes a hierarchical scenario-based specification of system behavior. It achieves scalability by utilizing the scenario relations embodied in this hierarchy. SHARP first constructs and solves models of basic scenarios, and combines the obtained results based on the defined scenario dependencies; the dependencies we handle are sequential and parallel execution of multiple scenarios. This process iteratively continues through the scenario hierarchy until finally obtaining the\u00a0\u2026", "num_citations": "10\n", "authors": ["627"]}
{"title": "Injecting software architectural constraints into legacy scientific applications\n", "abstract": " While software architectures have been shown to aid developers in maintenance, reuse, and evolution as well as many other software engineering tasks, there is little language-level support for these architectural concepts in scientific programming languages such as Fortran and C. Because many existing scientific codes are written in legacy languages, it is difficult to integrate them into architected software systems. By wrapping scientific codes in architecturally-aware interfaces, we are able to componentize legacy programs, integrating them into systems built with first-class architectural elements while meeting performance and throughput requirements of scientific codes.", "num_citations": "10\n", "authors": ["627"]}
{"title": "Software connector classification and selection for data-intensive systems\n", "abstract": " Data-intensive systems and applications transfer large volumes of data and metadata to highly distributed users separated by geographic distance and organizational boundaries. An influential element in these large volume data transfers is the selection of the appropriate software connector that satisfies user constraints on the required data distribution scenarios. Currently, this task is typically accomplished by consulting \"gurus\", who rely on their intuitions, at best backed by anecdotal evidence. In this paper we present a systematic approach for selecting software connectors based on eight key dimensions of data distribution that we use to represent the data distribution scenarios. Our approach, dubbed DISCO, has been implemented as a Java-based framework. The early experience with DISCO indicates good accuracy and scalability.", "num_citations": "10\n", "authors": ["627"]}
{"title": "SEALANT: A detection and visualization tool for inter-app security vulnerabilities in androic\n", "abstract": " Android's flexible communication model allows interactions among third-party apps, but it also leads to inter-app security vulnerabilities. Specifically, malicious apps can eavesdrop on interactions between other apps or exploit the functionality of those apps, which can expose a user's sensitive information to attackers. While the state-of-the-art tools have focused on detecting inter-app vulnerabilities in Android, they neither accurately analyze realistically large numbers of apps nor effectively deliver the identified issues to users. This paper presents SEALANT, a novel tool that combines static analysis and visualization techniques that, together, enable accurate identification of inter-app vulnerabilities as well as their systematic visualization. SEALANT statically analyzes architectural information of a given set of apps, infers vulnerable communication channels where inter-app attacks can be launched, and visualizes\u00a0\u2026", "num_citations": "9\n", "authors": ["627"]}
{"title": "Tile architectural style for privacy-preserved distributed computing\n", "abstract": " A method and system for privacy-preserved distributed computing on large networks using a tile-based architecture is disclosed. An expression for a tile seed assembly characterizing a problem, such as an NP-complete problem, may be determined. The solution to the tile seed assembly is a full tile assembly including a plurality of tile types. In a network of participating nodes, a tile type may be assigned to each node. A description of a tile type specific to a node may be provided to each node. A tile seed assembly may be established on selected nodes. Through progressive recruitment and replication, the tile assembly may mature, in response to the problem being solvable, into a full tile assembly having a solution. The solution may be received by the client computer.", "num_citations": "9\n", "authors": ["627"]}
{"title": "Discreetly distributing computation via self-assembly\n", "abstract": " One aspect of large networks, such as the Internet, is the colossal amount of computation its nodes could perform if that computation were distributed efficiently. The Internet has already led to solving some problems, eg, NP-complete problems, that were unlikely to have been solved on individual computers. However, the methods leading to those solutions disclosed inputs, algorithms, and outputs to the Internet nodes. It has even been argued in the literature that it is not possible to ask an entity for help with solving NP-complete problems without disclosing the input and algorithm.In this paper, we present an architectural style that distributes computation over a network discreetly, such that no small group of computers (asymptotically smaller than \u0398 (n log n) for an n-bit input) knows the algorithm or the input. The style abstracts away the distribution and only requires writing non-parallel code, automating in turn the parallelization of computation. Further, the style is faultand adversary-tolerant (malicious, faulty, and unstable nodes may not break the computation) and scalable (communication among the nodes does not increase with network or problem size). Systems designed and constructed according to the style free the architect from having to worry about these non-functional properties. We formally argue that our architectural style has all three properties: discreetness, fault and adversary tolerance, and scalability.", "num_citations": "9\n", "authors": ["627"]}
{"title": "Reusing Off-the-Shelf Components to Develop a Family of Applications in the C2 Architectural Style\n", "abstract": " Reuse of large-grain software components offers the potential for significant savings in application development cost and time. Successful reuse of components and component substitutability depends both on qualities of the components reused as well as the software context in which the reuse is attempted. Disciplined approaches to the structure and design of software applications offers the potential of providing a hospitable setting for such reuse. We present the results of a series of exercises designed to determine how well \u201coff-the-shelf\u201d constraint solvers could be reused in applications designed in accordance with the C2 software architectural style. The exercises involved the reuse of SkyBlue and Amulet\u2019s one-way formula constraint solver. We constructed numerous variations of a single application (thus an application family). The paper summarizes the style and presents the results from the exercises. The exercises were successful in a variety of dimensions; one conclusion is that the C2 style offers significant potential for the development of application families and that wider trials are warranted. 1", "num_citations": "9\n", "authors": ["627"]}
{"title": "Analyzing design tradeoffs in large-scale socio-technical systems through simulation of dynamic collaboration patterns\n", "abstract": " Emerging online collaboration platforms such as Wikipedia, Twitter, or Facebook provide the foundation for socio-technical systems where humans have become both content consumer and provider. Existing software engineering tools and techniques support the system engineer in designing and assessing the technical infrastructure. Little research, however, addresses the engineer\u2019s need for understanding the overall socio-technical system behavior. The effect of fundamental design decisions becomes quickly unpredictable as multiple collaboration patterns become integrated into a single system.               We propose the simulation of human and software elements at the collaboration level. We aim for detecting and evaluating undesirable system behavior such as users experiencing repeated update conflicts or software components becoming overloaded. To this end, this paper contributes (i) a\u00a0\u2026", "num_citations": "8\n", "authors": ["627"]}
{"title": "Construction of Analytic Frameworks for Component-Based Architectures.\n", "abstract": " Prediction of non-functional properties of software architectures requires technologies that enable the application of analytic theories to component models. However, available analytic techniques generally operate on formal models specified in notations that cannot flexibly and intuitively capture the architectures of large-scale distributed systems. The construction of model interpreters that transform architectural models into analysis models has proved to be a time-consuming and difficult task. This paper describes (1) how a reusable model interpreter framework can reduce the complexity involved in this task, and (2) how such a framework can be designed, implemented, utilized, and verified.", "num_citations": "8\n", "authors": ["627"]}
{"title": "Separating architectural concerns to ease program understanding\n", "abstract": " This paper presents an iterative, user-guided approach to program understanding based on a framework for analyzing and visualizing software systems. The framework is built around a pluggable and extensible set of clues about a given problem domain, execution environment, and/or programming language. The approach leverages two orthogonal architectural views of a system and describes how a proper identification of boundaries for separate concerns helps in reasoning about the system.", "num_citations": "8\n", "authors": ["627"]}
{"title": "Composing style-based software architectures from architectural primitives\n", "abstract": " Software architectures provide high-level abstractions to deal with the complexity and richness of large-scale software systems. Often, similar architectural organization is found in different software systems. Architectural styles are an approach to exploit such similarities between different architectures. A style is useful in the design of architectures due to guarantees of desirable stylistic properties across architectures based on that style. Styles are also believed to bring economies of scale in the design and implementation of architectures. Although there are many systematic techniques for describing and selecting styles, there is considerably less underpinning for the systematic design and construction of style-based architectures.", "num_citations": "8\n", "authors": ["627"]}
{"title": "A connector-aware middleware for distributed deployment and mobility\n", "abstract": " To address the need for highly configurable and customizable distributed systems, researchers and practitioners are investigating various innovative approaches. One of the promising techniques emerging from this area of study is mobile computing. In this paper we present an architecture-based approach to supporting distributed deployment and mobility of software systems. We exploit a connector-aware architectural middleware in providing these capabilities. The approach has been successfully tested on several applications for networks of small, mobile, resource constrained devices (e.g., hand-held computers).", "num_citations": "8\n", "authors": ["627"]}
{"title": "Relating Software Component Models\n", "abstract": " A software component is typically modeled at one or more of four levels: interface, static behavior, dynamic behavior, and interaction protocol. Each of these levels helps to ensure different aspects of component compatibility and interoperability. Existing approaches to component modeling have either focused on only one of the levels (eg, interfaces in various IDLs) or on well-understood combinations of two of the levels (eg, interfaces and their associated pre-and post-conditions in static behavioral modeling approaches). This paper argues that, in order to accrue the true benefits of component-based software development, one may need to model components at all four levels. Before that can be possible, one needs to understand the relationships among the different models. We detail one such pair-wise relationship\u2014between static and dynamic component models\u2014and draw parallels between it and the remaining models.", "num_citations": "8\n", "authors": ["627"]}
{"title": "Middleware for Software Architecture-Based Development in Distributed, Mobile, and Resource-Constrained Environments\n", "abstract": " Over the past several decades software researchers and practitioners have proposed various approaches, techniques, and tools for developing large-scale software systems. The results of these efforts have been characterized as programming-inthe-large (PitL). A new set of challenges has arisen with the emergence of inexpensive, small, heterogeneous, resourceconstrained, possibly embedded, highly-distributed, and highly-mobile computing platforms. We refer to software development in this new setting as programming-in-the-smalland-many (Prism). This paper provides a description and evaluation of a middleware intended to support software architecture-based development of applications in the Prism setting. The middleware provides implementation-level support for the key aspects of Prism application architectures: components, connectors, architectural configurations, and communication events. Additionally, the middleware directly facilitates several system qualities necessitated by Prism, including light weight, distribution, mobility, context awareness, asynchrony, and support for disconnected operation. Our middleware has been applied successfully in a number of applications and used as an educational tool in a graduate-level embedded systems course. Recently, the middleware has been successfully evaluated by a major industrial organization for use in one of their key distributed embedded systems. While a number of issues remain to be explored, our experience with the middleware thus far has been very positive, indicating that the principles of architecture-based software development can be successfully applied in the Prism\u00a0\u2026", "num_citations": "8\n", "authors": ["627"]}
{"title": "Proactive detection of higher-order software design conflicts\n", "abstract": " Software architects who collaboratively evolve a software model rely on version control systems (VCSs) to synchronize their individual changes to the model. However, with the current generation of software model VCSs, architects remain unaware of newly arising conflicts until the next synchronization, raising the risk that delayed conflict resolution will be much harder. There are existing tools that proactively detect analogous conflicts at the level of source code. However, it is challenging to directly use them for software models because those tools are constructed to manage code-level rather than model-level changes. Furthermore, no empirical data is currently available regarding the impact of proactive conflict detection on collaborative design. In this paper, we report on our design-level proactive conflict detection research, which specifically targets a class of higher-order conflicts that do not prevent merging but\u00a0\u2026", "num_citations": "7\n", "authors": ["627"]}
{"title": "Distributing refinements of a system-level partial behavior model\n", "abstract": " Early in a system's life cycle, a system's behavior is typically partially specified using scenarios, invariants, and temporal properties. These specifications prohibit or require certain behaviors, while leaving other behaviors uncategorized into either of those. Engineers refine the specification by eliciting more requirements to finally arrive at a complete behavioral description. Partial-behavior models have been utilized as a formal foundation for capturing partial system specifications. Mapping the requirements to partial behavior models enables automated analyses (e.g., requirements consistency checking) and helps to elicit new requirements. Under the current practices, software systems are reasoned about and their behavior specified exclusively at the system level, disregarding of the fact that a system typically consists of interacting components. However, exclusively refining a behavior specification at the system\u00a0\u2026", "num_citations": "7\n", "authors": ["627"]}
{"title": "Improving dependability of component-based systems via multi-versioning connectors\n", "abstract": " The promise of architecture-based software development is that complex systems can be built and evolved reasonably quickly and reliably using coarse-grained components. However, practice has shown that many problems of traditional software development still persist in a component-based setting, and even that new problems are introduced. A class of such problems steins from the opportunity to perform system upgrade at the component level. The problems include errors in the functionality introduced by a new version of a component, decreased reliability of a new component version, inefficiency of components designed for reuse, component interaction mismatches, and so on. This paper presents an approach intended to alleviate the problems caused by component upgrades. Our approach focuses on software architectures both at system design and implementation levels. Specifically, our\u00a0\u2026", "num_citations": "7\n", "authors": ["627"]}
{"title": "ADL independent architectural representation in XML\n", "abstract": " The Extensible Markup Language, XML [1], is a proper subset of the Standard Generalized Markup Language, or SGML, which has been accepted as a standard by the World Wide Web Consortium (W3C) for structuring electronic documents.However, the first and still the most widely used markup language for the web is none other than HTML, or Hypertext Markup Language. HTML\u2019s goals are achieved by using pre-defined tags to add meaning to data. Taking this a step further, XML adds the ability to add the concept of relationships between tags, which helps in capturing the semantics of a particular domain.", "num_citations": "7\n", "authors": ["627"]}
{"title": "Bringing Architecture Thinking into Developers' Daily Activities\n", "abstract": " In software engineering there has traditionally been a distinction between high-level architecting and lower level implementation activities (e.g. coding and testing). Those who are developing and maintaining the software are often not engaged in early design activities. For example, software programmers tend to lack design and architecture skills and architects are often blamed for not knowing how to write good code and for not being involved in low-level implementation tasks. This results in software quality issues, software implementations that drifted from initial design, and incorrect or missing architectural decisions in the code. The continuous move towards reducing upfront architecture design efforts, and the popularity of practices such as test-driven development highlight the importance of enriching software implementation practices with new architecting notions, practices and tools. This was the topic of the\u00a0\u2026", "num_citations": "6\n", "authors": ["627"]}
{"title": "A reference architecture for integrated development and run-time environments\n", "abstract": " The need to support different stages of a software system's life-cycle in a software development environment has resulted in the emergence of plug-ins that can monitor and adapt the resulting system's run-time environment. In several recent self-adaptive systems, the existence of these plug-ins has resulted in the integration of the development and runtime environments. We introduce a novel reference architecture that captures the architectures of disparate development environments - from those, such as traditional development environments, that have no run-time plug-ins, to the ones, such as the recently emerging development environments, that are fully integrated with the run-time environments. This reference architecture aids the study and understanding of development environments. More importantly, adherence to the architecture improves the run-time availability of certain critical system facilities while\u00a0\u2026", "num_citations": "6\n", "authors": ["627"]}
{"title": "Revisiting modal interface automata\n", "abstract": " Modern software systems are typically built of components that communicate through their external interfaces. A component's behavior can be effectively described using finite state automata-based formalisms (e.g., statecharts [5]). The basic formalism, labelled transition systems, describes the behavior of a component in terms of states and labeled transitions. The more advanced formalisms, such as modal transition systems and interface automata, extend LTS to incorporate additional information related to interface operation controllability - distinguishing between input, output, and internal actions - and the possible partiality of a component's specification - distinguishing between required and unknown (maybe) behaviors. Capturing the controllability and partiality aspects of a component's specification facilitates (1) checking interface compatibility, (2) checking whether one component can safely replace another\u00a0\u2026", "num_citations": "6\n", "authors": ["627"]}
{"title": "Preserving privacy in distributed computation via self-assembly\n", "abstract": " We present the tile style, an architectural style that allows the creation of distributed software systems for solving NP-complete problems on large public networks. The tile style preserves the privacy of the algorithm and data, tolerates faulty and malicious nodes, and scales well to leverage the size of the public network to accelerate the computation. We exploit the known property of NP-complete problems to transform important real-world problems, such as protein folding, image recognition, and resource allocation, into canonical problems, such as 3-SAT, that the tile style solves. We provide a full formal analysis of the tile style that indicates the style preserves data privacy as long as no adversary controls more than half of the public network. We also present an empirical evaluation showing that problems requiring privacy-preservation can be solved on a very large network using the tile style orders of magnitude faster than using existing alternatives.", "num_citations": "6\n", "authors": ["627"]}
{"title": "Coupling Static and Dynamic Semantics in an Architecture Description Language\n", "abstract": " One of the problems in designing today\u2019s complex, reactive and mission critical systems is providing extensive multi-dimensional analysis of the systems at the architectural level. Architecture description languages (ADLs) provide such analysis capabilities. However, ADLs mainly focus on specific system aspects (eg, formal refinement rules, deadlock detection, or schedulability analysis). In this paper, we describe an approach to combining the syntax and semantics of two heterogeneous architecture modeling notations in such a way that they remain consistent. The resulting integrated notation and toolset expand the available architecture modeling and analysis capabilities. In turn, this enables the architect to uncover a wider range of problems early in the development process and thus assists in reducing the development costs. 1.", "num_citations": "6\n", "authors": ["627"]}
{"title": "A microservice architecture for online mobile app optimization\n", "abstract": " A large number of techniques for analyzing and optimizing mobile apps have emerged in the past decade. However, those techniques' components are notoriously difficult to extract and reuse outside their original tools. This paper introduces MAOMAO, a microservice-based reference architecture for reusing and integrating such components. MAOMAO's twin goals are (1) adoption of available app optimization techniques in practice and (2) improved construction and evaluation of new techniques. The paper uses several existing app optimization techniques to illustrate both the motivation behind MAOMAO and its potential to fundamentally alter the landscape in this area.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Making well-informed software design decisions\n", "abstract": " Design decisions software architects make directly impact system quality. Real-world systems involve a large number of such decisions, and each decision is typically influenced by others and involves trade-offs in system properties. This paper poses the problem of making complex, interacting design decision relatively early in the project's lifecycle and outlines a search-based and simulation-based approach for helping architects make these decisions and understand their effects.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Toward a Classification Framework for Software Architectural Smells\n", "abstract": " Architectural decay is a commonly occurring phenomenon in long-lived software systems. During a system\u2019s lifetime, its architecture gradually degrades via the appearance of architectural \u201cbad smells\u201d, which are instances of poorly thoughtthrough design decisions. To date, there has been limited in-depth study of this phenomenon, its root causes, its characteristics, or the trends it may follow. Instead, both researchers and practitioners have relied on folklore, and their own intuitions and experiences, when referring to architectural smells and their negative impact on software systems. Two key reasons for the absence of large-scale studies of architectural smells are the lack of a systematic categorization of smells and further the absence of algorithms for automatically detecting smells. In this paper, we propose a framework (1) to classify architectural smells based on their characteristics and (2) to detect the smells based on their symptoms. The categorization includes five different classes of smells, of which we focus on four that can be readily detected with the help of existing architecture recovery and analysis techniques. We illustrate the framework with 11 distinct architectural smells across the four categories. We formally define each smell, present a detection algorithm for it, and illustrate it with an example from real systems.", "num_citations": "5\n", "authors": ["627"]}
{"title": "A highly extensible simulation framework for domain-specific architectures\n", "abstract": " Discrete event simulation is a powerful and flexible mechanism for analyzing both the functional characteristics and quality properties of software design models. However, software engineers do not utilize simulations in many situations where it has significant potential benefits because (1) the programming model used by existing discrete event simulators is not well-suited for capturing domain-specific software designs, and (2) customizing and optimizing core simulation algorithms based on domain-specific requirements and constraints is difficult and, in some cases, not possible. In this paper, we describe a new approach to constructing discrete event simulations of software systems that removes both of these obstacles. First, our simulation approach supports a software architecture-based programming model and allows software engineers to define domain-specific modeling constructs. Second, our simulation approach allows domain-specific optimization of simulation engine functions through modification or replacement of core framework components. To demonstrate the implementation of our approach, we present XDEVS, is a highly extensible discrete event simulation framework that provides both of the above capabilities. We evaluated the utility and efficiency of XDEVS using a large-scale simulation of a volunteer computing system, and this evaluation confirmed that XDEVS represents an improvement over the current stateof-the-art.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Improving the quality of requirements specifications via automatically created object-oriented models\n", "abstract": " In industry, reviews and inspections are the primary methods to identify ambiguities, inconsistencies, and under specifications in natural language (NL) software requirements specifications (SRSs). However, humans have difficulties identifying ambiguities and tend to overlook inconsistencies in a large NL SRS. This paper presents a three-step, semi-automatic method, supported by a prototype tool, for identifying inconsistencies and ambiguities in NL SRSs. The method combines the strengths of automation and human reasoning to overcome difficulties with reviews and inspections. First, the tool parses a NL SRS according to a constraining grammar. Second, from relationships exposed in the parse, the tool creates the classes, methods, variables, and associations of an object-oriented analysis model of the specified system. Third, the model is diagrammed so that a human reviewer can use the model to detect ambiguities and inconsistencies. Since a human finds the problems, the tool has to have neither perfect recall nor perfect precision. The effectiveness of the approach is demonstrated by applying it and the tool to a widely published example NL SRS. A separate study evaluates the tool's domain-specific term detection.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Style-based software architectural compositions as domain-specific models\n", "abstract": " Architectural styles represent composition patterns and constraints at the software architectural level and are targeted at families of systems with shared characteristics. While both style-specific and style-neutral modeling environments for software architectures exist, creation of such environments is expensive and frequently involves reinventing the wheel. This paper describes the rapid design of a style-neutral architectural modeling environment, ViSAC. ViSAC is based on Alfa, a framework for constructing style-based software architectures from architectural primitives, and is obtained by configuring Vanderbilt University\u2019s Generic Modeling Environment (GME). Users can define their own styles in ViSAC and, in turn, use them to design software architectures. Moreover, ViSAC supports the hierarchical design of heterogeneous software architectures, ie, using multiple styles. The rich user interface of GME and support for domain-specific semantics enable interactive design of well-formed styles and architectures.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Programming-in-the-Many: A Software Engineering Paradigm for the 21st Century\n", "abstract": " Over the past several decades software researchers and practitioners have proposed various approaches, techniques, and tools for developing large-scale software systems. The results of these efforts have been characterized as programming-in-the-large (PitL). A new set of challenges has arisen with the emergence of inexpensive, small, heterogeneous, resource-constrained, possibly embedded, highly-distributed, and highly-mobile computing platforms. We refer to software development in this new setting as programming-in-the-many (PitM). This paper argues for a concerted research effort needed to address the challenges of PitM. As \u201cproof-of-concept\u201d we highlight the results of a research project we have conducted in this area over the past two years. While the details of our work may not be universally applicable, we believe that our approach suggests a plausible software engineering research agenda for the future. The centerpiece of our approach is a software architectural style with explicit support for the needs of PitM applications: self-awareness, distribution, heterogeneity, dynamism, mobility, and disconnected operation. The style is accompanied by a set of implementation, deployment, and runtime evolution tools targeted to a variety of traditional (ie, desktop) and mobile computing platforms. Our approach has been successfully applied on several applications. While a number of issues pertaining to PitM remain areas of future work, our experience to date has been very positive.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Reuse of off-the-shelf constraint solvers in C2-style architectures\n", "abstract": " Reuse of large-grain software components offers the potential for significant savings in application development cost and time. Successful reuse of components and component substitutability depends both on qualities of the components reused as well as the software context in which the reuse is attempted. Disciplined approaches to the structure and design of software applications offers the potential of providing a hospitable setting for such reuse. We present the results of a series of experiments designed to determine how well \u201coff-the-shelf\u201d constraint solvers could be reused in applications designed in accordance with the C2 software architectural style. The experiments involved the reuse of SkyBlue and Amulet\u2019s one-way formula constraint solver. We constructed numerous variations of a single application (thus an application family). The paper summarizes the style and presents the results from the experiments. The experiments were successful in a variety of dimensions; one conclusion is that the C2 style offers significant potential to application developers and that wider trials are warranted.", "num_citations": "5\n", "authors": ["627"]}
{"title": "Empirically assessing opportunities for prefetching and caching in mobile apps\n", "abstract": " Network latency in mobile software has a large impact on user experience, with potentially severe economic consequences. Prefetching and caching have been shown effective in reducing the latencies in browser-based systems. However, those techniques cannot be directly applied to the emerging domain of mobile apps because of the differences in network interactions. Moreover, there is a lack of research on prefetching and caching techniques that may be suitable for the mobile app domain, and it is not clear whether such techniques can be effective or whether they are even feasible. This paper takes the first step toward answering these questions by conducting a comprehensive study to understand the characteristics of HTTP requests in over 1,000 popular Android apps. Our work focuses on the prefetchability of requests using static program analysis techniques and cacheability of resulting responses. We\u00a0\u2026", "num_citations": "4\n", "authors": ["627"]}
{"title": "SHARP: A scalable approach to architecture-level reliability prediction of concurrent systems\n", "abstract": " Early prediction of reliability is important in building dependable software. Existing approaches are unable to model concurrent systems in a scalable way. To address the scalability challenge, we propose a framework that is applicable at the architecture level. Our framework achieves scalability by approaching the system from the perspective of usage scenarios and by employing a hierarchical solution. Specifically, we solve lower granularity scenario-based submodels and a higher granularity system model; we then combine their results to obtain a system reliability estimate. Our evaluation indicates that (a) the proposed hierarchical framework is accurate, and (b) that it is more scalable than existing techniques.", "num_citations": "4\n", "authors": ["627"]}
{"title": "The gridlite dream: Bringing the grid to your pocket\n", "abstract": " The emergence of small, mobile, inexpensive computing platforms has made computation possible virtually anywhere, and has opened up countless opportunities for distributed and decentralized collaboration and information sharing among a wide range of actors. The software-intensive systems of today are increasingly shaped by their decentralized, resource-constrained, embedded, autonomic, and mobile (DREAM) computing environments. In this paper we present GridLite, a software architecture-based grid platform suitable for deployment in DREAM environments. Our prototype implementation of GridLite represents an effective and highly efficient marriage of our OODT data grid and Prism-MW architectural middleware solutions. The ultimate goal of GridLite is to extend the reach of the grid all the way to people\u2019s \u201cpockets\u201d. Our initial experience suggests that this goal is achievable and worthy of\u00a0\u2026", "num_citations": "4\n", "authors": ["627"]}
{"title": "E. James Whitehead, and Jason E. Robbins. A component-and message-based architectural style for gui software\n", "abstract": " While a large fraction of application system code is devoted to user interface (UI) functions, support for reuse in this domain has largely been confined to creation of UI tool-kits (\" widgets\u201d). We present a novel architectural style directed at supporting larger grain reuse and flexible system composition. Moreover, the style supports design of distributed, concurrent, applications. A key aspect of the style is that components are not built with any dependencies on what typically would be considered lower-level components, such as user interface toolkits. Indeed, all components are oblivious to the existence of any components to which notification messages are sent. Asynchronous notification mes-sages and asynchronous request messages are the sole basis for inter-component communication. While our focus has been on applications involving graphical user interfaces, the style has the potential for broader applicability. Several trial applications using the style are described'. ically made use of two primary run-time architectures: the client-server style (as exemplified by X windows) and the call-back model, a control model in which application functions are invoked under the control of the user interface. Also well known is the model-view-controller (MVC) style [KP88), which is commonly exploited in Smalltalk applica-tions. The Arch style is more recent, and has an associated meta-model [Wor92).This paper presents a new architectural style. It is designed to support the particular needs of applications that have a graphical user interface aspect, but the style clearly has the potential for supporting other types of applications. This style draws its key ideas\u00a0\u2026", "num_citations": "4\n", "authors": ["627"]}
{"title": "Continuous analysis of collaborative design\n", "abstract": " In collaborative design, architects' individual design decisions may conflict and, when joined, may violate system consistency rules or non-functional requirements. These design conflicts can hinder collaboration and result in wasted effort. Proactive detection of code-level conflicts has been shown to improve collaborative productivity, however, the computational resource requirements for proactively computing design conflicts have hindered its applicability in practice. Our survey and interviews of 50 architects from six large software companies find that 60% of their projects involve collaborative design, that architects consider integration costly, and that design conflicts are frequent and lead to lost work. To aid collaborative design, we re-engineer FLAME, our prior design conflict detection technique, to use cloud resources and a novel prioritization algorithm that, together, achieve efficient and nonintrusive conflict\u00a0\u2026", "num_citations": "3\n", "authors": ["627"]}
{"title": "Workshop on software engineering for cloud computing:(SECLOUD 2011)\n", "abstract": " Cloud computing is emerging as more than simply a technology platform but a software engineering paradigm for the future. Hordes of cloud computing technologies, techniques, and integration approaches are widely being adopted, taught at the university level, and expected as key skills in the job market. The principles and practices of the software engineering and software architecture community can serve to help guide this emerging domain. The fundamental goal of the ICSE 2011 Software Engineering for Cloud Workshop is to bring together the diverse communities of cloud computing and of software engineering and architecture research with the hopes of sharing and disseminating key tribal knowledge between these rich areas. We expect as the workshop output a set of identified key software engineering challenges and important issues in the domain of cloud computing, specifically focused on how\u00a0\u2026", "num_citations": "3\n", "authors": ["627"]}
{"title": "Helios: Impact analysis for eventbased systems\n", "abstract": " Event-based software systems contain highly-decoupled components that interact by exchanging messages via implicit invocation, thus allowing flexible system composition and adaptation. At the same time, these inherently desirable properties render an event-based system more difficult to understand and evolve since, in the absence of explicit dependency information, an engineer has to assume that any component in the system may potentially interact with, and thus depend on, any other component. Software analysis techniques that have been used successfully in traditional, explicit invocation-based systems are of little use in this domain. In order to aid the understandability of, and assess the impact of changes in, event-based systems, we propose Helios, a technique that combines component-level (1) controlflow and (2) state-based dependency analysis with systemlevel (3) structural analysis to produce a complete and accurate message dependence graph for a system. We have applied Helios to applications constructed on top of four different event-based implementation platforms. We summarize the results of several such applications. We demonstrate that Helios enables effective event-based impact analysis and quantify its improvements over existing alternatives. 1.", "num_citations": "3\n", "authors": ["627"]}
{"title": "High performance software architectures: A connector-oriented approach\n", "abstract": " Scientists in multiple domains have begun conducting investigations using a new paradigm centered on computer simulation as means of experimentation and theory validation. Unfortunately, our ability to program simulations that are equal to the task of truly new science is handicapped by our lack of support for high performance computing abstractions. In this position paper, we explore the potential role of software architectures as a means of encapsulating many of the services required for parallel programming into explicit first-class software connectors.", "num_citations": "3\n", "authors": ["627"]}
{"title": "Engineering reliability into hybrid systems via rich design models: recent results and current directions\n", "abstract": " Software reliability techniques are aimed at reducing or eliminating failures in software systems. Reliability in software systems has traditionally been measured during or after system implementation. However, software engineering methodology lays stress on doing the \"correct things\" early on in the software development lifecycle in order to curb development and maintenance costs. In this paper, we argue that reliability of a software system should be assessed throughout the system's life span, starting with the software architecture level. Our research goal is to estimate the reliability of software systems in early design stages, which we believe involves the ability to reason about numerous uncertainties that exist in this stage, including uncertainty due to lack of execution artifacts. Our proposed approach is to develop techniques that will couple software architectural models with a suite of stochastic reliability\u00a0\u2026", "num_citations": "3\n", "authors": ["627"]}
{"title": "Toward composition of style-conformant software architectures\n", "abstract": " The codification of software architectural decisions made to address recurring software development challenges results in architectural styles. The primary benefit of architectural styles is that properties demonstrated at the level of a style are carried over into the software system architectures constructed using that style. However, in the absence of comprehensive techniques for checking conformance of a software architecture to its style (s), the expected stylistic properties are not always present in the architecture. This paper argues for a need to look beyond the existing formalizations of styles and architectures to construct style-conformant software architectures. The paper proposes a compositional formalization of styles and style-based architectures aimed at ensuring an architecture\u2019s conformance to its style (s).", "num_citations": "3\n", "authors": ["627"]}
{"title": "JavaBeans and software architecture\n", "abstract": " Java has emerged as a popular programming language and platform for Web applications. JavaBeans\u2122 defines the software component model in the Java programming language that is used for creating reusable, coarse-grained components. Beans are used in numerous complementary technologies including Enterprise JavaBeans, Java Abstract Windowing Toolkit (AWT), Java Database Connectivity (JDBC), Java Mail, and Java Management Extensions (JMX) to create software components. Beans provide a hybrid of object-oriented and loosely-coupled architectural styles, where the interaction between components is in the form of both events and method calls. This chapter focuses on the support for component technology in Java, specifically in the form of JavaBeans and its technology variants that fulfil the needs of Web application development. The chapter also discusses the role of JavaBeans and its technology variants in architecture-based software development.", "num_citations": "3\n", "authors": ["627"]}
{"title": "Automatic detection of latent software component relationships from online Q&A sites\n", "abstract": " Modern software system stacks are composed of large numbers of software components. These components may include a broad range of entities such as services, libraries, and frameworks, all intended to address specific requirements. It is not only necessary that these components satisfy respective functional and non-functional concerns, but also that the combinations of selected components work well together. The space of component combinations to explore is huge. Together with the almost universal lack of formal documentation suggesting desirable combinations and cautioning against undesirable ones, this renders the proper selection of combinations very challenging. For this reason, software engineers often solicit advice and document their experience on online forums such as community Q&A sites. In this paper, we show that these Q&A sites contain valuable knowledge about inter-component\u00a0\u2026", "num_citations": "2\n", "authors": ["627"]}
{"title": "Identifying Inter-Component Communication Vulnerabilities in Eventbased Systems\n", "abstract": " Event based systems are flexible, scalable, and adaptable based on its feature of non-determinism in event communication. However, this may yield security vulnerabilities in event communication between components. For example, malicious components can steal sensitive data or manipulate other components in an intended way. This paper introduces SCUTUM, a novel technique that automatically detects vulnerable event communication channels from event-based systems by combining static flow analysis and pattern matching. SCUTUM\u2019s evaluation demonstrated that it identifies vulnerable event communication channels with higher accuracy than existing techniques from 28 real-world apps and it is applicable to the apps comprising a number of components.", "num_citations": "2\n", "authors": ["627"]}
{"title": "Revisiting compatibility of input-output modal transition systems\n", "abstract": " Modern software systems are typically built of components that communicate through their external interfaces. The external behavior of a component can be effectively described using finite state automata-based formalisms. Such component models can then used for varied analyses. For example, interface automata, which model the behavior of components in terms of component states and transitions between them, can be used to check whether the resulting system is compatible. By contrast, partial-behavior modeling formalisms, such as modal transition systems, can be used to capture and then verify properties of sets of prospective component implementations that satisfy an incomplete requirements specification. In this paper, we study how pairwise compatibility should be defined for partial-behavior models. To this end, we describe the limitations of the existing compatibility definitions, propose a set of\u00a0\u2026", "num_citations": "2\n", "authors": ["627"]}
{"title": "iDARE\u2014a reference architecture for integrated software environments\n", "abstract": " Traditionally, software development environments have tended to treat a system's development\u2010time activities separately from its run\u2010time. After a system is in operation, it frequently needs to be maintained and evolved. In traditional environments, this results in frequent relocations of a system between the disjoint development and run\u2010time environments, which is undesirable for several reasons. A more effective solution is to couple the development and run\u2010time environments to directly monitor and adapt running systems. Given the growing need for interaction between development\u2010time and run\u2010time aspects of modern software systems, it is important to understand development and run\u2010time environments, and their relationship. To this end, we study and classify a wide range of software development environments on the basis of their level of interaction with the corresponding run\u2010time environments\u00a0\u2026", "num_citations": "2\n", "authors": ["627"]}
{"title": "Automatically mining specifications from invocation traces and method invariants\n", "abstract": " Software library documentation often describes the APIs of individual methods, but does not capture the intended protocols and method interactions. This can cause developers to misuse the library by invoking its methods out of sequence, while also restricting effective runtime detection of protocol violations and automated verification of the client code. Specification mining, if accurate, can help mitigate these problems. There are two classes of specification mining techniques: one that observes library executions, and another that identifies internal-state invariants. Unfortunately, models inferred by these state-of-the-art techniques often suffer from inaccuracies. In this paper, we aim to improve the quality of mined specifications in order to facilitate API understanding, test generation, and verification tasks. To that end, we combine the two classes of techniques in two novel ways, producing a pair of new model-inference techniques. We find that our new techniques improve significantly upon the state-of-the-art when applied to nine off-the-shelf libraries, increasing the precision of the inferred models by 4% and the recall by 41% on average. Additionally, we find that our approach automatically exposes both behavior that avoids raising exceptions and good-practice rules that capture proper library use, while being robust to noisy inputs.", "num_citations": "2\n", "authors": ["627"]}
{"title": "Software architecture challenges and opportunities for the 21st century: dynamism, mobility, autonomy, services, grids, and clouds\n", "abstract": " Developments in the area of software architecture over the past two decades have pushed architecture to the forefront of a number of critical software engineering activities: modeling, design, analysis, simulation, implementation, deployment, maintenance, and evolution. Architecture is advocated as an effective conceptual tool for addressing the many challenges of developing large, complex, distributed systems. Largely in parallel to these developments, significant advances have also been made in the domains of mobile, autonomic, service-oriented, grid-based, and most recently, cloud-based computing. The systems in these domains are also large, complex, and distributed; they are frequently expected to dynamically adapt to failures as well as changing requirements and execution contexts. At first blush, a number of the advances in these domains appear not to have resulted from an explicit software\u00a0\u2026", "num_citations": "2\n", "authors": ["627"]}
{"title": "A reference framework for requirements and architecture in biomedical Grid systems\n", "abstract": " In this paper we introduce the work done to define a framework for requirements and architectural understanding in biomedical grid computing systems. A set of core requirements for biomedical grids have been identified on the basis of our experience in the analysis and development of several biomedical and other grid systems including the National Cancer Institute 's Early Detection Research Network (EDRN) in the US and the National Cancer Research Institute (NCRI) Platform in the UK. The requirements have been specified taking into account different points of view and are intended as a core set that can be extended on the basis of project specific aspects. These are also mapped to existing architectures of biomedical grid systems, and their constituent components. Such a framework is intended as a guide for equipping developers with conceptual tools to avoid costly mistakes when architecting biomedical\u00a0\u2026", "num_citations": "2\n", "authors": ["627"]}
{"title": "Adapt: Event-passing protocol for reducing delivery costs in scatter-gather parallel processes\n", "abstract": " The scatter-gather event pattern is commonly used in many high-performance codes to deliver data subsets for use in data-parallel processes and return the results. There are a number of collective algorithms and multiple collective calls in the ubiquitous Message Passing Interface standards which perform aspects of gathering. Programmers have traditionally been left to their own devices, however, to perform complex scatterings of data subsets to processors executing the dataparallel computation. We have developed ADaPT, an Adaptive Data-parallel Publication/Subscription Transport protocol, to reduce the time lost to excessive synchronization with the unicast event-passing commands often employed to scatter data.", "num_citations": "2\n", "authors": ["627"]}
{"title": "ARTISAn: an approach and tool for improving software system understanding via interactive, tailorable source code analysis\n", "abstract": " In situations in which developers are not familiar with a system or its documentation is inadequate, the system's source code becomes the only reliable source of information. Unfortunately, source code has much more detail than is needed to understand the system, and it disperses or obscures high-level constructs that would ease the system\u2019s understanding. Automated tools can aid system understanding by identifying recurring program features, classifying the system modules based on their purpose and usage patterns, and analyzing dependencies across the modules. This paper presents an iterative, user-guided approach to program understanding based on a framework for analyzing and visualizing software systems. The framework is built around a pluggable and extensible set of clues about a given problem domain, execution environment, and/or programming language. We evaluate our approach by providing the analysis of our tool\u2019s results obtained from several case studies.", "num_citations": "2\n", "authors": ["627"]}
{"title": "Alfa: A framework for composing software architectures from architectural primitives\n", "abstract": " Architectural styles represent composition patterns and constraints at the software architectural level and are targeted at families of systems with shared characteristics. They enable architectural reuse and hence can bring economy to architecture-based software development. Existing research on architectural styles provides little guidance for the systematic design and construction of architectural style elements. This paper proposes a framework, Alfa, for systematically and constructively composing \u201carchitectural primitives\u201d to obtain elements of architectural styles. This is based on our observation that architectural styles and, indeed, software architectures share many underlying concepts that lead to architectural primitives. We have identified eight forms and nine functions as architectural primitives that reflect the syntactic and semantic characteristics of software architectures and are expressive enough to compose elements of architectural styles used in modern, distributed systems. Such an approach enables systematic construction of style-based architectures. In that direction, this paper evaluates the suitability of Alfa as an assembly language for software architectures and its suitability for composing architectural styles for network-based systems.", "num_citations": "2\n", "authors": ["627"]}
{"title": "Architectural Implications of Common Operator Interfaces\n", "abstract": " If a common operator interface (COI) for satellite ground systems is built with conventional user interface (UI) technology, then there is substantial risk that the UI will end up determining a significant part of the ground system\u2019s architecture. UI technology typically forces applications to be constructed as a set of call-backs to the UI. To avoid this situation an approach is required which sharply divides the user interface part of the system from the rest of the software. If the ground system is to run on heterogeneous hardware platforms a second sharp separation is also recommended: presentation and dialog decisions from platform specific toolkits. This presentation suggests a multi-level solution to this problem which is established at the architecture level and maintained in the implementation.", "num_citations": "2\n", "authors": ["627"]}
{"title": "eQual: informing early design decisions\n", "abstract": " When designing a software system, architects make a series of design decisions that directly impact the system's quality. The number of available design alternatives grows rapidly with system size, creating an enormous space of intertwined design concerns that renders manual exploration impractical. We present eQual, a model-driven technique for simulation-based assessment of architectural designs. While it is not possible to guarantee optimal decisions so early in the design process, eQual improves decision quality. eQual is effective in practice because it (1) limits the amount of information the architects have to provide and (2) adapts optimization algorithms to effectively explore massive spaces of design alternatives. We empirically demonstrate that eQual yields designs whose quality is comparable to a set of systems' known optimal designs. A user study shows that, compared to the state-of-the-art\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Strategies for Pattern-Based Detection of Architecturally-Relevant Software Vulnerabilities\n", "abstract": " Software vulnerabilities expose a system to security breaches. In this paper, we focus on vulnerabilities rooted in a system's architecture. Specifically, we describe our attempt at developing ways of depicting and detecting architectural vulnerabilities. Our guiding observation was that vulnerabilities that belong to the same category result in commonalities in the source code. This observation led us to hypothesize that it is possible to define patterns that can be used to detect similar vulnerabilities. To test this hypothesis, we collected a dataset of vulnerabilities reported for the Tomcat web server that spanned 20 different categories and 90 unique vulnerabilities. We represented each individual vulnerability with a Program Dependence Graph (PDG) and employed two approaches we believed to be especially promising based on the results they yielded when applied to similar problems. The first approach relied on\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Collaborative-Design Conflicts: Costs and Solutions\n", "abstract": " Collaborative design exposes software architects to the risk of making conflicting modeling changes that either can't be merged or, when merged, violate consistency rules, nonfunctional requirements, or other system constraints. Such design conflicts are common and incur a high cost, including having to redo and abandon work. Proactive conflict detection can alleviate this risk. This article motivates the need for design conflict detection, describes the benefits of such detection to practitioners, and identifies requirements for building detection tools. In particular, FLAME is a collaborative-design framework that efficiently and continuously detects design conflicts. This article is part of a theme issue on collaborative modeling.", "num_citations": "1\n", "authors": ["627"]}
{"title": "Editorial from the new editor in chief\n", "abstract": " TAKING over for Matt Dwyer as TSE\u2019s Editor-in-Chief (EIC) is a great honor and an even greater responsibility. Matt steps down with TSE firmly established as the premier software engineering research journal. At the same time, several challenges remain, not the least of which is the fact that the publishing trends in software engineering currently favor conferences at the expense of journals. There are several reasons behind this. Some of them are legitimate: Regular submission cycles, relatively quick decision and feedback, and preset deadlines are appealing, and they help to maintain a vibrant, growing research community in a rapidly moving field. Other reasons are not as laudable, nor are they good for the longterm health of the community in my view: Despite the low acceptance rates of top conferences and high quality of submissions they receive, conferences inherently attract more incremental work. It is\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Foreword by Nenad Medvidovic Behold the Golden Age of Software Architecture\n", "abstract": " In the mid-to-late 1990s, I had the fortune of witnessing a great deal of activity and innovation that, today, is sometimes referred to as the \u201cgolden age\u201d of software architecture research. As a community, we were trying to understand the phenomena underlying software systems' architectures, develop abstractions to capture those phenomena, construct models to embody the abstractions properly and effectively, analyze the models for interesting and important properties, and, finally, figure out how to implement systems that would inherit all of the positive and none of the negative characteristics we encountered along the way. This resulted in a seeming whirlwind of notations, techniques, tools, patterns, styles, and reference architectures. It was an incredibly exciting and fun time if you were a software architecture researcher. The rest, as they say, has been history.An issue that emerged somewhat more slowly and\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Isomorphism in model tools and editors\n", "abstract": " Domain-specific languages (DSLs) are modeling languages that are customized for a specific context or project. DSLs allow for fast and precise modeling because the language features and constructs can be precisely tailored based on the needs of the modeling effort. There exist highly customizable model-editing tools that can be easily configured to support DSLs defined by end-users (e.g., system architects, engineers, and analysts). However, to leverage models created using these tools for automated analysis, simulation, and code generation, end-users must build custom analysis tools and code generators. In contrast to model editors, the implementation and maintenance of these analysis and code generation tools can be tedious and hampers the utility of DSLs. In this paper, we posit that analysis and code generation tools for DSLs are, in fact, isomorphic to model editing tools. The implication of this insight\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Supporting refinement of partial behavior models under model composition and abstraction\n", "abstract": " During requirements elicitation and preliminary design, a system\u2019s behavior is typically partially specified: some behavior is defined as either forbidden or required, while other behavior is not yet categorized as either of those. The goal is then to gradually refine the specification and finally arrive at a complete behavioral description. Partial-behavior modeling formalisms, such as Modal Transition Systems, can support such gradual refinement. However, several challenges still remain, particularly in the context of hierarchical architectural specifications where (sub) system models are composed of smaller subsystems and components, and, in turn, abstracted to be made more compact and analyzable. Refinement of a behavior specification can be performed using models of varying scopes (eg, different subsystems) and levels of abstraction, depending on the stakeholder needs. The primary challenge then becomes ensuring that a refinement of a model is correct when that model is a composition (or abstraction) of other models; this problem has not been addressed in the existing literature. In this paper, we propose a framework that supports reasoning about behavior refinement of composite and abstract models. Our framework assures that (1) a refinement of a composition is realized with refinements of the individual composed models and (2) a refinement of an abstract model is interpreted in terms of a refinement of the detailed model.", "num_citations": "1\n", "authors": ["627"]}
{"title": "Crystal-growth-inspired algorithms for computational grids\n", "abstract": " Biological systems surpass man-made systems in many important ways. Most notably, systems found in nature are typically self-adaptive and self-managing, capable of surviving drastic changes in their environments, such as internal failures and malicious attacks on their components. Large distributed software systems have requirements common to those of some biological systems, particularly in the number and power of individual components and in the qualities of service of the system. However, it is not immediately clear how engineers can extract useful properties from natural systems and inject them into software systems.", "num_citations": "1\n", "authors": ["627"]}
{"title": "Injecting Robustness into Autonomic Grid Systems\n", "abstract": " Autonomic computational grids are self-organizing software systems that pool the computational resources of large public networks to solve computationally-intensive problems. While autonomic grids can scale to networks far larger than centralized grids, they have not seen the same adoption and success in industry due to an incomplete treatment of fault tolerance. In this paper, we propose two complementary mechanisms, progressive redundancy and redundant distribution, that secure autonomic grids by injecting robustness into insecure, possibly malicious networks. Progressive redundancy replicates computation in a way that reduces the probability of failure while minimizing the associated cost. Redundant distribution allows for the replication of computation in decentralized networks. We formally define the class of grid technologies to which progressive redundancy and redundant distribution apply and evaluate the cost and benefit of using the techniques. Progressive redundancy and redundant distribution reduce the probability of system failure exponentially, at a linear cost in the execution speed of the system.", "num_citations": "1\n", "authors": ["627"]}
{"title": "Software architecture and mobility: a perfect marriage or an uneasy alliance?\n", "abstract": " Developments in the area of software architecture over the past decade have pushed it to the forefront of a number of critical software engineering activities: modeling, design, analysis, simulation, implementation, deployment, and evolution. Architecture is advocated as an effective conceptual tool for addressing the many challenges of developing large, complex, distributed systems. Largely in parallel to these developments, significant advances have also been made in the domain of mobile computing. Many mobile systems are also large, complex, and distributed, yet a majority of the advances in this domain appear not to have resulted from an explicit software architectural focus. Despite this, architecture appears to offer clear benefits in this domain, as evidenced by some recent approaches. In this talk, I will overview the state-of-the-art in the area of mobile computing, with a specific focus on the role software\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "An architectural style for high-performance asymmetrical parallel computations\n", "abstract": " Researchers with deep knowledge of scientific domains are becoming more interested in developing highly-adaptive and irregular (asymmetrical) parallel computations, leading to development challenges for both delivery of data for computation and mapping of processes to physical resources. Using software engineering principles, we have developed a new communications protocol and architectural style for asymmetrical parallel computations called ADaPT. Utilizing the support of architecturally-aware middleware, we show that ADaPT provides a more efficient solution in terms of message passing and load balancing than asymmetrical parallel computations using collective calls in the Message-Passing Interface (MPI) or more advanced frameworks implementing explicit load-balancing policies. Additionally, developers using ADaPT gain significant windfall from good practices in software engineering, including\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "The GridLite DREAM: Bringing the Grid to Your Pocket\n", "abstract": " The emergence of small, mobile, embedded, inexpensive computing platforms (eg, PDAs, cell phones, GPS receivers) has made computation possible virtually anywhere. In turn, this has opened up countless possibilities for distributed and decentralized collaboration and information sharing among a wide range of individuals and organizations, including engineers, scientists, health and humanitarian workers, emergency response teams, law enforcement agencies, and average citizens. Fleets of mobile devices are, or will soon be, employed in complex scenarios such as land and sea exploration, environment monitoring, traffic management, fire fighting, and damage surveys in times of natural disaster. The software-intensive systems of today are increasingly shaped by their decentralized, resource-constrained, embedded, autonomic, and mobile (DREAM) computing environments.In parallel with this development, another exciting and promising direction in modern computing has emerged\u2013the grid. Grid computing connects dynamic collections of individuals, institutions, and resources to create virtual organizations, which support sharing, discovery, transformation, and distribution of data and computational resources. Distributed workflow, massive parallel computation, and knowledge discovery are only some of the applications of the grid. Grid applications involve large numbers of distributed devices executing large numbers of computational and data components. As such, they require techniques and tools for supporting their design, implementation, and dynamic evolution.", "num_citations": "1\n", "authors": ["627"]}
{"title": "Improving Availability of Distributed Event-Based Systems via Run-Time Monitoring and Analysis\n", "abstract": " Improving Availability of Distributed Event-Based Systems via Run-Time Monitoring and Analysis Page 1 Improving Availability of Distributed Event-Based Systems via Run-Time Monitoring and Analysis Sam Malek and Marija Mikic-Rakic Nels Beckman Nenad Medvidovic University of Southern California WADS 2004 Page 2 May 25th ICSE-WADS 2004 2 Outline \u27a2 Motivation \u25a1 Problem description \u25a1 Prism-MW \u25a1 DeSi \u25a1 Algorithms \u25a1 Concluding remarks Page 3 May 25th ICSE-WADS 2004 3 Motivation Deployment architecture: distribution (ie, assignment) of software components onto hardware nodes. How good is this deployment architecture? What are its properties? How should it be modified to ensure higher availability? Page 4 May 25th ICSE-WADS 2004 4 Outline \u2751 Motivation \u27a2 Problem description \u25a1 Prism-MW \u25a1 DeSi \u25a1 Algorithms \u25a1 Concluding remarks Page 5 May 25th ICSE-WADS 2004 5 Problem \u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "A Focused Approach to Software Architectural Recovery\n", "abstract": " A Focused Approach to Software Architectural Recovery Page 1 A Focused Approach to Software Architectural Recovery http://sunset.usc.edu/~neno/Focus Nenad Medvidovic, Vladimir Jakobac Center for Software Engineering University of Southern California Los Angeles {neno,jakobac}@usc.edu Page 2 Why Recovery? \u220e Eroded architectures \u220e Architectural model out of sync with the current implementation \u220e Reducing maintenance costs \u220e Modifications should not cause other unforeseen problems \u220e System evolution \u220e Reuse Page 3 Focusing Architectural Recovery Propose idealized architectural model Map components onto architecture Identify key use cases Generate Refined Architecture Analyze component interactions Identify Components Logical Architecture Physical Architecture Identify Components Page 4 Component Recovery \u220e Four-step process \u220e Generate class diagram from implementation \u220e \u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Using Service Utilization Metrics to Assess and Improve Product Line Architectures\n", "abstract": " Metrics have long been used in software engineering to measure, evaluate, and improve software products and processes. Many metrics have been developed and their subsequent use in different settings has led to varying levels of success. Software architecture is a discipline in which few metrics have been applied, a surprising fact given the important role that software architecture plays in software development. Software product line architectures represent one area of software architecture in which metrics can be of especially great use. The critical importance of the structure defined by a product line architecture requires that its properties be meaningfully assessed and that informed architectural decisions be made to guide its evolution. In this paper, we present several novel metrics that we have designed to address this issue. These metrics are based on the concept of service utilization and are designed to take into account the context in which individual architectural elements are placed. We show the utility of the metrics by applying them in a case study involving a digital library product line architecture. In doing so, we demonstrate how the metrics illustrate deficiencies that, when addressed, improve the overall structural quality of the product line architecture.", "num_citations": "1\n", "authors": ["627"]}
{"title": "A Situated Approach to Scalable Control for Strongly Cooperative Robot Teams\n", "abstract": " This thesis examines the exploitation of the situated nature of multi-robot systems. We believe that such exploitation is the key to construction of robust, scalable systems with minimal requirements for sensing, computation, and communication.Traditional approaches to autonomous robotics view controllers as symbol processing systems, while situated approaches map perceptions to actions without symbolic deliberation. Situated approaches in the form of behavior-based or reactive control were the key to overcoming many of the problems of early autonomous robots, and have been so influential that almost all current robot control systems are described as at least partly reactive.\" The question of how much of the intelligent control spectrum can be covered by situated systems remains open, yet most researchers turn to hybrid systems Mat95a with both deliberative and reactive layers\" when attempting to scale behavior to higher levels of complexity. Many biologically-inspired systems take advantage of individual agents' situatedness to reduce or eliminate the need for centralized control or explicit global knowledge. This reduces the need for complexity of sensing, computation, and communication of individuals and leads to robust, scalable systems. Situatedness is not often associated with strongly cooperative parkertra98 robot team behavior that is, with performance of tasks that require distinct roles to be concurrently filled, and which cannot be be performed by a single robot. In natural insect systems, however, situated approaches have proven effective both for task performance HM00, DGF+91, TGGD91 and for task allocation Gor99, HW90\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Software Architecture-Based Development Support for Ubiquitous Systems\n", "abstract": " Over the past several decades software researchers and practitioners have proposed various approaches, techniques, and tools for developing large-scale software systems. A new set of challenges has arisen with the emergence of inexpensive, small, heterogeneous, resource-constrained, possibly embedded, highlydistributed, and highly-mobile computing platforms that are permeating virtually every facet of life (ie, ubiquitous systems). This paper presents an approach to software development for ubiquitous systems whose intent is to address these challenges. Our approach to Prism directly leverages the principles and solutions from the emerging body of work on software architectures. We refer to software development in this setting as programming in the small and many (Prism), in order to distinguish it from the commonly adopted software engineering paradigm of programming in the large (PitL). The centerpiece of our approach is a software architectural style and its middleware that support the key aspects of Prism applications: self-awareness, distribution, heterogeneity, dynamism, mobility, and graceful degradation. Our approach has been successfully applied on a number of ubiquitous applications. While several issues pertaining to Prism remain areas of future work, our experience to date has been very positive.", "num_citations": "1\n", "authors": ["627"]}
{"title": "Software Architectural Support for Distributed, Mobile, and Resource-Constrained Environments\n", "abstract": " Over the past several decades software researchers and practitioners have proposed various approaches, techniques, and tools for developing large-scale software systems. The results of these efforts have been characterized as programming-in-thelarge (PitL). A new set of challenges has arisen with the emergence of inexpensive, small, heterogeneous, resource-constrained, possibly embedded, highly-distributed, and highlymobile computing platforms. We refer to software development in this new setting as programming-in-the-small-and-many (Prism). This paper presents an approach intended to address the challenges of Prism. The centerpiece of our approach is a software architectural style with explicit support for the needs of Prism applications: self-awareness, distribution, heterogeneity, dynamism, mobility, and disconnected operation. The style is accompanied by a set of implementation, deployment, and\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}
{"title": "Runtime Support for Architecture-Level Configuration Management\n", "abstract": " Software architectures endow developers with abstractions, notations, and tools for providing high-level models of large, complex software systems. Configuration management (CM) is primarily concerned with capturing the evolution of a software system at the level of source code. Recently, an argument has been made for marrying CM with software architectures and using CM techniques to support the evolution of architectural models. In this paper, we extend this idea: the goal is to enable CM at the level of implementations of architectural models during runtime. We discuss the manner in which we have leveraged and extended an architecture implementation infrastructure to this end. Our initial results show that CM can play a pervasive role in supporting architectural evolution at specification-time(ie, architectural descriptions), implementation-time (ie, source code), and runtime (ie, deployed, executing\u00a0\u2026", "num_citations": "1\n", "authors": ["627"]}