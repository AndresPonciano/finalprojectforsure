{"title": "Sequent calculi for induction and infinite descent\n", "abstract": " This article formalizes and compares two different styles of reasoning with inductively defined predicates, each style being encapsulated by a corresponding sequent calculus proof system.The first system, LKID, supports traditional proof by induction, with induction rules formulated as rules for introducing inductively defined predicates on the left of sequents.We show LKID to be cut-free complete with respect to a natural class of Henkin models; the eliminability of cut follows as a corollary. The second system, LKID\u03c9, uses infinite (non-well-founded) proofs to represent arguments by infinite descent. In this system, the left-introduction rules for inductively defined predicates are simple case-split rules, and an infinitary, global condition on proof trees is required in order to ensure soundness.We show LKID\u03c9 to be cut-free complete with respect to standard models, and again infer the eliminability of cut. The infinitary\u00a0\u2026", "num_citations": "144\n", "authors": ["1777"]}
{"title": "Cyclic proofs for first-order logic with inductive definitions\n", "abstract": " We consider a cyclic approach to inductive reasoning in the setting of first-order logic with inductive definitions. We present a proof system for this language in which proofs are represented as finite, locally sound derivation trees with a \u201crepeat function\u201d identifying cyclic proof sections. Soundness is guaranteed by a well-foundedness condition formulated globally in terms of traces over the proof tree, following an idea due to Sprenger and Dam. However, in contrast to their work, our proof system does not require an extension of logical syntax by ordinal variables.               A fundamental question in our setting is the strength of the cyclic proof system compared to the more familiar use of a non-cyclic proof system using explicit induction rules. We show that the cyclic proof system subsumes the use of explicit induction rules. In addition, we provide machinery for manipulating and analysing the structure of cyclic\u00a0\u2026", "num_citations": "130\n", "authors": ["1777"]}
{"title": "A generic cyclic theorem prover\n", "abstract": " We describe the design and implementation of an automated theorem prover realising a fully general notion of cyclic proof. Our tool, called , is able to construct proofs obeying a very general cycle scheme in which leaves may be linked to any other matching node in the proof, and to verify the general, global infinitary condition on such proof objects ensuring their soundness.  is based on a new, generic theory of cyclic proofs that can be instantiated to a wide variety of logics. We have developed three such concrete instantiations, based on: (a) first-order logic with inductive definitions; (b) entailments of pure separation logic; and (c) Hoare-style termination proofs for pointer programs. Experiments run on these instantiations indicate that  offers significant potential as a future platform for inductive theorem proving.", "num_citations": "124\n", "authors": ["1777"]}
{"title": "Cyclic proofs of program termination in separation logic\n", "abstract": " We propose a novel approach to proving the termination of heap-manipulating programs, which combines separation logic with cyclic proof within a Hoare-style proof system.Judgements in this system express (guaranteed) termination of the program when started from a given line in the program and in a state satisfying a given precondition, which is expressed as a formula of separation logic. The proof rules of our system are of two types: logical rules that operate on preconditions; and symbolic execution rules that capture the effect of executing program commands. Our logical preconditions employ inductively defined predicates to describe heap properties, and proofs in our system are cyclic proofs: cyclic derivations in which some inductive predicate is unfolded infinitely often along every infinite path, thus allowing us to discard all infinite paths in the proof by an infinite descent argument. Moreover, the use of this\u00a0\u2026", "num_citations": "99\n", "authors": ["1777"]}
{"title": "A decision procedure for satisfiability in separation logic with inductive predicates\n", "abstract": " We show that the satisfiability problem for the\" symbolic heap\" fragment of separation logic with general inductively defined predicates---which includes most fragments employed in program verification---is decidable. Our decision procedure is based on the computation of a certain fixed point from the definition of an inductive predicate, called its\" base\", that exactly characterises its satisfiability.", "num_citations": "78\n", "authors": ["1777"]}
{"title": "Undecidability of propositional separation logic and its neighbours\n", "abstract": " Separation logic has proven an effective formalism for the analysis of memory-manipulating programs. We show that the purely propositional fragment of separation logic is undecidable. In fact, for any choice of concrete heap-like model of separation logic, validity in that model remains undecidable. Besides its intrinsic technical interest, this result also provides new insights into the nature of decidable fragments of separation logic. In addition, we show that a number of propositional systems which approximate separation logic are undecidable as well. In particular, these include both Boolean BI and Classical BI. All of our undecidability results are obtained by means of a single direct encoding of Minsky machines.", "num_citations": "74\n", "authors": ["1777"]}
{"title": "Sequent calculus proof systems for inductive definitions\n", "abstract": " Inductive definitions are the most natural means by which to represent many families of structures occurring in mathematics and computer science, and their corresponding induction / recursion principles provide the fundamental proof techniques by which to reason about such families. This thesis studies formal proof systems for inductive definitions, as needed, e.g., for inductive proof support in automated theorem proving tools. The systems are formulated as sequent calculi for classical first-order logic extended with a framework for (mutual) inductive definitions. The default approach to reasoning with inductive definitions is to formulate the induction principles of the inductively defined relations as suitable inference rules or axioms, which are incorporated into the reasoning framework of choice. Our first system LKID adopts this direct approach to inductive proof, with the induction rules formulated as rules for introducing atomic formulas involving inductively defined predicates on the left of sequents. We show this system to be sound and cut-free complete with respect to a natural class of Henkin models. As a corollary, we obtain cut-admissibility for LKID. The well-known method of infinite descent `a la Fermat, which exploits the fact that there are no infinite descending chains of elements of well-ordered sets, provides an alternative approach to reasoning with inductively defined relations. Our second proof system LKIDw formalises this approach. In this system, the left-introduction rules for formulas involving inductively defined predicates are not induction rules but simple case distinction rules, and an infinitary, global soundness condition on proof\u00a0\u2026", "num_citations": "65\n", "authors": ["1777"]}
{"title": "Complete sequent calculi for induction and infinite descent\n", "abstract": " This paper compares two different styles of reasoning with inductively defined predicates, each style being encapsulated by a corresponding sequent calculus proof system. The first system supports traditional proof by induction, with induction rules formulated as sequent rules for introducing inductively defined predicates on the left of sequents. We show this system to be cut-free complete with respect to a natural class of Henkin models; the eliminability of cut follows as a corollary. The second system uses infinite (non-well-founded) proofs to represent arguments by infinite descent. In this system, the left rules for inductively defined predicates are simple case-split rules, and an infinitary, global condition on proof trees is required to ensure soundness. We show this system to be cut-free complete with respect to standard models, and again infer the eliminability of cut. The second infinitary system is unsuitable for\u00a0\u2026", "num_citations": "57\n", "authors": ["1777"]}
{"title": "Parametric completeness for separation theories\n", "abstract": " In this paper, we close the logical gap between provability in the logic BBI, which is the propositional basis for separation logic, and validity in an intended class of separation models, as employed in applications of separation logic such as program verification. An intended class of separation models is usually specified by a collection of axioms describing the specific model properties that are expected to hold, which we call a separation theory. Our main contributions are as follows. First, we show that several typical properties of separation theories are not definable in BBI. Second, we show that these properties become definable in a suitable hybrid extension of BBI, obtained by adding a theory of naming to BBI in the same way that hybrid logic extends normal modal logic. The binder-free extension captures most of the properties we consider, and the full extension HyBBI(\u2193) with the usual \u2193 binder of hybrid logic\u00a0\u2026", "num_citations": "55\n", "authors": ["1777"]}
{"title": "Formalised inductive reasoning in the logic of bunched implications\n", "abstract": " We present a framework for inductive definitions in the logic of bunched implications, BI, and formulate two sequent calculus proof systems for inductive reasoning in this framework. The first proof system adopts a traditional approach to inductive proof, extending the usual sequent calculus for predicate BI with explicit induction rules for the inductively defined predicates. The second system allows an alternative mode of reasoning with inductive definitions by cyclic proof. In this system, the induction rules are replaced by simple case-split rules, and the proof structures are cyclic graphs formed by identifying some sequent occurrences in a derivation tree. Because such proof structures are not sound in general, we demand that cyclic proofs must additionally satisfy a global trace condition that ensures soundness. We illustrate our inductive definition framework and proof systems with simple examples which\u00a0\u2026", "num_citations": "48\n", "authors": ["1777"]}
{"title": "Bunched logics displayed\n", "abstract": " We formulate a unified display calculus proof theory for the four principal varieties of bunched logic by combining display calculi for their component logics. Our calculi satisfy cut-elimination, and are sound and complete with respect to their standard presentations. We show how to constrain applications of display-equivalence in our calculi in such a way that an exhaustive proof search need be only finitely branching, and establish a full deduction theorem for the bunched logics with classical additives, BBI and CBI. We also show that the standard sequent calculus for BI can be seen as a reformulation of its display calculus, and argue that analogous sequent calculi for the other varieties of bunched logic are very unlikely to exist.", "num_citations": "46\n", "authors": ["1777"]}
{"title": "Cyclic abduction of inductively defined safety and termination preconditions\n", "abstract": " We introduce cyclic abduction: a new method for automatically inferring safety and termination preconditions of heap-manipulating while programs, expressed as inductive definitions in separation logic. Cyclic abduction essentially works by searching for a cyclic proof of the desired property, abducing definitional clauses of the precondition as necessary in order to advance the proof search process.             We provide an implementation, , of our cyclic abduction method, based on a suite of heuristically guided tactics. It is often able to automatically infer preconditions describing lists, trees, cyclic and composite structures which, in other tools, previously had to be supplied by hand.", "num_citations": "37\n", "authors": ["1777"]}
{"title": "Classical BI: Its semantics and proof theory\n", "abstract": " We present Classical BI (CBI), a new addition to the family of bunched logics which originates in O'Hearn and Pym's logic of bunched implications BI. CBI differs from existing bunched logics in that its multiplicative connectives behave classically rather than intuitionistically (including in particular a multiplicative version of classical negation). At the semantic level, CBI-formulas have the normal bunched logic reading as declarative statements about resources, but its resource models necessarily feature more structure than those for other bunched logics; principally, they satisfy the requirement that every resource has a unique dual. At the proof-theoretic level, a very natural formalism for CBI is provided by a display calculus \\`a la Belnap, which can be seen as a generalisation of the bunched sequent calculus for BI. In this paper we formulate the aforementioned model theory and proof theory for CBI, and prove some fundamental results about the logic, most notably completeness of the proof theory with respect to the semantics.", "num_citations": "33\n", "authors": ["1777"]}
{"title": "Automatic cyclic termination proofs for recursive procedures in separation logic\n", "abstract": " We describe a formal verification framework and tool implementation, based upon cyclic proofs, for certifying the safe termination of imperative pointer programs with recursive procedures. Our assertions are symbolic heaps in separation logic with user defined inductive predicates; we employ explicit approximations of these predicates as our termination measures. This enables us to extend cyclic proof to programs with procedures by relating these measures across the pre-and postconditions of procedure calls.", "num_citations": "32\n", "authors": ["1777"]}
{"title": "Model checking for symbolic-heap separation logic with inductive predicates\n", "abstract": " We investigate the *model checking* problem for symbolic-heap separation logic with user-defined inductive predicates, i.e., the problem of checking that a given stack-heap memory state satisfies a given formula in this language, as arises e.g. in software testing or runtime verification. First, we show that the problem is *decidable*; specifically, we present a bottom-up fixed point algorithm that decides the problem and runs in exponential time in the size of the problem instance. Second, we show that, while model checking for the full language is EXPTIME-complete, the problem becomes NP-complete or PTIME-solvable when we impose natural syntactic restrictions on the schemata defining the inductive predicates. We additionally present NP and PTIME algorithms for these restricted fragments. Finally, we report on the experimental performance of our procedures on a variety of specifications extracted from\u00a0\u2026", "num_citations": "30\n", "authors": ["1777"]}
{"title": "Undecidability of propositional separation logic and its neighbours\n", "abstract": " In this article, we investigate the logical structure of memory models of theoretical and practical interest. Our main interest is in \u201cthe logic behind a fixed memory model\u201d, rather than in \u201ca model of any kind behind a given logical system\u201d. As an effective language for reasoning about such memory models, we use the formalism of separation logic. Our main result is that for any concrete choice of heap-like memory model, validity in that model is undecidable even for purely propositional formulas in this language. The main novelty of our approach to the problem is that we focus on validity in specific, concrete memory models, as opposed to validity in general classes of models. Besides its intrinsic technical interest, this result also provides new insights into the nature of their decidable fragments. In particular, we show that, in order to obtain such decidable fragments, either the formula language must be severely restricted\u00a0\u2026", "num_citations": "30\n", "authors": ["1777"]}
{"title": "Classical BI: a logic for reasoning about dualising resources\n", "abstract": " We show how to extend O'Hearn and Pym's logic of bunched implications, BI, to classical BI (CBI), in which both the additive and the multiplicative connectives behave classically. Specifically, CBI is a non-conservative extension of (propositional) Boolean BI that includes multiplicative versions of falsity, negation and disjunction. We give an algebraic semantics for CBI that leads us naturally to consider resource models of CBI in which every resource has a unique dual. We then give a cut-eliminating proof system for CBI, based on Belnap's display logic, and demonstrate soundness and completeness of this proof system with respect to our semantics.", "num_citations": "24\n", "authors": ["1777"]}
{"title": "A formalised first-order confluence proof for the \u03bb-calculus using one-sorted variable names\n", "abstract": " We present the titular proof development that has been verified in Isabelle/HOL. As a first, the proof is conducted exclusively by the primitive proof principles of the standard syntax and of the considered reduction relations: the naive way, so to speak. Curiously, the Barendregt Variable Convention takes on a central technical role in the proof. We also show: (i) that our presentation of the \u03bb-calculus coincides with Curry\u2019s and Hindley\u2019s when terms are considered equal up to \u03b1-equivalence and (ii) that the confluence properties of all considered systems are equivalent.", "num_citations": "23\n", "authors": ["1777"]}
{"title": "A Formalised First-Order Confluence Proof for the \u03bb-Calculus Using One-Sorted Variable Names (Barendregt Was Right after all... almost)\n", "abstract": " We present the titular proof development which has been implemented in Isabelle/HOL. As a first, the proof is conducted exclusively by the primitive induction principles of the standard syntax and the considered reduction relations: the naive way, so to speak. Curiously, the Barendregt Variable Convention takes on a central technical role in the proof. We also show (i) that our presentation coincides with Curry\u2019s and Hindley\u2019s when terms are considered equal up-to \u03b1 and (ii) that the con uence properties of all considered calculi are equivalent.", "num_citations": "23\n", "authors": ["1777"]}
{"title": "A unified display proof theory for bunched logic\n", "abstract": " We formulate a unified display calculus proof theory for the four principal varieties of bunched logic by combining display calculi for their component logics. Our calculi satisfy cut-elimination, and are sound and complete with respect to their standard presentations. We show that the standard sequent calculus for BI can be seen as a reformulation of its display calculus, and argue that analogous sequent calculi for the other varieties of bunched logic seem very unlikely to exist.", "num_citations": "21\n", "authors": ["1777"]}
{"title": "Automatically verifying temporal properties of pointer programs with cyclic proof\n", "abstract": " We propose a deductive reasoning approach to the automatic verification of temporal properties of pointer programs, based on cyclic proof. We present a proof system whose judgements express that a program has a certain temporal property over memory state assertions in separation logic, and whose rules operate directly on the temporal modalities as well as symbolically executing programs. Cyclic proofs in our system are, as usual, finite proof graphs subject to a natural, decidable soundness condition, encoding a form of proof by infinite descent.               We present a proof system tailored to proving CTL properties of nondeterministic pointer programs, and then adapt this system to handle fair execution conditions. We show both systems to be sound, and provide an implementation of each in the Cyclist  theorem prover, yielding an automated tool that is capable of automatically discovering proofs of\u00a0\u2026", "num_citations": "19\n", "authors": ["1777"]}
{"title": "Biabduction (and related problems) in array separation logic\n", "abstract": " We investigate array separation logic (), a variant of symbolic-heap separation logic in which the data structures are either pointers or arrays, i.e., contiguous blocks of memory. This logic provides a language for compositional memory safety proofs of array programs. We focus on the biabduction problem for this logic, which has been established as the key to automatic specification inference at the industrial scale. We present an  decision procedure for biabduction in , and we also show that the problem of finding a consistent solution is -hard. Along the way, we study satisfiability and entailment in , giving decision procedures and complexity bounds for both problems. We show satisfiability to be -complete, and entailment to be decidable with high complexity. The surprising fact that biabduction is simpler than entailment is due to the fact that, as we show, the element of choice over\u00a0\u2026", "num_citations": "18\n", "authors": ["1777"]}
{"title": "Sub-classical Boolean bunched logics and the meaning of par\n", "abstract": " We investigate intermediate logics between the bunched logics Boolean BI and Classical BI, obtained by combining classical propositional logic with various flavours of Hyland and De Paiva's full intuitionistic linear logic. Thus, in addition to the usual multiplicative conjunction (with its adjoint implication and unit), our logics also feature a multiplicative disjunction (with its adjoint co-implication and unit). The multiplicatives behave\" sub-classically\", in that disjunction and conjunction are related by a weak distribution principle, rather than by De Morgan equivalence. We formulate a Kripke semantics, covering all our sub-classical bunched logics, in which the multiplicatives are naturally read in terms of resource operations. Our main theoretical result is that validity according to this semantics coincides with provability in a corresponding Hilbert-style proof system. Our logical investigation sheds considerable new light on how one can understand the multiplicative disjunction, better known as linear logic's\" par\", in terms of resource operations. In particular, and in contrast to the earlier Classical BI, the models of our logics include the heap-like memory models of separation logic, in which disjunction can be interpreted as a property of intersection operations over heaps.", "num_citations": "18\n", "authors": ["1777"]}
{"title": "Craig interpolation in displayable logics\n", "abstract": " We give a general proof-theoretic method for proving Craig interpolation for displayable logics, based on an analysis of the individual proof rules of their display calculi. Using this uniform method, we prove interpolation for a spectrum of display calculi differing in their structural rules, including those for multiplicative linear logic, multiplicative additive linear logic and ordinary classical logic. Our analysis of proof rules also provides new insights into why interpolation fails, or seems likely to fail, in many substructural logics. Specifically, contraction appears particularly problematic for interpolation except in special circumstances.", "num_citations": "10\n", "authors": ["1777"]}
{"title": "The mechanisation of Barendregt-style equational proofs (the residual perspective)\n", "abstract": " We show how to mechanise equational proofs about higher-order languages by using the primitive proof principles of first-order abstract syntax over one-sorted variable names. We illustrate the method here by proving (in Isabelle/HOL) a technical property which makes the method widely applicable for the \u03bb-calculus: the residual theory of \u03b2 is renaming-free up-to an initiality condition akin to the so-called Barendregt Variable Convention. We use our results to give a new diagram-based proof of the development part of the strong finite development property for the \u03bb-calculus. The proof has the same equational implications (e.g., confluence) as the proof of the full property but without the need to prove SN. We account for two other uses of the proof method, as presented elsewhere. One has been mechanised in full in Isabelle/HOL.", "num_citations": "10\n", "authors": ["1777"]}
{"title": "On the complexity of pointer arithmetic in separation logic\n", "abstract": " We investigate the complexity consequences of adding pointer arithmetic to separation logic. Specifically, we study an extension of the points-to fragment of symbolic-heap separation logic with sets of simple \u201cdifference constraints\u201d of the form , where x and y are pointer variables and k is an integer offset. This extension can be considered a practically minimal language for separation logic with pointer arithmetic.                 Most significantly, we find that, even for this minimal language, polynomial-time decidability is already impossible: satisfiability becomes -complete, while quantifier-free entailment becomes -complete and quantified entailment becomes -complete (where  is the second class in the polynomial-time hierarchy).                 However, the language does satisfy the small model property, meaning that any satisfiable formula has a model, and any invalid entailment has a\u00a0\u2026", "num_citations": "8\n", "authors": ["1777"]}
{"title": "Realizability in cyclic proof: Extracting ordering information for infinite descent\n", "abstract": " In program verification, measures for proving the termination of programs are typically constructed using (notions of size for) the data manipulated by the program. Such data are often described by means of logical formulas. For example, the cyclic proof technique makes use of semantic approximations of inductively defined predicates to construct Fermat-style infinite descent arguments. However, logical formulas must often incorporate explicit size information (e.g.\u00a0a list length parameter) in order to support inter-procedural analysis.                 In this paper, we show that information relating the sizes of inductively defined data can be automatically extracted from cyclic proofs of logical entailments. We characterise this information in terms of a graph-theoretic condition on proofs, and show that this condition can be encoded as a containment between weighted automata. We also show that under certain\u00a0\u2026", "num_citations": "4\n", "authors": ["1777"]}
{"title": "Formalizing proofs in Isabelle/HOL of equational properties for the lambda-calculus using one-sorted variable names\n", "abstract": " We present the Isabelle/HOL formalisation of some key equational properties of the untyped \u03bb-calculus with one-sorted variable names. Existing machine formalisations of \u03bb-calculus proofs typically rely on alternative representations and/or proof principles to facilitate mechanization and we briefly account for these works. Our own development remains faithful to the standard textbook presentation and the usual pen-and-paper proof practices; we reason purely inductively over the standard first-order syntax of the calculus, using only primitive proof principles of the syntax and the reduction relations under consideration. We prove the confluence property of the \u03bb-calculus at the raw syntactic level and derive confluence of the real \u03bb-calculus (the structural collapse onto equivalence classes of the raw calculus) via a general result about abstract rewrite systems which we also formalise. We then show a technical property of the residual theory of the calculus which suggests the general applicability of the method to other equational properties of the calculus. Finally, we make some proof-technical observations pertaining to the extent to which our Isabelle proofs may be automated.", "num_citations": "3\n", "authors": ["1777"]}
{"title": "A Compositional Deadlock Detector for Android Java\n", "abstract": " We develop a static deadlock analysis for commercial Android Java applications, of sizes in the tens of millions of LoC, under active development at Facebook. The analysis runs primarily at code-review time, on only the modified code and its dependents; we aim at reporting to developers in under 15 minutes. To detect deadlocks in this setting, we first model the real language as an abstract language with balanced re-entrant locks, nondeterministic iteration and branching, and non-recursive procedure calls. We show that the existence of a deadlock in this abstract language is equivalent to a certain condition over the sets of critical pairs of each program thread; these record, for all possible executions of the thread, which locks are currently held at the point when a fresh lock is acquired. Since the critical pairs of any program thread is finite and computable, the deadlock detection problem for our language is decidable, and in NP. We then leverage these results to develop an open-source implementation of our analysis adapted to deal with real Java code. The core of the implementation is an algorithm which computes critical pairs in a compositional, abstract interpretation style, running in quasi-exponential time. Our analyser is built in the INFER verification framework and has been in industrial deployment for over two years; it has seen over two hundred fixed deadlock reports with a report fix rate of \u223c54%.", "num_citations": "2\n", "authors": ["1777"]}
{"title": "Disproving inductive entailments in separation logic via base pair approximation\n", "abstract": " We give a procedure for establishing the invalidity of logical entailments in the symbolic heap fragment of separation logic with user-defined inductive predicates, as used in program verification. This disproof procedure attempts to infer the existence of a countermodel to an entailment by comparing computable model summaries, a.k.a. bases (modified from earlier work), of its antecedent and consequent. Our method is sound and terminating, but necessarily incomplete.                 Experiments with the implementation of our disproof procedure indicate that it can correctly identify a substantial proportion of the invalid entailments that arise in practice, at reasonably low time cost. Accordingly, it can be used, e.g., to improve the output of theorem provers by returning \u201cno\u201d answers in addition to \u201cyes\u201d and \u201cunknown\u201d answers to entailment questions, and to speed up proof search or automated theory exploration by\u00a0\u2026", "num_citations": "2\n", "authors": ["1777"]}
{"title": "Reasoning over Permissions Regions in Concurrent Separation Logic\n", "abstract": " We propose an extension of separation logic with fractional permissions, aimed at reasoning about concurrent programs that share arbitrary regions or data structures in memory. In existing formalisms, such reasoning typically either fails or is subject to stringent side conditions on formulas (notably precision) that significantly impair automation. We suggest two formal syntactic additions that collectively remove the need for such side conditions: first, the use of both \u201cweak\u201d and \u201cstrong\u201d forms of separating conjunction, and second, the use of nominal labels from hybrid logic. We contend that our suggested alterations bring formal reasoning with fractional permissions in separation logic considerably closer to common pen-and-paper intuition, while imposing only a modest bureaucratic overhead.", "num_citations": "1\n", "authors": ["1777"]}
{"title": "Size relationships in abstract cyclic entailment systems\n", "abstract": " A cyclic proof system generalises the standard notion of a proof as a finite tree of locally sound inferences by allowing proof objects to be potentially infinite. Regular infinite proofs can be finitely represented as graphs. To preclude spurious cyclic reasoning, cyclic proof systems come equipped with a well-founded notion of 'size' for the models that interpret their logical statements. A global soundness condition on proof objects, stated in terms of this notion of size, ensures that any non-well-founded paths in the proof object can be disregarded. We give an abstract definition of a subclass of such cyclic proof systems: cyclic entailment systems. In this setting, we consider the problem of comparing the size of a model when interpreted in relation to the antecedent of an entailment, with that when interpreted in relation to the consequent. Specifically, we give a further condition on proof objects which ensures that models of a given entailment are always 'smaller' when interpreted with respect to the consequent than when interpreted with respect to the antecedent. Knowledge of such relationships is useful in a program verification setting.", "num_citations": "1\n", "authors": ["1777"]}
{"title": "Machine-Checked Interpolation Theorems for Substructural Logics Using Display Calculi\n", "abstract": " We present a mechanised formalisation, in Isabelle/HOL, of Brotherston and Gor\u00e9\u2019s proof of Craig interpolation for a large of class display calculi for various propositional substructural logics. Along the way, we discuss the particular difficulties associated with the local interpolation property for various rules, and some important differences between our proofs and those of Brotherston and Gor\u00e9, which are motivated by the ease of mechanising the development. Finally, we discuss the value for this work of using a prover with a programmable user interface (here, Isabelle with its Standard ML interface).", "num_citations": "1\n", "authors": ["1777"]}
{"title": "Hennessy-Milner completeness in transition systems with synchronous concurrent composition\n", "abstract": " We consider the problem of obtaining Hennessy-Milner soundness and completeness---the coincidence of logical equivalence and bisimilarity---in the setting of transition systems with synchronous concurrent composition. Starting from a richly expressive modal logic, motivated by resource semantics and distributed systems modelling, including both additive and multiplicative propositional connectives and also additive and multiplicative action modalities, as well as certain first-order quantifiers, we establish sufficient conditions for Hennessy--Milner soundness and completeness to hold. We develop two examples in detail. First, using the propositional part of the logic, we consider a calculus of resources and processes, explaining how the semantics may be refined to give a familiar equational theory. Second, employing a first-order, arithmetic theory, we consider a calculus with utilities that is able to express optimality and equilibria in resource allocation.", "num_citations": "1\n", "authors": ["1777"]}
{"title": "Complete Sequent Calculi for Induction and Infinite Descent\n", "abstract": " This paper compares two different styles of reasoning with inductively defined predicates, each style being encapsulated by a corresponding sequent calculus proof system. The first system supports traditional proof by induction, with induction rules formulated as sequent rules for introducing inductively defined predicates on the left of sequents. We show this system to be cut-free complete with respect to a natural class of Henkin models; the eliminability of cut follows as a corollary. The second system uses infinite (non-well-founded) proofs to represent arguments by infinite descent. In this system, the left rules for inductively defined predicates are simple case-split rules, and an infinitary, global condition on proof trees is required to ensure soundness. We show this system to be cut-free complete with respect to standard models, and again infer the eliminability of cut. The second infinitary system is unsuitable for formal reasoning. However, it has a natural restriction to proofs given by regular trees, ie to those proofs representable by finite graphs. This restricted\" cyclic\" system subsumes the first system for proof by induction. We conjecture that the two systems are in fact equivalent, ie, that proof by induction is equivalent to regular proof by infinite descent.", "num_citations": "1\n", "authors": ["1777"]}