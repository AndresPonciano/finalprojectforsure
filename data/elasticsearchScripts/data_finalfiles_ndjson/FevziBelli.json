{"title": "Finite state testing and analysis of graphical user interfaces\n", "abstract": " Based on finite-state automata (FSA) and equivalent regular expressions, the paper introduces a holistic view of fault modeling that can be carried out as a complementary step to system modeling, revealing much rationalization potential. Appropriate formal notions will be used to introduce efficient algorithms to systematically generate and select test cases. The completeness of the test can be determined exploiting the link coverage of the state transition diagram of the FSA that models both the desired and undesired behavior of the system under test; this enables a precise scalability of the test and analysis process, leading to a better cost-effectiveness The elements of the approach will be narrated by realistic examples which will be used also to validate the approach.", "num_citations": "261\n", "authors": ["476"]}
{"title": "Fault-tolerant programs and their reliability\n", "abstract": " The authors review and extend available techniques for achieving fault-tolerant programs. The representation of the techniques is uniform and is illustrated by simple examples. For each technique a fault tree has been developed to derive failure probability from the probabilities of the basic fault events. This allows the subsequent analysis of program-failure causes and the reliability modeling of computer programs. Numerical examples are given to support the comparison of the reviewed techniques. The models can be used to evaluate numerical values of program reliability in a relatively simple way. The models deal with program reliability for a single run, which seems more practical and straightforward than dealing with distributions as for hardware systems. Evaluations obtained by using models correspond to those used in the literature; however, the authors' procedures are computationally simpler.< >", "num_citations": "72\n", "authors": ["476"]}
{"title": "An approach to the reliability optimization of software with redundancy\n", "abstract": " An approach to the optimization of software reliability is proposed. The emphasis is put on the software redundancy to achieve fault tolerance, ie, the results of the optimization process are applied to determine the optimal structure of software to be developed. Two optimization models are formulated covering, respectively, modified recovery block scheme and multiversion programming approaches. Both cases are illustrated by simple examples.", "num_citations": "70\n", "authors": ["476"]}
{"title": "Specification of fault-tolerant system issues by predicate/transition nets and regular expressions-approach and case study\n", "abstract": " In this paper a method is presented to systematically integrate fault tolerance properties into the design of complex software systems. This is achieved by exploiting a formal specification of the system where the amount of necessary redundancy can be determined. The system description is based thereby on a combination of a predicate/transition net with regular expressions. The net model provides a formal-but nevertheless lucid-overview of the system behavior in general, supporting the correct understanding of potential concurrency in the system processes. Regular expressions are used to model the sequential behavior of single-system components in detail. Both model layers provide well-defined levels of error detection; the regular expressions enable the system designer to also determine and introduce redundancy to achieve error correction. The paper briefly outlines the methods we use to describe and\u00a0\u2026", "num_citations": "55\n", "authors": ["476"]}
{"title": "A holistic approach to model\u2010based testing of Web service compositions\n", "abstract": " The behavior of composed Web services depends on the results of the invoked services; unexpected behavior of one of the invoked services can threat the correct execution of an entire composition. This paper proposes an event\u2010based approach to black\u2010box testing of Web service compositions based on event sequence graphs, which are extended by facilities to deal not only with service behavior under regular circumstances (i.e.,\u2009where cooperating services are working as expected) but also with their behavior in undesirable situations (i.e., where cooperating services are not working as expected). Furthermore, the approach can be used independently of artifacts (e.g., Business Process Execution Language) or type of composition (orchestration/choreography). A large case study, based on a commercial Web application, demonstrates the feasibility of the approach and analyzes its characteristics. Test\u00a0\u2026", "num_citations": "42\n", "authors": ["476"]}
{"title": "Towards automation of checklist-based code-reviews\n", "abstract": " Different types of code-reviews (Fagan-style code-inspections, Parnas-like active design reviews and walkthroughs) have been found to be very useful in improving the quality of software. In many cases reviewers use checklists to guide their analysis during review sessions. However, valuable, checklist-based code-reviews have the principal shortcoming of their high costs due to lack of supporting tools enabling at least partial automation of typical multiple appearing rules. This paper describes an approach towards semi-automation of some steps of individual review processes based on checklists. The method proposed is interactive, i.e. reviewers will be enabled to actualize, extend, and check the consistency and redundancy of their checklists. The basic idea underlying the approach is the usage of a rule-based system, adapting concepts of the compiler theory and knowledge engineering, for acquisition and\u00a0\u2026", "num_citations": "37\n", "authors": ["476"]}
{"title": "Event-driven modeling and testing of web services\n", "abstract": " A service-oriented architecture (SOA) for Web applications is often implemented using Web service (WS) standards and consists of different functions the executions of which are perceived as events. The order and time-appropriateness of occurrences of these events play a vital role for the proper working of a real-time SOA. This paper presents an event-based approach for modeling and testing of functional behavior of WS in SOA by event sequence graphs (ESG). Nodes of ESG represent events, e.g., \"request\" or \"response\", and arcs give the sequence of these events. For representing parameter values, e.g., for time-out of function calls, ESG are augmented by decision tables (DT). A case study carried out on a commercial Web system with SOA validates the approach and analyzes its characteristic issues. The novelty of the approach stems from (i) its simplicity and lucidity in representing complex real-time Web\u00a0\u2026", "num_citations": "33\n", "authors": ["476"]}
{"title": "Test generation and minimization with\" Basic\" statecharts\n", "abstract": " Model-based testing as a black-box testing technique has grown in importance. The models used represent the relevant features of the system under consideration (SUC), and can also be used as a basis for generating test case sets. In this work we introduce a novel representation of state-charts which subsumes common features of different state-chart variants. Based on this model and well-defined test criteria, efficient algorithms are introduced for generating test case sets. Those test case sets are minimized to cover both the model of SUC and its inversion, ie, the complementary model.", "num_citations": "32\n", "authors": ["476"]}
{"title": "On negative tests of web applications\n", "abstract": " Web applications are of decisive importance in e-commerce. Due to the heterogeneous nature and different quality criteria of system environment, its components and user expectations, new demands emerge for testing of those systems to ensure a high reliability level. This paper introduces a novel approach to testing the functionality of web applications. For this purpose the system under test (SUT) is modeled by structured event sequence graphs (sESG) combined with decision tables. Walks through the ESG form\u201d complete\u201d event sequences and thus define tests. The test process is completed by augmenting the model (s) given for testing the SUT behavior in unexpected, undesirable situations; this will be called\u201d negative testing\u201d. Accordingly,\u201d positive tests\u201d check the conformity of SUT behavior with the expected one under regular circumstances. A test algorithm is presented for minimizing the test effort in execution of both positive and negative tests. Commercially available test tools help with reducing the manual work and costs.", "num_citations": "29\n", "authors": ["476"]}
{"title": "Event-driven modeling and testing of real-time web services\n", "abstract": " A service-oriented architecture (SOA) for web applications is often implemented using web services (WSs) and consists of different operations the executions of which are perceived as events. The order and time-appropriateness of occurrences of these events play a vital role for the proper functioning of a real-time SOA. This paper presents an event-based approach to modeling and testing of functional behavior of WSs by event sequence graphs (ESG). Nodes of an ESG represent events, e.g., \u201crequest\u201d or \u201cresponse\u201d, and arcs give the sequence of these events. For representing parameter values, e.g., for time-out of operation calls, ESG are augmented by decision tables. A case study carried out on a commercial web system with SOA validates the approach and analyzes its characteristic issues. The novelty of the approach stems from (i) its simplicity and lucidity in representing complex real-time web\u00a0\u2026", "num_citations": "28\n", "authors": ["476"]}
{"title": "Methoden und Modelle der Fehlertoleranz\n", "abstract": " Methoden und Modelle der Fehlertoleranz - Digitale Bibliothek - Gesellschaft f\u00fcr Informatik eV GI Logo GI Logo Login Digital Library All of DSpace Communities & Collections Titles Authors By Issue Date Subjects This Collection Titles Authors By Issue Date Subjects Toggle navigation Digital Library Gesellschaft f\u00fcr Informatik eV GI-DL English Deutsch English English Deutsch View Item DSpace Home Informatik Spektrum Band 09 (1986) Band 09 - Heft 2 (April 1986) View Item DSpace Home Informatik Spektrum Band 09 (1986) Band 09 - Heft 2 (April 1986) View Item Methoden und Modelle der Fehlertoleranz Author: Belli, Fevzi [DBLP] ; Echtle, Klaus [DBLP] ; G\u00f6rke, Winfried [DBLP] Citation BibTeX Belli, F., Echtle, K. & G\u00f6rke, W., (1986). Methoden und Modelle der Fehlertoleranz. Informatik Spektrum: Vol. 9, No. 2. Berlin Heidelberg: Springer-Verlag. (S. 68-81). Haben Sie fehlerhafte Angaben entdeckt? Sagen Sie : ..\u2026", "num_citations": "24\n", "authors": ["476"]}
{"title": "A formal framework for mutation testing\n", "abstract": " Model-based approaches, especially based on directed graphs (DG), are becoming popular for mutation testing as they enable definition of simple, nevertheless powerful, mutation operators and effective coverage criteria. However, these models easily become intractable if the system under consideration is too complex or large. Moreover, existing DG-based algorithms for test generation and optimization are rare and rather in an initial stage. Finally, DG models fail to represent languages beyond type-3 (regular). This paper proposes a grammar-based mutation testing framework, together with effective mutation operators, coverage concepts and algorithms for test sequence generation. The objective is to establish a formal framework for model-based mutation testing which enables complementary or alternative use of regular grammars, depending on the preferences of the test engineer. A case study validates the\u00a0\u2026", "num_citations": "21\n", "authors": ["476"]}
{"title": "A test coverage notion for logic programming\n", "abstract": " Reliability determination for software is closely related to software testing. Testing delivers important data for software reliability models. Two important tasks of software testing are test case generation and determination of test coverage. Because of its declarative paradigm, all the well-known approaches to the above mentioned tasks are not applicable to logic programming. Implementation based testing is an approach to tackle the test problem for logic programming. We focus on test coverage aspects for logic programming. Analog to the coverage notion for conventional programming, e.g., path coverage on the control flow graph, we define a coverage measure on an abstract model of the logic program to be tested. Our abstract model is the set of goal-induced instances of program clauses. This is motivated by the computational model of resolution calculus for first-order predicate logic. Anti-unification is utilized to\u00a0\u2026", "num_citations": "21\n", "authors": ["476"]}
{"title": "Event-oriented, model-based GUI testing and reliability assessment\u2014approach and case study\n", "abstract": " It is widely accepted that graphical user interfaces (GUIs) highly affect\u2014positive or negative\u2014the quality and reliability of human-machine systems. However, quantitative assessment of the reliability of GUIs is a relatively young research field. Based on probability theory and statistics, the existing software reliability models describe the behavior of software failures and attempt to predict the reliability of the system under consideration (SUC). They operate on particular assumptions about the probability distribution of the cumulative number of failures, the observed failure data, and the form of the failure intensity function, etc. Bad news is that there is no single, universal model that can be used in all cases. To select an appropriate model, or a set of models, the failure data should be considered and analyzed carefully. We expect that the methods used for modeling and testing a GUI also affect its reliability\u00a0\u2026", "num_citations": "19\n", "authors": ["476"]}
{"title": "Event-based GUI testing and reliability assessment techniques--An experimental insight and preliminary results\n", "abstract": " It is widely accepted that graphical user interfaces (GUIs) highly affect - positive or negative - the quality and reliability of human-machine systems. In spite of this fact, quantitative assessment of the reliability of GUIs is a relatively young research field. Existing software reliability assessment techniques attempt to statistically describe the software testing process and to determine and thus predict the reliability of the system under consideration (SUC). These techniques model the reliability of the SUC based on particular assumptions and preconditions on probability distribution of cumulative number of failures, failure data observed, and form of the failure intensity function, etc. We expect that the methods used for modeling a GUI and related frameworks used for testing it also affect the factors mentioned above, especially failure data to be observed and prerequisites to be met. Thus, the quality of the reliability\u00a0\u2026", "num_citations": "19\n", "authors": ["476"]}
{"title": "Einf\u00fchrung in die logische Programmierung mit PROLOG\n", "abstract": " mit PROLOG Page 1 Einf\u00fchrung in die logische Programmierung mit PROLOG VO\ufb02 Prof. Dr. Fevzi Belli Hochschule Bremerhaven _ 2., \u00fcberarbeitete und erweiterte Auflage Wissenschaftsverlag Mannheim/Wien/ Z\u00fcrich Page 2 Inhaltsverzeichnis Vorwort Verwendete Notation und Konventionen . . . . . . l\u2018\u2014'l\u2014'l\u2014' 0 HP-\u2018H l NNMNN ul\u00e4nlbnbubnl\u00e4bnbnl\u00e4hnbn\u00dfulb UJUJUJMLAWUJW I. NNNMNNNNNNN l \u00dc I u MMMH IO G I uooocnoo-\u201aJoxmawww I l 0 I t I l \"-.IG\"|U\"I|l-\"-rUJNl\"\u201c' I0 NMNI-\u2018r-\u2018r-dl-It-Iv-\u2018rI I Lnbw MH l 0 NP\u2014' l I NIP\u2018 ou in I\u00dfU-\u201aNl-\u2018l-\u2018lJ Nl\u2014' MP4 un M?\u201c OO 0 O llu I l II l 0 l 0 l I 0 l C Einleitung . . . . . . . . . . . . . . . Logik als Programmiersprache . . . . . . Techniken der Interaktion bei Mensch-/ Maschine\u2014Systemen der EDV . . . . . . . Wissensbasierte Systeme (Expertensysteme) \"Unkonventionelle\" Programmiersprachen . \u00dcbungsaufgabe . . . . . . . . . . . . . Die ersten Schritte in PROLOG . . . . . Geschichte von PROLOG . . . . . . '\u2026", "num_citations": "19\n", "authors": ["476"]}
{"title": "Mutation testing of\" go-back\" functions based on pushdown automata\n", "abstract": " A go-back (GB) function for canceling recent user or system operations and going back to and resuming of previous state(s) is very often used regardless of the application domain. Therefore, faulty handling of them can cause severe damages in those applications. This paper proposes a mutation-based approach to testing GB functions modeled by pushdown automata. Novel mutation operators, recent coverage criteria, and a new algorithm for test case generation are introduced. A case study validates the approach and discusses its characteristics.", "num_citations": "18\n", "authors": ["476"]}
{"title": "Software testing via model checking\n", "abstract": " Testing is a necessary, but costly process for user-centric quality control. Moreover, testing is not comprehensive enough to completely detect faults. Many formal meth ods have been pro posed to avoid the drawbacks of testing, e.g., model checking that can be automatically carried out. This paper presents an approach that (i) generates test cases from the specification and (ii) transfers the specification-oriented testing process to model checking. Thus, the approach combines the advantages of testing and model checking assuming the availability of (i) a model that specifies the ex pected, desirable system behavior as required by the user and (ii) a second model that describes the system behavior as observed. The first model is complemented in also specifying the undesirable system properties. The approach analyzes both these specification models to generate test cases that are then converted into\u00a0\u2026", "num_citations": "18\n", "authors": ["476"]}
{"title": "Model-based testing of web service compositions\n", "abstract": " The use of web services integrated in different applications, especially the composition of services, brings challenges for testing due to their complex interactions. In this paper, we propose an event-based approach to test web service compositions. The approach is based on event sequence graphs which we extend by facilities to consider the specific features of web service compositions. An enterprise service bus component supports the test case execution. A case study, based on a commercial web application, demonstrates the feasibility of the approach and analyzes its characteristics. The results of empirical work suggest that the approach is a promising candidate to reach a high level of confidence and reliability.", "num_citations": "17\n", "authors": ["476"]}
{"title": "Are longer test sequences always better?-a reliability theoretical analysis\n", "abstract": " One of the interesting questions currently discussed in software testing, both in practice and academia, is the role of test sequences on software testing, especially on fault detection. Previous work includes empirical research on rather small examples tested by relatively short test sequences. Belief is \"the longer the better\", i.e., the longer test sequences are, the more faults are detected. This paper extends those approaches applied to a large commercial application using test sequences of increasing length, which are generated and selected by graph-model-based techniques. Experiments applying many software reliability models of different categories deliver surprising results.", "num_citations": "16\n", "authors": ["476"]}
{"title": "Coverage-based, prioritized testing using neural network clustering\n", "abstract": " Graph-based algorithms are commonly used to automatically gener ate test cases for coverage-oriented testing of software systems. Because of time and cost constraints, the entire set of test cases generated by those algorithms cannot be run. It is then essential to prioritize the test cases in sense of a rank ing, i.e., to order them according to their significance which usually is given by several attributes of relevant events entailed. This paper suggests unsupervised neural network clustering of test cases for forming preference groups, where adaptive competitive learning algorithm is applied for training the neural net work used. A case study demonstrates and validates the approach.", "num_citations": "16\n", "authors": ["476"]}
{"title": "Model-based test case prioritization using cluster analysis: a soft-computing approach\n", "abstract": " Model-based testing is related to the particular relevant features of the software under test (SUT) and its environment. Real-life systems often require a large number of tests, which cannot exhaustively be run due to time and cost constraints. Thus, it is necessary to prioritize the test cases in accordance with their importance as the tester perceives it, usually given by several attributes of relevant events entailed. Based on event-oriented graph models, this paper proposes an approach to ranking test cases in accordance with their preference degrees. For forming preference groups, events are clustered using an unsupervised neural network and fuzzy c-means clustering algorithm. The suggested approach is model-based, so it does not necessitate the availability of the source code of the SUT. It differs from existing approaches also in that it needs no prior information about the tests carried out before. Thus, it can be used to reflect the tester's preferences not only for regression testing as is common in the literature but also for ranking test cases in any stage of software development. For the purpose of experimental evaluation, we compare the suggested prioritization approach with six well-known prioritization methods.", "num_citations": "15\n", "authors": ["476"]}
{"title": "Dependability and Software Reuse--Coupling Them by an Industrial Standard\n", "abstract": " Whereas a software component may be perfectly suited to one application, it may prove to cause severe faults in other applications. The pre-standard IEC/PAS 62814 (Dependability of Software Products Containing Reusable Components - Guidance for Functionality and Tests), which has recently been released, addresses the functionality, testing, and dependability of software components to be reused and products that contain software to be used in more than one application. The present paper introduces into this prestandard and give hints how to use it. The author, who chaired its realization that started in 2006, briefly summarizes the difficult process to bring the industrial partners with controversial interests to a consensus.", "num_citations": "15\n", "authors": ["476"]}
{"title": "Directed acyclic graph modeling of security policies for firewall testing\n", "abstract": " Currently network security of institutions highly depend on firewalls, which are used to separate untrusted network from trusted one by enforcing security policies. Security policies used in firewalls are ordered set of rules where each rule is represented as a predicate and an action. This paper proposes modeling of firewall rules via directed acyclic graphs (DAG), from which test cases can be automatically generated for firewall testing. The approach proposed follows test case generation algorithm developed for event sequence graphs. Under a local area network setup with the aid of a specifically developed software for this purpose, generated test cases are converted to network test packets, test packets are sent to the firewall under test (FUT), and sent packets are compared with passed packets to determine test result.", "num_citations": "15\n", "authors": ["476"]}
{"title": "Coverage-oriented, prioritized testing\u2013a fuzzy clustering approach and case study\n", "abstract": " Existing test techniques focus on particular, relevant aspects of the requirements of the system under test (SUT). Real-life SUTs have, however, numerous features to simultaneously be considered, often leading to a large number of tests. In such cases, because of time and cost constraints the entire set of tests cannot be run. It is then essential to prioritize the tests in sense of a ordering of the relevant events entailed in accordance with the importance of their numerous features. This paper proposes a graph-model-based approach to prioritizing the test process. Tests are ranked according to their preference degrees which are deter mined indirectly, i.e., through classifying the events. To construct the groups of events, Fuzzy c-Means (FCM) clustering algorithm is used. A case study demonstrates and validates the approach. Contrary to other approaches, no prior information is needed about the tests carried\u00a0\u2026", "num_citations": "15\n", "authors": ["476"]}
{"title": "Modeling, analysis and testing of safety issues-an event-based approach and case study\n", "abstract": " This paper proposes an event-based approach with an intuitive simple graphical representation of the system and its environment for designing, analysis and testing safety-critical systems. The events are user actions and system responses, and are ordered according to the threats posed by the resulting system states. This ordering is an integral aspect of the graphical representation, making it possible to directly identify the risks associated with each and every functionally desirable, and undesirable, event relative to one another. Tests that target safety requirements are devised by examining possible traces of these events, represented compactly by regular expressions, exhibiting particular risk patterns such as human error and system failures.", "num_citations": "15\n", "authors": ["476"]}
{"title": "Empirical performance analysis of computer-supported code-reviews\n", "abstract": " Checklist-based code-reviews have been generally accepted as valuable means for software development and management. In order to overcome shortcomings of manual reviewing techniques, such as high costs and lack of systematization, we have already developed and implemented a knowledge-based approach for semi-automation of some steps of individual code-reviews based on checklists. The aim of this paper is to evaluate the performance of our approach for code-reviews. Therefore, two independent groups of reviewers were analyzing the same piece of code (conventional C-programs developed in the automotive industry for gear unit control), where one of the groups deployed the semi-automated approach and the other group used the traditional manual technique. The resulting empirical data were analyzed by means of software metrics and software reliability modeling. Metrics specific to review\u00a0\u2026", "num_citations": "15\n", "authors": ["476"]}
{"title": "Program segmentation for controlling test coverage\n", "abstract": " We present a new control flow based approach to dynamic testing of sequential software. A practicable number of test cases is generated by using the boundary interior path testing strategy (J.B. Goodenough and S.L. Gerhard, 1975) and by dividing the test units into test segments (program fragments composed of one statement or a sequence of statements). The size of the test segments can be adjusted by means of a parameter, i.e. the thoroughness of the test coverage can be adapted to the needs of the tester. The selection of test cases is performed by constructing path classes for each test segment. The coverage criteria constructed by means of our approach (test segment coverage criteria) are fulfilled if at least one path from each path class is covered. A validation of our approach is given by comparing the fault detection capabilities of test segment coverage criteria with the fault detection capabilities of\u00a0\u2026", "num_citations": "15\n", "authors": ["476"]}
{"title": "Software-Konstruktion mit LISP\n", "abstract": " N\u00fctzliche Produkte entstehen kaum per Zufall. Sie erfordern einen sorgsam geplanten Herstellungsproze\u00df, wenn es gilt, sie wirtschaftlich, in gew\u00fcnschter Qualit\u00e4t und termingerecht zu produzieren. Das planm\u00e4\u00dfige Konstruieren ist eine Aufgabe f\u00fcr Ingenieure. Sie kennen bew\u00e4hrte Grundkonstruktionen, mit denen sie die gestellte Aufgabe meistern. Stets greifen sie dazu auf schon existierende Halb-und Fertigprodukte (normierte Bausteine) zur\u00fcck.", "num_citations": "14\n", "authors": ["476"]}
{"title": "Methoden und Hilfsmittel f\u00fcr die systematische Pr\u00fcfung komplexer Software\n", "abstract": " F\u00fcr einen verl\u00e4\u00dflichen Einsatz von komplexen Software-Systemen ist einerseits wichtig, da\u00df sie mit technologisch angemessenen Techniken und Methoden aufgabengerecht konstruiert werden. Andererseits ist die Nachweisf\u00fchrung keineswegs trivial, da\u00df das zu liefernde bzw. abzunehmende System den erw\u00fcnschten Leistungsumfang voll, d.h. in aller erdenklichen Funktionsvielfalt deckt. Der vorliegende Beitrag fa\u00dft die einschl\u00e4gigen Pr\u00fcftechniken f\u00fcr Software zusammen.", "num_citations": "14\n", "authors": ["476"]}
{"title": "Input contract testing of graphical user interfaces\n", "abstract": " User inputs are critical for the security, safety, and reliability of software systems. This paper proposes a new concept called user input contracts, which is an integral part of a design-by-contract supplemented development process, and a model-based testing approach to detect violations of user input contracts. The approach generates test cases from an input contract integrated with graph-based model of user interface specification and applies them to the system under consideration. The paper presents a proof-of-concept tool that has been developed and used to validate the approach by experiments. The experiments are conducted on a web-based system for marketing tourist services to analyze input robustness of system under consideration with respect to user input contracts.", "num_citations": "13\n", "authors": ["476"]}
{"title": "Towards scalable robustness testing\n", "abstract": " Several approaches have been developed to assess the robustness of a system. We propose a model-based approach to scalable testing the robustness of a software system using event sequence graphs (ESG) and decision tables (DT). Elementary modification operators are introduced to manipulate ESGs and DTs resulting in faulty models. Test cases generated from these faulty models are applied to the system under consideration to check its robustness. Thus, the approach enables the quantification of robustness with respect to a universe of erroneous inputs.", "num_citations": "13\n", "authors": ["476"]}
{"title": "Event-based input validation using design-by-contract patterns\n", "abstract": " This paper proposes an approach for validation of numerical inputs based on graphical user interfaces (GUI) that are modeled and specified by event sequence graphs (ESG). For considering complex structures of input data, ESGs are augmented by decision tables and patterns of design by contract (DbC). The approach is evaluated by experiments on boundary overflows, which occur when input values violate the range of specified values. Furthermore, a tool is presented that implements our approach enabling a semi-automatically detection of boundary overflow errors and suggesting correction steps based on DbC.", "num_citations": "13\n", "authors": ["476"]}
{"title": "View graphs for analysis and testing of programs at different abstraction levels\n", "abstract": " This paper introduces view graphs, which allow representation of source code for program analysis and testing at different levels of abstraction. At a low level of abstraction, view graphs can be used for white-box analysis and testing, and at a high level of abstraction, they can be used for black-box analysis and testing. View graphs are thus an approach to integrate black-box and white-box techniques.", "num_citations": "13\n", "authors": ["476"]}
{"title": "Exploiting model morphology for event-based testing\n", "abstract": " Model-based testing employs models for testing. Model-based mutation testing (MBMT) additionally involves fault models, called mutants, by applying mutation operators to the original model. A problem encountered with MBMT is the elimination of equivalent mutants and multiple mutants modeling the same faults. Another problem is the need to compare a mutant to the original model for test generation. This paper proposes an event-based approach to MBMT that is not fixed on single events and a single model but rather operates on sequences of events of length k \u2265 1 and invokes a sequence of models that are derived from the original one by varying its morphology based on k. The approach employs formal grammars, related mutation operators, and algorithms to generate test cases, enabling the following: (1) the exclusion of equivalent mutants and multiple mutants; (2) the generation of a test case in linear\u00a0\u2026", "num_citations": "12\n", "authors": ["476"]}
{"title": "Model-based mutation testing using pushdown automata\n", "abstract": " SUMMARY A model-based mutation testing (MBMT) approach enables to perform negative testing where test cases are generated using mutant models containing intentional faults. This paper introduces an alternative MBMT framework using pushdown automata (PDA) that relate to context-free (type-2) languages. There are two key ideas in this study. One is to gain stronger representational power to capture the features whose behavior depends on previous states of software under test (SUT). The other is to make use of a relatively small test set and concentrate on suspicious parts of the SUT by using MBMT approach. Thus, the proposed framework includes (1) a novel usage of PDA for modeling SUT,(2) novel mutation operators for generating PDA mutants,(3) a novel coverage criterion, and an algorithm to generate negative test cases from mutant PDA. A case study validates the approach, and discusses its characteristics and limitations.", "num_citations": "12\n", "authors": ["476"]}
{"title": "Event-based mutation testing vs. state-based mutation testing-an experimental comparison\n", "abstract": " Model-based testing (MBT) focuses on relevant, mostly user-centric features of the system under consideration (SUC) and enables test case generation without requiring source code. Depending on these features and the preferences of the tester, modeling can be event-based or state-based. This paper compares both techniques using mutation testing, which is originally code-based, but has recently been extended to enable also MBT. For the comparison, the paper introduces frameworks that are composed of a set of models, a set of mutation operators, a set of coverage criteria, and a set of test generation algorithms. The introduced concepts and notions are demonstrated over a case study based on a large web-based commercial portal. Analysis of the experimental data yields results on the discussed frameworks reviewing benefits and drawbacks of event-based and state-based testing.", "num_citations": "12\n", "authors": ["476"]}
{"title": "Advancing test automation technology to meet the challenges of model-based software testing-Guest editors' introduction to the special section of the Third IEEE International\u00a0\u2026\n", "abstract": " Editorial: Advancing test automation technology to meet the challenges of model-based software testing - Guest editors' introduction to the special section of the Third IEEE International Workshop on Automation of Software Test (AST 2008): Information and Software Technology: Vol 51, No 11 ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Information and Software Technology Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsInformation and Software TechnologyVol. , No. Editorial: Advancing test automation technology to meet the challenges of model-based software testing - Guest editors' introduction to the special section of the Third IEEE (-\u2026", "num_citations": "12\n", "authors": ["476"]}
{"title": "Prioritizing coverage-oriented testing process-an adaptive-learning-based approach and case study\n", "abstract": " This paper proposes a graph-model-based approach to prioritizing the test process. Tests are ranked according to their preference degrees which are determined indirectly, i.e., through classifying the events. To construct the groups of events, unsupervised neural network is trained by adaptive competitive learning algorithm. A case study demonstrates and validates the approach.", "num_citations": "12\n", "authors": ["476"]}
{"title": "Erprobte Modelle zur Quantifizierung der Software-Zuverl\u00e4ssigkeit\n", "abstract": " Ein Software-System wird intuitiv als zuverl\u00e4ssig bezeichnet, wenn es den berechtigten Benutzungserwartungen bez\u00fcglich der Erf\u00fcllung seiner Aufgaben \u00fcber einen Zeitraum hinweg auf zufriedenstellende Weise entspricht. Eine Quantifizierung dieser Zuverl\u00e4ssigkeit wird durch mathematische Modelle, Software-Zuverl\u00e4ssigkeitsmodelle, angestrebt. Vor allem f\u00fcr sicherheitskritische Systeme sind solche Modelle, die eine solide theoretische Fundierung besitzen, eingesetzt worden. Dieser Artikel gibt eine \u00dcbersicht \u00fcber die bestehenden \u201eklassischen\u201c Ans\u00e4tze zur quantitativen Software-Zuverl\u00e4ssigkeitsbestimmung und fa\u00dft Erfahrungen mit deren Einsatz in der Praxis zusammen. Als Ausblick werden neue Entwicklungen zu alternativen Sichtweisen der Zuverl\u00e4ssigkeit beleuchtet.", "num_citations": "11\n", "authors": ["476"]}
{"title": "Does\" depth\" really matter? On the role of model refinement for testing and reliability\n", "abstract": " Model-based testing attempts to generate test cases from a model focusing on relevant aspects of a given system under consideration (SUC). When SUC becomes too large to be modeled in a single step, existing design techniques usually require a modularization of the modeling process. Thereby, the refinement process results in a decomposition of the model into several hierarchical layers. Conventional testing requires the refined components be completely replaced by these subcomponents for test case generation. Mostly, this resolution of components leads to an oversized, large model where test case generation becomes very costly, and the generated test case set is very large leading to infeasible long test execution time. To solve these problems, we present a new strategy to reduce (i) the number of test cases, and (ii) the costs of test case generation and test execution. For determining the trade-off due to\u00a0\u2026", "num_citations": "10\n", "authors": ["476"]}
{"title": "Model-based higher-order mutation analysis\n", "abstract": " Mutation analysis is widely used as an implementation-oriented method for software testing and test adequacy assessment. It is based on creating different versions of the software by seeding faults into its source code and constructing test cases to reveal these changes. However, in case that source code of software is not available, mutation analysis is not applicable. In such cases, the approach introduced in this paper suggests the alternative use of a model of the software under test. The objectives of this approach are (i) introduction of a new technique for first-order and higher-order mutation analysis using two basic mutation operators on graph-based models, (ii) comparison of the fault detection ability of first-order and higher-order mutants, and (iii) validity assessment of the coupling effect.", "num_citations": "10\n", "authors": ["476"]}
{"title": "Model based mutation testing of firewalls\n", "abstract": " We propose a combined approach for test case generation to uncover errors both in firewall software and in its configuration. A case study validates the approach.", "num_citations": "10\n", "authors": ["476"]}
{"title": "Layer-centric testing\n", "abstract": " Model-based testing attempts to generate test cases from a model focusing on relevant aspects of a given system under consideration (SUC). When SUC becomes too large to be modeled in a single step, existing design techniques usually require a modularization of the modeling process. Thereby, the refinement process results in a hierarchical decomposition of the SUC in several hierarchical layers. Conventional testing requires the refined components be completely replaced by these subcomponents for test case generation. We present a new test case generation strategy based on the different layers of the model to reduce (i) the number of test cases, and thus (ii) the costs of test case generation and test execution. A case study based on a complex application component of a large web-based commercial system validates the approach and discusses its characteristics regarding the number of test cases and their fault detection ability. Surprisingly, most of the faults could be detected by a considerably reduced test case set.", "num_citations": "9\n", "authors": ["476"]}
{"title": "Communication sequence graphs for mutation-oriented integration testing\n", "abstract": " Integration testing (IT) plays an important role for validation of the communication between different software components to ensure their optimal cooperation. In this paper we (i) introduce communication sequence graphs (CSG) for integration testing representing the communication between software components on a meta-level, (ii) define coverage criteria based on these graphs, and (iii) give hints how to extend CSG notion by Boolean algebra in order to represent complex data structures of data exchanged between components to be integrated. A case study borrowed from a robot controlling system illustrates CSG as a new integration testing approach.", "num_citations": "9\n", "authors": ["476"]}
{"title": "A holistic approach to test-driven model checking\n", "abstract": " Testing is the most common validation method in the soft ware in dustry. It entails the execu tion of the software system in the real envi ron ment. Nevertheless, testing is a cost-in tensive process. Be cause of its conceptual simplicity the combination of formal methods and test methods has been widely advocated. Model checking be longs to the promising candidates for this marriage. The present paper modifies and ex tends the existing approaches in that, after the test case gen eration, a model checking step supports the manual test process. Based on the holistic approach to specifi cation-based construction of test suites, this paper proposes to generate test cases to cover both the specifi cation model and its com ple ment. This helps also to clearly differ enti ate the correct system outputs from the faulty ones as the test cases based on the specifi ca tion are to succeed the test, and the ones based on the\u00a0\u2026", "num_citations": "9\n", "authors": ["476"]}
{"title": "Declarative paradigm of test coverage\n", "abstract": " Two facts about declarative programming prevent the application of conventional testing methods. First, the classical test coverage measures such as statement, branch or path coverage, cannot be used, since in declarative programs no control flow notion exists. Second, there is no widely accepted language available for formal specification, since predicate logic, which is the most common formalism for declarative programming, is already a very high\u2010level abstract language. This paper presents a new approach exending previous work by the authors on test input generation for declarative programs. For this purpose, the existing program instrumentation notion is extended and a new logic coverage measure is introduced. The approach is mathematically formalized and the goal of achieving 100% program logic coverage controls the automatic test input generation. The method is depicted by means of logic\u00a0\u2026", "num_citations": "9\n", "authors": ["476"]}
{"title": "Systems Modelling and Simulation by Means of Predicate/Transition Nets and Logic Programming.\n", "abstract": " In this paper we present a method for systems design, specification and test based on predicate/transition nets (PrT nets) and logic programming. An approach to transforming requirements driven Prt net models into logic programs is given. The automatically generated logic programs contain the static structure and the dynamic behavior of the PrT net models and can be used for simulation and test purposes. Moreover, they can be viewed as specification of the programs to be implemented. Examples are given which illus-trate the transformation steps and show how Prolog goals can be used to test system model properties in a compact and easy way.", "num_citations": "9\n", "authors": ["476"]}
{"title": "Testing and reliability of logic programs\n", "abstract": " The systematic approaches to testing and reliability determination of programs e.g. are applicable to imperative programming but not immediately to declarative programming, such as logic programming, which is of great importance to develop knowledge-based systems. We describe an approach to implementation-based testing and reliability determination of logic programs materialized in a product assurance environment, presently limited to two major components: the test environment PROTest and the reliability assessment environment PRORool, with the results of the former serving as input for the latter. The test environment consists of structure analysis of logic programs, automatic test case generation and execution, test coverage determination, and generation of test reports. The reliability assessment environment provides an approach to reliability prediction and estimation of Prolog programs, introducing\u00a0\u2026", "num_citations": "9\n", "authors": ["476"]}
{"title": "Comparative analysis of concurrent fault tolerance techniques for real-time applications\n", "abstract": " Consensus recovery block scheme and concurrent recovery scheme may become useful for real-time applications as they consider concurrency and time efficiency. The authors compare the performance of both techniques in terms of the times they consume to achieve software fault tolerance. For this purpose a simple model is used and analysed which simulates different real-time situations.<>", "num_citations": "9\n", "authors": ["476"]}
{"title": "GUI-based testing of boundary overflow vulnerability\n", "abstract": " Boundary overflows are caused by violation of constraints, mostly limiting the range of internal values of program, and can be provoked by an intruder to gain control of or access to stored data. In order to countermeasure this well-known vulnerability issue, this paper focuses on input validation of graphical user interfaces (GUI). The approach proposed generates test cases for numerical inputs based on GUI specification through decision tables. If boundary overflow error(s) are detected, the source code will be analyzed to localize and correct the encountered error(s) automatically.", "num_citations": "8\n", "authors": ["476"]}
{"title": "Protocol-based testing of firewalls\n", "abstract": " A firewall is the most important tool of network security defense. Its proper functioning is critical to the network it protects. Therefore a firewall should be tested rigorously with respect to its implemented network protocols and security policy specification. We propose a combined approach for test case generation to uncover errors both in firewall software and in its configuration. In the proposed approach, abstract test cases are generated by mutating event sequence graph model of chosen network protocol and filled with values from policy specification by using equivalence partitioning and boundary value analysis. A case study is presented to validate the presented approach.", "num_citations": "7\n", "authors": ["476"]}
{"title": "A graph-model-based testing method compared with the classification tree method for test case generation\n", "abstract": " In automotive industry, mechanic control units are more and more replaced by electronic devices that are often aggregated in electronic control units (ECU). Systematic testing is one of the preferred industrial validation methods to ensure functionality of those ECUs. It is imperative to reduce the costs and improve the effectiveness of testing by automating the testing process. This paper introduces a model-based testing method using event sequence graphs and compares this approach with the classification tree method which is popular in automotive industry. A case study applies both methods to the formal specification of an adaptive cruise control unit for generation and selection of test cases. To enable a meaningful comparison, test costs and number of faults revealed by both methods will be compared.", "num_citations": "7\n", "authors": ["476"]}
{"title": "Boolean Differentiation for Formalizing Myers' Cause-Effect Graph Testing Technique\n", "abstract": " Cause-Effect Graph Testing is a popular technique used for almost four decades. Based on Boolean algebra, this technique assists deriving test cases from a given specification informally written in a natural language. The present paper suggests Boolean differentiation for formalizing this technique. The new approach is applied to an example, borrowed from G. Myers, for demonstrating and analyzing its features. Evaluations show that the new approach outperforms Myers' approach in terms of the detected faults per test cases.", "num_citations": "6\n", "authors": ["476"]}
{"title": "Using regular grammars for event-based testing\n", "abstract": " Model-based testing involves formal models for test generation. This paper suggests regular grammars for event-based modeling. This model, represented in BNF, will then be systematically modified by well-defined mutation operators in order to generate fault models, called mutants. Specific algorithms apply to both the model of the system under consideration and the mutants to generate test cases. While existing methods focus on single events the approach introduced in this paper suggests considering event sequences of length k\u22651, that is, k-sequences. The approach also enables to cope with a tough problem encountered in mutation-oriented testing: the elimination of mutants that are equivalent to the original model, and mutants that model the same faults multiple times. These mutants lead to unproductive test suites that cause wasting of resources. The approach proposed devises strategies to\u00a0\u2026", "num_citations": "6\n", "authors": ["476"]}
{"title": "Model-based test prioritizing\u2013a comparative soft-computing approach and case studies\n", "abstract": " Man-machine systems have many features that are to be considered simultaneously. Their validation often leads to a large number of tests; due to time and cost constraints they cannot exhaustively be run. It is then essential to prioritize the test subsets in accordance with their importance for relevant features. This paper applies soft-computing techniques to the prioritizing problem and proposes a graph model-based approach where preference degrees are indirectly deter mined. Events, which imply the relevant system behavior, are classified, and test cases are clustered using (i) unsupervised neural network clustering, and (ii) Fuzzy c-Means clustering algorithm. Two industrial case studies validate the approach and compare the applied techniques.", "num_citations": "6\n", "authors": ["476"]}
{"title": "Advancing test automation technology to meet the challenges of model-driven software development: report on the 3rd workshop on automation of software test\n", "abstract": " The Third Workshop on Automation of Software Test (AST 2008) at the 30th Interna\u00ac tional Conference on Software Engineering (ICSE 2008) sets a special theme on model-based software testing. Nine full research papers and six short papers will be presented in four sessions at the workshop. This report summarizes the organization of the workshop as well as the sessions and papers to be presented at the workshop.", "num_citations": "6\n", "authors": ["476"]}
{"title": "Holistic testing with basic statecharts\n", "abstract": " Based on prior work, this paper extends our holistic approach to generation and selection of test cases based on statecharts. A basic definition of statecharts is given. Furthermore, test selection criteria and a test process are presented.", "num_citations": "6\n", "authors": ["476"]}
{"title": "An extension of PROLOG for object-oriented programming in logic\n", "abstract": " In this paper, we attempt extending Logic Programming \u201csmoothly\u201d in order to allow object-orientation in a PROLOG-like environment. We call our extension \u201cPROLoop\u201d(Yet another PROLOG-based Language for Object-Oriented Programming). PROLoop is the essential component of a PROLOG-based environment (\u201cPROViro\u201d) to develop knowledge and rule-based expert systems.", "num_citations": "6\n", "authors": ["476"]}
{"title": "Some aspects on the development and validation of FIREX: a knowledge-based system for the transport of dangerous goods and fire department consulting\n", "abstract": " Publication: IEA/AIE'89: Proceedings of the 2nd international conference on Industrial and engineering applications of artificial intelligence and expert systems-Volume 2 June 1989 Pages 680\u2013689 https://doi. org/10.1145/67312.67333", "num_citations": "6\n", "authors": ["476"]}
{"title": "A strategy for the development of communication fault-tolerant systems by means of regular expressions\n", "abstract": " For many critical applications it appears necessary to protect the system operation against certain run time user and hardware errors, eg wrong command inputs, transmission errors etc. In this paper we present a method for systematic treatment of such problems. The basic idea is to model system behaviour by a regular expression, ie an expression that can be generated by a type-3 grammar of Chomsky hierarchy. By means of this tool, we can systematically specify not only the required system operation, but also erroneous system behaviour. A strategy is derived to include redundancy in the system specification so that such conditions can be detected and corrected. The paper discusses also how the correcting operations at run time can be supported by additional hardware of highly regular structure.", "num_citations": "6\n", "authors": ["476"]}
{"title": "Regular expressions for fault handling in sequential circuits\n", "abstract": " Based on regular expressions (RE), this paper proposes an approach to modeling sequential circuits and related faults, and introduces a strategy for self-detecting, self-localizing, and self-correcting modeled faults. A case study evaluates the approach and analyzes its characteristics.", "num_citations": "5\n", "authors": ["476"]}
{"title": "Test prioritization at different modeling levels\n", "abstract": " Validation of real-life software systems often leads to a large number of tests; which, due to time and cost constraints, cannot exhaustively be run. Therefore, it is essential to prioritize the test cases in accordance with their importance the tester perceives. This paper introduces a model-based approach for ranking tests according to their preference degrees, which are determined indirectly, through event classification. For construction of event groups, Gustafson - Kessel clustering algorithms are used. Prioritizing is performed at different granularity levels in order to justify the effectiveness of the clustering algorithm used. A case study demonstrates and validates the approach.", "num_citations": "5\n", "authors": ["476"]}
{"title": "Towards test case generation for synthesizable VHDL programs using model checker\n", "abstract": " VHDL programs are often tested by means of simulations, relying on test benches written intuitively. In this paper, we propose a formal approach to construct test benches from system specification. To consider the real-time properties of VHDL programs, we first transform them to timed automata and then perform model checking against the properties designated from the specification. Counterexamples returned from the model checker serve as a basis of test cases, i.e. they are used to form a test bench. The approach is demonstrated and complemented by a simple case study.", "num_citations": "5\n", "authors": ["476"]}
{"title": "Mutation of Directed Graphs--Corresponding Regular Expressions and Complexity of Their Generation\n", "abstract": " Directed graphs (DG), interpreted as state transition diagrams, are traditionally used to represent finite-state automata (FSA). In the context of formal languages, both FSA and regular expressions (RE) are equivalent in that they accept and generate, respectively, type-3 (regular) languages. Based on our previous work, this paper analyzes effects of graph manipulations on corresponding RE. In this present, starting stage we assume that the DG under consideration contains no cycles. Graph manipulation is performed by deleting or inserting of nodes or arcs. Combined and/or multiple application of these basic operators enable a great variety of transformations of DG (and corresponding RE) that can be seen as mutants of the original DG (and corresponding RE). DG are popular for modeling complex systems; however they easily become intractable if the system under consideration is complex and/or large. In such situations, we propose to switch to corresponding RE in order to benefit from their compact format for modeling and algebraic operations for analysis. The results of the study are of great potential interest to mutation testing.", "num_citations": "5\n", "authors": ["476"]}
{"title": "\u201eNegativ \u201c-Tests interaktiver Systeme und ihre Automatisierung\n", "abstract": " Die konventionelle, benutzungsorientierte Pr\u00fcfung der Qualit\u00e4t von Software konzentriert sich aufs Testen des Systemverhaltens unter regul\u00e4ren Bedingungen. Der vorliegende Beitrag \u00fcberpr\u00fcft das Systemverhalten \u00fcber diese \u201eSch\u00f6nwetter-Tests\u201c hinaus bei fehlerhaften, meist unerwarteten Benutzungseingaben (\u201eNegativ\u201c-Tests). Dabei ist das Augenmerk auf Testautomatisierung gelegt, insbes. zur Pr\u00e4zisierung des Wertebereichs der Testeingabedaten, Verfeinerung der Testeingaben und Verdeutlichung kausaler Abh\u00e4ngigkeiten.", "num_citations": "5\n", "authors": ["476"]}
{"title": "A Holistic view for Modeling and Testing User Interactions using Finite-State Techniques\n", "abstract": " With the growing complexity of the computer-based system, also their user interfaces, mostly materialized graphically, become more complex, accordingly making the test and analysis process more and more tedious and costly. The paper introduces a holistic view of fault modeling that can be carried out as a complementary step to system modeling, enabling a precise scalability of the test process, revealing much rationalization potential. Finite-state based notions and tools enable to introduce efficient algorithms to generate and select test cases systematically. The elements of the approach will be illuminated and validated by realistic examples.", "num_citations": "5\n", "authors": ["476"]}
{"title": "Systems specification, analysis, and validation by means of timed predicate/transition nets and logic programming\n", "abstract": " A method is presented for systems design, specification and analysis based on predicate/transition nets (PrT nets) and logic programming. In order to evaluate and optimize the behavior of systems, the PrT net models are extended with quantitative time. The firing times are assigned to transitions and are given by arithmetic expressions which might contain variables An approach to transforming requirements driven PrT net models into logic programs is given. The generated logic programs contain the static structure and the dynamic behavior of the PrT net models and can be used for simulation and analysis purposes. Moreover they can be viewed as a precise and lucid specification of the programs to be implemented. Three examples are given which illustrate how Prolog goals can be used to validate system model properties. Example 1 describes the transformation steps for simple PrT net models. In Example 2\u00a0\u2026", "num_citations": "5\n", "authors": ["476"]}
{"title": "Model-Based Integration Testing with Communication Sequence Graphs.\n", "abstract": " While unit testing is supposed to guarantee the proper function of single units, integration testing (ITest) is intended to validate the communication and cooperation between different components. ITest is important because many events are caused by integration-related faults such as, for example, failures during money transfer, air-and spacecraft crashes, and many more that are not detectable during unit testing. This chapter introduces an approach to model-based integration testing. After a brief review of existing work (1) communication sequence graphs (CSG) are introduced for representing the communication between software components on a meta-level and (2) based on CSG and other introduced notions test coverage criteria are defined. A case study based on a robot-controlling application illustrates and validates the approach.", "num_citations": "4\n", "authors": ["476"]}
{"title": "Ereignis-basierter Test grafischer Benutzeroberfl\u00e4chen\u2013ein Erfahrungsbericht\n", "abstract": " Wie leicht zu erkennen ist, nahm der Aufwand zur manuellen Testdurchf\u00fchrung mehr Zeit ein als die eigentliche Modellierung der Graphen, n\u00e4mlich ca. 60%(84 Stunden zu 53 Stunden). Zuk\u00fcnftig ist geplant, die manuelle Testdurchf\u00fchrung zu automatisieren. Ziel ist es dabei, Test-Skripte aus den Graphen zu generieren, die durch eine entsprechende Testumgebung automatisiert ausgef\u00fchrt werden. Ebenso sinnvoll ist ein Backtracking der gefundenen Fehler zur\u00fcck in die Graphen, indem Ereignispaare, die Fehler detektiert haben, entsprechend im Graphen hervorgehoben werden. Im Idealfall muss sich der Testingenieur keine Gedanken mehr um die Aufstellung und Ausf\u00fchrung der Testf\u00e4lle k\u00fcmmern, sondern kann komplett auf Graphen-Ebene arbeiten.", "num_citations": "4\n", "authors": ["476"]}
{"title": "PROTest II, Testing Logic Programs\n", "abstract": " Testing of programs has been of great interest in the past decades, and many results have been presented [7, 1, 8]. How-ever, all these systematic approaches are applicable to imper-ative programming but not for declarative programming, such as logic programming. In this paper, we describe an approach to testing logic programming materialized in a test environment, including a test language. The environment consists of structure analysis of logic programs, automatic test case generation, automatic test erecution, test coverage determination, and generation of test reports. Our concept refines a type and mode scheme for Prolog.", "num_citations": "4\n", "authors": ["476"]}
{"title": "Eine theorie der analyse und konstruktion fehlertolerierender systeme\n", "abstract": " In this paper, we are going to introduce mathematical concepts to define the notion of a \u201eModule\u201c for hardware and software systems and to take into account methods of fault-tolerant computation from the very beginning of system development. Moduls are formalized by means of Regular Expressions and their derivates. With the aid of these mathematical concepts a theory of the analysis and construction of fault-tolerant systems will be presented.               The general fault-tolerant problem will be solved in three steps: The predication of fault-tolerence of a system, the diagnosis of faults while the system is in operation and, last but not least, a construction of a fault-tolerant system.               The methods applied are syntactical although the class of faults under consideration are by no means restricted to the calls of syntax errors in programming.", "num_citations": "4\n", "authors": ["476"]}
{"title": "Finite-state testing of graphical user interfaces\n", "abstract": " The most Human-Computer-Interfaces will be materialized by Graphical User Interfaces (GUI). With the growing complexity of the computer-based system, also their GUIs become more complex, accordingly making the test process more and more costly. The paper introduces a holistic view of fault modeling that can be carried out as a complementary step to system modeling, enabling a precise scalability of the test process, revealing many rationalization potential while testing. Appropriate formal notions and tools enable to introduce efficient algorithms to generate test cases systematically. Based on a basic coverage metric, test case selection can be carried out efficiently. The elements of the approach will be narrated by realistic examples which will be used also to validate the approach.", "num_citations": "4\n", "authors": ["476"]}
{"title": "Model-based contract testing of graphical user interfaces\n", "abstract": " Graphical User Interfaces (GUIs) are critical for the security, safety and reliability of software systems. Injection attacks, for instance via SQL, succeed due to insufficient input validation and can be avoided if contract-based approaches, such as Design by Contract, are followed in the software development lifecycle of GUIs. This paper proposes a model-based testing approach for detecting GUI data contract violations, which may result in serious failures such as system crash. A contract-based model of GUI data specifications is used to develop test scenarios and to serve as test oracle. The technique introduced uses multi terminal binary decision diagrams, which are designed as an integral part of decision table-augmented event sequence graphs, to implement a GUI testing process. A case study, which validates the presented approach on a port scanner written in Java programming language, is presented.", "num_citations": "3\n", "authors": ["476"]}
{"title": "Testing Composite Web Services--An Event-Based Approach\n", "abstract": " Web services (WS) empower centralization of computer-based services for broadly offering them over a network. Additionally, WSs can be combined to implement new services which are called composite WSs. This enables enterprises and private users to realize complex Web applications by putting different, existing services together. The objective of this paper is to generate test cases for testing interactions of WSs within a composite WS. Dependencies among transferred data as well as conditions in control flow and real-time constraints are modeled by concurrent event sequence graphs (cESG) which are augmented by decision tables (DT). This novel approach allows a precise fault modeling that leads to an efficient test process. Thus, the novelty of the approach stems from (i) its simplicity and lucidity in representing complex real-time composite WSs, (ii) its modeling that considers a comfortable fault\u00a0\u2026", "num_citations": "3\n", "authors": ["476"]}
{"title": "Reliability prediction and estimation of Prolog programs\n", "abstract": " This paper presents an approach to reliability prediction and estimation of PROLOG programs, and introduces 2 complexity measures for PROLOG programs. The structural complexity measure refers to the program's static characteristics: size and number of clauses; clause arguments (number and types); and clause types (facts or rules). The operational complexity measure refers to the program's dynamic characteristics: execution frequency of program components; user behavior; and backtracking and recursion. Values of the two measures are used to: (1) predict PROLOG program reliability before testing and in the early testing stages; and (2) estimate the reliability as a function of time, in order to determine whether the reliability objective is achieved. The feature-oriented reliability determination approach leads to improvements in the accuracy of software reliability predictions and estimations.< >", "num_citations": "3\n", "authors": ["476"]}
{"title": "An environment for self-testing of logic programs\n", "abstract": " An environment for self-testing of logic programs | Proceedings of the 7th international conference on Industrial and engineering applications of artificial intelligence and expert systems ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search iea-aei Conference Proceedings Upcoming Events Authors Affiliations Award Winners More HomeConferencesIEA-AEIProceedingsIEA/AIE '94An environment for self-testing of logic programs Article An environment for self-testing of logic programs Share on Authors: Fevzi Belli View Profile , Oliver Jack View Profile Authors Info & Affiliations Publication: IEA/AIE '94: Proceedings of the 7th international conference on Industrial and engineering applications of artificial and May ! \u2026", "num_citations": "3\n", "authors": ["476"]}
{"title": "Determining the reliability of prolog programs\n", "abstract": " In this paper an approach to reliability prediction and estimation of Prolog programs is proposed. Two complexity measures describing Prolog programs are introduced. Values of the two measures are used, subsequently, to predict the reliability of Prolog programs before testing and in the early testing stages, and further, to estimate the reliability as a function of time, in order to determine whether the reliability objective is achieved. The proposed reliability determination approach is based on previous work (Azem et al., 1993), extending the prediction approach used therein through modification of the complexity measures and providing an estimation approach. It leads to improvements in the quality of predictions and estimations with respect to software reliability characteristics. The proposed approach is implemented in a reliability assessment environment, which also includes several well-known software reliability\u00a0\u2026", "num_citations": "3\n", "authors": ["476"]}
{"title": "Transforming VHDL to timed automata\n", "abstract": " 1 BackgroundSynthesizable VHDL is the subset of VHDL, which is used for synthesizing digital circuits. The entire formal grammar definition of VHDL is beyond the scope of this work, yet some of the statements and critical aspects are explained in this context. For complete grammar definition of hardware description languages, see [5] and [3]. Without loss of generality, we restrict our work to the following VHDL syntax for the sake of clarity:", "num_citations": "2\n", "authors": ["476"]}
{"title": "Einsatz Eines Gefahrgut-Informationssystems\u2014Beobachtungen und Konsequenzen f\u00fcr Die Weiterentwicklung\n", "abstract": " Das Informationssystem f\u00fcr Umweltchemikalien, Chemieanlagen und St\u00f6rf\u00e4lle (kurz INFUCHS; Betreiber Umweltbundesamt Berlin) wird von der BeruMeuerwehr der Stadt Bremerhaven in Form einer Pilotanwendung erprobt In diesem Kontext wird die M\u00f6glichkeit einer Verkn\u00fcpfung der INFUCHS-Leistungen mit unserem wissensbasierten System FIREX (*FIRe avoidance and combat Expertise, s, z.B. /1/) gepr\u00fcft Bei dieser Verkn\u00fcpfung interessieren uns Gestaltungsfragen einer sinnvollen Arbeitsteilung (prim\u00e4r die DV-technische Schnittstellen-Definition). Es geht um die Verst\u00e4rkung des FIREX-Fachwissens durch automatischen R\u00fcckgriff auf eine Gefahrgutdatenbank.               Die vorliegende Arbeit dokumentiert konkrete INFUCHS-Erfahrungen und skizziert daraus Konsequenzen f\u00fcr die Wieterentwicklung von \u201ezentral gepflegten\u201c Informationssytemen, wenn diese f\u00fcr eine Entscheidungsunterst\u00fctzung \u201evor\u00a0\u2026", "num_citations": "2\n", "authors": ["476"]}
{"title": "Ein Ansatz zur Zuverl\u00e4ssigkeits-Optimierung fehlertoleranter Software/Towards reliability optimization of fault-tolerant software\n", "abstract": " Criteria for the evaluation ofprobabilistic methods for the determination of the reliability of computer programs will be developed. An approach to the optimization of the software reliability subject to the resources applied (as to amount and quality of programming efforts, development and operation environment, and redundancy to achieve fault-tolerance) is given. The results will be applied to determine the optimal structure of the software to be developed.", "num_citations": "2\n", "authors": ["476"]}
{"title": "CADAS: a tool for designing reliable embedded software and supporting testing \u201cin the large\u201d\n", "abstract": " The development of embedded software systems has been plagued by problems of reliability, availability and high costs. The development of ADA has recognised the contribution of the implementation language to this budget deficit. Unfortunately, that of the support environment including verification and validation and the interplay of its individual components has still to be generally recognised and understood.               In order to define an ideal tool for verification and validation, its interplay with other programming support environment components must first be recognised. The design and part realisation of such a tool has been achieved through the development of CADAS (Computer Aided Design And Verification System). In this paper its development, implementation and use todate are discussed. A concept of how it may be used to support the development and verification of exception handlers is\u00a0\u2026", "num_citations": "2\n", "authors": ["476"]}
{"title": "Erweiterung regul\u00e4rer Sprachen zur automatischen Erkennung und Korrektur von syntaktischen Fehlern\n", "abstract": " Die vorliegende Arbeit wurde als Dissertation von der Technischen Universit\u00e4t Berlin, Fachbereich Informatik genehmigt. Die Berichter waren", "num_citations": "2\n", "authors": ["476"]}
{"title": "Mutation Operators for Decision Table-Based Contracts Used in Software Testing\n", "abstract": " The Design by Contract technique allows developers to improve source code with contracts, and testing using contracts helps to identify faults. However, the source code of the program under test is not always available. With black-box testing, it is possible to generate contracts from specifications of the software. In this paper, we apply mutation analysis on a model of a given specifications, where mutants are initially gained by applying proposed in this paper certain mutation operators on corresponding model, and then mutated specifications are examined.", "num_citations": "1\n", "authors": ["476"]}
{"title": "Vorwort der Herausgeber\n", "abstract": " Vorwort der Herausgeber De Gruyter De Gruyter EN English Deutsch EUR \u20ac GBP \u00a3 USD $ 0 \u00d7 Your purchase has been completed. Your documents are now available to view. \u00d7 Changing the currency will empty your shopping cart. Confirm Cancel Fevzi Belli, Hinrich E. Bonin and Hinrich E. Bonin Software-Konstruktion mit LISP Vorwort der Herausgeber De Gruyter | 1991 DOI: https://doi.org/10.1515/9783110852769-001 PDF PDF Share Cite \u00d7 Chapter Software-Konstruktion mit LISP Vorwort der Herausgeber Fevzi Belli, Hinrich E. Bonin, Hinrich E. Bonin 2019 MLA APA Harvard Chicago Vancouver Belli, Fevzi, Bonin, Hinrich E. and Bonin, Hinrich E.. \"Vorwort der Herausgeber\". Software-Konstruktion mit LISP, Berlin, Boston: De Gruyter, 2019, pp. V-VI. https://doi.org/10.1515/9783110852769-001 Belli, F., Bonin, H. & Bonin, H. (2019). Vorwort der Herausgeber. In Software-Konstruktion mit LISP (pp. V-VI). Berlin, : De :\u2026", "num_citations": "1\n", "authors": ["476"]}
{"title": "Karar tablosu destekli olay s\u0131ra \u00e7izgeleri temelli s\u0131nama durum \u00fcretim arac\u0131\n", "abstract": " Model temelli s\u0131nama alan\u0131nda otomatik s\u0131nama durum \u00fcretimi \u00f6nemli konular\u0131n ba\u015f\u0131nda gelir. Otomatik s\u0131nama durum \u00fcretimi i\u00e7in formel bir modelleme y\u00f6ntemi ile \u00fcretim i\u00e7in algoritmalar gereklidir. Bu bildirinin ilk yazar\u0131n\u0131n geli\u015ftirdi\u011fi Olay S\u0131ra \u00c7izgeleri (\u0130ng. Event Sequence Graphs) formel modelleme y\u00f6ntemi ve s\u0131nama durum \u00fcretim algoritmalar\u0131, bu bildirinin di\u011fer yazarlar\u0131 taraf\u0131ndan karar tablolar\u0131 destekli \u015fekilde geni\u015fletilmi\u015ftir. Ortaya konan modelleme y\u00f6ntemi ve algoritmalar kodlanarak bir s\u0131nama durum \u00fcretim arac\u0131 2008 y\u0131l\u0131ndan beri geli\u015ftirilmektedir. An\u0131lan ara\u00e7 bir\u00e7ok \u00e7al\u0131\u015fmada kullan\u0131lm\u0131\u015f ve bu \u00e7al\u0131\u015fmalar\u0131n anlat\u0131ld\u0131\u011f\u0131 yay\u0131nlarda bu ara\u00e7tan s\u00f6z edilmi\u015ftir. Bu bildiride karar tablolar\u0131 destekli olay s\u0131ra \u00e7izgeleri temelli s\u0131nama durum arac\u0131n\u0131n son durumu tan\u0131t\u0131lm\u0131\u015f ve an\u0131lan ara\u00e7 ile bir \u00f6rnek \u00e7al\u0131\u015fma sergilenmi\u015ftir.", "num_citations": "1\n", "authors": ["476"]}
{"title": "Assuring dependability of software reuse: An industrial standard\n", "abstract": " Whereas a software component may be perfectly suited to one application, it may prove to cause severe faults in other applications. The pre-standard IEC/PAS 62814 (Dependability of Software Products Containing Reusable Components \u2013 Guidance for Functionality and Tests), which has recently been released, addresses the functionality, testing, and dependability of software components to be reused and products that contain software to be used in more than one application; that is, reused by the same or by another development organization, regardless of whether it belongs to the same or another legal entity than the one that has developed this software. This paper introduces into this pre-standard and give hints how to use it. The author, who chaired its realization that started in 2006, briefly summarizes the difficult process to bring the industrial partners with controversial interests to a consensus.", "num_citations": "1\n", "authors": ["476"]}
{"title": "Olay Tabanl\u0131 S\u0131nama \u0130\u00e7in Mutant Se\u00e7imi.\n", "abstract": " Model tabanl\u0131 s\u0131nama, s\u0131nama \u00f6rne\u011fi \u00fcretimi i\u00e7in bi\u00e7imsel modeller kullanmay\u0131 i\u00e7erir. Bu bildiri olay tabanl\u0131 modelleme i\u00e7in d\u00fczenli gramerleri \u00f6nermektedir. \u00d6nerilen modeli de\u011fi\u015fikiklere u\u011fratmak i\u00e7in tan\u0131mlanan mutasyon i\u015fle\u00e7leri sistematik olarak hata modelleri ya da mutantlar\u0131n \u00fcretilmesinde kullan\u0131lmaktad\u0131r. As\u0131l sistem modeliyle mutantlar \u00fczerinde uygulanan algoritmalar ile s\u0131nama \u00f6rnekleri \u00fcretilmektedir. Mevcut y\u00f6ntemler birer olaya odaklan\u0131rken bu bildirideki yakla\u015f\u0131m k\u2265 1 uzunlu\u011fundaki olay ard\u0131\u015f\u0131mlar\u0131na (k-ard\u0131\u015f\u0131mlar\u0131na) odaklanmakta ve a\u015famal\u0131 olarak farkl\u0131 hatalar\u0131n modellenmesini sa\u011flamaktad\u0131r. Yakla\u015f\u0131m ayr\u0131ca mutasyon tabanl\u0131 s\u0131namada kar\u015f\u0131la\u015f\u0131lan \u015fimdiye kadar \u00e7\u00f6z\u00fclmemi\u015f \u015fu sorunlar ile de ba\u015fa \u00e7\u0131kmaktad\u0131r:(i) As\u0131l modele denk mutantlar\u0131n ve (ii) ayn\u0131 hatay\u0131 modelleyen birden fazla mutant\u0131n ortadan kald\u0131r\u0131lmas\u0131. Bu t\u00fcr mutantlar kaynaklar\u0131n israf\u0131na ve s\u0131nama s\u00fcrecinde verim kayb\u0131na yol a\u00e7maktad\u0131r. \u00d6nerilen yakla\u015f\u0131m \u00e7er\u00e7evesinde s\u00f6z konusu mutantlar\u0131n \u00fcretilmeye bile gereksinim duyulmadan d\u0131\u015flanmas\u0131 i\u00e7in mutant se\u00e7me taktikleri geli\u015ftirilmektedir. Ayr\u0131ca, yakla\u015f\u0131m\u0131n bir \u00f6rnek \u00e7al\u0131\u015fma \u00fczerinde varolan olay ard\u0131\u015f\u0131m \u00e7izgeleri tabanl\u0131 yakla\u015f\u0131mla k\u0131yaslanarak ge\u00e7erlili\u011fi g\u00f6sterilmektedir.", "num_citations": "1\n", "authors": ["476"]}
{"title": "Fehlertolerierende Rechensysteme/Fault-Tolerant Computing Systems: 3. Internationale GI/ITG/GMA-Fachtagung/3rd International GI/ITG/GMA Conference Bremerhaven, 9.\u201311. September\u00a0\u2026\n", "abstract": " Dieser Band enth\u00e4lt die 38 Beitr\u00e4ge der 3. GI/ITG/GMA-Fachtagung \u00fcber\" Fehlertolerierende Rechensysteme\". Unter den 10 aus dem Ausland eingegangenen Beitr\u00e4gen sind 4 eingeladene Vortr\u00e4ge. Insgesamt dokumentiert dieser Tagungsband die Entwicklung der Konzeption und Implementierung fehlertoleranter Systeme in den letzten drei Jahren vor allem in Europa. S\u00e4mtliche Beitr\u00e4ge sind neue Forschungs-oder Entwicklungsergebnisse, die vom Programmausschu\u20ac der Tagung aus 70 eingereichten Beitr\u00e4gen ausgew\u00e4hlt wurden.", "num_citations": "1\n", "authors": ["476"]}
{"title": "PRIORITIZING COVERAGE-ORIENTED TESTING PROCESS\u2014AN ADAPTIVE-LEARNING-BASED APPROACH AND CASE STUDY\n", "abstract": " This chapter proposes a graph-model-based approach to prioritizing the test process. Tests are ranked according to their preference degrees which are determined indirectly, i.e., through classifying the events. For construction of the groups of events, an unsupervised neural network is trained by adaptive competitive learning algorithm. A casestudy demonstrates and validates the approach.", "num_citations": "1\n", "authors": ["476"]}
{"title": "Ereignisbasiertes Testen eingebetteter Systeme\u2013Vergleich mit Klassifikationsb\u00e4umen anhand eines automotiven Beispiels\n", "abstract": " Mechanische Steuerkomponenten, wie die in modernen Automobilen, werden mehr und mehr durch elektronische verdr\u00e4ngt. Diese sind meistens mit einem Steuerger\u00e4t gekoppelt. Um die Funktionsf\u00e4higkeit dieser Steuerger\u00e4te zu gew\u00e4hrleisten, ist ein systematisches Testen notwendig. Die Automatisierung der Tests soll nicht nur die Qualit\u00e4t steigern, sondern auch die Effizienz erh\u00f6hen, um die Kosten zu reduzieren. W\u00e4hrend die eigentliche Durchf\u00fchrung der Tests mittlerweile einen hohen Automatisierungs grad erreicht hat, werden die Testf\u00e4lle oft manuell erstellt. Dieser Beitrag beschreibt den Einsatz von Ereignis-Sequenz-Graphen, die aus einer formalen Beschreibung eines Steuerger\u00e4tes die Erzeugung von Testf\u00e4llen erm\u00f6glichen. Diese Methode wird mit der Klassifikationsbaummethode anhand einer Fallstudie verglichen.Effizienz der aufgestellten Testschritte undf\u00e4lle h\u00e4ngen stark von der Erfahrung des Testingenieurs ab. Sie sollte eher dazu benutzt werden, um die nach systematischen Methoden aufgestellten Testf\u00e4lle sinnvoll zu erg\u00e4nzen. Zudem wird das Aufstellen von Negativ-Testf\u00e4llen meistens vernachl\u00e4ssigt, da die Anforderungen in der Regel nur positiv formuliert sind. Ebenfalls weit verbreitet ist die Klassifikationsbaummethode. Sie erm\u00f6glicht \u00fcber eine Klassifizierung aller Aspekte des Testobjekts die Komplexit\u00e4t zu reduzieren. Die Grundlage f\u00fcr diese Methode bildet die", "num_citations": "1\n", "authors": ["476"]}
{"title": "Ereignisorientiertes Testen Web\u00fcbasierter Systeme \u00fc Verfeinerung des holistischen Ansatzes und eine Fallstudie\n", "abstract": " Auf der Grundlage eines ereignisbasierten Ansatzes zum Test von Web\u00fcbasierten Systemen verfeinert dieser Beitrag die Beschreibung von Eingabedaten und modelliert charakteristische Merkmale von Eingaben anhand von Eingabeformularen. Eine Fallstudie validiert den vorgestellten Testansatz unter Ber\u00fccksichtigung von ung\u00fcltigen Eingabedaten.", "num_citations": "1\n", "authors": ["476"]}
{"title": "Goal-driven, scalable generation of complete interaction sequences for testing graphical user interfaces\n", "abstract": " Short Paper; Topics: Verification/Validation, Planning", "num_citations": "1\n", "authors": ["476"]}
{"title": "Industrial and engineering applications of artificial intelligence and expert systems\n", "abstract": " This work is subjeet to copyright. Ali rights are reserved, whether the who1c or part of the material is concerned, specifically the rights of translation, reprinting, re-use of illustrations, recitation, broadeasting, reproduction on microfilms or in any other way, and storage in data hanks. Duplication of this publication or parts thereof is pennitted only under the provisions or the German Copyright Law of September 9, 1965, in its current version, and permission for use must always be obtained from Springer-Verlag. Violations are li able for prosccution under the German Copyright Law.", "num_citations": "1\n", "authors": ["476"]}
{"title": "A built-in test language for PROLOG to validate knowledge-based systems\n", "abstract": " This paper refines and completes the results of our previous work represented in/3/. Our present work concentrates on the implementation of a uniform, white-box test environment PROTest (PROLOG Test Environment). PROTest supports the development of object-oriented, rule and knowledge-based expert systems which will be implemented in PROLOG. PROTest assists the programmer-as well as the quality engineer-in particular to generate test cases, to exercise his or her programs by means of these test cases, to produce test reports after the test execution etc (Testing in the Large).", "num_citations": "1\n", "authors": ["476"]}
{"title": "Towards reliability optimization of fault-tolerant software\n", "abstract": " The paper surveys and classifies probabilistic models for the reliability prediction of computer programs. The controversial discussion about the pros and cons of the software reliability modelling will be sketched. An approach to the optimization of the software reliability achieved by the resources applied (as to amount and quality of programming efforts, development and operatiOn environment, and redundancy to achieve faulttolerence} is given. The results will be applied to determine the structure of software to be developed. The approach will be illustrated by simple examples.", "num_citations": "1\n", "authors": ["476"]}
{"title": "PROLOG-Systeme in der Praxis\n", "abstract": " PROLOG-Systeme in der Praxis Page 1 PROLOG-Systeme in der Praxis \u00dcberblick mit Anwendungsbeispielen inTurbo-PROLOG und anderen PROLOG-Systemen von Prof. Dr.-Ing. Fevzi Belli Hochschule Bremerhaven unter Mitarbeit von Alfred Schmidt Hochschule Bremerhaven Wissenschaftsverlag Mannheim/Wien/Z\u00fcrich Page 2 12 Inhaltsverzeichnis Vorwort 5 Vorbemerkungen 7 1. Einleitung: Entstehung und Besonderheiten von PROLOG 15 1.1 Geschichte von PROLOG 15 1.2 Bestandteile eines PROLOG-Programms ... 16 1.2.1 Ein typisches PROLOG-Programm besteht aus: 18 1.2.2 Typischer Mensch-/Maschine-Dialog bei PROLOG-Programmen 19 1.2.3 Abfragen an die Wissensbasis 20 1.2.4 Variablen 21 1.2.5 Konjunktion bei Abfragen 2 3 2. Verschiedene Dialekte und Quasi-Norm der PROLOG 24 2.1 \"Edinburgh\"-Syntax: Quasi-Norm 24 2.1.1 Terme 26 2.1.1.1 Konstante 26 2.1.1.2 Variablen 28 \u2026", "num_citations": "1\n", "authors": ["476"]}
{"title": "Fault-tolerant programs\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "1\n", "authors": ["476"]}
{"title": "Ein B\u00fcndel heuristischer Methoden zur Kostenoptimalen Bestimmung und Sicherung von Software-Zuverl\u00e4ssigkeit\n", "abstract": " Ausgehend von den Methoden der konventionellen Qualit\u00e4tssicherung und den vorhandenen Techniken des Software-Engineering wird in dieser Arbeit ein Ansatz vorgestellt, welcher die Zuverl\u00e4ssigkeit von Software-Produkten unter Ber\u00fccksichtigung der Wirtschaftlicheitsaspekte bestimmt und sichert. Die Komponenten der Methode sind: Pr\u00fcfen des Software-Produktes, Bestimmung der Zuverl\u00e4ssigkeit (Messen) und Optimierung dieser Pr\u00fcf- und Me\u00df-Prozedur im Hinblick auf ihre Kosten und Nutzen.", "num_citations": "1\n", "authors": ["476"]}
{"title": "CADAS: A Tool for Rapid Prototyping and Testing of Embedded Software\n", "abstract": " The development of embedded software systems has todate been problematic and subject to high costs due to the lack of non-project specific tools which support the development of such systems over all life cycle phases, from requirement validation through to\" in-service\" support. In order that prototyping may be carried out in a cost effective manner, all interested parties ought to be in the position to define and evaluate the possible solutions in a dynamic closed loop user friendly manner. In an attempt to meet the above requirements, and to provide a flexible framework for future needs, a design has been conceived and is being realised through the development of CADAS. cised on the target software. ESG in 1980, faced with the joint problems of rising software development costs and the need to quickly, effectively evaluate\" in-service\" system refits undertook a review of present tools and methodologies used in the development and support of such systems. With the growing interest in fault tolerant systems (2) and in particular the topic of exception handling (3) the importance and problems associated with prototyping were acknowledged as taking on a new importance. In addition, the then available validation and verification tools were not only project specific, but also life cycle phase specific, focusing mainly on the detail design phase. An analysis of the problems associated with both topics, prototyping and the verification and validation of real time closed loop systems, underlined the need for a tool which fully supported both activities. An important product of such a common tool would be the provision of full traceability on a comparable\u00a0\u2026", "num_citations": "1\n", "authors": ["476"]}