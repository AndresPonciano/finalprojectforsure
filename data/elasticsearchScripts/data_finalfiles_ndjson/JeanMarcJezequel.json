{"title": "Making components contract aware\n", "abstract": " Components have long promised to encapsulate data and programs into a box that operates predictably without requiring that users know the specifics of how it does so. Many advocates have predicted that components will bring about widespread software reuse, spawning a market for components usable with such mainstream software buses as the Common Object Request Broker Architecture (CORBA) and the Distributed Component Object Model (DCOM). In the Windows world, at least, this prediction is becoming a reality. Yet recent reports indicate mixed results when using and reusing components in mission-critical settings. Such results raise disturbing questions. How can you trust a component? What if the component behaves unexpectedly, either because it is faulty or simply because you misused it? Before we can trust a component in mission-critical applications, we must be able to determine, reliably\u00a0\u2026", "num_citations": "896\n", "authors": ["540"]}
{"title": "Weaving executability into object-oriented meta-languages\n", "abstract": " Nowadays, object-oriented meta-languages such as MOF (Meta-Object Facility) are increasingly used to specify domain-specific languages in the model-driven engineering community. However, these meta-languages focus on structural specifications and have no built-in support for specifications of operational semantics. In this paper we explore the idea of using aspect-oriented modeling to add precise action specifications with static type checking and genericity at the meta level, and examine related issues and possible solutions. We believe that such a combination would bring significant benefits to the community, such as the specification, simulation and testing of operational semantics of metamodels. We present requirements for such statically-typed meta-languages and rationales for the aforementioned benefits.", "num_citations": "672\n", "authors": ["540"]}
{"title": "Models@ run. time to support dynamic adaptation\n", "abstract": " Today's society increasingly depends on software systems deployed in large companies, banks, airports, and so on. These systems must be available 24/7 and continuously adapt to varying environmental conditions and requirements. Such dynamically adaptive systems exhibit degrees of variability that depend on user needs and runtime fluctuations in their contexts. The paper presents an approach for specifying and executing dynamically adaptive software systems that combines model-driven and aspect-oriented techniques to help engineers tame the complexity of such systems while offering a high degree of automation and validation.", "num_citations": "510\n", "authors": ["540"]}
{"title": "Design by contract: The lessons of Ariane\n", "abstract": " Design by contract is the principle that the interfaces between modules of a software system-especially a mission-critical one-should be governed by precise specifications. The contracts cover mutual obligations (pre-conditions), benefits (post-conditions), and consistency constraints (invariants). Together, these properties are known as assertions, and are directly supported in some design and programming languages. A recent $500 million software error provides a sobering reminder that this principle is not just a pleasant academic ideal. On June 4, 1996, the maiden flight of the European Ariane 5 launcher crashed, about 40 seconds after takeoff. The rocket was uninsured. The French space agency, CNES (Centre National d'Etudes Spatiales), and the European Space Agency (ESA) immediately appointed an international inquiry board. The board makes several recommendations with respect to software\u00a0\u2026", "num_citations": "386\n", "authors": ["540"]}
{"title": "Taming dynamically adaptive systems using models and aspects\n", "abstract": " Since software systems need to be continuously available under varying conditions, their ability to evolve at runtime is increasingly seen as one key issue. Modern programming frameworks already provide support for dynamic adaptations. However the high-variability of features in Dynamic Adaptive Systems (DAS) introduces an explosion of possible runtime system configurations (often called modes) and mode transitions. Designing these configurations and their transitions is tedious and error-prone, making the system feature evolution difficult. While Aspect-Oriented Modeling (AOM) was introduced to improve the modularity of software, this paper presents how an AOM approach can be used to tame the combinatorial explosion of DAS modes. Using AOM techniques, we derive a wide range of modes by weaving aspects into an explicit model reflecting the runtime system. We use these generated modes to\u00a0\u2026", "num_citations": "296\n", "authors": ["540"]}
{"title": "On model typing\n", "abstract": " Where object-oriented languages deal with objects as described by classes, model-driven development uses models, as graphs of interconnected objects, described by metamodels. A number of new languages have been and continue to be developed for this model-based paradigm, both for model transformation and for general programming using models. Many of these use single-object approaches to typing, derived from solutions found in object-oriented systems, while others use metamodels as model types, but without a clear notion of polymorphism. Both of these approaches lead to brittle and overly restrictive reuse characteristics. In this paper we propose a simple extension to object-oriented typing to better cater for a model-oriented context, including a simple strategy for typing models as a collection of interconnected objects. We suggest extensions to existing type system formalisms to support\u00a0\u2026", "num_citations": "178\n", "authors": ["540"]}
{"title": "UMLAUT: an extendible UML transformation framework\n", "abstract": " Advanced users often find themselves restricted by the limited facilities of most UML CASE tools when they want to do complex manipulations of UML models, e.g., apply design patterns, generate code for simulation and validation etc. We describe UMLAUT, a freely available UML transformation framework for manipulating UML models. These manipulations are expressed as algebraic compositions of reified elementary transformations. They are thus open to extensions through inheritance and aggregation. To illustrate the interest of our approach, we show how the model of a UML distributed application can be automatically transformed into a labeled transition system validated using advanced protocol validation technology.", "num_citations": "174\n", "authors": ["540"]}
{"title": "Precise modeling of design patterns\n", "abstract": " Design Patterns are now widely accepted as a useful concept for guiding and documenting the design of object-oriented software systems. Still the UML is ill-equipped for precisely representing design patterns. It is true that some graphical annotations related to parameterized collaborations can be drawn on a UML model, but even the most classical GoF patterns, such as Observer, Composite or Visitor cannot be modeled precisely this way. We thus propose a minimal set of modifications to the UML 1.3 meta-model to make it possible to model design patterns and represent their occurrences in UML, opening the way for some automatic processing of pattern applications within CASE tools. We illustrate our proposal by showing how the Visitor and Observer patterns can be precisely modeled and combined together using our UMLAUT tool. We conclude on the generality of our approach, as well as its\u00a0\u2026", "num_citations": "168\n", "authors": ["540"]}
{"title": "An aspect-oriented and model-driven approach for managing dynamic variability\n", "abstract": " Constructing and executing distributed systems that can adapt to their operating context in order to sustain provided services and the service qualities are complex tasks. Managing adaptation of multiple, interacting services is particularly difficult since these services tend to be distributed across the system, interdependent and sometimes tangled with other services. Furthermore, the exponential growth of the number of potential system configurations derived from the variabilities of each service need to be handled. Current practices of writing low-level reconfiguration scripts as part of the system code to handle run time adaptation are both error prone and time consuming and make adaptive systems difficult to validate and evolve. In this paper, we propose to combine model driven and aspect oriented techniques to better cope with the complexities of adaptive systems construction and execution, and to\u00a0\u2026", "num_citations": "152\n", "authors": ["540"]}
{"title": "Design patterns application in UML\n", "abstract": " The Unified Modeling Language (UML) currently proposes a mechanism to model recurrent design structures: the parameterized collaborations. The main goal of this mechanism is to model the structure of Design Patterns. This is an interesting feature because it can help designers to point out pattern application without spending time with intricate design details. Moreover, it can also help designers to better document their systems and to manage their own design pattern library, which could be used in different systems or projects. However, from a tool perspective, the semantics associated to parameterized collaborations is still vague. To put it more precisely, the underlying representation of a design pattern and of its application, and the binding between these two levels is not exactly defined, and therefore, can be interpreted in different ways. This article has two purposes. First, we point out ambiguities\u00a0\u2026", "num_citations": "142\n", "authors": ["540"]}
{"title": "Design patterns and contracts\n", "abstract": " Design Patterns and Contracts \u2014 Monash University Skip to main navigation Skip to search Skip to main content Monash University Logo Help & FAQ Home Profiles Research Units Equipment Projects Research Output Prizes Activities Press / Media Design Patterns and Contracts Jean-Marc Jezequel, Michel Train, Christine Mingins Research output: Book/Report \u203a Book \u203a Research \u203a peer-review Overview Original language English Place of Publication Massachusetts USA Publisher Addison-Wesley Professional Number of pages 348 ISBN (Print) 0201309599 Publication status Published - 2000 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Jezequel, JM., Train, M., & Mingins, C. (2000). Design Patterns and Contracts. Addison-Wesley Professional. Jezequel, Jean-Marc ; Train, Michel ; Mingins, Christine. / Design Patterns and Contracts. Massachusetts USA : Addison-Wesley Professional, 2000. \u2026", "num_citations": "129\n", "authors": ["540"]}
{"title": "A dynamic component model for cyber physical systems\n", "abstract": " Cyber Physical Systems (CPS) offer new ways for people to interact with computing systems: every thing now inte-grates computing power that can be leveraged to provide safety, assistance, guidance or simply comfort to users. CPS are long living and pervasive systems that intensively rely on microcontrollers and low power CPUs, integrated into build-ings (eg automation to improve comfort and energy opti-mization) or cars (eg advanced safety features involving car-to-car communication to avoid collisions). CPS operate in volatile environments where nodes should cooperate in opportunistic ways and dynamically adapt to their context. This paper presents \u00bc-Kevoree, the projection of Kevoree (a component model based on [email protected]) to microcon-trollers. \u00bc-Kevoree pushes dynamicity and elasticity con-cerns directly into resource-constrained devices. Its evalua-tion regarding key criteria in the embedded\u00a0\u2026", "num_citations": "111\n", "authors": ["540"]}
{"title": "Model driven language engineering with kermeta\n", "abstract": " In many domains such as telecom, aerospace and automotive industries, engineers rely on Domain Specific Modeling Languages (DSML) to solve the complex issues of engineering safety critical software. Traditional Language Engineering starts with the grammar of a language to produce a variety of tools for processing programs expressed in this language. Recently however, many new languages tend to be first defined through metamodels, i.e. models describing their abstract syntax. Relying on well tooled standards such as E-MOF, this approach makes it possible to readily benefit from a set of tools such as reflexive editors, or XML serialization of models. This article aims at showing how Model Driven Engineering can easily complement these off-the-shelf tools to obtain a complete environment for such a language, including interpreter, compiler, pretty-printer and customizable editors. We illustrate the\u00a0\u2026", "num_citations": "106\n", "authors": ["540"]}
{"title": "Modeling and validating dynamic adaptation\n", "abstract": " This paper discusses preliminary work on modeling and validation dynamic adaptation. The proposed approach is on the use of aspect-oriented modeling (AOM) and models at runtime. Our approach covers design and runtime phases. At design-time, a base model and different variant architecture models are designed and the adaptation model is built. Crucially, the adaptation model includes invariant properties and constraints that allow the validation of the adaptation rules before execution. During runtime, the adaptation model is processed to produce a correct system configuration that can be executed.", "num_citations": "105\n", "authors": ["540"]}
{"title": "Melange: A meta-language for modular and reusable development of dsls\n", "abstract": " Domain-Specific Languages (DSLs) are now developed for a wide variety of domains to address specific concerns in the development of complex systems. When engineering new DSLs, it is likely that previous efforts spent on the development of other languages could be leveraged, especially when their domains overlap. However, legacy DSLs may not fit exactly the end user requirements and thus require further extension, restriction, or specialization. While current language workbenches provide import mechanisms, they usually lack an explicit support for such customizations of imported artifacts. In this paper, we propose an approach for building DSLs by safely assembling and customizing legacy DSLs artifacts. This approach is based on typing relations that provide a reasoning layer for manipulating DSLs while ensuring type safety. On top of this reasoning layer, we provide an algebra of operators for\u00a0\u2026", "num_citations": "101\n", "authors": ["540"]}
{"title": "A toolkit for weaving aspect oriented UML designs\n", "abstract": " Separation of concerns is a basic engineering principle that is also at the core of object-oriented analysis and design methods in the context of the Unified Modeling Language (UML). The UML gives the designer a rich, but somehow disorganized, set of views on her model as well as many features, such as design pattern occurrences, stereotypes or tag values, allowing her to add non-functional information to a model. Aspect-oriented concepts are applied to manage the multitude of design constraints. However, it can then be an overwhelming task to reconcile the various aspects of a model into a working implementation. In this paper, we present our UMLAUT framework as a toolkit for easily building application specific\" weavers\" for generating detailed design models from high level, aspect oriented UML models. This is illustrated with a toy example of a distributed multimedia application with a weaving generating\u00a0\u2026", "num_citations": "101\n", "authors": ["540"]}
{"title": "Model driven design and aspect weaving\n", "abstract": " A model is a simplified representation of an aspect of the world for a specific purpose. In complex systems, many aspects are to be handled, from architectural aspects to dynamic behavior, functionalities, user-interface, and extra-functional concerns (such as security, reliability, timeliness, etc.). For software systems, the design process can then be characterized as the weaving of all these aspects into a detailed design model. Model Driven Design aims at automating this weaving process, that is automatically deriving software systems from theirs models. This paper explores the relationship between modeling and aspect weaving. It points out some of the challenges related to such automatic model weaving, illustrating them with the example of a weaving process for behavioral models represented as scenarios.", "num_citations": "93\n", "authors": ["540"]}
{"title": "Using UML action semantics for executable modeling and beyond\n", "abstract": " The UMLlac ks precise and formal foundations for several constructs such as transition guards or method bodies, for which it resorts to semantic loopholes in the form of \u201cuninterpreted\u201d expressions. The Action Semantics proposal aims at filling this gap by providing both a metamodel integrated into the UML metamodel, and a model of execution for these statements. As a future OMG standard, the Action Semantics eases the move to tool interoperability, and allows for executable modeling and simulation. We explore in this paper a specificity of the Action Semantics: its applicability to the UML metamodel, itself a UML model. We show how this approach paves the way for powerful metaprogramming capabilities such as refactoring, aspect weaving, application of design patterns or round-trip engineering. Furthermore, the overhead for designers is minimal, as mappings from usual objectoriented languages to\u00a0\u2026", "num_citations": "89\n", "authors": ["540"]}
{"title": "Model-driven analysis and synthesis of concrete syntax\n", "abstract": " Metamodeling is raising more and more interest in the field of language engineering. While this approach is now well understood for defining abstract syntaxes, formally defining concrete syntaxes with metamodels is still a challenge. Concrete syntaxes are traditionally expressed with rules, conforming to EBNF-like grammars, which can be processed by compiler compilers to generate parsers. Unfortunately, these generated parsers produce concrete syntax trees, leaving a gap with the abstract syntax defined by metamodels, and further ad-hoc hand-coding is required. In this paper we propose a new kind of specification for concrete syntaxes, which takes advantage of metamodels to generate fully operational tools (such as parsers or text generators). The principle is to map abstract syntaxes to concrete syntaxes via bidirectional mapping-models with support for both model-to-text, and text-to-model\u00a0\u2026", "num_citations": "84\n", "authors": ["540"]}
{"title": "Mashup of metalanguages and its implementation in the kermeta language workbench\n", "abstract": " With the growing use of domain-specific languages (DSL) in industry, DSL design and implementation goes far beyond an activity for a few experts only and becomes a challenging task for thousands of software engineers. DSL implementation indeed requires engineers to care for various concerns, from abstract syntax, static semantics, behavioral semantics, to extra-functional issues such as runtime performance. This paper presents an approach that uses one metalanguage per language implementation concern. We show that the usage and combination of those metalanguages is simple and intuitive enough to deserve the term mashup. We evaluate the approach by completely implementing the non-trivial fUML modeling language, a semantically sound and executable subset of the Unified Modeling Language (UML).", "num_citations": "83\n", "authors": ["540"]}
{"title": "On model subtyping\n", "abstract": " Various approaches have recently been proposed to ease the manipulation of models for specific purposes (e.g., automatic model adaptation or reuse of model transformations). Such approaches raise the need for a unified theory that would ease their combination, but would also outline the scope of what can be expected in terms of engineering to put model manipulation into action. In this work, we address this problem from the model substitutability point of view, through model typing. We introduce four mechanisms to achieve model substitutability, each formally defined by a subtyping relation. We then discuss how to declare and check these subtyping relations. This work provides a formal reference specification establishing a family of model-oriented type systems. These type systems enable many facilities that are well known at the programming language level. Such facilities range from abstraction\u00a0\u2026", "num_citations": "78\n", "authors": ["540"]}
{"title": "MTL and Umlaut NG-Engine and framework for model transformation\n", "abstract": " Model Tranformation Language (MTL) is an open-source object- and view-oriented imperative language dedicated to model transformations, developed in the context of the OMG Query/View/Transformation (QVT) proposal. MTL is the stepping stone towards defining a transformation framework that we call Umlaut NG. It enables a variety of advanced model transformations, such as application of design patterns, weaving aspects at design level, synthesis test cases from UML models and derivation of products in product lines.", "num_citations": "78\n", "authors": ["540"]}
{"title": "Code generation from UML models with semantic variation points\n", "abstract": " UML semantic variation points provide intentional degrees of freedom for the interpretation of the metamodel semantics. The interest of semantic variation points is that UML now becomes a family of languages sharing lot of commonalities and some variabilities that one can customize for a given application domain. In this paper, we propose to reify the various semantic variation points of UML 2.0 statecharts into models of their own to avoid hardcoding the semantic choices in the tools. We do the same for various implementation choices. Then, along the line of the OMG\u2019s Model Driven Architecture, these semantic and implementation models are processed along with a source UML model (that can be seen as a PIM) to provide a target UML model (a PSM) where all semantic and implementation choice are made explicit. This target model can in turn serve as a basis for a consistent use of code generation\u00a0\u2026", "num_citations": "76\n", "authors": ["540"]}
{"title": "Ing\u00e9nierie Dirig\u00e9e par les Mod\u00e8les: des concepts \u00e0 la pratique...\n", "abstract": " L'Ing\u00e9nierie Dirig\u00e9e par les Mod\u00e8les (IDM), ou Model Driven Engineering (MDE) en anglais, s'inscrit dans l'\u00e9volution des techniques pour le d\u00e9veloppement de syst\u00e8mes informatiques afin d'en ma\u00eetriser leurs complexit\u00e9s en se concentrant sur une pr\u00e9occupation plus abstraite que la programmation classique. En s'appuyant sur des approches g\u00e9n\u00e9ratives, il s'agit d'engendrer tout ou partie d'une application \u00e0 partir de mod\u00e8les. Un mod\u00e8le est une abstraction, une simplification d'un syst\u00e8me qui est n\u00e9cessaire et suffisante pour comprendre un aspect particulier du syst\u00e8me mod\u00e9lis\u00e9 et r\u00e9pondre aux questions que soul\u00e8ve cet aspect du syst\u00e8me. Un syst\u00e8me peut \u00eatre d\u00e9crit par diff\u00e9rents mod\u00e8les li\u00e9s les uns aux autres, et exprim\u00e9 chacun \u00e0 l'aide d'un langage de mod\u00e9lisation d\u00e9di\u00e9 (Domain Specific Modeling Languages - DSML). Le principe est d'utiliser autant de langages de mod\u00e9lisation diff\u00e9rents que les aspects chronologiques ou technologiques du d\u00e9veloppement du syst\u00e8me le n\u00e9cessitent. L'activit\u00e9 consistant \u00e0 d\u00e9finir ces DSML (la syntaxe et la s\u00e9mantique), appel\u00e9e m\u00e9tamod\u00e9lisation, est donc une probl\u00e9matique cl\u00e9 de l'IDM. En outre, les autres probl\u00e9matiques cl\u00e9s de l'IDM consistent \u00e0 rendre les mod\u00e8les construits op\u00e9rationnels (pour la simulation, la g\u00e9n\u00e9ration de code, de documentation ou de test, la validation, la v\u00e9rification, l'ex\u00e9cution, etc.) \u00e0 l'aide de composition et de transformation de mod\u00e8le. A la fois un cours et un tutoriel, cet ouvrage offre une approche didactique et pragmatique d'apprentissage de l'IDM. Nous pr\u00e9sentons dans la premi\u00e8re partie les principes cl\u00e9s de cette nouvelle ing\u00e9nierie. Nous introduisons une description\u00a0\u2026", "num_citations": "75\n", "authors": ["540"]}
{"title": "An eclipse modelling framework alternative to meet the models@ runtime requirements\n", "abstract": " Models@Runtime aims at taming the complexity of software dynamic adaptation by pushing further the idea of reflection and considering the reflection layer as a first-class modeling space. A natural approach to Models@Runtime is to use MDE techniques, in particular those based on the Eclipse Modeling Framework. EMF provides facilities for building DSLs and tools based on a structured data model, with tight integration with the Eclipse IDE. EMF has rapidly become the defacto standard in the MDE community and has also been adopted for building Models@Runtime platforms. For example, Frascati (implementing the Service Component Architecture standard) uses EMF for the design and runtime tooling of its architecture description language. However, EMF has primarily been thought to support design-time activities. This paper highlights specific Models@Runtime requirements, discusses the benefits\u00a0\u2026", "num_citations": "71\n", "authors": ["540"]}
{"title": "Matching model-snippets\n", "abstract": " An important demand in Model-Driven Development is the simple and efficient expression of model patterns. Current approaches tend to distinguish the language they use to express patterns from the one for modelling. Consequently, productivity is reduced by dealing with a distinct new language, and new intermediate steps are introduced in order to support pattern-matching. In this paper we propose a framework for expressing patterns as model-snippets. We present how model-snippets are specified upon concepts in a given domain (meta-model), and how we perform pattern-matching with model-snippets, whatever the meta-model. We also provide an implementation which is well integrated with existing technologies, such as Eclipse Modelling Framework.", "num_citations": "59\n", "authors": ["540"]}
{"title": "Generic model refactorings\n", "abstract": " Many modeling languages share some common concepts and principles. For example, Java, MOF, and UML share some aspects of the concepts of classes, methods, attributes, and inheritance. However, model transformations such as refactorings specified for a given language cannot be readily reused for another language because their related metamodels may be structurally different. Our aim is to enable a flexible reuse of model transformations across various metamodels. Thus, in this paper, we present an approach allowing the specification of generic model transformations, in particular refactorings, so that they can be applied to different metamodels. Our approach relies on two mechanisms: (1) an adaptation based mainly on the weaving of aspects; (2) the notion of model typing, an extension of object typing in the model-oriented context. We validated our approach by performing some experiments\u00a0\u2026", "num_citations": "54\n", "authors": ["540"]}
{"title": "Using UML action semantics for model execution and transformation\n", "abstract": " The Unified Modelling Language (UML) lacks precise and formal foundations and semantics for several modeling constructs, such as transition guards or method bodies. These semantic discrepancies and loopholes prevent executability, making early testing and validation out of reach of UML tools. Furthermore, the semantic gap from high-level UML concepts to low-level programming constructs found in traditional object-oriented language prevents the development of efficient code generators.The recent Action Semantics (AS) proposal tackles these problems by extending the UML with yet another formalism for describing behavior, but with a strong emphasis on dynamic semantics. This formalism provides both, a metamodel integrated into the UML metamodel, and a model of execution for these statements. As a future OMG standard, the AS eases the move to tool interoperability, and allows for executable\u00a0\u2026", "num_citations": "54\n", "authors": ["540"]}
{"title": "Introducing variability into aspect-oriented modeling approaches\n", "abstract": " As development techniques, paradigms and platforms evolve far more quickly than domain applications, software modernization and migration, is a constant challenge to software engineers. For more than ten years now, the Sodifrance company has been intensively using Model-Driven Engineering (MDE) for both development and migration projects. In this paper we report on the use of MDE as an efficient, flexible and reliable approach for a migration process (reverse-engineering, transformation and code generation). Moreover, we discuss how MDE is economically profitable and is cost-effective over the migration through out-sourced manual re-development. The paper is illustrated with the migration of a large-scale banking system from Mainframe to J2EE.", "num_citations": "51\n", "authors": ["540"]}
{"title": "An architecture and a process for implementing distributed collaborations\n", "abstract": " Collaborations (between objects) are increasingly being recognized as fundamental building blocks to structure object-oriented design, and they have made their way into UML. But very often the first class aspect of a design level collaboration is lost during the detailed design process, making it difficult to keep good traceability between the design and the implementation. The problem is not simple, because for any given collaboration abstraction, there might be several possible design solutions depending on the many non-functional forces impacting a given application. We propose a process and an architecture in which the notion of collaboration is preserved from analysis to design and implementation, while allowing the designer to change his mind about which particular design trade-off is selected in order to face changing non-functional requirements during maintenance. We illustrate our approach with a case\u00a0\u2026", "num_citations": "49\n", "authors": ["540"]}
{"title": "A reference architecture and roadmap for models@ run. time systems\n", "abstract": " The key property of models@run.time systems is their use and provision of manageable reflection, which is characterized to be tractable and predictable and by this overcomes the limitation of reflective systems working on code, which face the problem of undecidability due to Turing-completeness. To achieve tractability, they abstract from certain aspects of their code, maintaining runtime models of themselves, which form the basis for reflection. In these systems, models form abstractions that neglect unnecessary details from the code, details which are not pertinent to the current purpose of reflection. Thus, models@run.time systems are a new class of reflective systems, which are characterized by their tractability, due to abstraction, and their ability to predict certain aspects of their own behavior for the future. This chapter outlines a reference architecture for models@run.time systems with the appropriate\u00a0\u2026", "num_citations": "47\n", "authors": ["540"]}
{"title": "Combining aspect-oriented modeling with property-based reasoning to improve user interface adaptation\n", "abstract": " User interface adaptations can be performed at runtime to dynamically reflect any change of context. Complex user interfaces and contexts can lead to the combinatorial explosion of the number of possible adaptations. Thus, dynamic adaptations come across the issue of adapting user interfaces in a reasonable time-slot with limited resources. In this paper, we propose to combine aspect-oriented modeling with property-based reasoning to tame complex and dynamic user interfaces. At runtime and in a limited time-slot, this combination enables efficient reasoning on the current context and on the available user interface components to provide a well suited adaptation. The proposed approach has been evaluated through EnTiMid, a middleware for home automation.", "num_citations": "47\n", "authors": ["540"]}
{"title": "Object-oriented software engineering with Eiffel\n", "abstract": " Object-oriented programming and the Eiffel language are described in this book, and their unique features are related to the field of software engineering. Chapter 1 is an overview. Chapters 2 through 5 describe Eiffel in the context of its approach to object orientation. Finally, chapters 6 through 9 cover building software systems with Eiffel. The book starts at too basic a level for a text whose title refers to software engineering of any kind. Most software engineering courses take for granted that the reader is already a competent programmer in the language used for the exposition; nowadays, prior exposure to object orientation would normally be assumed. This is not to criticize the book, only the title. The first section on Eiffel and object orientation is quite good, covers most of the important issues, and develops the topic in an intelligent and easily assimilated order. The discussion of system testing is particularly good\u00a0\u2026", "num_citations": "47\n", "authors": ["540"]}
{"title": "Extra-functional contract support in components\n", "abstract": " According to Szyperski, \u201ca software component is a unit of composition with contractually specified interfaces and explicit context dependencies only\u201d. But it is well known that these contractually specified interfaces should go well beyond mere syntactic aspects: they should also involve functional, synchronization and Quality of Service (QoS) aspects. In large, mission-critical component based systems, it is also particularly important to be able to explicitly relate the QoS contracts attached to provided interfaces with the QoS contracts obtained from required interfaces. In this paper we propose a language called QoSCL (defined as an add-on to the UML2.0 component model) to let the designer explicitly describe and manipulate these higher level contracts and their dependencies. We show how the very same QoSCL contracts can then be exploited for (1) validation of individual components, by automatically\u00a0\u2026", "num_citations": "45\n", "authors": ["540"]}
{"title": "Dissemination of reconfiguration policies on mesh networks\n", "abstract": " Component-based platforms are widely used to develop and deploy distributed pervasive system that exhibit a high degree of dynamicity, concurrency, distribution, heterogeneity, and volatility. This paper deals with the problem of ensuring safe yet efficient dynamic adaptation in a distributed and volatile environment. Most current platforms provide capabilities for dynamic local adaptation to adapt these systems to their evolving execution context, but are still limited in their ability to handle distributed adaptations. Thus, a remaining challenge is to safely propagate reconfiguration policies of component-based systems to ensure consistency of the architecture configuration models over a dynamic and distributed system. In this paper we implement a specific algorithm relying on the models at runtime paradigm to manage platform independent models of the current system architecture and its deployed\u00a0\u2026", "num_citations": "44\n", "authors": ["540"]}
{"title": "Combining aspect and model-driven engineering approaches for software process modeling and execution\n", "abstract": " One major advantage of executable software process models is that once defined, they can be simulated, checked and validated in short incremental and iterative cycles. This also makes them a powerful asset for important process improvement decisions such as resource allocation, deadlock identification and process management. In this paper, we propose a framework that combines Aspect and Model-Driven Engineering approaches in order to ensure process modeling, simulation and execution. This framework is based upon UML4SPM, a UML2.0-based language for Software Process Modeling and Kermeta, an executable metaprogramming language.", "num_citations": "41\n", "authors": ["540"]}
{"title": "Using mde to build a schizophrenic middleware for home/building automation\n", "abstract": " In the personal or corporate spheres, the home/office of tomorrow is soon to be the home/office of today, with a plethora of networked devices embedded in appliances, such as mobile phones, televisions, thermostats, and lamps, making it possible to automate and remotely control many basic household functions with a high degree of accuracy. In this domain, technological standardization is still in its infancy, or remains fragmented. The different functionalities of the various appliances, as well as market factors, imply that the devices that control them communicate via a multitude of different protocols (KNX, LonWorks, InOne). Building a high level middleware to support all the appliances seems to be a reasonable approach. However, market factors has shown that the emergence of a unique and universal middleware is a dream. To solve this issue, we have built a new generation of schizophrenic\u00a0\u2026", "num_citations": "40\n", "authors": ["540"]}
{"title": "Model typing for improving reuse in model-driven engineering\n", "abstract": " Where object-oriented languages deal with objects as described by classes, model-driven development uses models, as graphs of interconnected objects, described by metamodels. A number of new languages have been and continue to be developed for this model-based paradigm, both for model transformation and for general programming using models. Many of these use single-object approaches to typing, derived from solutions found in object-oriented systems, while others use metamodels as model types, but without a clear notion of polymorphism. Both of these approaches lead to brittle and overly restrictive reuse characteristics. In this paper we propose a simple extension to object-oriented typing to better cater for a model-oriented context, including a simple strategy for typing models as a collection of interconnected objects. Using a simple example we show how this extended approach permits\u00a0\u2026", "num_citations": "39\n", "authors": ["540"]}
{"title": "A requirement-centric approach to web service modeling, discovery, and selection\n", "abstract": " Service-Oriented Computing (SOC) has gained considerable popularity for implementing Service-Based Applications (SBAs) in a flexible and effective manner. The basic idea of SOC is to understand users\u2019 requirements for SBAs first, and then discover and select relevant services (i.e., that fit closely functional requirements) and offer a high Quality of Service (QoS). Understanding users\u2019 requirements is already achieved by existing requirement engineering approaches (e.g., TROPOS, KAOS, and MAP) which model SBAs in a requirement-driven manner. However, discovering and selecting relevant and high QoS services are still challenging tasks that require time and effort due to the increasing number of available Web services. In this paper, we propose a requirement-centric approach which allows: (i)\u00a0modeling users\u2019 requirements for SBAs with the MAP formalism and specifying required services\u00a0\u2026", "num_citations": "36\n", "authors": ["540"]}
{"title": "A retrospective on software component quality models\n", "abstract": " The academic and commercial sectors have shown an interest in Component Based Software Development (CBSD) because devel-oping and using various component forms as building blocks can significantly enhance software based system development and use. The perspective of reduced development costs and shorter life-cycles acts as a motivation for this interest. The idea is to create high quality parts and join them together to form a functioning system. One of the most critical processes in CBSD is the selection of appropriate COTS components that meet the user?s require-ments. An important step in the component selection process is the evaluation of components using quality models. Current compo-nent selection approaches try to propose appropriate quality mod-els for the effective assessment of such components. These proposals attempt to define quality characteristics, attributes, and metrics which\u00a0\u2026", "num_citations": "36\n", "authors": ["540"]}
{"title": "Weaving aspect configurations for managing system variability\n", "abstract": " Variability management is a key concern in the software industry. It allows designers to rapidly propose applications that fit the environment and the user needs, with a certain Quality-of-Service level, by choosing adapted variants. While Aspect-Oriented Programming has been introduced for managing variability and complexity at the code level, the Software Product-Line community highlights the needs for variability in the earlier phases of the software lifecycle, where a system is generally described by means of models. In this paper, we propose a generic approach for weaving flexible and reusable aspects at a model level. By extending our generic Aspect-Oriented Modeling approach with variability, we can manage variability and complexity in the early phases of the software lifecycle.", "num_citations": "35\n", "authors": ["540"]}
{"title": "Kevoree Modeling Framework (KMF): Efficient modeling techniques for runtime use\n", "abstract": " The creation of Domain Specific Languages(DSL) counts as one of the main goals in the field of Model-Driven Software Engineering (MDSE). The main purpose of these DSLs is to facilitate the manipulation of domain specific concepts, by providing developers with specific tools for their domain of expertise. A natural approach to create DSLs is to reuse existing modeling standards and tools. In this area, the Eclipse Modeling Framework (EMF) has rapidly become the defacto standard in the MDSE for building Domain Specific Languages (DSL) and tools based on generative techniques. However, the use of EMF generated tools in domains like Internet of Things (IoT), Cloud Computing or Models@Runtime reaches several limitations. In this paper, we identify several properties the generated tools must comply with to be usable in other domains than desktop-based software systems. We then challenge EMF on these properties and describe our approach to overcome the limitations. Our approach, implemented in the Kevoree Modeling Framework (KMF), is finally evaluated according to the identified properties and compared to EMF.", "num_citations": "34\n", "authors": ["540"]}
{"title": "Active operations on collections\n", "abstract": " Collections are omnipresent within models: collections of references can represent relations between objects, and collections of values can represent object attributes. Consequently, manipulating models often consists of performing operations on collections. For example, transformations create target collections from given source collections. Similarly, constraint evaluations perform computation on collections. Recent research works focus on making such transformations or constraint evaluations active (i.e. incremental, or live). However, they propose their own solutions to the issue by the introduction of specific languages and/or systems. This paper proposes a mathematical formalism, centered on collections and independent of languages and systems, that describes how the implementation of standard operations on collections can be made active. The formalism also introduces a reversed active\u00a0\u2026", "num_citations": "34\n", "authors": ["540"]}
{"title": "K@ rt: An aspect-oriented and model-oriented framework for dynamic software product lines\n", "abstract": " Software systems should often provide continuous services and cannot easily be stopped. However, in order to meet new requirements from the user or the marketing, systems should be able to evolve in order to provide new services or modify existing ones. Adapting software systems at runtime is not an easy task and should be realized with attention. In this paper, we present K@RT, our generic and extensible framework for managing dynamic software product lines. K@RT is composed of three parts: i) a generic and extensible metamodel for describing running systems at a high-level of abstraction, ii) a set of metaaspects that extends the generic metamodel with constraint checking, supervising and connections with execution platforms iii) some platform-specific causal connections that allow us to supervise systems running on different execution platforms.", "num_citations": "33\n", "authors": ["540"]}
{"title": "Composition of qualitative adaptation policies\n", "abstract": " In a highly dynamic environment, software systems requires a capacity of self-adaptation to fit the environment and the user needs evolution, which increases the software architecture complexity. Despite most current execution platforms include some facilities for handling dynamic adaptation, current design methodologies do not address this issue. One of the requirement for such a design process is to describe adaptation policies in a composable and qualitative fashion in order to cope with complexity. This paper introduces an approach for describing adaptation policies in a qualitative way while keeping the compositionality of adaptation policies. The basic example of a Web server is used to illustrate how to specify and to compose two adaptations policies which handle respectively the use of a cache and the deployment of new data sources.", "num_citations": "31\n", "authors": ["540"]}
{"title": "Validating distributed software modelled with UML\n", "abstract": " The development of correct OO distributed software is a daunting task as soon as the distributed interactions are not trivial. This is due to the inherent complexity of distributed systems (latency, error recovery, etc.), leading to numerous problems such as deadlocks, race conditions, and many difficulties in trying to reproduce such error conditions and debug them. The OO technology is ill equipped to deal with this dimension of the problem. On the other hand, the willingness of mastering this complexity in the context of telecommunication protocols gave birth to specific formal verification and validation tools. The aim of this paper is to explore how the underlying technology of these tools could be made available to the designer of OO distributed software. We propose a framework allowing the integration of formal verification and validation technology in a seamless OO lifecycle based on UML, the Unified Modeling Language.", "num_citations": "31\n", "authors": ["540"]}
{"title": "Model-driven engineering for software product lines\n", "abstract": " Modeling variability in the context of software product-lines has been around for about 25 years in the research community. It started with Feature Modeling and soon enough was extended to handle many different concerns. Beyond being used for a mere description and documentation of variability, variability models are more and more leveraged to produce other artifacts, such as configurators, code, or test cases. This paper overviews several classification dimensions of variability modeling and explores how do they fit with such artifact production purposes.", "num_citations": "30\n", "authors": ["540"]}
{"title": "Model-driven analysis and synthesis of textual concrete syntax\n", "abstract": " Meta-modeling is raising more and more interest in the field of language engineering. While this approach is now well understood for defining abstract syntaxes, formally defining textual concrete syntaxes with meta-models is still a challenge. Textual concrete syntaxes are traditionally expressed with rules, conforming to EBNF-like grammars, which can be processed by compiler compilers to generate parsers. Unfortunately, these generated parsers produce concrete syntax trees, leaving a gap with the abstract syntax defined by meta-models, and further ad hoc hand-coding is required. In this paper we propose a new kind of specification for concrete syntaxes, which takes advantage of meta-models to generate fully operational tools (such as parsers or text generators). The principle is to map abstract syntaxes to textual concrete syntaxes via bidirectional mapping-models with support for both model-to-text\u00a0\u2026", "num_citations": "30\n", "authors": ["540"]}
{"title": "Leveraging CVL to manage variability in software process lines\n", "abstract": " Variability on project requirements often implies variability on software processes. To manage such variability, Software Process Lines (SPLs) can be used to represent commonality (i.e., common practices) and variability (i.e., differences) of a set of related software processes. To this end, some Software Process Modeling Languages (SPMLs) natively integrate variability mechanisms. Nevertheless, such a coupling between the SPML and the variability mechanisms i) requires to interpret the requirements variability in terms of the processes variability, ii) limits the reuse of the requirements variability for other purposes (e.g., the development itself), and iii) is a barrier to the use of advances from the field of variability management. In this paper, we propose an approach to apply the Common Variability Language (CVL from the OMG consortium) for requirement variability modeling and its binding to the processes. This\u00a0\u2026", "num_citations": "29\n", "authors": ["540"]}
{"title": "A model-driven measurement approach\n", "abstract": " Companies using domain specific languages in a model-driven development process need to measure their models. However, developing and maintaining a measurement software for each domain specific modeling language is costly. Our contribution is a model-driven measurement approach. This measurement approach is model-driven from two viewpoints: 1) it measures models of a model-driven development process; 2) it uses models as unique and consistent metric specifications, w.r.t a metric specification metamodel. This declarative specification of metrics is then used to generate a fully fledged implementation. The benefit from applying the approach is evaluated by two applications. They indicate that this approach reduces the domain-specific measurement software development cost.", "num_citations": "29\n", "authors": ["540"]}
{"title": "From contracts to aspects in uml designs\n", "abstract": " Separation of concerns is a basic engineering principle that is often applied in object-oriented analysis and design by dissociating functional aspects (business objects) from non-functional ones, such as persistency, fault-tolerance and so on. The Unified Modeling Language (UML) then gives the designer a rich, but somehow disorganized, set of views on her model as well as many features, such as design pattern occurrences, stereotypes or tag values to add non-functional annotations to a model. In this paper, we explore a possibility to organize all of these features around the central notions of (1) quality of service contracts (for specifying non-functional properties a la QML) and (2) aspects for describing how they can be implemented. We propose to model contracts in UML with a small set of stereotypes, and to represent aspects a bit like design pattern occurrences, that is using parameterized collaborations equipped with transformation rules expressed with meta-level OCL2.", "num_citations": "29\n", "authors": ["540"]}
{"title": "Increase software trustability with self-testable classes in java\n", "abstract": " The rise of component-based software development poses the problem of components trustability. To know whether a given component can be used within a certain context, there must be a way of telling what the component is supposed to do (its contract) without entering into the details of the how. Based on this idea, we have proposed a general Design-for-Trustability methodology (\"DfT\"), starting from simple self-testing of individual classes to optimized integration testing, This paper describes the \"DfT\" methodology, the self-testable class model that supports it and the associated tools for Java development.", "num_citations": "29\n", "authors": ["540"]}
{"title": "EPEE-AN EIFFEL ENVIRONMENT TO PROGRAM DISTRIBUTED-MEMORY PARALLEL COMPUTERS\n", "abstract": " Most parallel O-O programming languages (OOPLs) currently use a general parallelism model based on communicating sequential processes. This approach makes it difficult to program massively parallel systems in an easy and efficient way. This article proposes the use of data parallelism, and describes how a pure, sequential OOPL can embed data parallelism in a clean and elegant fashion to exploit the potential power of massively parallel systems. EPEE (an Eiffel Parallel Execution Environment) is presented at work with parallel matrix computations, and experimental performance results are given as well as some conclusions.", "num_citations": "29\n", "authors": ["540"]}
{"title": "Contract aware components, 10 years after\n", "abstract": " The notion of contract aware components has been published roughly ten years ago and is now becoming mainstream in several fields where the usage of software components is seen as critical. The goal of this paper is to survey domains such as Embedded Systems or Service Oriented Architecture where the notion of contract aware components has been influential. For each of these domains we briefly describe what has been done with this idea and we discuss the remaining challenges.", "num_citations": "27\n", "authors": ["540"]}
{"title": "Integrating iot and ios with a component-based approach\n", "abstract": " There is a growing interest in leveraging Service Oriented Architectures (SOA) in domains such as home automation, automotive, mobile phones or e-Health. With the basic idea (supported in e.g. OSGi) that components provide services, it makes it possible to smoothly integrate the Internet of Things (IoT) with the Internet of Services (IoS). The paradigm of the IoS indeed offers interesting capabilities in terms of dynamicity and interoperability. However in domains that involve \u201cthings\u201d (e.g. appliances), there is still a strong need for loose coupling and a proper separation between types and instances that are well-known in Component-Based approaches but that typical SOA fail to provide. This paper presents how we can still get the best of both worlds by augmenting SOA with a Component-Based approach. We illustrate our approach with a case study from the domain of home automation.", "num_citations": "27\n", "authors": ["540"]}
{"title": "Building a global time on parallel machines\n", "abstract": " This paper presents a pragmatic algorithm to build a global time on any distributed system, which is optimal for homogeneous parallel machines. After some discution on time, clocks and distributed systems, we survey and criticize the classical approaches based on clock synchronisation techniques. Satisfying better our purposes, a statistical method is chosen as a building block to derive an original algorithm valid for any topology. This algorithm is particularly well suited for distributed algorithm experimentation purposes because, after an acquisition phasis, it induces neither CPU nor message overhead. We provide in the conclusion some data about its behavior and performances on some parallel machines.", "num_citations": "26\n", "authors": ["540"]}
{"title": "Safe model polymorphism for flexible modeling\n", "abstract": " Domain-Specific Languages (DSLs) are increasingly used by domain experts to handle various concerns in systems and software development. To support this trend, the Model-Driven Engineering (MDE) community has developed advanced techniques for designing new DSLs. However, the widespread use of independently developed, and constantly evolving DSLs is hampered by the rigidity imposed to the language users by the DSLs and their tooling, e.g., for manipulating a model through various similar DSLs or successive versions of a given DSL. In this paper, we propose a disciplined approach that leverages type groups\u05f3 polymorphism to provide an advanced type system for manipulating models, in a polymorphic way, through different DSL interfaces. A DSL interface, a.k.a. model type, specifies a set of features, or services, available on the model it types, and subtyping relations among these model types\u00a0\u2026", "num_citations": "25\n", "authors": ["540"]}
{"title": "Towards a generic aspect-oriented modeling framework\n", "abstract": " Aspect-Oriented Modeling approaches propose to model reusable aspects, or cross-cutting concerns, that can be later on composed into various base systems. These approaches are often limited to a particular domain: UML class diagrams, UML sequence diagrams, ... and therefore they cannot easily be adapted to other domains. In this paper, we propose to extend the notion of aspect to emcompass an open ended number of domains. We present our Generic Aspect-Oriented Modeling Framework and show how it can easily be specialized for any specific domain.", "num_citations": "25\n", "authors": ["540"]}
{"title": "A UML-integrated test description language for component testing\n", "abstract": " A mass market in reusable components demands a high level of compo- nent quality, testing being a crucial part of software quality assurance. For components modelled in UML there are significant advantages to using UML also for the test description language. Since we wish to describe tests of non-trivial temporal ordering properties, we define our test description language based around UML interaction diagrams, seeking inspiration from the work on conformance testing of telecom protocols. We aim at a fully integrated approach which can be captured in a UML component testing profile.", "num_citations": "24\n", "authors": ["540"]}
{"title": "A multi-processor Estelle to C compiler to experiment distributed algorithms on parallel machines\n", "abstract": " This paper presents a first attempt to generate parallel code from Estelle descriptions. We have dealt with a simple context in which only a static subset of Estelle and an homogeneous target machine are considered. We begin to present and justify the concept of experimentation on distributed algorithms for which our Estelle compiler has been designed. Then we discuss how the Estelle constructs are mapped onto C structures and how they are interpreted by a distributed runtime kernel. A technical annex gives an idea of the current version of the tool, named Echidna.", "num_citations": "24\n", "authors": ["540"]}
{"title": "Integrating legacy systems with mde\n", "abstract": " Integrating several legacy software systems together is commonly performed with multiple applications of the Adapter Design Pattern in OO languages such as Java. The integration is based on specifying bi-directional translations between pairs of APIs from different systems. Yet, manual development of wrappers to implement these translations is tedious, expensive and error-prone. In this paper, we explore how models, aspects and generative techniques can be used in conjunction to alleviate the implementation of multiple wrappers. Briefly the steps are, (1) the automatic reverse engineering of relevant concepts in APIs to high-level models; (2) the manual definition of mapping relationships between concepts in different models of APIs using an ad-hoc DSL; (3) the automatic generation of wrappers from these mapping specifications using AOP. This approach is weighted against manual development of wrappers\u00a0\u2026", "num_citations": "23\n", "authors": ["540"]}
{"title": "Unifying runtime adaptation and design evolution\n", "abstract": " The increasing need for continuously available software systems has raised two key-issues: self-adaptation and design evolution. The former one requires software systems to monitor their execution platform and automatically adapt their configuration and/or architecture to adjust their quality of service (optimization, fault-handling). The later one requires new design decisions to be reflected on the fly on the running system to ensure the needed high availability (new requirements, corrective and preventive maintenance). However, design evolution and self adaptation are not independent and reflecting a design evolution on a running self-adaptative system is not always safe. We propose to unify run-time adaptation and run-time evolution by monitoring both the run-time platform and the design models. Thus, it becomes possible to correlate those heterogeneous events and to use pattern matching on events to\u00a0\u2026", "num_citations": "23\n", "authors": ["540"]}
{"title": "Echidna, an Estelle compiler to prototype protocols on distributed computers\n", "abstract": " We report our experience in developing a compiler and a distributed run\u2010time kernel for distributed computers, called Echidna. Echidna is a software package which has been available for more than two years, and aims to support protocol designers in protocol modeling, validation and performance evaluation. It is basically oriented towards the rapid prototyping of distributed algorithms on distributed computers: the Intel iPSC hypercube, the Supernode machine, and networks of Transputers and Suns were considered. Algorithms are described using an ISO formal description technique called Estelle. First, we present and justify the concept of experimentation on distributed algorithms for which our Estelle compiler has been designed. Then we discuss how Estelle constructs are mapped onto C structures and how they are interpreted by a distributed run\u2010time kernel. We conclude by presenting typical uses of Echidna.", "num_citations": "23\n", "authors": ["540"]}
{"title": "When systems engineering meets software language engineering\n", "abstract": " The engineering of systems involves many different stakeholders, each with their own domain of expertise. Hence more and more organizations are adopting Domain Specific Languages (DSLs) to allow domain experts to express solutions directly in terms of relevant domain concepts. This new trend raises new challenges about designing DSLs, evolving a set of DSLs and coordinating the use of multiple DSLs for both DSL designers and DSL users. This paper explores various dimensions of these challenges, and outlines a possible research roadmap for addressing them. The message of this paper is also to claim that if language engineering techniques to design any single (disposable) language are mature, the language engineering community needs to fundamentally change its view on software language design. We need to take the next step and adopt the perspective that a software language is\u00a0\u2026", "num_citations": "21\n", "authors": ["540"]}
{"title": "Using UML sequence diagrams as the basis for a formal test description language\n", "abstract": " A formal, yet user-friendly, test description language could increase the possibilities for automation in the testing phase while at the same time gaining widespread acceptance. Scenario languages are currently one of the most popular formats for describing interactions between possibly distributed components. The question of giving a solid formal basis to scenario languages such as MSC has also received a lot of attention. In this article, we discuss using one of the most widely-known scenario languages, UML sequence diagrams, as the basis for a formal test description language for use in the distributed system context.", "num_citations": "21\n", "authors": ["540"]}
{"title": "Conformance testing from UML specifications. Experience Report\n", "abstract": " UMLAUT is a framework for building tools dedicated to the manipulation of models described using the Unified Modeling Language (UML). TGV is a tool for the generation of conformance test suites for protocols. Both tools are connected so that it is possible to specify an application in UML and derive automatically some test cases. In this article, the integration of those tools in an industrial process is evaluated through a case study. This case study, proposed by Gemplus, is a Java Card applet: a classical electronic purse.", "num_citations": "21\n", "authors": ["540"]}
{"title": "A multi-paradigm object oriented parallel environment\n", "abstract": " Control and data parallelism are two complementary but often mutually exclusive paradigms used to program massively parallel systems. We propose to encapsulate both control and data parallelism in regular classes of a sequential object oriented language: a SPMD programming model is used and thus no language extensions are needed, provided a shared virtual memory is available. We show how these ideas are implemented in EPEE, our Eiffel Parallel Execution Environment. As an example, we present the implementation of both paradigms on a toy linear algebra example and show how they can interoperate. We conclude with some performance results and prospective remarks.< >", "num_citations": "21\n", "authors": ["540"]}
{"title": "UML 2002-The Unified Modeling Language: Model Engineering, Concepts, and Tools: 5th International Conference, Dresden, Germany, September 30 October 4, 2002. Proceedings\n", "abstract": " Five years on from its adoption in 1997 by the Object Management Group (OMG), the Uni? ed Modeling Language is the de facto standard for creating-agrammatic models of software systems. More than 100 books have been written about UML, and it is taught to students throughout the world. The de? nition of UML version 2 is well under way, and should be largely completed within the year. This will not only improve and enhance UML itself, including standard facilities for diagram interchange, but also make it fully integrated with other modeling technologies from the OMG, such as Meta-Object Facility (MOF) and XML Metadata Interchange (XMI). The Object Constraint Language, which has become an important vehicle for communicating detailed insights between UML researchers and practitioners, will have a much expanded speci? cation and be better integrated with the UML. The popularity of UML signi? es the possibility of a shift of immense prop-tions in the practice of software development, at least comparable to the shift from the use of assembly language to \u201cthird-generation\u201d or \u201chigh-level\u201d p-gramming languages. We dream of describing the behavior of software systems in terms of models, closely related to the needs of the enterprise being served, and being able to routinely translate these models automatically into executing p-grams on distributed computing systems. The OMG is promoting Model-Driven Architecture (MDA) as a signi? cant step towards this vision, and the MDA c-cept has received considerable support within the IT industry.", "num_citations": "20\n", "authors": ["540"]}
{"title": "Achieving process modeling and execution through the combination of aspect and model\u2010driven engineering approaches\n", "abstract": " One major advantage of executable software process models is that once defined, they can be simulated, checked and validated in short incremental and iterative cycles. This also makes them a powerful asset for important process improvement decisions such as resource allocation, deadlock identification and process management. In this paper, we propose a framework that combines Aspect and Model\u2010driven Engineering approaches in order to ensure process modeling, simulation and execution. This framework is based on UML4SPM, a UML2.0\u2010based language for Software Process Modeling and Kermeta, an executable metaprogramming language. Copyright \u00a9 2010 John Wiley & Sons, Ltd.", "num_citations": "19\n", "authors": ["540"]}
{"title": "A model-driven approach for virtual machine image provisioning in cloud computing\n", "abstract": " The Cloud Computing Infastructure-as-a-Service (IaaS) layer provides a service for on demand virtual machine images deployment. This service provides a flexible platform for cloud users to develop, deploy, and test their applications. However, one major issue of application deployment is to ensure the compatibility of software components installed in a virtual machine image. This paper describes a model-driven approach to manage, create configurations, and deploy images for virtual machine image provisioning in Cloud Computing. This approach considers virtual image as product lines and uses feature models to represent their configurations. It uses model-based techniques to handle automatic deployment and reconfiguration, making the management of virtual images more flexible and easier than traditional approaches.", "num_citations": "19\n", "authors": ["540"]}
{"title": "A models@ runtime framework for designing and managing service-based applications\n", "abstract": " Coordinating the configurations of Services, Orchestrations, Execution Platform and Infrastructure layers in a Service-Based environment is a significant challenge for software industry. In recent years, it has become even more difficult, because infrastructure solutions such as AmazonEC2, Cloudstack or RackSpace have increasingly rich capabilities, allowing for example, the infrastructure/platform/application dynamic adaptations. To address this challenge, in the context of the S-Cube Network of Excellence, we have proposed a domain specific modelling language to describe the whole Service-Based Applications layers entities using a models@runtime-based approach to cover the life-cycle of such applications. Our approach allows (i) to keep a representation of all the layers of a services-based applications, (ii) to coordinate the cross-layer reconfiguration and adaptations and (iii) to provide a support for\u00a0\u2026", "num_citations": "19\n", "authors": ["540"]}
{"title": "QoS assurance for service-based applications using discrete-event simulation\n", "abstract": " The new paradigm for distributed computing over the Internet is that of Web services. The goal of Web services is to achieve universal interoperability between applications by using standardized protocols and languages. One of the key ideas of the Web service paradigm is the ability of building complex and value-added service-based applications by composing preexisting services. For a service-based application, in addition to its functional requirements, Quality of service (QoS) requirements are important and deserve a special attention. In this paper, we introduce a discrete-event modeling approach for service-based application. This approach is oriented towards QoS assurance through discrete-event simulation.", "num_citations": "19\n", "authors": ["540"]}
{"title": "Measuring models\n", "abstract": " Model-Driven Engineering (MDE) is an approach to software development that uses models as primary artifacts, from which code, documentation and tests are derived. One way of assessing quality assurance in a given domain is to define domain metrics. We show that some of these metrics are supported by models. As text documents, models can be considered from a syntactic point of view ie, thought of as graphs. We can readily apply graph-based metrics to them, such as the number of nodes, the number of edges or the fan-in/fan-out distributions. However, these metrics cannot leverage the semantic structuring enforced by each specific metamodel to give domain specific information. Contrary to graph-based metrics, more specific metrics do exist for given domains (such as LOC for programs), but they lack genericity. Our contribution is to propose one metric, called s, that is generic over metamodels and\u00a0\u2026", "num_citations": "19\n", "authors": ["540"]}
{"title": "Semantic join point models: Motivations, notions and requirements\n", "abstract": " Aspect-oriented programming (AOP) has been designed to provide a better separation of concerns at development level by modularizing concerns that would otherwise be tangled and scattered across other concerns. Current mainstream AOP techniques separate crosscutting concerns on a syntactic basis whereas a concern is more a semantic matter. Therefore, a different, more semanticoriented, approach to AOP is needed. In this position paper, we investigate the limitations of mainstream AOP techniques, mainly AspectJ, in this regard and highlight the issues that need to be addressed to design semantic-based join point models.", "num_citations": "19\n", "authors": ["540"]}
{"title": "Bridging the chasm between MDE and the world of compilation\n", "abstract": " Modeling and transforming have always been the cornerstones of software system development, albeit often investigated by different research communities. Modeling addresses how information is represented and processed, while transformation cares about what the results of processing this information are. To address the growing complexity of software systems, model-driven engineering (MDE) leverages domain-specific languages to define abstract models of systems and automated methods to process them. Meanwhile, compiler technology mostly concentrates on advanced techniques and tools for program transformation. For this, it has developed complex analyses and transformations (from lexical and syntactic to semantic analyses, down to platform-specific optimizations). These two communities appear today quite complementary and are starting to meet again in the software language\u00a0\u2026", "num_citations": "18\n", "authors": ["540"]}
{"title": "Model and metamodel composition: separation of mapping and interpretation for unifying existing model composition techniques\n", "abstract": " Model-Driven Engineering (MDE) is a software development methodology that relies on the Separation of Concerns (SoC) and Abstraction principles to deal with complexity. Thinking in terms of higher levels of abstraction and building dedicated models to address specific concerns allow decomposing a problem into more manageable subproblems. Within the framework of MDE, model composition is an active field of research that focuses on automating the composition of model-based artifacts in a multi-modeling environment. However the lack of a common formalism for comparing existing approaches hinders their adaptation and reuse for building new model composition techniques. The main contribution of this thesis is to propose a novel definition of model composition as a pair of a mapping and an interpretation. This definition paves the way to a theoretical framework that (1) unifies existing representations of model composition techniques and (2) automates the process of building model composition tools. The main contribution is supported by two subsidiaries propositions: - We propose categories to classify existing mapping techniques and existing model composition interpretations. - We define a language that supports the definition of generic mappings among models and the definition of interpretations. We validate the contribution through two experiments: (1) a systematic literature review validates the proposed categories for mappings and interpretations; (2) a prototype that supports the model composition approach has been tested on an industrial case study from Technicolor about the composition of legacy APIs for the\u00a0\u2026", "num_citations": "18\n", "authors": ["540"]}
{"title": "Reifying variants in configuration management\n", "abstract": " Using a solid software configuration management (SCM) is mandatory to establish and maintain the integrity of the products of a software project throughout the project's software life cycle. Even with the help of sophisticated tools, handling the various dimensions of SCM can be a daunting (and costly) task for many projects.  The contribution of this article is to (1)propose a method (based on the use creational design patterns) to simplify SCM by reifying the variants of an object-oriented software system into language-level objects and (2)show that newly available compilation technology makes this proposal attractive with respect to performance (memory footprint and execution time) by inferring which classes are needed for a specific configuration and optimizing  the generated code accordingly.", "num_citations": "17\n", "authors": ["540"]}
{"title": "Managing variability complexity in aspect-oriented modeling\n", "abstract": " Aspect-Oriented Modeling (AOM) approaches propose to model reusable aspects that can be applied to different systems at the model level. To improve reusability, several contributions have pointed out the needs of variability in the AOM approaches. Nevertheless, the support of variability makes the aspect design more complex and the introduction of several dimensions of variability (advice, pointcut and weaving) creates a combinatorial explosion of variants and a risk of inconsistency in the aspect model. As the integration of an aspect model may be a complex task, the AOM framework has to be a support for the designer to ensure the consistency of the resulting model. This paper presents an approach describing how to ensure that an aspect model with variability can be safely integrated into an existing model. Verification includes static checking of aspect model consistency and dynamic checking\u00a0\u2026", "num_citations": "16\n", "authors": ["540"]}
{"title": "An object-oriented framework for supercomputing\n", "abstract": " Scientific programmers are eager to take advantage of the computational power offered by Distributed Computing Systems (DCSs) but are generally reluctant to undertake the porting of their application programs onto such machines. The DCSs commercially available today are indeed widely believed to be difficult to use, which should not be a surprise because they are traditionally programmed with software tools dating back to the days of punch cards and paper tape. We claim that, provided modern object-oriented technologies are used, these computers can be programmed easily and efficiently. We propose a framework where the tricky parallel codes can be encapsulated in object-oriented software components that can be reused, combined, and customized in confidence by application programmers. We propose to use a kind of parallelism known as data-parallelism, encapsulated within classes of a purely\u00a0\u2026", "num_citations": "15\n", "authors": ["540"]}
{"title": "Transparent parallelisation through reuse: between a compiler and a library approach\n", "abstract": " Software environments for commercially available Distributed Memory Parallel Computers (DMPCs) mainly consist of libraries of routines to handle communications between processes written in sequential languages such as C or Fortran. This approach makes it difficult to program massively parallel systems in both an easy and efficient way. Another approach relies on (semi-)automatic parallelizing compilers but it has its own drawbacks. We propose to tackle this problem at an intermediate level (i.e. between high level parallelizing compilers and raw libraries), using Object Oriented (OO) technologies. We show that existing OO techniques based on the reuse of carefully designed software components can be applied with satisfactory results to the large scale scientific computation field. We propose to use a form of parallelism, known as data parallelism, and to embed it in a pure sequential OOL (Eiffel). We\u00a0\u2026", "num_citations": "15\n", "authors": ["540"]}
{"title": "Scapegoat: an Adaptive monitoring framework for Component-based systems\n", "abstract": " Modern component frameworks support continuous deployment and simultaneous execution of multiple software components on top of the same virtual machine. However, isolation between the various components is limited. A faulty version of any one of the software components can compromise the whole system by consuming all available resources. In this paper, we address the problem of efficiently identifying faulty software components running simultaneously in a single virtual machine. Current solutions that perform permanent and extensive monitoring to detect anomalies induce high overhead on the system, and can, by themselves, make the system unstable. In this paper we present an optimistic adaptive monitoring system to determine the faulty components of an application. Suspected components are finely instrumented for deeper analysis by the monitoring system, but only when required\u00a0\u2026", "num_citations": "14\n", "authors": ["540"]}
{"title": "Model-driven simulation of a maritime surveillance system\n", "abstract": " This paper reports an industrial experiment made at Thales to use Model Driven Architecture (MDA) for system engineering. System engineering processes are currently mainly document-centric. The main experiment goal was to study the applicability of MDA at the system engineering level. The experiment consisted of setting up a model-driven simulation environment for a maritime surveillance system. The simulation is achieved thanks to 3 models conform to 3 metamodels. The implementation uses the Eclipse Modeling Framework and is written in the Java Programming language. This pilot project met the deadline, the budget and the threshold of desired functionalities. We report the main advances given by the MDA approach in the context of simulation for system engineering.", "num_citations": "14\n", "authors": ["540"]}
{"title": "Efficient high-level abstractions for web programming\n", "abstract": " Writing large Web applications is known to be difficult. One challenge comes from the fact that the application's logic is scattered into heterogeneous clients and servers, making it difficult to share code between both sides or to move code from one side to the other. Another challenge is performance: while Web applications rely on ever more code on the client-side, they may run on smart phones with limited hardware capabilities. These two challenges raise the following problem: how to benefit from high-level languages and libraries making code complexity easier to manage and abstracting over the clients and servers differences without trading this ease of engineering for performance? This article presents high-level abstractions defined as deep embedded DSLs in Scala that can generate efficient code leveraging the characteristics of both client and server environments. We compare performance on client-side\u00a0\u2026", "num_citations": "13\n", "authors": ["540"]}
{"title": "Improving reusability in software process lines\n", "abstract": " Software processes orchestrate manual or automatic tasks to create new software products that meet the requirements of specific projects. While most of the tasks are about inventiveness, modern developments also require recurrent, boring and time-consuming tasks (e.g., the IDE configuration, or the continuous integration setup). Such tasks struggle to be automated due to their various execution contexts according to the requirements of specific projects. In this paper, we propose a methodology that benefits from an explicit modeling of a family of processes to identify the possible reuse of automated tasks in software processes. We illustrate our methodology on industrial projects in a software company. Our methodology promoted both the identification of possible automated tasks for configuring IDEs and continuous integration, and their reuse in various projects of the company. Our methodology contributes to the\u00a0\u2026", "num_citations": "13\n", "authors": ["540"]}
{"title": "Toward a generic and extensible merge operator\n", "abstract": " Merging is a common way to compose both crosscutting and non-crosscutting models. In this paper, we argue that merge can be defined more generically as an operator at the meta-modelling level. By describing merge at this level, a merge operator can be used to compose models based on meta-models other than UML. There are various merge variants and we concede that a full unification of all merge semantics may be infeasible. To define a common merge, we propose the definition of a common merge kernel as a semantic base that can be extended to realise the different expressions of merge.", "num_citations": "13\n", "authors": ["540"]}
{"title": "An MDA approach to tame component based software development\n", "abstract": " The aim of this paper is to show how the Model Driven Architecture (MDA) can be used in relation with component based software engineering. A software component only exhibits its provided or required interfaces, hence defining basic contracts between components allowing one to properly wire them. These contractually specified interfaces should go well beyond mere syntactic aspects: they should also involve functional, synchronization and Quality of Service (QoS) aspects. In large, mission-critical component based systems, it is also particularly important to be able to explicitly relate the QoS contracts attached to provided interfaces with the QoS contracts obtained from required interfaces. We thus introduce a QoS contract model (called QoSCL for QoS Constraint Language), allowing QoS contracts and their dependencies to be modeled in a UML2.0 modeling environment. Building on Model Driven\u00a0\u2026", "num_citations": "13\n", "authors": ["540"]}
{"title": "A discrete-events simulation approach for evaluation of service-based applications\n", "abstract": " One of the promises of the service-oriented architecture(SOA) is to build complex added-value services in order to enhance and extend existing ones. service-based applications(SBAs) are asked not only to perform required functionalities,but also to deliver expected level of Quality of Service (QoS). Dealing with QoS management of such distributed applications, which are executed in dynamic environments,raises the need to consider context characteristics.This paper proposes a discrete-events simulation approach which assures the evaluation of SBAs performance under different context status. The main contributions of this paper are: (i) the discrete-events modeling approach for SBAs, (ii) the context-based model for SBAs considered in the discrete-events simulation model, and (iii) the evaluation of a set of QoS metrics by simulation.", "num_citations": "12\n", "authors": ["540"]}
{"title": "QCCS: A methodology for the development of contract-aware components based on aspect oriented design\n", "abstract": " QCCS (Quality Controlled Component-based Software development)[1] is an IST project sponsored by the European Commission that will develop a methodology and supporting tools for the creation of components based on contracts and Aspect Oriented Programming (AOP).Components that have been designed according to the QCCS methodology will have proven properties, which are formally specified in contracts and can therefore be safely applied to build complex systems and services. Also they may be re-used in other situations. Because each component knows its pre-and post-conditions for usage, it is easy to discover situations in which the component is used erroneously. Hence our work results in a methodology and supporting technology which copes with two key problems:\u2022 Enabling the smooth and sound integration of components from multiple independent", "num_citations": "12\n", "authors": ["540"]}
{"title": "Parallel operators\n", "abstract": " Encapsulating parallelism and synchronization code within object-oriented software components is a promising avenue towards mastering the complexity of the distributed memory supercomputer programming. However, in trying to give application programmers benefit of supercomputer power, the library designer generally resorts to low level parallel constructs, a time consuming and error prone process. To solve this problem we introduce a new abstraction called Parallel Operators. A Parallel Operator exists simultaneously on all processors involved in a distributed computation: it acts as a single ubiquitous entity capable of processing shared or distributed data in parallel. In this paper we reify this concept in our Eiffel Parallel Execution Environment (EPEE) context, and we show that it is both natural and efficient to express computations over large shared or distributed data structures using Parallel\u00a0\u2026", "num_citations": "12\n", "authors": ["540"]}
{"title": "A Multi-Processor Estelle-to-C Compiler to Prototype Algorithms on Parallel Machines\n", "abstract": " A Multi-Processor Estelle-to-C Compiler to Prototype Algorithms on Parallel Machines | Proceedings of the IFIP WG6.1 Ninth International Symposium on Protocol Specification, Testing and Verification IX ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsProceedings of the IFIP WG6.Ninth International Symposium on Protocol Specification, Testing and Verification IXA Multi-Processor Estelle-to-C Compiler to Prototype Algorithms on Parallel Machines ARTICLE A Multi-Processor Estelle-to-C Compiler to Prototype Algorithms on Parallel Machines Share on Authors: Claude Jard profile image Claude Jard View Profile , Jean \u2026", "num_citations": "12\n", "authors": ["540"]}
{"title": "When Model Driven Engineering meets virtual reality: Feedback from application to the Collaviz framework\n", "abstract": " Despite the increasing use of 3D Collaborative Virtual Environments (3D CVE), their development is still a cumbersome task. The various concerns to consider (distributed system, 3D graphics, etc.) complexify the development as well as the evolution of CVEs. Software engineering recently proposed methods and tools to ease the development process of complex software systems. Among them, Model-Driven Engineering (MDE) considers models as first-class entities. A model is an abstraction of a specific aspect of the system under study for a specific purpose. MDE thus breaks down a complex system into as many models for different purposes, such as: generating code from models; building domain specific programming/modeling languages (DSL); generating tools such as graphical or textual editors. In this paper we leverage MDE for developing 3D CVEs. We show how the Collaviz framework took benefits\u00a0\u2026", "num_citations": "11\n", "authors": ["540"]}
{"title": "A multi-perspective approach for web service composition\n", "abstract": " The new paradigm for distributed computing over the Internet is that of Web services (WSs). One of the key ideas of this new paradigm is the ability to create value-added Service-Based Applications (SBAs) by composing pre-existing services. Building SBAs necessitates the discovery and the selection of the most appropriate WSs that fit closely users' functional and non-functional requirements. Due to the large number of WSs that are advertised over public and private registries and the various functional and non-functional capabilities that are required by users, discovery and selection of WSs have become a real challenge nowadays. In this paper, we present a WS composition approach that is built upon both perspectives: intentional and operational. In the intentional perspective, we propose to model users' requirements for SBAs using the MAP formalism and specify the required WSs using an Intentional Service\u00a0\u2026", "num_citations": "11\n", "authors": ["540"]}
{"title": "Typing relationships in MDA\n", "abstract": " As the OMG\u2019s Model-Driven Architecture matures from a field of research and specification into one of system engineering, it faces all of the challenges endemic to the practice. Among the foremost of these is the need to support re-use of its artifacts as they evolve. As systems begin to be built upon the basic ideas of models interrelated by model transformations, it will become increasingly important to have appropriate definitions for the typing relationships that can exist between models and metamodels, since it is these definitions that will determine the substitutability characteristics of these artifacts in model transformations. This paper seeks to enumerate a number of these relationships, to provide initial characterisations of them in terms of their significance to the goal of re-use in MDA.", "num_citations": "11\n", "authors": ["540"]}
{"title": "Reifying configuration management for object-oriented software\n", "abstract": " Using a solid Software Configuration Management (SCM) is mandatory to establish and maintain the integrity of the products of a software project throughout the project's software life cycle. Even with the help of sophisticated tools, handling the various dimensions of SCM can be a daunting (and costly) task for many projects. The contribution of this paper is to propose a method (based on the use Creational Design Patterns) to simplify SCM by reifying the variants of an object-oriented software system into language-level objects; and to show that newly available compilation technology makes this proposal attractive with respect to performance (memory footprint and execution time) by inferring which classes are needed for a specific configuration and optimizing the generated code accordingly, We demonstrate this idea on an artificial case study intended to be representative of a properly designed OO software. All\u00a0\u2026", "num_citations": "11\n", "authors": ["540"]}
{"title": "Vers l'utilisation d'outils de validation de protocoles dans UML\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "11\n", "authors": ["540"]}
{"title": "Comparing and classifying model transformation reuse approaches across metamodels\n", "abstract": " Model transformations are essential elements of model-driven engineering (MDE) solutions, as they enable the automatic manipulation of models. MDE promotes the creation of domain-specific metamodels, but without proper reuse mechanisms, model transformations need to be developed from scratch for each new metamodel. In this paper, our goal is to understand whether transformation reuse across metamodels is needed by the community, evaluate its current state, identify practical needs and propose promising lines for further research. For this purpose, we first report on a survey to understand the reuse approaches used currently in practice and the needs of the community. Then, we propose a classification of reuse techniques based on a feature model and compare a sample of specific approaches\u2014model types, concepts, a-posteriori typing, multilevel modeling, typing requirement models, facet-oriented\u00a0\u2026", "num_citations": "10\n", "authors": ["540"]}
{"title": "Model Transformation Reuse Across Metamodels\n", "abstract": " Model transformations (MTs) are essential elements of model-driven engineering (MDE) solutions. MDE promotes the creation of domain-specific metamodels, but without proper reuse mechanisms, MTs need to be developed from scratch for each new metamodel. In this paper, we classify reuse approaches for MTs across different metamodels and compare a sample of specific approaches \u2013 model types, concepts, a-posteriori typing, multilevel modeling, and design patterns for MTs \u2013 with the help of a feature model developed for this purpose, as well as a common example. We discuss strengths and weaknesses of each approach, provide a reading grid used to compare their features, and identify gaps in current reuse approaches.", "num_citations": "10\n", "authors": ["540"]}
{"title": "Specifying and running rich graphical components with loa\n", "abstract": " Interactive system designs often require the use of rich graphical components whose capabilities go beyond the set of widgets provided by GUI toolkits. The implementation of such rich graphical components require a high programming effort that GUI toolkits do not alleviate. In this paper, we propose the Loa framework that allows both the specification of rich graphical components and their integration within running interactive applications. We illustrate the specification and integration with the Loa framework as part of a global process for the design of interactive systems.", "num_citations": "10\n", "authors": ["540"]}
{"title": "Model\u2010driven architecture of a maritime surveillance system simulator\n", "abstract": " This article reports on an experiment to apply a model\u2010driven approach for systems engineering in an industrial context. This experiment consisted of setting up a model\u2010driven simulation environment for a maritime surveillance system. The simulation is fully based on three models, each conforming to a specific metamodel. We discuss the main advances given by model\u2010driven orientated simulation for systems engineering. \u00a9 2009 Wiley Periodicals, Inc. Syst Eng", "num_citations": "10\n", "authors": ["540"]}
{"title": "Implementing and evaluating an efficient dynamic load-balancer for distributed molecular dynamics simulation\n", "abstract": " Introduces and evaluates a new efficient dynamic load-balancing scheme for parallel molecular dynamics simulation on distributed memory machines. It decomposes a spatial domain of particles into disjoint parts, each of which corresponds with a processor and dynamically changes its shape to keep almost the same number of particles throughout simulation. In contrast to other similar schemes, ours requires no long-distance inter-processor communications but only those among adjacent processors (and, thus, little communication overhead), whereas it still guarantees fast reduction of load imbalance among the processors. It owes these advantages mainly to the following features. (1) The sufficiently correct global load information is effectively obtained with the stepwise propagation of appropriate information via nearest-neighbor communication. (2) In addition to the global load balancing, another load\u00a0\u2026", "num_citations": "10\n", "authors": ["540"]}
{"title": "On language interfaces\n", "abstract": " Complex systems are developed by teams of experts from multiple domains, who can be liberated from becoming programming experts through domain-specific languages (DSLs). The implementation of the different concerns of DSLs (including syntaxes and semantics) is now well established and supported by various language workbenches. However, the various services associated to a DSL (e.g., editors, model checkers, debuggers, or composition operators) are still directly based on its implementation. Moreover, while most of the services crosscut the different DSL concerns, they only require specific information on each. Consequently, this prevents the reuse of services among related DSLs and increases the complexity of service implementation. Leveraging the time-honored concept of interface in software engineering, we discuss the benefits of language interfaces in the context of software language\u00a0\u2026", "num_citations": "9\n", "authors": ["540"]}
{"title": "EntiMid: un middleware aux services de la maison\n", "abstract": " Face aux enjeux de soci\u00e9t\u00e9 li\u00e9s au vieillissement de la population, la domotique est souvent cit\u00e9e comme une solution pour favoriser le maintien \u00e0 domicile des personnes \u00e2g\u00e9es et la coordination des acteurs autour de cette probl\u00e9matique. Cet article liste les exigences auxquelles doit faire face une plate-forme domotique. Il montre que ces exigences rendent inop\u00e9rantes les solutions commerciales existantes, d\u2019autant que ces derni\u00e8res cherchent bien souvent \u00e0 imposer sur le march\u00e9 une solution propri\u00e9taire qui ne peut pr\u00e9tendre \u00e0 la richesse fonctionnelle n\u00e9cessaire. Il propose, en cons\u00e9quence, un ensemble de propri\u00e9t\u00e9s souhaitables pour un intergiciel orient\u00e9 domotique, permettant le d\u00e9ploiement d\u2019une solution \u00e0 l\u2019\u00e9chelle d\u2019une agglom\u00e9ration. L\u2019architecture d\u2019un intergiciel construit au dessus d\u2019une plateforme OSGI, et respectant ces propri\u00e9t\u00e9s est ensuite pr\u00e9sent\u00e9e. Enfin, une exp\u00e9rience de d\u00e9ploiement de cet intergiciel dans le cadre du laboratoire domotique de l\u2019universit\u00e9 de Rennes 1 met en \u00e9vidence la pertinence de la solution propos\u00e9e.", "num_citations": "9\n", "authors": ["540"]}
{"title": "Composition et expression qualitative de politiques d'adaptation pour les composants Fractal\n", "abstract": " Ever-growing systems' complexity and novel requirements engineering approaches such as reuse or globalization imply that requirements are produced by different stakeholders and written in possibly different languages. In this context, checking consistency so that requirements specifications are amenable to formal analysis is a challenge. Current techniques either fail to consider the requirement set as a whole, missing certain inconsistency types or are unable to take heterogeneous (i.e. expressed in different languages) specifications into account. We propose to use model composition to address this problem in a staged approach. First, heterogeneous requirements are translated in model fragments instances of a common metamodel. Then, fragments are merged in one unique model. On such a model inconsistencies such as under-specifications can be incrementally detected and formal analysis is made possible. Our approach is fully supported by our model composition framework. We propose model composition as means to address flexibility needs in requirements integration. Threats to validity such as the impact of new requirements languages needs to be addressed in future work.", "num_citations": "9\n", "authors": ["540"]}
{"title": "Model-driven generative approach for concrete syntax composition\n", "abstract": " This position paper presents a model-driven generative approach for composing concrete syntax. Concrete syntax is generated from information contained in a business model (represented with UML class diagrams) and from textual templates (represented in a composition model). The approach was originally implemented in the context of Web engineering (generation of HTML text) and was latter applied to paper catalogue generation (generation of QuarkXpress textual serialization format). Our contribution to the workshop would be to discuss how our approach could be applied to model generative programming, to gather feedback and to foster the discussion.", "num_citations": "9\n", "authors": ["540"]}
{"title": "A methodology for specifying data distribution using only standard object-oriented features\n", "abstract": " Object-oriented class frameworks are promising alternatives to traditional languages and their parallelizing compilers due to their higher at&action facilities for encapsulating parallelism and distribution. We claim that language feature6 already available in cxisiting object-oriented languages such aa C* for constructing class t&reworks can be maximally exploited for achieving 6cp6ration of parallelism and data distribution, without language extaxsions or ad-hoc methodologies. We first model parallel computation a6 crtiered application of a function onto 6tructurcd elements. and, ba6cd on the model, we construct a class fmmcwcrk which formulates 1) data distribution 66 hierarchical decomposition of the 6tructured elements to layered objects and 2) parallelism as nested rruversuls across these objects. We evaluate the feasibiity of our proposal on the Pujitsu APlOtXl parallel computer by extending the EPEE class\u00a0\u2026", "num_citations": "9\n", "authors": ["540"]}
{"title": "Numeric parallel programming with sequential object oriented languages\n", "abstract": " Archive ouverte HAL - Numeric Parallel Programming with Sequential Object Oriented Languages Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00495755, version 1 Communication dans un congr\u00e8s Numeric Parallel Programming with Sequential Object Oriented Languages Fr\u00e9d\u00e9ric Guidec 1 Jean-Marc J\u00e9z\u00e9quel 1 D\u00e9tails 1 PAMPA - Models and Tools for Programming Distributed Parallel Architectures IRISA - Institut de Recherche en Informatique et Syst\u00e8mes Al\u00e9atoires, INRIA Rennes Type de \u2026", "num_citations": "9\n", "authors": ["540"]}
{"title": "Using Model Driven Engineering technologies for building authoring applications\n", "abstract": " Building authoring applications is a tedious and complex task that requires a high programming effort. Document technologies, especially XML based ones, can help in reducing such an effort by providing common bases for manipulating documents. Still, the overall task consists mainly of writing the application's source code. Model Driven Engineering (MDE) focuses on generating the source code from an exhaustive model of the application. In this paper, we illustrate that MDE technologies can be used to automate the development of authoring application components, but fail in generating the code of graphical components. We present our framework, called Malai, that aims to solve this issue.", "num_citations": "8\n", "authors": ["540"]}
{"title": "Applying CLP to predict extra-functional properties of component-based models\n", "abstract": " A component is the basic re-usable unit of composition to build composite systems by connecting to others through their provided and required ports. Checking the functional compliance between provided and required ports is necessary to build functional systems. At the same time, one of the most important issues today in Component-Based Software Engineering (CBSE) is the prediction of the composite structure Quality of Service (QoS) at design time, using the extrafunctional properties of its components. This paper focuses on this specific CBSE issue, and the use of Constraint Logic Programming (CLP) in this context. For each component providing and requiring services, we propose to specify the QoS properties as required and provided operations, called dimensions, on the component ports. In this model, a QoS property can depend on other QoS attributes, and be constrained by OCL pre- and post\u00a0\u2026", "num_citations": "8\n", "authors": ["540"]}
{"title": "Des classes autotestables\n", "abstract": " Dans le double but d'am\u00e9liorer le processus de d\u00e9veloppement et de maintenance des com-posants logiciels et de disposer d'un support p\u00e9dagogique coh\u00e9rent pour l'apprentissage de la programmation par objets, nous avons d\u00e9velopp\u00e9 le concept de classe auto-testable. Ce concept est \u00e9troitement li\u00e9 \u00e0 l'approche de programmation contractuelle introduite par B.Meyer et aux besoins d'auto-documentation des composants logiciels. Apr\u00e8s avoir pr\u00e9cis\u00e9 la nature et les objectifs des tests que nous souhaitons r\u00e9aliser, nous sp\u00e9cifions un mod\u00e8le g\u00e9n\u00e9ral de classe auto-testable, ind\u00e9pendant du langage utilis\u00e9, et nous en pr\u00e9cisons les modalit\u00e9s d'application. Des prototypes d'impl\u00e9mentation en Eiffel, Perl, Java et C++ ont \u00e9t\u00e9 r\u00e9alis\u00e9s et exploit\u00e9s dans diverses situations. Pour les trois derniers langages, cette impl\u00e9mentation a conduit au d\u00e9veloppement d'un m\u00e9canisme simple de chien de garde des contrats. ABSTRACT. We define the concept of Self-Testable Class with a double aim: to improve the process of software components development and maintenance, and to have a coherent teaching support for object oriented programming training. This concept is closely related to the so-called \"programming by contracts\" approach (B.Meyer) and to the software components self-documentation. We show the nature and the objectives of the tests in an object oriented software development. Then, we specify a general, language independent Self-Testable Class model. A simple example is given. Implementation prototypes in Eiffel, Perl, Java and C++ have been produced and exploited in various situations. For all but the first one, this implementation\u00a0\u2026", "num_citations": "8\n", "authors": ["540"]}
{"title": "Building a global clock for observing computations in distributed memory parallel computers\n", "abstract": " A common time reference (i.e. global clock) is needed for observing the behavior of a distributed algorithm on a distributed computing system. The paper presents a pragmatic algorithm to build a global clock on any distributed system, which is optimal for homogeneous distributed memory parallel computers (DMPCs). In order to observe and sort concurrent events in common DMPCs, we need a global clock with a resolution finer than the message transfer time variance, which is better than what deterministic and fault\u2010tolerant algorithms can obtain. Thus a statistical method is chosen as a building block to derive an original algorithm valid for any topology. Its main originality over related approaches is to cope with the problem of clock granularity in computing frequency offsets between local clocks to achieve a resolution comparable with the resolution of the physical clocks. This algorithm is particularly well suited\u00a0\u2026", "num_citations": "8\n", "authors": ["540"]}
{"title": "Outils pour l'experimentation d'algorithmes distribues sur machines paralleles\n", "abstract": " Description detaillee du compilateur estele (technique de description formelle d'algorithmes distribues, normalisee par l'iso) generant du code pour diverses machines paralleles (ipsc, fps-t40, reseau de sun)", "num_citations": "8\n", "authors": ["540"]}
{"title": "Model-based product line evolution: an incremental growing by extension\n", "abstract": " Model-Based Engineering (MBE) and Product Line Engineering (PLE) have been combined, to handle new system development constraints like: increasing complexity, higher product quality, faster time-to-market and cost reduction. As observed by some authors, the derivation of a product from product line shared core assets has been insufficiently addressed and can remain tedious in practice. We cope with this issue focusing on having a flexible and reactive model-based derivation, and propose an incremental evolution by extension of the product line coupled with this derivation activity. Process and tools bridge the gap between Application and Domain Engineering introducing a semi-automatic feedback to benefits from the developments made in the Application Engineering. The approach is applied to a model-based product line dedicated to Class diagrams, and is tooled within the Eclipse environment.", "num_citations": "7\n", "authors": ["540"]}
{"title": "Une approche centr\u00e9e exigences pour la composition de services web\n", "abstract": " Cet article pr\u00e9sente une approche centr\u00e9e exigences pour la composition de services web qui permet : (i) la mod\u00e9lisation des exigences des utilisateurs avec le formalisme la Carte et la sp\u00e9cification des services requis avec un mod\u00e8le intentionnel de services (MIS) ; (ii) la d\u00e9couverte des services web pertinents en interrogeant le moteur de recherche de services Service-Finder ; (iii) la s\u00e9lection automatique de services pertinents et de haute QdS par l'application de l'analyse formelle de concepts (AFC) ; et (iv) la g\u00e9n\u00e9ration automatique de processus de coordination BPEL par l'application de la technique de transformation de mod\u00e8les. Dans cet article, nous illustrons notre approche par une application d'arrangement de conf\u00e9rences et nous la validons empiriquement en termes de pr\u00e9cision et de rappel sur cette application.", "num_citations": "7\n", "authors": ["540"]}
{"title": "A framework managing quality of service contracts in distributed applications\n", "abstract": " Designers and implementers of distributed applications have to deal with many difficult problems, such as concurrency control, distributed communication, fault-tolerance, quality of service management. Finding object-oriented solutions to these problems is a very active topic of research and development. Carefully chosen design patterns can help to reverse solutions for distributed application problems. We show how design patterns may allow a designer and developer to manage quality of service issues of distributed object interaction (e.g. when an object invokes a method on another remote object). Interactions between distributed objects (method invocation, remote method execution, result return) may be disturbed by network phenomena such as message losses, variation of transmission latency or bandwidth, link or site crashes. Robust distributed applications must deal with these events in a structured way\u00a0\u2026", "num_citations": "7\n", "authors": ["540"]}
{"title": "Design of a Parallel Object-Oriented Linear Algebra Library\n", "abstract": " Scientific programmers are eager to exploit the computational power offered by Distributed Memory Parallel Computers (DMPCs), but are generally reluctant to undertake the manual porting of their application programs onto such machines. We demonstrate that a purely sequential object-oriented language can be used to build parallel libraries that permit an efficient and transparent use of DMPCs. As an illustration, we discuss the design of an extensible object-oriented parallel linear algebra library.", "num_citations": "7\n", "authors": ["540"]}
{"title": "Experience in validating protocol integration using Estelle\n", "abstract": " This paper presents a ten months long experiment led at TRANSPAC to check the interest of a Formal Description Technique like Estelle for industrial purposes. Through the Intelligent Network new service introduction, Estelle-and associated tools, e.g. VEDA and EC H ID N A-has been used for different purposes: validation of a brand new protocol and test of its implementation, modelisation of an already existing one, and validation of the integration of both protocols. After a brief introduction to the TRANSPAC framework, we present an outline of these experiments. Then we draw some conclusion on the suitability of both Estelle and the tools used in this context, and on the economical balance of such an approach to deal with concrete problems.", "num_citations": "7\n", "authors": ["540"]}
{"title": "Customizing the common variability language semantics for your domain models\n", "abstract": " The Common Variability Language (CVL) provides a well-structured mechanism to express variability and to relate this variability to any MOF-compliant model. This characteristic allows users to define the materialization of a given CVL resolution/configuration. Using variation points, it is possible to express and manipulate the links between the variability abstraction model and the base model. However, the meaning of a given variation point can vary according to the semantics of each domain. For example, a variation point that excludes an element in the base model can lead to further operations, like excluding other elements which were associated to the deleted element, or even to reassign references to another model element. Therefore, it is necessary to address this semantic variability in order to align the materialization semantics to the base model semantics. In this paper, we show how Kermeta can be used\u00a0\u2026", "num_citations": "6\n", "authors": ["540"]}
{"title": "Managing variability in multi-views engineering: A live demo\n", "abstract": " This paper presents a tool-suite to model variability of a Software Product Line with feature models in the context of multi-views engineering. This tool-suite proposes four modules: (i) to model variability of views using a feature diagram, (ii) to select features required for a specific product, (iii) to derive a product and (iv) to visualize variability information directly inside the base-model editor. This tool is developed and tested on the ANR Movida project which deals with multi-views engineering as part of Model-Driven Engineering.", "num_citations": "6\n", "authors": ["540"]}
{"title": "Conception fonctionnelle de services d'entreprise fond\u00e9e sur l'alignement entre coeur de m\u00e9tier et Syst\u00e8me d'Information\n", "abstract": " La connaissance des processus constituant le c\u0153ur de m\u00e9tier de l'entreprise et sa structure organisationnelle permet d\u2019aligner l\u2019organisation de cette entreprise sur sa strat\u00e9gie. Or pour concevoir un ensemble de services fournis par l'entreprise \u00e0 un client particulier, il faut \u00eatre capable de d\u00e9crire les processus m\u00e9tier du point de vue client, et non de la production. Afin de respecter les objectifs de l'entreprise, nous proposons dans cet article de fonder la d\u00e9marche de conception des services, informatis\u00e9s ou non, sur le point de vue des syst\u00e8mes de l'architecture d'entreprise ou EA (Enterprise Architecture). L'apport de l'EA \u00e0 notre d\u00e9marche de conception des services d\u2019entreprise est conditionn\u00e9 par l'\u00e9cart entre la prise en compte de la strat\u00e9gie de l'entreprise au niveau du SI cible et sa prise en compte au niveau du c\u0153ur de m\u00e9tier. L'alignement ainsi d\u00e9fini est compl\u00e9t\u00e9 dans cette d\u00e9marche de conception par une conception automatique des services gr\u00e2ce \u00e0 l'ing\u00e9nierie des mod\u00e8les.ABSTRACT. The enterprise organization must fulfil its strategy. Processes describing enterprise business core and enterprise organizational structure enable enterprise to meet this objective. This paper concerns business process driven design of customer oriented services. The description of business processes from customer instead of the production department allows indeed service set providing to the customer by the enterprise. In order to satisfy enterprise objectives, the service design procedure is so based on the Enterprise Architecture (EA) system point of view, whether services are computerized or not. Our service design procedure benefits from EA\u00a0\u2026", "num_citations": "6\n", "authors": ["540"]}
{"title": "Software product lines for creating service-oriented applications\n", "abstract": " Service-oriented architectures and software product lines are currently two approaches that get a lot of attention in research and practice. They both promise to aid in the development of flexible, cost-effective software systems and to support a high level of reuse.These approaches to software development share a common goal. They both encourage an organization to reuse existing assets and capabilities rather than redeveloping them again and again for new systems. These approaches enable organizations to gain enormously on reuse. They are able to achieve many desired benefits such as productivity gains, decreased development costs, and improved time to market, higher reliability, and competitive advantage [32].", "num_citations": "6\n", "authors": ["540"]}
{"title": "Leveraging models from design-time to runtime. A live demo\n", "abstract": " This paper describes a demo which leverages models at designtime and runtime in the context of adaptive system, some details about the underlying approach as well as some implementation details. Our tool allows deploying and dynamically reconfiguring component-based applications, in a guided and safe way, based on the OSGi platform. It combines reflexive and generative programming techniques, based on models, to achieve this goal.", "num_citations": "6\n", "authors": ["540"]}
{"title": "A MDA Approach to Model & Implement Transformations\n", "abstract": " Only in software and in linguistics a model has the same nature as the thing it models. In software at least, this opens the possibility to automatically derive software from its model. This property is well known from any compiler writer (and others), but it was recently be made quite popular with an OMG initiative called the Model Driven Architecture (MDA). The model transformations allowing the engineers to more or less automatically go from platform-independent models (PIM) to platform-specific models (PSM) are increasingly seen as vital assets that must be managed with sound software engineering principles. We believe that transformations should be first-class models in the MDA world; we propose to adopt the object-oriented approach and to leverage the expressive power of UML as a metamodel defining the transformation language.", "num_citations": "6\n", "authors": ["540"]}
{"title": "Object-oriented design of real-time telecom systems\n", "abstract": " Many engineers are still reluctant to adopt advanced object oriented technologies (such as high modularity, dynamic binding, automatic garbage collection, etc.) for embedded systems with real time constraints, because of their supposed inefficiency. We set ourselves into the context of building telecommunication systems with a standard object oriented analysis and design approach. We describe how we use relevant design patterns, followed with an implementation in a pure object oriented language (Eiffel) to conciliate the needed efficiency with the benefits of the object oriented approach-flexibility, dynamic configurability, maintainability, portability etc. We discuss a case study based on the implementation of SMDS (Switched Multi-megabits Data Service) servers featuring high throughput and low delay transmissions and respecting the real time constraints of SMDS.", "num_citations": "6\n", "authors": ["540"]}
{"title": "Parallelizing object oriented software through the reuse of parallel components\n", "abstract": " Archive ouverte HAL - Parallelizing Object Oriented Software through the Reuse of Parallel Components Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00494950, version 1 Article dans une revue Parallelizing Object Oriented Software through the Reuse of Parallel Components Jean-Marc J\u00e9z\u00e9quel 1 Fr\u00e9d\u00e9ric Guidec 1 Franck Hamelin 1 D\u00e9tails 1 PAMPA - Models and Tools for Programming Distributed Parallel Architectures IRISA - Institut de Recherche en Informatique et Syst\u00e8mes Al\u00e9atoires, INRIA \u2026", "num_citations": "6\n", "authors": ["540"]}
{"title": "A model-based approach for optimizing power consumption of IaaS\n", "abstract": " Virtual Machine Image (VMI) provisioning is an important process of Infrastructure as a Service delivery model to provide virtual images in Cloud Computing. The power consumption and energy efficiency of VMI provisioning process depend not only on the hardware infrastructure, but also on the VMI\\,'s configuration, which helps to compose, configure and deploy VMIs in Cloud Computing environments. The major issue of improving the energy efficiency of VMI provisioning process is how to reduce the power consumption while ensuring the compatibility of software components installed in a virtual machine image. This paper describes a model-driven approach to improve the energy efficiency of VMI provisioning in Cloud Computing. This approach considers virtual images as product lines and uses feature models to represent their configurations. It uses model-based techniques to handle VMI specialization\u00a0\u2026", "num_citations": "5\n", "authors": ["540"]}
{"title": "Specifying and implementing ui data bindings with active operations\n", "abstract": " Modern GUI toolkits propose the use of declarative data bindings to link the domain data to their presentations. These approaches work fine for defining simple bindings, but require an increasing programming effort as soon as the bindings become more complex. In this paper, we propose the use of active operations for specifying and implementing UI data bindings to tackle this issue. We demonstrate that the proposed approach goes beyond the usual declarative data bindings by combining the simplicity of the declarative approaches with the expressiveness of active operations.", "num_citations": "5\n", "authors": ["540"]}
{"title": "Building a Kermeta Compiler using Scala: an Experience Report.\n", "abstract": " This paper presents an experience report of building a Kermeta compiler using Scala as a target language. Kermeta is a domain specific language inspired by languages such as Eiffel or OCL for specifying the operational semantics of metamodels. This engineering work, initially motivated by performance issues of our Kermeta interpreter, is an excuse to study and discuss some paradigm mismatches between Scala and Kermeta. We particulary discuss the mapping on Scala of Kermeta concepts :open classes, multiple inheritance, design by contracts, model type, etc.", "num_citations": "5\n", "authors": ["540"]}
{"title": "UML reflections\n", "abstract": " The UML shares with reflective architectures the idea that self-definition of languages and systems is a key principle for building and maintaining complex systems. The UML is now defined by a four-layer metalevel structure, enabling a flexible and extensible definition of models by metamodels, and even a self-description of the meta-metamodel (the MOF). This metalevel dimension of UMLis currently restricted to structural reflection. But recently a new extension to the UML, called the Action Semantics (AS), has been proposed for standardization to the OMG. This paper explores how this proposed extension brings a behavioural reflection dimension to the UML. Indeed, we show that it is not only possible but quite effective to use the AS for manipulating UMLmo dels (including the AS metamodel). Besides elegant conceptual achievements, such as a metacircular definition of the AS, reflective modeling with\u00a0\u2026", "num_citations": "5\n", "authors": ["540"]}
{"title": "Polymorphic matrices in paladin\n", "abstract": " Scientific programmers are eager to take advantage of the computational power offered by Distributed Computing Systems (DCSs), but are generally reluctant to undertake the porting of their application programs onto such machines. The DCS commercially available today are indeed widely believed to be difficult to use, which should not be a surprise since they are traditionally programmed with software tools dating back to the days of punch cards and paper tape. We claim that provided modern object oriented technologies are used, these computers can be programmed easily and efficiently. In EPEE, our Eiffel Parallel Execution Environment, we propose to use a kind of parallelism known as data-parallelism, encapsulated within classes of the Eiffel sequential object-oriented language, using the SPMD (Single Program Multiple Data) programming model. We describe our method for designing with this\u00a0\u2026", "num_citations": "5\n", "authors": ["540"]}
{"title": "Programming massively parallel architectures with sequential object oriented languages\n", "abstract": " Most parallel object oriented languages (OOL) are currently using a general parallelism model based on communicating sequential processes. This approach makes it difficult to program massively parallel systems in an easy and efficient way. So we propose to use another form of parallelism, known as data parallelism. We describe how it can be integrated in a given OOL in a clean and elegant fashion, using only already existing concepts -i.e. without modifying the OOL syntax and semantic to exploit the potential power of massively parallel systems. To illustrate our ideas, we present an application of this approach to a well known parallel paradigm, along with experimental performance results.", "num_citations": "5\n", "authors": ["540"]}
{"title": "Towards Adversarial Configurations for Software Product Lines\n", "abstract": " Ensuring that all supposedly valid configurations of a software product line (SPL) lead to well-formed and acceptable products is challenging since it is most of the time impractical to enumerate and test all individual products of an SPL. Machine learning classifiers have been recently used to predict the acceptability of products associated with unseen configurations. For some configurations, a tiny change in their feature values can make them pass from acceptable to non-acceptable regarding users' requirements and vice-versa. In this paper, we introduce the idea of leveraging these specific configurations and their positions in the feature space to improve the classifier and therefore the engineering of an SPL. Starting from a variability model, we propose to use Adversarial Machine Learning techniques to create new, adversarial configurations out of already known configurations by modifying their feature values. Using an industrial video generator we show how adversarial configurations can improve not only the classifier, but also the variability model, the variability implementation, and the testing oracle.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Integrating software process reuse and automation\n", "abstract": " Reusing software processes from a Software Process Line (SPL, i.e., a set of software processes that captures their commonalities and variabilities) and automating their execution is a way to reduce development costs. However, to our best knowledge no approach integrates both aspects. The difficulty is to automate the execution of a process whose variability is only partially resolved (i.e., a value is not set to each variable part of the process). Indeed, according to projects' constraints, it is possible to start the execution of a part of a process whose variability is resolved, while postponing the resolution of the variability of other parts of this process. In this paper, we propose a tool-supported approach that integrates both aspects. It consists of reusing processes from an SPL according to projects' requirements. The processes are bound to components that automate their execution. When the variability of a process to\u00a0\u2026", "num_citations": "4\n", "authors": ["540"]}
{"title": "Ing\u00e9nierie Dirig\u00e9 par les Mod\u00e8les: du design-time au runtime\n", "abstract": " Les mod\u00e8les sont utilis\u00e9s depuis longtemps en sciences et en ing\u00e9nierie comme un outil fondamental de gestion de la complexit\u00e9. La mod\u00e9lisation permet de s\u00e9parer des pr\u00e9occupations en abstrayant des aspects sp\u00e9cifiques de la r\u00e9alit\u00e9 pour des objectifs pr\u00e9cis. Cette approche est devenue relativement populaire ces derni\u00e8res ann\u00e9es pour faire face \u00e0 des pr\u00e9occupations d'analyse et de conception, en s'appuyant notamment sur des langages de mod\u00e9lisation de la famille d'UML. Bien s\u00fbr, la s\u00e9paration des pr\u00e9occupations est d'un int\u00e9r\u00eat limit\u00e9 si on ne peut pas recomposer ces pr\u00e9occupations automatiquement. La composition automatique de mod\u00e8les permet en effet de g\u00e9rer des variations de pr\u00e9occupations de conception par exemple dans le contexte d'op\u00e9rations de maintenance ou dans celui de l'ing\u00e9nierie des lignes de produits. Allant au-del\u00e0 de la r\u00e9solution de cette probl\u00e9matique dans les phases de conception, nous montrons comment la composition de mod\u00e8les peut aussi \u00eatre utilis\u00e9e pendant l'ex\u00e9cution d'un syst\u00e8me pour sp\u00e9cifier et g\u00e9rer des syst\u00e8mes logiciels dynamiquement adaptatifs, ici conceptualis\u00e9s comme des lignes de produits logiciels dynamiques. Montrant comment l'IDM \u00e0 l'ex\u00e9cution peut aider les ing\u00e9nieurs \u00e0 ma\u00eetriser la complexit\u00e9 des syst\u00e8mes adaptatifs tout en offrant un haut degr\u00e9 d'automatisation et de validation.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Definition of a New Level One Test Case Measurements of Equilibrium Radiation from an Inductively Coupled Plasma in the near-UV to near-IR spectral region for a Titan-type N2\u00a0\u2026\n", "abstract": " A test case, using a similar methodology and experimental set-up than previous test case TC5-Level 1 is presented in this paper. An inductively coupled plasma torch, working at atmospheric pressure, is used to create N2-CH4 Titan-like plasma (98%N2 - 2%CH4). The operating frequency and power are 64 MHz and 3 kW respectively. This kind of apparatus allows obtaining plasma in chemical and quasi-thermal equilibrium The spectral measurements cover the [300-800] nm range and are performed inside the induction coil. Each interesting spectrum is calibrated and compared to the line-by-line spectral code SPARTAN used for the simulation of the radiative emission of entry-type plasma. Finally, a discussion is proposed about the nucleation phenomenon which is occurred in the ICP torch with the N2-CH4 plasma. Preliminary studies show the synthesis of nanostructured carbon on the quartz tube.", "num_citations": "4\n", "authors": ["540"]}
{"title": "A model-driven process for self-adaptive software\n", "abstract": " Many Embedded Systems are supposed to run continuously, which includes recovering from errors by adapting their configuration or their architecture to changing conditions in their environment. The design of such systems has to relate some high-level extra-functional properties to some low level ones such as memory or CPU consumption by defining some complex feed-back loops for the dynamic adaptation of the system. However, the design of such feed-back loops (also called ``adaptation policies'') is still a very complex endeavour if you want to go beyond predefined fallback modes. Since the expression of extra-functional properties and the design of adaptation policies are complex activities, they are generally delayed down to implementation time. Adaptation policies are then implemented without either high level design nor dedicated tests, which may lead to costly roll-back operations in the design process. To avoid such roll-back operations, we suggest a model-driven process based on new executable meta-modelling techniques. At modelling time, designers have to complement the architectural description with some sensors and actuators related to the involved extra-functional properties. It allows designers to specify in a consistent way the related adaptation policies. Then since the model is executable, some simulations of the adaptation policies can be performed at design time to evaluate their performances with respect to some relevant test scenarios. Then, using model-driven transformations, it allows the generation of code skeletons for real-time embedded platforms. In this article we illustrate our approach with a simple case\u00a0\u2026", "num_citations": "4\n", "authors": ["540"]}
{"title": "Expression qualitative de politiques d'adaptation pour Fractal\n", "abstract": " Les plates-formes d'ex\u00e9cution r\u00e9centes telles que Fractal ou Open- COM offrent de nombreuses facilit\u00e9s pour assurer la prise en compte de propri\u00e9t\u00e9s extra-fonctionnelles (introspection, sondes, chargement dynamique, etc). Cependant, l'int\u00e9gration de politiques d'adaptation reste d\u00e9licate car elle n\u00e9cessite de corr\u00e9ler la configuration du syst\u00e8me avec l'\u00e9volution de son environnement. Le travail pr\u00e9sent\u00e9 dans cet article propose une description qualitative des \u00e9volutions de l'environnement et une interpr\u00e9tation possible bas\u00e9e sur de la logique floue. L'article pr\u00e9sente \u00e9galement une extension de la plate-formeFractal impl\u00e9mentant les m\u00e9canismes n\u00e9cessaires \u00e0 l'ex\u00e9cution de ces politiques d'adaptation de haut niveau. L'approche est illustr\u00e9e \u00e0 l'aide d'un serveur HTTP qui modifie sa configuration (architecturale et locale) en fonction de plusieurs param\u00e8tres extra-fonctionnels tels que la charge du serveur et la dispersion des requ\u00eates.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Modeling and aspect weaving\n", "abstract": " A model is a simplified representation of an aspect of the world for a specific purpose. Complex systems typically give rise to more than one model because many aspects are to be handled. For software systems, the design process can be characterized as a (partially automated) weaving of these aspects into a detailed design model. While verification is usually feasible on each of the aspects, it is seldom possible on the resulting detailed design because of the size explosion. Hence we need weaving processes that exhibit good composition properties from the point of view of verification. We present an example of such a weaving process for behavioral models represented as scenarios.", "num_citations": "4\n", "authors": ["540"]}
{"title": "An object-oriented framework for data parallelism\n", "abstract": " Distributed memory supercomputers are well known for being di cult to program. We believe that the object-orien ted framework technologies can be used to drastically reduce this apparent complexity. As an example, we describe a framework where the data parallel codes can be encapsulated in object-oriented software components that can be reused, combined and customized with con dence by library designers to o er application programmers easy to use programming models.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Bdl: a semantics backbone for uml dynamic diagrams\n", "abstract": " The UML (Unified Modelling Language) comprises various types of notations, to model the functional architecture, the behaviour of its components, and its deployment. Dynamic diagrams provide descriptions of the components and system behaviour. Examples of dynamic diagrams are collaboration and sequence diagrams to specify high level abstractions for sequences of actions involving several components of the system. Activity diagrams, state diagrams, and statecharts are used to specify the detailed behaviour of a single component. In this report we propose a new formalism, called BDL, to serve as a semantic backbone for dynamic diagrams of UML. BDL diagrams allow to provide a set of UML diagrams a global dynamic semantics. It allows to specify the behaviour of systems. It provides a common semantics to the different dynamic diagrams -this report analyses in detail sequence diagrams and statecharts. Composing components requires different types of communication, synchronous or asynchronous. While a precise description of these choices is essential at deployment stage, it is useful not to bother with this at early design stages. To this end, BDL supports a flexible, dual synchronous/asynchronous semantics for its communications. It provides sounded support for moving from synchronous to asynchronous communication while preserving dynamic semantics. We illustrate the use of BDL on a small example of service adaptation in telecommunications.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Making Components Contract Aware\n", "abstract": " Before we can trust a component in mission-critical applications, we must be able to determine, reliably and in advance, how it will behave.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Performance issues in implementing a portable SMDS server\n", "abstract": " Connectionless servers may be used to provide connectionless data services in ATM wide area networks. However, their performance might be a critical point, since, like with any other server, undersized connectionless servers might become bottlenecks in the network. This paper aims at providing some insight on this issue. We present the design and the implementation of a portable SMDS (Switched Multi-megabits Data Service) server, and discusses performance related aspects of a SMDS server-based connectionless network implemented in our laboratory. We conclude on the interest and perspectives of this kind of network architecture.", "num_citations": "4\n", "authors": ["540"]}
{"title": "A parallel execution environment for a sequential object oriented language\n", "abstract": " To efficiently program massively parallel systems we propose to use a form of parallelism known as data parallelism along with a SPMD programming model. We describe how a sequential Object Oriented Language (OOL) can embed data parallelism in a clean and elegant fashion\u2014without language extensions\u2014to exploit the potential power of massively parallel systems. To illustrate our ideas, we present EPEE (our OOL Parallel Execution Environment) and an application of this approach to a well known parallel paradigm. After some remarks on our implementation, we show experimental performance results and draw some conclusions on the generality of this approach.", "num_citations": "4\n", "authors": ["540"]}
{"title": "Conformance testing from uml specifications\n", "abstract": " UMLAUT is a framework for building tools dedicated to the manipulation of models described using the Unified Modeling Language (UML). TGV is a tool for the generation of conformance test suites for protocols. Both tools are connected so that it is possible to specify an application in UML and derive automatically some test cases. In this article, the integration of those tools in an industrial process is evaluated through a case study. This case study, proposed by Gemplus, is a Java Card applet: a classical electronic purse. 1", "num_citations": "4\n", "authors": ["540"]}
{"title": "Poster: Multimorphic Testing\n", "abstract": " The functional correctness of a software application is, of course, a prime concern, but other issues such as its execution time, precision, or energy consumption might also be important in some contexts. Systematically testing these quantitative properties is still extremely difficult, in particular, because there exists no method to tell the developer whether such a test set is \"good enough\" or even whether a test set is better than another one. This paper proposes a new method, called Multimorphic testing, to assess the relative effectiveness of a test suite for revealing performance variations of a software system. By analogy with mutation testing, our core idea is to vary software parameters, and to check whether it makes any difference on the outcome of the tests: i.e. are some tests able to \"kill\" bad morphs (configurations)? Our method can be used to evaluate the quality of a test suite with respect to a quantitative property\u00a0\u2026", "num_citations": "3\n", "authors": ["540"]}
{"title": "Relationships formalization for model-based product lines\n", "abstract": " Model-Based Engineering (MBE) and Product Line Engineering (PLE) have been combined, to handle new system development constraints like: increasing complexity, higher product quality and cost reduction. Many authors have pointed out the need of modularization in the variability and in the core assets space. Existing approaches focus on separating and delimiting concerns or providing generic composition mechanisms. In Model-Based Product Lines, with an increasing number of models to manage, organizing the modeling space becomes central to support product line consistency, maintenance and product derivation process. To organize the modeling space, we propose to precisely describe the dependencies among modeling artifacts and clarify their use. Thus, we introduce the Product Line Modeling Space (PLiMoS) language that specializes relationships, based on an intentional framework, for the\u00a0\u2026", "num_citations": "3\n", "authors": ["540"]}
{"title": "Un processus \u00e0 base de mod\u00e8les pour les syst\u00e8mes auto-adaptatifs\n", "abstract": " De plus en plus de syst\u00e8mes embarqu\u00e9s ont un fonctionnement continu qui n\u00e9cessite, de la part du syst\u00e8me, une capacit\u00e9 d'adaptation aux changements susceptibles de survenir dans son environnement. La conception de ces syst\u00e8mes passe invariablement par la conception de boucles de contr\u00f4le impliquant de nombreuses propri\u00e9t\u00e9s extra fonctionnelles (m\u00e9moire, puissance, CPU, bande passante, etc) et qui ajustent la l'architecture et la configuration du syst\u00e8me aux variations de l'environnement. Si ce principe de boucle de contr\u00f4le est bien connu des concepteurs, il n'est pourtant pas int\u00e9gr\u00e9 dans le processus de d\u00e9veloppement logiciel. L'adaptation du syst\u00e8me \u00e0 son environnement est impl\u00e9ment\u00e9e de mani\u00e8re adhoc par le d\u00e9veloppeur, comme le serait une optimisation. Nous proposons donc, dans cet article, un processus de d\u00e9veloppement bas\u00e9 sur les mod\u00e8les, combinant l'architecture logicielle du syst\u00e8me et ses capacit\u00e9s d'adaptation. Il permet au concepteur de se focaliser, d\u00e8s la conception, sur les probl\u00e9matiques li\u00e9es \u00e0 l'adaptation et de valider ces mod\u00e8les par le biais de simulations.", "num_citations": "3\n", "authors": ["540"]}
{"title": "Model-driven engineering metrics for real time systems\n", "abstract": " As with other software development processes, model-driven engineering of real time software systems include quality assurance and measurement. Model-driven engineering (MDE) supports the development of real-time software systems by means of a set of languages, processes, methods and tools. To measure the models, a dedicated measurement software has to be developed, which is costly. In this paper, we propose a framework to concisely define and automatically implement an open-ended family of metrics for real-time software systems. The overall contribution of this approach is to give an instant, reliable and low cost implementation of model metrics seamlessly integrated into modeling tools", "num_citations": "3\n", "authors": ["540"]}
{"title": "Vers des Lignes de Produits Flexibles\n", "abstract": " Afin de faire face \u00e0 la complexit\u00e9 du logiciel due \u00e0 la variabilit\u00e9 de ses environnements et de ses utilisations, l'ing\u00e9nierie des lignes de produits permet d'important gains en termes de co\u00fbts et de qualit\u00e9 de d\u00e9veloppement en syst\u00e9matisant la r\u00e9utilisation d'\u00e9l\u00e9ments communs. N\u00e9anmoins, les approches actuelles manquent de flexibilit\u00e9 dans la prise en compte des exigences particuli\u00e8res \u00e0 un utilisateur. Nous illustrons ici comment, en utilisant des techniques d'ing\u00e9nierie des mod\u00e8les telles que la composition et la transformation et en les outillant dans l'environnement de m\u00e9tamodelisation Kermeta, il est possible de concilier flexibilit\u00e9 et efficacit\u00e9 lors de la d\u00e9rivation de produits.", "num_citations": "3\n", "authors": ["540"]}
{"title": "L'ing\u00e9nierie des mod\u00e8les\n", "abstract": " Ce que propose l'approche de l'ing\u00e9nierie des mod\u00e8les (IDM, ou MDE en anglais pour Model Driven Engineering) est de m\u00e9caniser le processus que les ing\u00e9nieurs exp\u00e9riment\u00e9s suivent \u00e0 la main. M{\u00ea}me s'il existe une longue exp\u00e9rience de l'utilisation de l'ing\u00e9nierie des mod\u00e8les dans certains domaines comme les t\u00e9l\u00e9coms, sa g\u00e9n\u00e9ralisation \u00e0 l'ensemble de l'industrie n'en est qu'\u00e0 ses d\u00e9buts. Visant \u00e0 automatiser une partie du processus du d\u00e9veloppement, elle requiert un effort d'abstraction plus important de la part des d\u00e9veloppeurs. En contrepartie, elle permet de conserver le savoir faire de conception proche des centres de d\u00e9cision, gr", "num_citations": "3\n", "authors": ["540"]}
{"title": "Patrons de conception\n", "abstract": " La d\u00e9finition de la nature de l'activit\u00e9 de conception de logiciel est rest\u00e9e longtemps assez floue. La g\u00e9n\u00e9ralisation dans l'industrie d'une approche par objets de la conception de logiciel a permis de focaliser la t", "num_citations": "3\n", "authors": ["540"]}
{"title": "Model-driven engineering with contracts, patterns, and aspects\n", "abstract": " \u220e A model represents reality for the given purpose; the model is an abstraction of reality in the sense that it cannot represent all aspects of reality. This allows us to deal with the world in a simplified manner, avoiding the complexity, danger and irreversibility of reality.", "num_citations": "3\n", "authors": ["540"]}
{"title": "The design of gccl: a generalized common contract language\n", "abstract": " Following its inception in Eiffel by Meyer and its diffusion to other environments (e.g., the standardisation of OCL as part of UML), Design by Contract now faces a major challenge in component-based software engineerin- g (CBSE). Compositional reasoning about system properties from component ones has been recently asserted by the SEI as the \"key technical challenge\" of CBSE, and contracts as a \"key technical concept to support this vision\". To live up to these expectations, DbC must tackle extra-functional properties of components and support Klein's \"architectural-based attribute reasoning.\" Besides adopting the necessary new concepts, a good contract language must provide for abstraction, application, composition and scoping mechanisms in such a way to be used from modeling in UML to programming in standard languages (as seamless extensions to Java, C#, C++, Eiffel, and so on) through execution on traditional operating systems with minimal middleware additions. This paper examines conceptual foundations and design decisions to propose GCCL, a novel open generalized common contract language. GCCL is meant to be compatible with existing DbC (sub)languages, and especially OCL.", "num_citations": "3\n", "authors": ["540"]}
{"title": "Product line engineering with uml\n", "abstract": " The Unified Modeling Language (UML) is a standard language for the object-oriented analysis and design. We propose in this paper an approach based on the UML that supports the Product Line Engineering. We provide a set of patterns for modeling variability issues of a Product Line Architecture, we define architectural constraints for Product Line expressed in UML as meta-level OCL constraints, and we propose a method based on the use of a creational design pattern to automate the derivation process. This makes it possible to automatically derive a given product from the set of all possible ones, and to specialize its model accordingly.", "num_citations": "3\n", "authors": ["540"]}
{"title": "An approach to integrate formal validation in an OO life-cycle of protocols\n", "abstract": " Despite excellent results on pilot projects, formal validation based on standard Formal Description Techniques (FDTs) never really catch up in the industry. We claim that this is mainly due to standard FDTs lack of support for the modern software development methods and life-cycles needed in the construction and maintenance of open distributed systems. We propose to go the other way round, that is to integrate formal validation technology within well established object-oriented (OO) development methods. Building on the intuition that a universal language taking into account all the possible semantics aspects of parallelism and communication is a holy grail, we propose to rely on an open (but simpler) OO language to build dedicated frameworks. Such frameworks can be specialized toward classes of distributed applications, and integrate formal validation tools. We illustrate our approach using the\u00a0\u2026", "num_citations": "3\n", "authors": ["540"]}
{"title": "Operator design pattern, application to parallel computation\n", "abstract": " Archive ouverte HAL - Operator design pattern, application to parallel computation Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00765493, version 1 Communication dans un congr\u00e8s Operator design pattern, application to parallel computation Jean-Marc J\u00e9z\u00e9quel 1 Jean-Lin Pacherie 1 D\u00e9tails 1 PAMPA - Models and Tools for Programming Distributed Parallel Architectures IRISA - Institut de Recherche en Informatique et Syst\u00e8mes Al\u00e9atoires, INRIA Rennes Type de document : Communication dans \u2026", "num_citations": "3\n", "authors": ["540"]}
{"title": "Impact of Data Cleansing for Urban Bus Commercial Speed Prediction\n", "abstract": " Public Transportation Information Systems (PTIS) are widely used for public bus services amongst cities in the world. These systems gather information about trips, bus stops, bus speeds, ridership, etc. This massive data are an inviting source of information for machine learning predictive tools. However, it most often suffers from quality deficiencies, due to multiple data sets with multiple structures, to different infrastructures using incompatible technologies, to human errors or hardware failures. In this paper, we consider the impact of data cleansing on a classical machine-learning task: predicting urban bus commercial speed. We show that simple, transport specific business and quality rules can drastically enhance data quality, whereas more sophisticated rules may offer little improvements despite a high computational cost.", "num_citations": "2\n", "authors": ["540"]}
{"title": "M\u00e9thodes d'analyse et de mod\u00e9lisation agro climatique et de changement climatique \u00e0 l'\u00e9chelle des terroirs viticoles\n", "abstract": " UNIV-PARIS1| UNIV-NANTES| EPHE| INSU| CNRS| UNIV-BREST| LETG-COSTEL| LETG| LAMP| PRES_CLERMONT| INRA| PRODIG-PUBLICATIONS| UR2-HB| AGROPARISTECH| PARISTECH| UNIV-ANGERS| UNIV-RENNES2| COMUE-NORMANDIE| UNIV-RENNES| UNICAEN| SORBONNE-UNIVERSITE| UNIV-PARIS7| USPC| CAMPUS-CONDORCET| SU-LETTRES| INRAE| UP-SOCIETES-HUMANITES| PSL", "num_citations": "2\n", "authors": ["540"]}
{"title": "Bridging the Gap between Software Process and Software Development\n", "abstract": " Model Driven Engineering (MDE) benefits software development (a.k.a. Model Driven Software Development) as well as software processes (a.k.a. Software Process Modeling). Nevertheless, the gap between processes and development is still too great. Indeed, information from processes is not always used to improve development and vice versa. For instance, it is possible to define the development tools used in a process description without linking them to the real tools. This position paper illustrates the need for bridging the gap between software process and software development, using MDE. A real industrial software process is shown as an example.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Aspect-Oriented Modeling to Support Dynamic Adaptation\n", "abstract": " Since software systems need to be continuously available under varying conditions, their ability to evolve at runtime is increasingly seen as one key issue. Modern programming frameworks already provide support for dynamic adaptations. However the high-variability of features in Dynamically Adaptive Systems (DAS) introduces an explosion of possible runtime system configurations (often called modes) and mode transitions. Designing these configurations and their transitions is tedious and errorprone, making the system feature evolution difficult. This demo presents a tool-chain developed by the DiVA project, which combines AOM and Model-Driven Engineering to tame the combinatorial explosion of DAS modes. Using AOM techniques, we derive a wide range of modes by weaving aspects into an explicit model reflecting the runtime system. We use these generated modes to automatically adapt the system using MDE techniques.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Introduction to Model-Driven Engineering\n", "abstract": " Introduction to Model- Driven Engineering Page 1 1 Introduction to ModelDriven Engineering Prof. Jean-Marc J\u00e9z\u00e9quel (Univ. Rennes 1 & INRIA) Triskell Team @ IRISA Campus de Beaulieu F-35042 Rennes Cedex Tel : +33 299 847 192 Fax : +33 299 847 171 e-mail : jezequel@irisa.fr http://www.irisa.fr/prive/jezequel (or: Why I'd like write program that write programs rather than write programs) \u00a9 J.-M. J\u00e9z\u00e9quel, Sep-13 2 Who (does not) know this? \u220e Rovio\u2019s Angry Bird \u2013 more than 1.7 billion downloads \u2013 hundreds of millions of monthly active users \u2013 Revenue > $500M Page 2 2 \u00a9 J.-M. J\u00e9z\u00e9quel, Sep-13 3 How would you build Angry Birds? \u220e Only from a technical perspective \u2013 Leaving away the Art Design & brilliant marketing \u220e The game is physics-based \u2013 you adjust the trajectory and power of the slingshot with your finger \u220e Architecture? \u00a9 J.-M. J\u00e9z\u00e9quel, Sep-13 4 Additional issues \u2013 Frameworks: Box2d, \u2026", "num_citations": "2\n", "authors": ["540"]}
{"title": "QCCS: Quality controlled component-based software development\n", "abstract": " QCCS is an European 1ST project that is developing and evaluating a new design methodology for software components. The QCCS methodology simplifies the development process of components that have formally specified non-functional properties. The approach is heavily based on UML because it tries to tackle the problem already during the design phase. QCCS provides a means for modelling contracts aware components and their assembly in UML. Besides the specification process we support the concrete design and implementation of such components.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Protocol engineering using UML\n", "abstract": " En d\u00e9pit de l\u2019int\u00e9r\u00eat croissant pour les m\u00e9thodes formelles et leurs outils de validation et v\u00e9rification asso ci\u00e9s, le d\u00e9veloppement des syst\u00e8mes r\u00e9partis les ignore le plus souvent. Cela est d\u00fb, d\u2019apr\u00e8s les auteurs, principalement \u00e0 leur non-int\u00e9gration dans les cycles modernes de d\u00e9veloppement logiciel. La construction et la maintenance des syst\u00e8mes r\u00e9partis ouverts sont pour la plupart fond\u00e9s sur un d\u00e9veloppement. L\u2019article \u00e9tudie un cadre de conception UML (unified modeling language) pour \u00e9quiper le processus de d\u00e9veloppement objet avec des outils de validation formelle et montre comment des techniques de validation classiques peuvent \u00eatre utilis\u00e9es d\u00e8s maintenant sur des mod\u00e8les UML en exploitant des informations contenues dans les diagrammes de classes et de d\u00e9ploiement, et en utilisant une s\u00e9mantique op\u00e9rationnelle des diagrammes d\u2019\u00e9tat. Il pr\u00e9sente aussi comment les vues\u00a0\u2026", "num_citations": "2\n", "authors": ["540"]}
{"title": "A simple dynamic load-balancing scheme for parallel molecular dynamics simulation on distributed memory machines\n", "abstract": " We propose a simple and efficient load-balancing scheme for parallel molecular dynamics simulation on distributed memory machines. It decomposes spatial domain of particles into disjoint parts, each of which corresponds with a processor and dynamically changes its shape to keep about the same number of particles throughout the simulation. In contrast to other similar schemes, ours requires no long-distance inter-processor communications but only those among adjacent processors (thus little communication overheads), whereas it still guarantees fast reduction of load-imbalance among the processors. It owes these advantages mainly to the following features: (1) The sufficiently correct global load information is effectively obtained with step-wise propagation of appropriate information via nearest neighbor communication. (2) In addition to the global load-balancing, another load-balancing procedure is\u00a0\u2026", "num_citations": "2\n", "authors": ["540"]}
{"title": "Object-Oriented Frameworks for Distributed Systems: A Survey\n", "abstract": " Object-oriented frameworks are gaining importance to help reduce development efforts in large complex systems. They help developers leverage the knowledge of experienced domain experts, thus reducing the complexity of the development of large systems. Distributed applications are inherently complex and are therefore difficult to develop. Frameworks are used to hide away these complex issues, freeing the developer to concentrate on the application requirements instead. This paper will present an overview of object oriented frameworks and describe a few example frameworks targetted for distributed applications development. It will conclude by stating future trends in frameworks and a suggestion of promising areas of interest for research.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Conception et implantation d'un serveur SMDS sur architectures modulaires\n", "abstract": " Nous nous proposons d'etudier ici l'int er^ et d'utiliser des architectures parall eles am emoire distribu ee pour r ealiser une maquette de serveur SMDS (Switched Multi-megabit Data Service) pour r eseau haut-d ebit de type ATM. Ce type de serveur a des fonctionnalit es de routage et de commutation, de multicast optimis e, et de gestion de la congestion. Nous d ecrivons notre d emarche de r ealisation de cette maquette, qui repose sur l'adoption d'une m ethode d'analyse et de conception par objets (OMT), prolong ee par a une implantation en Ei el, que nous avons pu porter sur di erentes architectures. Gr^ ace a une implantation sur machine r eellement parall ele (Paragon XP/S, ou chaque processeur joue soit le r^ ole d'un g en erateur de tra c, soit le r^ ole d'un serveur SMDS), nous avons exp eriment e en vrai parall elisme le comportement fonctionnel des di erents protocoles de SMDS, et etudi e dans la premi ere phase de ce projet une parall elisation par simple duplication des serveurs. Ceci nous ad ej a permis d'obtenir des performances int eressantes, que nous analysons.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Programming massively parallel architectures with sequential object oriented languages\n", "abstract": " Most parallel object oriented languages (OOL) are currently using a general parallelism model based on communicating sequential processes. This approach makes it difficult to program massively parallel systems in an easy and efficient way. So we propose to use another form of parallelism, known as data parallelism. We describe how it can be integrated in a given OOL in a clean and elegant fashion, using only already existing concepts \u2014 i.e. without modifying the OOL syntax and semantics \u2014 to exploit the potential power of massively parallel systems. To illustrate our ideas, we present an application of this approach to a well known parallel paradigm, along with experimental performance results.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Parall\u00e9lisation d'un routeur XTP\n", "abstract": " Nous \u00e9tudions dans cet article la faisabilit\u00e9 d'utiliser des machines parall\u00e8les \u00e0  m\u00e9moire distribu\u00e9e \u00e0 usage g\u00e9n\u00e9ral pour r\u00e9aliser des fonctions de r\u00e9seaux haut d\u00e9bit. Nous nous sommes int\u00e9ress\u00e9s au probl\u00e8me de la commutation dans le cadre du protocole XTP (protocole de gestion des couches r\u00e9seau et transport pour les r\u00e9seaux haut d\u00e9bit). Cette \u00e9tude s'appuie sur les outils g\u00e9n\u00e9raux d\u00e9velopp\u00e9s dans le projet PAMPA (m\u00e9thodes et outils de parall\u00e9lisation et de validation) et a donn\u00e9 lieu \u00e0 une \u00e9valuation de performance en fonction des types et tailles de machines utilis\u00e9es.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Un compilateur Estelle multi-processeurs pour l'exp\u00e9rimentation d'algorithmes distribu\u00e9s sur machines parall\u00e8les\n", "abstract": " R\u00e9sum\u00e9 Ce rapport pr\u00e9sente dans le d\u00e9tail un outil de g\u00e9n\u00e9ration de code parall\u00e8le \u00e0. partir de descriptions formelles d\u2019algorithmes distribu\u00e9s exprim\u00e9es dans le langage Estelle. Nous avons consid\u00e9r\u00e9 un contexte assez simple de distribution, o\u00f9 l\u2019on traite un sous-ensemble \u201cstatique\u201d d\u2019Estelle et o\u00f9 la machine cible est homog\u00e8ne (exemple du calculateur iPSC). Nous commen\u00e7ons par pr\u00e9senter et justi\ufb01er le concept d\u2019exp\u00e9rimentation d\u2019algorithmes distribu\u00e9s sur machines parall\u00e8les, pour lequel notre compilateur Estelle a \u00e9t\u00e9 con\u00e7u. Nous discutons alors comment les constructions Estelle ont \u00e9t\u00e9 cod\u00e9es dans des structures du langage C, et comment elles sont interpr\u00e9t\u00e9es par un noyau d\u2019ex\u00e9cution distribu\u00e9. Des annexes techniques donnent une id\u00e9e pr\u00e9cise de l\u2019\u00e9tat actuel de l\u2019outil r\u00e9alis\u00e9, appel\u00e9 Echidna.", "num_citations": "2\n", "authors": ["540"]}
{"title": "Interacto: A Modern User Interaction Processing Model\n", "abstract": " Since most software systems provide their users with interactive features, building user interfaces (UI) is one of the core software engineering tasks. It consists in designing, implementing and testing ever more sophisticated and versatile ways for users to interact with software systems, and safely connecting these interactions with commands querying or modifying their state. However, most UI frameworks still rely on a low level model, the bare bone UI event processing model. This model was suitable for the rather simple UIs of the early 80s (menus, buttons, keyboards, mouse clicks), but now exhibits major software engineering flaws for modern, highly interactive UIs. These flaws include lack of separation of concerns, weak modularity and thus low reusability of code for advanced interactions, as well as low testability. To mitigate these flaws, we propose Interacto as a high level user interaction processing model. By\u00a0\u2026", "num_citations": "1\n", "authors": ["540"]}
{"title": "Introduction to the special section on best papers from SEAMS 2014\n", "abstract": " This special section in the current issue of TAAS, which consists of revised and extended versions of 4 selected papers that were originally presented at the 9th ACM/IEEE International Symposium on Software Engineering for Adaptive and Self-Managing Systems (SEAMS 2014). The symposium was held in Hyderabad, India, on June 2 and 3, 2014, and was co-located with the 36th International Conference on Software Engineering (ICSE 2014). We received 80 full paper submissions for review. Of these, 18 papers were accepted and classified into 15 long papers and 3 short papers. The acceptance rate was therefore 22.5%, which is comparable to those of previous editions of SEAMS. SEAMS brings together researchers and practitioners from diverse areas, such as biologically inspired computing, artificial intelligence, machine learning, and control systems, to investigate, discuss, and examine thoroughly the\u00a0\u2026", "num_citations": "1\n", "authors": ["540"]}
{"title": "Using Path-Dependent Types to Build Type Safe JavaScript Foreign Function Interfaces\n", "abstract": " The popularity of statically typed programming languages compiling to JavaScript shows that there exists a fringe of the programmer population interested in leveraging the benefits of static typing to write Web applications. To be of any use, these languages need to statically expose the Web browser dynamically typed native API, which seems to be a contradiction in terms. Indeed, we observe that existing statically typed languages compiling to JavaScript expose the browser API in ways that either are not type safe, or when they are, typically over constrain the programmers. This article presents new ways to encode the challenging parts of the Web browser API in static type systems such that both type safety and expressive power are preserved. Our first encoding relies on type parameters and can be implemented in most mainstream languages but drags phantom types up to the usage sites. The second\u00a0\u2026", "num_citations": "1\n", "authors": ["540"]}
{"title": "Vers un rapprochement de l'IDM et de la compilation\n", "abstract": " L'ing\u00e9nierie dirig\u00e9e par les mod\u00e8les (IDM) s'int\u00e9resse \u00e0 la d\u00e9finition de syst\u00e8mes complexes par leur repr\u00e9sentation et leur abstraction \u00e0 l'aide de langages de mod\u00e9lisation d\u00e9di\u00e9s \u00e0 un domaine. Le domaine de la compilation s'int\u00e9resse quant \u00e0 lui \u00e0 des analyses et \u00e0 des traitements complexes sur des structures de donn\u00e9es (depuis les analyses lexicale et syntaxique jusqu'\u00e0 l'optimisation par rapport \u00e0 la cible d'ex\u00e9cution). Motiv\u00e9es par des objectifs initiaux diff\u00e9rents, ces deux communaut\u00e9s ont longtemps men\u00e9 des travaux qui apparaissent aujourd'hui comme compl\u00e9mentaires et qui convergent vers le domaine de l'\" ing\u00e9nierie des langages \". Ce domaine aborde toutes les phases du cycle de vie d'un langage, depuis sa d\u00e9finition jusqu'\u00e0 son usage. Pour cela elle regroupe des besoins en terme de d\u00e9veloppement et d'outillage des langages. Dans cet article nous analysons les apports de l'IDM et de la compilation \u00e0 l'ing\u00e9nierie des langages. Nous dressons ensuite un panorama des verrous \u00e0 lever pour permettre une fertilisation crois\u00e9e de ces deux communaut\u00e9s.", "num_citations": "1\n", "authors": ["540"]}
{"title": "Monitoring your lego mindstorms with giotto\n", "abstract": " In the domain of soft real-time application design, the gap between component-specification models and their implementations often implies that the implementations cannot fully take advantage of the specification models. The component's time behaviour is not always used during the implementation process by the targeted programming languages because they cannot deal easily with time. In this presentation we propose a complete model transformation chain to generate monitors from time specification. We demonstrate the applicability of this approach for monitoring a Lego MindstormsTM application with Giotto platform.", "num_citations": "1\n", "authors": ["540"]}
{"title": "Reifying the semantic domains of component contracts\n", "abstract": " In domains such as automotive or avionics, software cannot any longer be produced as a single chunk, and engineers are contemplating the possibility of componentizing it. A component only exhibits its provided or required interfaces, which must be enriched to take into account extra-functional aspects. This defines multi-level contracts between components allowing one to properly wire them. Instead of defining an integrated language only making available a limited set of concepts for modeling extra-functional aspects, we propose to handle open-ended modeling of extra-functional aspects of real-time and embedded systems, based on meta-modeling techniques and Model Driven Engineering (MDE) for reifying their semantics. Then the designer can use off-the-shelf tools to perform various kinds of design time analysis.", "num_citations": "1\n", "authors": ["540"]}
{"title": "Reusable MDA Components: A Testing-for-Trust Approach\n", "abstract": " Making model transformations trustable is an obvious target for model-driven development since they impact on the design process reliability. Ideally, model transformations should be designed and tested so that they may be used and reused safely as MDA components. We present a method for building trustable MDA components. We first define the notion of MDA component as composed of its specification, one implementation and a set of associated test cases. The testing-for-trust approach checks the consistency between these three facets using the mutation analysis. It points out the lack of efficiency of the tests and the lack of precision of the specification. The mutation analysis thus gives a rate that evaluates: the level of consistency between the component\u2019s facets and the level of trust we can have in a component. Relying on this estimation of the component trustability, developers can consciously trade reliability for resources.", "num_citations": "1\n", "authors": ["540"]}
{"title": "Contract spaces for trusted components\n", "abstract": " @ A! BDCFEHGPI9QRCSIUTWVX YAb a% EdcfebghGiCSep CSIbqD@ AsrtB'A@ vuGhg! uGPw0ebGhE xy H FGPEdE a% yc GP $ TiX tY1 F td 7A egfbh i jWkmlni oqps rit uivFw xzy|{iuS} yi yR $ p0 F t $ vS $ pmw pP zy hw\u00a4 wt vm xzw P mx| w 1 hy wd $ y $ Sw x| w 8 pP| w xR h tw y y\u00a6 n W y $ x%| mwg w vmx| wy| y| $ p7 nw vSw p mw pwy\u00a4 nn fw xzwph zw x| $ wy\u00a4 mvS $ p xzw P mx| w hpmw y yw Fw w hw p (t hpP| x $ y\u00a6|\u00a1 w $ w $ v\u00a2| xz yR| w\u00a3 $ vS $ pmw ph y 3| yi yR $ p\u00a3 x n yRw y\u00a4| mw y| y| mw $3 w vFw pw pF twy\u00a5 Swt\u00a6 wwpn fw xzw s $ ps xzw P m xzw s $ pP| x $ t zy oqp| my vF PyR| $ pv nvSw xf 3w\u00a4 vmxz n \u00a7 vS hy| w yRw $ w xz $9 t hp yR| xz yv z wt vm\u00a5| wy| w\u00a4 w vFw pwptwy%\u00a9 0\u00aaR \u00ab\u00ac WF\u00ae dz $\u00ab\u00ae\u00b1!\u00ab\u00ac WF\u00ae d| h \u00abt\u00ae \u00b2 $ \u00b3qm\u00b3 S\u00b2h\u00b3tf \u00abt\u00b5 \u00ab\u00b6 n\u00b7 i\u00b1t\u00b3t\u00b1np g\u00b7 f \u00abt\u00ae H\u00b9\u00ac WfW\u00b6 \u00ba\u00b6 s\u00b5 \u00b2h\u00b3\u00bb \u00b3 S\u00b2 $ \u00b3\u00ae S|\u00ac m\u00b3\u00ae d\u00b9 \u00b3t\u00b1% oqp h mx\u00a5 iw\u00a4 F z mw y| wt $ pFy\u00a6 zx| t zy vmxz Wi w% $ x z mw w \u00bc pm| $ pn U t hph zxz hn yR| x $ t| $ p \u00ff mw x| w $ Sw x| w\u00a6 $ pP| x $ t zyb $ p\u00a6 Sw th vm| w \u00bd w tw \u00be xz $\u00bf yz W z yR\u00bc w xzw P m xzw t hp yR| x n ph y $| mw x| w $ xzw vmxz t pm\u00c01 \u00ab\u00ac n\u00ae H| $\u00ab\u00ae b\u00b1Hmh \u00abz\u00b3t\u00b1x W z mw x| $ p yR pm\u00c0h w $ pP| x $ t zy b \u00c1w% yz t yzy| mw\u00a4 xzw P m xzw w pP zy $ p 8 yRw ynb yR th vF hpmw pP t hph zxz hwy", "num_citations": "1\n", "authors": ["540"]}