{"title": "Kronos: A verification tool for real-time systems\n", "abstract": " The main purpose of this paper is to explain how to use Kronos, a tool for formally checking whether a real-time system meets its requirements. Kronos is founded on the theory of timed automata and timed temporal logics.", "num_citations": "973\n", "authors": ["1619"]}
{"title": "The tool KRONOS\n", "abstract": " Both approaches presented in this paper considerably improve Kronos performance and functionalities. Forward analysis permits handling examples with a large number of clocks, as the example of the FDDI protocol shows: up to 25 clocks, which, to our knowledge, exceeds the clock-space dimension of similar examples treated in the literature. Moreover, this method is capable of providing a counter-example sequence, as a diagnosis in the case a system fails to verify an invariance or bounded response property. Minimization considerably reduces the number of states and transitions of large systems, as the example of Fischer's protocol illustrates. It also allows for further analysis, using standard techniques for untimed systems, such as comparison and reduction with respect to behavioral equivalences. The combination of timed and untimed minimization allowed us to discover the problem of starvation in the first\u00a0\u2026", "num_citations": "718\n", "authors": ["1619"]}
{"title": "A new class of decidable hybrid systems\n", "abstract": " One of the most important analysis problems of hybrid systems is the reachability problem. State of the art computational tools perform reachability computation for timed automata, multirate automata, and rectangular automata. In this paper, we extend the decidability frontier for classes of linear hybrid systems, which are introduced as hybrid systems with linear vector fields in each discrete location. This result is achieved by showing that any such hybrid system admits a finite bisimulation, and by providing an algorithm that computes it using decision methods from mathematical logic.", "num_citations": "279\n", "authors": ["1619"]}
{"title": "Symbolic reachability computation for families of linear vector fields\n", "abstract": " The control paradigm of physical processes being supervised by digital programs has lead to the development of a theory of hybrid systems combining finite state automata with differential equations. One of the most important problems in the verification of hybrid systems is the reachability problem. Even though the computation of reachable spaces for finite state machines is well developed, computing the reachable space of a differential equation is difficult. In this paper, we present the first known families of linear differential equations with a decidable reachability problem. This is achieved by posing the reachability computation as a quantifier elimination problem in the decidable theory of the reals. We illustrate the applicability of our approach by performing computations using the packages Redlog and Qepcad. Such symbolic computations can be incorporated in computer-aided verification tools for purely\u00a0\u2026", "num_citations": "273\n", "authors": ["1619"]}
{"title": "Model checking timed automata\n", "abstract": " The theory of timed automata provides a formal framework to model and to verify the correct functioning of real-time systems. Among the different verification problems that have been investigated within this theory, the so-called reachability problem has been the most throughly studied. This problem is stated as follows. Given two states of the system, is there an execution starting at one of them that reaches the other? The first reason for studying such problem is that safety properties can expressed as the non-reachability of a set of states where the system is consider to show an incorrect or unsafe functioning. Second, the algorithms developed for analyzing other classes of properties are essentially based on the algorithms developed for solving the reachability question. In this paper we survey the different algorithms, data-structures and tools that have been proposed in the literature to solve this problem.", "num_citations": "256\n", "authors": ["1619"]}
{"title": "Analysis of timed systems using time-abstracting bisimulations\n", "abstract": " The objective of this paper is to show how verification of dense-time systems modeled as timed automata can be effectively performed using untimed verification techniques. In that way, the existing rich infrastructure in algorithms and tools for the verification of untimed systems can be exploited. The paper completes the ideas introduced in (Tripakis and Yovine, 1996, in Proc. 8th Conf. Computer-Aided Verification, CAV'96, Rutgers, NJ. LNCS, Vol. 1102, Springer-Verlag, 1996, pp. 232\u2013243).               Our approach consists in two steps. First, given a timed system A, we compute a finite graph G which captures the behavior of A modulo the fact that exact time delays are abstracted away. Then, we apply untimed verification techniques on G to prove properties on A. As property-specification languages, we use both the linear-time formalism of timed B\u00fcchi automata (TBA) and the branching-time logic TCTL. Model\u00a0\u2026", "num_citations": "225\n", "authors": ["1619"]}
{"title": "Two examples of verification of multirate timed automata with Kronos\n", "abstract": " Multirate timed automata are an extension of timed automata where each clock has its own speed varying between a lower and an upper bound that may change from one control location to another. This formalism is well-suited for specifying hybrid systems where the dynamics of the continuous variables are defined or can be approximated by giving the minimal and maximal rate of change. To avoid the difficulties inherent in the verification of multirate timed automata, we follow an approach that consists of first transforming the multirate timed automata into timed automata and then applying the symbolic techniques implemented in KRONOS. We show the practical interest of this approach analyzing two examples recently proposed in the literature and considered to be realistic case studies: a manufacturing plant and the Philips audio control protocol.", "num_citations": "217\n", "authors": ["1619"]}
{"title": "Reducing the number of clock variables of timed automata.\n", "abstract": " We propose a method for reducing the number of clocks of a timed automaton by combining two algorithms. The first one consists in detecting active clocks, that is, those clocks whose values are relevant for the evolution of the system. The second one detects sets of clocks that are always equal. We implemented the algorithms and applied them to several case studies. These experimental results show that an appropriate encoding of the state space, based on the output of the algorithms, leads to a considerable reduction of the memory space allowing a more efficient verification.", "num_citations": "209\n", "authors": ["1619"]}
{"title": "Verifying et-lotos Programs with Kronos\n", "abstract": " ET-LOTOS is a timed extension of LOTOS proposed for modeling real-time systems. KRONOS is a tool that checks whether an automaton extended with clocks (called timed automaton) satisfies a real-time requirement expressed as a formula of the logic TCTL. This paper shows that real-time systems described in a reasonable subset of ET-LOTOS can be verified with KRONOS by compiling them into timed automata. We illustrate the practical interest of our approach with a case study: the Tick-Tock protocol.", "num_citations": "129\n", "authors": ["1619"]}
{"title": "Checking timed B\u00fcchi automata emptiness efficiently\n", "abstract": " This paper presents an on-the-fly and symbolic technique for efficiently checking timed automata emptiness. It is symbolic because it uses the simulation graph (instead of the region graph). It is on-the-fly because the simulation graph is generated during the test for emptiness. We have implemented a verification tool called Profounder based on this technique. To our knowledge, Profounder is the only available tool for checking emptiness of timed B\u00fcchi automata. To illustrate the practical interest of our approach, we show the performances of the tool on a non-trivial case study.", "num_citations": "110\n", "authors": ["1619"]}
{"title": "M\u00e9thodes et outils pour la v\u00e9rification symbolique de syst\u00e8mes temporis\u00e9s\n", "abstract": " Ce travail propose une m\u00e9thode pour l'analyse de syst\u00e8mes temps-re\u00e9l. Cette m\u00e9thode est bas\u00e9e sur la compilation des sp\u00e9cifications vers des graphes temporis\u00e9s, \u00e0 partir desquels il est possible de v\u00e9rifier des propri\u00e9t\u00e9s et de g\u00e9n\u00e9rer du code ex\u00e9cutable. Les graphes temporis\u00e9s sont des automates \u00e9tendus avec des variables, appel\u00e9es horloges, qui permettent de d\u00e9crire les contraintes temporelles. Un algorithme de compilation est d\u00e9velopp\u00e9 pour l'alg\u00e8bre de processus temporis\u00e9s ATP, qui est une extension des alg\u00e8bres de processus avec des op\u00e9rateurs temporels comme le``timeout''et le``watchdog''. L'int\u00e9r\u00eat de l'algorithme est que la taille du graphe obtenu est ind\u00e9pendante des valeurs des param\u00e8tres des op\u00e9rateurs temporels. Les propri\u00e9t\u00e9s temps-re\u00e9l sur les graphes temporis\u00e9s sont d\u00e9crites par des formules de la logique TCTL. Il est montr\u00e9 que les op\u00e9rateurs temporels de TCTL s' expriment en\u00a0\u2026", "num_citations": "104\n", "authors": ["1619"]}
{"title": "Analysis of timed systems based on time-abstracting bisimulations\n", "abstract": " We adapt a generic minimal model generation algorithm to compute the coarsest finite model of the underlying infinite transition system of a timed automaton. This model is minimal modulo a time-abstracting bisimulation. Our algorithm uses a refinement method that avoids set complementation, and is considerably more efficient than previous ones. We use the constructed minimal model for verification purposes by defining abstraction criteria that allow to further reduce the model and to compare it to a specification.", "num_citations": "81\n", "authors": ["1619"]}
{"title": "Parametric prediction of heap memory requirements\n", "abstract": " This work presents a technique to compute symbolic polynomial approximations of the amount of dynamic memory required to safely execute a method without running out of memory, for Javalike imperative programs. We consider object allocations and deallocations made by the method and the methods it transitively calls. More precisely, given an initial configuration of the stack and the heap, the peak memory consumption is the maximum space occupied by newly created objects in all states along a run from it. We over-approximate the peak memory consumption using a scopedmemory management where objects are organized in regions associated with the lifetime of methods. We model the problem of computing the maximum memory occupied by any region configuration as a parametric polynomial optimization problem over a polyhedral domain and resort to Bernstein basis to solve it. We apply the\u00a0\u2026", "num_citations": "79\n", "authors": ["1619"]}
{"title": "Minimum-time reachability for timed automata\n", "abstract": " The problem of minimum-time reachability for timed automata is: given an automaton, and initial state q0 and a target state qf, nd whether a run from q0 to qf exists, and if yes, a minimum time run. We show that this problem can be solved by examining acyclic paths in a forward reachability graph generated on-they from the timed automaton. Based on this result, we then propose three algorithms with di erent complexities.", "num_citations": "69\n", "authors": ["1619"]}
{"title": "Synthesis of safe, QoS extendible, application specific schedulers for heterogeneous real-time systems\n", "abstract": " We present a new scheduler architecture, which permits adding QoS (quality of service) policies to the scheduling decisions. We also present a new scheduling synthesis method which allows a designer to obtain a safe scheduler for a particular application. Our scheduler architecture and scheduler synthesis method can be used for heterogeneous applications where the tasks communicate through various synchronization primitives. We present a prototype implementation of this scheduler architecture and related mechanisms on top of an open-source OS (operating system) for embedded systems.", "num_citations": "60\n", "authors": ["1619"]}
{"title": "Reachability computation for linear hybrid systems\n", "abstract": " Linear hybrid systems are finite state machines with linear vector fields of the form \u1e8b = Ax in each discrete location. Very recently, the reachability problem for classes of linear hybrid systems was shown to be decidable. In this paper, the decidability result is extended to capture classes of linear hybrid systems where in each location the dynamics are of the form \u1e8b = Ax + Bu, for various types of inputs.", "num_citations": "48\n", "authors": ["1619"]}
{"title": "A methodology and tool support for generating scheduled native code for real-time java applications\n", "abstract": " Current trends in industry are leading towards the use of Java [5] as a programming language for implementing embedded and real-time applications. From the software engineering perspective, the Java environment is indeed a very attractive development framework. Object-oriented programming provides encapsulation of abstractions into objects that communicate through clearly defined interfaces. Dynamic loading eases the maintenance and improvement of complex applications with evolving requirements and functionality. Besides, Java provides built-in support for multi-threading.", "num_citations": "38\n", "authors": ["1619"]}
{"title": "Program instrumentation and run-time analysis of scoped memory in java\n", "abstract": " We present a method to analyze, monitor and control dynamic memory allocation in Java. It first consists in performing pointer and escape analysis to detect memory scopes. This information is used to automatically instrument Java programs in such a way memory is allocated and freed by a region-based memory manager. Our source code instrumentation fully exploits the result of scope analysis by dynamically mapping allocation places to the region stack at runtime via a registering mechanism. Moreover, it allows executing the same transformed program with different implementations of scoped-memory managers and perform different run-time analysis without changing the transformed code. In particular, we consider a class of managers that handle variable-size regions composed of fixed-size memory blocks for which we provide analytical models for the intra- and inter-region fragmentation. These models can\u00a0\u2026", "num_citations": "37\n", "authors": ["1619"]}
{"title": "Model checking for extended timed temporal logics\n", "abstract": " We introduce the real-time temporal logic BTATLp which is obtained by extending CTL* with both past operators and timed automata constraints. Considering together past operators and automata constraints allows expressing timing requirements in a simple and natural way. Model-checking for full BTATLp is undecidable. Fortunately, there exist significant (both linear-time and branching-time) fragments for which the verification problem is decidable. In particular, we identify a sublogic of BTATLp, which is more expressive than TCTL, and for which model-checking can be effectively done. The practical interest of this logic is illustrated through the example of the Philips audio protocol.", "num_citations": "33\n", "authors": ["1619"]}
{"title": "Hybrid computation\n", "abstract": " The goal of this paper is twofold: first a rapid introduction to the concept of hybrid system and second the presentation of a new direction in computer algebra that we have called hybrid computation. Hybrid computation can be seen as the application of the philosophy of hybrid system to the field of computation. We have focused our presentation on four directions that are actually developped in the MASH (Mod\u00e9lisation Alg\u00e9brique et Syst\u00e8mes Hybrides) project: Integration of ODE, Dynamic hybrid systems, Generalized splines and Optimal control [5].", "num_citations": "32\n", "authors": ["1619"]}
{"title": "Verification of the fast reservation protocol with delayed transmission using the tool kronos\n", "abstract": " The authors report the work carried out at VERIMAG within the framework of an research cooperation with CNET. The goal of the work was twofold: to formally specify the FRP-DT using the timed-automaton formalism, and to analyze its behavior using the tool KRONOS. The work has revealed some unexpected behaviors of the design such as a timeout that never expires, and transitions that never occur, and more important potential problems such as inconsistency in the bandwidth reserved along the connection path.", "num_citations": "32\n", "authors": ["1619"]}
{"title": "Computing optimal operation schemes for chemical plants in multi-batch mode\n", "abstract": " We propose a computer-aided methodology to automatically generate time optimal production schemes for chemical batch plants operating in multi-batch mode. Our approach is based on the following principles: (1) the plant is modeled at the level of process operations whose behavior is specified by timed automata, (2) the optimal production schemes are generated using algorithms for reachability analysis of timed automata implemented in OpenKronos, (3) the output of the verification tool is post-processed to derive high-level control code. We apply our methodology to the batch plant at the University of Dortmund. The automatically computed operation schemes turned out to be more efficient than the previously used handwritten ones.", "num_citations": "31\n", "authors": ["1619"]}
{"title": "Jahuel: A formal framework for software synthesis\n", "abstract": " We present a theoretically sound and automated model-based design, analysis, and implementation framework for synthesizing correct-by-construction code. Special emphasis is put on multi-threaded software and multi-processor architectures. The framework consists in (1) a formal language which provides platform-independent constructs to specify the behavior of an application using an abstract execution model, and (2) a compilation chain for refining the application abstract model into its concrete implementation on a target platform. The prototype Jahuel is currently being used for developing experimental industrial applications.", "num_citations": "28\n", "authors": ["1619"]}
{"title": "Decidable hybrid systems\n", "abstract": " One of the most important analysis problems of hybrid systems is the reachability problem. State of the art computational tools perform reachability computation for timed automata, multirate automata, and rectangular automata. In this paper, we extend the decidability frontier for classes of linear hybrid systems, which are introduced as hybrid systems with linear vector elds in each discrete location. This extension is important given the applicability of linear vector elds in control systems. This result is achieved by showing that any such hybrid system admits a nite bisimulation, and by providing an algorithm that computes it using decision methods from mathematical logic.", "num_citations": "27\n", "authors": ["1619"]}
{"title": "Semi-automatic region-based memory management for real-time java embedded systems\n", "abstract": " In this paper we address the problem of dynamic memory management in real-time Java embedded systems. Our work aims at suppressing the need for garbage collection in order to avoid unpredictable pause times. For that we use a simple static analysis algorithm coupled with region-based memory management as presented in [15]. To overcome the well-known limitations of region inference, we propose in this paper to involve the developer in the analysis process by providing feedback on programming constructs likely to produce memory leaks. Experiments show that for most programming patterns, our system behaves as efficiently as a garbage collector in terms of memory consumption. Our analysis tool is furthermore able to provide useful feedback to the programmer to pinpoint problematic constructs.", "num_citations": "26\n", "authors": ["1619"]}
{"title": "Fast escape analysis for region-based memory management\n", "abstract": " We present an algorithm for escape analysis inspired by, but more precise than, the one proposed by Gay and Steensgaard [D. Gay and B. Steensgaard. Fast escape analysis and stack allocation for object-based programs. In CC'00. Springer-Verlag, 2000]. The primary purpose of our algorithm is to produce useful information to allocate memory using a region-based memory manager. The algorithm combines intraprocedural variable-based and interprocedural points-to analyses. This is a work in progress towards achieving an application-oriented trade-off between precision and scalability. We illustrate the algorithm on several typical programming patterns, and show experimental results of a first prototype on a few benchmarks.", "num_citations": "22\n", "authors": ["1619"]}
{"title": "Modelling, analysis and parallel implementation of an on-line video encoder\n", "abstract": " Video encoding is a fundamental component of a wide range of real-time multimedia applications. In this paper, we present the fine grain MPEG-4 parallelism and describe a modelling, mapping and scheduling approach that produces code for an industrial video encoder on SMP platforms.", "num_citations": "21\n", "authors": ["1619"]}
{"title": "Fault diagnosis for intra-platoon communications\n", "abstract": " We formalize the design and logical verification of a fault diagnosis and monitoring system for intra-platoon communication systems. A platoon is a string of automatic vehicles with distributed control strategies. Vehicles rely on real-time control data from other vehicles for correct execution of their control laws. A time-driven system is responsible for delivering the control data.", "num_citations": "21\n", "authors": ["1619"]}
{"title": "Regular inference on artificial neural networks\n", "abstract": " This paper explores the general problem of explaining the behavior of artificial neural networks (ANN). The goal is to construct a representation which enhances human understanding of an ANN as a sequence classifier, with the purpose of providing insight on the rationale behind the classification of a sequence as positive or negative, but also to enable performing further analyses, such as automata-theoretic formal verification. In particular, a probabilistic algorithm for constructing a deterministic finite automaton which is approximately correct with respect to an artificial neural network is proposed.", "num_citations": "17\n", "authors": ["1619"]}
{"title": "Computing optimal operation schemes for multi batch operation of chemical plants\n", "abstract": " We describe a methodology for optimal controller construction for chemical batch plants. The emphasis lies on the problem of running multiple batches.We consider a layered design and solution to the above problem, in particular with a lower layer realised in PLCs and a higher layer realised on arbitrary computer systems (usually PCs), such that the lower layer o ers to the higher layer a collection of atomic process operations. Then safe operation is a concern of the lower layer while optimisation and scheduling is a concern of the higher layer mostly. We formalise these concepts and apply them to the case study of a student's batch plant at the university of Dortmund. Using several algorithmic approaches from real time veri cation, we were able to compute optimal schedules for this plant, which improve over the previously used ad hoc schedules.", "num_citations": "17\n", "authors": ["1619"]}
{"title": "VTS-based specification and verification of behavioral properties of AADL models\n", "abstract": " AADL is an aerospace standard for model-driven design of complex real-time embedded systems. Currently, behavioral properties of AADL models can be specified inside the system description using AADL concepts or outside it using external textual languages, and verified using schedulability analysis or (Time Petri Net-based) model-checking tools. This paper (1) proposes Visual Timed Scenarios (VTS) as a graphical property specification language for AADL, and (2) devises an effective translation from VTS to Time Petri Nets (TPN) which enables model-checking properties expressed in VTS over AADL models using TPN-based tools integrated into AADL-compliant IDEs (eg, TOPCASED).", "num_citations": "16\n", "authors": ["1619"]}
{"title": "On synthesizing parametric specifications of dynamic memory utilization\n", "abstract": " We present a static analysis approach for estimating the amount of memory dynamically allocated by a piece of code. The technique is suitable for imperative languages with highlevel memory management mechanisms like Java and resorts to ideas that come from the community of parallel computing and the field of pointer escape analysis. Firstly, we propose a general procedure for synthesizing a parametric specification which over-estimates the amount of memory allocated by a program method in terms of its parameters. Then, we introduce a series of extensions to deal with the problem of estimating memory consumption in a scoped-memory management setting. The proposed techniques can be used to predict memory allocation, both during compilation and at runtime. Applications are manyfold, from improvements in memory management to the generation of parametric memory-allocation certificates. These specifications would enable application loaders and schedulers to make decisions based on the available memory resources and the memory-consumption estimates.", "num_citations": "16\n", "authors": ["1619"]}
{"title": "Speedup prediction for selective compilation of embedded Java programs\n", "abstract": " We propose a profile based code selection scheme for an AOT Java compiler. This scheme relies on a model that accurately predicts the speedup of a given selection. The model takes into account the cross-call patterns of the application. This approach allows us to reduce the size of compiled code significantly for several benchmarks.", "num_citations": "15\n", "authors": ["1619"]}
{"title": "Timing analysis and code generation of vehicle control software using Taxys\n", "abstract": " PATH's automated vehicle control application software is responsible for the longitudinal and lateral control of each vehicle in a platoon [5]. The software consists of a set of processes running concurrently on a PC, reading data from various sensors (e.g., radar, speedometer, accelerometer, magnetometer), writing to actuators (throttle, brake and steering), and using radio to communicate data to other vehicles. The processes exchange data with each other using a publish/subscribe scheme. In this paper, we describe the current software, and propose a model written in the synchronous language Esterel [1]. We use Taxys [2,7], a tool for timing analysis of Esterel based on the Kronos model-checker [3], and the Esterel compiler Saxo-RT [6], to verify that the application meets its deadlines. Timing analysis is done on-the-fly during the execution of the appropriately instrumented C code generated by the compiler\u00a0\u2026", "num_citations": "15\n", "authors": ["1619"]}
{"title": "A timed automaton-based method for accurate computation of circuit delay in the presence of cross-talk\n", "abstract": " We present a timed automaton-based method for accurate computation of the delays of combinational circuits. In our method, circuits are represented as networks of timed automata, one per circuit element. The state space of the network represents the evolution of the circuit over time and delay is computed by performing a symbolic traversal of this state space.             Based on the topological structure of the circuit, a partitioning of the network and a corresponding conjunctively decomposed OBDD representation of the state space is derived. The delay computation algorithm operates on this decomposed representation and, on a class of circuits, obtains performance orders of magnitude better than a non-specialized traversal algorithm.             We demonstrate the use of timed automata for accurate modeling of gate delay and cross-talk. We introduce a gate delay model which accurately represents transistor\u00a0\u2026", "num_citations": "15\n", "authors": ["1619"]}
{"title": "Jscoper: Eclipse support for research on scoping and instrumentation for real time java applications\n", "abstract": " We present JScoper, an Eclipse plug-in which will help developers, researchers and students, to generate, understand, and manipulate memory regions in scoped-memory management setting. The main goal of the plug-in is to provide a tool that will transparently assist the translation of Java applications into Real-time Specification for Java (RTSJ) compliant applications. More accurately, its purpose is to enable automatic and semi-automatic ways to translate heap-based Java programs into scope-based ones, by leveraging GUI features for navigation, specification and debugging.", "num_citations": "14\n", "authors": ["1619"]}
{"title": "P-Ware: A precise and scalable component-based simulation tool for embedded multiprocessor industrial applications\n", "abstract": " We present a component-based framework and its supporting simulation tool for joint software-hardware modelling and performance analysis of multiprocessor embedded systems. This joint evaluation enables predicting the impact of hardware configuration on software performance and hardware capability to accommodate other services at design time. The experiments carried out on several real- life industrial-size applications show that our framework is scalable while achieving fast simulation speeds, and delivers correct performance trends which are successfully used for identifying and improving limiting performance factors.", "num_citations": "13\n", "authors": ["1619"]}
{"title": "Stability analysis of a longitudinal control law for autonomous vehicles\n", "abstract": " We focus on the analysis of an acceleration law for a following autonomous vehicle with constant time headway goal. We first define a function that measures the positioning of the following vehicle compared to the leading vehicle, with respect to the desired time headway. We study the convergence and limit of this positioning function, and prove the asymptotic stability of our acceleration control law under some initial conditions on the following vehicle and some invariant conditions on the leading vehicle. We then extend this result when the acceleration are saturated by the technology bounds, and we apply it to prove the platoon stability. Finally, we conduct several simulations that validate our theoretical results and show the impact of the initial conditions.", "num_citations": "13\n", "authors": ["1619"]}
{"title": "Summary-based inference of quantitative bounds of live heap objects\n", "abstract": " This article presents a symbolic static analysis for computing parametric upper bounds of the number of simultaneously live objects of sequential Java-like programs. Inferring the peak amount of irreclaimable objects is the cornerstone for analyzing potential heap-memory consumption of stand-alone applications or libraries. The analysis builds method-level summaries quantifying the peak number of live objects and the number of escaping objects. Summaries are built by resorting to summaries of their callees. The usability, scalability and precision of the technique is validated by successfully predicting the object heap usage of a medium-size, real-life application which is significantly larger than other previously reported case-studies.", "num_citations": "11\n", "authors": ["1619"]}
{"title": "Synthesizing parametric specifications of dynamic memory utilization in object-oriented programs\n", "abstract": " We present a static analysis approach for computing a parametric upper-bound of the amount of memory dynamically allocated by (Java-like) imperative object-oriented programs. We propose a general procedure for synthesizing non-linear formulas (actually polynomials) which conservatively estimate memory consumption in terms of method\u2019s parameters. We have implemented the procedure and evaluated it on several benchmarks. Experimental results produced exact estimations for most test cases, and quite precise approximations for many of the others. We also apply our technique to compute usage in the context of scoped memory and discuss some open issues.", "num_citations": "11\n", "authors": ["1619"]}
{"title": "Compositional constraints generation for concurrent real-time loops with interdependent iterations\n", "abstract": " In this paper we describe an assume/guarantee based execution constraints synthesis algorithm for concurrent threads executing on parallel platforms. Threads are loops which can have several control points, such as the activation of loop iterations and the interaction with other threads. Real-time applications such as multimedia applications are usually specified using this kind of concurrent interacting threads. The proposed compositional algorithm outputs a set of sufficient constraints on the control points in order to meet timing objectives. The paper first presents the timed system model we use to specify such applications. Then, the constraints synthesis algorithm is presented and illustrated on a real-time video application.", "num_citations": "11\n", "authors": ["1619"]}
{"title": "CheckDroid: a tool for automated detection of bad practices in Android applications using taint analysis\n", "abstract": " Today, Android runs on more than 80% of smartphones and tablets in the market. Although a guide to good programming practices exists, it is not at all enforced by current IDEs. This work presents CheckDroid, a tool towards automatically detecting bad patterns early in the development cycle. Its originality relies on the idea of mapping bad practices into appropriate paths in the code which can be found by static taint analysis. The main benefit for developers consists in the ability to early, simply and quickly clean up the code of potential causes of runtime errors. More specific tools can be used later for deeper verification. Preliminary experimental evaluation shows that CheckDroid is able to find common bad practices incurred in by newbie Android programmers.", "num_citations": "10\n", "authors": ["1619"]}
{"title": "Quantitative dynamic\u2010memory analysis for Java\n", "abstract": " Space\u2010 and time\u2010predictability are hard to achieve for object\u2010oriented languages with automated dynamic\u2010memory management. Although there has been significant work to design APIs, such as the Real\u2010Time Specification for Java (RTSJ), and to implement garbage collectors to enable real\u2010time performance, quantitative space analysis is still in its infancy. This work presents the integration of a series of compile\u2010time analysis techniques to help predicting quantitative memory usage. In particular, we focus on providing tool assistance for identifying RTSJ scoped\u2010memory regions, their sizes, and overall memory usage. First, the tool\u2010suite synthesizes a memory organization where regions are associated with methods. Second, it infers their sizes in parametric closed form in terms of relevant program variables. Third, it exhibits a parametric upper bound on the amount of available free memory required to execute a\u00a0\u2026", "num_citations": "10\n", "authors": ["1619"]}
{"title": "Efficient Region-Based Memory Management for Resource-limited Real-Time Embedded Systems.\n", "abstract": " This paper presents a simple and efficient static analysis algorithm, combined with a region allocation policy for real-time embedded Java applications. The goal of this work is to provide a static analysis mechanism efficient enough to be integrated in an assisted-development environment, and to implement region-based memory management primitives suited for resource-limited platforms such as smart cards.", "num_citations": "10\n", "authors": ["1619"]}
{"title": "Computing efficient operation schemes for chemical plants in multi-batch mode\n", "abstract": " We propose a computer-aided methodology to auto- matically generate time optimal production schemes for chemical batch plants operating in multi-batch mode. Our approach is based on the following principles: (1) the plant is modeled at the level of process operations whose behavior is specified by timed automata, (2) the optimal production schemes are generated using algo- rithms implemented in OPENKRONOS, a tool for formal verification of timed automata, (3) the output of the verification tool is post-processed to derive high-level control code. We apply our methodology to the batch plant at the University of Dortmund. The automatically computed operation schemes turned out to be more efficient than the previously used handwritten ones.", "num_citations": "10\n", "authors": ["1619"]}
{"title": "An approach for the verification of the temporal consistency of NCL applications\n", "abstract": " NCL is used to write interactive applications for DTV. This paper presents the first steps of our approach towards the formalization of the semantics of NCL. We use Time Petri Nets (TPN) as target formalism for giving mathematically precise meaning to NCL. We rely on Visual Timed Scenarios (VTS) to graphically specify the behavioral properties the NCL application should satisfy. We sketch the method to translate NCL programs into TPN models and to verify VTS properties on the obtained model. We illustrate the approach with \u201cO Primeiro Jo\u00e3o\u201d from club. ncl. org. br.", "num_citations": "8\n", "authors": ["1619"]}
{"title": "On transforming Java-like programs into memory-predictable code\n", "abstract": " The ScopedMemory class of the RTSJ enables the organization of objects into regions. This ensures time-predictable management of dynamic memory. Using scopes forces the programmer to reason in terms of locality, to comply with RTSJ restrictions. The programmer is also faced with the problem of providing upper-bounds for regions. Without appropriate compile-time support, scoped-memory management may lead to unexpected runtime errors.", "num_citations": "8\n", "authors": ["1619"]}
{"title": "A formal approach to derivation of concurrent implementations in software product lines\n", "abstract": " High-performance real-time embedded applications, such as HDTV, video streaming, and packet routing, motivate the use of multicore and multiprocessor hardware platforms offering multiple processing units (eg, VIPER [15], Philips Wasabi/Cake [35], Intel IXP family of network processors [21]). These architectures provide significant price, performance, and flexibility advantages. Besides, such applications are subject to mass customization, as many variations of the same product are delivered to the market with different price, performance, and functionality. The key to mass customization is to capitalize on the commonality and to effectively manage the variation in a software product line [13]. However, in current industrial practices, application requirements and design constraints are spread out and do not easily integrate and propagate through the development process. Moreover, the increasing complexity of applications tends to enlarge the abstraction gap between application description and hardware. Therefore, customization becomes a burdensome and error-prone task. In summary, the complexity of both software and hardware, together with the stringent performance requirements (eg, timing, power consumption, etc.), makes design, deployment, and customization extremely difficult, leading to costly development cycles which result in products with suboptimal performances.During the development cycle of applications for multiprocessors, two models of execution should be distinguished. The first one is the abstract model inherent to the specification of the application, which typically corresponds to logically concurrent activities, with data\u00a0\u2026", "num_citations": "7\n", "authors": ["1619"]}
{"title": "A scheduler synthesis methodology for joint SW/HW design exploration of SoC\n", "abstract": " The introduction of high-performance applications such as multimedia applications into SoCs led the manufacturers to provide embedded SoCs able to offer an important computing power which makes it possible to answer the increasing requirements of future evolutions of these applications. One of the adopted solutions is the use of multiprocessor SoCs. In this paper, we present a joint SW/HW design exploration methodology for multiprocessor SoCs. The system model relies on transaction-level component-based models for modeling parallel software and multiprocessor hardware. Our proposal comprises two original points. First, we propose a composable software-level scheduler constraints synthesis technique. Second, we present a combined software-level and exploratory hardware-level schedulers. The methodology has the advantage of combining real-time requirements of software with effective\u00a0\u2026", "num_citations": "6\n", "authors": ["1619"]}
{"title": "Modelling and exploration environment for application specific multiprocessor systems\n", "abstract": " We present a tool-assisted platform-based design flow for embedded multiprocessor applications. The methodology relies on (1) a formal language which provides constructs to specify the platform- independent behavior of an application using an abstract execution model, and to describe the micro-architecture components of the hardware architecture, together with its compilation chain Jahuel [1], and (2) a component-based meta-model for joint software and hardware performance modelling and analysis, together with its simulation tool P-Ware [2], which provides fast, precise and scalable platform-level simulations. Jahuel and P-Ware have been successfully used for the design of industrial multimedia and packet-forwarding embedded software on application-specific multiprocessor architectures.", "num_citations": "6\n", "authors": ["1619"]}
{"title": "Efficient region-based memory management for resource-limited real-time embedded systems\n", "abstract": " This paper presents a simple and efficient static analysis algorithm, combined with a region allocation policy for real-time embedded Java applications. The goal of this work is to provide a static analysis mechanism efficient enough to be integrated in an assisted-development environment, and to implement region-based memory management primitives suited for resource-limited platforms such as smart cards.", "num_citations": "6\n", "authors": ["1619"]}
{"title": "Formal Techniques, Modelling and Analysis of Timed and Fault-Tolerant Systems: Joint International Conferences on Formal Modeling and Analysis of Timed Systems, FORMATS 2004\u00a0\u2026\n", "abstract": " This volume contains the proceedings of the joint conference on Formal M-elling and Analysis of Timed Systems (FORMATS) and Formal Techniques in Real-Time and Fault Tolerant Systems (FTRTFT), held in Grenoble, France, on September 22-24, 2004. The conference united two previously independently-ganized conferences FORMATS and FTRTFT. FORMATS 2003 was organized asasatelliteworkshopofCONCUR2003andwasrelatedtothreeindependently started workshop series: MTCS (held as a satellite event of CONCUR 2000 and CONCUR 2002), RT-TOOLS (held as a satellite event of CONCUR 2001 and FLoC 2002) and TPTS (held at ETAPS 2002). FTRTFT is a symposium that was held seven times before: in Warwick 1988, Nijmegen 1992, Lu \u0308beck 1994, Uppsala 1996, Lyngby 1998, Pune 2000 and Oldenburg 2002. The proceedings of these symposia were published as volumes 331, 571, 863, 1135, 1486, 1926, and 2469 in the LNCS series by Springer. Thisjointconferenceis dedicatedtotheadvancementofthetheoryandpr-ticeofthe modelling, designandanalysisofreal-timeandfault-tolerantsystems. Indeed, computersystemsarebecomingincreasinglywidespreadinreal-timeand safety-critical applications such as embedded systems. Such systems are char-terized by the crucial need to manage their complexity in order to produce reliable designs and implementations. The importance of timing aspects, p-formance and fault-tolerance is continuously growing. Formal techniques o? er a foundation for systematic design of complex systems. They have bene? cial-plications throughout the engineering process, from the capture of\u00a0\u2026", "num_citations": "6\n", "authors": ["1619"]}
{"title": "The diadem-kronos connection: Bridging the gap between implementation and verification of hybrid systems\n", "abstract": " Design and development of complex systems involves several steps: analysis, synthesis, veri cation, simulation and implementation. These steps are often visited several times in the system design life-cycle. With each visit, the system description moves from the abstract to the concrete, and the modeling frameworks used also get successively ner. The nal product of system design is the implementation. The implementation often interacts with and controls critical equipment. Design aws that lead to equipment malfunctioning can rarely be tolerated. Hence, it is crucial that the implementation be as close to the veri ed design as possible.", "num_citations": "6\n", "authors": ["1619"]}
{"title": "Compiling timed algebras into timed automata\n", "abstract": " Real-time systems are hard to model, specify and design. It is common practice today to pass from informal speci cations to implementations and then test the behavior of the system on some cases, which is inadequate to develop bug-free real-time systems. To ensure correctness we need to employ automatic veri cation methods and tools. The following real-time software development process has been proposed in 7]: ATP is used to describe real-time systems and TCTL to specify the real-time requirements. The veri cation approach consists in translating ATP to timed automata and then performing model-checking. In this work we present a tool that compiles ATP terms into timed automata.", "num_citations": "6\n", "authors": ["1619"]}
{"title": "A framework for modelling and performance analysis of multiprocessor embedded systems: Models and benefits\n", "abstract": " Nous pr\u00e9sentons un framework pour la mod\u00e9lisation et l\u2019analyse de performance des syst\u00e8mes embarqu\u00e9s multiprocesseurs. Notre framework est constitu\u00e9e de composants mod\u00e9lisant du logiciel parall\u00e8le et du mat\u00e9riel multiprocesseur, et des outils pour la g\u00e9n\u00e9ration de code et l\u2019analyse de performances. Elle permet une analyse conjointe du logiciel et du mat\u00e9riel. Cette derni\u00e8re rend possible la pr\u00e9diction de l\u2019impact du mat\u00e9riel sur les performances du logiciel et de la capacit\u00e9 du mat\u00e9riel \u00e0 s\u2019 adapter \u00e0 de futurs services, et cela au moment de la conception du syst\u00e8me. Le mod\u00e8le des composants est bas\u00e9 sur une description du mat\u00e9riel au niveau transaction et une description au niveau programmeur du logiciel. Les exp\u00e9riences effectu\u00e9es prouvent que notre m\u00e9thodologie passe \u00e0 l\u2019\u00e9chelle et fournit des r\u00e9sultats de performances pr\u00e9cis avec des vitesses de simulation rapides.", "num_citations": "4\n", "authors": ["1619"]}
{"title": "On-the-fly Black-Box Probably Approximately Correct Checking of Recurrent Neural Networks\n", "abstract": " We propose a procedure for checking properties of recurrent neural networks used for language modeling and sequence classification. Our approach is a case of black-box checking based on learning a probably approximately correct, regular approximation of the intersection of the language of the black-box (the network) with the complement of the property to be checked, without explicitly building individual representations of them. When the algorithm returns an empty language, there is a proven upper bound on the probability of the network not verifying the requirement. When the returned language is nonempty, it is certain the network does not satisfy the property. In this case, an explicit and interpretable characterization of the error is output together with sequences of the network truly violating the property. Besides, our approach does not require resorting to an external decision procedure for verification nor\u00a0\u2026", "num_citations": "3\n", "authors": ["1619"]}
{"title": "Formal specification and implementation of an automated pattern-based parallel-code generation framework\n", "abstract": " Programming correct parallel software in a cost-effective way is a challenging task requiring a high degree of expertise. As an attempt to overcoming the pitfalls undermining parallel programming, this paper proposes a pattern-based, formally grounded tool that eases writing parallel code by automatically generating platform-dependent programs from high-level, platform-independent specifications. The tool builds on three pillars: (1) a platform-agnostic parallel programming pattern, called PCR, (2) a formal translation of PCRs into a parallel execution model, namely Concurrent Collections (CnC), and (3) a program rewriting engine that generates code for a concrete runtime implementing CnC. The experimental evaluation carried out gives evidence that code produced from PCRs can deliver performance metrics which are comparable with handwritten code but with assured correctness. The technical\u00a0\u2026", "num_citations": "3\n", "authors": ["1619"]}
{"title": "Region-Based Memory Management: An Evaluation of Its Support in RTSJ\n", "abstract": " Memory management is a source of unpredictability in the execution time of Java programs. This is because garbage collection introduces possibly unbounded blocking pauses to threads, which is unacceptable in real-time systems. To cope with this problem, the Real-Time Specification for Java (RTSJ) adopts a region-based approach which relies on memory scopes that are automatically freed upon termination of their lifetime. This allows the turning off of garbage collection during the execution of critical tasks, thus ensuring real-time guarantees. This chapter explains the RTSJ memory model and proposes improvements to its suggested implementation. It also discusses a static analysis-based approach to ensure that memory scopes are correctly use and dimensioned at compile time.", "num_citations": "3\n", "authors": ["1619"]}
{"title": "Symbolic prediction of dynamic memory requirements\n", "abstract": " This work presents a technique to compute symbolic non-linear approximations of the amount of dynamic memory required to safely run a method in (Java-like) imperative programs. We do that for scoped-memory management where objects are organized in regions associated with the lifetime of methods. Our approach resorts to a symbolic non-linear optimization problem which is solved using Bernstein basis.", "num_citations": "3\n", "authors": ["1619"]}
{"title": "Bip: Language and tools for component-based construction\n", "abstract": " A central idea in systems engineering is that complex systems are built by assembling components. System designers deal with a large variety of components, each having different characteristics, from a large variety of viewpoints, each highlighting different dimensions of a system. A central problem is the meaningful composition of heterogeneous components to ensure their correct interoperation.BIP (Behavior, Interaction, Priority) has been designed to overcome the difficulties of state-of-the-art componentbased approaches. BIP provides a language and a theory for incremental composition of heterogeneous components, ensuring correctness-by-construction for essential system properties such as mutual exclusion, deadlockfreedom and progress. Besides, it enables formal verification.", "num_citations": "3\n", "authors": ["1619"]}
{"title": "Kronos: A Verification Tool for Real-Time Systems.(Kronos User\u2019s Manual Release 2.2)\n", "abstract": " The main purpose of this paper is to explain how to use Kronos, a tool for formally checking whether a real-time system meets its requirements. Kronos is founded on the theory of timed automata and timed temporal logics.", "num_citations": "3\n", "authors": ["1619"]}
{"title": "A case study: the CSMA/CD protocol\n", "abstract": " The aim of this work is to show how a real system such as the CSMA-CD protocol can be speci ed using the real-time speci cation languages Atp and timed automata, and veri ed with the tool Kronos. This case study has been published in IEEE Transactions on Software Engineering NSY92]. For the formal syntax and operational semantics of Atpand timed automata see NSY92]. Real-time properties are expressed in the logic Tctl ACD90, HNSY92]. This paper is organized as follows. In section 1 we present the informal description of the protocol. In section 2 we give a formal speci cation in Atp and show the corresponding timed automata. In section 3 we verify some real-time properties with the tool Kronos.", "num_citations": "3\n", "authors": ["1619"]}
{"title": "Property Checking with Interpretable Error Characterization for Recurrent Neural Networks\n", "abstract": " This paper presents a novel on-the-fly, black-box, property-checking through learning approach as a means for verifying requirements of recurrent neural networks (RNN) in the context of sequence classification. Our technique steps on a tool for learning probably approximately correct (PAC) deterministic finite automata (DFA). The sequence classifier inside the black-box consists of a Boolean combination of several components, including the RNN under analysis together with requirements to be checked, possibly modeled as RNN themselves. On one hand, if the output of the algorithm is an empty DFA, there is a proven upper bound (as a function of the algorithm parameters) on the probability of the language of the black-box to be nonempty. This implies the property probably holds on the RNN with probabilistic guarantees. On the other, if the DFA is nonempty, it is certain that the language of the black-box is nonempty. This entails the RNN does not satisfy the requirement for sure. In this case, the output automaton serves as an explicit and interpretable characterization of the error. Our approach does not rely on a specific property specification formalism and is capable of handling nonregular languages as well. Besides, it neither explicitly builds individual representations of any of the components of the black-box nor resorts to any external decision procedure for verification. This paper also improves previous theoretical results regarding the probabilistic guarantees of the underlying learning algorithm. View Full-Text", "num_citations": "2\n", "authors": ["1619"]}
{"title": "Static taint analysis applied to detecting bad programming practices in android\n", "abstract": " Frameworks and Application Programming Interfaces (API) usually come along with a set of guidelines that establish good programming practices in order to avoid pitfalls which could lead, at least, to bad user experiences, but also to program crashes. Most often than not, such guidelines are not at all enforced by IDEs. This work investigates whether static taint analysis could be effectively used for automatically detecting bad programming patterns in Android applications. It presents the implemented tool, called CheckDroid, together with the preliminary experimental evaluation carried out.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "A model-based approach for multiple QoS in scheduling: from models to implementation\n", "abstract": " Meeting multiple Quality of Service (QoS) requirements is an important factor in the success of complex software systems. This paper presents an automated, model-based scheduler synthesis approach for scheduling application software tasks to meet multiple QoS requirements. As a first step, it shows how designers can meet deadlock-freedom and timeliness requirements, in a manner that (i) does not over-provision resources, (ii) does not require architectural changes to the system, and that (iii) leaves enough degrees of freedom to pursue further properties. A major benefit of our synthesis methodology is that it increases traceability, by linking each scheduling constraint with a specific pair of QoS property and underlying platform execution model, so as to facilitate the validation of the scheduling constraints and the understanding of the overall system behaviour, required to meet further QoS properties\u00a0\u2026", "num_citations": "2\n", "authors": ["1619"]}
{"title": "Parallel model analysis and implementation for MPEG-4 encoder\n", "abstract": " Video encoding is a fundamental component of a wide range of real-time multimedia applications, which require more storage and communication bandwidth than traditional data and have performance constraints. In this paper we present the fine grain MPEG-4 parallelism model and a message-passing based parallel MPEG-4 implementation program on SMP multi-processors. For this, a flexible model transformation approach based on a dynamic partitioning and scheduling heuristic is presented. Finally, we discuss the extension of traditional Quality-bitrate control mechanism to Performance-Quality-Bitrate in a two step control mechanism.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "Using temporal constraints networks to manage temporal scenario of multimedia documents\n", "abstract": " The purpose of this paper is to show that multimedia applications introduce new open problems in temporal constraint-based reasoning. In particular, we adress three issues related to scanario specication, namely the distinction of controllable and uncontrollable durations, Hierarchical structuration and Interruption-like behaviour. This paper mainly outlines this new requirements in multimedia authoring applications through an example. Then, we partially tackle the raised problems and give future research directions and the work we intend to achieve in this area.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "System design using Teja and KRONOS. case study: The FDDI protocol\n", "abstract": " In this paper we illustrate a computer-aided approach to formal system design (comprising of analysis, veri cation, simulation and implementation). As a case study we use the fddi data link protocol. We use the teja system as the platform for system speci cation and implementation. We use the kronos tool as the platform for veri cation.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "On-thefly symbolic model-checking for real-time systems\n", "abstract": " This paper presents an on-the-Jly and symbolic algorithm for checking whether a timed automaton satisfies a formula of a timed tt> mporal logic which is more expressive than TCTL. The algorithm is on-the-fly in the sense that the state-space is generated dynamically and only the minimal amount of information required by the verification procedure is stored in memory. The algorithm is symbolic in the sense that it manipulates sets of states, instead of states, which are represented as boolean combinations of linear inequalities of clocks. We show how a prototype implementation of our algorithm has improved the performances of the tool KRONOS for the verification of the FDDI protocol.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "Veri caci on autom atica de sistemas temporizados utilizando Kronos\n", "abstract": " Encontramos a diario sistemas en los cuales el tiempo juega un rol fundamental: sistemas de tiempo real, protocolos de comunicaci on, aplicaciones multimedia, etc. Su car acter cr tico y creciente complejidad motiv o la b usqueda de m etodos para su veri caci on autom atica. En este marco se desarroll o la herramienta KRONOS, en la que se utilizan grafos temporizados para la descripci on de los sistemas y la l ogica TCTL como lenguaje de especi caci on de propiedades temporales. Mediante el an alisis de ejemplos concretos mostramos el inter es pr actico de la herramienta KRONOS para la veri caci on autom atica de sistemas temporizados.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "Distributed implementation of a linda kernel\n", "abstract": " A computer network is an interconnected collection of autonomous computers. A distributed system consists of a collection of concurrent, autonomous, descentralized and loosely coupled components. Linda is a high-level parallel programming language intended for distributed programming. It consists of a reduced set of primitives which can be embedded in any sequential language to transform it in a parallel one. This work describes a Linda kernel developed for a 3B Computer Network at ESLAI.", "num_citations": "2\n", "authors": ["1619"]}
{"title": "An assessment of the application of private aggregation of ensemble models to sensible data\n", "abstract": " This paper explores the use of Private Aggregation of Teacher Ensembles (PATE) in a setting where students have their own private data that cannot be revealed as is to the ensemble. We propose a privacy model that introduces a local differentially private mechanism to protect student data. We implemented and analyzed it in case studies from security and health domains, and the result of the experiment was twofold. First, this model does not significantly affecs predictive capabilities, and second, it unveiled interesting issues with the so-called data dependency privacy loss metric, namely, high variance and values.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "TLA+ specification of PCR parallel programming pattern\n", "abstract": " Our research goal is to formalize the semantics of a parallel programming pattern called PCR in terms of TLA+. In this way, we can leverage TLA+ related tools to prove temporal properties of PCR programs. Besides correctness and termination, we are particularly interested in proving refinement. Moreover, we envisage to develop a translator from PCR into TLA+ to make the integration seamless.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "Performance analysis of embedded multiprocessor industrial applications: methodology and tools\n", "abstract": " We present a framework and its supporting simulation tool for modelling and performance analysis of multiprocessor embedded systems. Our framework consists of component-based models for modelling parallel software and multiprocessor hardware, and tools for code generation and performance analysis. The framework component meta-model relies on transaction-level description of hardware and programmer-level description of software where timing properties of the hardware micro-architectures are modelled as annotations in the concurrency meta-model. The framework has the advantage of allowing fast precise and scalable joint analysis of software and hardware performance rather than evaluating each one in isolation. This joint evaluation enables predicting the impact of hardware configuration on software performance and hardware capability to accommodate other services at design time.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "An approach to derivation of component-based implementations from data-oriented specifications\n", "abstract": " The design and implementation of software-intensive embedded product lines requires dealing with a variety of constantly changing application-and system-dependent functional and non-functional requirements and constraints that spread out throughout the development process. Moreover, because product lines are built upon a set of core services which are improved, customized, extended and integrated to come up with differentiated products, there is a need to resort to component-based approaches. However, many embedded applications (eg, video compression) are most likely specified in a transformational data-oriented style. The componentization of such applications is therefore deferred to the implementation phase, where performance and platform constraints are taken into account. This paper discusses a formally-grounded method to carry on this process. The approach consists in integrating (1) the componentbased language and execution engine BIP [4], and (2) the coordination language and code-generation infrastructure FXML/Jahuel [1]. The framework is illustrated with an MPEG-4 video encoder.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "P-ware: Performanceaware transaction-level simulation for network processor applications\n", "abstract": " Platform-based design is an approach to cope with increasing costs in developing complex embedded systems. In order to support performance analysis at system-platform level, this report presents a methodology and tool which provide a joint SW/HW component-based modelling and simulation framework. Our framework allows for specifying variable transaction latencies, and separates functional and timed behavior of components. We apply the framework for analyzing several implementations of an IPv4 forwarder application on an Intel\u2019s dual IXP2800. The analysis allows evaluating both SW and HW performance such as packets throughput, threads utilization, bus bandwidth and channels conflicts.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "Synthesizing parametric specifications of dynamic memory utilization in imperative object-oriented programs\n", "abstract": " We present a static analysis approach for over-approximating the amount of memory dynamically allocated by (Java-like) imperative object-oriented programs. We propose a general procedure for synthesizing symbolic specifications (actually polynomials) which conservatively estimate memory consumption in terms of methods\u2019 parameters. We have implemented the procedure and evaluated it on several benchmarks. Experimental results produced exact estimations for most test cases, and quite precise approximations for many of the others. We also apply our technique to compute usage in the context of scoped memory.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "A methodology for analyzing the dynamics of hybrid systems\n", "abstract": " We discuss an algebraic and computational framework for formally analyzing hybrid systems that attempts to avoid numerical integration by resorting to (algebraically) finding primitives, and inverting and (numerically) evaluating functions when needed. The goal of the paper is to start exploring a little bit deeper into this idea to try to find out (a) a methodology, (b) algebraic and computational tools to support it, (c) classes of systems to which we can apply it in principle, and (d) a framework in which we can reasonably apply it in practice (with today's computational tools).", "num_citations": "1\n", "authors": ["1619"]}
{"title": "Modeling, timing analysis and code generation of PATH's automated vehicle control application software\n", "abstract": " The PATH's automated vehicle control application software is responsible for the longitudinal and lateral control of each vehicle in a \u00d4\u00d0 \u00d8\u00d3\u00d3\u00d2 [6]. The software consists of a set of processes running concurrently on a PC, reading data from various sensors (eg, radar, speedometer, accelerometer, magnetometer), writing to actuators (throttle, brake and steering), and using radio to communicate data to other vehicles. The processes exchange data with each other using a \u00d4\u00d9 \u00d0\u00d7\u00bb\u00d7 \u00d9\u00d7 \u00d6 scheme. In this paper, we describe the current software, and propose a model written in the synchronous language\u00d7 \u00d8 \u00d6 \u00d0 [1]. We use \u00cc \u00dc\u00dd\u00d7[2, 8], a tool for timing analysis of\u00d7 \u00d8 \u00d6 \u00d0 based on the \u00c3\u00d6\u00d3\u00d2\u00d3\u00d7 model-checker [3] and the\u00d7 \u00d8 \u00d6 \u00d0 compiler \u00cb \u00dc\u00d3\u00b9\u00ca\u00cc [7], to verify that the application meets its deadlines. The C code generated by \u00cb \u00dc\u00d3\u00b9\u00ca\u00cc, appropriately linked to the \u00d4\u00d9 \u00d0\u00d7\u00bb\u00d7 \u00d9\u00d7 \u00d6 library, can be run on the vehicles, thus\u00a0\u2026", "num_citations": "1\n", "authors": ["1619"]}
{"title": "Reach set computation for linear vector fields using quantifier elimination\n", "abstract": " Hybrid systems 12] combine discrete event systems with di erential equations. One of the most important problems for hybrid systems is the reachability problem which asks whether some region of the state space is reachable from an initial region. The important issue for computational algorithms for hybrid systems is decidability. A survey of decidable and undecidable classes of hybrid systems with continuous dynamics of the form _x 2 ab] can be found in 6] and the references therein.Recently, in 8, 9], we have shown new decidability results involving hybrid systems with linear vector elds of the form _x= Ax+ Bu. These results are signi cant given the wide applicability of linear systems in control theory. In order to achieve them we have heavily relied on two key concepts from model theory, namely, o-minimality 11] and quanti er elimination 2, 10, 13, 4].", "num_citations": "1\n", "authors": ["1619"]}
{"title": "Embedded Systems\n", "abstract": " For more than three decades, reverse engineering has been a major issue in industry wanting to capitalise on legacy systems. Lots of companies have developed reverse engineering tools in order to help developers in their work. However, those tools have been focusing on traditional information systems. Working on a time critical embedded system we found that the solutions available focus either on software behaviour structuring or on data extraction from the system. None of them seem to be clearly using both approaches in a complementary way. In this paper, based on our industrial experiment, we list the requirements that such a tool should fulfil. We also present a short overview of existing reverse engineering tools and their features.", "num_citations": "1\n", "authors": ["1619"]}
{"title": "Verification and implementation of SHIFT models\n", "abstract": " CiteSeerX \u2014 Verification and Implementation of SHIFT Models Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Verification and Implementation of SHIFT Models (1998) Cached Download as a PDF Download Links [www.path.berkeley.edu] Save to List Add to Collection Correct Errors Monitor Changes by Sergio Yovine , Sergio Yovine Citations: 1 - 1 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract errors may have been inadvertently introduced. Keyphrases shift model Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us Developed at and hosted by The College of Information Sciences and Technology \u2026", "num_citations": "1\n", "authors": ["1619"]}
{"title": "A practical approach towards the integration of different methods and tools for the analysis of hybrid systems\n", "abstract": " CiteSeerX \u2014 A practical approach towards the integration of different methods and tools for the analysis of hybrid systems Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA A practical approach towards the integration of different methods and tools for the analysis of hybrid systems (1998) Cached Download as a PDF Download Links [www.path.berkeley.edu] Save to List Add to Collection Correct Errors Monitor Changes by Sergio Yovine Citations: 1 - 1 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases hybrid system practical approach different method Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source \u2026", "num_citations": "1\n", "authors": ["1619"]}