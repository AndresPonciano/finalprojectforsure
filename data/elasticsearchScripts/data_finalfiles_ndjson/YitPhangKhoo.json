{"title": "Directed symbolic execution\n", "abstract": " In this paper, we study the problem of automatically finding program executions that reach a particular target line. This problem arises in many debugging scenarios; for example, a developer may want to confirm that a bug reported by a static analysis tool on a particular line is a true positive. We propose two new directed symbolic execution strategies that aim to solve this problem: shortest-distance symbolic execution (SDSE) uses a distance metric in an interprocedural control flow graph to guide symbolic execution toward a particular target; and call-chain-backward symbolic execution (CCBSE) iteratively runs forward symbolic execution, starting in the function containing the target line, and then jumping backward up the call chain until it finds a feasible path from the start of the program. We also propose a hybrid strategy, Mix-CCBSE, which alternates CCBSE with another (forward) search strategy. We\u00a0\u2026", "num_citations": "245\n", "authors": ["1839"]}
{"title": "Adapton: Composable, Demand-Driven Incremental Computation\n", "abstract": " Many researchers have proposed programming languages that support incremental computation (IC), which allows programs to be efficiently re-executed after a small change to the input. However, existing implementations of such languages have two important drawbacks. First, recomputation is oblivious to specific demands on the program output; that is, if a program input changes, all dependencies will be recomputed, even if an observer no longer requires certain outputs. Second, programs are made incremental as a unit, with little or no support for reusing results outside of their original context, e.g., when reordered. To address these problems, we present \u03bbiccdd, a core calculus that applies a demand-driven semantics to incremental computation, tracking changes in a hierarchical fashion in a novel demanded computation graph. \u03bbiccdd also formalizes an explicit separation between inner, incremental\u00a0\u2026", "num_citations": "93\n", "authors": ["1839"]}
{"title": "Path projection for user-centered static analysis tools\n", "abstract": " The research and industrial communities have made great strides in developing sophisticated defect detection tools based on static analysis. To date most of the work in this area has focused on developing novel static analysis algorithms, but has neglected study of other aspects of static analysis tools, particularly user interfaces. In this work, we present a novel user interface toolkit called Path Projection that helps users visualize, navigate, and understand program paths, a common component of many tools' error reports. We performed a controlled user study to measure the benefit of Path Projection in triaging error reports from Locksmith, a data race detection tool for C. We found that Path Projection improved participants' time to complete this task without affecting accuracy, while participants felt Path Projection was useful and strongly preferred it to a more standard viewer.", "num_citations": "43\n", "authors": ["1839"]}
{"title": "Mixing type checking and symbolic execution\n", "abstract": " Static analysis designers must carefully balance precision and efficiency. In our experience, many static analysis tools are built around an elegant, core algorithm, but that algorithm is then extensively tweaked to add just enough precision for the coding idioms seen in practice, without sacrificing too much efficiency. There are several downsides to adding precision in this way: the tool's implementation becomes much more complicated; it can be hard for an end-user to interpret the tool's results; and as software systems vary tremendously in their coding styles, it may require significant algorithmic engineering to enhance a tool to perform well in a particular software domain. In this paper, we present Mix, a novel system that mixes type checking and symbolic execution. The key aspect of our approach is that these analyses are applied independently on disjoint parts of the program, in an off-the-shelf manner. At the\u00a0\u2026", "num_citations": "26\n", "authors": ["1839"]}
{"title": "Mixing Type Checking and Symbolic Execution (Extended Version)\n", "abstract": " Static analysis designers must carefully balance precision and efficiency. In our experience, many static analysis tools are built around an elegant, core algorithm, but that algorithm is then extensively tweaked to add just enough precision for the coding idioms seen in practice, without sacrificing too much efficiency. There are several downsides to adding precision in this way: the tool's implementation becomes much more complicated; it can be hard for an end-user to interpret the tool's results; and as software systems vary tremendously in their coding styles, it may require significant algorithmic engineering to enhance a tool to perform well in a particular software domain.  In this paper, we present Mix, a novel system that mixes type checking and symbolic execution. The key aspect of our approach is that these analyses are applied independently on disjoint parts of the program, in an off-the-shelf manner. At the boundaries between nested type checked and symbolically executed code regions, we use special mix rules to communicate information between the off-the-shelf systems. The resulting mixture is a provably sound analysis that is more precise than type checking alone and more efficient than exclusive symbolic execution. In addition, we also describe a prototype implementation, Mixy, for C. Mixy checks for potential null dereferences by mixing a null/non-null type qualifier inference system with a symbolic executor", "num_citations": "26\n", "authors": ["1839"]}
{"title": "Directing JavaScript with arrows\n", "abstract": " JavaScript programmers make extensive use of event-driven programming to help build responsive web applications. However, standard approaches to sequencing events are messy, and often lead to code that is difficult to understand and maintain. We have found that arrows, a generalization of monads, are an elegant solution to this problem. Arrows allow us to easily write asynchronous programs in small, modular units of code, and flexibly compose them in many different ways, while nicely abstracting the details of asynchronous program composition. In this paper, we present Arrowlets, a new JavaScript library that offers arrows to the everyday JavaScript programmer. We show how to use Arrowlets to construct a variety of state machines, including state machines that branch and loop. We also demonstrate how Arrowlets separate computation from composition with examples such as a drag-and-drop handler\u00a0\u2026", "num_citations": "25\n", "authors": ["1839"]}
{"title": "Measuring the utility of gaze detection for task modeling: A preliminary study\n", "abstract": " Search engines present readers with a list of documents ranked by predicted relevance to a keyword query. Salient sections of documents that are selected for examination can be highlighted using similar techniques. An ability to restructure information presentation based on an analyst\u2019s initial interactions with an information space might improve search outcomes. This study takes the first steps towards designing an analysis environment in which structural overlays evolve in response to an analyst\u2019s actions. Two sources of implicit feedback are explored: topical similarity to material included in a very brief written report, and eye behavior patterns. Results indicate that using eye-tracking can be as effective as lexical overlap, but more work is needed.", "num_citations": "16\n", "authors": ["1839"]}
{"title": "Resolution of textual code in a graphical hierarchical model of a technical computing environment\n", "abstract": " A device may receive a chart generated via a technical computing environment, where the chart includes a textual portion and a graphical portion, and the graphical portion includes state information. The device may parse the chart into the textual portion and the graphical portion, and may process the textual portion with a textual engine of the technical computing environment to generate textual results. The device may process the graphical portion with a graphical engine of the technical computing environment to generate graphical results, and may combine the textual results with the graphical results to generate chart results. The device may output or store the chart results.", "num_citations": "9\n", "authors": ["1839"]}
{"title": "Conditional-based duration logic\n", "abstract": " A model of a state machine may be created in a modeling environment, and the model may be executed over a simulation time. A duration operator may be defined within the model. The duration operator may include as an input argument, a conditional expression that may evaluate to True or False. During execution, the modeling environment may define a plurality of time steps over the course of the model's simulation time. The conditional expression of the duration operator may be evaluated at the time steps. When the conditional expression evaluates to True, the modeling environment may begin tracking elapsed simulation time, and may continue to track elapsed simulation time while the conditional expression remains True. The value of elapsed simulation time may be made available to other portions of the model.", "num_citations": "3\n", "authors": ["1839"]}
{"title": "Systems and methods for creating harness models for model verification\n", "abstract": " Systems and methods automatically construct a harness model having a selected component from source model. The systems and methods determine an execution context of the component in the source model, and construct and configure the harness model to provide the same or an equivalent execution context in the harness model. Model elements may be added to the harness model, and the model elements may be configured to replicate the execution context. The harness model may be executed, and the operation of the component evaluated. Changes to the component are synchronized between the source model and the harness model, as are changes to the component's execution context. Assessment operations may be included in the harness model, and these assessment operations may be evaluated when the harness model is executed. A verification report that includes the results of the\u00a0\u2026", "num_citations": "2\n", "authors": ["1839"]}
{"title": "User-centered Program Analysis Tools\n", "abstract": " The research and industrial communities have made great strides in developing advanced software defect detection tools based on program analysis. Most of the work in this area has focused on developing novel program analysis algorithms to find bugs more efficiently or accurately, or to find more sophisticated kinds of bugs. However, the focus on algorithms often leads to tools that are complex and difficult to actually use to debug programs.", "num_citations": "1\n", "authors": ["1839"]}
{"title": "Directing javascript with arrows (functional pearl)\n", "abstract": " JavaScript, being a single-threaded language, makes extensive use of event-driven programming to enable responsive web applications. However, standard approaches to sequencing events are messy, and often lead to code that is difficult to understand and maintain. We have found that arrows, a generalization of monads, are an elegant solution to this problem. Arrows allow us to easily write asynchronous programs in small, modular units of code, and flexibly compose them in many different ways, while nicely abstracting the details of asynchronous program composition. In particular, we show how to use arrows to construct a variety of state machines, such as autoscrollers and drag-and-drop handlers.", "num_citations": "1\n", "authors": ["1839"]}