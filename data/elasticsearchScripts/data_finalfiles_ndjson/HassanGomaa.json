{"title": "Designing Software Product Lines with UML\n", "abstract": " This book describes an evolutionary software engineering process for the development of software product lines, which uses the Unified Modeling Language (UML) notation. A software product line (or product family) consists of a family of software systems that have some common functionality and some variable functionality. The interest in software product lines emerged from the field of software reuse when developers and managers realized that they could obtain much greater reuse benefits by reusing software architectures instead of reusing individual software components. The field of software product lines is increasingly recognized in industry and government as being of great strategic importance for software development. Studies indicate that if three or more systems with a degree of common functionality are to be developed, then developing a product line is significantly more cost-effective than developing each system from scratch.The traditional mode of software development is to develop single systems\u2014that is, to develop each system individually. For software product lines, the development approach is broadened to consider a family of software systems. This approach involves analyzing what features (functional requirements) of the software family are common, what features are optional, and what features are alternatives. After the feature analysis, the goal is to design a software architecture for the product line, which has common components (required by all members of the family), optional components (required by only some members of the family), and variant components (different versions of which are required by different\u00a0\u2026", "num_citations": "1163\n", "authors": ["635"]}
{"title": "Software design methods for concurrent and real-time systems\n", "abstract": " From the Publisher: real-time, and distributed systems, describing the concepts most important in their design, and surveys the design methods available for them. Drawing on his experience in industry, he takes two related object-oriented methods - ADARTS (Ada-based Design Approach for Real-Time Systems) and CODARTS (Concurrent Design Approach for Real-Time Systems) - and shows in detail how they can be applied. The author first introduces the reader to real-time and concurrency concepts, and reviews the background in software design and development needed for the balance of the book. He then describes a number of methods that can be used for real-time and concurrent system design, comparing them through application to a common problem. Methods described include Real-time Structured Analysis and Design, Jackson System Development, Naval Research Lab/Software Cost Reduction\u00a0\u2026", "num_citations": "443\n", "authors": ["635"]}
{"title": "Software modeling and design: UML, use cases, patterns, and software architectures\n", "abstract": " This book covers all you need to know to model and design software applications from use cases to software architectures in UML and shows how to apply the COMET UML-based modeling and design method to real-world problems. The author describes architectural patterns for various architectures, such as broker, discovery, and transaction patterns for service-oriented architectures, and addresses software quality attributes including maintainability, modifiability, testability, traceability, scalability, reusability, performance, availability, and security. Complete case studies illustrate design issues for different software architectures: a banking system for client/server architecture, an online shopping system for service-oriented architecture, an emergency monitoring system for component-based software architecture, and an automated guided vehicle for real-time software architecture. Organized as an introduction followed by several short, self-contained chapters, the book is perfect for senior undergraduate or graduate courses in software engineering and design, and for experienced software engineers wanting a quick reference at each stage of the analysis, design, and development of large-scale software systems.", "num_citations": "280\n", "authors": ["635"]}
{"title": "A software design method for real-time systems\n", "abstract": " DARTS\u2014a design method for real-time systems\u2014leads to a highly structured modular system with well-defined interfaces and reduced coupling between tasks.", "num_citations": "245\n", "authors": ["635"]}
{"title": "Prototyping as a tool in the specification of user requirements\n", "abstract": " One of the major problems In developing new computer applications is specifying the useres requirements such that the Requirements Specification Is correct~ complete and unambiguous. Although prototyplng Is often considered too expensive, correctlng ambiguities and misunderstandings at the specification stake is significantly cheaper than correcting a system after It has gone into production.; his paper describes how a prototype was used to help specify the requirements of a computer system to manage and control a semiconductor processing facility. The cost of developing~ nd running the prototype was less than 10% of the total software development cost.", "num_citations": "192\n", "authors": ["635"]}
{"title": "Model composition in product lines and feature interaction detection using critical pair analysis\n", "abstract": " Software product lines (SPL) are an established technology for developing families of systems. In particular, they focus on modeling commonality and variability, that is, they are based on identifying features common to all members of the family and variable features that appear only in some members. Model-based development methods for product lines advocate the construction of SPL requirements, analysis and design models for features. This paper describes an approach for maintaining feature separation during modeling using a UML composition language based on graph transformations. This allows models of features to be reused more easily. The language can be used to compose the SPL models for a given set of features. Furthermore, critical pair analysis is used to detect dependencies and conflicts between features during analysis and design modeling. The approach is supported by a tool that\u00a0\u2026", "num_citations": "191\n", "authors": ["635"]}
{"title": "QoS management in service-oriented architectures\n", "abstract": " The next generation of software systems will be highly distributed, component-based and service-oriented. They will need to operate in unattended mode and possibly in hostile environments, will be composed of a large number of \u2018replaceable\u2019 components discoverable at run-time, and will have to run on a multitude of unknown and heterogeneous hardware and network platforms. This paper focuses on QoS management in service-oriented architectures in which service providers (SP) provide a set of interrelated services to service consumers, and a QoS broker mediates QoS negotiations between SPs and consumers. The main contributions of this paper are: (i) the description of an architecture that includes a QoS broker and service provider software components, (ii) the specification of a secure protocol for QoS negotiation with the support of a QoS broker, (iii) the specification of an admission control mechanism\u00a0\u2026", "num_citations": "137\n", "authors": ["635"]}
{"title": "Software reconfiguration patterns for dynamic evolution of software architectures\n", "abstract": " A software reconfiguration pattern is a solution to a problem in component-based software systems where the configuration needs to be updated while the system is operational. It defines how a set of components participating in a software pattern cooperate to change the configuration. This paper describes an approach for designing software reconfiguration patterns. It also describes how reconfiguration patterns can be used in reconfigurable software product line architectures. A change management model for dynamically evolving a software product line is also described. The paper concludes with a description of case studies and a proof-of-concept prototype.", "num_citations": "130\n", "authors": ["635"]}
{"title": "Software development of real-time systems\n", "abstract": " Concentrating on those aspects of software development peculiar to real-time systems, this collection of development methods and tools emphasizes incremental development; the testing of tusk interfaces during integration testing, as well as unit and partial integration testing on the development system; and the development of automated tools to assist in the testing process.", "num_citations": "126\n", "authors": ["635"]}
{"title": "A method for design and performance modeling of client/server systems\n", "abstract": " Designing complex distributed client/server applications that meet performance requirements may prove extremely difficult in practice if software developers are not willing or do not have the time to help software performance analysts. The paper advocates the need to integrate both design and performance modeling activities so that one can help the other. We present a method developed and used by the authors in the design of a fairly large and complex client/server application. The method is based on a software performance engineering language developed by one of the authors. Use cases were developed and mapped to a performance modeling specification using the language. A compiler for the language generates an analytic performance model for the system. Service demand parameters at servers, storage boxes, and networks are derived by the compiler from the system specification. A detailed model\u00a0\u2026", "num_citations": "125\n", "authors": ["635"]}
{"title": "Reusable software requirements and architectures for families of systems\n", "abstract": " In this article, an application domain perspective is applied to software reuse. An application domain is represented by a family of systems that have some features in common and others that differentiate them. A domain model is a problem-oriented architecture that captures the similarities and variations of the family of systems that compose the application domain. Because the application domain requirements capture the composite features of the members of the family, they are categorized as kernel (required by all family members) or optional (required by some family members). It is the optional features that determine the characteristics of a given target system. The relationship between the domain requirements and the object types in the domain model are captured by means of feature/object dependencies, which define the object types and prerequisite features needed to support a given feature. Software\u00a0\u2026", "num_citations": "119\n", "authors": ["635"]}
{"title": "Agent-oriented compositional approaches to services-based cross-organizational workflow\n", "abstract": " With the sophistication and maturity of distributed component-based services and semantic web services, the idea of specification-driven service composition is becoming a reality. One such approach is workflow composition of services that span multiple, distributed web-accessible locations. Given the dynamic nature of this domain, the adaptation of software agents represents a possible solution for the composition and enactment of cross-organizational services. This paper details design aspects of an architecture that would support this evolvable service-based workflow composition. The internal coordination and control aspects of such an architecture is addressed. These agent developmental processes are aligned with industry-standard software engineering processes.", "num_citations": "115\n", "authors": ["635"]}
{"title": "Modeling variability in software product lines with the variation point model\n", "abstract": " A major challenge for software reuse is developing components that can be reused in several applications. This paper describes a systematic method for providing components that can be extended through variation points, as initially specified in the software requirements. Allowing the reuser or application engineer to extend components at pre-specified variation points creates a more flexible set of components. The existing variation point methods do not provide enough design detail for the reuser. This paper introduces a method called the Variation Point Model (VPM), which models variation points at the design level, beginning with the common requirements. The product line approach provides a systematic approach for software reuse. A challenge with the product line approach is to model the variability between the core assets and the applications. This paper describes the VPM and how it is used for modeling\u00a0\u2026", "num_citations": "110\n", "authors": ["635"]}
{"title": "Multiple-view meta-modeling of software product lines\n", "abstract": " This paper describes a multiple-view meta-modeling approach for software product lines using the Unified Modeling Language notation (UML). A multiple-view model for a software product line is an object-oriented domain model which defines the different aspects of a software product line, namely the use case model, static model, collaboration model, statechart model, and feature model, including the commonality and variability. The meta-model depicts life cycle phases, views within each phase, and meta-classes within each view. The relationships between the different views are described. Consistency checking rules are defined based on the relationships among meta-classes in the meta-model. Finally, tool support for the approach is described.", "num_citations": "98\n", "authors": ["635"]}
{"title": "Dynamic software reconfiguration in software product families\n", "abstract": " This paper describes an approach for the dynamic reconfiguration of software product families. A software reconfiguration pattern is a solution to a problem in a software product family where the configuration needs to be updated while the system is operational. It defines how a set of components participating in a software pattern cooperate to change the configuration of a system from one configuration of the product family to another. An approach for the design of reconfiguration patterns and a change management model for software product families are also described. The paper concludes with a description of case studies and a proof-of-concept prototype.", "num_citations": "93\n", "authors": ["635"]}
{"title": "Design and performance modeling of component interconnection patterns for distributed software architectures\n", "abstract": " The ability to estimate the future performance of a large and complex distributed software system at design time, and iteratively refine these estimates at development time, can significantly reduce overall software cost and risk. This paper investigates component interconnection in client/server systems, in particular the design and performance modeling of component interconnection patterns, which define and encapsulate the way client and server components communicate with each other. We start with UML design models of the component interconnection patterns. These designs are performance annotated using an XML-type notation. The performance-annotated UML design model is mapped to a performance model, which allows us to analyze the performance of the software architecture executing on various system configurations.", "num_citations": "93\n", "authors": ["635"]}
{"title": "A framework for utility-based service oriented design in SASSY\n", "abstract": " The architecture of a software system has a significant impact on its quality of service (QoS) as measured by several performance metrics such as execution time, availability, throughput, and security. This paper presents a framework that is part of a large project called SASSY (Self-Architecting Software Systems), whose goal is to allow domain experts to specify the system requirements using a visual activity-based language. The SASSY framework automatically generates a base architecture that corresponds to the requirements. Then SASSY generates a new architecture, derived from the base architecture, that optimizes a utility function for the entire system. The utility function is a multivariate function of several QoS metrics. The paper shows a complete example and illustrates how SASSY automatically adapts to changes in the environment's QoS features.", "num_citations": "88\n", "authors": ["635"]}
{"title": "The impact of rapid prototyping on specifying user requirements\n", "abstract": " Prototyping has been recognized as being a powerful and indeed essential tool in many branches of engineering. Although software prototyping is often considered too expensive, correcting ambiguities and misunderstandings at the requirements specification stage is significantly cheaper than correcting a system after it has gone into production. This paper describes how rapid prototyping impacts the Requirements Analysis and Specification phase of the software life cycle. This is illustrated by describing the experience gained from a prototype used to assist in the requirements specification of a system to manage and control an integrated circuit fabrication facility. The cost of the prototype was less than 10 percent of the total software development cost.", "num_citations": "83\n", "authors": ["635"]}
{"title": "Modeling adaptive and evolvable software product lines using the variation point model\n", "abstract": " The product line approach provides a systematic approach for software reuse. A challenge with modeling adaptive and evolvable software product lines is how to model variability. This paper describes four different approaches to modeling variability, modeling variability using parameterization, modeling variability using information hiding, modeling variability using inheritance, and modeling variability using variation points. The variation point model (VPM) is used to demonstrate the fourth approach. VPM allows a reuser or application engineer to extend components at pre-specified variation points. For this to be possible, a variation point must be modeled such that the reuser has enough knowledge to build a variant.", "num_citations": "81\n", "authors": ["635"]}
{"title": "Service robot for the elderly\n", "abstract": " Our aim is to develop the service robot based on a systematic software engineering method, particularly for real-time, embedded and distributed systems with UML. To do so, we applied the COMET method, which is a UML-based method for the development of concurrent applications, specifically distributed and real-time applications. We describe our experience of applying the COMET/UML method to developing the service robot for the elderly, T-Rot, which is under development at CIR. Here, our emphasis was on an autonomous navigation system for the service robot, which is one of the most challenging issues and is essential in developing service robots, especially mobile service robots to help elderly people. It includes hardware integration for various sensors and actuators as well as software development and integration of modules like a path planner and a localizer.", "num_citations": "66\n", "authors": ["635"]}
{"title": "Structuring criteria for real time system design\n", "abstract": " This paper discusses and compares the criteria used. by different design methods for decomposing a. real tune system into tasks and modules. The criterta considered are coupling, cohesion and information hidin for module structurmg and concurrency for tasks.. TE e Structured Design method uses the module cou hng and cohesion criteria. The NRL method and Object 8. rtented Destgn use information hiding as the primary criterion for identifying modules and objects respectively. The Darts design method uses a set of task structuring criteria for identifying the concurrent tasks in the system. A new design method for real time systems is introduced that uses both task structuring and information hiding module structurmg criteria. The method is described and illustrated by means of an example of an automoble cruise control system", "num_citations": "66\n", "authors": ["635"]}
{"title": "A knowledge-based software engineering environment for reusable software requirements and architectures\n", "abstract": " This paper describes a prototype Knowledge-Based Software Engineering Environment used to demonstrate the concepts of reuse of software requirements and software architectures. The prototype environment, which is application-domain independent, is used to support the development of domain models and to generate target system specifications from them. The prototype environment consists of an integrated set of commercial-off-the-shelf software tools and custom developed software tools.               The concept of reuse is prevalent at several levels of the domain modeling method and prototype environment. The environment itself is domain-independent thereby supporting the specification of diverse application domain models. The domain modeling method specifies a family of systems rather than a single system; features characterize the variations in functional requirements supported by the\u00a0\u2026", "num_citations": "63\n", "authors": ["635"]}
{"title": "Automated software product line engineering and product derivation\n", "abstract": " This paper describes a prototype automated software product line engineering environment, in which a multiple view model of the product line architecture and components are developed and stored in a product line repository. Automated software product derivation consists of tailoring the product line architecture given the product features and selecting the components to be included in the product. The automated environment is built on top of Rational Rose RT. Automated support is provided for developing multiple product line views, using the feature model as the unifying view, an underlying product line meta-model that provides a schema for a product line repository, support for consistency checking among the multiple views, and support for feature-based product line derivation", "num_citations": "61\n", "authors": ["635"]}
{"title": "Object oriented analysis and modeling for families of systems with UML\n", "abstract": " This paper describes how the Unified Modeling Language (UML) notation can be used to model families of systems. The use case model for the family is used to model kernel and optional use cases. The static model for the family is used to model kernel, optional and variant classes, as well as their relationships. The dynamic model for the family is used to model object interactions in support of kernel and optional use cases, and for modeling all state dependent kernel, optional, and variant objects using statecharts.", "num_citations": "61\n", "authors": ["635"]}
{"title": "Validation of dynamic behavior in UML using colored Petri nets\n", "abstract": " This paper describes an approach for modeling the behavioral characteristics of concurrent objectoriented designs using the Petri net formalism. Specifically, this paper describes an approach for integrating colored Petri nets with concurrent object architecture designs created with the COMET method and specified in the Unified Modeling Language (UML). This work is part of an on-going effort to automate the behavioral analysis of concurrent and real-time object-oriented software designs.", "num_citations": "61\n", "authors": ["635"]}
{"title": "Designing software product lines with uml 2.0: From use cases to pattern-based software architectures\n", "abstract": " This tutorial addresses how to develop objectoriented requirements, analysis, and design models of software product lines using the Unified Modeling Language (UML) 2.0 notation.", "num_citations": "59\n", "authors": ["635"]}
{"title": "Dynamic software adaptation for service-oriented product lines\n", "abstract": " This paper describes a dynamic software adaptation approach and environment for service-oriented product lines. The approach uses a dynamic feature model and product line architecture for a family of service-oriented architectures (SOA), in which a member of the SOA can be dynamically adapted to a different member of the family at run-time. The approach integrates software product line and feature modeling concepts with SOA and dynamic software adaptation concepts. The approach is validated using a case study of a dynamic service-oriented product line.", "num_citations": "57\n", "authors": ["635"]}
{"title": "A software design method for distributed real-time applications\n", "abstract": " This paper describes a software design method for distributed real-time applications that typically consist of several concurrent tasks executing on multiple nodes supported by a local area network. The design method is an extension of DARTS, the design approach for real-time systems, and is called DARTS/DA, DARTS for distributed real-time applications. The method starts by developing a data flow model of the distributed application using structured analysis. The next stage involves decomposing the application into distributed subsystems based on a set of subsystem structuring criteria and defining the interfaces between them. Next, each subsystem is structured into concurrent tasks using the DARTS task structuring criteria and the interfaces between tasks are defined. Finally, each task, which represents a sequential program, is structured into modules using the structured design method. As an example\u00a0\u2026", "num_citations": "57\n", "authors": ["635"]}
{"title": "A framework for QoS-aware software components\n", "abstract": " The next generation of software systems will be highly distributed, component-based, service-oriented, will need to operate in unattended mode and possibly in hostile environments, will be composed of a large number of \"replaceable\" components discoverable at run-time, and will have to run on a multitude of unknown and heterogeneous hardware and network platforms. This paper focuses on service oriented-architectures in which each component provides a set of interrelated services to other components. These components are QoS-aware (i.e., aware of Quality of Service requirements) and are capable of engaging in QoS negotiations with other components of a distributed application. The main contributions of this paper are: i) the description of an architecture for QoS-aware software components that are able to negotiate QoS requirements with other components, ii) the specification of the protocols used for\u00a0\u2026", "num_citations": "52\n", "authors": ["635"]}
{"title": "A multiple-view meta-modeling approach for variability management in software product lines\n", "abstract": " This paper describes a multiple-view meta-modeling approach for managing variability in software product lines using the Unified Modeling Language notation (UML). A multiple-view meta-model for software product lines describes how each view relates semantically to other views. The meta-model depicts life cycle phases, views within each phase, and meta-classes within each view. The relationships between the meta-classes in the different views are described. Consistency checking rules are defined based on the relationships among the meta-classes in the meta-model. This paper briefly describes multiple-view modeling of software product lines before describing the multiple-view meta-modeling approach for software product lines and an approach for consistency checking between meta-model views. The paper then provides a detailed description of the tool support for product line multiple-view\u00a0\u2026", "num_citations": "51\n", "authors": ["635"]}
{"title": "An object-oriented domain analysis and modeling method for software reuse\n", "abstract": " Describes an object-oriented domain analysis and modeling method for analyzing and modeling a family of systems. This method addresses the issues of how to represent an application domain by means of multiple views, and how to represent similarities and variations in the domain. The method also supports an approach for generating a target system specification from the domain model, given the requirements of an individual target system. The goal is to provide a more effective way of managing system evolution and addressing software reuse from a generation technology perspective. The method is illustrated by means of an example.< >", "num_citations": "51\n", "authors": ["635"]}
{"title": "Model-based software design and adaptation\n", "abstract": " This paper describes a modeling approach to software design and adaptation, in particular the design of evolutionary and dynamically reconfigurable software architectures. The different versions of an evolutionary system are considered a software product line, with each version of the system a product line member. After implementation, the model co-exists with the system and evolves with it. The software architecture is built out of architectural patterns. For each software architectural pattern, there is a corresponding software reconfiguration pattern, which describes how the software architecture can be dynamically adapted.", "num_citations": "47\n", "authors": ["635"]}
{"title": "Designing concurrent, distributed, and real-time applications with UML\n", "abstract": " Object-oriented concepts are crucial in software design because they address fundamental issues of adaptation and evolution. With the proliferation of object-oriented notations and methods, the Unified Modeling Language (UML) has emerged to provide a standardized notation for describing object-oriented models. However, for the UML notation to be effectively applied, it needs to be used with an object-oriented analysis and design method. This tutorial describes the COMET method for designing real-time and distributed applications, which integrates object-oriented and concurrency concepts and uses the UML notation.", "num_citations": "47\n", "authors": ["635"]}
{"title": "Performance engineering of component-based distributed software systems\n", "abstract": " The ability to estimate the future performance of a large and complex distributed software system at design time can significantly reduce overall software cost and risk. This paper investigates the design and performance modeling of component interconnection patterns, which define and encapsulate the way client and server components communicate with each other. We start with UML design models of the component interconnection patterns. These designs are performance annotated using an XML-type notation. The performance-annotated UML design model is mapped to a performance model, which can be used to analyze the performance of the software architecture on various configurations.", "num_citations": "47\n", "authors": ["635"]}
{"title": "Variability modeling for service oriented product line architectures\n", "abstract": " Service Oriented Architecture (SOA) has emerged as a model for distributed computing that promotes flexible deployment and reuse. Software product lines (SPL) promote reusable development for product families. SOA systems need the capability of managing variability to address different client requirements. Our approach uses SPL concepts to model SOA systems as service families. SPL development relies on feature models to describe the commonality and variability of member applications. We introduce a multiple view SOA variability model based on feature modeling, which is described in UML and SoaML, the newly released SOA standard. Such a framework facilitates variability modeling of service families in a systematic and platform independent way.", "num_citations": "45\n", "authors": ["635"]}
{"title": "UML-based service robot software development: a case study\n", "abstract": " The research field of Intelligent Service Robots, which has become more and more popular over the last years, covers a wide range of applications from climbing machines for cleaning large storefronts to robotic assistance for disabled or elderly people. When developing service robot software, it is a challenging problem to design the robot architecture by carefully considering user needs and requirements, implement robot application components based on the architecture, and integrate these components in a systematic and comprehensive way for maintainability and reusability. Furthermore, it becomes more difficult to communicate among development teams and with others when many engineers from different teams participate in developing the service robot. To solve these problems, we applied the COMET design method, which uses the industry-standard UML notation, to developing the software of an\u00a0\u2026", "num_citations": "45\n", "authors": ["635"]}
{"title": "A reuse-oriented approach for structuring and configuring distributed applications\n", "abstract": " In this paper, we take a reuse-oriented perspective to designing configurable distributed applications. An application domain is defined as a family of systems with some features in common and others that differentiate them. During domain modelling, reusable specifications and architectures are developed, which capture the similarities and variations of the family of systems that compose the application domain. Target systems are generated by tailoring the reusable specifications and architectures, given the requirements of the target system. In this paper, we describe how the domain modelling approach to developing reusable software may be applied to the development of configurable distributed applications. We also describe criteria for distributed subsystem structuring and for distributed subsystem configuration. An example is provided of applying this approach.", "num_citations": "44\n", "authors": ["635"]}
{"title": "A software architectural design method for large-scale distributed information systems\n", "abstract": " This paper describes a software architectural design method for large-scale distributed information systems. The method, which is part of an integrated design and performance evaluation method, addresses the design of client/server software architectures, where the servers need to cooperate with each other to service client requests. The goal of this software architecture is to provide a concurrent message based design that is highly configurable. The method is illustrated by applying it to the design of a complex software system, the Earth Observing System Data and Information System (EOSDIS) Core System.", "num_citations": "43\n", "authors": ["635"]}
{"title": "Modeling behavioral design patterns of concurrent objects\n", "abstract": " Object-oriented software development practices are being rapidly adopted within increasingly complex systems, including reactive, real-time and concurrent system applications. While data modeling is performed very well under current object-oriented development practices, behavioral modeling necessary to capture critical information in real-time, reactive, and concurrent systems is often lacking. Addressing this deficiency, we offer an approach for modeling and analyzing concurrent object-oriented software designs through the use of behavioral design patterns, allowing us to map stereotyped UML objects to colored Petri net (CPN) representations in the form of reusable templates. The resulting CPNs are then used to model and analyze behavioral properties of the software architecture, applying the results of the analysis to the original software design.", "num_citations": "42\n", "authors": ["635"]}
{"title": "Dynamic self-adaptation for distributed service-oriented transactions\n", "abstract": " Dynamic software adaptation addresses software systems that need to change their behavior during execution. To address reuse in dynamic software adaptation, software adaptation patterns, also referred to as software reconfiguration patterns, have been developed. A software adaptation pattern defines how a set of components that make up an architecture or design pattern dynamically cooperate to change the software configuration to a new configuration given a set of adaptation commands. This paper describes a dynamic self-adaptation pattern for distributed transaction management in service-oriented applications.", "num_citations": "41\n", "authors": ["635"]}
{"title": "Domain modeling for software reuse and evolution\n", "abstract": " This paper describes a prototype domain modeling environment used to demonstrate the concepts of reuse of software requirements and software architectures. The environment, which is application-domain independent, is used to support the development of domain models and to generate target system specifications from them. The prototype environment consists of an integrated set of commercial-off-the-shelf software tools and custom developed software tools.< >", "num_citations": "41\n", "authors": ["635"]}
{"title": "A prototype domain modeling environment for reusable software architectures\n", "abstract": " This paper describes a prototype domain modeling environment used to demonstrate the concepts of reuse of software requirements and software architectures. The environment, which is application-domain independent, is used to support the development of domain models and to generate target system specifications from them. The prototype environment consists of an integrated set of commercial-off-the-shelf software tools and custom developed software tools. The concept of reuse is prevalent at several levels of the domain modeling method and prototype environment. The environment is domain-independent thereby supporting the specification of diverse application domain models. The domain modeling method specifies a family of systems rather than a single system; optional features characterize the variations in functional requirements supported by the family, and individual family members are\u00a0\u2026", "num_citations": "40\n", "authors": ["635"]}
{"title": "Multiple-view modelling and meta-modelling of software product lines\n", "abstract": " A multiple-view modelling and meta-modelling approach for software product lines (SPLs) using the unified modelling language notation is described. A multiple-view model for an SPL defines the different perspectives of the product line, namely the use case model, static model, collaboration model, statechart model and feature model, including the commonality and variability. The meta-model for SPLs depicts the life-cycle phases, views within each phase and meta-classes within each view. The relationships between the different meta-model views are described. Consistency checking rules are specified based on the relationships among meta-classes in the meta-model. These rules, which are specified formally using the object constraint language, are used to resolve inconsistencies between multiple views in the same phase or different phases, and to define allowable mappings between multiple views in\u00a0\u2026", "num_citations": "39\n", "authors": ["635"]}
{"title": "On a language based method for software performance engineering of client/server systems\n", "abstract": " Designing complex distributed client/server applications that meet performance requirements may prove extremely difficult in practice tf software developers are not willing or do not have the time to help software performance analysts. This paper advocates the need to integrate both activities so that one can help the other. We present a methodology developed and used by the authors in the design of a fairly large and complex C/S application. The methodology is based on Clisspe, a software performance engineering language developed by one of the authors. Use cases were developed using the language. A compiler for Clisspe generates an analytic performance model for the system. Service demand parameters at servers, storage boxes, and networks are derived by the compiler from the system specification. A detailed model of DBMS query optimizers allows the compiler to estimate the number of I/OS and\u00a0\u2026", "num_citations": "37\n", "authors": ["635"]}
{"title": "The impact of prototyping on software system engineering\n", "abstract": " CiNii \u8ad6\u6587 - The impact of prototyping on software system engineering CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092 \u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005 ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 The impact of prototyping on software system engineering GOMAA H. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 GOMAA H. \u53ce\u9332\u520a\u884c\u7269 System and Software Requirements Engineering System and Software Requirements Engineering, 543-552, 1990 IEEE Computer Press \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u9867\u5ba2\u5bfe\u8a71\u6642\u306e\u8981\u6c42\u7372\u5f97\u3068\u78ba\u8a8d\u3092\u652f\u63f4\u3059\u308b\u30d7\u30ed\u30c8 \u30bf\u30a4\u30d4\u30f3\u30b0\u30c4\u30fc\u30eb : ROAD/EE \u4e2d\u5cf6 \u6bc5 , \u7530\u6751 \u76f4\u6a39 , \u5ca1\u7530 \u548c\u4e45 , \u548c\u7530 \u96c4\u6b21 \u96fb\u5b50\u60c5\u5831\u901a\u4fe1\u5b66\u4f1a\u8ad6\u6587\u8a8c. DI, \u60c5\u5831\u30fb\u30b7\u30b9\u30c6\u30e0, I-\u60c5\u5831\u51e6\u7406 = The transactions of the Institute of Electronics, Information and \u2026", "num_citations": "33\n", "authors": ["635"]}
{"title": "Reusable component interconnection patterns for distributed software architectures\n", "abstract": " This paper investigates the design of reusable component interconnection in client/server systems. In particular, the paper describes the design of component interconnection patterns, which define and encapsulate the way client and server components communicate with each other. This paper uses the Unified Modeling Language (UML) to describe the component interconnection patterns for synchronous, asynchronous, and brokered communication. When designing a new distributed application, the appropriate component interaction patterns may then be selected and reused.", "num_citations": "32\n", "authors": ["635"]}
{"title": "Modelling complex systems by separating application and security concerns\n", "abstract": " This paper describes how to model complex applications by modelling application requirements and designs separately from security requirements and designs using the UML notation. By careful separation of concerns, the security requirements are captured in security use cases and encapsulated in security objects separately from the application requirements and objects. The approach reduces system complexity caused by mixing security requirements with business application requirements with the goal of making complex systems more maintainable. Furthermore, the security use cases and objects can be reused by other software applications.", "num_citations": "31\n", "authors": ["635"]}
{"title": "Methods and tools for the automated configuration of distributed applications from reusable software architectures and components\n", "abstract": " A reuse-oriented perspective is taken to designing and implementing configurable distributed applications. An application domain is defined as a family of systems that have some features in common and others that differentiate them. During domain engineering, reusable specifications, architectures and component types are developed, which capture the similarities and variations of the family of systems that compose the application domain. Target systems are generated by tailoring the reusable specification and architecture given the requirements of the target system, and configuring a target system based on the tailored architecture. The paper describes a method and software engineering environment for configuring distributed applications from a reusable architecture and library of predefined component types.", "num_citations": "31\n", "authors": ["635"]}
{"title": "Software requirements and architecture modeling for evolving non-secure applications into secure applications\n", "abstract": " This paper describes an approach to modeling the evolution of non-secure applications into secure applications in terms of the software requirements model and software architecture model. The requirements for security services are captured separately from application requirements, and the security services are encapsulated in connectors in the software architecture, separately from the components providing functional services. The enterprise architecture is described in terms of use case models, static models, and dynamic models. The software architecture is described in terms of components and connectors, which can be deployed to distributed configurations. By separating application concerns from security concerns, the evolution from a non-secure application to a secure application can be achieved with less impact on the application. An electronic commerce system is described to illustrate the approach.", "num_citations": "29\n", "authors": ["635"]}
{"title": "Knowledge-based automation of a design method for concurrent systems\n", "abstract": " This paper describes a knowledge-based approach to automate a software design method for concurrent systems. The approach uses multiple paradigms to represent knowledge embedded in the design method. Semantic data modeling provides the means to represent concepts from a behavioral modeling technique, called Concurrent Object-Based Real-time Analysis (COBRA), which defines system behavior using data/control flow diagrams. Entity-relationship modeling is used to represent a design metamodel based on a design method, called COncurrent Design Approach for Real-Time Systems (CODARTS), which represents concurrent designs as software architecture diagrams, task behavior specifications and module specifications. Production rules provide the mechanism for codifying a set of CODARTS heuristics that can generate concurrent designs based on semantic concepts included in COBRA\u00a0\u2026", "num_citations": "29\n", "authors": ["635"]}
{"title": "Software product line engineering for Web services and UML\n", "abstract": " Summary form only given. A software product line consists of a family of software systems that have some common functionality and some variable functionality. A better understanding of the product line can be obtained by considering the different perspectives, such as requirements modeling, static modeling, and dynamic modeling. This paper describes a multiple view UML based product line modeling approach for modeling software product lines based on Web services.", "num_citations": "28\n", "authors": ["635"]}
{"title": "Consistency in multiple-view UML models: a case study\n", "abstract": " Software designs described using UML consist of multiple views describing the static and dynamic views of the system being modeled. The dynamic modeling perspective is depicted by use cases during requirement modeling and by class diagrams, statecharts and interaction (sequence and collaboration) diagrams during analysis and design. For a given software design, these multiple views must be consistent with each other. This paper describes how consistency checking between multiple views of a software design can be carried out using Object Constraint Language (OCL) constraints, and is illustrated by a detailed case study", "num_citations": "28\n", "authors": ["635"]}
{"title": "Composition of software architectures from reusable architecture patterns\n", "abstract": " In this paper a software architecture perspective is taken to designing reusable software applications. An application domain is defined as a family of systems that have some features in common and others that differentiate them. During domain engineering, reusable specifications, architectural design patterns, and component types are developed, which capture the similarities and variations of the family of systems that compose the application domain. This paper describes the composition of software architectures from reusable feature based domain specific architectural design patterns.", "num_citations": "28\n", "authors": ["635"]}
{"title": "Feature based variability for service oriented architectures\n", "abstract": " Service Oriented Architecture (SOA) has emerged as a paradigm for distributed computing that promotes flexible deployment and reuse. A software product line (SPL) is a family of software systems that have some common functionality and some variable functionality. During application derivation, the common functionality is reused and a selection is made among the variable functionality. The challenge in SPL is to manage variability among the SPL members - feature modeling is frequently used for this purpose. SOA systems currently lack a systematic approach for managing variability in service requirements. The approach described in this paper addresses this problem by applying SPL concepts to model SOA systems as service families. In this paper, we describe how to model variability in the architectural views of a multiple-view SOA variability model. The approach integrates feature modeling with service\u00a0\u2026", "num_citations": "26\n", "authors": ["635"]}
{"title": "Feature driven dynamic customization of software product lines\n", "abstract": " This paper describes a model driven development approach for software product lines based on Web services, in which feature selection drives the dynamic customization of the product line architecture and implementation to derive the application. During product line modeling, feature and their dependencies are described in a feature model. The product line architecture is based around a client/server pattern consisting of user interface objects interacting with Web services. During application engineering, features are selected by the application engineer and used to dynamically customize the product line architecture and implementation.", "num_citations": "26\n", "authors": ["635"]}
{"title": "Modeling variability with the variation point model\n", "abstract": " A major challenge for software reuse is developing components that can be reused in several applications. This paper describes a systematic method for providing components that can be extended through variation points, as initially specified in the software requirements. Allowing the reuser or application engineer to extend components at pre-specified variation points creates a more flexible set of components. The existing variation point methods do not provide enough design detail for the reuser. This paper introduces a method called the Variation Point Model (VPM), which models variation points at the design level, beginning with the common requirements.", "num_citations": "25\n", "authors": ["635"]}
{"title": "Real-time software design for embedded systems\n", "abstract": " This tutorial reference takes the reader from use cases to complete architectures for real-time embedded systems using SysML, UML, and MARTE and shows how to apply the COMET/RTE design method to real-world problems. The author covers key topics such as architectural patterns for distributed and hierarchical real-time control and other real-time software architectures, performance analysis of real-time designs using real-time scheduling, and timing analysis on single and multiple processor systems. Complete case studies illustrating design issues include a light rail control system, a microwave oven control system, and an automated highway toll system. Organized as an introduction followed by several self-contained chapters, the book is perfect for experienced software engineers wanting a quick reference at each stage of the analysis, design, and development of large-scale real-time embedded systems, as well as for advanced undergraduate or graduate courses in software engineering, computer engineering, and software design.", "num_citations": "24\n", "authors": ["635"]}
{"title": "Analyzing behavior of concurrent software designs for embedded systems\n", "abstract": " This paper describes an integrated approach for the design and subsequent behavioral analysis of concurrent software designs for embedded systems. The approach integrates software design using the COMET concurrent object-oriented design method, colored Petri net (CPN) modeling, and performance measurement of the target system. The approach combines information from platform-independent and platform-specific models to construct analyses of software architectures for embedded systems. It allows an engineer/analyst to examine behavioral and performance properties of a software architecture design paired with a candidate implementation architecture. Applying the behavioral design patterns in the UML-based design along with corresponding CPN templates, the results from the analyses can be directly mapped back to the original design artifacts. The approach is illustrated using a robot controller\u00a0\u2026", "num_citations": "24\n", "authors": ["635"]}
{"title": "Modeling behavioral patterns of concurrent software architectures using Petri nets\n", "abstract": " To address behavioral modeling issues specific to concurrent software architectures, this paper outlines an approach for systematically modeling behavioral patterns found in concurrent software designs by applying colored Petri net (CPN) templates with UML artifacts. In this approach, CPNs are used as an underlying representation of the dynamic object-oriented architecture. These CPNs are then used to provide a simulated functional flow of the architecture and to analyze the concurrent behavior. By applying the results from the CPN analysis to the original UML model, an engineer can enhance the quality of the design and thereby gain additional insight to the behavioral properties of the software design prior to implementation.", "num_citations": "24\n", "authors": ["635"]}
{"title": "Data and information architectures for large-scale distributed data intensive information systems\n", "abstract": " The Earth Observing System (EOS) Data and Information System (EOSDIS) is perhaps one of the most important examples of large-scale, geographically distributed, and data intensive systems. The paper presents various facets of a data and information architecture for EOSDIS. EOS data is organized by means of an object-oriented schema, while EOS knowledge is organized through multiple domain-specific thesauri, complemented by domain knowledge and rules. The information holdings are organized into the source data archives, a data warehouse which provides an integrated view of the information holdings, and information marts which generate value-added information products for specialized user communities. Finally a federated client-server architecture is proposed to allow non-EOSDIS systems to become members of the EOSDIS community, allowing them to access EOSDIS holdings, and sharing\u00a0\u2026", "num_citations": "24\n", "authors": ["635"]}
{"title": "Software design methods for the design of large-scale real-time systems\n", "abstract": " This article discusses and compares the concepts and criteria used in software design methods for developing large-scale concurrent and modifiable real-time systems. Concurrency is addressed by task structuring, whereas modifiability is addressed by module structuring. In addition, the behavioral aspects of a real-time system are addressed by means of finitestate machines. Structured design, design approach for real-time systems (DARTS), Jackson system development JSD), Naval Research Laboratory (NRL) software cost reduction, and object-oriented design methods are compared from the perspective of how they address these concepts. Two related design methods for real-time systems, Ada-based DARTS (ADARTS) and concurrent DARTS (CODARTS), are described that use both task-structuring and information-hiding module-structuring criteria. The methods are described and illustrated by means of\u00a0\u2026", "num_citations": "24\n", "authors": ["635"]}
{"title": "Separation of concerns in software product line engineering\n", "abstract": " A software product line consists of a family of software systems that have some common functionality and some variable functionality. A better understanding of the product line can be obtained by separating the concerns of the common software, in terms of common features, components, and source code, from the variable software. This paper describes an approach and prototype tool support for separation of concerns and automatic customization of target applications, which are members of the software product line.", "num_citations": "23\n", "authors": ["635"]}
{"title": "A knowledge-based method for inferring semantic concepts from visual models of system behavior\n", "abstract": " Software designers use visual models, such as data flow/control flow diagrams or object collaboration diagrams, to express system behavior in a form that can be understood easily by users and by pogrammers, and from which designers can generate a software architecture. The research described in this paper is motivated by a desire to provide an automated designer's assistant that can generate software architectures for concurrent systems directly from behavioral models expressed visually as flow diagrams. To achieve this goal, an automated designer's assistant must be capable of interpreting flow diagrams in semantic, rather than syntactic, terms. While semantic concepts can be attached manually to diagrams using labels, such as stereotypes in the Unified Model Language (UML), this  paper considers the possibility of providing autmated assistance to infer appropriate tags for symbols on a flow diagram\u00a0\u2026", "num_citations": "23\n", "authors": ["635"]}
{"title": "A performance oriented design methodology for Large-Scale distributed data intensive information systems\n", "abstract": " The Earth Observing System (EOS) Data and Information System (EOSDIS) is perhaps one of the most important examples of a large-scale, geographically distributed, and data-intensive systems. Designing such systems in a way that ensures that the resulting design will satisfy all functional and performance requirements is not a trivial task. This paper presents a performance oriented methodology to design large-scale distributed data intensive information systems. The methodology is then applied to the design of the EOSDIS Core System (ECS). Performance results, based on queueing network models of ECS are also presented.", "num_citations": "22\n", "authors": ["635"]}
{"title": "Knowledge-based approach for generating target system specifications from a domain model\n", "abstract": " Several institutions in industry and academia are pursuing research efforts in domain modeling to address unresolved issues in software reuse. To demonstrate the concepts of domain modeling and software reuse, a prototype software engineering environment is being developed at George Mason University to support the creation of domain models and the generation of target system specifications. This prototype environment, which is applica-tion domain independent, consists of an inte-grated set of commercial off-the-shelf software tools and custom-developed software tools. This paper describes the knowledge-based tool that has been developed as part of the environ-ment to generate target system specifications from a domain model.At George Mason University, a project is underway to support software engineering lifecycles, methods, and prototyping environments to support software reuse at the requirements and design phases of the software lifecycle, in addition to the coding phase. A reuse-oriented software lifecycle, the Evolutionary Domain Lifecycle (Gomaa, 1989; Gomaa, 1991a) has been proposed, which is a highly iterative life-cycle that takes an application domain perspective allowing the development of families of systems. A domain analysis and modeling method has also been developed (Gomaa, 1990). This paper describes a knowledgebased approach for generating target system specifications from a domain model.", "num_citations": "22\n", "authors": ["635"]}
{"title": "A software modeling odyssey: Designing evolutionary architecture-centric real-time systems and product lines\n", "abstract": " According to OMG, \u201cmodeling is the designing of software applications before coding.\u201d This paper describes a modeling approach to software design. The paper describes the key elements of design methods for component based software product lines, which promote reuse, variability management, and evolution. Approaches for executable models and performance analysis of concurrent and real-time design are discussed. Finally, some outstanding challenges are outlined, in particular the design of evolutionary and dynamically reconfigurable software architectures.", "num_citations": "21\n", "authors": ["635"]}
{"title": "Software architectural reuse issues in service-oriented architectures\n", "abstract": " Many companies today are adopting service-oriented architecture (SOA). While SO A has the potential to offer significant benefits to companies, the architectural issues associated with this new architecture paradigm need to be explored. The goal of this paper is to explore software architectures and patterns for SOAs using unified modeling language (UML). Specifically, this paper addresses issues on composing applications from reusable services, differentiating between several services that are similar but not identical, and establishing a common data model.", "num_citations": "19\n", "authors": ["635"]}
{"title": "Modeling software product lines with uml\n", "abstract": " This position paper addresses how the Unified Modeling Language (UML)[Booch99, Rumbaugh99, Gomaa00a] may be used for modeling software product lines [DeBaud99](also referred to as software product families and families of systems). The paper considers how the various views of the UML, the use case view, the static modeling view, and the dynamic modeling view, may be used for modeling software product lines. It also considers how the feature model, which has been used for modeling the common and variable requirements in families of systems, can be integrated with the UML. Other papers addressing this topic are [Atkinson00, Cohen98, Gomaa00b, Griss98, Jacobson97].As an example of modeling software product lines, a factory automation product line is considered in this paper. The problem has been simplified to fit this paper. This product line encompasses three mutually exclusive kinds of factory systems, high volume low flexibility manufacturing systems, low volume highly flexible manufacturing systems, and factory monitoring systems.", "num_citations": "19\n", "authors": ["635"]}
{"title": "Architectural design patterns for flight software\n", "abstract": " Software design patterns are best practice solutions to common software design problems. When they are properly applied, software design patterns can greatly improve the quality of software architectures. However, applying design patterns in practice can be difficult since design pattern descriptions are domain and platform independent. Leveraging the benefits of design patterns is particularly important in the space flight software (FSW) domain because better designs are needed to help reduce the number of in flight software related anomalies. In order to address the aforementioned problems, this paper presents software architectural design patterns for space flight software. This paper describes how architectural design pattern templates can be used to build common features of FSW architectures. The FSW architectures produced can be validated for functional and performance correctness.", "num_citations": "18\n", "authors": ["635"]}
{"title": "Modeling state-dependent objects using colored Petri nets\n", "abstract": " This paper describes an approach for using Petri nets to model and analyze the behavioral characteristics of state-dependent objects represented in the Unified Modeling Language (UML). Specifically, this paper describes an approach for systematically mapping UML state-dependent objects and their corresponding statecharts into colored Petri nets. This work is part of an on-going effort to automate the behavioral analysis of concurrent and real-time object-oriented software designs. The benefit of this approach is that by providing a systematic means for modeling state-dependent objects using colored Petri nets and relating this to the larger research effort, the overall concurrent architecture may then be modeled and analyzed using a single, cohesive technique.", "num_citations": "17\n", "authors": ["635"]}
{"title": "Model-based Recovery Connectors for Self-adaptation and Self-healing.\n", "abstract": " Self-healing and self-configuration are highly desirable properties in software systems so that components can dynamically adapt to changing environments and recover from failure with minimal human intervention. This paper discusses a model-based approach for self-healing and self-configuration using recovery connectors. A recovery connector extends connectors in component-based software architectures and serviceoriented architectures with self-healing and self-configuration capabilities so that a component or service can be dynamically adapted and recovered from failures. The design of the recovery connector is based on the MAPE-K loop model and can handle both recovery and adaptation.", "num_citations": "16\n", "authors": ["635"]}
{"title": "Applying software product lines to multiplatform video games\n", "abstract": " In this paper, we explore the application of Software Product Line (SPL) technology in the video games domain by exploiting differences in various video game platforms to design a variable component-based software product line architecture for a multiplatform video game. Our approach consists of constructing a feature dependency model for describing variability in multiplatform video games. We explored variability in the user interface, input devices, output devices, CPU, as well as other variability in various video game platforms. Then, we designed a variable component-based SPL that is tailored to every video game in the product line. We validated our approach by implementing a SPL of a combat flight-simulator game and by deriving two versions of the game: a Windows desktop version and a Windows Phone version. The derivation process of each version is done by selecting features from the feature\u00a0\u2026", "num_citations": "16\n", "authors": ["635"]}
{"title": "An automated framework for variability management of service-oriented software product lines\n", "abstract": " Service Oriented Architecture (SOA) development practices typically lack a systematic framework for managing variability in service requirements and architectures. This paper addresses this gap by applying software product line (SPL) concepts to model SOA systems as service families. The approach is to model SOA variability with a multiple-view service model and a corresponding meta-model. We integrate SPL concepts of feature modeling and commonality/variability analysis with multiple service requirements and architectural views by using UML and the Service Oriented Architecture Modeling Language (SoaML). The paper describes an automated framework for service-oriented SPL engineering that allows modelers to design, deploy, and execute service-oriented SPLs.", "num_citations": "16\n", "authors": ["635"]}
{"title": "A pattern-based modeling approach for software product line engineering\n", "abstract": " This paper addresses the problem of variability in software product line (SPL) engineering by first considering different SPL model-based approaches and in particular the tradeoff between the development effort in domain engineering vs. application engineering. The paper then describes a SPL engineering approach, which is both model-based, and pattern-based. This approach bases the SPL software architecture on software architectural patterns and relates these patterns to SPL features. The paper describes how this approach has been applied to an unmanned space flight SPL.", "num_citations": "16\n", "authors": ["635"]}
{"title": "Service Allocation Mechanism\n", "abstract": " A system and method for allocating services is disclosed. A broker records a capability, for providing a service, and a demanded amount of resources for providing the services from at least one provider. A consumer requests a desired quality of service from the broker. The broker, using the demanded amount of resources and recorded capability, determines if the desired quality of service can be provided. If the broker can satisfy the request, the broker issues a certificate to the consumer, and the consumer provides the certificate directly to the provider to authorize provision of the service at the desired quality of service. If not, the broker generates a counter-offered quality of service that corresponds to the available amount for resources for accomplishing the service. In response, the consumer either rejects the counter-offered quality of service or accepts the counter-offer and receives a certificate for the counter\u00a0\u2026", "num_citations": "16\n", "authors": ["635"]}
{"title": "Domain modeling of software process models\n", "abstract": " The paper presents a novel application involving two important software engineering research areas: process modeling and software reuse. The Spiral Model is a risk-driven process model, which, depending on the specific risks associated with a given project, may be tailored to create a project-specific process model. The software reuse area is that of domain modeling of families of systems, which capture the similarities and variations among the members of the family. The domain modeling approach is used to create a domain model of a Spiral Process Model (SPM), thereby capturing the similarities and variations among a family of process models. The SPM domain model has been extended to capture the key process areas of the Software Engineering Institute's Capability Maturity Model (CMM). The domain model is used to generate project-specific process models. This approach allows managers to configure\u00a0\u2026", "num_citations": "16\n", "authors": ["635"]}
{"title": "Domain modeling methods and environments\n", "abstract": " At George Mason University, a project is underway to support software engineering lifeeycles, methods, and environments to support software reuse at the requirements and design phases of the software lifecycle, in addition to the coding phase. A reuse-oriented software lifecycle, the Evolutionary Domain Lifecycle [Gomaa89, Gomaa91a], has been proposed, which is a highly iterative lifeeycle that takes an application domain perspective allowing the development of families of systems. Current emphasis is on the domain analysis and specification phase of the EDLC for developing an application domain model, which captures the similarities and variations of the domain.", "num_citations": "16\n", "authors": ["635"]}
{"title": "Dare: A distributed adaptation and failure recovery framework for software systems\n", "abstract": " This paper describes DARE, an architecture-based, decentralized framework that provides both self-configuration and self-healing properties to large and highly dynamic software systems. The design of DARE is based on the autonomic computing MAPE-K loop model and integrates architecture discovery mechanisms with recovery and adaptation connectors. This paper describes the design and detailed experimental validation of the DARE framework which show DARE's decentralized capability of dynamically adapting and recovering components.", "num_citations": "15\n", "authors": ["635"]}
{"title": "Architecture-centric evolution in software product lines\n", "abstract": " This paper describes how an architecture-centric evolution approach can be used to develop and evolve software product line architectures. The architecturecentric evolution approach described in this paper uses a model driven architecture concept in which UML models of the software architecture are developed prior to implementation and later evolved after original deployment.", "num_citations": "14\n", "authors": ["635"]}
{"title": "A reusable architecture for federated client/server systems\n", "abstract": " This paper describes research into the design of reusable and extensible software architectures for families of systems. The approach is illustrated by an example of a federation of client/server software systems. The architecture, which is specified in an Architecture Description Language, is organized at three levels of software reuse, application domain independent, domain specific, and application specific. The architecture is composed of reusable domain specific black box architecture patterns and extensible domain specific white box architecture patterns. The paper describes the different levels of reuse in the software architecture and how the architecture may be extended.", "num_citations": "14\n", "authors": ["635"]}
{"title": "Use cases for distributed real-time software architectures\n", "abstract": " This paper describes how use cases can be applied to the architectural design of distributed real-time applications. In order to benefit from use cases in distributed real-time design it is necessary to extend use cases, particularly in the design phase, when important design decisions need to be made. To achieve this, use cases are integrated with CODARTS (Concurrent Design Approach for Real-Time Systems) distributed design concepts. Three different categories of use cases are described here, client/server use cases, subscription use cases and real-time control use cases. Different forms of message communication are associated with the different use case types. The overall design of the distributed real-time system is achieved by composing it from the use cases.", "num_citations": "14\n", "authors": ["635"]}
{"title": "Domain modeling for World Wide Web based software product lines with UML\n", "abstract": " This paper describes a domain modeling approach using the Unified Modeling Language (UML) for modeling software product lines of World Wide Web (WWW) based applications, thereby permitting reuse of domain requirements and analysis models. The paper describes how the various views of the UML, in particular the use case modeling view and the static modeling view, may be used for modeling such product lines and illustrates this with a domain modeling exercise. It also describes how the feature model can be integrated with the UML for modeling product lines.", "num_citations": "13\n", "authors": ["635"]}
{"title": "Feature Modeling for Service Variability Management in Service-Oriented Architectures.\n", "abstract": " Service Oriented Architecture (SOA) has emerged as a model for distributed software development that promotes flexible deployment and reuse. Software product lines (SPL) promote reusable application development for product families. Service oriented systems change to respond to changing clients\u2019 requirements. As they change, service oriented systems can be modeled as service families similar to the SPL concept. Some SPL development techniques rely on feature models to describe the commonality and variability of member applications. We use SPL feature modeling techniques to model the variability of service families. In this paper, we introduce a platform independent approach to model SOA variability based on feature modeling. We develop a UML meta-model to describe features. Then, we describe SOA variability scenarios using the newly released OMG standard SoaML. Finally, we develop a meta-model that maps features into SoaML. We believe that such an approach facilitates variability management of service families in a systematic and platform independent way.", "num_citations": "12\n", "authors": ["635"]}
{"title": "Tool support for software variability management and product derivation in software product lines\n", "abstract": " Software variability management is a key challenge in developing software product lines and deriving products from the product line. In order to provide effective variability management and product derivation in software product lines, which is capable of being automated, certain fundamental building blocks are required. These include multiple product line views, the feature model as the unifying view, an underlying product line meta-model that provides a schema for a product line repository, support for consistency checking among the multiple views, and support for feature-based product line derivation. This paper describes multiple-view modeling of software product lines, with particular emphasis on the feature modeling view, multiple-view UML meta-modeling for software product lines, variability management in the metamodel, and consistency checking between meta-model views. The paper then describes the requirements for tool support for product lines and product derivation, before describing a software prototype tool for this purpose and evaluating the effectiveness of the tool.", "num_citations": "12\n", "authors": ["635"]}
{"title": "Automated configuration of distributed applications from reusable software architectures\n", "abstract": " In this paper a reuse-oriented perspective is taken to designing and implementing configurable distributed applications. An application domain is defined as a family of systems that have some features in common and others that differentiate them. During domain engineering, reusable specifications, architectures and component types are developed, which capture the similarities and variations of the family of systems that compose the application domain. Target systems are generated by tailoring the reusable specification and architecture given the requirements of the target system, and configuring a target system based on the tailored architecture. The paper describes an automated approach for configuring distributed applications from a reusable architecture and library of predefined component types.", "num_citations": "12\n", "authors": ["635"]}
{"title": "A software design method for Ada based real time systems\n", "abstract": " Hassan Gomaa School of Information Technology & Engineering George Mason University Fairfax, Virginia 22030 and", "num_citations": "12\n", "authors": ["635"]}
{"title": "Desarm: A decentralized mechanism for discovering software architecture models at runtime in distributed systems\n", "abstract": " Runtime models play a critical role in modern self-adaptive systems. Hence, runtime architectural models are needed when making adaptation decisions in architecture-based self-adaptive systems. However, when these systems are distributed and highly dynamic, there is an added need to discover the systems software architecture model at runtime. Current methods of runtime architecture discovery take a centralized approach, in which the process is carried out from a single location. These methods are inadequate for large distributed systems because they do not scale up well and have a single point of failure. Also, systems of such size consist of nodes that are typically highly dynamic in nature. Existing approaches to architecture discovery are not capable of addressing these concerns. This paper describes DeSARM (Decentralized Software Architecture discoveRy Mechanism), a completely decentralized and automated approach for runtime discovery of software architecture models of distributed systems based on gossiping and message tracing. DeSARM is able to identify at runtime important architectural characteristics such as components and connectors, in addition to synchronous and asynchronous communication patterns. Furthermore, through its use of gossiping, it exhibits the properties of scalability, global consistency among participating nodes, and resiliency to failures. The paper discusses DeSARM\u2019s architecture and detailed design, and demonstrates its properties through experimentation.", "num_citations": "10\n", "authors": ["635"]}
{"title": "XANA: an end user software product line framework for smart spaces\n", "abstract": " This paper describes XANA, an end user development framework that extends existing end user development tools for smart spaces with software product line concepts. The framework targets two types of users: the Software Product Line (SPL) designers and the end users. SPL designers use XANA's product line creation interface to create the software product line for end users. The product line creation interface allows SPL designers to capture the product line's feature model, the component design that implements each feature and the product line architecture. End users using XANA's application derivation interface select the features needed for their smart spaces and generate software applications from the product line previously created. In this paper we present the phases and operational semantics of XANA. We illustrate its use with a case study. The paper presents a preliminary user study that was\u00a0\u2026", "num_citations": "10\n", "authors": ["635"]}
{"title": "Feature-based variability meta-modeling for service-oriented product lines\n", "abstract": " Service Oriented Architecture (SOA) has emerged as a paradigm for distributed computing that promotes flexible deployment and reuse. However, SOA systems currently lack a systematic approach for managing variability in service requirements and design. Our paper addresses this problem by applying software product line (SPL) concepts to model SOA systems as service families. We introduce an approach to model SOA variability with a multiple-view SOA variability model and a corresponding meta-model. The approach integrates SPL concepts of feature modeling and commonality/variability analysis with different service views using UML and SoaML. This paper describes a multiple-view meta-model that maps features to variable service models as well as model consistency checking rules. We describe how to derive family member applications and also present a validation of the approach.", "num_citations": "10\n", "authors": ["635"]}
{"title": "Applying software product line concepts in service orientation\n", "abstract": " Today's competitive business environment commands innovation, increasingly shorter time-to-market and efficiency. Product line technology, pioneered in manufacturing, is increasingly finding its way to the software sector allowing companies to sustain growth and achieve market success. Regardless of the domain, however, information systems have been behind all facets of business operations. Here, the emerging service oriented architectures can help provide the answers to the need for agility, versatility and economies. This effort introduces the concepts of software product lines and service orientation and explores their parallels. Next, it attempts to show the applicability of software product line methods to service orientation. Finally, the work discusses the main obstacles on the road to realising the synergy between these cutting-edge technologies.", "num_citations": "10\n", "authors": ["635"]}
{"title": "Improving the Reliability of Concurrent Object-Oriented Software Designs.\n", "abstract": " Object-oriented software development practices are being rapidly adopted within increasingly complex systems, including real-time and concurrent system applications. To address reliability issues with designing software architectures for these concurrent, time-critical system, this paper outlines an approach for integrating formalisms with state-of-the-practice object-oriented models expressed in UML. In this approach, colored Petri nets (CPNs) are used as an underlying representation of the dynamic object-oriented architecture. These CPNs are then used to provide a simulated functional flow of the architecture and to analyze the concurrent behavior. By applying the results from the CPN analysis to the original UML model, an engineer can enhance the quality of the design and thereby improve the reliability of the resulting system.", "num_citations": "10\n", "authors": ["635"]}
{"title": "Knowledge-based approach to domain modeling: Application to NASA's payload operations control centers\n", "abstract": " Several institutions in industry and academia are pursuing research efforts in domain modeling to address unresolved issues in software reuse. To demonstrate the concepts of domain modeling and software reuse, a prototype software engineering environment is being developed at George Mason University to support the creation of domain models and the generation of target system specifications. This prototype environment, which is application domain independent, consists of an integrated set of commercial off-the-shelf software tools and custom-developed software tools. This paper describes the knowledge-based tool that has been developed as part of the environment to generate target system specifications from a domain model. This knowledge-based approach to domain modeling has been applied to NASA's Payload Operations Control Center (POCC) domain.", "num_citations": "10\n", "authors": ["635"]}
{"title": "Extended the DARTS software design method to distributed real time applications\n", "abstract": " A software design method is described for distributed real-time applications that typically consist of several concurrent tasks executing on multiple nodes supported by a local area network. The design method is an extension of DARTS (design approach for real-time systems) and is called DARTS/DA (DARTS for distributed applications). The method starts by developing a data-flow model of the distributed application using structured analysis. The next stage involves decomposing the application into distributed subsystems based on a set of subsystem structuring criteria and defining the interfaces between therm. next each subsystem is structured into concurrent tasks using the DARTS task-structuring criteria, and the interfaces between tasks are defined. Finally each task is structured into modules. As an example, DARTS/DA is applied to the design of a distributed factory-automation system.<>", "num_citations": "10\n", "authors": ["635"]}
{"title": "Advances in software design methods for concurrent, real-time and distributed applications\n", "abstract": " This paper describes the advances in software design methods for concurrent, real-time and distributed applications from structured methods for centralized systems to distributed, object-oriented, component-based and service-oriented systems and product lines. The influence of software architectural and design patterns is also described. Current challenges for designing service-oriented architectures, adaptive software design, and evolutionary software design are also discussed.", "num_citations": "9\n", "authors": ["635"]}
{"title": "Feature dependent coordination and adaptation of component-based software architectures\n", "abstract": " This paper describes a feature dependent approach for the coordination and adaptation of distributed component-based software architectures, which can be used for applications derived from a software product line architecture or for evolutionary multi-version applications. The paper describes how feature dependent coordination components are used to coordinate the execution of kernel, optional and variant components in a distributed component-based software architecture.", "num_citations": "9\n", "authors": ["635"]}
{"title": "A software engineering environment for configuring distributed applications from reusable software architectures\n", "abstract": " In this paper a reuse-oriented perspective is taken for designing and implementing configurable distributed applications. An application domain is defined as a family of systems that have some features in common and others that differentiate them. During domain engineering, reusable specifications, architectures and component types are developed, which capture the similarities and variations of the family of systems that compose the application domain. Target systems are generated by tailoring the reusable specification and architecture given the requirements of the target system, and configuring a target system based on the tailored architecture. The paper describes a software engineering environment for configuring distributed applications from a reusable architecture and library of predefined component types.", "num_citations": "9\n", "authors": ["635"]}
{"title": "Integrating Petri nets with design methods for concurrent and real-time systems\n", "abstract": " This paper describes on-going efforts to integrate Petri nets with software design methods for concurrent and real time systems. Specifically, this paper presents an approach for integrating colored Petri nets with the Ada-based Design Approach for Real-Time Systems (ADARTS/sup SM/) and its sister method, CODARTS (Concurrent Design Approach for Real-Time Systems).", "num_citations": "9\n", "authors": ["635"]}
{"title": "Generating target system specifications from a domain model using CLIPS\n", "abstract": " The quest for reuse in software engineering is still being pursued and researchers are actively investigating the domain modeling approach to software construction. There are several domain modeling efforts reported in the literature and they all agree that the components that are generated from domain modeling are more conducive to reuse. Once a domain model is created, several target systems can be generated by tailoring the domain model or by evolving the domain model and then tailoring it according to the specified requirements. This paper presents the Evolutionary Domain Life Cycle (EDLC) paradigm in which a domain model is created using multiple views, namely. aggregation hierarchy, generalizationlspecialization hierarchies, object communication diagrams and state transition diagrams. The architecture of the Knowledge Based Requirements Elicitation Tool (KBRET) which is used to generate target system specifications is also presented. The preliminary version of KBRET is implemented in CLIPS.", "num_citations": "9\n", "authors": ["635"]}
{"title": "A modelling approach to the evalution of computer system performance\n", "abstract": " This thesis investigates some aspects of developing fast approximate models of computer system performance. Two different modelling techniques, regression and simulation modelling, have been applied and a method developed of combining their use within a multilevel hybrid modelling framework. The main objective of this thesis is to demonstrate the feasibility and value of this approach to the modelling and evaluation of computer system performance. The approach has been demonstrated by modelling a CDC 6000 computer system at three levels of detail. At each level, a self-contained model of the system has been developed. The Workload Model is a purely regression model of computer system performance. It was developed after a comprehensive performance analysis and analysis of residuals. The model expresses a batch job's elapsed time as a function of the job's reso'Irce demands and the load on the system. The model has been successfully validated. The Load Adjusting Model is a hybrid simulation/regression model in which a simulation framework is created which models job arrival and termination. Within this framework, regression techniques are used. The model has been successfully calibrated and validated. The Memory Management Model is developed from the Load Adjusting Model by a systematic expansion of detail. The Memory Management subsystem is simulated in considerable detail, whereas the rest of the system is modelled in much less detail. The model has been successfully calibrated and validated.", "num_citations": "9\n", "authors": ["635"]}
{"title": "A software product line approach for end user development of smart spaces\n", "abstract": " Several End User Development (EUD) tools have been proposed that enable end users to create software applications for smart spaces. Even though most of the tools focus on architecture and usability they don't take into account the end user background. For instance some end users are domain experts, experienced software developers, and others have very limited computer skills. Furthermore current EUD approaches do not address reuse. In this paper we present XANA, an EUD framework that extends existing EUD tools with Software Product Line (SPL) concepts. The framework targets two types of users: the application designers and the end users. Application designers create the SPL for end users. End users select SPL features and derive applications for their smart spaces. XANA promotes reuse by allowing end users to reuse features and components to create applications. We illustrate its use with\u00a0\u2026", "num_citations": "8\n", "authors": ["635"]}
{"title": "Model-based run-time software adaptation for distributed hierarchical service coordination\n", "abstract": " Dynamic software adaptation addresses software systems that need to change their behavior at run-time. A software adaptation pattern models how the components that make up an architecture pattern cooperate to change the software configuration at run-time. This paper describes a model-based run-time adaptation pattern for distributed hierarchical service coordination in service-oriented applications, in which multiple service coordinators are organized in a distributed hierarchical configuration.", "num_citations": "8\n", "authors": ["635"]}
{"title": "Software modeling of evolution to a secure application: From requirements model to software architecture\n", "abstract": " Software Modeling of Evolution to a Secure Application: From Requirements Model to Software Architecture \u2014 Texas Tech University Scholars Skip to main navigation Skip to search Skip to main content Texas Tech University Scholars Logo Home Scholars Organizations Grants Research Scholarly Activities Search by expertise, name or affiliation Software Modeling of Evolution to a Secure Application: From Requirements Model to Software Architecture Eonsuk Shin, Hassan Gomaa Computer Science Research output: Contribution to journal \u203a Article Overview Fingerprint Original language English Pages (from-to) 60-70 Journal Science of Computer Programming State Published - Apr 2007 Fingerprint Dive into the research topics of 'Software Modeling of Evolution to a Secure Application: From Requirements Model to Software Architecture'. Together they form a unique fingerprint. Software architecture Engineering \u2026", "num_citations": "8\n", "authors": ["635"]}
{"title": "Modeling behavioral patterns of concurrent objects using Petri nets\n", "abstract": " Object-oriented software development practices are being rapidly adopted within increasingly complex systems, including reactive, real-time and concurrent system applications. While data modeling is performed very well under current object-oriented development practices, behavioral modeling necessary to capture critical information in real-time, reactive, and concurrent systems is often lacking. Addressing this deficiency, we offer an approach for modeling and analyzing concurrent object-oriented software designs through the use of behavioral patterns captured through colored Petri nets", "num_citations": "8\n", "authors": ["635"]}
{"title": "Object-oriented modeling approaches to agent-based workflow services\n", "abstract": " With the increasing popularity of component-based services and semantic web services, the idea of specification-driven service composition is becoming a reality. With the distribution of these autonomous services, a realizable goal will be the transformation of the Internet into a universal service repository. In such an environment, intelligent agents can play a significant role in configuring and enacting the workflow composition of the atomic distributed services to create entirely new higher-level services. In this work, there is a large-scale agent-based architecture to support such a distributed service environment. Furthermore, we introduce an object-oriented modeling and software engineering approach towards the development, configuration, and operational control of the agents that manage processes in this cross- organizational workflow environment.", "num_citations": "8\n", "authors": ["635"]}
{"title": "Designing real-time and embedded systems with the COMET/UML method\n", "abstract": " 45 which the system has to interface. External classes are categorized using stereotypes. An external class can be an\" external input device\", an\" external output device\", an\" external I/O device\", an\" external user\", an\" external system\", or an\" external timer\". For a real-time system, it is desirable to identify low level external classes that correspond to the physical I/O devices to which the system has to interface. These external classes are depicted with the stereotype\" external I/O device\". Standard association names are used on system context class diagrams (Fig. 2) as follows:\u00b7\" external input device\" inputs to\" system\"\u00b7\" system\" outputs to\" external output device\"\u00b7\" external user\" interacts with\" system\"\u00b7\" external system\" interfaces to\" system\"\u00b7\" external timer\" awakens\" system\"", "num_citations": "8\n", "authors": ["635"]}
{"title": "Designing Real-Time applications with the COMET/UML method\n", "abstract": " Most object-oriented analysis and design methods only address the design of sequential systems or omit the important design issues that need to be addressed when designing real-time and distributed applications [Bacon97, Douglas99, Selic94]. It is essential to blend object-oriented concepts with the concepts of concurrent processing [MageeKramer99] in order to successfully design these applications. This paper describes some of the key aspects of the COMET method for designing real-time and distributed applications, which integrates object-oriented and concurrent processing concepts and uses the UML notation [Booch98, Rumbaugh99].", "num_citations": "8\n", "authors": ["635"]}
{"title": "Dynamic navigation in multiple view software specifications and designs\n", "abstract": " This paper describes an approach for dynamic navigation among multiple view software specifications and designs. Each view contains graphical and/or textual information about a particular aspect of the system. The paper describes an approach for facilitating access to a specification/design model by mapping the multiple views of the model to an integrated underlying representation and providing a Dynamic Navigation System for navigating through this representation in an application-independent and method-independent fashion. The paper also describes a hypermedia prototype that provides dynamic navigation among the multiple views using different search strategies and paths.", "num_citations": "8\n", "authors": ["635"]}
{"title": "Validating the ADARTS software design method for real-time systems\n", "abstract": " This paper outlines the validation of the Ada-based Design Approach for Real-Time Systems (ADARTS) undertaken by the Software Productivity Consortium.", "num_citations": "8\n", "authors": ["635"]}
{"title": "A Software Product Line Approach to Designing End User Applications for the Internet of Things.\n", "abstract": " The ubiquity of the Internet of Things (IoT) has made a big impact in creating smart spaces that can sense and react to human activities. The natural progression of these spaces is for end users to create customized applications that suit their everyday needs. One of the shortcomings of the current approaches is that there is a lack of reuse and end users have to design from scratch similar applications for different smart spaces, which leads to duplication of effort and software quality issues. This paper describes a systematic approach for adopting reuse in IoT by using Software Product Line (SPL) concepts while using design patterns relevant to these environments. In detail the paper describes the End User (EU) SPL process that can be used to design EU SPLs for IoT environments and derive applications for different smart spaces. A Smart Home case study is discussed to illustrate the inner workings of the EU SPL process for IoT applications.", "num_citations": "7\n", "authors": ["635"]}
{"title": "Design of secure software architectures with secure connectors\n", "abstract": " This paper describes the design of secure connectors that are used in the design of secure software architectures for distributed business applications. Mixing security concerns with business concerns in software architectures makes applications more complex. With the goal of making secure software architectures more maintainable and evolvable, the secure connectors proposed in this paper are designed separately from business application components by considering different communication patterns between the components as well as security services required by application components. Each secure connector encapsulates security relevant objects to provide application components with security services. In this paper, secure connectors are applied to design the software architectures of electronic commerce and automated teller machine applications.", "num_citations": "7\n", "authors": ["635"]}
{"title": "Evolving software requirements and architectures using software product line concepts\n", "abstract": " This paper proposes an evolutionary development approach, which uses software product line and feature modeling concepts for evolving software requirements and architectures. The different versions of an evolutionary system are considered a software product line, with each version of the system a product line member. Requirements are modeled using both use case and feature modeling. Evolution is built into the software development approach because variability in the software architecture is determined by considering the impact of each variable feature on the software architecture and evolving the architecture to address new features. Being feature based, the approach closely relates the evolution of the software architecture to the evolution of software requirements, as well as providing traceability between requirements and architecture.", "num_citations": "7\n", "authors": ["635"]}
{"title": "Service Variability Meta-Modeling for Service-Oriented Architectures\n", "abstract": " Service Variability Meta-Modeling for Service- Oriented Architectures Page 1 Service Variability Meta-Modeling for ServiceOriented Architectures Mohammad Abu-Matar and Hassan Gomaa Department of Computer Science George Mason University Fairfax, VA, USA mabumata@gmu.edu hgomaa@gmu.edu Software Variability Modeling Workshop (VARY11), MODELS Conference, Wellington, New Zealand g , October 2011 Page 2 THE PROBLEM Service Oriented Architecture (SOA) \u2013 Architectural style for distributed computing \u2013 Service providers offer services \u2013 Application development by assembling services Problem \u2013 Services need to support requirements of different clients SOA Variability is ad hoc and platform specific \u2013 SOA Variability is ad-hoc and platform specific \u2013 No systematic way to effectively model variability in SOA \u2022 In unified and platform independent manner In unified and platform independent \u2026", "num_citations": "7\n", "authors": ["635"]}
{"title": "Integration of the domain modeling method for families of systems with the SOFL formal specification language\n", "abstract": " An application domain is defined as a family of systems that have some features in common and others that differentiate them. A domain model is a multiple view object oriented analysis model for the application domain that reflects the common aspects and variations among the members of the family of systems that constitute the domain. The paper describes the integration of the domain modeling method for analyzing and modeling families of software systems with the SOFL formal specification language. Aggregation hierarchies and generalization/specialization hierarchies are depicted using the UML static modeling notation. Object communication diagrams are depicted using the SOFL condition data flow diagram notation. SOFL is used for the formal specification of the kernel, optional and variant classes.", "num_citations": "7\n", "authors": ["635"]}
{"title": "An approach for generating executable distributed applications from reusable software architectures\n", "abstract": " A reuse oriented perspective is taken to designing and implementing configurable distributed applications. An application domain is defined as a family of systems that have some features in common and others that differentiate them. During domain modeling, reusable specifications, architectures and component types are developed, which capture the similarities and variations of the family of systems that compose the application domain. Target systems are generated by tailoring the reusable specifications and architectures given the requirements of the target system, and configuring a target system based on the tailored architecture. The paper describes an approach for generating and configuring distributed applications from the domain model and a library of predefined component types.", "num_citations": "7\n", "authors": ["635"]}
{"title": "A behavioral analysis method for real-time control systems\n", "abstract": " This paper describes a method for analyzing and modeling real-time control systems called Concurrent Object-Based Real-Time Analysis (COBRA). COBRA is an alternative approach to Real-Time Structured Analysis, Object-Oriented Analysis, and Jackson System Development, for analyzing and modeling real-time control systems. It blends concepts from all three methods. A COBRA behavioural model can be mapped to an object-oriented design.", "num_citations": "7\n", "authors": ["635"]}
{"title": "An architecture-based dynamic adaptation model and framework for adaptive software systems\n", "abstract": " This paper describes an architecture-based dynamic adaptation model and framework for adaptive software systems. The framework provides for a reusable adaptation infrastructure and uses a layered architecture pattern. It also provides separation of concerns from the system's software architecture and supports internal state information checkpointing and restoration. Any dynamic software adaptation process, whether instigated internally or externally, makes runtime changes only to affected components. The dynamic adaptation model separates adaptation-impacted parts of a system from those that need not be concerned with the dynamic adaptation.", "num_citations": "6\n", "authors": ["635"]}
{"title": "Separating application and security concerns in use case models\n", "abstract": " This paper describes an approach to model complex applications by modeling application requirements separately from security requirements in use case models. By careful separation of concerns, the security requirements are captured in security use cases separately from the application requirements, which are captured in application use cases. The approach reduces system complexity caused by mixing security requirements with business application requirements with the goal of making complex systems more maintainable. Furthermore, the security use cases can be reused by other software applications. This paper describes how the application and security concerns are modeled separately, and how they can be woven together into an application.", "num_citations": "6\n", "authors": ["635"]}
{"title": "Variability in multiple-view models of software product lines\n", "abstract": " This paper describes how variability is handled in multiple-view models of software product lines, which are depicted using the Unified Modeling Language notation (UML). A multiple-view model for a software product line is an object-oriented domain model which defines the different aspects of a software product line, namely the use case model, static model, collaboration model, statechart model, and feature model, including the commonality and variability. The relationships between the different views are described. The integration of multiple views is achieved by considering relationships among the views in a multiple view meta-model, so that consistency between multiple views is maintained as the multiple-view model evolves. Finally, tool support for the approach is described.", "num_citations": "6\n", "authors": ["635"]}
{"title": "Inter-agent communication in cooperative information agent-based systems\n", "abstract": " This paper describes several different approaches for information agents to communicate and cooperate with each other in agent-based systems. The paper describes different communication patterns for inter-agent cooperation. In particular, three patterns of inter-agent communication are described in more detail, brokered communication, subscription/notification communication, and negotiated communication. In each case, the pattern is described and examples of its use are given. The cooperative inter-agent interactions are described in the Unified Modeling Language (UML) notation. Agent-based systems can be designed using these different patterns of interagent communication. Examples are given from electronic commerce, realtime monitoring, and travel reservation systems.", "num_citations": "6\n", "authors": ["635"]}
{"title": "Configuration of distributed heterogeneous information systems\n", "abstract": " Summary form only given. In a paper by H. Gomaa, 1993), a domain modeling approach was described for structuring and configuring families of distributed applications. The problem addressed now is the configuration of evolving distributed heterogenous information systems. The solution to this problem proposed by the author is to create a federation of information systems. Rather than individual information systems having to wrestle with interfacing to each other, all information systems that are interested in cooperating together form a federation, which provides an agreed set of services and addresses the information integration problem in a unified manner. A federation interface manager is a software subsystem that manages each member information system's interface to the federation. The goal is to allow each information system's clients and server(s) to be integrated into the federation with the minimum\u00a0\u2026", "num_citations": "6\n", "authors": ["635"]}
{"title": "A prototype software engineering environment for domain modeling and reuse\n", "abstract": " The topics are presented in viewgraph form and include the following: the evolutionary domain life cycle; domain modeling; NASA payload operations control center domain modeling; prototype software engineering environment creating domain model; prototype software engineering environment target system specification; and the Knowledge Based Requirements Elicitation Tool (KBRET). (Author)", "num_citations": "6\n", "authors": ["635"]}
{"title": "Reusable secure connectors for secure software architecture\n", "abstract": " This paper describes the design of reusable secure connectors that are used in the design of secure software architectures for distributed software applications. The secure connectors are designed separately from application components by reusing the appropriate communication pattern between components as well as the security services required by these components. Each secure connector is designed as a composite component that encapsulates both security service components and communication pattern components. Integration of security services and communication patterns within a secure connector is provided by a security coordinator. The main advantage is that secure connectors can be reused in different applications. In this paper, secure connectors are reused in electronic commerce and automated teller machine applications.", "num_citations": "5\n", "authors": ["635"]}
{"title": "A comparison of executable model based approaches for embedded systems\n", "abstract": " Designing and building embedded systems is a challenging problem. Designers must ensure that the software architecture meets its functional requirements and also, since embedded systems often have real-time constraints, meets its performance requirements. It is usually difficult to determine whether or not the embedded system designs will meet functional and performance requirements. To help increase confidence in embedded software architectures, designers often turn to executable model based approaches to assess their systems. There are many different approaches for designing and analyzing real-time embedded systems. This paper is intended to help designers in their choice by comparing two different executable model based approaches for designing and validating real-time embedded systems, namely state machines and colored Petri nets. Both approaches are compared using seven different\u00a0\u2026", "num_citations": "5\n", "authors": ["635"]}
{"title": "Software product line engineering of space flight software\n", "abstract": " This paper presents a practical solution to a real life industrial problem in the unmanned space flight software (FSW) domain using software product lines and software architectural design patterns. In the FSW domain, there exists a significant amount of variability in the required capabilities. For example, some FSW have a significant amount of hardware to control and operate in a nearly autonomous fashion. In contrast, other FSW have a small amount of hardware to control and rely heavily of commanding from the ground station to operate the spacecraft. The underlying architecture and component interactions needed for the different FSWs are quite different. This amount of architectural variability makes it difficult to develop a SPL architecture that covers the all possible variability in the FSW domain. Therefore, this paper presents a practical solution to this real world problem that leverages software product line\u00a0\u2026", "num_citations": "5\n", "authors": ["635"]}
{"title": "Model-based software design of real-time embedded systems\n", "abstract": " This paper describes a model-based software design method for real-time embedded systems. When designing concurrent and real-time systems, it is essential to blend object-oriented concepts with the concepts of concurrent processing. This paper describes a model-based software design method for designing real-time embedded systems, which integrates object-oriented and concurrent processing concepts and uses the UML notation.", "num_citations": "5\n", "authors": ["635"]}
{"title": "Independent Model-Driven Software Performance Assessments of UML Designs\n", "abstract": " In many software development projects, performance requirements are not addressed until after the application is developed or deployed, resulting in costly changes to the software or the acquisition of expensive high-performance hardware. To remedy this, researchers have developed model-driven performance analysis techniques for assessing how well performance requirements are being satisfied early in the software lifecycle. In some cases, companies may not have the expertise to perform such analysis on their software; therefore they have an independent assessor perform the analysis. This paper describes an approach for conducting independent model-driven software performance assessments of UML 2.0 designs and illustrates this approach using a real-time signal generator as a case study", "num_citations": "5\n", "authors": ["635"]}
{"title": "Software Product Line Engineering and Dynamic Customization of a Radio Frequency Management System\n", "abstract": " Unified Memory is an emerging technology which is supported by CUDA 6. X. Before CUDA 6. X, the existing CUDA programming model relies on programmers to explicitly manage data between CPU and GPU and hence increases programming complexity. CUDA 6. X provides a new technology which is called as Unified Memory to provide a new programming model that defines CPU and GPU memory space as a single coherent memory (imaging as a same common address space). The system manages data access between CPU and GPU without explicit memory copy functions. This paper is to evaluate the Unified Memory technology through different applications on different GPUs to show the users how to use the Unified Memory technology of CUDA 6. X efficiently. The applications include Diffusion3D Benchmark, Parboil Benchmark Suite, and Matrix Multiplication from the CUDA SDK Samples. We\u00a0\u2026", "num_citations": "5\n", "authors": ["635"]}
{"title": "Software design methods for concurrent and real-time systems\n", "abstract": " This tutorial surveys the state of the art in software design methods for concurrent and real-time systems. The important concepts of concurrent tasking, fundamental to the design of this class of system, information hiding, fundamental to the design of modifiable and reusable components, finite state machines, for addressing the behavioral aspects of a system, and object-oriented concepts, for the systematic adaptation of components, are introduced. Several design methods for concurrent and real-time systems are presented and compared. The design of distributed applications will also be addressed. The tutorial is illustrated by means of several examples. The tutorial will also discuss the industrial and academic courses that can be given based on this material.", "num_citations": "5\n", "authors": ["635"]}
{"title": "A Software Product Line Approach for Feature Modeling and Design of Secure Connectors.\n", "abstract": " This paper describes a software product line approach to modeling the variability of secure software connectors by means of a feature model, which consists of security pattern and communication pattern features used in the design of secure component-based software architectures for concurrent and distributed software applications. Applying separation of concerns, these features are designed as security and communication pattern components. Each secure connector is designed as a composite component that encapsulates both security pattern and communication pattern components. Integration of these components within a secure connector is enabled by a security coordinator. This paper describes the feature model, design of secure connectors, how applications are built using secure connectors, and the validation of the approach.", "num_citations": "4\n", "authors": ["635"]}
{"title": "TESS: Automated performance evaluation of self-healing and self-adaptive distributed software systems\n", "abstract": " This paper deals with the problem of evaluating and testing recovery and adaptation frameworks (RAF) for distributed software systems. We present TESS, a testbed for automatically generating distributed software architectures and their corresponding runtime applications, deploying them to the nodes of a cluster, running many different types of experiments involving failures and adaptation, and collecting in a database the values of a variety of failure recovery and adaptation metrics. Using the collected data, TESS automatically performs a thorough and scientific analysis of the efficiency and/or effectiveness of a RAF. This paper presents a case study on the use of TESS to evaluate DARE, a RAF developed by our group.", "num_citations": "4\n", "authors": ["635"]}
{"title": "Model-based Design of Reusable Secure Connectors.\n", "abstract": " This paper describes the integration of security and communication patterns in reusable secure connectors that are incorporated in the model-based design of secure distributed component-based software architectures. The secure connectors are designed separately from application components by reusing the appropriate communication pattern between components as well as the security patterns required by these components. Each secure connector is designed as a composite component that encapsulates both security pattern and communication pattern components. Integration of security patterns and communication patterns within a secure connector is enabled by a security coordinator. The main advantage is that secure connectors can be reused in different secure applications.", "num_citations": "4\n", "authors": ["635"]}
{"title": "Model-Based Recovery and Adaptation Connectors: Design and Experimentation\n", "abstract": " This paper describes the design of model-based Recovery and Adaptation Connectors (RAC) that handle recovery and adaptation concerns of services in service-oriented architectures. When a service needs to be dynamically adapted, RAC ensures that the service first transitions to a quiescent state before it is replaced with a new service. When a service recovers from a run-time failure, RAC ensures that transactions that have been interrupted due to service failure are aborted and then restarted with the recovered service. Thus, RAC ensures that no transactions are lost due to dynamic service adaptation or failure. The design of the RAC is based on the autonomic computing MAPE-K loop model and handles both stateless and stateful services. Our approach has been validated through experimentation of planned failure and adaptation scenarios.", "num_citations": "4\n", "authors": ["635"]}
{"title": "Integrating and applying architectural design patterns in space flight software product lines\n", "abstract": " The unmanned space flight software (FSW) domain contains a significant amount of variability within its required capabilities. Although all FSW execute commands from the ground station to control the spacecraft, there is significant amount of variability in the volume of commands that must be processed, the amount of control given to the ground station versus onboard autonomy, and the amount and type of hardware that requires controlling. This degree of architectural variability makes it difficult to develop a FSW software product line (SPL) architecture that covers the all possible variations. In order to address this challenge, this paper presents a SPL approach for FSW SPLs that manages variability at a higher level of granularity using software architectural design patterns and requires less modeling during the SPL engineering phase. Specifically it describes how variable design patterns can be interconnected to\u00a0\u2026", "num_citations": "4\n", "authors": ["635"]}
{"title": "Designing software product lines with the unified modeling language (UML)\n", "abstract": " This tutorial addresses how to develop object-oriented requirements, analysis, and design models of software product lines using the Unified Modeling Language (UML) 2.0 notation. During requirements modeling, the tutorial covers how to develop kernel, optional, and alternative use cases for defining the software functional requirements of the system. The tutorial also describes the feature model for capturing product line requirements and how it relates to the use case model. During analysis, the tutorial covers how to develop static models for defining kernel, optional, and variant classes and their relationships. It also describes how to create dynamic models in which interaction models describe the dynamic interaction between the objects that participate in each kernel, optional, and alternative use case, and in which statecharts define the state-dependent aspects of the product line. The tutorial then\u00a0\u2026", "num_citations": "4\n", "authors": ["635"]}
{"title": "A software design method for Ada 95 based concurrent and real-time systems\n", "abstract": " The Ada-based Design Approach for Real-Time Systems (ADARTS SM) is a design approach for concurrent and real-time systems using the Ada programming language. The current version of Ada, Ada 83, has many shortcomings for concurrent and real-time systems, several of which are addressed by the Ada 95 revision to the Ada language. This paper describes how the features of Ada 95 that help in concurrent software design have been incorporated into the ADARTS 95 and CODARTS/Ada 95 design methods. It uses an automobile cruise control system case study to examine an Ada 95 implementation of a concurrent and real-time system in comparison to the Ada 83 solution.", "num_citations": "4\n", "authors": ["635"]}
{"title": "Objects and domain engineering (panel)\n", "abstract": " Domain engineering is a field that has been emerging as a key component of any domainspecific reuse strategy. Domain engineering is a means of analysing and modelling a problem domain with a view to reusing the concepts of that domain across multiple software systems. There are domain analysis approaches currently available that are not based on object-oriented techniques, yet an object-oriented approach would seem to some to be the most suitable for domain engineering.", "num_citations": "4\n", "authors": ["635"]}
{"title": "Structuring and configuring distributed applications\n", "abstract": " An approach is described for designing configurable distributed applications. The main characteristics of this approach are: domain modeling where a domain model corresponds to an architecture for a family of systems, in which members of the family have some components in common and others that vary and the domain model captures the similarities and variations of the members of the family; target system generation where the architecture of the target system is generated from the domain model, based on the features (requirements) of the individual target system; and target system configuration when the instances of the target system components are generated and interconnected and the components are mapped onto a hardware configuration. The domain modeling approach models the application domain as a collection of concurrent objects that communicate by means of messages.< >", "num_citations": "4\n", "authors": ["635"]}
{"title": "The software engineering of a microcomputer application system\n", "abstract": " A system development methodology is outlined before describing its application to the development of a microcomputer system. Structured analysis techniques were used for determining the information flow through the system. The system was then structured into modules using structured design and information hiding techniques. The detailed design of the system was described in pseudocode. The system was coded in assembler supplemented by a set of structured programming macros. A systematic bottom\u2010up testing procedure was adopted for system integration.", "num_citations": "4\n", "authors": ["635"]}
{"title": "A simulation based model of a virtual storage system\n", "abstract": " This paper describes how two different modelling techniques, regression and simulation modelling, have been combined within a hybrid simulation/regression model of a virtual storage computer system. In the model, simulation techniques are used to model in detail a task's arrival, entering and dropping from the multiprogramming set, and termination. The rest of the system is modelled in much less detail mainly using regression techniques. The application of this method to modelling an IBM VM/370 system is described.", "num_citations": "4\n", "authors": ["635"]}
{"title": "Applying end user software product line engineering for smart spaces\n", "abstract": " Smart spaces are physical environments equipped with pervasive technology that sense and react to human activities and changes in the environment. End User Development (EUD) skills vary significantly among end users who want to develop software applications for their smart spaces. This paper presents a systematic approach for adopting reuse in EUD for smart spaces by using Software Product Line (SPL) concepts. End User (EU) SPL designers develop EU SPLs for smart spaces whereas end users derive their individual smart space applications from these SPLs. In particular, this paper presents a systematic approach for EU SPL designers to develop EU SPLs and end users to derive software applications for their spaces, an EUD environment that supports EU SPL development and application derivation, and a testing approach for testing EU SPLs and derived applications.", "num_citations": "3\n", "authors": ["635"]}
{"title": "Run-time Software Architectural Models for Adaptation, Recovery and Evolution.\n", "abstract": " This paper describes approaches for dynamic software adaptation using runtime models of the software architecture. Software adaptation patterns consist of interaction models and state machine models that are used during dynamic software adaptation. Software adaptation and recovery concerns are off-loaded from components by incorporating them into connectors, which are responsible for dynamically adapting and recovering components. Both centralized and decentralized approaches to adaptation and recovery are considered. Two approaches to dynamic software product lines are described, a dynamic software adaptation approach for service-oriented product lines and the design of variable adaptation and recovery connectors.", "num_citations": "3\n", "authors": ["635"]}
{"title": "A Multi-platform End User Software Product Line Meta-model for Smart Environments.\n", "abstract": " End User (EU) architectures for smart environments aim to enable end users to create and deploy software applications for their smart spaces. EU Software Product Lines (SPL) extend EU architectures for smart environments with product line support to promote reuse and software application portability. This paper describes a meta-modeling approach for developing EU SPLs for smart environments. We present a metamodel as the basis for developing a framework for creating EU SPLs and deriving EU applications. The metamodel is composed of platform independent and platform specific meta-models. This paper describes in detail both parts of the meta-model and discusses the relationships and mappings between them. This paper also presents the XANA EU SPL framework that was developed using the proposed platform specific meta-model and discusses XANA\u2019s product line creation and application derivation process.", "num_citations": "3\n", "authors": ["635"]}
{"title": "Variability modeling in model-driven software product line engineering\n", "abstract": " This paper describes an approach for modeling variability in software product lines that are developed, and later evolved, using model-driven software product line development. This paper describes variability management in UML based multiple-view models of the software product line, which consist of developing use case and feature models during requirements modeling, static and dynamic models during analysis modeling, and component-based software architectures during design modeling. This paper also describes an underlying multiple-view meta-model for the software product line, with consistency checking between the multiple views.", "num_citations": "3\n", "authors": ["635"]}
{"title": "Modeling and Analysis of Concurrent and Real-Time Object-Oriented Designs\n", "abstract": " Object-oriented software development practices are being rapidly adopted within increasingly complex systems, including real-time and concurrent system applications. To increase confidence in the resulting software designs for these concurrent, time-critical systems, this position paper outlines an approach for integrating formalisms with state-of-the-practice object-oriented models expressed in UML. In this approach, colored Petri nets (CPNs) are used as an underlying representation of the dynamic object-oriented architecture. These CPNs are then used to provide a simulated functional flow of the architecture and to analyze the concurrent behavior. By applying the results from the CPN analysis to the original UML model, an engineer can enhance the quality of the design and thereby gain confidence that that resulting design meets the functional and performance requirements of the system.", "num_citations": "3\n", "authors": ["635"]}
{"title": "Object-Oriented Modeling Approaches to Agent-Based CrossOrganizational Workflow\n", "abstract": " With the increasing popularity of component-based services and semantic web services, the idea of specification-driven service composition is becoming a reality. With the distribution of these autonomous services, a realizable goal will be the transformation of the Internet into a universal service repository. In such an environment, intelligent agents can play a significant role in configuring and enacting the workflow composition of the atomic distributed services to create entirely new higher-level services. In this work, there is a large-scale agent-based architecture to support such a distributed service environment. Furthermore, we introduce an object-oriented modeling and software engineering approach towards the development, configuration, and operational control of the agents that manage processes in this cross-organizational workflow environment.", "num_citations": "3\n", "authors": ["635"]}
{"title": "A Knowledge-Based Method for Inferring Semantic Concepts from Graphical Models of Real-time Systems\n", "abstract": " Designers of software for real-time systems often use models, in the form of data flow/control flow diagrams, to express system behavior in a graphical notation that can be understood easily by users and by programmers, and from which designers can generate a software architecture. The research described in this paper is motivated by the desire to provide an automated designer\u2019s assistant that can generate software architectures for real-time systems directly from models expressed as data flow/control flow diagrams. To achieve this goal, an automated designer\u2019s assistant must be capable of interpreting flow diagrams in semantic, rather than syntactic, terms. Unfortunately, flow diagrams, with a limited number of syntactic elements, are seldom expressive enough to depict the semantic concepts that a designer intends; instead, most design methods that include flow diagrams allow the designer to augment those diagrams with a textual description to express semantic information. This paper proposes a knowledge-based approach capable of inferring the presence of semantic concepts from data flow/control flow diagrams. To illustrate the approach, the paper specifies a knowledge-based graphical model for data flow/control flow diagrams used in the context of a specific modeling method for real-time systems, Concurrent Object-based Real-time Analysis (COBRA). In addition, the paper applies the approach to the design of software for an automated cruise-control system and provides an evaluation of the approach based upon results from four case studies. For the case studies, the knowledge-based graphical model recognized, automatically\u00a0\u2026", "num_citations": "3\n", "authors": ["635"]}
{"title": "A Knowledge-based Approach for Automating a Design Method for Concurrent and Real-Time Systems.\n", "abstract": " This paper describes a knowledge-based approach to automate CODARTS, a software design method for concurrent and real-time systems. The approach uses multiple paradigms to represent knowledge embedded within CODARTS. Semantic data modeling provides the means to model specifications and related designs. A specification meta-model enables automated inferences about the presence of semantic concepts within a specification, while a design meta-model permits automated reasoning concerning concurrent designs. Production rules form the basis for modeling a set of heuristics that can generate concurrent designs based upon semantic concepts from the specification and design meta-models. Together, the semantic data models and production rules, encoded using an expert-system shell, compose CODA, an automated designer\u2019s assistant. CODA is applied to generate ten concurrent designs for four real-time problems.", "num_citations": "3\n", "authors": ["635"]}
{"title": "The calibration and validation of a hybrid simulation/regression model of a batch computer system\n", "abstract": " Calibration and validation are two stages in the development of a performance model of a computer system during which the degree of confidence in the model is established. This paper describes a case study of the calibration and validation of a hybrid simulation/regression Load Adjusting Model of a batch computer system. During calibration, a given workload trace was applied to the Load Adjusting Model and the parameters of the model were adjusted using an iterative tuning procedure. During validation, the parameters of the model, established during calibration, were kept constant and the model was tested using different workload traces.", "num_citations": "3\n", "authors": ["635"]}
{"title": "Variable recovery and adaptation connectors for dynamic software product lines\n", "abstract": " This paper describes the design of variable adaptation and recovery connectors used in the software adaptation of dynamic software product lines. The approach integrates software product line and feature modelling concepts with autonomic properties of self-healing and self-adaptation. The feature model and variable software architecture of the variable connectors are described as well as a validation of the dynamic adaptation approach.", "num_citations": "2\n", "authors": ["635"]}
{"title": "Teaching Software Modeling and Design.\n", "abstract": " This paper describes my experience with teaching courses on software modeling and design to undergraduate and graduate (Masters and PhD) students, in addition to in-depth short courses to industry. The undergraduate course is an introductory software engineering course, which includes lectures on software modeling and design. The Masters course is a detailed course on software modeling and design. The PhD and advanced Masters courses are advanced courses on software modeling and design in the areas of software product line engineering and real-time design. The in-depth industrial courses are courses that cover essentially the same material in overview (1 or 2 day) or more detailed (4 day) formats.", "num_citations": "2\n", "authors": ["635"]}
{"title": "UML-based service robot software development: a case study\n", "abstract": " Robots have been used in several new applications. In recent years, both academic and commercial research has been focusing on the development of a new generation of robots in the emerging field of service robots. Service robots are individually designed to perform tasks in a specific environment for working with or assisting humans and must be able to perform services semi-or fully automatically (Kawamura & Iskarous, 1994; Rofer et al., 2000). Examples of service robots are those used for inspection, maintenance, housekeeping, office automation and aiding senior citizens or physically challenged individuals (Schraft, 1994; Rofer et al., 2000). A number of commercialized service robots have recently been introduced such as vacuum cleaning robots, home security robots, robots for lawn mowing, entertainment robots, and guide robots (Rofer et al., 2000; Kim et al., 2003; You et al., 2003; Pineau et al., 2003; Kim et al., 2005).In this context, Public Service Robot (PSR) systems have been developed for indoor service tasks at Korea Institute of Science and Technology (KIST)(Kim et al., 2003; Kim et al., 2004). The PSR is an intelligent service robot, which has various capabilities such as navigation, manipulation, etc. Up to now, three versions of the PSR systems, that is, PSR-1, PSR-2, and a guide robot Jinny have been built.", "num_citations": "2\n", "authors": ["635"]}
{"title": "Design Methods for Concurrent and Real-time Systems\n", "abstract": " Abstract and real-time systems that use these concepts. It then describes two related design methods for concurrent and real-time systems, ADARTS (Ada-based Design Approach for Real-Time Systems) and CODARTS (Concurrent Design Approach for Real-Time Systems), which build on these earlier methods.\"", "num_citations": "2\n", "authors": ["635"]}
{"title": "A Behavioral Analysis and Modeling Method for Real-Time Systems\n", "abstract": " This paper describes a method for analyzing and modeling real-time systems called Concurrent Object-Based Real-Time Analysis (COBRA). COBRA is an alternative approach to Real-Time Structured Analysis, Object-Oriented Analysis, and Jackson System Development, for analyzing and modeling real-time systems. It blends concepts from all three methods. A COBRA behavioral model can be mapped to an object-oriented design.", "num_citations": "2\n", "authors": ["635"]}
{"title": "Software design of distributed manufacturing control systems\n", "abstract": " How a software design method for distributed real-time applications can be used to design distributed manufacturing control systems which consist of several concurrent tasks executing on multiple modes supported by a local area network is described. The application is a manufacturing control system which controls part manufacturing in a high-volume, low-flexibility assembly plant. The method addresses the needs of distributed real-time manufacturing applications by providing criteria for structuring subsystems into concurrent tasks. The method leads to a design which is primarily message based.<>", "num_citations": "2\n", "authors": ["635"]}
{"title": "Design and Experimentation of an Automated Performance Evaluation Testbed for Self-Healing and Self-Adaptive Distributed Software Systems\n", "abstract": " Evaluating the performance of distributed software systems is very challenging especially in the presence of failures and adaptation. Of particular interest to this paper is self-healing and self-adaptation middleware that detects failures of distributed software systems, analyzes their root causes, devises plans to recover from these failures, and executes these plans. Recovery plans may trigger software architecture adaptations, which may be also initiated by the need to maintain performance and availability goals. This paper focuses on the evaluation and testing of recovery and adaptation frameworks (RAF) for distributed component-based software systems. We present TESS, a testbed for automatically generating distributed software architectures and their corresponding runtime applications, deploying them to the nodes of a cluster, running many different types of experiments involving failures and adaptation, and collecting in a database the values of a variety of failure recovery and adaptation metrics. Queries can then be run against the database to provide a thorough and scientific analysis of the efficiency and/or effectiveness of a RAF. Additionally, this paper presents a case study of the use of TESS for the evaluation of a specific RAF, called DARE, developed by our group.", "num_citations": "1\n", "authors": ["635"]}
{"title": "Modeling Executable Architectural Design Patterns for Software Product Lines.\n", "abstract": " This paper addresses variability in software product line architectures by addressing variability at a higher level of granularity through architectural design patterns. This approach models three levels of executable architectural design patterns to progressively address variability within the SPL and the member applications. The approach is intended for distributed real-time embedded software domains and has been applied to a space flight SPL.", "num_citations": "1\n", "authors": ["635"]}
{"title": "Towards Integrated System and Software Modeling for Embedded Systems\n", "abstract": " This paper addresses the integration of system modeling and software modeling, particularly for embedded systems, which are software intensive systems that consist of both hardware and software components. This paper describes a systems modeling approach to create structural and behavioral models of the total system using SysML. The systematic transition to software modeling using UML is then described.", "num_citations": "1\n", "authors": ["635"]}
{"title": "Static Modeling\n", "abstract": " SWE 621: Software Modeling and Architectural Design Lecture 3 Static Modeling Page 1 A-1 SWE 621: Software Modeling and Architectural Design Lecture 3 Static Modeling Hassan Gomaa Dept of Computer Science Copyright 2011 H. Gomaa George Mason University Fairfax, VA Copyright \u00a9 2011 Hassan Gomaa All rights reserved. No part of this document may be reproduced in any form or by any means, without the prior written permission of the author. This electronic course material may not be distributed by e-mail or posted on any other World Wide Web site without the prior written permission of the author. Steps in Using COMET/UML 1 Develop Software Requirements Model \u2013 Develop Use Case Model (Chapter 6) 2 Develop Software Analysis Model \u2013 Develop static model of problem domain (Chapter 7) \u2013 Structure system into objects (Chapter 8) \u2013 Develop statecharts for state dependent objects (Chapter \u2026", "num_citations": "1\n", "authors": ["635"]}
{"title": "Separating Application and Security Concerns in Modeling Software Product Lines\n", "abstract": " Separating Application and Security Concerns in Modeling Software Product Lines \u2014 Texas Tech University Scholars Skip to main navigation Skip to search Skip to main content Texas Tech University Scholars Logo Home Scholars Organizations Grants Research Scholarly Activities Search by expertise, name or affiliation Separating Application and Security Concerns in Modeling Software Product Lines Eonsuk Shin, Hassan Gomaa Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter \u203a peer-review Overview Fingerprint Original language English Title of host publication Separating Application and Security Concerns in Modeling Software Product Lines Publisher CRC Press State Published - Jan 1 2010 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Shin, E., & Gomaa, H. (2010). Separating Application and Security Concerns in Modeling Software Product \u2026", "num_citations": "1\n", "authors": ["635"]}
{"title": "Separating application and security concerns in modeling software product lines\n", "abstract": " Contents 14.1 Introduction............................................................................................. 338 14.2 Security Services for Application Systems................................................ 340 14.3 Security Requirements Modeling of Software Product Lines................... 341ABSTRACT", "num_citations": "1\n", "authors": ["635"]}
{"title": "Modeling of Evolution to Secure Application System: from Requirements Model to Software Architecture.\n", "abstract": " This paper describes an approach to modeling the evolution of an application system to a secure application system in terms of the software requirements model and software architecture model. The requirements for security services are captured separately from application requirements, and the security services are encapsulated in connectors in the software architecture, separately from the components providing functional services. In this paper, the evolution of requirements and software architecture models to their corresponding security models is described in the center of security requirement conditions. A security requirement condition is maintained consistently from the security requirements model to secure software architecture. In the requirements model and software architecture for a secure system, a security service is fulfilled if a security requirement condition holds. An electronic commerce system is considered to demonstrate the approach.", "num_citations": "1\n", "authors": ["635"]}
{"title": "Software Design Methods for Distributed Applications\n", "abstract": " Consider an application design to provide fault-tolerant commodity trading. At the highest level of abstraction (the requirements description), end users ask the application to buy or sell some commodity at a given price (or better) and in a given quantity (or less). The system replies to each client, indicating the partner with whom the trade is consummated, and the quantity and price involved. It also keeps track of each client\u2019s account.(This is credited on selling and debited on buying. Commissions are deducted at every sale.) The system expresses the requirements abstraction with nondeterminism, because there might be many acceptable ways to match buyers and sellers. A spontaneous, nondeterministic event represents a node crash; this does not alter the state for the requirements abstraction (although, in any implementation, the crash will reinitialize volatile data structures). In developing this application\u00a0\u2026", "num_citations": "1\n", "authors": ["635"]}
{"title": "An exercise in resource allocation\n", "abstract": " In a large operating system, the probability that bottlenecks exist is high. The outcome of modifications to the system attempting to overcome these bottlenecks are often not easy to predict. It is frequently difficult to discover:  (1) Whether an improvement has actually been made to the system.  (2) Where exactly the improvement in system performance, if any, is occurring.  (3) How to adjust parameters of the system to achieve an improved performance.   Performance tools are described in this paper which were used to help resolve these points in the implementation of a Peripheral Processor and Channel Scheduling mechanism in the operating system used at CERN on a CDC 6000 system. The paper shows how analysis of the performance data provided a clearer appreciation of the performance of the scheduling mechanism.", "num_citations": "1\n", "authors": ["635"]}
{"title": "Decentralized Software Architecture Discovery in Distributed Systems\n", "abstract": " Software architecture discovery plays an increasingly important role in the evolution, maintenance, and runtime self-adaptation of modern software systems whose architecture may have become outdated or may not have previously existed. However, current approaches to architecture discovery take a centralized approach, in which the process is carried out from a single location. This proves inadequate in the case of large distributed systems which, due to size, consist of nodes that are disparately located and are highly dynamic in nature. This report presents DeSARM: Decentralized Software Architecture discoveRy Mechanism, a completely decentralized and automated approach for software architecture discovery of distributed systems based on gossiping and message tracing. Through message tracing, the technique is able to identify important architectural characteristics such as components and connectors, in addition to synchronous and asynchronous communication patterns. Furthermore, through its use of gossiping, it exhibits the properties of scalability, global consistency among participating nodes, self-organization, and resiliency to failures. The report discusses DeSARM\u2019s architecture and detailed design and demonstrates its properties through an analysis of small and large-scale experiments.", "num_citations": "1\n", "authors": ["635"]}
{"title": "Methods and Tools for Domain Specific Software Architectures\n", "abstract": " At George Mason University, a project is underway to support software engineering lifecycles, methods, and environments to support software reuse at the requirements and design phases of the software lifecycle, in addition to the coding phase. A reuse-oriented software lifecycle, the Evolutionary Domain Lifecycle 1, 2], has been proposed, which is a highly iterative lifecycle that takes an application domain perspective allowing the development of families of systems. Current emphasis is on the domain analysis and speci cation phase of the EDLC for developing an application domain model, which captures the similarities and variations of the domain.", "num_citations": "1\n", "authors": ["635"]}