{"title": "Specifying distributed software architectures\n", "abstract": " There is a real need for clear and sound design specifications of distributed systems at the architectural level. This is the level of the design which deals with the high-level organisation of computational elements and the interactions between those elements. The paper presents the Darwin notation for specifying this high-level organisation. Darwin is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language supports the specification of both static structures and dynamic structures which may evolve during execution. The central abstractions managed by Darwin are components and services. Services are the means by which components interact.             In addition to its use in specifying the architecture of a distributed system, Darwin has an operational semantics for\u00a0\u2026", "num_citations": "1303\n", "authors": ["1061"]}
{"title": "Coordination in evolving systems\n", "abstract": " To facilitate the writing of large maintainable distributed systems we need to separate out various concerns. We view these concerns as being communication, computation, configuration and coordination. We look at the coordination requirements of long running systems, paying particular attention to enabling the dynamic addition and removal of services. We show that the key to a smooth integration of configuration and coordination into systems is a new style of communication. We show how these ideas can be incorporated into the actor model.", "num_citations": "75\n", "authors": ["1061"]}
{"title": "pi-Calculus semantics for the concurrent configuration language Darwin\n", "abstract": " Darwin is a configuration language for distributed and parallel programs, providing a hierarchical structure of components with dynamic binding. To specify precisely the behavior of Darwin programs, the authors sketch a translation of the features of the language into the pi -calculus, a formalism for modeling concurrent processes. The match between underlying models for Darwin and pi -calculus is good. An example to demonstrate each language is developed. This is followed by a formal semantics of Darwin in the calculus.< >", "num_citations": "42\n", "authors": ["1061"]}
{"title": "MagicBeans: a platform for deploying plugin components\n", "abstract": " Plugins are optional components which can be used to enable the dynamic construction of flexible and complex systems, passing as much of the configuration management effort as possible to the system rather than the user, allowing graceful upgrading of systems over time without stopping and restarting. Using plugins as a mechanism for evolving applications is appealing, but current implementations have limited functionality. In this paper we present a framework that supports the construction and evolution of applications with a plugin architecture.", "num_citations": "41\n", "authors": ["1061"]}
{"title": "A distributed abstract machine for boxed ambient calculi\n", "abstract": " Boxed ambient calculi have been used to model and reason about a wide variety of problems in mobile computing. Recently, several new variants of Boxed Ambients have been proposed, which seek to improve on the original calculus. In spite of these theoretical advances, there has been little research on how such calculi can be correctly implemented in a distributed environment. This paper bridges a gap between theory and implementation by defining a distributed abstract machine for a variant of Boxed Ambients with channels. The abstract machine uses a list semantics, which is close to an implementation language, and a blocking semantics, which leads to an efficient implementation. The machine is proved sound and complete with respect to the underlying calculus. A prototype implementation is also described, together with an application for tracking the location of migrating ambients. The\u00a0\u2026", "num_citations": "41\n", "authors": ["1061"]}
{"title": "JErlang: Erlang with joins\n", "abstract": " Erlang is an industrially successful functional language that uses the Actor model for concurrency. It supports the message-passing paradigm by providing pattern-matching over received messages. Unfortunately coding synchronisation between multiple processes is not straightforward. To overcome this limitation we designed and implemented JErlang, a Join-Calculus inspired extension to Erlang. We provide a rich set of language features with our joins. We present implementation details of our two alternative solutions, a library and an altered VM. Our optimisations provide JErlang with good performance.", "num_citations": "36\n", "authors": ["1061"]}
{"title": "Modelling a framework for plugins\n", "abstract": " Using plugins as a mechanism for extending applications to provide extra functionality is appealing, but current implementations are limited in scope. We have designed a framework to allow the construction of flexible and complex systems from plugin components. In this paper we describe how the use of modelling techniques helped in the exploration of design issues and refine our ideas before implementing them. We present both an informal model and a formal specification produced using Alloy. Alloy\u2019s associated tools allowed us to analyse the plugin system\u2019s behaviour statically.", "num_citations": "36\n", "authors": ["1061"]}
{"title": "Session types in Haskell: Updating message passing for the 21st century\n", "abstract": " Session Types allow plans of conversation between two concurrent processes to be treated as types. Type checking then ensures that communication between processes is safe: i.e. it obeys the protocol specified by the session type. Thus Session Types offer a means to establish conformance to protocols in both distributed applications and multi-threaded programming.    We incorporate Session Types into Haskell as a tool for concurrent programming. Our implementation, which is a standard Haskell library, presents a monadic API to the programmer. Using the library looks and feels very much like normal monadic computation and thus there is a shallow learning curve for the Haskell programmer. Our implementation lifts the invariants and properties of Session Types into Haskells rich type system. This allows our implementation to statically verify the use of the communication primitives provided without an additional type checker, preprocessor or modification to the compiler.    Our implementation supports multiple concurrent communication channels, individual processes can interleave actions across any number of open channels, and channels themselves can be sent and received. New channels can be created between pre-existing processes as well as to newly created processes. Communication is asynchronous and fully polymorphic. To our knowledge, no other implementation of Session Types is available in any language which matches our library in terms of functionality and supported features. We describe the key aspects of our implementation and demonstrate, through a running example, its usage and flexibility.", "num_citations": "35\n", "authors": ["1061"]}
{"title": "Keep off the grass: Locking the right path for atomicity\n", "abstract": " Atomicity provides strong guarantees against errors caused by unanticipated thread interactions, but is difficult for programmers to implement with low-level concurrency primitives. With the introduction of multicore processors, the problems are compounded. Atomic sections are a high level language feature that programmers can use to designate the blocks of code that need to be free from unanticipated thread interactions, letting the language implementation handle the low-level details such as deadlock. From a language designer\u2019s point of view, the challenge is to implement atomic sections without compromising performance.               We propose an implementation of atomic sections that inserts locks transparently into object-oriented programs. The main advantages of our approach are: (1) We infer path expressions (that at run-time resolve to actual objects) for many more accesses in the atomic section\u00a0\u2026", "num_citations": "31\n", "authors": ["1061"]}
{"title": "Safe upgrading without restarting\n", "abstract": " The distributed development and maintenance paradigm for component delivery is fraught with problems. One wants a relationship between developers and clients that is autonomous and anonymous. Yet components written in languages such as C++ require the recompilation of all dependent subsystems when a new version of a component is released. The design of Java's binary format has side-stepped this constraint, removing the need for total recompilation with each change. But the potential is not fulfilled if programs have to be stopped to swap in each new component. This paper describes a framework that allows Java programs to be dynamically upgraded. Its key purpose is to allow libraries that are safe to replace existing libraries without adversely affecting running programs. The framework provides developers with a mechanism to release their libraries and provides clients with the surety of only\u00a0\u2026", "num_citations": "31\n", "authors": ["1061"]}
{"title": "Changing the marks-based culture of learning through peer-assisted tutorials\n", "abstract": " We describe and evaluate an approach to student learning that aims to instil a culture of formative assessment based on peer-assisted learning. The idea is for suitably qualified undergraduates to assist in the running of weekly first-year tutorials. They mark submitted work, provide written and verbal feedback and lead problem-solving discussions during tutorials. However, contrary to normal practice, the marks they award do not contribute to the students\u2019 end-of-year total; all tutorial work becomes essentially voluntary. We report results from a pilot implementation of the scheme over a 12 month period in an engineering department at a leading academic institution. The scheme was such that a comparative and triangulated assessment was possible among the students and tutor team. Results show no discernible degradation in student attendance, submission rates and performance in either the weekly exercises or\u00a0\u2026", "num_citations": "28\n", "authors": ["1061"]}
{"title": "Reasoned Programming\n", "abstract": " Can we ever be sure that our computer programs will work reliably? One approach to this problem is to attempt a mathematical proof of reliability, and this has led to the idea of Formal Methods: if you have a formal, logical speci cation of the properties meant byworking reliably', then perhaps you can give a formal mathematical proof that the program (presented as a formal text) satis es them.Of course, this is by no means trivial. Before we can even get started on a formal proof we must turn the informal ideas intended byworking reliably'into a formal speci cation, and we also need a formal account of what it means to say that a program satis es a speci cation (this amounts to a semantics of the programming language, an account of the meaning of programs). None the less, Formal Methods are now routinely practised by a number of software producers.", "num_citations": "28\n", "authors": ["1061"]}
{"title": "What do you get from a \u03c0-calculus semantics?\n", "abstract": " Darwin is a programming system for the development of distributed and parallel programs. Darwin programs consist of three parts. Firstly, there is a configuration part which provides a hierarchical structure of components with dynamic binding. Secondly, there is the actual communication part which provides the interaction and synchronisation required by the system. Finally, there is the computation part providing the component programs written in C++. The subdivision of concurrent programs into organisation, communication and computation leads to programs that are easy to specify, compile and execute. In order to specify precisely the behaviour of Darwin programs, we translate the organisation and communication into the \u03c0-calculus, a formalism for modelling concurrent processes. The \u03c0-calculus specification enables us to deduce behavioural properties of Darwin programs.", "num_citations": "27\n", "authors": ["1061"]}
{"title": "Component coordination in middleware systems\n", "abstract": " Configuration and coordination are central issues in the design and implementation of middleware systems and are one of the reasons why building such systems is more difficult and complex than constructing stand-alone sequential programs. Through configuration, the structure of the system is established \u2014 which elements it contains, where they are located and how they are interconnected. Coordination is concerned with the interaction of the various components \u2014 when an interaction takes place, which parties are involved, what protocols are followed. Its purpose is to coordinate the behaviour of the various components in a way that meets the overall system specification. The open and adaptive nature of middleware systems makes the task of configuration and coordination particularly challenging. We propose a model that can operate in such an environment and enables the dynamic\u00a0\u2026", "num_citations": "25\n", "authors": ["1061"]}
{"title": "Changing Java Programs\n", "abstract": " The promises of object-orientation and distributed computing could be delivered if the software we needed were written in stone. But it isn't, it changes. The challenge of distributed object-oriented maintenance is to find a means of evolving software, which already has a distributed client base. Working within this scenario, we observe how certain object-oriented language systems seek to support differing client requirements and service obligations. In particular, we examine how the Java Language Specification (JLS) facilitates the concept of binary compatibility, a useful property, but one that may introduce a class of clients who dare not re-compile! Following a suggestion in the new draft JLS, we describe our tool to manage distributed version control and we formulate some proposals for future developments.", "num_citations": "23\n", "authors": ["1061"]}
{"title": "Stage: Python with actors\n", "abstract": " Programmers hoping to exploit multi-core processors must split their applications into threads suitable for independent, concurrent execution. The lock-based concurrency of many existing languages is clumsy and error prone - a barrier to writing fast and correct concurrent code. The Actor model exudes concurrency - each entity in the model (an Actor) executes concurrently. Interaction is restricted to message passing which prevents many of the errors associated with shared mutable state and locking, the common alternative. By favouring message passing over method calling the Actor model makes distribution straightforward. Early Actor-based languages enjoyed only moderate success, probably because they were before their time. More recent Actor languages have enjoyed greater success, the most successful being ERLANG, but the language is functional; a paradigm unfamiliar to many programmers. There\u00a0\u2026", "num_citations": "22\n", "authors": ["1061"]}
{"title": "Finding the needle: stack traces for GHC\n", "abstract": " Even Haskell programs can occasionally go wrong. Programs calling head on an empty list, and incomplete patterns in function definitions can cause program crashes, reporting little more than the precise location where error was ultimately called. Being told that one application of the head function in your program went wrong, without knowing which use of head went wrong can be infuriating. We present our work on adding the ability to get stack traces out of GHC, for example that our crashing head was used during the evaluation of foo, which was called during the evaluation of bar, during the evaluation of main. We provide a transformation that converts GHC Core programs into ones that pass a stack around, and a stack library that ensures bounded heap usage despite the highly recursive nature of Haskell. We call our extension to GHC StackTrace.", "num_citations": "19\n", "authors": ["1061"]}
{"title": "Modelling darwin in the \u03c0-calculus\n", "abstract": " Darwin is a general purpose structuring tool of use in building complex distributed systems from diverse components and diverse component interaction mechanisms. It is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language allows the specification of both static structures and dynamic structures which evolve during execution. The central abstractions managed by Darwin are components and services. Bindings are formed by manipulating references to services.             The paper describes the operational semantics of Darwin in terms of the \u03c0-calculus, Milner's calculus of mobile processes. The correspondence between the treatment of names in the \u03c0-calculus and the management of service references in Darwin leads to an elegant and concise \u03c0-calculus\u00a0\u2026", "num_citations": "19\n", "authors": ["1061"]}
{"title": "Lock inference in the presence of large libraries\n", "abstract": " Atomic sections can be implemented using lock inference. For lock inference to be practically useful, it is crucial that large libraries be analysed. However, libraries are challenging for static analysis, due to their cyclomatic complexity.               Existing approaches either ignore libraries, require library implementers to annotate which locks to take or only consider accesses performed upto one level deep in library call chains. Thus, some library accesses may go unprotected, leading to atomicity violations that atomic sections are supposed to eliminate.               We present a lock inference approach for Java that analyses library methods in full. We achieve this by (i) formulating lock inference as an Interprocedural Distributive Environment dataflow problem, (ii) using a graph representation for summary information and (iii) applying a number of optimisations to our implementation to reduce space-time\u00a0\u2026", "num_citations": "18\n", "authors": ["1061"]}
{"title": "Feeling the way through DLL Hell\n", "abstract": " Dynamic linking provides a way to share code components across applications and across the network. But managing these relationships as new code versions are developed gives rise to a range of problems well recognized by system support personnel. Operating system and language designers attempt to design solutions to these problems into the latest versions of their products and we have applied some tests to se if they have succeeded.", "num_citations": "18\n", "authors": ["1061"]}
{"title": "Managing the evolution of. net programs\n", "abstract": " The component-based model of code execution imposes some requirements on the software components themselves, and at the same time lays some constraints on the modern run-time environment. Software components need to store descriptive metadata, and the run-time system must access this \u2018reflectively\u2019 in order to implement dynamic linking. Software components also undergo dynamic evolution whereby a client component experiences the effects of modifications, made to a service component even though these occurred after the client was built.               We wanted to see whether the dynamic linking mechanism implemented in Microsoft\u2019s .NET environment could be utilized to maintain multiple versions of components. A formal model was developed to assist in understanding the .NET mechanism and in describing our way of dealing with multiple versions. This showed that .NET incorporates all\u00a0\u2026", "num_citations": "16\n", "authors": ["1061"]}
{"title": "Evolution of distributed java programs\n", "abstract": " A major challenge of maintaining object-oriented programs is to find a means of evolving software that already has a distributed client base. This should be easier for Java developers than for most, because dynamic linking has been designed into the runtime system.             It turns out however that things are not so straightforward as they seem, since a given modification can leave a remote client in one of a number of states, not all of which are tolerable, let alone desirable. In this paper we attempt to delineate these states, and to consider ways of avoiding the worst of them. We describe our utility, which offers library developers a transparent version control system, to protect their remote clients.", "num_citations": "16\n", "authors": ["1061"]}
{"title": "Formalising system structure\n", "abstract": " Darwin is a language designed for configuring distributed systems. A system is modelled as a decompositional hierarchy of components with interfaces. Connections are represented as bindings between interfaces. Darwin programs define component types. Configurations of a system are obtained by instantiating these types. Configurations have to comply with a number of constraints on the system structure. It is therefore intuitive to express these constraints in the domain of configurations rather than on the language level. To succeed in this endeavour we need to precisely express the relation between Darwin programs and configurations. We do this in terms of a first order logic theory of Darwin programs and configurations. Models of the theory provide a straightforward mapping from Darwin programs to configurations and vice versa. Most of the constraints on configurations as well as structural transformations\u00a0\u2026", "num_citations": "16\n", "authors": ["1061"]}
{"title": "Painless plugins\n", "abstract": " Using plugins as a mechanism for evolving applications is appealing, but current implementations are limited in scope. Plugins are optional components which can be used to enable the dynamic construction of flexible and complex systems, passing as much of the configuration management effort as possible to the system rather than the user, allowing graceful upgrading of systems over time without stopping and restarting. In this paper we explore the design space of plugin architectures, present a framework that addresses the aforementioned issues, and demonstrate some examples of applications implemented using our plugin architecture.", "num_citations": "15\n", "authors": ["1061"]}
{"title": "Semantics of a higher-order coordination language\n", "abstract": " A distributed program can be viewed as a composition of three parts. Firstly, there is a coordination part which provides a hierarchical structure of components with dynamic binding. Secondly, there is the actual communication part which provides the interaction and synchronisation required by the system. Finally, there is the computation part providing the component programs.             Darwin is a language for describing distributed configurations in terms of component types, their instantiation to components with interfaces and the binding of those interfaces. A Darwin program thus defines a class of configurations. Although the language is very small it contains second-order constructs: component types can appear as parameters in the instantiation of other component types. Furthermore Darwin provides support for dynamic run-time instantiation of components. Component types therefore must have a run\u00a0\u2026", "num_citations": "14\n", "authors": ["1061"]}
{"title": "Verification of policy-based self-managed cell interactions using alloy\n", "abstract": " Self-Managed Cells (SMCs) define an infrastructure for building ubiquitous computing applications. An SMC consists of an autonomous administrative domain based on a policy-driven feedback control-loop. SMCs are able to interact with each other and compose with other SMCs to form larger autonomous components. In this paper we present a formal specification of an SMC's behavior for the analysis and verification of its operation in collaborations of SMCs. These collaborations typically involve SMCs originated from different administrative authorities, and the definition of a formal model has helped us to verify the correctness of their operation when SMCs are composed or federated.", "num_citations": "13\n", "authors": ["1061"]}
{"title": "Higher-order type-level programming in Haskell\n", "abstract": " Type family applications in Haskell must be fully saturated. This means that all type-level functions have to be first-order, leading to code that is both messy and longwinded. In this paper we detail an extension to GHC that removes this restriction. We augment Haskell\u2019s existing type arrow, |->|, with an unmatchable arrow, |\u00a0>|, that supports partial application of type families without compromising soundness. A soundness proof is provided. We show how the techniques described can lead to substantial code-size reduction (circa 80%) in the type-level logic of commonly-used type-level libraries whilst simultaneously improving code quality and readability.", "num_citations": "12\n", "authors": ["1061"]}
{"title": "Lexis exam invigilation system\n", "abstract": " Computers have made their way into the classroom and lecture hall. Overhead projectors, blackboards, and whiteboards are being displaced by smartboards and computer based multimedia presentations. Students with laptops are a common sight and many courses have their lecture notes on the web. Students are studying programming, web-site design, computer graphics, and many other practical disciplines, yet these courses are still being assessed with traditional pen and paper examinations.", "num_citations": "11\n", "authors": ["1061"]}
{"title": "Component adaptation in contemporary execution environments\n", "abstract": " Because they are required to support component deployment and composition, modern execution environments embody a number of common features such as dynamic linking and support for multiple component versions. These features help to overcome some classical maintenance problems focused largely on component evolution, where successive generations of collaborating components need to be kept collaborating. What has been less studied has been component adaptation, whereby a component developed in an environment consisting of one set of service components is required to operate in one or several other environments containing qualitatively different components. In this paper we examine the needs developers and deployers have arising out of component adaptation and explore the concept of Flexible Dynamic Linking as a means of satisfying them. We describe a suite of tools\u00a0\u2026", "num_citations": "10\n", "authors": ["1061"]}
{"title": "Implementing Fickle\n", "abstract": " Tickle is an exciting development in object oriented programming, characterized by the ability of an object to change its class membership at run-time.", "num_citations": "10\n", "authors": ["1061"]}
{"title": "From process algebra to java code\n", "abstract": " The \u03b4\u03c0-calculus, a new calculus based on the \u03c0-calculus, is a model for mobile distributed computation. The \u03b4\u03c0-calculus can be used to specify applications, in order to reason about their security and correctness properties. The \u03b4\u03c0 primitives have been been implemented as a Java API. The implementation in Java provides a means of bridging the gap between application specification and implementation.", "num_citations": "9\n", "authors": ["1061"]}
{"title": "Agent-based configuration management\n", "abstract": " The application of agent technology in the context of distributed systems provides the basis for a new, exible approach to the management of such systems. In this paper we illustrate how agents are used in con guration management. The approach views a distributed system as a collection of distributed agents with a clear separation between various concerns that have to be addressed in distributed systems. The con guration aspect is described by de ning con guration scripts on agents using the language Evolution, thus de ning a con guration management interface. The implementation of the system is based on a high-performance interpreter for an actor-based language. Recon guration is not just con ned to system structure but can also a ect the agent state and hence the behaviour of an agent. Agents can be (re-) de ned at run-time, which enables the dynamic de nition of new agent types and the addition/modi cation of con guration scripts. The construction of complex management structures can be carried out by de ning management agents. The con guration management in our system can be carried out via a simple WWW interface, thus enabling remote support. The architecture enables the provision of advanced tool support for con guration management and its integration with other aspects of system management.", "num_citations": "9\n", "authors": ["1061"]}
{"title": "Tickling Java with a feather\n", "abstract": " Fragments of mainstream programming languages are formalised in order to show desirable properties of their static semantics. We ask if said formalisms could also be used to define a test suite for the mainstream programming language in question, and what the utility of such a suite would be.In this work, we present our findings from testing Java with Featherweight Java (FJ). We take the syntax and binding structure of FJ to define an instance space of non-isomorphic test programs and implementations of FJ type checkers to provide oracles for our tests, to ensure the mainstream implementation conforms with the expectations of FJ. Using these, we evaluate (using code coverage techniques) how much of the Sun OpenJDK javac can be tested by FJ.", "num_citations": "8\n", "authors": ["1061"]}
{"title": "Keeping control of reusable components\n", "abstract": " Development and deployment via components offers the possibility of prolific software reuse. However, to achieve this potential in a component-rich environment, it is necessary to recognize that component deployment (and subsequent composition) is closer to a continual process than a one-off operation. This is due to the requirement that newly-evolved components need to replace their ancestors in a timely and efficient manner at the client deployment sites. Modern runtime systems which employ dynamic link-loading mechanisms can permit such dynamic evolution. We review the capabilities of several alternative runtime environments to establish some requirements for dynamic evolution. Then we describe a tool designed to support developers and administrators in the migration of component updates within the Microsoft .NET framework.", "num_citations": "8\n", "authors": ["1061"]}
{"title": "Coordinating components in middleware systems\n", "abstract": " Configuration and coordination are central issues in the design and implementation of middleware systems and are one of the reasons why building such systems is more complex than constructing stand\u2010alone sequential programs. Through configuration, the structure of the system is established\u2014which elements it contains, where they are located and how they are interconnected. Coordination is concerned with the interaction of the various components\u2014when an interaction takes place, which parties are involved, what protocols are followed. Its purpose is to coordinate the behaviour of the various components to meet the overall system specification. The open and adaptive nature of middleware systems makes the task of configuration and coordination particularly challenging. We propose a model that can operate in such an environment and enables the dynamic integration and coordination of components by\u00a0\u2026", "num_citations": "8\n", "authors": ["1061"]}
{"title": "System structuring: a convergence of theory and practice?\n", "abstract": " Darwin is a general purpose structuring tool of use in building complex distributed systems from diverse components and diverse component interaction mechanisms. It is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language allows the specification of both static structures and dynamic structures which evolve during execution. The central abstractions managed by Darwin are components and services. Bindings are formed by manipulating references to services.     The paper describes the operational semantics of Darwin in terms of the pi-calculus, Milner\u00c6s calculus of mobile processes. The correspondence between the treatment of names in the pi-calculus and the management of service references in Darwin leads to an elegant and concise pi-calculus model of Darwin\u00c6s operational semantics. The model has proved useful in arguing the correctness of Darwin implementations and in designing  extensions to Darwin and reasoning about their behaviour. The paper discusses the reasons why other formalisms fail to capture elegantly the system structuring concepts on which Darwin is based.", "num_citations": "8\n", "authors": ["1061"]}
{"title": "Program design with Modula-2\n", "abstract": " The material in this book is based on an initial programming course taught, for the past five years, to Computing and Software Engineering undergraduates in the Department of Computing, Imperial College, London. Lecturers delivering subsequent courses in the department rely to a greater or lesser extent on a course such as this to supply a foundation or a context for ensuing studies. For this purpose the traditional initial programming course can be deficient in at least two areas. Firstly, where a course concentrates largely on syntax details to the detriment of design issues, it can be difficult for students to perceive the parallels between their own coding efforts (and the methods they employ) and the implementation phase of a large-scale software project, as considered in subsequent software engineering courses. The closest a good initial programming course gets to this is through inculcating the ideas of top-down design which does not \u2018scale up'to large projects very effectively. Secondly, unless it is very carefully considered in advance, the pro-gramming style which most naturally suggests itself in an initial programming course can actually work against the student in subsequent courses which deal with techniques for \u2018reasoning about code\u2019. For instance, it is common practice to teach students to use temporary data stores for holding intermediate results. Yet, for reasoning about code, the introduction of large numbers of local variables clutters up the reasoning process. So their programming habits can become a disadvantage.It was specifically to deal with these requirements in the context of an initial programming course that the course at\u00a0\u2026", "num_citations": "8\n", "authors": ["1061"]}
{"title": "Implementing Stage: the Actor based language\n", "abstract": " Intel\u2019s 80 core processor represents the state of the art in processor technology and to take advantage of these additional cores programmers will have to write concurrent code. Writing massively concurrent code in existing languages to achieve even modest concurrency is difficult. And then we have the challenge of getting the most out of commodity clusters of networked computers.Programmers hoping to exploit these trends using existing mainstream languages and paradigms often fail because these languages do not fuse well with concurrency and distribution. The lock-based concurrency of many existing languages including JAVA and PYTHON is clumsy and error prone and many languages sorely lack high level distribution semantics. The Actor model of Hewitt, Bishop and Steiger is a model which fits more naturally with concurrency and distribution. The model exudes concurrency and by prohibiting shared\u00a0\u2026", "num_citations": "7\n", "authors": ["1061"]}
{"title": "Ephemeral Java Source Code\n", "abstract": " In an object oriented, distributed environment, program maintenance, which has never been the most predictable task, becomes even more uncertain. Java's dynamic loading mechanism was developed to tackle some of the uncertainties. In doing so, it shifts the focus from the state of the sources to that of the binaries. This paper discusses some of the implications of that move.", "num_citations": "7\n", "authors": ["1061"]}
{"title": "Formal underpinnings of Java\n", "abstract": " Publication: OOPSLA'98 Addendum: Addendum to the 1998 proceedings of the conference on Object-oriented programming, systems, languages, and applications (Addendum) January 1998 Pages 0.35\u2013A35 https://doi. org/10.1145/346852.346968", "num_citations": "7\n", "authors": ["1061"]}
{"title": "Why functional programming?\n", "abstract": " To say that no one uses functional languages is an exaggeration. Phone calls in the European Parliament are routed by programs written in Ericsson\u2019s functional language Erlang. Virtual CDs are distributed on Cornell\u2019s network via the Ensemble system written in INRIA\u2019s CAML, and real CDs are shipped by Polygram in Europe using Software AG\u2019s Natural Expert. Functional languages are the language of choice for writing theorem provers, including the HOL system which helped debug the design of the HP 9000 line of multiprocessors. These applications and others are described in a previous column [1].", "num_citations": "7\n", "authors": ["1061"]}
{"title": "Data-flow design as a visual programming language\n", "abstract": " Data-flow design techniques and the functional programming style both decompose problems in a data-driven fashion. We propose a method based on data-flow diagrams which yields designs which can be mechanically translated into code written in a functional programming language. Users who specify or design systems with data-flow techniques can effectively execute their specifications or designs with a minimum of additional &sign decisions and without recourse to a programming language. Data-flow diagram elements behave as programming constructs in a \u201cvisual pmgramming\u201d language. The paper solves a single problem to illustrate the methodology and show the kind of code produced.1. A Functional Design Methodology The potential which a functional programming language has for producing programs capable of running on parallel hardware is beginning to be exploited by hardware designers\u00a0\u2026", "num_citations": "6\n", "authors": ["1061"]}
{"title": "High coverage testing of Haskell programs\n", "abstract": " This paper presents a new lightweight technique for automatically generating high coverage test suites for Haskell library code. Our approach combines four main features to increase test coverage:(1) automatically inferring the constructors and functions needed to generate test data;(2) using needed narrowing to take advantage of Haskell's lazy evaluation semantics;(3) inspecting elements inside returned data structures through the use of case statements, and (4) efficiently handling polymorphism by lazily instantiating all possible instances.", "num_citations": "5\n", "authors": ["1061"]}
{"title": "Extending the S-Net Type System\n", "abstract": " In this paper we discuss the results of evaluating the S-Net type system. We found some problems that would lead to inefficient S-Net compiler implementation, or even incorrect implementations of S-Net programs. We solved the problems by extending the type system so that it can capture more properties that S-Net was designed with.", "num_citations": "5\n", "authors": ["1061"]}
{"title": "A flexible model for dynamic linking in Java and C\n", "abstract": " Dynamic linking supports flexible code deployment, allowing partially linked code to link further code on the fly, as needed. Thus, end-users enjoy the advantage of automatically receiving any updates, without any need for any explicit actions on their side, such as re-compilation, or re-linking. On the down side, two executions of a program may link in different versions of code, which in some cases causes subtle errors, and may mystify end-users. Dynamic linking in Java and C# are similar: the same linking phases are involved, soundness is based on similar ideas, and executions which do not throw linking errors give the same result. They are, however, not identical: the linking phases are combined differently, and take place in different order. Consequently, linking errors may be detected at different times by Java and C# runtime systems. We develop a non-deterministic model, which describes the behaviour of\u00a0\u2026", "num_citations": "5\n", "authors": ["1061"]}
{"title": "Flexible, source level dynamic linking and re-linking\n", "abstract": " We give a formal semantics for dynamic linking and re-linking of code. The semantics is at source language level, and allows linking at a finer grain than current Java or C# implementations: Besides supporting the loading and verification of classes interleaved with program execution, it also allows type-safe removal and replacement of classes, fields and methods. Such extended features support unanticipated software evolution. 1", "num_citations": "5\n", "authors": ["1061"]}
{"title": "Flint for safer smart contracts\n", "abstract": " The Ethereum blockchain platform supports the execution of decentralised applications or smart contracts. These typically hold and transfer digital currency to other parties on the platform; however, they have been subject to numerous attacks due to the unintentional introduction of bugs. Over a billion dollars worth of currency has been stolen since its release in July 2015. As smart contracts cannot be updated after deployment, it is imperative that the programming language supports the development of robust contracts. We propose Flint, a new statically-typed programming language specifically designed for writing robust smart contracts. Flint's features enforce the writing of safe and predictable code. To encourage good practices, we introduce protection blocks. Protection blocks restrict who can run code and when (using typestate) it can be executed. To prevent vulnerabilities relating to the unintentional loss of currency, Flint Asset traits provide safe atomic operations, ensuring the state of contracts is always consistent. Writes to state are restricted, simplifying reasoning about smart contracts.", "num_citations": "4\n", "authors": ["1061"]}
{"title": "Aether: Self-adaptive networked entities: Autonomous computing elements for future pervasive applications and technologies\n", "abstract": " The \u00c6THER project has laid the foundation of a complete new framework for designing and programming computing resources that live in changing environments and need to re-configure their objectives in a dynamic way. This chapter contributes to a strategic research agenda in the field of self-adaptive computing systems. It brings inputs to the reconfigurable hardware community and proposes directions to go for reconfigurable hardware and research on self-adaptive computing; it tries to identify some of the most promising future technologies for reconfiguration, while pointing out the main foreseen Challenges for reconfigurable hardware. This chapter presents the main solutions the \u00c6THER project proposed for some of the major concerns in trying to engineer a self-adaptive computing system. The text exposes the \u00c6THER vision of self-adaptation and its requirements. It describes and discusses the\u00a0\u2026", "num_citations": "4\n", "authors": ["1061"]}
{"title": "Using objects for structuring multiparadigm programming environments\n", "abstract": " Multiparadigm programming allows the programmer to write the implementation of a system in a number of different paradigms. We describe our approach to multiparadigm programming based on modeling programming paradigms as object classes. In particular, objects can be used to encapsulate program modules, and classes to encapsulate their respective paradigms. The paradigm class hierarchy can then be used to abstract common paradigm characteristics and the call-gate, a local inter-operation abstraction can be used to flatten the class hierarchy into a collection of paradigms. We use this object-oriented structuring mechanism to provide the base for designing multiparadigm environment generators. In order to demonstrate our approach we develop MPSS, a multiparadigm environment generator, use it to implement blueprint, a six paradigm programming environment, and use all its paradigms in a numerical and symbolic integration package.", "num_citations": "4\n", "authors": ["1061"]}
{"title": "Safely abstracting memory layouts\n", "abstract": " Modern architectures require applications to make effective use of caches to achieve high performance and hide memory latency. This in turn requires careful consideration of placement of data in memory to exploit spatial locality, leverage hardware prefetching and conserve memory bandwidth. In unmanaged languages like C++, memory optimisations are common, but at the cost of losing object abstraction and memory safety. In managed languages like Java and C#, the abstract view of memory and proliferation of moving compacting garbage collection does not provide enough control over placement and layout. We have proposed SHAPES, a type-driven abstract placement specification that can be integrated with object-oriented languages to enable memory optimisations. SHAPES preserves both memory and object abstraction. In this paper, we formally specify the SHAPES semantics and describe its memory safety model.", "num_citations": "3\n", "authors": ["1061"]}
{"title": "Extending SHAPES for SIMD Architectures: An approach to native support for Struct of Arrays in languages\n", "abstract": " SIMD (Single Instruction, Multiple Data) instruction sets are ubiquitous on modern hardware, but rarely used in software projects. A major reason for this is that efficient SIMD code requires data to be laid out in memory in an unconventional manner, forcing developers to explicitly refactor their code and data structures in order to make use of SIMD.", "num_citations": "3\n", "authors": ["1061"]}
{"title": "Reuse and Abuse.\n", "abstract": " The designers of modern programming languages and runtime systems have devoted considerable efforts to ensuring that today\u2019s software systems can, in some circumstances, be updated incrementally through the mechanism of dynamic linking. We examine those circumstances and the situations where they do not apply. We describe tools designed to support dynamic evolution on behalf of component developers, and to help their clients to benefit from it.", "num_citations": "3\n", "authors": ["1061"]}
{"title": "Pluggable, Iterative Type Checking for Dynamic Programming Languages\n", "abstract": " Dynamically typed programming languages are great. They can be highly expressive, incredibly flexible, and very powerful. They free a programmer of the chains of needing to explicitly say what classes are allowed in any particular point in the program. They delay dealing with errors until the last possible moment at runtime. They trust the programmer to get the code right.Unfortunately, programmers are not to be trusted to get the code right! So to combat this, programmers started writing tests to exercise their code. The particularly conscientious ones started writing the tests before the code existed. The problem is, tests are still code, and tests would still only point out errors at runtime.", "num_citations": "3\n", "authors": ["1061"]}
{"title": "Towards a minimal object-oriented language for distributed and concurrent programming\n", "abstract": " The aim of the project was to develop and implement a concurrent object-oriented language for distributed programming. Based on an analysis of the state of the art in the design of objectoriented systems and an abstract but very simple and compact de nition of the object-oriented paradigm, we rst develop a model for objects that is simple and incorporates only essential features. It is shown how inter-object and intra-object concurrency arise naturally from this model. Taking a look at the problems which arise when implementing a concurrent and distributed objectoriented system, this model is then re ned and modi ed. A formal speci cation of the nal model-the basis for the implementation of a system-is presented. The second part of the project was devoted to the design of a language and the precise de nition of its syntax and semantics. The language has only a few constructs. This minimalistic approach makes it easier to reason about it. High-level object-oriented features are not included as primitives but it is shown how these can be modelled using the existing constructs. As concurrency issues were expected to play an central role it was important to de ne the semantics in a way that enables reasoning about these issues. It was decided to use Milner's-calculus for that purpose. This calculus is well-de ned and provides a convenient way of modelling concurrency. As the intention was to design a minimal language it seemed appropriate to describe its semantics in terms of a calculus which itself only has a minimal set of constructs. However, it was found that the calculus lacked the expressiveness needed to de ne the semantics of the language\u00a0\u2026", "num_citations": "3\n", "authors": ["1061"]}
{"title": "An object model for multiparadigm programming\n", "abstract": " We became interested in multi-language object models while researching problems related to multiparadigm programming [SDE94a, SDE94b]. It is widely accepted that different types of tasks can be best implemented in different paradigms. As an example the logic programming paradigm is particularly well suited for implementing expert systems, while many operations on lists can be elegantly described in the functional programming paradigm. Multiparadigm programming can allow each part of a system to be implemented in the most suitable paradigm. Some of the problems in achieving this ideal are: accommodation of different syntactic notations, accommodation of diverse execution models, support for different implementation strategies, ability to use existing tools, and arbitrary paradigm mixing and matching.Some of these problems can be overcome by designing around an object-based multiparadigm programming environment. In an object based multiparadigm programming environment every paradigm forms a class, and every module written in that paradigm is an object member of that paradigm's class. Paradigms form the class hierarchy with the target machine architecture being the root of it. Inheritance is used to bridge the semantic gaps between different paradigms. In the following paragraphs we will present these aspects in greater detail and discuss a possible design abstraction for multi-language module inter-operation.", "num_citations": "3\n", "authors": ["1061"]}
{"title": "Haskell-Like S-Expression-Based Language Designed for an IDE\n", "abstract": " The state of the programmers\u2019 toolbox is abysmal. Although substantial effort is put into the development of powerful integrated development environments (IDEs), their features often lack capabilities desired by programmers and target primarily classical object oriented languages. This report documents the results of designing a modern programming language with its IDE in mind. We introduce a new statically typed functional language with strong metaprogramming capabilities, targeting JavaScript, the most popular runtime of today; and its accompanying browser-based IDE. We demonstrate the advantages resulting from designing both the language and its IDE at the same time and evaluate the resulting environment by employing it to solve a variety of nontrivial programming tasks. Our results demonstrate that programmers can greatly benefit from the combined application of modern approaches to programming tools.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "PASCAL for Programmers\n", "abstract": " The material for this book first appeared in the magazine Personal Computer World, as a series of articles which ran from September 1979 to June 1980. It was designed to appeal to a new (in 1979) sort of reader the microcomputer enthusiast, both amateur and professional about whom two assumptions were made. The first was that the reader was someone who had already learned to program (probably in BASIC) and who wanted to create programs in as systematic and proficient a fashion as possible. The second was that the reader would not be adverse to an occasional glimpse of how the underlying machine played its part in executing these programs. As a result of these, no attempt was made to teach the\" problem-solving\" aspects of programming (although the Top-Down philosophy for program design formed a key feature) and no apology was made for the repeated references to the way in which a Pascal compiler\" viewed\" some particular code fragment. In preparing this material for publication as a single volume, there has been little deviation from this policy. Nevertheless, it should be remarked that the first five chapters contain all the material one would need to cover in an initial course in programming (up to the level of most BASIC's) while the second half of the book tackles some of the more sophisticated techniques available to the Pascal programmer.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "Fairness for Chorded Languages\n", "abstract": " Joins or chords is a concurrency construct that seems to fit well with the object oriented paradigm. Chorded languages are presented with implicit assumptions regarding the fair treatment of processes by the scheduler. We define weak and strong fairness for the Small Chorded Object-Oriented Language (                   l                 SCHOOL) which allows the classification of executions as fair. We investigate the liveness behaviour of programs and establish worst-case behaviours in terms of scheduling delays.               We discover that weak fairness, although giving the scheduler implementer greater freedom in selecting the next process which is to be executed, is harder to implement than strong fairness; strong fairness benefits from a straightforward implementation, however, imposes many more constraints and limits the selection function of a scheduler.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "Safely Speaking in Tongues: Statically Checking Domain Specific Languages in Haskell\n", "abstract": " Haskell makes it very easy to build and use Domain Specific Languages (DSLs). However, it is frequently the case that a DSL has invariants that can not be easily enforced statically, resulting in runtime checks. This is a great pity given Haskell\u00c6s rich and powerful type system and leads to all the usual problems of dynamic checking.     We believe that Domain Specific Languages are becoming more popular: the internet itself is a good example of many DSLs (HTML, CSS, JavaScript, Flash, etc), and more seem to be being added every day; most graphics cards already accept programs written in the DSL OpenGL Shading Language (GLSL); and the predicted growth of heterogeneous CPUs (for example IBM\u00c6s Cell CPU) will demand many different DSLs for the various programming models and instruction sets that become available.     We present a technique that allows invariants of any given DSL to be lifted into the Haskell type system. This removes the need for runtime checks of the DSL and prevents programs that violate the invariants of the DSL from ever being compiled or executed. As a result we avoid the pitfalls of dynamic checking and return the user of the DSL to the safety and tranquillity of the strongly statically typed Haskell world.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "Clase: cursor library for a structured editor\n", "abstract": " The zipper is a well known design pattern for providing a cursor-like interface to a data structure. However, the classic treatise by Huet (1) only scratches the surface of some of the potential applications of the zipper. In this work we have taken inspiration from Huet, and built a library suitable as an underpinning for a structured editor for programming languages. We consider a zipper structure that is suitable for traversing heterogeneous data types, encoding routes to other places in the tree (for bookmark or quick-jump functionality), expressing lexically bound information using contexts, and traversals for rendering a program indicating where the cursor is currently focused in the whole.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "Session Types in Haskell\n", "abstract": " Session Types allow plans of conversation between two concurrent processes to be treated as types. Type checking then ensures that communication between processes is safe: ie it obeys the protocol specified by the session type. Thus Session Types offer a means to establish conformance to protocols in both distributed applications and multi-threaded programming. We incorporate Session Types into Haskell as a tool for concurrent programming. Our implementation, which is a standard Haskell library, presents a monadic API to the programmer. Using the library looks and feels very much like normal monadic computation and thus there is a shallow learning curve for the Haskell programmer. Our implementation lifts the invariants and properties of Session Types into Haskell\u2019s rich type system. This allows our implementation to statically verify the use of the communication primitives provided without an additional type checker, preprocessor or modification to the compiler. Our implementation supports multiple concurrent communication channels, individual processes can interleave actions across any number of open channels, and channels themselves can be sent and received. New channels can be created between pre-existing processes as well as to newly created processes. Communication is asynchronous and fully polymorphic. To our knowledge, no other implementation of Session Types is available in any language which matches our library in terms of functionality and supported features. We describe the key aspects of our implementation and demonstrate, through a running example, its usage and flexibility.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "Flexible Dynamic Linking for .NET\n", "abstract": " A modern object-oriented application is a set of components developed or reused by programmers, and tested together for correctness and performance. Each component\u2019s dependencies on other components are type-checked at compile-time and embedded into the executable image, from where they guide the dynamic linking process. We propose that an application can potentially consist of multiple sets of components, all known to the application\u2019s programmers. Each set implements the application\u2019s functionality in some special way, eg using only patent-free algorithms or being optimised for 64-bit processors. Depending on the components available on a user\u2019s machine, the dynamic linking process will select a suitable set and load components from it. We describe our approach for writing programs that use a \u201cdefault\u201d set of components and carry nominal and structural specifications about permissible sets of alternative components. We modified the linking infrastructure of Rotor, a .NET VM, to efficiently and safely find components on the user\u2019s machine that satisfy the programmer\u2019s specifications. Specifications can be applied to individual classes and methods, so only code that might want to use alternative code needs to undergo the modified linking process.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "Component Deployment: Third International Working Conference, CD 2005, Grenoble, France, November 28-29, 2005, Proceedings\n", "abstract": " This volume of Lecture Notes in Computer Science contains the proceedings of the rd 3 Working Conference on Component Deployment (CD 2005), which took place from 28 to 29, November 2005 in Grenoble, France, and co-located with Middleware 2005. CD 2005 is the third international conference in the series, the first two being held in Berlin and Edinburgh in 2002 and 2004, respectively. The proceedings of both these conferences were also published by Springer in the Lecture Notes in Computer Science series and may be found in volumes 2370 and 3083. Component deployment addresses the tasks that need to be performed after components have been developed and addresses questions such as:\u2022 What do we do with components after they have been built?\u2022 How do we deploy them into their execution environment?\u2022 How can we evolve them once they have been deployed? CD 2005 brought together researchers and practitioners with the goal of deve-ping a better understanding of how deployment takes place in the wider context. The Program Committee selected 15 papers (12 long papers, three short papers) out of 29 submissions. All submissions were reviewed by at least three members of the Program Committee. Papers were selected based on originality, quality, soundness and relevance to the workshop.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "A concurrency model of chorded languages\n", "abstract": " Chords are a concurrency mechanism of object-oriented language inspired by the join of the Join-calculus. We present a formal model of chorded languages, namely the Small Chorded Object-Oriented Language (SCHOOL), a minimal language which aims to capture the essence of the concurrent behaviours of chords. Furthermore we study the interaction of chords with fields, a standard feature of many object-oriented language. We achieve this by extending SCHOOL to include fields, resulting in fd SCHOOL. Fields are orthogonal to chords in terms of concurrent behaviours, and also can be encoded using only chords; hence fields are a macro-expansion of chords. We show this by means of an encoding between the two languages.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "A demonstration of data inconsistency in the Java memory model\n", "abstract": " Threads in Java are not constrained to produce sensible run-time behaviour. It is possible (accidentally) to write programs with very undesirable properties. Previously we have formalized Java's multi-threaded behaviour. From our formalization, we have developed a set of applets to demonstrate the characteristics and effects of unsafe behaviours regarding the usage of shared variables, as well as the additional effects of synchronization and volatile declarations. Using synchronization prevents this level of unsafe properties, but using volatile declarations does not help prevents these unsafe properties.", "num_citations": "2\n", "authors": ["1061"]}
{"title": "The Environment as an Argument\n", "abstract": " Context-awareness as defined in the setting of Ubiquitous Computing [3] is all about expressing the dependency of a specific computation upon some implicit piece of information. The manipulation and expression of such dependencies may thus be neatly encapsulated in a language where computations are first-class values. Perhaps surprisingly however, context-aware programming has not been explored in a functional setting, where first-class computations and higher-order functions are commonplace. In this paper we present an embedded domain-specific language (EDSL) for constructing context-aware applications in the functional programming language Haskell.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Automatic unit test generation for JavaScript\n", "abstract": " The old adage \u201cto err is human\u201d is more than manifest in the software world: programmers make mistakes. As a result, it is estimated that 50% of software development time is spent on software testing alone. This has prompted many attempts in the past decades to fully automate testing, through tools that generate tests autonomously. In addition to saving time, automatic test generation enables more systematic and unbiased testing, increasing the robustness and quality of programs.Dynamic languages have recently risen in popularity, as their flexibility suits today\u2019s fast-moving software industry. The growth of web applications has led to an increase in the use of JavaScript in particular. Formerly cast as a browser scripting language, JavaScript is becoming a more versatile programming language used for application development as well. This motivates research in automatic test generation for JavaScript, yet the existing work in that domain [19, 2, 38, 5] lacks autonomy and support for the class-based programming style which is becoming the norm in JavaScript development. In this report, we present Flycatcher, an automatic unit test generation tool written for and in JavaScript. We contribute to the field of automatic test generation by proposing a tool that is capable of successfully generating tests for a comprehensive subset of the JavaScript language. On top of providing the tester with a suite of unit tests, Flycatcher reports the errors found during the test generation process. Experimental evaluation shows that Flycatcher is capable of consistently achieving high code coverage with a selection of benchmark programs.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Strengthening the zipper\n", "abstract": " The zipper is a well known design pattern for providing a cursor-like interface to a data structure. However, the classic treatise by Huet only scratches the surface of some of its potential applications. In this paper we take inspiration from Huet, and describe a library suitable as an underpinning for structured editors. We consider a zipper structure that is suitable for traversing heterogeneous data types, encoding routes to other places in the tree (for bookmark or quick-jump functionality), expressing lexically bound information using contexts, and traversals for rendering a program indicating where the cursor is currently focused.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "A Featherweight Model for Chorded Languages\n", "abstract": " Chords are a concurrency mechanism of object-oriented languages inspired by the join of the Join-Calculus. We present SCHOOL, the Small Chorded Object-Oriented Language, a featherweight model which aims to capture the essence of the concurrent behaviours of chords. Our model serves as a generalisation of chorded behaviours found in existing experimental languages such as Polyphonic C\u266f. Furthermore, we study the interaction of chords with fields by extending SCHOOL to include fields, resulting in f SCHOOL. Fields are orthogonal to chords in terms of concurrent behaviours. We show that adding fields to SCHOOL does not change its expressiveness by means of an encoding between the two languages.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Safely Speaking in Tongues\n", "abstract": " Haskell makes it very easy to build and use Domain Specific Languages (DSLs). However, it is frequently the case that a DSL has invariants that can not be easily enforced statically, resulting in runtime checks. This is a great pity given Haskell\u2019s rich and powerful type system and leads to all the usual problems of dynamic checking.We believe that Domain Specific Languages are becoming more popular: the internet itself is a good example of many DSLs (HTML, CSS, JavaScript, Flash, etc), and more seem to be being added every day; most graphics cards already accept programs written in the DSL OpenGL Shading Language (GLSL); and the predicted growth of heterogeneous CPUs (for example IBM\u2019s Cell CPU) will demand many different DSLs for the various programming models and instruction sets that become available.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Exploiting Online Games\n", "abstract": " This talk (based on a book of the same title co-authored by Greg Hoglund) frankly describes controversial security issues surrounding MMORPGs such as World of Warcraft. This no-holds-barred approach is fully loaded with code examples, debuggers, bots, and hacks, of interest whether you are a gamer, a game developer, a software security person, or an interested bystander. I will cover:", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Extensible optimisation framework for .NET virtual machine\n", "abstract": " Component-based programming is a new programming paradigm where independent pieces of code are combined together to form the application program. Most performance improvement opportunities come from adapting components to their context of use, but these improvements tend to reduce re-usability, clarity and long-term software value. The purpose of this work is to change this, so that developers can write programs that follow component-based programming logic, and a program would be automatically and transparently transformed into one that is comparable, or better, in performance to an equivalent application. This work introduce a domain-specific optimisation component that encodes knowledge specific to a particular application domain. The component has the access to the results of static data-flow analysis that is sharpen by control-flow information obtained at run-time. These results are used\u00a0\u2026", "num_citations": "1\n", "authors": ["1061"]}
{"title": "A new linking strategy for. net\n", "abstract": " Dynamic linking in modern execution environments like .NET is considerably more sophisticated than in the days of C shared libraries on UNIX. One aspect of this sophistication is that .NET assemblies embed type information about dynamically linked resources.This type information implicitly represents compile-time assumptions about the resources available at run-time. However, at run-time, different resources may actually be available. For example, the execution environment on a mobile phone might provide fewer, simpler classes than on a desktop PC. We have designed and implemented a \u201cflexible\u201d dynamic linking scheme that supports the run-time selection of .NET assemblies and classes. This enables a regime of \u201ccompile once, run anywhere\u201d. We describe the scheme\u2019s integration with the .NET linking infrastructure, review important design decisions and report on experiences with the \u201cRotor\u201d shared\u00a0\u2026", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Observing the Dynamic Linking Process in Java\n", "abstract": " Java supports a novel paradigm for code deployment: Instead of linking the complete program into code before execution, the classes and interfaces making up the program are loaded and linked on demand during execution. Classes are verified before the creation of objects. Verification checks subtypes, and may require loading of further classes or interfaces.This is a more complex runtime model than usually found in programming languages, but it has the advantage of faster strart-ip (as there is less code to load initially), of linking at runtime to the most up-to-date version of any utility, and of lazier error detection (exceptions only need to be thrown if there is an attempt to execute unsafe code). These advantages are obtained without compromising type safety. Usually, the Java linking process takes place implicitly, and, as long as it\" goes well\", it does not manifest itself, and does not affect program evaluation\u00a0\u2026", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Can Corba save a fringe language from becoming obsolete?\n", "abstract": " Not only does CORBA offer the advantage of distribution transparency for building applications, but it may provide esoteric programming languages with greater capabilities through its interoperability standard. Implementing interoperability with the CORBA/IIOP gives rise to several problems of compatibility between the CORBA computational model and those of the languages or sub-systems for which an IIOP bridge implementation is built. This paper describes how an actor-based language, Rosette, has been extended to provide support for distributed environments by extending the language with support for the CORBA/IIOP. The prototype IIOP interface has been implemented as a half-bridge. The Rosette types, object model and concurrency are very different from those generally available in conventional languages and CORBA. We discuss the issues relating to type compatibility, run-time type\u00a0\u2026", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Thread and Main Memory Semantics\n", "abstract": " Thread and Main Memory Semantics | Proceedings of the Workshop on Object-Oriented Technology ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsProceedings of the Workshop on Object-Oriented TechnologyThread and Main Memory Semantics Article Thread and Main Memory Semantics Share on Authors: Vishnu Kotrajaras View Profile , Susan Eisenbach View Profile Authors Info & Affiliations Proceedings of the Workshop on Object-Oriented TechnologyJune 1999 Published:14 June 1999 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New \u2026", "num_citations": "1\n", "authors": ["1061"]}
{"title": "What can Java binary compatibility mean\n", "abstract": " Java binary compatibility prescribes conditions under which modification and re-compilation of classes does not necessitate re-compilation of further classes importing the modified classes. Binary compatibility is a novel concept for language design. We argue that the description of the term binary compatibility in the Java language specification allows for many possible interpretations. We discuss the various interpretations and their ramifications, and suggest one interpretation, which is best in our view.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Functional progaming on parallel architectures\n", "abstract": " Publisher SummaryThis chapter elaborates the functional programming on parallel architectures. Executable specification languages are very high-level languages, and executable specifications display all the characteristics of high-level language programs. They offer greatly reduced source-code length. It is found that if a PASCAL program offers an order-of-magnitude reduction in length over an equivalent assembler program, a typical executable specification probably offers a further order-of-magnitude reduction. One effect of this is a marked improvement in programmer efficiency, since individual programmers are thought to deliver roughly the same number of lines of code per unit time regardless of the language they use. On the negative side, high-level language programs make notoriously less efficient use of the underlying hardware than equivalent machine-code programs, and this is correspondingly truer\u00a0\u2026", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Parallel architecture for functional programming\n", "abstract": " Modern software development seeks to produce faster, more reliable programs. Greater speed comes from putting more mips into the machine while one approach to improving reliability lies in trying to introduce greater rigour into the design process. Using a conventional architecture and with a traditional programming language these two goals are in conflict as the extra power is soaked up by the more elaborate code. Happily the conflict can be resolved by recourse to a functional language which allows for parallel execution through the mechanism of graph reduction. This paper introduces a representative functional programming language, Hope, and explores the ALICE architecture which executes Hope programs in parallel.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Errors for the Common Man: Hiding the unintelligable in Haskell\n", "abstract": " If a library designer takes full advantage of Haskell\u00c6s rich type system and type-level programming capabilities, then the resulting library will frequently inflict huge and unhelpful error messages on the library user. These error messages are typically in terms of the library and do not refer to the call-site of the library by the library user, nor provide any guidance to the user as to how to fix the error.     The increasing appetite for programmable type-level computation makes this a critical issue, as the advantages and capabilities of type-level computation are nullified if useful error messages cannot be returned to the user.     We present a novel technique that neatly side-steps the default error messages and allows the library programmer to control the generation of error messages that are statically returned to the user. Thus with this technique, there is no longer any drawback to using the full power of Haskell\u00c6s type system.", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Fast multi-level locks for java\n", "abstract": " Atomic sections guarantee atomic and isolated execution of a block of code. Transactional Memory can be used to implement them but suffers from the inability to support system calls and has high overhead. Lock inference is a pessimistic alternative that infers the locks necessary to prevent thread interference. Our research looks at lock inference techniques for Java programs. An important aspect of the performance of a lock inference approach is the efficiency of its runtime locks. In this paper, we describe an implementation of the multi-level locks of Gray et al [7] using Java\u2019s Synchronizer framework [14] and present some preliminary performance results for a number of workloads that perform a varying proportion of fine-grained and coarse-grained operations. We compare our lock implementation against Java\u2019s ReentrantReadWriteLock and the STM algorithms TL2 [6] and LSA [17].", "num_citations": "1\n", "authors": ["1061"]}
{"title": "Client Speciation: The DOOM scenario\n", "abstract": " The promises of object-orientation and distributed computing could be delivered if the software we needed were written in stone. But it isn't, it changes. The challenge of Distributed Object-oriented Maintenance (DOOM) is to find a means of evolving software, which already has a distributed client base.Working within this scenario, we observe how certain object-oriented language systems seek to support differing client requirements and service obligations. In particular, we examine how the Java Language Specification (JLS) facilitates the concept of binary compatibility, a useful property, but one that may introduce a class of clients who dare not re-compile! Following a suggestion in the new draft JLS, we describe our tool to manage DOOM version control and we formulate some proposals for future developments.", "num_citations": "1\n", "authors": ["1061"]}