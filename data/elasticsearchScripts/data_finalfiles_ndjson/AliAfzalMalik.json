{"title": "Quantifying requirements elaboration to improve early software cost estimation\n", "abstract": " This paper describes an empirical study undertaken to investigate the quantitative aspects of the phenomenon of requirements elaboration which deals with transformation of high-level goals into low-level requirements. Prior knowledge of the magnitude of requirements elaboration is instrumental in developing early estimates of a project\u2019s cost and schedule. This study examines the data on two different types of goals and requirements \u2013 capability and level of service (LOS) \u2013 of 20 real-client, graduate-student, team projects done at USC. Metrics for data collection and analyses are described along with the utility of results they produce. Besides revealing a marked difference between the elaboration of capability goals and the elaboration of LOS goals, these results provide some initial relationships between the nature of projects and their ratios of elaboration of capability goals into capability or functional requirements.", "num_citations": "16\n", "authors": ["423"]}
{"title": "A parametric effort estimation model for mobile apps\n", "abstract": " According to a recent report [1], in 2015 alone, the revenue generated from mobile applications is expected to reach $100 billion. This figure indicates that one cannot neglect the potential of mobile application development business. Yet, despite this huge potential there is no calibrated and validated model for estimating the effort required to develop a new mobile application. In this paper, we fill this gap by proposing a new parametric model for helping project managers to estimate the effort required to develop mobile applications. Improper software development effort estimation can result in project failures due to budget overruns and schedule slips. A reasonable effort estimate, on the other hand, can lead to a successful project by enabling solid planning and scheduling. The parametric effort estimation model proposed in this paper is calibrated using data of more than 160 real-life mobile applications developed\u00a0\u2026", "num_citations": "12\n", "authors": ["423"]}
{"title": "A case study analyzing the impact of software process adoption on software quality\n", "abstract": " A constant focus on improving the quality of software lies at the heart of better customer satisfaction, increased market share, and higher profit margins. This paper presents the results of a case study designed to analyze the impact on software quality of the adoption of Scrum -- an agile software development process -- by a Pakistani software house that was not using any particular process earlier. Pre- and post-process adoption data on the severity of errors and defects and the ratio of passed to failed test cases is gathered and analyzed for four web-based financial applications developed by the software house. The results of the quantitative analysis clearly indicate that the adoption of an agile process improved the quality of the software produced by the software house by reducing the percentage of serious errors and defects and by increasing the ratio of passed to failed test cases.", "num_citations": "10\n", "authors": ["423"]}
{"title": "A size estimation model for board-based desktop games\n", "abstract": " Software size estimation plays a key role in the planning of projects at the time of project inception. This paper describes the derivation, validation, and usage of a parametric model meant for estimating the size of board-based desktop games. This model is derived using forward stepwise multiple linear regression on a data set comprising over 60 open source board-based games collected from multiple open source repositories. A variety of prediction accuracy metrics (e.g., MMRE, PRED(x), MdMRE, and so on) are used to assess this model and K-fold cross-validation is used to validate this model. Model assessment and validation exercises yield promising results. The utility of this model is demonstrated by presenting a worked-out game size estimation example followed by some size-related what-if analyses.", "num_citations": "8\n", "authors": ["423"]}
{"title": "Size estimation of open source board-based software games\n", "abstract": " Software effort, schedule, and cost estimation has the highest utility at the time of inception. Since software size is one of the most important determinant of software effort (and, hence, cost), it is extremely beneficial to estimate size early. This early estimation of size is likely to result in better planning for projects dealing with the development of software games. Yet, despite its utility, a survey of the existing literature does not reveal a technique developed for this purpose. In particular, this paper focuses on the size estimation of open source board-based software games. A new software size estimation model is proposed for this sub-domain. In this research, 52 open source board-based software games are thoroughly examined and analyzed. After shortlisting potential predictors of software size for this sub-domain, forward stepwise Multiple Linear Regression (MLR) is used for model fitting. The results show that our\u00a0\u2026", "num_citations": "7\n", "authors": ["423"]}
{"title": "Birds of a Feather Gel Together: Impact of Team Homogeneity on Software Quality and Team Productivity\n", "abstract": " Even though a lot of projects fail due to social issues or personality conflicts, only a small number of empirical studies have been conducted to quantitatively assess the impact of individual personality attributes on the software being developed and the team developing that software. The goal of this paper is to quantify the abstract notion of team homogeneity and to measure its impact on software quality and team productivity. A metric called team homogeneity index (THI) is proposed for this purpose. The six-step process of calculating the THI of a software development team is described and illustrated with the help of an example. Finally, the utility of THI is assessed by conducting a controlled experiment in two different phases of the software development life cycle (SDLC), i.e., implementation and testing. The results reveal that, during the implementation phase, teams with greater THI values were noticeably more\u00a0\u2026", "num_citations": "6\n", "authors": ["423"]}
{"title": "Swiss army knife of software processes generic framework of ISO 27001 and its mapping on resource management\n", "abstract": " Process reuse has gained much attention recently due to its tangible benefits. Similar benefits can also be obtained by reusing frameworks of existing standards. One such example is ISO 27001 standard that has a generic framework which can be used for improvement of areas other than information security. This paper presents the results of a case study in which we performed a mapping of ISO 27001 standard on resource management of a real-world organization by applying clauses and evaluating degree of applicability. Findings show that all clauses of ISO 27001 standard except Clause 6 are applicable to resource management. The framework of ISO 27001, therefore, seems flexible enough to be used for the improvement and process maturation of other management areas by defining relevant controls.", "num_citations": "5\n", "authors": ["423"]}
{"title": "An Empirical Study of Requirements Elaboration\n", "abstract": " This paper describes an empirical study undertaken to investigate the quantitative aspects of the phenomenon of requirements elaboration which deals with the transformation of high-level goals into low-level requirements. Prior knowledge of the magnitude of requirements elaboration is instrumental in developing early estimates of a project\u2019s cost and schedule. This study examines the data on capability goals and capability requirements of 20 realclient, MS-student, team projects done at USC. Metrics for data collection and analysis are described along with the utility of the results they produce. These results suggest some relationship between the nature of projects and the size of requirements elaboration.", "num_citations": "4\n", "authors": ["423"]}
{"title": "Impact of Design Patterns on Software Complexity and Size\n", "abstract": " Many different factors influence the quality of software. Among the most important of these factors is software complexity. One way to improve software quality, therefore, is to minimize its complexity making it more understandable and maintainable. The design phase of the software development life cycle plays an instrumental role in fostering quality in software. Seasoned designers often use past design best practices codified in the form of design patterns to make their designs and the resultant code more elegant, robust, and resilient to change. Little work, however, has been done to empirically assess the quantitative impact of design patterns on software complexity. This research is an attempt to fill this gap. A comparative analysis of before and after versions of program pairs written without and with design patterns was performed for all twentythree GoF (Gang of Four) design patterns. These program pairs were collected (or, in some cases, developed) and compared with respect to their complexity and size. The results of this comparative analysis reveal that the cyclomatic complexity of the programs written using design patterns was less for most of the design patterns as compared to the programs written without using design patterns. However, the values of CK metrics, number of classes, and software size SLOC (Source Lines of Code) increased when design patterns were used.", "num_citations": "3\n", "authors": ["423"]}
{"title": "Evaluating the Impact of Pair Testing on Team Productivity and Test Case Quality\u2013A Controlled Experiment\n", "abstract": " One of the main objectives of software testing is to uncover the maximum number of faults while consuming the least amount of resources. This research is an attempt to investigate the utility of an unconventional testing technique called pair testing in achieving this goal. In pair testing, two individuals sit together at one keyboard to test the software. An empirical study was designed and conducted to evaluate the performance of pair testing vis-\u00e0-vis conventional testing. Six pairs of testers divided into two different groups-one using pair testing and the other using conventional testing-participated in a controlled experiment involving three separate projects. The productivity of the groups and the quality of their work were quantitatively evaluated and compared. The results of comparison revealed that the group using pair testing spent more effort but the quality of its work was better.", "num_citations": "3\n", "authors": ["423"]}
{"title": "Effort estimation of ETL projects using Forward Stepwise Regression\n", "abstract": " Effort estimation is a key component of planning a software development project. In the past, there has been a lot of research on estimation methods for traditional applications but, unfortunately, these methods do not apply to Extract Transform Load (ETL) projects. Coming up with a systematic effort estimate for ETL projects is a challenging task since ETL development does not follow the traditional Software Development Life Cycle (SDLC). Traditional application development is requirements-driven whereas ETL application development is data-driven. This research paper describes the development of an effort estimation model for ETL projects and compares this model with the most widely used algorithmic effort estimation model i.e. COCOMO II. A dataset comprising 220 industrial projects from five different software houses is used to build this effort estimation model using Forward Stepwise Regression. After\u00a0\u2026", "num_citations": "3\n", "authors": ["423"]}
{"title": "Determining the factors affecting the accuracy of effort estimates for different application and task types\n", "abstract": " An important asset in the skill set of any software project manager is the ability to somewhat accurately estimate the effort required to develop a software application. Acquiring this asset, however, requires a thorough understanding of the factors that may affect the accuracy of these estimates. This paper presents the results of an empirical study conducted to determine the causes of variation in the accuracy of effort estimations for different application and task types. A Pakistani software house that specializes in developing financial transaction processing applications is chosen for this empirical study. Actual and estimated values for software development effort are gathered and analyzed for four different types of applications - web-based, database, parallel processing, and telephony - each having six different types of tasks i.e. business-development, new features, usability, security, support, and performance. Over\u00a0\u2026", "num_citations": "3\n", "authors": ["423"]}
{"title": "An Empirical Study of Requirements-to-Code Elaboration Factors\n", "abstract": " During a software development project\u2019s lifecycle, requirements are specified at multiple levels of detail eg objectives, shall statements, use cases, etc. The elaboration of requirements proceeds from one level of detail to the other till the final level\u2013lines of code\u2013is reached. This empirical study conducts a quantitative analysis of this hierarchical process of requirements elaboration. Multi-level requirements data from 25 small e-services projects is examined and the ratios between the numbers of requirements at consecutive levels are determined. Knowledge of these ratios\u2013called elaboration factors\u2013can play a crucial role in early software cost estimation. A case study demonstrating the utility of this approach in producing an early size estimate of a large commercial project is also presented.", "num_citations": "3\n", "authors": ["423"]}
{"title": "Evolution of Prepaid Payment Processor's Software Architecture: An Empirical Study\n", "abstract": " Prepaid cards are the payment option for consumers who want to use an electronic means of payment but do not want to tie up the payment with a credit or debit account. When a prepaid card transaction is initiated using a Point of Sale (POS) machine or an Automated Teller Machine (ATM), it travels through multiple entities for authorization. These entities include merchants, acquirers, branded networks, and payment processors. Each of the entities has its own software solution for processing its part of the transaction. In this paper we present an empirical study of the evolution of a payment processor's software architecture. We first describe a basic architecture which acts as a baseline for further evolution. Results of transaction processing on this baseline architecture are discussed to highlight different quality of service issues. This architecture is gradually evolved into subsequent architectures resolving the\u00a0\u2026", "num_citations": "2\n", "authors": ["423"]}
{"title": "Comparative analysis of requirements elaboration of an industrial product\n", "abstract": " Requirements for a software development project are gradually refined as more information becomes available. This process of requirements elaboration can be quantified using the appropriate set of metrics. This paper reports the results of an empirical study conducted to analyze the requirements elaboration of an industrial software process management tool-SoftPM-being used by more than 300 Chinese commercial software organizations. After adjusting for the effects of overlaps amongst different versions of SoftPM, multi-level requirements data are gathered and elaboration factors for each version are obtained. These elaboration data are compared with the data from a previous empirical study that analyzed requirements elaboration of a set of different small e-services projects. This comparison reveals that the elaboration factors of different SoftPM versions have much less variation confirming the intuition that\u00a0\u2026", "num_citations": "2\n", "authors": ["423"]}
{"title": "Empirical Study on Pair Documentation\n", "abstract": " The single most important deliverable of the entire requirements engineering process is the software/system requirements specification (SRS). This research focuses on a non-traditional approach of producing the SRS, ie, pair documentation. As in the case of pair programming, pair documentation involves two individuals working simultaneously on the same SRS. This paper presents the design and results of an empirical study conducted to analyze the impact of pair documentation on requirements, quality and team productivity. Requirements documents produced by two different teams (one of them using pair documentation) working on the same project are compared. The results reveal that there is a marked improvement in the productivity of the team using pair documentation and the quality of the document produced by this team is also much better.", "num_citations": "1\n", "authors": ["423"]}
{"title": "An Empirical Study of the Efficacy of COCOMO II Cost Drivers in Predicting a Project\u2019s Elaboration Profile\n", "abstract": " A project\u2019s elaboration profile consists of a set of ratios called elaboration factors that quantify the step-wise expansion of a project\u2019s requirements from very high-level business objectives to very low-level source lines of code. Knowledge of a project\u2019s elaboration profile can be extremely useful in deriving an early estimate of its size. The real challenge, however, is to predict the elaboration profile. Can the COCOMO II cost drivers be used for this purpose? This paper attempts to answer this question. It examines the elaboration profiles and COCOMO II cost driver ratings of 25 small real-client projects. The data collection process is thoroughly described and the cost drivers relevant at each stage of elaboration are identified. Relationships between elaboration factors and relevant cost drivers are analyzed using simple as well as multiple regression. The results indicate that there is no magical formula for predicting the various elaboration factors just from the values of COCOMO II cost drivers. This may be due to some confounding factors which are highlighted in this paper.", "num_citations": "1\n", "authors": ["423"]}