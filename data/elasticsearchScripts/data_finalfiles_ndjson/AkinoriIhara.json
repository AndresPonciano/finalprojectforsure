{"title": "A dataset of high impact bugs: Manually-classified issue reports\n", "abstract": " The importance of supporting test and maintenance activities in software development has been increasing, since recent software systems have become large and complex. Although in the field of Mining Software Repositories (MSR) there are many promising approaches to predicting, localizing, and triaging bugs, most of them do not consider impacts of each bug on users and developers but rather treat all bugs with equal weighting, excepting a few studies on high impact bugs including security, performance, blocking, and so forth. To make MSR techniques more actionable and effective in practice, we need deeper understandings of high impact bugs. In this paper we introduced our dataset of high impact bugs which was created by manually reviewing four thousand issue reports in four open source projects (Ambari, Camel, Derby and Wicket).", "num_citations": "49\n", "authors": ["2280"]}
{"title": "An analysis method for improving a bug modification process in open source software development\n", "abstract": " As open source software products have evolved over time to satisfy a variety of demands from increasing users, they have become large and complex in general. Open source developers often face with challenges in fixing a considerable amount of bugs which are reported into a bug tracking system on a daily basis. As a result, the mean time to resolve bugs has been protracted in these days. In order to reduce the mean time to resolve bugs, managers/leaders of open source projects need to identify and understand the bottleneck of a bug modification process in their own projects. In this paper, we propose an analysis method which represents a bug modification process using a bug tracking system as a state transition diagram and then calculates the amount of time required to transit between states. We have conducted a case study using Firefox and Apache project data to confirm the usefulness of the analysis\u00a0\u2026", "num_citations": "42\n", "authors": ["2280"]}
{"title": "Patch reviewer recommendation in oss projects\n", "abstract": " In an Open Source Software (OSS) project, many developers contribute by submitting source code patches. To maintain the quality of the code, certain experienced developers review each patch before it can be applied or committed. Ideally, within a short amount of time after its submission, a patch is assigned to a reviewer and reviewed. In the real world, however, many large and active OSS projects evolve at a rapid pace and the core developers can get swamped with a large number of patches to review. Furthermore, since these core members may not always be available or may choose to leave the project, it can be challenging, at times, to find a good reviewer for a patch. In this paper, we propose a graph-based method to automatically recommend the most suitable reviewers for a patch. To evaluate our method, we conducted experiments to predict the developers who will apply new changes to the source\u00a0\u2026", "num_citations": "20\n", "authors": ["2280"]}
{"title": "Code review participation: game theoretical modeling of reviewers in gerrit datasets\n", "abstract": " Code review is a common practice for improving the quality of source code changes and expediting knowledge transfer in a development community. In modern code review, source code changes or patches are considered to be assessed and approved for integration by multiple reviews. However, from our empirical study, we found that some patches are reviewed by only one reviewer, and some reviewers did not continue the review discussion, which can have negative effects on software quality. To understand these reviewers' behaviors, we model the code review situation based on the snowdrift game, which is used to analyze social dilemmas. With this game-theoretical modeling, we found that it can explain reviewers' behaviors well.", "num_citations": "17\n", "authors": ["2280"]}
{"title": "The impact of a low level of agreement among reviewers in a code review process\n", "abstract": " Software code review systems are commonly used in software development. In these systems, many patches are submitted to improve the quality. To verify the quality, voting is commonly used by contributors; however, there still exists a major problem, namely, that reviewers do not always simply reach a broad agreement. In our previous study, we found that consensus is not usually reached, implying that an individual reviewer\u2019s final decision usually differs from that of the majority of the other reviewers. In this study, we further investigate the reasons why such situations often occur, and provide suggestions for better handling of these problems. Our analysis of the Qt and OpenStack project datasets allow us to suggest that a patch owner should select more appropriate reviewers who often agree with others\u2019 decisions.", "num_citations": "15\n", "authors": ["2280"]}
{"title": "Understanding key features of high-impact bug reports\n", "abstract": " Nowadays, software projects are receiving bug reports on a daily basis. Developers cannot treat all the bugs in the same priority since some bugs can significantly affect software development process and the quality of products. Previous studies defined these bugs as High Impact Bug (HIB) and they found that HIB should be fixed quicker than other bugs in software development. However, fixing a HIB sometimes become complicated because the low-quality bug reports can be delay the bug fixing. In this study, we investigate what information is essential when reporting a HIB report. As a case study, we manually examine the HIB reports and perform both qualitative and quantitative analysis in Apache Camel project. Our main findings include: (1) we find four types of features are the most requested information from developers when they fix HIB, (2) the requested additional information significantly influences bug\u00a0\u2026", "num_citations": "11\n", "authors": ["2280"]}
{"title": "Why is collaboration needed in oss projects? a case study of eclipse project\n", "abstract": " In open source software development, the collaboration among developers is the key to improve software quality. In particular, to fix a bug related to various parts of a system, developers need collaboration because each developer usually has very limited knowledge about a large software system. This paper aims to clarify how narrow (or how wide) is each developer's knowledge area in the Eclipse project, and how often do developers need to collaborate with each other. As a result of analysis, we found that 50% of committers take care of just one or two modules, which indicates the necessity of collaboration when a bug-fix affects multiple modules. In addition, we also found the significant relationship between committers' collaborations and the re-opened bugs. We conclude that a committer should be aware the risk of re-opened bugs caused by the collaboration.", "num_citations": "11\n", "authors": ["2280"]}
{"title": "An analysis of committers toward improving the patch review process in oss development\n", "abstract": " In recent years, individual and business users have made widespread use of Open Source Software (OSS) products. As OSS products have become important for the modern society, users expect OSS developers to fix existing bugs in the products as soon as possible. The goal of our study is to develop a better understanding of the patch review process in OSS development and to provide insight on how to elect an appropriate developer as a committer who will have a great impact on the quality of OSS products. We conducted a case study of the PostgreSQL project to look at an actual patch review process and how committers contribute to the patch review process. As a result of this case study, we found that there are significant differences between committers and noncommitters in the number of patch reviews and edits. We also found committers tend to review and edit patches many times, but are not always speedy about reviewing and editing patches.", "num_citations": "11\n", "authors": ["2280"]}
{"title": "Good or bad committers? a case study of committers' cautiousness and the consequences on the bug fixing process in the Eclipse project\n", "abstract": " There are many roles to play in the bug fixing process in open source software development. A developer called ``Committer'', who has a permission to submit a patch into software repository, plays a major role in this process and hold a key to the successfulness of the project. In this work, we have observed each committer activities from the Eclipse-Platform bug tracking system and version archives. Despite the importance of committer's activities, we suspected that sometimes committers can make mistakes, which have negative consequences to the bug fixing process. Our research focus on studying the consequences of each committer's activities to this process. We collected each committer's historical data and evaluated each of them by comparing the more cautiousness to less cautiousness committers. Then we looked deeper into each committer's characteristics to see the reasons why some committers tend to\u00a0\u2026", "num_citations": "8\n", "authors": ["2280"]}
{"title": "How is if statement fixed through code review? a case study of qt project\n", "abstract": " Peer code review is key to ensuring the absence of software defects. To improve the review process, many code review tools provide OSS(Open Source Software) project CI(Continuous Integration) tests that automatically verify code quality issues such as a code convention issues. However, these tests do not cover project policy issues and a code readability issues. In this study, our main goal is to understand how a code owner fixes conditional statement issues based on reviewers feedback. We conduct an empirical study to understand if statement changes after review. Using 69,325 review requests in the Qt project, we analyze changes of the if conditional statements that (1) are requested to be reviewed, and (2) that are implemented after review. As a result, we find the most common symbolic changes are \"(\" and \")\" (35%), \"!\" operator (20%) and \"->\" operator (12%). Also, \"!\" operator is frequently replaced with \"(\"\u00a0\u2026", "num_citations": "7\n", "authors": ["2280"]}
{"title": "Pilot study of collective decision-making in the code review process\n", "abstract": " Political arguments and voting requirements often follow a simple majority method which is a decision rule that selects various alternatives that have a majority, that is, more than half the votes. On the other hand, Q&A services such as StackExchange and Yahoo! Answers use the simple majority method only as a reference point. In other words, even if an answer receives a majority vote (which represents a preferred answer for followers), the questioner might not accept the answer. In this case, the voting is used only as a reference. Open Source Software (OSS) projects might also use the voting approach only as a reference on the code review process, because a core reviewer (who makes the final decision) might not integrate a patch which was approved by reviewers into the version control system. Likewise, the votes from other reviewers might also only be used as a reference. This study identifies how many patch sets for code review follow the simple majority method in collective decision-making among reviewers. As a case study, we have analysed the criteria needed to integrate patch sets using Qt project data. From the results, we have found that only 59.5% patch sets followed the simple majority method. Patch sets with more negative votes than positive votes were likely to be rejected. Furthermore, the last vote in the first review also impacted the final decision in the first review.", "num_citations": "7\n", "authors": ["2280"]}
{"title": "Industry questions about open source software in business: Research directions and potential answers\n", "abstract": " As open source software (OSS) has become an integral part of today's software businesses, many software companies rely on OSS to develop their customer solutions and products. On the other hand, they face various concerns in using OSS, such as technical support, quality, security and licensing issues. This paper focuses on OSS-related FAQ in industry, and tries to answer them or to provide research directions based on lessons learned from recent mining OSS repository researches.", "num_citations": "7\n", "authors": ["2280"]}
{"title": "Devreplay: Automatic repair with editable fix pattern\n", "abstract": " Static analysis tools, or linters, detect violation of source code conventions to maintain project readability. Those tools automatically fix specific violations while developers edit the source code. However, existing tools are designed for the general conventions of programming languages. These tools do not check the project/API-specific conventions. We propose a novel static analysis tool DevReplay that generates code change patterns by mining the code change history, and we recommend changes using the matched patterns. Using DevReplay, developers can automatically detect and fix project/API-specific problems in the code editor and code review. Also, we evaluate the accuracy of DevReplay using automatic program repair tool benchmarks and real software. We found that DevReplay resolves more bugs than state-of-the-art APR tools. Finally, we submitted patches to the most popular open-source projects that are implemented by different languages, and project reviewers accepted 80% (8 of 10) patches. DevReplay is available on https://devreplay.github.io.", "num_citations": "6\n", "authors": ["2280"]}
{"title": "An analysis of gradual patch application: A better explanation of patch acceptance\n", "abstract": " Patch submission has been known as one of the most important activities to sustain the open source software (OSS). The patch archive can be analyzed to procure many benefit cognizance for supporting the OSS project works. The recent models and methods that analyze the patches acceptance are quite rack of comprehensive; hence, complex activities such as a committer portioning the Passed QA patch out and accept are still excluded from the analysis. Therefore, the results derived from those methods would be inadequate to conclude the actual patch acceptance. In this research, we introduce an algorithm for analyzing patch acceptance including the partial and gradually accepted conditions. Validating our algorithm, we present our methods for indicating the partial and gradual application of the Passed QA patch between either mailing list and SVN or Bugzilla and CVS which are the commonly deployed\u00a0\u2026", "num_citations": "6\n", "authors": ["2280"]}
{"title": "Do open source software projects conduct tests enough?\n", "abstract": " Do open source software projects provide and maintain tests? What metrics are correlated with the test success? This paper answers these questions by executing tests of 452 open source software projects in GitHub and measuring 13 metrics from 77 projects. Only 117 projects passed all test cases. Additionally, the results are correlated with the comment density, public documented API density, and test coverage.", "num_citations": "5\n", "authors": ["2280"]}
{"title": "On the Lag of Library Vulnerability Updates: An Investigation into the Repackage and Delivery of Security Fixes Within The npm JavaScript Ecosystem\n", "abstract": " Vulnerabilities in third-party libraries is a growing concern for the software developer, as it poses risks not only to the software client itself but to the entire software ecosystem. To mitigate these risks, developers are strongly recommended to update their dependencies. Recent studies show that affected developers are not likely to respond to the vulnerability threat. However, another reason for the lag of vulnerability updates is due to slow repackaging (ie, package the vulnerability fix into a new version) and delivery (ie, affected client adopt the new version) of the fix. To understand these lags of updates, we use both qualitative and quantitative approaches to conduct an empirical study on how 188 fixes were repackaged and delivered across over eight hundred thousand releases of npm software clients hosted on GitHub. We report two lags:(1) lags in repackaging occur as vulnerability fixes are more likely to be bundled with other non-related updates (ie, about 83.33% of commits are not related to the fix) and (2) lags in the delivery are caused by clients that are more likely to adopt the minor fix than adopt the patch fix. Furthermore, other factors such as downstream dependencies and severity do have an impact. We also find that freshness of packages does not impact the amount of lags. The identification of these two lags opens up different avenues on how to facilitate faster fix delivery throughout a library ecosystem.", "num_citations": "4\n", "authors": ["2280"]}
{"title": "Impact of coding style checker on code review-a case study on the openstack projects\n", "abstract": " Code review is key to ensuring the absence of potential issues in source code. Code review is changing from a costly manual check by reviewer to a cost-efficient automatic check by coding style checkers. So that patch authors can verify the changed code before submitting their patches. Although cost-efficiency, the checkers do not detect all potential issues, requiring reviewers to verify the submitted patches based on their knowledge. It would be most efficient if patch authors will learn potential issues and remove the same type of issues from patches prior to code review. This study investigates potential issues that patch authors have repeatedly introduced in their patch submissions despite receiving feedback. To understand the impact of adopting checkers to patch authors' coding style improvement, this study compares two types of potential issues: Automatically Detected Issues by checkers (ADIs) and Manually\u00a0\u2026", "num_citations": "4\n", "authors": ["2280"]}
{"title": "Do Review Feedbacks Influence to a Contributor's Time Spent on OSS Projects?\n", "abstract": " Open Source Software (OSS) does not work without contributions from the community. In particular, long-term contributors (LTCs) (e.g., committer), defined as contributors who spend at least one year on OSS projects, play a crucial role in a project success because they would have permission to add (commit) code changes to a project's version control system, and to become a mentor for a beginner in OSS projects. However, contributors often leave a project before becoming a LTC because most contributors are volunteers. If contributors are motivated in their work in OSS projects, they might not leave the projects. In this study, we examine the phenomena involved in becoming a LTC in terms of motivation to continue in OSS projects. In particular, our target motivation is to understand what is involved in long-term contribution with other expert contributors. We study classifier to identify a LTC who will contribute\u00a0\u2026", "num_citations": "4\n", "authors": ["2280"]}
{"title": "Project IS^ 3: Incentive-Based Intelligent Intervention for Smart and Sustainable Society\n", "abstract": " Project IS^3 is the leading-edge project in Nara Institute of Science and Technology, a national graduate school in Japan, started from February 2016. This project aims to utilize a human's behavior change for solving the social problems and maintaining our society sustainably. In order to cause the behavior change intentionally, various information technologies are required. In this paper, we explain the concept and goal of our project and figure out what we will do in this project.", "num_citations": "4\n", "authors": ["2280"]}
{"title": "Good or Bad Committers?\u2014\u2014A Case Study of Committer's Activities on the Eclipse's Bug Fixing Process\n", "abstract": " There are many roles to play in the bug fixing process in open source software development. A developer called \u201cCommitter\u201d, who has a permission to submit a patch into a software repository, plays a major role in this process and holds a key to the successfulness of the project. Despite the importance of committer\u2019s activities, we suspect that sometimes committers can make mistakes which have some consequences to the bug fixing process (eg, reopened bugs after bug fixing). Our research focuses on studying the consequences of each committer\u2019s activities to this process. We collected each committer\u2019s historical data from the Eclipse-Platform\u2019s bug tracking system and version control system and evaluated their activities using bug status in the bug tracking system and commit log in the version control system. Then we looked deeper into each committer\u2019s characteristics to see the reasons why some committers tend to make mistakes more than the others.", "num_citations": "4\n", "authors": ["2280"]}
{"title": "An Algorithm for Gradual Patch Acceptance Detection in Open Source Software Repository Mining\n", "abstract": " Nowadays, software development societies have given more precedence to Open Source Software (OSS). There is much research aimed at understanding the OSS society to sustain the OSS product. To lead an OSS project to a successful conclusion, researchers study how developers change source codes called patches in project repositories. In existing studies, we found an argument in the conventional patch acceptance detection procedure. It was so simplified that it omitted important cases from the analysis, and would lead researchers to wrong conclusions. In this research, we propose an algorithm to overcome the problem. To prove out our algorithm, we constructed a framework and conducted two case studies. As a result, we came to a new and interesting understanding of patch activities.", "num_citations": "4\n", "authors": ["2280"]}
{"title": "Extraction of library update history using source code reuse detection\n", "abstract": " This paper proposes a method to extract and visualize a library update history in a project. The method identifies reused library versions by comparing source code in a product with existing versions of the library so that developers can understand when their own copy of a library has been copied, modified, and updated.", "num_citations": "3\n", "authors": ["2280"]}
{"title": "Which review feedback did long-term contributors get on OSS projects?\n", "abstract": " Open Source Software (OSS) cannot exist without contributions from the community. In particular, long-term contributors (LTCs) (e.g., committer), defined as contributors who spend at least one year on OSS projects, play crucial role in a project success because they would have permission to add (commit) code changes to a project's version control system, and to become a mentor for a beginner in OSS projects. However, contributors often leave a project before becoming a LTC because most contributors are volunteers. If contributors are motivated in their work in OSS projects, they might not leave the projects. In this study, we examine the phenomena involved in becoming a LTC in terms of motivation to continue in OSS projects. In particular, our target motivation is to understand what is involved in long-term contribution with other expert contributors. We study classifier to identify a LTC who will contribute patch\u00a0\u2026", "num_citations": "3\n", "authors": ["2280"]}
{"title": "Understanding Oss Openness Through Relationship between Patch Acceptance and Evolution Pattern\n", "abstract": " Openness is referred how much does the OSS core committer team share and compile with their non-committers. Because the openness can be varied from time to time, a study for explaining the vary of openness would be a good approach to support the OSS. It will not only encourage the non-committers to exert more contribution when the openness is high, but it will also make the them still have an optimistic outlook on the project when the openness is low. Unfortunately, there is only a few studies aiming to understand this principle. This work, we seek out for the key factors that identify the transitory changed of the openness. Unlike most previous studies, we focus on the clear relevant evidences that are more concrete. Our temporal-based analysis on patch acceptance in two major OSS projects: Apache HTTP Server and Eclipse Platform conclude that special event occurrences have a decisive influence over the openness either in transitory or lasting. Moreover, our investigation on the relationship between the temporal changes of openness and a plausible OSS evolution pattern broadens the mutual accord in both openness and the evolution of OSS.", "num_citations": "3\n", "authors": ["2280"]}
{"title": "Identifying and predicting key features to support bug reporting\n", "abstract": " Bug reports are the primary means through which developers triage and fix bugs. To achieve this effectively, bug reports need to clearly describe those features that are important for the developers. However, previous studies have found that reporters do not always provide such features. Therefore, we first perform an exploratory study to identify the key features that reporters frequently miss in their initial bug report submissions. Then, we propose an approach that predicts whether reporters should provide certain key features to ensure a good bug report. A case study of the bug reports for Camel, Derby, Wicket, Firefox, and Thunderbird projects shows that Steps to Reproduce, Test Case, Code Example, Stack Trace, and Expected Behavior are the additional features that reporters most often omit from their initial bug report submissions. We also find that these features significantly affect the bug\u2010fixing process. On\u00a0\u2026", "num_citations": "2\n", "authors": ["2280"]}
{"title": "What Are the Perception Gaps Between FLOSS Developers and SE Researchers?\n", "abstract": " In recent years, many researchers in the SE community have been devoting considerable efforts to provide FLOSS developers with a means to quickly find and fix various kinds of bugs in FLOSS products such as security and performance bugs. However, it is not exactly sure how FLOSS developers think about bugs to be removed preferentially. Without a full understanding of FLOSS developers\u2019 perceptions of bug finding and fixing, researchers\u2019 efforts might remain far away from FLOSS developers\u2019 needs. In this study, we interview 322 notable GitHub developers about high impact bugs to understand FLOSS developers\u2019 needs for bug finding and fixing, and we manually inspect and classify developers\u2019 answers (bugs) by symptoms and root causes of bugs. As a result, we show that security and breakage bugs are highly crucial for FLOSS developers. We also identify what kinds of high impact bugs should\u00a0\u2026", "num_citations": "2\n", "authors": ["2280"]}
{"title": "Mining source code improvement patterns from similar code review works\n", "abstract": " Code review is key to ensuring the absence of potential issues in source code. Code reviewers spend a large amount of time to manually check submitted patches based on their knowledge. Since a number of patches sometimes have similar potential issues, code reviewers need to suggest similar source code changes to patch authors. If patch authors notice similar code improvement patterns by themselves before submitting to code review, reviewers' cost would be reduced. In order to detect similar code changes patterns, this study employs a sequential pattern mining to detect source code improvement patterns that frequently appear in code review history. In a case study using a code review dataset of the OpenStack project, we found that the detected patterns by our proposed approach included effective examples to improve patches without reviewers' manual check. We also found that the patterns have been\u00a0\u2026", "num_citations": "2\n", "authors": ["2280"]}
{"title": "Differences of time between modification and re-modification: An analysis of a bug tracking system\n", "abstract": " Managers of open source projects need to understand time to resolve bugs, which are reported into a bug tracking system on a daily basis, to make a release plan. Hewett et al. proposed an empirical approach to predicting time required to repair bugs. However, the predictive model did not distinguish between time to modify a firstly-reported bug and time to re-modify a bug. In this paper, toward predicting time to resolve bugs with accuracy, we identify such the differences of time between bug modifications and re-modifications. We have conducted a case study using Firefox project data. As a result of this case study, we have confirmed that time to resolve a firstly reported bug was shorter than time to re-modify a bug.", "num_citations": "2\n", "authors": ["2280"]}
{"title": "How are IF-Conditional Statements Fixed Through Peer CodeReview?\n", "abstract": " Peer code review is key to ensuring the absence of software defects. To reduce review costs, software developers adopt code convention checking tools that automatically identify maintainability issues in source code. However, these tools do not always address the maintainability issue for a particular project. The goal of this study is to understand how code review fixes conditional statement issues, which are the most frequent changes in software development. We conduct an empirical study to understand if-statement changes through code review. Using review requests in the Qt and OpenStack projects, we analyze changes of the if-conditional statements that are (1) requested to be reviewed, and are (2) revised through code review. We find the most frequently changed symbols are \u201c( )\u201d, \u201c.\u201d, and \u201c!\u201d. We also find project-specific fixing patterns for improving code readability by association rule mining. For example\u00a0\u2026", "num_citations": "1\n", "authors": ["2280"]}
{"title": "\u5f62\u614b\u7d20 N-gram \u3092\u7528\u3044\u305f\u4e0d\u5177\u5408\u4fee\u6b63\u5b8c\u4e86\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u7279\u5b9a\n", "abstract": " This paper proposes a method to recommend the developer the source code from a bug report. The proposed method combines the N-gram and morphological analysis. It finds the commit log which similar to a comment written in the target bug report. Evaluation experiment applied the proposed method to the repository of open source software projects. The result shows that the proposed method recommended the correct source code for 75.9% of the bug reports.", "num_citations": "1\n", "authors": ["2280"]}
{"title": "A System for Information Integration between Development Support Systems\n", "abstract": " Many software projects use dezvelopment support systems such as bug tracking system (BTS) or version control system (VCS) to manage development information. Such the support systems preserve information according to a type of information (eg, bug information in BTS and change information of source code in VCS). Since the systems do not provide developers with a feature to integrate several types of information required to complete development tasks, the developers need to collect the information by themselves that would result in inefficient development. In this paper, we demonstrate a system called SUSHI that helps developer integrate the information between multiple development support systems. Our system collects information which belongs to the same development context and provides developers with hyper links to related information in the support systems. Since our system also runs as a proxy server, developers can continue to use existing systems and stored information without any conversion.", "num_citations": "1\n", "authors": ["2280"]}