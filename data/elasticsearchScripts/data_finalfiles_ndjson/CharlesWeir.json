{"title": "A stitch in time: Supporting android developers in writingsecure code\n", "abstract": " Despite security advice in the official documentation and an extensive body of security research about vulnerabilities and exploits, many developers still fail to write secure Android applications. Frequently, Android developers fail to adhere to security best practices, leaving applications vulnerable to a multitude of attacks. We point out the advantage of a low-time-cost tool both to teach better secure coding and to improve app security. Using the FixDroid IDE plug-in, we show that professional and hobby app developers can work with and learn from an in-environment tool without it impacting their normal work; and by performing studies with both students and professional developers, we identify key UI requirements and demonstrate that code delivered with such a tool by developers previously inexperienced in security contains significantly less security problems. Perfecting and adding such tools to the Android\u00a0\u2026", "num_citations": "90\n", "authors": ["1383"]}
{"title": "Developers need support, too: A survey of security advice for software developers\n", "abstract": " Increasingly developers are becoming aware of the importance of software security, as frequent high-profile security incidents emphasize the need for secure code. Faced with this new problem, most developers will use their normal approach: web search. But are the resulting web resources useful and effective at promoting security in practice? Recent research has identified security problems arising from Q&A resources that help with specific secure-programming problems, but the web also contains many general resources that discuss security and secure programming more broadly, and to our knowledge few if any of these have been empirically evaluated. The continuing prevalence of security bugs suggests that this guidance ecosystem is not currently working well enough: either effective guidance is not available, or it is not reaching the developers who need it. This paper takes a first step toward\u00a0\u2026", "num_citations": "74\n", "authors": ["1383"]}
{"title": "Organizing pointers to objects in an array to improve the speed of object retrieval\n", "abstract": " The invention may be a method of organizing pointers. The pointers may identify addresses where objects are stored. The pointers may be stored in arrays so that the pointers corresponding to the most recently selected objects are stored nearer to ends of the arrays than are the pointers corresponding to less recently selected objects. The invention may be embodied as a machine designed to carry out the method, or as a memory device that is capable of causing a computer to carry out the method.", "num_citations": "55\n", "authors": ["1383"]}
{"title": "From needs to actions to secure apps? the effect of requirements and developer practices on app security\n", "abstract": " Increasingly mobile device users are being hurt by security or privacy issues with the apps they use. App developers can help prevent this; inexpensive security assurance techniques to do so are now well established, but do developers use them? And if they do so, is that reflected in more secure apps? From a survey of 335 successful app developers, we conclude that less than a quarter of such professionals have access to security experts; that less than a third use assurance techniques regularly; and that few have made more than cosmetic changes as a result of the European GDPR legislation. Reassuringly, we found that app developers tend to use more assurance techniques and make more frequent security updates when (1) they see more need for security, and (2) there is security expert or champion involvement.", "num_citations": "13\n", "authors": ["1383"]}
{"title": "Patterns for designing in teams\n", "abstract": " Few sources appear to cover this subject. Most books on software design or methods appear to assume a single designer, possibly kept from wilder excesses by a system of reviews. However software development is almost invariably a team process. How then can we leverage the individual strengths of each development team member to get a better result than one single designer could achieve alone?The purpose of design is to agree what will be built. Designs must be written down to get agreement1, so in practice the design will exist as a set of written documents. According to the needs of the design process these may be anything from a collection of sketches to an encyclopaedic set of formal specifications. It is difficult yet vital to produce such documents as a team, since the design process takes much of the creative manpower in the project.", "num_citations": "13\n", "authors": ["1383"]}
{"title": "Architectural Styles for Distribution Using Macro-Patterns for System Design\n", "abstract": " This paper highlights the problem of describing the software architecture of a distributed system, and introduces the Architectural Styles proposed by Shaw&Garlan as a possible solution. Using a pattern template, it explores four major styles for distribution architecture: Host-Terminal, Client-Server, Broadcast Data and Batch Communication. Introduction One major problem we find in building large software systems is the problem of talking about their structure. How do we discuss different ways of putting together system components? Currently we lack a sufficiently rich vocabulary. There is a very effective method to build up a vocabulary. We use narrative, examples, similes and references to build up new concepts in the mind of the reader, and then give this concept a name. From then on we can use the name in our discussions and documentation. I am aware of two leading researchers using this kind of approach:[Jackson] describesProblem Frames'(structures for a system), and uses a...", "num_citations": "9\n", "authors": ["1383"]}
{"title": "A Passion for Security: Intervening to Help Software Developers\n", "abstract": " While the techniques to achieve secure, privacy-preserving software are now well understood, evidence shows that many software development teams do not use them: they lack the \u2018security maturity\u2019 to assess security needs and decide on appropriate tools and processes; and they lack the ability to negotiate with product management for the required resources. This paper describes a measuring approach to assess twelve aspects of this security maturity; its use to assess the impact of a lightweight package of workshops designed to increase security maturity; and a novel approach within that package to support developers in resource negotiation. Based on trials in eight organizations, involving over 80 developers, this paper demonstrates that (1) development teams can notably improve their security maturity even in the absence of security specialists; and (2) suitably guided, developers can find effective ways to\u00a0\u2026", "num_citations": "6\n", "authors": ["1383"]}
{"title": "Improve your Sense of Ownership Exploring a Design Principle\n", "abstract": " How far does a program object extend? It sounds like a trivial question. Surely an object covers only the memory allocated by the system for its space? A C++ object occupies the space allocated by the \u2018new\u2019operator; a Smalltalk object the same. However, when we think about what we really mean by \u2018an object\u2019, in most cases we find that the answer is not at all trivial. For most objects are made up of other objects; they own other objects. This article will explore this ownership in detail. The notation used here is based on Syntropy\u2019s implementation model (see [Cook&Daniels]). The following uses the C++ term \u201cpointer\u201d to mean an object identifier; Smalltalk programmers and others please make the appropriate translations: AB Indicates that for each B, there is exactly one associated A; for each A, there are zero or many Bs To this we add arrows to show how the associations are actually implemented in code: AB An instance of A contains a collection of pointers to B (but a B has no references to any A\u2019s) AB Each B has a pointer to its corresponding A (but As know nothing of Bs). AB Each A has a collection of pointers to B; each B has a collecton of pointers to A. Note: Strictly speaking, these descriptions of the arrows give just one possible implementation of the required visibilities. For example, in the first case, A might contain (in C++) an embedded array of B\u2019s, or A might look up its B\u2019s in some central location. Figure 1: A Note on Notation Consider the Order object in Figure 2 (which uses the notation described in Figure 1). It has associations to each of its OrderItem objects. Each OrderItem then has an association to the ordered Product. It seems\u00a0\u2026", "num_citations": "2\n", "authors": ["1383"]}
{"title": "Architectural Styles for Distribution\n", "abstract": " This paper highlights the problem of describing the software architecture of a distributed system, and introduces the Architectural Styles proposed by Shaw&Garlan as a possible solution. Using a pattern template, it explores four major styles for distribution architecture: Host-Terminal, Client-Server, Broadcast Data and Batch Communication.", "num_citations": "1\n", "authors": ["1383"]}