{"title": "Construction of abstract state graphs with PVS\n", "abstract": " In this paper, we propose a method for the automatic construction of an abstract state graph of an arbitrary system using the Pvs theorem prover.             Given a parallel composition of sequential processes and a partition of the state space induced by predicates \u03d5 1, ..., g4                  l                on the program variables which defines an abstract state space, we construct an abstract state graph, starting in the abstract initial state. The possible successors of a state are computed using the Pvs theorem prover by verifying for each index i if \u03d5 i or \u00ac\u03d5 i is a postcondition of it. This allows an abstract state space exploration for arbitrary programs.", "num_citations": "1925\n", "authors": ["1632"]}
{"title": "Validating timed UML models by simulation and verification\n", "abstract": " This paper presents a technique and a tool for model-checking operational (design level) UML models based on a mapping to a model of communicating extended timed automata. The target language of the mapping is the IF format, for which existing model-checking and simulation tools can be used.               Our approach takes into consideration most of the structural and behavioural features of UML, including object-oriented aspects. It handles the combination of operations, state machines, inheritance and polymorphism, with a particular semantic profile for communication and concurrency. We adopt a UML profile that includes extensions for expressing timing. The breadth of concepts covered by our mapping is an important point, as many previous approaches for applying formal validation to UML put much stronger limitations on the considered models.               For expressing properties about models, a\u00a0\u2026", "num_citations": "138\n", "authors": ["1632"]}
{"title": "A real-time profile for UML\n", "abstract": " This paper describes an approach for real-time modelling in UML, focusing on analysis and verification of time and scheduling-related properties. To this aim, a concrete UML profile, called the \u03c9profile, is defined, dedicated to real-time modelling by identifying a set of relevant concepts for real-time modelling which can be considered as a refinement of the standard SPT profile. The profile is based on a rich concept of event representing an instant of state change, and allows the expression of duration constraints between occurrences of events. These constraints can be provided in the form of OCL-like expressions annotating the specification or by means of state machines, stereotyped as \u2018observers\u2019. A framework for modelling scheduling issues is obtained by adding a notion of resource and a notion of execution time. For proving the relevance of these choices, the profile has been implemented in a\u00a0\u2026", "num_citations": "81\n", "authors": ["1632"]}
{"title": "A tool for symbolic program verification and abstraction\n", "abstract": " We give the description of a verification tool taking boolean programs of guarded commands as input; internal representation of programs are sets of Binary Decision Diagrams (BDD) (one for each guarded command). It allows to construct an abstract program of the same form obtained using an abstraction relation given by a boolean expression on \u201cconcrete\u201d' and \u201cabstract\u201d variables. The tool allows the verification of CTL formulas on programs. We illustrate its possibilities on an example.", "num_citations": "81\n", "authors": ["1632"]}
{"title": "Verification of a distributed cache memory by using abstractions\n", "abstract": " The purpose of this paper is to verify a distributed cache memory system by using the following general verification method: verify the properties characterizing a complex system on some small finite abstraction of it, obtained as a composition of abstractions of each component of the system. For a large class of systems including infinite state systems, the abstractions of the components can be obtained by replacing all operators on concrete domains by abstract operators on some abstract domain. This holds also for the abstraction of the control part of the system as we consider a kind of guarded command programs where all the control is expressed in terms of operations on explicit control variables.", "num_citations": "75\n", "authors": ["1632"]}
{"title": "Contract-based verification of hierarchical systems of components\n", "abstract": " In this paper, we add to the usual notion of contract a structural part specifying the composition operator used to compose the component and its environment. We provide a framework for compositional verification including a proof rule for dominance between contracts based on apparent circular reasoning. We also briefly describe a consistency condition and a method based on assumption generation to generate or refine contracts.", "num_citations": "71\n", "authors": ["1632"]}
{"title": "Verifying invariants using theorem proving\n", "abstract": " Our goal is to use a theorem prover in order to verify invariance properties of distributed systems in a \u201cmodel checking like\u201d manner. A system S is described by a set of sequential components, each one given by a transition relation and a predicate Init defining the set of initial states. In order to verify that P is an invariant of S, we try to compute, in a model checking like manner, the weakest predicate P\u2032 stronger than P and weaker than Init which is an inductive invariant, that is, whenever P\u2032 is true in some state, then P\u2032 remains true after the execution of any possible transition. The fact that P is an invariant can be expressed by a set of predicates (having no more quantifiers than P) on the set of program variables, one for every possible transition of the system. In order to prove these predicates, we use either automatic or assisted theorem proving depending on their nature.             We show in this paper how\u00a0\u2026", "num_citations": "63\n", "authors": ["1632"]}
{"title": "Validation of UML models via a mapping to communicating extended timed automata\n", "abstract": " We present a technique and a tool for model-checking operational UML models based on a mapping of object oriented UML models into a framework of communicating extended timed automata \u2013 in the IF format \u2013 and the use of the existing model-checking and simulation tools for this format.               We take into account most of the structural and behavioral characteristics of classes and their interplay and tackle issues like the combination of operations, state machines, inheritance and polymorphism, with a particular semantic profile for communication and concurrency. The UML dialect considered here, also includes a set of extensions for expressing timing.               Our approach is implemented by a tool importing UML models via an XMI repository, and thus supporting several commercial and non-commercial UML editors. For user friendly interactive simulation, an interface has been built, presenting\u00a0\u2026", "num_citations": "62\n", "authors": ["1632"]}
{"title": "Characterization of a sequentially consistent memory and verification of a cache memory by abstraction\n", "abstract": " The contribution of the paper is two-fold. We give a set of properties expressible as temporal logic formulas such that any system satisfying them is a sequentially consistent memory, and which is sufficiently precise such that every reasonable concrete system that implements a sequentially consistent memory satisfies these properties. Then, we verify these properties on a distributed cache memory system by means of a verification method, based on the use of abstract interpretation which has been presented in previous papers and so far applied to finite state systems. The motivation for this paper was to show that it can also be successfully applied to systems with an infinite state space. This is a revised and extended version of [GrA94].", "num_citations": "46\n", "authors": ["1632"]}
{"title": "Timed annotations in UML\n", "abstract": " In this paper we describe an approach for real-time modeling in UML focusing on analysis and verification of time and scheduling related properties. We show that the use of timed events, representing instant of state changes, provides the right level of abstraction for reasoning about timed computations. This is also, at notation level, the choice of the OMG UML Real-Time Profile. We complete this profile by identifying important events and duration expressions. One originality of the approach presented here, is that it provides a formal semantics of the time related primitives in terms of timed automata with urgency. An interesting point is that this time extension is independent of the dynamic semantics of the functional part.", "num_citations": "45\n", "authors": ["1632"]}
{"title": "Metamodels in Europe: Languages, tools, and applications\n", "abstract": " This article provides an overview of current efforts in Europe for using metamodeling in the integrated development of critical systems such as automotive electronics. It distinguishes between lightweight versus heavyweight approaches, surveys a number of related current European projects, and gives details about the Speeds project to illustrate the role of metamodeling-driven system engineering.", "num_citations": "43\n", "authors": ["1632"]}
{"title": "Contract-based reasoning for component systems with rich interactions\n", "abstract": " In this chapter we propose a rule unifying circular and non-circular assume-guarantee reasoning and show its interest for contract-based design and verification. Our work was motivated by the need to combine, in the top-down methodology of the FP7 SPEEDS project, partial tool chains for two component frameworks derived from the HRC model and using different refinement relations. While the L0 framework is based on a simple trace-based representation of behaviors and uses set operations for defining refinement, the more elaborated L1 framework offers the possibility to build systems of components with complex interactions. Our approach in L1 is based on circular reasoning and results in a method for checking contract dominance which does not require the explicit composition of contracts. In order to formally relate results obtained in L0 and L1, we provide a definition of the minimal concepts\u00a0\u2026", "num_citations": "34\n", "authors": ["1632"]}
{"title": "What are the limits of model checking methods for the verification of real life protocols?\n", "abstract": " Model checking is a well known method to carry out formal verification of distributed systems. This method needs a model representing the behaviour of the system to be verified. The size of this model depends on the complexity of the system. To be able to verify real life systems, it is necessary to use techniques allowing to take advantage of all the available storage space, to reduce the amount of information needed for the verification and to speed up computation time. But the expressiveness of the languages used to describe the system and its expected behaviours (properties) limit the possible reductions. We present in this paper our choices for an automatic verification tool by using model checking. The preliminary results obtained from its use for the verification of a real life protocol allow us to make some estimations about the limits of model checking methods.", "num_citations": "34\n", "authors": ["1632"]}
{"title": "Verification experiments on the MASCARA protocol\n", "abstract": " In this paper, we describe a case study on the verification of a real industrial protocol for wireless atm, called mascara. Several tools have been used: sdl has been chosen as the specification language and the commercial tool Objectgeode has been used for creating and maintaining sdl descriptions. The if tool-set has been used for generation, minimization and comparison of system models and verification of expected properties. All specification and verification tools are connected via the if language, which has been defined as an intermediate representation for timed asynchronous systems as well as an open validation environment. Due to the complexity of the protocol, static analysis techniques, such as live variable analysis and program slicing, were the key to the success of this case study. The results obtained give some hints concerning a methodology for the formal verification of real systems.", "num_citations": "33\n", "authors": ["1632"]}
{"title": "Contracts for BIP: Hierarchical interaction models for compositional verification\n", "abstract": " This paper presents an extension of the BIP component framework to hierarchical components by considering also port sets of atomic components to be structured (ports may be in conflict or ordered, where a larger port represents an interaction set with larger interactions). A composed component consisting of a set of components connected through BIP connectors and a set of ports representing a subset of the internal connectors and ports, has two semantics: one in terms if interactions as defined by the BIP semantics, and one in terms of the actions represented by external ports where the structure of the port set of the component is derived from the internal structure of the component.               A second extension consists in the addition of implicit interactions which is done through an explicit distinction of conflicting and concurrent ports: interactions involving only non conflicting ports can be executed\u00a0\u2026", "num_citations": "32\n", "authors": ["1632"]}
{"title": "Correct development of embedded systems\n", "abstract": " This paper provides an overview on the approach of the Ist Omega project for the development of correct software for embedded systems based on the use of UML as modelling language. The main contributions of the project are the definition of a useful subset of UML and some extensions, a formal dynamic semantics integrating all notations and a tool set for the validation of models based on this semantics.", "num_citations": "29\n", "authors": ["1632"]}
{"title": "Achieving distributed control through model checking\n", "abstract": " We apply model checking of knowledge properties to the design of distributed controllers that enforce global constraints on concurrent systems. We calculate when processes can decide, autonomously, to take or block an action so that the global constraint will not be violated. When the separate processes cannot make this decision alone, it may be possible to temporarily coordinate several processes in order to achieve sufficient knowledge jointly and make combined decisions. Since the overhead induced by such coordinations is important, we strive to minimize their number, again using model checking. We show how this framework is applied to the design of controllers that guarantee a priority policy among transitions.", "num_citations": "28\n", "authors": ["1632"]}
{"title": "Building distributed controllers for systems with priorities\n", "abstract": " Composition of components by means of multi-party synchronizations and priorities allows specifying properties of systems in a very abstract manner, and are meaningful for many application domains. Such specifications are generally easier to verify than the more concrete ones based on message passing. Synchronizations may introduce deadlocks, whereas priorities do not. In this paper, we propose two algorithms: one which given a specification Sys constructs\u2014if necessary and if possible\u2014a set of priority rules enforcing deadlock freedom. A second algorithm builds a distributed implementation of such a prioritized specification. This second algorithm is presently restricted to binary synchronizations but it differs from comparable algorithms such as \u03b1-core (1) by the fact that it handles specifications with (global) priorities. We have implemented this algorithm and compared its efficiency with \u03b1-core in the\u00a0\u2026", "num_citations": "24\n", "authors": ["1632"]}
{"title": "Time in state machines\n", "abstract": " State machines are a very general means to express computations in an implementationindependent way. There are ways to extend the abstract state machine (ASM) framework with distribution aspects, but there is no unifying framework for handling time so far.", "num_citations": "23\n", "authors": ["1632"]}
{"title": "A real-time profile for UML and how to adapt it to SDL\n", "abstract": " This paper presents work of the IST project OMEGA, where we have defined a UML profile for real-time that is compatible with the Profile for Performance, Scheduling and Real-time recently accepted at OMG. In contrast to this OMG profile, we put emphasis on semantics and on its use in the context of timed analysis of real-time embedded systems. The defined profile is compatible with the time concepts existing in SDL, and we show how we can also adapt these notations to SDL and MSC, which do not yet have a notation for this purpose.", "num_citations": "22\n", "authors": ["1632"]}
{"title": "Expression of time and duration constraints in SDL\n", "abstract": " In this paper we give an overview on a set of time related features, useful in the context of real-time system design and classify them into two categories, those needed for modelling of non functional aspects and analysis, and those needed for functional design. We allow the distinction between functional and non functional timing aspects of a specification. We show how these features are represented at the semantic level with a minimal number of primitives.", "num_citations": "22\n", "authors": ["1632"]}
{"title": "Modeling and validation of a software architecture for the Ariane-5 launcher\n", "abstract": " We present the modeling and validation experiments performed with the IFx validation toolset and with the UML profile developed within the IST Omega project, on a representative space vehicle control system: a model of the Ariane-5 flight software obtained by manual reverse engineering. The goal of the study is to verify functional and scheduling-related requirements under different task architecture assumptions. The study is also a proof of concept for the UML-based validation technique proposed in IFx.", "num_citations": "21\n", "authors": ["1632"]}
{"title": "OMEGA: correct development of real time and embedded systems\n", "abstract": " Building embedded real time software systems of guaranteed quality, in a cost-effective manner, is an important technological challenge. Component-based design leads to a need for a new architecture-based software engineering practice in which complex systems are built by composing available components with known properties and evaluating the impact of local design choices on their global behaviour. This requires new tool support for their development. The aim of the Omega project1 was to contribute to this new development paradigm by providing a framework for model-based development of real-time and embedded systems. It should enable a consistent use of models by advanced analysis tools on one hand and commercial code generators on the other. The project has obtained a number of interesting results concerning the following three main work directions.", "num_citations": "19\n", "authors": ["1632"]}
{"title": "Reasoning about safety and progress using contracts\n", "abstract": " Designing concurrent or distributed systems with complex architectures while preserving a set of high-level requirements through all design steps is not a trivial task. Building upon a generic notion of contract                 framework which relies on a component                 framework and two refinement relations: conformance and refinement                 under                 context, we provide a condition under which circular reasoning can be used for checking dominance, i.e. refinement between contracts. We then propose an instantiation of such a contract framework for safety and progress requirements in component systems with data exchange. This allows us to prove non-trivial properties of a protocol for tree-like networks.", "num_citations": "17\n", "authors": ["1632"]}
{"title": "Abstraction as the key for invariant verification\n", "abstract": " We present a methodology for constructing abstractions and refining them by analyzing counter-examples. We also present a uniform verification method that combines abstraction, model-checking and deductive verification. In particular, it shows how to use the abstract system in a deductive proof even when the abstract model does not satisfy the specification and when it simulates the concrete system with respect to a weaker notion of simulation than Milner\u2019s.", "num_citations": "17\n", "authors": ["1632"]}
{"title": "Logique du temps arborescent pour la sp\u00e9cification et la preuve de programmes\n", "abstract": " Nous \u00e9tudions les logiques du temps arborescent en tant qu'outils de sp\u00e9cification et de preuve des programmes. Les diff\u00e9rentes logiques modales et temporelles sont compar\u00e9es par rapport aux deux crit\u00e8res suivantes: puissance d'expression et d\u00e9cidabilit\u00e9. Cette \u00e9tude porte essentiellement sur fa comparaison des logiques du temps arborescent et des logiques du temps lin\u00e9aire. Ensuite, le probl\u00e8me de l'utilisation des logiques du temps arborescent en tant qu'outils de preuves des programmes est \u00e9tudi\u00e9. Nous proposons une logique pour la preuve constructive des propri\u00e9t\u00e9s des processus contr\u00f4lables de CCS. Cette logique est telle, que la relation de congruence induite est la congruence observationnelle de CCS", "num_citations": "14\n", "authors": ["1632"]}
{"title": "Program verification using compositional abstraction\n", "abstract": " {In this paper we describe a method for the obtention of the minimal transition system, representing a communicating system given by a set of parallel processes, avoiding the complexity of the non minimal transition system. We consider minimization with respect to observational equivalence, but the method may be adapted to any other equivalence. An interesting method to achieve this goal is to proceed by stepwise composition and minimization of the components of the system. However, if no precautions are taken, the intermediate state graphs generated by this method may contain a lot of transitions which are impossible in the whole context. We give here a variant of this method which allows to avoid these impossible transitions by taking into account at each composition step a guess of the interface behaviour of the context. This``interface specification''must be provided by the user. The method is based on a\u00a0\u2026", "num_citations": "13\n", "authors": ["1632"]}
{"title": "Achieving distributed control through model checking\n", "abstract": " We apply model checking of knowledge properties to the design of distributed controllers that enforce global constraints on concurrent systems. The problem of synthesizing a distributed controller is undecidable in the general case. We thus look at a variant of the synthesis problem that allows adding temporary synchronizations between processes. We calculate when processes can decide autonomously, based on their knowledge, whether to take or block an action so that the global constraint is not violated. The local knowledge of processes may not suffice to control the processes so as to achieve the global constraint without introducing new deadlocks. When individual processes cannot take a decision alone based on their knowledge, one may coordinate several processes to achieve joint knowledge in order to take joint decisions. A fixed coordination among sets of processes may severely degrade\u00a0\u2026", "num_citations": "12\n", "authors": ["1632"]}
{"title": "How useful is the UML realtime profile SPT without semantics?\n", "abstract": " {In this position paper we argue that the present practise in UML, consisting in standardising notations only at the level of abstract syntax (meta-model) is in particular in the context of real-time embedded systems, and thus the SPT profile, hindering the usefulness of the standard. A standard should make possible exchange of (parts of) models, and this is clearly not the case today. We argue that the real-time profile that we have defined in the context of the OMEGA project, can provide a basis for the semantic definition of any real-time profile. Also, the translation of the operational part of UML into IF, based on the use of priorities, can be mimicked for providing a means to define any particular execution semantics in UML.},", "num_citations": "12\n", "authors": ["1632"]}
{"title": "Formal specification and verification of a network independent atomic multicast protocol.\n", "abstract": " Research on formal description techniques during the last years has revealed new trends on the description of distributed systems. Nevertheless, the application of these techniques to real and complex systems is not straightforward and there are not many case studies in this area. This paper presents an experience in protocol building area, by involving a close interaction between protocol design and formal verification, and shows off its application in the design of a real distributed system: a network independent atomic multicast protocol.", "num_citations": "12\n", "authors": ["1632"]}
{"title": "Monitoring distributed systems using knowledge\n", "abstract": " In this paper, we use knowledge-based control theory to monitor global properties in a distributed system. We control the system to enforce that if a given global property is violated, at least one process knows this fact, and therefore may report it. Our approach uses knowledge properties that are precalculated based on model checking. As local knowledge is not always sufficient to monitor a global property in a concurrent system, we allow adding temporary synchronizations between two or more processes to achieve sufficient knowledge. Since synchronizations are expensive, we aim at minimizing their number using the knowledge analysis.", "num_citations": "11\n", "authors": ["1632"]}
{"title": "From orchestration to choreography: Memoryless and distributed orchestrators\n", "abstract": " In the context of Web services, making client and service interact so as to satisfy the client, that is, making the service compliant with the client, can be done using either orchestration or choreography. In this paper we propose to build, whenever possible, memoryless orchestrators, and then distribute them using protocols so as to obtain choreographies. When necessary for guaranteeing compliance, we infer from the initial (sequential) transition system possible concurrency between certain interactions, whose validity must be checked by the designer. Our approach allows for a clear distinction between the design phase and the implementation phase while being, in the general case, more efficient than orchestration. An example dealing with resource management illustrates the usefulness of memoryless orchestrators. We also discuss a methodology allowing contract-based design and verification of Web services at a higher level of abstraction.", "num_citations": "11\n", "authors": ["1632"]}
{"title": "Modeling and analysis of real-time and embedded systems\n", "abstract": " This paper presents an overview of the workshop MARTES on Modeling and Analysis of Real-time and Embedded Systems that has taken place for the first time in association with the MODELS/UML 2005 conference. The main themes discussed at this workshop concerned (1) methodologies and tools for quantitative analysis and (2) methodologies and languages for modeling quantitative aspects of real-time and embedded systems in the context of model driven development.", "num_citations": "11\n", "authors": ["1632"]}
{"title": "Property preserving abstractions under parallel composition\n", "abstract": " We study property preserving transformations for reactive systems. A key idea is the use of \u03f1-simulations which are simulations parametrized by a relation \u03f1, relating the domains of two systems. We particularly address the problem of property preserving abstractions of composed programs. For a very general notion of parallel composition, we give the conditions under which simulation is a precongruence for parallel composition and we study which kind of global properties are preserved by these abstractions.", "num_citations": "11\n", "authors": ["1632"]}
{"title": "Formal Methods for Components and Objects: Third International Symposium, FMCO 2004, Leiden, The Netherlands, November 2-5, 2004, Revised Lectures\n", "abstract": " Large and complex software systems provide the necessary infrastructure in all industries today. In order to construct such large systems in a systematic manner, the focus in the development methodologies has switched in the last two decades from functional issues to structural issues: both data and functions are encapsulated into software units which are integrated into large systems by means of various techniques supporting reusability and modifiability. This encapsulation principle is essential to both the object-oriented and the more recent componentbased software engineering paradigms.Formal methods have been applied successfully to the verification of mediumsized programs in protocol and hardware design. However, their application to the development of large systems requires more emphasis on specification, modelling and validation techniques supporting the concepts of reusability and modifiability\u00a0\u2026", "num_citations": "10\n", "authors": ["1632"]}
{"title": "Building correct cyber-physical systems: why we need a multiview contract theory\n", "abstract": " The design and verification of critical cyber-physical systems is based on a number of models (and corresponding analysis techniques and tools) representing different viewpoints such as function, timing, security and many more. Overall correctness is guaranteed by mostly informal, and therefore basic, arguments about the relationship between these viewpoint-specific models. We believe that a more flexible contract-based approach could lead to easier integration, to relaxed assumptions, and consequently to more cost efficient systems while preserving the current modelling approach and its tools.", "num_citations": "8\n", "authors": ["1632"]}
{"title": "Timing analysis and validation with UML: the case of the embedded MARS bus manager\n", "abstract": " This paper presents a case study in UML-based modeling and validation of the intricate timing aspects arising in a small but complex component of the airborne Medium-Altitude Reconnaissance System produced by the Netherlands National Aerospace Laboratory. The purpose is to show how automata-based timing analysis and verification tools can be used by field engineers for solving isolated hard points in a complex real-time design, even if the press-button verification of entire systems remains a remote goal. We claim that the accessibility of such tools is largely improved by the use of an UML profile with intuitive features for modeling timing and related properties.", "num_citations": "8\n", "authors": ["1632"]}
{"title": "How useful is the UML profile SPT without Semantics?\n", "abstract": " Thus, the SPT is defined to offer a common framework for real-time modeling that unifies the diversity of techniques, terminologies and notations existing in the real-time software community, while still leaving space for different kinds of specifications. In its present form, the main focus of SPT is on time and time-related concepts: performance, timelines, schedulability, etc, where for example with respect to schedulability mainly the existing standards theories (RMA) are covered.To answer these goals, the SPT offers a terminology for modeling real-time systems: it defines a set of concepts-aiming to fit standard real-time modeling techniques-and some relationships between these concepts as allowed by the meta-modeling technique used for the definition of the SPT. Clearly, these meta-modeling techniques can carry only very superficial semantic information. At a first sight this may be argued by its aim to address the needs of various real-time modeling techniques. However, a closer look to the SPT definition itself shows that such a definition is insufficient, in particular for promoting common understanding of specification and exchange of specifications between different tools, which is, at least for a large number of users, an important motivation for switching from proprietary formalisms and tools to standards, like UML.", "num_citations": "7\n", "authors": ["1632"]}
{"title": "A complete inference system for an algebra of regular acceptance models\n", "abstract": " This paper deals with regular acceptance models, a variant of readiness models [01], possible future models [RB] and acceptance trees [He]. These models are used as a semantic domain for Theoretical CSP [BHR]. In a previous paper [GS2] we presented a complete axiomattzation of an algebra for finite acceptance models. We extend these results for recursively defined acceptance models. The proofs which are not given here, can be found in [Gr].We consider a term language AT containing the sublanguage of TCSP constructed from the constants Stop and T (-Chaos in TCSP) by a set A of unary\" action\" operators, binary operators+(F1 in TCSP) and vCn in TCSP) and guarded recursion. Stop represents the process performing no action forever and T is the completely undefined process.+ and v are operators of external and internal nondeterministic choice.", "num_citations": "7\n", "authors": ["1632"]}
{"title": "A model transformation tool for performance simulation of complex uml models\n", "abstract": " We present a tool that automatically translates UML2 models of service-oriented systems to models for performance evaluation by a commercial simulator. The strength of our tool lies in its support for complex behaviors, which is made possible by a rich intermediate metamodel with clear operational semantics.", "num_citations": "6\n", "authors": ["1632"]}
{"title": "Using an UML profile for timing analysis with the IF validation tool-set.\n", "abstract": " This paper shows on hand of a case study the usefulness of the UML profile with realtime defined in the Omega project and of the IF validation tool-set. The case study is about intricate timing aspects arising in a small but complex component of the airborne Medium Altitude Reconaissance System produced by NLR 1. The purpose is to show how automata-based timing analysis and verification tools can be used by field engineers for solving isolated hard points in a complex real-time design, even if the press-button verification of entire systems remains a remote goal. We claim that the accessibility of such tools is largely improved by the use of a UML profile with intuitive features for modeling timing and related properties.", "num_citations": "6\n", "authors": ["1632"]}
{"title": "Projet Omega: Un profil UML et un outil pour la modelisation et la validation de systemes temps reel\n", "abstract": " Le d\u00e9veloppement de syst\u00e8mes temps r\u00e9el embarqu\u00e9s de qualit\u00e9 \u00e0 co\u00fbts ma\u00eetris\u00e9s repr\u00e9sente un d\u00e9fi technologique et industriel tr\u00e8s important. Dans certains secteurs industriels, tel que le transport, l\u2019a\u00e9ronautique, ou les t\u00e9l\u00e9communications, la tenue de ces objectifs qualit\u00e9/co\u00fbt impliquent l\u2019utilisation d\u2019outils et de techniques de validation et de v\u00e9rification formelles. Cela passe par l\u2019utilisation d\u2019une approche orient\u00e9e mod\u00e8le.Une des caract\u00e9ristiques de cette approche, est l\u2019utilisation de mod\u00e8les ex\u00e9cutables qui contiennent des informations sur les diff\u00e9rents aspects du syst\u00e8me: exigences fonctionnelles, architecture statique, exigences non fonctionnelles (en particulier temps r\u00e9el), etc. Pour que l\u2019utilisation de tels mod\u00e8les soit pertinente, le formalisme utilis\u00e9 doit \u00eatre suffisamment expressif, et son utilisation doit \u00eatre support\u00e9e, non seulement par des outils pour la g\u00e9n\u00e9ration de code, mais aussi par des outils de validation et de v\u00e9rification formelle au niveau du mod\u00e8le.", "num_citations": "6\n", "authors": ["1632"]}
{"title": "A framework for evaluating schedulability analysis tools\n", "abstract": " There exists a large variety of schedulability analysis tools based on different, often incomparable timing models. This variety makes it difficult to choose the best fit for analyzing a given real-time system. To help the research community to better evaluate analysis tools and their underlying methods, we are developing a framework which consists of (1) a simple language called RTSpec for specifying real-time systems, (2) a tool chain which translates a system specification in RTSpec into an input for various analysis tools, and (3) a set of benchmarks. Our goal is to enable users and developers of schedulability analysis tools to compare such tools systematically, automatically and rigorously.", "num_citations": "5\n", "authors": ["1632"]}
{"title": "A framework for contract-based reasoning: Motivation and application\n", "abstract": " Abstract In [13], we have introduced a framework for contract-based reasoning parametrized, among others, by a notion of behaviors and a notion of composition of such behaviors. Our aim is to separate clearly between properties of contracts that are speci c to a given framework and properties that apply to an entire class of contract-based veri cation frameworks. In particular, we think that soundness of (apparently) circular reasoning is a generic property that is essential when dealing with contracts. To support our claim, we discuss two particular instantiations of our framework that are adapted from [9] and [11]. We show that important results presented in these papers are direct consequences of the circular reasoning property of our framework. Proofs are thus shorter and, we believe, clearer. We also believe that such a methodology improves understanding of concepts. In particular, if circular reasoning is not sound in a given framework, there are two options: either not use it, or strengthen the de nition of re nement in a context so that in the modi ed framework circular reasoning is sound.", "num_citations": "5\n", "authors": ["1632"]}
{"title": "RTLib: A library of timed automata for modeling real-time systems\n", "abstract": " There exists a large variety of schedulability analysis tools based on different, often incomparable timing analysis models. This variety makes it difficult to choose the best fit for analyzing a given real-time system. We have developed RTLib, a library of timed automata templates that represent the semantics of a large variety of timing related concepts proposed by existing models and corresponding timing analysis tools. The key specificity of RTLib is that it is structured to be modular, such that (1) defining a new variant of a given concept requires only a localized change, and (2) non contradictory variants can be trivially combined. The extensibility of RTLib is demonstrated using five examples ranging from simple variants of the task activation model to the more complex mixed-criticality paradigm. RTLib provides the formal basis needed to compare the concepts offered by models of different timing analysis tools at the semantic level. This in turn will allow us to provide a syntactic mapping between the input of different tools. Our final goal is to help the research community to better evaluate analysis models and their underlying methods.", "num_citations": "4\n", "authors": ["1632"]}
{"title": "Model-based design and distributed implementation of bus arbiter for multiprocessors\n", "abstract": " The contribution of this paper is twofold. First we propose a high-level distributed and abstract model of the bus arbiter for multiprocessors. Our model provides a way for describing several existing arbitration protocols in a distributed and abstract manner so that their properties and performance could be easily compared and analyzed. Second, we propose to automatically verify deadlock freedom property of these protocols and to automatically generate their distributed implementation.", "num_citations": "4\n", "authors": ["1632"]}
{"title": "A Contract Framework for Reasoning\n", "abstract": " Designing concurrent or distributed systems with complex architectures while preserving a set of highlevel requirements through all design steps is not a trivial task. An approach which is both compositional and incremental is mandatory to master this complexity. We propose here a contract-based design and verification framework for safety and progress requirements in component systems with data exchange. We build upon a notion of contract framework which relies on a component algebra and two refinement relations: conformance and refinement under context. We provide a condition under which circular reasoning can be used for checking dominance, ie refinement between contracts. We illustrate our verification methodology with a case study: a protocol for tree-like networks for which both safety and progress must be ensured.", "num_citations": "4\n", "authors": ["1632"]}
{"title": "Modelling and analysis of real time and embedded systems\u2013Using UML\n", "abstract": " This paper presents an overview on the outcomes of the workshop MARTES on Modelling and Analysis of Real Time and Embedded Systems that has taken place for the second time in association with the MoDELS/UML 2006 conference. Important themes discussed at this workshop concerned (1) tools for analysis and model transformation and (2) concepts for modelling quantitative aspects with the perspective of analysis.", "num_citations": "4\n", "authors": ["1632"]}
{"title": "Validation\n", "abstract": " Validation - Archive ouverte HAL Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-01982593, version 1 Chapitre d'ouvrage Validation Karama Kanoun 1 Jean Arlat 1 L. Burrill 2 Yves Crouzet 1 Susanne Graf 3 Eliane Martins 4 David Powell 1 D\u00e9tails 1 LAAS-TSF - \u00c9quipe Tol\u00e9rance aux fautes et S\u00fbret\u00e9 de Fonctionnement informatique LAAS - Laboratoire d'analyse et d'architecture des syst\u00e8mes 2 SRD-AEG Technology 3 VERIMAG - IMAG - VERIMAG 4 UNICAMP - Institute of Computing [Campinas] \u2026", "num_citations": "4\n", "authors": ["1632"]}
{"title": "Construction of abstract state graphs of infinite systems with PVS\n", "abstract": " In this paper, we propose a method for the automatic construction of an abstract state graph of an in nite state system using the Pvs theorem prover. Given a system and a partition of the state space induced by predicates'1;:::;'on the program variables which de nes an abstract state space, we construct an abstract state graph, starting in the abstract initial state. The possible successors of a state are computed using the Pvs theorem prover by verifying for each index i if'i or:'i is a postcondition of it. This allows an abstract state space exploration for arbitrary systems.", "num_citations": "4\n", "authors": ["1632"]}
{"title": "Knowledge for the distributed implementation of constrained systems\n", "abstract": " Deriving distributed implementations from global specifications has been extensively studied for different application domains, under different assumptions and constraints. We explore here the knowledge perspective: a process decides to take a local action when it has the knowledge to do so. We discuss typical knowledge atoms that are useful for expressing local enabling conditions with respect to different notions of correctness, as well as different means for obtaining knowledge and for representing it locally in an efficient manner. Our goal is to use such a knowledge-based representation of the distribution problem for either deriving distributed implementations automatically from global specifications on which some constraint is enforced, or for improving the efficiency of existing protocols by exploiting local knowledge. We also argue that such a knowledge-based presentation helps achieving the\u00a0\u2026", "num_citations": "3\n", "authors": ["1632"]}
{"title": "Implementing distributed controllers for systems with priorities\n", "abstract": " Implementing a component-based system in a distributed way so that it ensures some global constraints is a challenging problem. We consider here abstract specifications consisting of a composition of components and a controller given in the form of a set of interactions and a priority order amongst them. In the context of distributed systems, such a controller must be executed in a distributed fashion while still respecting the global constraints imposed by interactions and priorities. We present in this paper an implementation of an algorithm that allows a distributed execution of systems with (binary) interactions and priorities. We also present a comprehensive simulation analysis that shows how sensitive to changes our algorithm is, in particular changes related to the degree of conflict in the system.", "num_citations": "3\n", "authors": ["1632"]}
{"title": "Qualification d'architectures fonctionnelles: D\u00e9marche et formalismes pour la sp\u00e9cification et la qualification d'architectures fonctionnelles r\u00e9parties\n", "abstract": " Qualification d'architectures fonctionnelles: D\u00e9marche et formalismes pour la sp\u00e9cification et la qualification d'architectures fonctionnelles r\u00e9parties - Universit\u00e9 Grenoble Alpes Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support Portail HAL de l'Universit\u00e9 Grenoble Alpes HAL archives-ouvertes.fr Accueil Rechercher D\u00e9poser Consulter Services hal-00375706, version 1 Communication dans un congr\u00e8s Qualification d'architectures fonctionnelles: D\u00e9marche et formalismes pour la sp\u00e9cification et la qualification d'architectures fonctionnelles r\u00e9parties Marius Bozga 1 Pierre Combes 2 Susanne Graf 1 Wei Monin 2 Nicolas Moteau 2 D\u00e9tails 1 VERIMAG - IMAG [1993-2015] - VERIMAG [1993-2015] 2 FT R&D \u2026", "num_citations": "3\n", "authors": ["1632"]}
{"title": "Timing analysis and validation of the embedded MARS bus manager\n", "abstract": " This paper presents a case study in UML-based modelling and validation of the intricate timing aspects arising in a small but complex component of the airborne Medium Altitude Reconaissance System produced by NLR 1. The purpose is to show how automata-based timing analysis and verification tools can be used by field engineers for solving isolated hard points in a complex real-time design, even if the press-button verification of entire systems remains a remote goal. We claim that the accessibility of such tools is largely improved by the use of a UML profile with intuitive features for modeling timing and related properties.", "num_citations": "3\n", "authors": ["1632"]}
{"title": "Knowledge-based construction of distributed constrained systems\n", "abstract": " The problem of deriving distributed implementations from global specifications has been extensively studied for a number of application domains. We explore it here from the knowledge perspective: A process may decide to take a local action when it has enough knowledge to do so. Such knowledge may be acquired by communication through primitives available on the platform or by static analysis. In this paper, we want to combine control and distribution, that is, we need to impose some global control constraint on a system executed in a distributed fashion. To reach that goal, we compare two approaches: either build a centralized controlled system, distribute its controller and then implement this controlled system on a distributed platform; or alternatively, directly enforce the control constraint while implementing the distributed system on the platform. We show how to achieve a solution following the\u00a0\u2026", "num_citations": "2\n", "authors": ["1632"]}
{"title": "Distributed implementation of systems with multiparty interactions and priorities\n", "abstract": " Rich interaction models are a powerful mechanism allowing to synchronize several entities in order to achieve some common goal and to specify global properties in an abstract manner. In this paper we focus on two types of interaction models, namely multiparty interactions and priorities where priorities may be used to specify different scheduling policies. We propose a protocol for building distributed implementation of component-based models with multiparty interactions and priorities. We also present a set of experiments providing a performance analysis of the protocol.", "num_citations": "2\n", "authors": ["1632"]}
{"title": "From complex UML models to systematic performance simulation\n", "abstract": " The creation and deployment of a service by a telecommunication operator is a complex activity where functional correctness and performance issues are equally critical. We thus promote a methodology that associates rigorous system definition and performance analysis throughout the entire design process, based on the guaranteed availability of analysis models. In this paper, we report how we applied a Model-Driven Engineering approach to build a tool that supports the methodology. The tool provides automatic and systematic transformations of UML 2 design models of a high degree of complexity to performance models for an industrial simulator. We stress in particular how attempting to build a reliable MDE process required careful design decisions and a thorough preliminary study of syntactic and semantic concerns.", "num_citations": "2\n", "authors": ["1632"]}
{"title": "Verification of UML models with timing contraints using IF\n", "abstract": " Verification of UML models with timing constraints using IF Page 1 1 ARTIST summerschool, N\u00e4sslingen, 30-09-2005 Verification of UML models with timing constraints using IF Susanne Graf Verimag http://www-if.imag.fr/ http://www-omega.imag.fr/ http://www-verimag.imag.fr/~graf/Artist-summerschool/ Page 2 2 ARTIST summerschool, N\u00e4sslingen, 30-09-2005 IST OMEGA: validation in the context of modelbased development of real-time systems Model (UML/ XMI) Behaviour Time platform Running implementation feedback Test Semantic models Validation tools System Requirements \u2565 update Environment System Requirements/ assumptions UML CASE tools feedback Page 3 3 ARTIST summerschool, N\u00e4sslingen, 30-09-2005 The IF toolbox: approach High-level programming and modeling notations (SDL, UML, SCADE, Java \u2026) Low-level semantics: transition systems simulation test verification1 verification2 \u2026", "num_citations": "2\n", "authors": ["1632"]}
{"title": "A framework for time in FDTs\n", "abstract": " ASM is recognized as a useful formalism for defining the semantics of programming languages and modeling formalisms, but it has not initially been intended for expressing non functional properties. Also, during the work with the SDL formal semantics, problems of expression of time progress occurred at several places. Several proposals for timed ASM based on quite different approaches have been made. On the other hand, there exist a number of frameworks for modeling timed computations outside the world of ASM. It seems useful to try to elaborate a common understanding of time in ASM. We propose a general time model based on timed events, where time passes only in states, to which the existing frameworks can be reduced. Furthermore, we provide a number of options for defining useful time frameworks and discuss some of their consequences. We use this framework to give an overview on a number of approaches on modeling time in and outside the context of ASM. As ASM are a very general framework for specifying state-transition systems, our approach is valid for state-transition systems in general.", "num_citations": "2\n", "authors": ["1632"]}
{"title": "Distributed implementation of constrained systems based on knowledge\n", "abstract": " Building correct distributed systems is challenging, and any attempt for providing a direct, global proof of correctness of a distributed system is bound to fail. An interesting alternative approach consists in starting from a specification or program of the system under construction, verifying all properties of interest on it - which has a much lower complexity than the verification on a distributed implementation - and finally derive a distributed implementation using some correct by-construction approach. Note that this topic is related to distributed control, where the objective is to enforce in a distributed manner some global constraint on a plant. Deriving such a distributed controller directly is difficult, and the correctness of the resulting controller is difficult to prove. A more feasible approach in this context is to first construct a global controller, then transform it into distributed one, again by means of a correct-by-construction\u00a0\u2026", "num_citations": "1\n", "authors": ["1632"]}
{"title": "Pr\u00e9sentation des r\u00e9sultats du projet OpenEmbeDD\n", "abstract": " OpenEmbeDD est une plate-forme g\u00e9n\u00e9rique, reposant sur les technologies d'Ing\u00e9nierie Dirig\u00e9e par les Mod\u00e8les (IDM), et int\u00e9grant des outils d'aide \u00e0 la conception d'applications temps r\u00e9el embarqu\u00e9 (TR/E). Les technologies d'IDM utilis\u00e9es dans OpenEmbeDD sont bas\u00e9es sur l'environnement Eclipse. Elles fournissent une solution simple et efficace pour l'int\u00e9gration d'outils TR/E sur la plateforme (par la r\u00e9alisation d'un modeleur) et l'interop\u00e9ration de ses outils (par transformation de mod\u00e8le). OpenEmbeDD peut \u00eatre instanci\u00e9e \u00e0 un domaine d'application pr\u00e9cis en s\u00e9lectionnant, parmi l'ensemble des outils disponibles, ceux qui r\u00e9pondent \u00e0 un cas d'utilisation particulier. La plate-forme OpenEmbeDD s'installe en quelques clics. Elle fournit alors une solution d'IDM compl\u00e8te pour mettre en oeuvre rapidement un modeleur et l'int\u00e9grer facilement \u00e0 une suite d'outils. Pour cela, OpenEmbeDD repose sur le format EMF/Ecore afin de faciliter la manipulation de mod\u00e8les, int\u00e8gre le g\u00e9n\u00e9rateur d'\u00e9diteurs graphiques Topcased, le langage de transformation ATL, l'environnement de m\u00e9ta-mod\u00e9lisation Kermeta, l'\u00e9diteur de profils Papyrus. Sa conformit\u00e9 aux standards industriels les plus r\u00e9pandus est un avantage important. OpenEmbeDD int\u00e8gre un modeleur UML complet accompagn\u00e9 de la mise en oeuvre de r\u00e9f\u00e9rence du profil temps-r\u00e9el MARTE. OpenEmbeDD inclus \u00e9galement d'autres standards comme AADL, SysML ou SDL. La plate-forme OpenEmbeDD permet donc de compl\u00e9menter la mod\u00e9lisation d'applications utilisant des profils UML standards avec toute la souplesse et la sp\u00e9cificit\u00e9 d'outils m\u00e9tier d'aide \u00e0 la conception pour le TR/E, et ce\u00a0\u2026", "num_citations": "1\n", "authors": ["1632"]}
{"title": "Contract\u2010based System Design\u2010The SPEEDS Approach\n", "abstract": " \u2022 HRC\u2013Heterogeneous Rich components will form the foundations for the component based construction of complete virtual system models.\u2022 Its main objectives are:\u2013to develop a framework for multiple viewpoint (functional and non-functional) component engineering,\u2013to enable full-scale reuse of components,\u2013to define a semantic-based common meta-model that enables the multiple view point access to full component information (functional and non-functional)\u2013to secure concurrent design processes, while enabling the assessment of design maturity at any stage of the project using the concept of \u201ccontracts\u201d between components", "num_citations": "1\n", "authors": ["1632"]}
{"title": "SVERTS\u2013Specification and Validation of Real-Time and Embedded Systems\n", "abstract": " This paper presents an overview on the workshop on Specification and Validation of Real-time and embedded Systems that has taken place for the second time in association with the UML 2004 conference. The main themes discussed at this year\u2019s workshop concerned modeling of real-time features with the perspective of validation as well as some particular validation issues.", "num_citations": "1\n", "authors": ["1632"]}
{"title": "On Lamport's comparison between linear and branching time temporal logic\n", "abstract": " We consider the problem of the comparison between a temporal logic of linear time TLL and a temporal logic of branching time TLB, already studied by Lamport, for a more restricted class ofmodels. To this end, we define a common class ofmodelsfor the two logies which are the transition Systems. By adopting as criterion ofcomparison Lamporfs strong \u00e9quivalence, we obtain the incomparableness of the two logies considered, that means, in each one of the two logies there exists a formula which expresses a property, non-expressible in the other. From our proof of incomparableness we obtained a stronger result, stating that there exists no linear time logic more expressive than TLB.", "num_citations": "1\n", "authors": ["1632"]}