{"title": "seL4: from general purpose to a proof of information flow enforcement\n", "abstract": " In contrast to testing, mathematical reasoning and formal verification can show the absence of whole classes of security vulnerabilities. We present the, to our knowledge, first complete, formal, machine-checked verification of information flow security for the implementation of a general-purpose microkernel; namely seL4. Unlike previous proofs of information flow security for operating system kernels, ours applies to the actual 8, 830 lines of C code that implement seL4, and so rules out the possibility of invalidation by implementation errors in this code. We assume correctness of compiler, assembly code, hardware, and boot code. We prove everything else. This proof is strong evidence of seL4's utility as a separation kernel, and describes precisely how the general purpose kernel should be configured to enforce isolation and mandatory information flow control. We describe the information flow security statement we\u00a0\u2026", "num_citations": "230\n", "authors": ["666"]}
{"title": "Types, bytes, and separation logic\n", "abstract": " We present a formal model of memory that both captures the low-level features of C's pointers and memory, and that forms the basis for an expressive implementation of separation logic. At the low level, we do not commit common oversimplifications, but correctly deal with C's model of programming language values and the heap. At the level of separation logic, we are still able to reason abstractly and efficiently. We implement this framework in the theorem prover Isabelle/HOL and demonstrate it on two case studies. We show that the divide between detailed and abstract does not impose undue verification overhead, and that simple programs remain easy to verify. We also show that the framework is applicable to real, security-and safety-critical code by formally verifying the memory allocator of the L4 microkernel.", "num_citations": "227\n", "authors": ["666"]}
{"title": "Operating system verification\u2014an overview\n", "abstract": " This paper gives a high-level introduction to the topic of formal, interactive, machine-checked software verification in general, and the verification of operating systems code in particular. We survey the state of the art, the advantages and limitations of machine-checked code proofs, and describe two specific ongoing larger-scale verification projects in more detail.", "num_citations": "179\n", "authors": ["666"]}
{"title": "Translation validation for a verified OS kernel\n", "abstract": " We extend the existing formal verification of the seL4 operating system microkernel from 9500 lines of C source code to the binary level. We handle all functions that were part of the previous verification. Like the original verification, we currently omit the assembly routines and volatile accesses used to control system hardware.", "num_citations": "146\n", "authors": ["666"]}
{"title": "Towards trustworthy computing systems: taking microkernels to the next level\n", "abstract": " As computer systems become increasingly mission-critical, used in life-critical situations, and relied upon to protect intellectual property, operating-system reliability is becoming an ever growing concern. In the past, mission- and life-critical embedded systems consisted of simple microcontrollers running a small amount of software that could be validated using traditional and informal techniques. However, with the growth of software complexity, traditional techniques for ensuring software reliability have not been able to keep up, leading to an overall degradation of reliability. This paper argues that microkernels are the best approach for delivering truly trustworthy computer systems in the foreseeable future. It presents the NICTA operating-systems research vision, centred around the L4 microkernel and based on four core projects. The seL4 project is designing an improved API for a secure microkernel, L4, verified\u00a0\u2026", "num_citations": "128\n", "authors": ["666"]}
{"title": "Secure microkernels, state monads and scalable refinement\n", "abstract": " We present a scalable, practical Hoare Logic and refinement calculus for the nondeterministic state monad with exceptions and failure in Isabelle/HOL. The emphasis of this formalisation is on large-scale verification of imperative-style functional programs, rather than expressing monad calculi in full generality. We achieve scalability in two dimensions. The method scales to multiple team members working productively and largely independently on a single proof and also to large programs with large and complex properties.               We report on our experience in applying the techniques in an extensive (100,000 lines of proof) case study\u2014the formal verification of an executable model of the seL4 operating system microkernel.", "num_citations": "97\n", "authors": ["666"]}
{"title": "Cogent: Verifying high-assurance file system implementations\n", "abstract": " We present an approach to writing and formally verifying high-assurance file-system code in a restricted language called Cogent, supported by a certifying compiler that produces C code, high-level specification of Cogent, and translation correctness proofs. The language is strongly typed and guarantees absence of a number of common file system implementation errors. We show how verification effort is drastically reduced for proving higher-level properties of the file system implementation by reasoning about the generated formal specification rather than its low-level C code. We use the framework to write two Linux file systems, and compare their performance with their native C implementations.", "num_citations": "96\n", "authors": ["666"]}
{"title": "Verified protection model of the seL4 microkernel\n", "abstract": " This paper presents a machine-checked high-level security analysis of seL4\u2014an evolution of the L4 kernel series targeted to secure, embedded devices. We provide an abstract specification of the seL4 access control system together with a formal proof that shows how confined subsystems can be enforced. All proofs and specifications in this paper are developed in the interactive theorem prover Isabelle/HOL.", "num_citations": "73\n", "authors": ["666"]}
{"title": "Noninterference for operating system kernels\n", "abstract": " While intransitive noninterference is a natural property for any secure OS kernel to enforce, proving that the implementation of any particular general-purpose kernel enforces this property is yet to be achieved. In this paper we take a significant step towards this vision by presenting a machine-checked formulation of intransitive noninterference for OS kernels, and its associated sound and complete unwinding conditions, as well as a scalable proof calculus over nondeterministic state monads for discharging these unwinding conditions across a kernel\u2019s implementation. Our ongoing experience applying this noninterference framework and proof calculus to the seL4 microkernel validates their utility and real-world applicability.", "num_citations": "66\n", "authors": ["666"]}
{"title": "Towards a Practical, Verified Kernel.\n", "abstract": " In the paper we examine one of the issues in designing, specifying, implementing and formally verifying a small operating system kernel-how to provide a productive and iterative development methodology for both operating system developers and formal methods practitioners.", "num_citations": "65\n", "authors": ["666"]}
{"title": "OS Verification-Now!\n", "abstract": " Hard, machine-supported formal verification of software is at a turning point. Recent years have seen theorem proving tools maturing with a number of successful, real-life applications. At the same time, small highperformance OS kernels, which can drastically reduce the size of the trusted computing base, have become more popular. We argue that the combination of those two trends makes it feasible, and desirable, to formally verify production-quality operating systems\u2014now.", "num_citations": "62\n", "authors": ["666"]}
{"title": "Running the manual: An approach to high-assurance microkernel development\n", "abstract": " We propose a development methodology for designing and prototyping high assurance microkernels, and describe our application of it. The methodology is based on rapid prototyping and iterative refinement of the microkernel in a functional programming language. The prototype provides a precise semi-formal model, which is also combined with a machine simulator to form a reference implementation capable of executing real user-level software, to obtain accurate feedback on the suitability of the kernel API during development phases. We extract from the prototype a machine-checkable formal specification in higher-order logic, which may be used to verify properties of the design, and also results in corrections to the design without the need for full verification. We found the approach leads to productive, highly iterative development where formal modelling, semi-formal design and prototyping, and end use all\u00a0\u2026", "num_citations": "58\n", "authors": ["666"]}
{"title": "Experience report: sel4: formally verifying a high-performance microkernel\n", "abstract": " We report on our experience using Haskell as an executable specification language in the formal verification of the seL4 microkernel. The verification connects an abstract operational specification in the theorem prover Isabelle/HOL to a C implementation of the microkernel. We describe how this project differs from other efforts, and examine the effect of using Haskell in a large-scale formal verification. The kernel comprises 8,700 lines of C code; the verification more than 150,000 lines of proof script.", "num_citations": "54\n", "authors": ["666"]}
{"title": "Verified Java bytecode verification\n", "abstract": " The bytecode verifier is an important part of Java's security architecture. This thesis presents a fully formal, executable, and machine checked specification of a representative subset of the Java Virtual Machine and its bytecode verifier together with a proof that the bytecode verifier is safe. The specification consists of an abstract framework for bytecode verification which is instantiated step by step with increasingly expressive type systems covering all of the interesting and complex pro...\u00bb", "num_citations": "50\n", "authors": ["666"]}
{"title": "Refinement through restraint: Bringing down the cost of verification\n", "abstract": " We present a framework aimed at significantly reducing the cost of verifying certain classes of systems software, such as file systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for efficient C code generation; and one functional, suitable for equational reasoning and verification. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C verification frameworks. Our framework is based on certifying compilation: For a well-typed Cogent program, our compiler produces C code, a high-level shallow embedding of its semantics in Isabelle/HOL\u00a0\u2026", "num_citations": "45\n", "authors": ["666"]}
{"title": "Challenges and experiences in managing large-scale proofs\n", "abstract": " Large-scale verification projects pose particular challenges. Issues include proof exploration, efficiency of the edit-check cycle, and proof refactoring for documentation and maintainability. We draw on insights from two large-scale verification projects, L4.verified and Verisoft, that both used the Isabelle/HOL prover. We identify the main challenges in large-scale proofs, propose possible solutions, and discuss the Levity tool, which we developed to automatically move lemmas to appropriate theories, as an example of the kind of tool required by such proofs.", "num_citations": "31\n", "authors": ["666"]}
{"title": "Mechanised separation algebra\n", "abstract": " We present an Isabelle/HOL library with a generic type class implementation of separation algebra, develop basic separation logic concepts on top of it, and implement generic automated tactic support that can be used directly for any instantiation of the library. We show that the library is usable by multiple example instantiations that include structures such as a heap or virtual memory, and report on our experience using it in operating systems verification.", "num_citations": "29\n", "authors": ["666"]}
{"title": "File systems deserve verification too!\n", "abstract": " File systems are too important, and current ones are too buggy, to remain unverified. Yet the most successful verification methods for functional correctness remain too expensive for current file system implementations---we need verified correctness but at reasonable cost. This paper presents our vision and ongoing work to achieve this goal for a new high-performance flash file system, called BilbyFs. BilbyFs is carefully designed to be highly modular, so it can be verified against a high-level functional specification one component at a time. This modular implementation is captured in a set of domain specific languages from which we produce the design-level specification, as well as its optimised C implementation. Importantly, we also automatically generate the proof linking these two artefacts. The combination of these features dramatically reduces verification effort. Verified file systems are now within reach for the\u00a0\u2026", "num_citations": "28\n", "authors": ["666"]}
{"title": "Towards verified virtual memory in L4\n", "abstract": " We report on the initial stage of an on-going verification project: the formalisation and verification of the L4 \u00b5-kernel. We describe an abstract model of the virtual memory subsystem in L4, prove safety properties about this model, and describe refinement of the abstract model towards the implementation of L4. All formalisations and proofs have been carried out in the theorem prover Isabelle.", "num_citations": "28\n", "authors": ["666"]}
{"title": "Concrete Semantics\n", "abstract": " This book is two books. Part I is a practical introduction to working with the Isabelle proof assistant. It teaches you how to write functional programs and inductive definitions and how to prove properties about them in Isa-belle\u2019s structured proof language. Part II is an introduction to the semantics of imperative languages with an emphasis on applications like compilers and program analysers. The distinguishing feature is that every bit of mathemat-ics has been formalised in Isabelle and that much of it is executable. Part I focusses on the details of proofs in Isabelle. Part II can be read even without familiarity with Isabelle\u2019s proof language: all proofs are described in detail but informally. The Isabelle formalisation, including the proofs, is online: all the material, including accompanying slides, can be downloaded. Although the subject matter is semantics and applications, the not-so-hidden agenda is to teach the reader two things: the art of precise logical reasoning and the practical use of a proof assistant as a surgical tool for formal proofs about computer science artefacts. In this sense the book represents a", "num_citations": "27\n", "authors": ["666"]}
{"title": "Formalising the L4 microkernel API\n", "abstract": " This paper gives an overview of a pilot project on the specification and verification of the L4 highperformance microkernel. Of the three aspects examined in the project, we describe one in more detail: the formalisation of the kernel\u2019s Application Programming Interface using the B Method. We conclude that machine-supported formal verification of software is at a turning point; that it is now feasible, and desirable, to formally verify production-quality operating systems.", "num_citations": "26\n", "authors": ["666"]}
{"title": "Verified bytecode subroutines\n", "abstract": " Bytecode subroutines are a major complication for Java bytecode verification: They are difficult to fit into the dataflow analysis that the JVM specification suggests. Hence, subroutines are left out or are restricted in most formalizations of the bytecode verifier. We examine the problems that occur with subroutines and give an overview of the most prominent solutions in the literature. Using the theorem prover Isabelle/HOL, we have extended our substantial formalization of the JVM and the bytecode verifier with its proof of correctness by the most general solution for bytecode subroutines.", "num_citations": "25\n", "authors": ["666"]}
{"title": "capDL: A language for describing capability-based systems\n", "abstract": " Capabilities provide an access control model that can be used to construct systems where safety of protection can be precisely determined. However, in order to be certain of the security provided by such systems it is necessary to verify that their capability distributions do in fact fulfil requirements relating to isolation and information flow, and that there is a direct connection to the actual capability distribution in the system. We claim that, in order to do this effectively, systems need to have explicit descriptions of their capability distributions. In this paper we present the capDL capability distribution language for the capability-based seL4 microkernel. We present the capDL model, its main features and their motivations, and provide a small example to illustrate the language syntax and semantics. CapDL plays a key role in our approach to development, analysis, and verification of trustworthy systems.", "num_citations": "24\n", "authors": ["666"]}
{"title": "Verifying the L4 virtual memory subsystem\n", "abstract": " We describe aspects of the formalisation and verification of the L4 \u00b5-kernel. Starting from an abstract model of the virtual memory subsystem in L4, we prove safety properties about this model, and then refine the page table abstraction, one part of the model, towards C source code. All formalisations and proofs have been carried out in the theorem prover Isabelle.", "num_citations": "24\n", "authors": ["666"]}
{"title": "Re\ufb01nement in the Formal Veri\ufb01cation of the seL4 Microkernel\n", "abstract": " 1 Introduction seL4, the subject of this veri\ufb01cation, is an operating system (OS) microkernel. The OS kernel by de\ufb01nition is the part of the software that runs in the most privileged mode of the hardware. As such, it has full privileges to access and change all parts of the system. Therefore, any defect in the OS kernel is potentially fatal to the operation of the whole system, not just to isolated parts of it. One approach to reduce the risk of such bugs is the microkernel approach: to reduce the privileged kernel code to an absolute minimum. The remaining code base\u20148,700 lines of C and 600 lines of assembly in the case of seL4\u2014is small enough to be amenable to formal veri\ufb01cation on the implementation level. The L4. veri\ufb01ed project has produced such an implementation proof for the C code of seL4. The overall proof comes to about 200,000 lines of proof script and roughly 10,000 intermediate lemmas. The proof assumes correctness of compiler, assembly code, and hardware. It also assumes correct use of low-level hardware caches (memory caches and translation-look-aside buffer) and correctness of the boot code (about 1,200 lines of the 8,700). It formally derives everything else. The veri\ufb01ed version of the seL4 kernel runs on the ARMv6 architecture and the Freescale i. MX31 platform. This article gives an overview of the main proof technique and the proof framework that was used in this veri\ufb01cation project: re\ufb01nement. The proof is not done in a re\ufb01nement calculus that transforms the program in many small steps, but proceeds in two large re\ufb01nement steps RA and RC instead. The three main speci\ufb01cation artefacts in the proof are shown in Fig. 1\u00a0\u2026", "num_citations": "22\n", "authors": ["666"]}
{"title": "A unified memory model for pointers\n", "abstract": " One of the challenges in verifying systems level code is the low-level, untyped view of the machine state that operating systems have. We describe a way to faithfully formalise this view while at the same time providing an easy-to-use, abstract and typed view of memory where possible. We have used this formal memory model to verify parts of the virtual memory subsystem of the L4 high-performance microkernel. All formalisations and proofs have been carried out in the theorem prover Isabelle and the verified code has been integrated into the current implementation of L4.", "num_citations": "22\n", "authors": ["666"]}
{"title": "It's time for trustworthy systems\n", "abstract": " The time for truly trustworthy systems, backed by machine checked formal proof and analysis, has arrived. Over the past few decades, advances in formal verification and analysis technologies mean that these tools can now scale sufficiently to cover the entire software trusted computing base of appropriately designed real world systems.", "num_citations": "21\n", "authors": ["666"]}
{"title": "From a verified kernel towards verified systems\n", "abstract": " The L4.verified project has produced a formal, machine- checked Isabelle/HOL proof that the C code of the seL4 OS microkernel correctly implements its abstract implementation. This paper briefly summarises the proof, its main implications and assumptions, reports on the experience in conducting such a large-scale verification, and finally lays out a vision how this formally verified kernel may be used for gaining formal, code-level assurance about safety and security properties of systems on the order of a million lines of code.", "num_citations": "20\n", "authors": ["666"]}
{"title": "Formalising a high-performance microkernel\n", "abstract": " This paper argues that a pragmatic approach is needed for integrating design and formalisation of complex systems. We report on our approach to designing the seL4 operating system microkernel API and its formalisation in Isabelle/HOL. The formalisation consists of the systematic translation of significant parts of the functional programming language Haskell into Isabelle/HOL, including monadbased code. We give an account of the experience, decisions and outcomes in this translation as well as the technical problems we encountered together with our solutions. The longer-term goal is to demonstrate that formalisation and verification of a large, complex, OS-level code base is feasible with current tools and methods and is in the order of magnitude of traditional development cost.", "num_citations": "18\n", "authors": ["666"]}
{"title": "Verified bytecode verification and type-certifying compilation\n", "abstract": " This article presents a type certifying compiler for a subset of Java and proves the type correctness of the bytecode it generates in the proof assistant Isabelle. The proof is performed by defining a type compiler that emits a type certificate and by showing a correspondence between bytecode and the certificate which entails well-typing. The basis for this work is an extensive formalization of the Java bytecode type system, which is first presented in an abstract, lattice-theoretic setting and then instantiated to Java types.", "num_citations": "18\n", "authors": ["666"]}
{"title": "A Framework for the Automatic Formal Verification of Refinement from Cogent to C\n", "abstract": " Our language Cogent simplifies verification of systems software using a certifying compiler, which produces a proof that the generated C code is a refinement of the original Cogent program. Despite the fact that Cogent itself contains a number of refinement layers, the semantic gap between even the lowest level of Cogent semantics and the generated C code remains large. In this paper we close this gap with an automated refinement framework which validates the compiler\u2019s code generation phase. This framework makes use of existing C verification tools and introduces a new technique to relate the type systems of Cogent and C.", "num_citations": "17\n", "authors": ["666"]}
{"title": "Proof engineering considered essential\n", "abstract": " In this talk, I will give an overview of the various formal verification projects around the evolving seL4 microkernel, and discuss our experience in large scale proof engineering and maintenance.             In particular, the presentation will draw a picture of what these verifications mean and how they fit together into a whole. Among these are a number of firsts: the first code-level functional correctness proof of a general-purpose OS kernel, the first non-interference proof for such a kernel at the code-level, the first binary-level functional verification of systems code of this complexity, and the first sound worst-case execution-time profile for a protected-mode operating system kernel.             Taken together, these projects produced proof artefacts on the order of 400,000 lines of Isabelle/HOL proof scripts. This order of magnitude brings engineering aspects to proofs that we so far mostly associate with software and code\u00a0\u2026", "num_citations": "17\n", "authors": ["666"]}
{"title": "Provable Security: How feasible is it?\n", "abstract": " Strong, machine-checked security proofs of operating systems have been in the too hard basket long enough. They will still be too hard for large mainstream operating systems, but even for systems designed from the ground up for security they have been counted as infeasible. There are high-level formal models, nice security properties, ways of architecting and engineering secure systems, but no implementation level proofs yet, not even with the recent verification of the seL4 microkernel. This needs to change.", "num_citations": "15\n", "authors": ["666"]}
{"title": "Concerned with the unprivileged: User programs in kernel refinement\n", "abstract": " It is a great verification challenge to prove properties of complete computer systems on the source code level. The L4.verified project achieved a major step towards this goal by mechanising a proof of functional correctness of the seL4 kernel. They expressed correctness in terms of data refinement with a coarse-grained specification of the kernel\u2019s execution environment. In this paper, we strengthen the original correctness theorem in two ways. First, we convert the previous abstraction relations into projection functions from concrete to abstract states. Second, we revisit the specification of the kernel\u2019s execution environment: we introduce the notion of virtual memory based on the kernel data structures, we distinguish individual user programs that run on top of the kernel and we restrict the memory access of each of these programs to its virtual memory. Through our work, properties like the separation of user\u00a0\u2026", "num_citations": "14\n", "authors": ["666"]}
{"title": "Correct OS kernel? proof? done\n", "abstract": " Two years ago Gernot Heiser demanded in this venue Your System is Secure? Prove it![5] He also mentioned the L4. verified [3] project at NICTA which is doing just that. This proof is now completed and in this article I\u2019m showing what we have proved and what that means for security.", "num_citations": "14\n", "authors": ["666"]}
{"title": "Operating system verification\n", "abstract": " Issue Title: Special Issue: Operating System Verification/Guest Edited by Gerwin Klein, Ralf Huuck and Bastian Schlich", "num_citations": "14\n", "authors": ["666"]}
{"title": "COGENT: certified compilation for a functional systems language\n", "abstract": " We present a self-certifying compiler for the COGENT systems language. COGENT is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. It compiles to efficient C code that is designed to interoperate with existing C functions. The language is suited for layered systems code with minimal sharing such as file systems or network protocol control code. For a well-typed COGENT program, the compiler produces C code, a high-level shallow embedding of its semantics in Isabelle/HOL, and a proof that the C code correctly implements this embedding. The aim is for proof engineers to reason about the full semantics of real-world systems code productively and equationally, while retaining the interoperability and leanness of C. We describe the formal verification stages of the compiler, which include automated formal refinement calculi, a switch from imperative update semantics to functional value semantics formally justified by the linear type system, and a number of standard compiler phases such as type checking and monomorphisation. The compiler certificate is a series of language-level meta proofs and per-program translation validation phases, combined into one coherent top-level theorem in Isabelle/HOL.", "num_citations": "13\n", "authors": ["666"]}
{"title": "Types, maps and separation logic\n", "abstract": " This paper presents a separation-logic framework for reasoning about low-level C code in the presence of virtual memory. We describe our abstract, generic Isabelle/HOL framework for reasoning about virtual memory in separation logic, and we instantiate this framework to a precise, formal model of ARMv6 page tables. The logic supports the usual separation logic rules, including the frame rule, and extends separation logic with additional basic predicates for mapping virtual to physical addresses. We build on earlier work to parse potentially type-unsafe, system-level C code directly into Isabelle/HOL and further instantiate the separation logic framework to C.", "num_citations": "12\n", "authors": ["666"]}
{"title": "Can We Prove Time Protection?\n", "abstract": " Timing channels are a significant and growing security threat in computer systems, with no established solution. We have recently argued that the OS must provide time protection, in analogy to the established memory protection, to protect applications from information leakage through timing channels. Based on a recently-proposed implementation of time protection in the seL4 microkernel, we investigate how such an implementation could be formally proved to prevent timing channels. We postulate that this should be possible by reasoning about a highly abstracted representation of the shared hardware resources that cause timing channels.", "num_citations": "11\n", "authors": ["666"]}
{"title": "Program verification in the presence of cached address translation\n", "abstract": " Operating system (OS) kernels achieve isolation between user-level processes using multi-level page tables and translation lookaside buffers (TLBs). Controlling the TLB correctly is a fundamental security property\u2014yet all large-scale formal OS verification projects leave correct functionality of the TLB as an assumption. We present a logic for reasoning about low-level programs in the presence of TLB address translation. We extract invariants and necessary conditions for correct TLB operation that mirror the informal reasoning of OS engineers. Our program logic reduces to a standard logic for user-level reasoning, reduces to side-condition checks for kernel-level reasoning, and can handle typical OS kernel tasks such as context switching and page table manipulations.", "num_citations": "11\n", "authors": ["666"]}
{"title": "Separation algebra\n", "abstract": " We present a generic type class implementation of separation algebra for Isabelle/HOL as well as lemmas and generic tactics which can be used directly for any instantiation of the type class. The ex directory contains example instantiations that include structures such as a heap or virtual memory. The abstract separation algebra is based upon \u201cAbstract Separation Logic\u201d by Calcagno et al. These theories are also the basis of \u201cMechanised Separation Algebra\u201d by the authors [1]. The aim of this work is to support and significantly reduce the effort for future separation logic developments in Isabelle/HOL by factoring out the part of separation logic that can be treated abstractly once and for all. This includes developing typical default rule sets for reasoning as well as automated tactic support for separation logic.", "num_citations": "11\n", "authors": ["666"]}
{"title": "The L4. verified project\u2014next steps\n", "abstract": " Last year, the NICTA L4.verified project produced a formal machine-checked Isabelle/HOL proof that the C code of the seL4 OS microkernel correctly implements its abstract implementation. This paper gives a brief overview of the proof together with its main implications and assumptions, and paints a vision on how this verified kernel can be used for gaining assurance of overall system security on the code level for systems of a million lines of code or more.", "num_citations": "11\n", "authors": ["666"]}
{"title": "Interactive Theorem Proving: 5th International Conference, ITP 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 14-17, 2014, Proceedings\n", "abstract": " This book constitutes the proceedings of the 5th International Conference on Interactive Theorem Proving, ITP 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, in Vienna, Austria, in July 2014. The 35 papers presented in this volume were carefully reviewed and selected from 59 submissions. The topics range from theoretical foundations to implementation aspects and applications in program verification, security and formalization of mathematics.", "num_citations": "10\n", "authors": ["666"]}
{"title": "Bringing Effortless Refinement of Data Layouts to Cogent\n", "abstract": " The language Cogent allows low-level operating system components to be modelled as pure mathematical functions operating on algebraic data types, which makes it highly suitable for verification in an interactive theorem prover. Furthermore, the Cogent compiler translates these models into imperative C programs, and provides a proof that this compilation is a refinement of the functional model. There remains a gap, however, between the C data structures used in the operating system, and the algebraic data types used by Cogent. This forces the programmer to write a large amount of boilerplate marshalling code to connect the two, which can lead to a significant runtime performance overhead due to excessive copying. In this paper, we outline our design for a data description language and data refinement framework, called Dargent, which provides the programmer with a means to specify how Cogent\u00a0\u2026", "num_citations": "9\n", "authors": ["666"]}
{"title": "FormGen: A Generator for Adaptive Forms Based on EasyGUI.\n", "abstract": " As a common task in modern applications users need to enter, edit or browse large, complex, maybe even recursive data structures. Many users prefer form based user interfaces. The form fillin interface style (Szekely 1998) is in widespread use eg for database queries, e-commerce orders etc. and exploits the user's familiarity with the paper equivalent. Many use cases are cumbersome on actual paper forms (eg \u201cfill in lines 7-9 only if you answered yes to question 6, proceed to 10 if you answered no\u201d) but can be handled quite elegantly with electronic forms by displaying relevant sections only-depending on the users former input. Those forms are called adaptive (Frank and Szekely 1998) or dynamic (Girgensohn, Zimmermann et al. 1995).Coding adaptive forms by hand or implementing them with a layout based development tool can grow rather expensive for large and more complex data structures. This paper focuses on how the development of adaptive form based user interfaces can be supported by the automatic code generation tool", "num_citations": "8\n", "authors": ["666"]}
{"title": "Backwards and forwards with separation logic\n", "abstract": " The use of Hoare logic in combination with weakest preconditions and strongest postconditions is a standard tool for program verification, known as backward and forward reasoning. In this paper we extend these techniques to allow backward and forward reasoning for separation logic. While the former is derived directly from the standard operators of separation logic, the latter uses a new one. We implement our framework in the interactive proof assistant Isabelle/HOL, and enable automation with several interactive proof tactics.", "num_citations": "7\n", "authors": ["666"]}
{"title": "The Cogent case for property-based testing\n", "abstract": " Property-based testing can play an important role in reducing the cost of formal verification: It has been demonstrated to be effective at detecting bugs and finding inconsistencies in specifications, and thus can eliminate effort wasted on fruitless proof attempts. We argue that in addition, property-based testing enables an incremental approach to a fully verified system, by allowing replacement of automatically generated tests of properties stated in the specification by formal proofs. We demonstrate this approach on the verification of systems code, discuss the implications on systems design, and outline the integration of property-based testing into the Cogent framework.", "num_citations": "7\n", "authors": ["666"]}
{"title": "Mapped separation logic\n", "abstract": " We present Mapped Separation Logic, an instance of Separation Logic for reasoning about virtual memory. Our logic is formalised in the Isabelle/HOL theorem prover and it allows reasoning on properties about page tables, direct physical memory access, virtual memory access, and shared memory. Mapped Separation Logic fully supports all rules of abstract Separation Logic, including the frame rule.", "num_citations": "7\n", "authors": ["666"]}
{"title": "Verifying a high-performance micro-kernel\n", "abstract": " This presentation will give an overview of the L4. verified project at NICTA. The aim of the project is to formally verify, in Isabelle/HOL, the functional correctness of the next L4 micro kernel. The talk will give a high-level introduction to the abstract L4 specification, to the challenges in designing and formalizing a high-performance micro kernel, to the solutions we have developed for letting OS designers and software verifiers work together productively, and finally to a framework for formal refinement and invariant proofs on monadic functional programs.", "num_citations": "7\n", "authors": ["666"]}
{"title": "Introduction to Milestones in Interactive Theorem Proving\n", "abstract": " On March 8, 2018, Tobias Nipkow celebrated his sixtieth birthday. In anticipation of the occasion, in January 2016, two of his former students, Gerwin Klein and Jasmin Blanchette, and one of his former postdocs, Andrei Popescu, approached the editorial board of theJournal of Automated Reasoning with a proposal to publish a surprise Festschrift issue in his honor. The e-mail was sent to twenty-six members of the board, leaving out one, for reasons that will become clear in a moment. It is a sign of the love and respect that Tobias commands from his colleagues that within two days every recipient of the e-mail had responded favorably and enthusiastically to the proposal.", "num_citations": "6\n", "authors": ["666"]}
{"title": "CDSL version 1: Simplifying verification with linear types\n", "abstract": " We introduce a purely functional domain specific language, CDSL, which aims to substantially reduce the cost of producing efficient, verified file system code. Given an executable specification of a file system, the CDSL compiler generates C code and, when fully implemented, will also generate an Isabelle/HOL proof linking the specification and the C implementation. We present two operational semantics for CDSL:(1) a value semantics, well suited for verification, and (2) an update semantics, which can be mapped to efficient C code. We outline the equivalence proof between these two semantics and discuss how the type system guarantees properties like termination, correct error handling, absence of memory leaks and aliasing.", "num_citations": "5\n", "authors": ["666"]}
{"title": "A Termination Checker for Isabelle Hoare Logic.\n", "abstract": " Hoare logic is widely used for software specification and verification. Frequently we need to prove the total correctness of a program: to prove that the program not only satisfies its pre-and post-conditions but also terminates. We have implemented a termination checker for Isabelle\u2019s Hoare logic. The tool can be used as an oracle, where Isabelle accepts its claim of termination. The tool can also be used as an Isabelle method for proving the entire total correctness specification. For many loop structures, verifying the tool\u2019s termination claim within Isabelle is essentially automatic.", "num_citations": "5\n", "authors": ["666"]}
{"title": "Formal reasoning under cached address translation\n", "abstract": " Operating system (OS) kernels achieve isolation between user-level processes using hardware features such as multi-level page tables and translation lookaside buffers (TLBs). The TLB caches address translation, and therefore correctly controlling the TLB is a fundamental security property of OS kernels\u2014yet all large-scale formal OS verification projects we are aware of leave the correct functionality of TLB as an assumption. In this paper, we present a verified sound abstraction of a detailed concrete model of the memory management unit (MMU) of the ARMv7-A architecture. This MMU abstraction revamps our previous address space specific MMU abstraction to include new software-visible TLB features such as caching of globally-mapped and partial translation entries in a two-stage TLB. We use this abstraction as the underlying model to develop a logic for reasoning about low-level programs in the presence\u00a0\u2026", "num_citations": "4\n", "authors": ["666"]}
{"title": "Finite Machine Word Library\n", "abstract": " This entry contains an extension to the Isabelle library for fixedwidth machine words. In particular, the entry adds printing as hexadecimals, additional operations, reasoning about alignment, signed words, enumerations of words, normalisation of word numerals, and an extensive library of properties about generic fixed-width words, as well as an instantiation of many of these to the commonly used 32 and 64-bit bases.", "num_citations": "4\n", "authors": ["666"]}
{"title": "Java source and bytecode formalizations in Isabelle: Bali\n", "abstract": " These theories, called Bali, model and analyse different aspects of the JavaCard source language. The basis is an abstract model of the JavaCard source language. On it, a type system, an operational semantics and an axiomatic semantics (Hoare logic) are built. The execution of a wellformed program (with respect to the type system) according to the operational semantics is proved to be typesafe. The axiomatic semantics is proved to be sound and relative complete with respect to the operational semantics.", "num_citations": "4\n", "authors": ["666"]}
{"title": "Towards provable timing-channel prevention\n", "abstract": " We describe our ongoing research that aims to eliminate microarchitectural timing channels through time protection, which eliminates the root cause of these channels, competition for capacity-limited hardware resources. A proof-ofconcept implementation of time protection demonstrated the approach can be effective a nd l ow o verhead, b ut also that present hardware fails to support the approach in some aspects and that we need an improved hardXare-software contract to achieve real security. We have demonstrated that these mechanisms are not hard to provide, and are working on their inclusion in the RISC-V ISA. Assuming compliant hardware, we outline how we think we can then formally prove that timing channels are eliminated.", "num_citations": "3\n", "authors": ["666"]}
{"title": "Interactive Theorem Proving\n", "abstract": " This special issue collects current efforts towards the construction of formal proofs with the use of interactive theorem provers, which combine formal proof-checking and proof-finding tools with human guidance.", "num_citations": "3\n", "authors": ["666"]}
{"title": "Concrete Semantics\n", "abstract": " This book is two books. Part I is a practical introduction to working with the Isabelle proof assistant. It teaches you how to write functional programs and inductive definitions and how to prove properties about them in Isabelle\u2019s structured proof language. Part II is an introduction to the semantics of imperative languages with an emphasis on applications like compilers and program analysers. The distinguishing features are that every bit of mathematics has been formalized in Isabelle and that much of it is executable. Part I focusses on the details of proofs in Isabelle. Part II can be read even without familiarity with Isabelle\u2019s proof language: all proofs are described in detail but informally. The Isabelle formalization, including the proofs, is available online: all the material, including accompanying slides, can be downloaded from the book\u2019s home page http://www. concrete-semantics. org. Although the subject matter is\u00a0\u2026", "num_citations": "3\n", "authors": ["666"]}
{"title": "CAmkES formalisation of a component platform\n", "abstract": " CAmkES is a component platform for embedded microkernel-based systems, offering many of the standard features available in component platforms. Some relevant features of CAmkES that are not common to all component platforms are:", "num_citations": "3\n", "authors": ["666"]}
{"title": "Kernel Development for High Assurance\n", "abstract": " In the paper we examine one of the issues in designing, specifying, implementing and formally verifying a small operating system kernel\u2014how to provide a productive and iterative development methodology for both operating system developers and formal methods practitioners. We espouse the use of functional programming languages as a medium for prototyping that is readily amenable to formalisation with a low barrier to entry for kernel developers, and report early experience in the process of designing and building seL4: a new, practical, and formally verified microkernel.", "num_citations": "3\n", "authors": ["666"]}
{"title": "On the automated synthesis of proof-carrying temporal reference monitors\n", "abstract": " We extend the range of security policies that can be guaranteed with proof carrying code from the classical type safety, control safety, memory safety, and space/time guarantees to more general security policies, such as general resource and access control. We do so by means of (1) a specification logic for security policies, which is the past-time fragment of LTL, and (2) a synthesis algorithm generating reference monitor code and accompanying proof objects from formulae of the specification logic. To evaluate the feasibility of our approach, we developed a prototype implementation producing proofs in Isabelle/HOL.", "num_citations": "3\n", "authors": ["666"]}
{"title": "Java Source and Bytecode Formalizations in Isabelle: \u03bcJava\n", "abstract": " This document contains the automatically generated listings of the Isabelle sources for \u00b5Java. \u00b5Java is a reduced model of JavaCard, dedicated to the study of the interaction of the source language, byte code, the byte code verifier and the compiler. In order to make the Isabelle sources more accessible, this introduction provides a brief survey of the main concepts of \u00b5Java.", "num_citations": "2\n", "authors": ["666"]}
{"title": "Machine Words in Isabelle/HOL\n", "abstract": " A formalisation of generic, fixed size machine words in Isabelle/HOL. An earlier version of this formalisation is described in [1].", "num_citations": "2\n", "authors": ["666"]}
{"title": "LATEX Sugar for Isabelle documents\n", "abstract": " This document shows how to typset mathematics in Isabelle-based documents in a style close to that in ordinary computer science papers.", "num_citations": "2\n", "authors": ["666"]}
{"title": "Microkernel verification down to assembly\n", "abstract": " When constructing systems with high assurance requirements, it is desirable to build on a formally verified trusted computing base, such as the seL4 microkernel [4]. The verification of seL4 guarantees correctness down to the kernel\u2019s C implementation and relies on the correctness of the C compiler used. CompCert, a verified C compiler [2, 5], has the potential to extend these guarantees to the level of assembly. We have made significant modifications to seL4, which has previously only been compiled with variants of GCC [3], in order to make it compatible with CompCert. The poster proposed will discuss the challenges that have been encountered, some lessons learnt and what we hope to gain from this approach.The contribution of this work is a first step towards our overall aim of the formal verification of a microkernel from a C implementation down to an assembly implementation. To our knowledge, this will be the first proof of functional correctness of a general-purpose operating system kernel down to assembly. The main achievement thus far is applying CompCert to seL4, during which we have already learnt some valuable lessons.", "num_citations": "2\n", "authors": ["666"]}
{"title": "Applications of Interactive Proof to Data Flow Analysis and Security.\n", "abstract": " We show how to formalise a small imperative programming language in the theorem prover Isabelle/HOL, how to define its semantics, and how to prove properties about the language, its type systems, and a number of data flow analyses. The emphasis is not on formalising a complex language deeply, but to teach a number of formalisation techniques and proof strategies using simple examples. For this purpose, we cover a basic type system with type safety proof, more complex security type systems, also with soundness proofs, and different kinds of data flow analyses, in particular definite initialisation analysis and constant propagation, again with correctness proofs.", "num_citations": "1\n", "authors": ["666"]}
{"title": "Proof engineering challenges for large-scale verification\n", "abstract": " In this extended abstract I summarise challenges for proof engineering that we encountered in the formal verification of the seL4 microkernel [7], and its subsequent proofs of integrity [12], non-interference [10], and binary correctness [11]. I focus on problems where there is scope for automation using AI and machine-learning techniques. For more background on the seL4 verification, and an analysis of the effort spent on it, see previous work [6]. The seL4 kernel is a 3rd generation microkernel in the L4 family [9]. Such kernels provide basic operating system (OS) mechanisms such as virtual memory, synchronous and asynchronous messages, interrupt handling, and in the case of seL4, capability-based access control. The idea is that, using these mechanisms, one can isolate software components in time and space from each other, enabling separate compositional verification of trusted components as well as proof that no such correctness is required of untrusted components, because the kernel and its policy configuration already sufficiently constrain their behaviour [2]. The verification of seL4 was not a large project by industrial software development standards, but it was sizeable for an academic formal verification project. The functional correctness proof of seL4 took roughly 12 person years, the overall initial project, including tool building, libraries, and research in scalable proof techniques, usable semantics of the C programming language, etc. took about 25 person years; for a more precise analysis see [6]. This effort later paid off in the proof of high-level security properties: they were much easier to show, because they could now be\u00a0\u2026", "num_citations": "1\n", "authors": ["666"]}
{"title": "1 An Example Submission\n", "abstract": " This is an example submission to the Archive of Formal Proofs. It shows submission requirements and explains the structure of a simple", "num_citations": "1\n", "authors": ["666"]}
{"title": "Formalisation of a component platform\n", "abstract": " Developing and maintaining large safety-and securitycritical software systems can be complex and error prone when based on a monolithic design. Techniques like formal verification can be used to gain a measure of confidence in the correctness of the system, but applying these to code bases at a scale of millions of lines of code remains infeasible [1]. Using component-based development to design a system from composable elements has the potential to lower the costs of both development and formal reasoning about the properties of the system. While there have been attempts in the past to apply formal methods to component systems, existing work assumes the correctness of the component platform itself [2, 3, 5]. This poster reports on ongoing work on the formal modelling and verification of a component platform for systems\u2019 development. There will be no demo with this poster.The term component platform as used here encompasses the definitions of concepts used in a component system specification (component, connection, etc.), the so-called glue code to provide communication between components and other infrastructure required for hosting components at runtime. Assurance in a component system requires trust in three parts of the system: the critical components, the component platform and the underlying operating system. For this work we are modifying an existing component platform that targets the seL4 microkernel [4]. We have constructed formal definitions of the component system concepts and intend to provide a functional specification of the glue code and a machine-checked proof of correctness of the glue code\u00a0\u2026", "num_citations": "1\n", "authors": ["666"]}
{"title": "Interactive Proof: Applications to Semantics.\n", "abstract": " Building on a previous lecture in the summer school, the introduction to interactive proof, this lecture demonstrates a specific application of interactive proof assistants: the semantics of programming languages. In particular, I show how to formalise a small imperative programming language in the theorem prover Isabelle/HOL, how to define its semantics in different variations, and how to prove properties about the language in the theorem prover. The emphasis of the lecture is not on formalising a complex language deeply, but to teach formalisation techniques and proof strategies using simple examples. To this purpose, we cover big-and small step semantics, typing and type safety, as well as a small machine language with compiler and compiler correctness proof.", "num_citations": "1\n", "authors": ["666"]}
{"title": "High assurance system software\n", "abstract": " This paper describes an approach to developing high assurance system software. We demonstrate how different formal methods can be applied in the development process by matching specific techniques and tools to the different levels of system requirements and how those techniques can complement each other.", "num_citations": "1\n", "authors": ["666"]}
{"title": "Reasoning about Translation Lookaside Buffers\n", "abstract": " The main security mechanism for enforcing memory isolation in operating systems is provided by page tables. The hardware-implemented Translation Lookaside Buffer (TLB) caches these, and therefore the TLB and its consistency with memory are security critical for OS kernels, including formally verified kernels such as seL4. If performance is paramount, this consistency can be subtle to achieve; yet, all major formally verified kernels currently leave the TLB as an assumption. In this paper, we present a formal model of the Memory Management Unit (MMU) for the ARM architecture which includes the TLB, its maintenance operations, and its derived properties. We integrate this specification into the Cambridge ARM model. We derive sufficient conditions for TLB consistency, and we abstract away the functional details of the MMU for simpler reasoning about executions in the presence of cached address translation, including complete and partial walks.", "num_citations": "1\n", "authors": ["666"]}