{"title": "ASTRAL: genome-scale coalescent-based species tree estimation\n", "abstract": " Motivation: Species trees provide insight into basic biology, including the mechanisms of evolution and how it modifies biomolecular function and structure, biodiversity and co-evolution between genes and species. Yet, gene trees often differ from species trees, creating challenges to species tree estimation. One of the most frequent causes for conflicting topologies between gene trees and species trees is incomplete lineage sorting (ILS), which is modelled by the multi-species coalescent. While many methods have been developed to estimate species trees from multiple genes, some which have statistical guarantees under the multi-species coalescent model, existing methods are too computationally intensive for use with genome-scale analyses or have been shown to have poor accuracy under some realistic conditions.                    Results: We present ASTRAL, a fast method for estimating species trees\u00a0\u2026", "num_citations": "820\n", "authors": ["992"]}
{"title": "BBCA: Improving the scalability of* BEAST using random binning\n", "abstract": " Species tree estimation can be challenging in the presence of gene tree conflict due to incomplete lineage sorting (ILS), which can occur when the time between speciation events is short relative to the population size. Of the many methods that have been developed to estimate species trees in the presence of ILS, *BEAST, a Bayesian method that co-estimates the species tree and gene trees given sequence alignments on multiple loci, has generally been shown to have the best accuracy. However, *BEAST is extremely computationally intensive so that it cannot be used with large numbers of loci; hence, *BEAST is not suitable for genome-scale analyses. We present BBCA (boosted binned coalescent-based analysis), a method that can be used with *BEAST (and other such co-estimation methods) to improve scalability. BBCA partitions the loci randomly into subsets, uses *BEAST on each subset to co-estimate the\u00a0\u2026", "num_citations": "51\n", "authors": ["992"]}
{"title": "Automatic and transparent transfer of theorems along isomorphisms in the Coq proof assistant\n", "abstract": " In mathematics, it is common practice to have several constructions for the same objects. Mathematicians will identify them modulo isomorphism and will not worry later on which construction they use, as theorems proved for one construction will be valid for all. When working with proof assistants, it is also common to see several data-types representing the same objects. This work aims at making the use of several isomorphic constructions as simple and as transparent as it can be done informally in mathematics. This requires inferring automatically the missing proof-steps. We are designing an algorithm which finds and fills these missing proof-steps and we are implementing it as a plugin for Coq.", "num_citations": "19\n", "authors": ["992"]}
{"title": "Impact of switching bug trackers: a case study on a medium-sized open source project\n", "abstract": " For most software projects, the bug tracker is an essential tool. In open source development, this tool plays an even more central role as it is generally open to all users, who are encouraged to test the software and report bugs. Previous studies have highlighted the act of reporting a bug as a first step leading a user to become an active contributor. The impact of the bug reporting environment on the bug tracking activity is difficult to assess because of the lack of comparison points. In this paper, we take advantage of the switch, from Bugzilla to GitHub, of the bug tracker of Coq, a medium-sized open source project, to evaluate and interpret the impact that such a change can have. We first report on the switch itself, including the migration of preexisting issues. Then we analyze data from before and after the switch using a regression discontinuity design, an econometric methodology imported from quantitative policy\u00a0\u2026", "num_citations": "10\n", "authors": ["992"]}
{"title": "Challenges in the collaborative evolution of a proof language and its ecosystem\n", "abstract": " In this thesis, I present the application of software engineering methods and knowledge to the development, maintenance, and evolution of Coq \u2014an interactive proof assistant based on type theory\u2014 and its package ecosystem. Coq has been developed at Inria since 1984, but has only more recently seen a surge in its user base, which leads to greater concerns about its maintainability, and the involvement of external contributors in the evolution of both Coq and its ecosystem of plugins and libraries. Recent years have seen important changes in the development processes of Coq, of which I have been a witness and an actor (adoption of GitHub as a development platform, first for its pull request mechanism, then for its bug tracker, adoption of continuous integration, switch to shorter release cycles, increased involvement of external contributors in the open source development and maintenance process). The contributions of this thesis include a historical description of these changes, the refinement of existing processes, the design of new processes, the design and implementation of new tools to help the application of these processes, and the validation of these changes through rigorous empirical evaluation. Involving external contributors is also very useful at the level of the package ecosystem. This thesis additionally contains an analysis of package distribution methods, and a focus on the problem of the long-term maintenance of single-maintainer packages.", "num_citations": "5\n", "authors": ["992"]}
{"title": "Hydras & Co.: Formalized mathematics in Coq for inspiration and entertainment\n", "abstract": " Hydras & Co. is a collaborative library of discrete mathematics for the Coq proof assistant, developed as part of the Coq-community organization on GitHub. The Coq code is accompanied by an electronic book, generated with the help of the Alectryon literate proving tool. We present the evolution of the mathematical contents of the library since former presentations at JFLA meetings. Then, we describe how the structure of the project is determined by two requirements which must be continuously satisfied. First, the Coq code needs to be compatible with its ever-evolving dependencies (the Coq proof assistant and several Coq packages both from inside and outside Coq-community) and reverse dependencies (Coq-community projects that depend on it). Second, the book needs to be consistent with the Coq code, which undergoes frequent changes to improve structure and include new material. We believe Hydras & Co. demonstrates that books on formalized mathematics are not limited to providing exposition of theories and reasoning techniquesthey can also provide inspiration and entertainment that transcends educational goals.", "num_citations": "1\n", "authors": ["992"]}
{"title": "A Nix toolbox for reproducible Coq environments, Continuous Integration and artifact reuse\n", "abstract": " When using or contributing to a Coq project (especially one with third party dependencies), it can be difficult and annoying to install the exact set of dependencies at the versions the maintainers recommend. It is more convenient when projects provide an easy way to set everything up to be ready to code, even more so if the dependencies can be quickly fetched in pre-compiled form. Nonetheless, it is also important to preserve the flexibility for project maintainers to test their projects against alternative versions (releases and development) of the dependencies, both while developing locally and in a distant Continuous Integration service (CI). Finally, being able to test that candidate changes do not break reverse dependencies (ie, packages that depend on the project) is essential to bring confidence to project maintainers. We have designed the Coq Nix toolbox which relies on Nix [3] to allow for better sharing of configurations and pre-compiled packages across several projects. This toolbox makes it easy to setup a project and generates CI configurations to test multiple versions of the dependencies and compatibility with reverse dependencies. It enables the use of a single command nix-shell to get the same working environment for every developer. This also saves compilation time since developers and users may download packages that have already been compiled in CI.", "num_citations": "1\n", "authors": ["992"]}
{"title": "A grounded theory of Community Package Maintenance Organizations-Registered Report\n", "abstract": " a) Context: In many programming language ecosystems, developers rely more and more on external open source dependencies, made available through package managers. Key ecosystem packages that go unmaintained create a health risk for the projects that depend on them and for the ecosystem as a whole. Therefore, community initiatives can emerge to alleviate the problem by adopting packages in need of maintenance. b) Objective: The goal of our study is to explore such community initiatives, that we will designate from now on as Community Package Maintenance Organizations (CPMOs) and to build a theory of how and why they emerge, how they function and their impact on the surrounding ecosystems. c) Method: To achieve this, we plan on using a qualitative methodology called Grounded Theory. We have begun applying this methodology, by relying on \"extant\" documents originating from several CPMOs. We present our preliminary results and the research questions that have emerged. We plan to answer these questions by collecting appropriate data (theoretical sampling), in particular by contacting CPMO participants and questioning them by e-mails, questionnaires or semi-structured interviews. d) Impact: Our theory should inform developers willing to launch a CPMO in their own ecosystem and help current CPMO participants to better understand the state of the practice and what they could do better.", "num_citations": "1\n", "authors": ["992"]}
{"title": "A first look at an emerging model of community organizations for the long-term maintenance of ecosystems' packages\n", "abstract": " One of the biggest strength of many modern programming languages is their rich open source package ecosystem. Indeed, modern language-specific package managers have made it much easier to share reusable code and depend on components written by someone else (often by total strangers). However, while they make programmers more productive, such practices create new health risks at the level of the ecosystem: when a heavily-used package stops being maintained, all the projects that depend on it are threatened. In this paper, I ask three questions. RQ1: How prevalent is this threat? In particular, how many depended-upon packages are maintained by a single person (who can drop out at any time)? I show that this is the case for a significant proportion of such packages. RQ2: How can project authors that depend on a package react to its maintainer becoming unavailable? I list a few options, and I\u00a0\u2026", "num_citations": "1\n", "authors": ["992"]}