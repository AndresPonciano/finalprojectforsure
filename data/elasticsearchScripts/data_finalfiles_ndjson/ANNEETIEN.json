{"title": "A model driven design framework for massively parallel embedded systems\n", "abstract": " Modern embedded systems integrate more and more complex functionalities. At the same time, the semiconductor technology advances enable to increase the amount of hardware resources on a chip for the execution. Massively parallel embedded systems specifically deal with the optimized usage of such hardware resources to efficiently execute their functionalities. The design of these systems mainly relies on the following challenging issues: first, how to deal with the parallelism in order to increase the performance; second, how to abstract their implementation details in order to manage their complexity; third, how to refine these abstract representations in order to produce efficient implementations. This article presents the Gaspard design framework for massively parallel embedded systems as a solution to the preceding issues. Gaspard uses the repetitive Model of Computation (MoC), which offers a powerful\u00a0\u2026", "num_citations": "150\n", "authors": ["139"]}
{"title": "A strategy driven business process modelling approach\n", "abstract": " Purpose \u2013 Most of the process models concentrate on who does what, when, i.e. on the description of the operational performance of tasks. The goal driven approaches try to establish a close relationship between the \u201cwhys\u201d and the \u201cwhats\u201d. The former captures the strategic goals of the organisation whereas the latter tells us how they are achieved through tasks carried out by actors. In addition, managers do not naturally make the distinction between what to achieve (the goal) and the manner to achieve it (the strategy). This confusion often leads to the expression of manners as goals. In order to make clear the fundamental distinction between these two concerns and to master the complexity of process modelling, this paper seeks to propose a goal\u2010perspective, the map\u2010driven process modelling approach.Design/methodology/approach \u2013 The map representation system conforms to goal models in the fact that it\u00a0\u2026", "num_citations": "132\n", "authors": ["139"]}
{"title": "Gaspard2: from MARTE to SystemC simulation\n", "abstract": " To efficiently use the tremendous amount of hardware resources available in next generation MultiProcessor Systems-on-Chip (MPSoC), new design methodologies and tools are needed to reduce the development complexity of such systems. In this paper, we present an efficient MPSoC design environment, Gaspard2. It uses the new standard MARTE (Modeling and Analysis of Real-Time and Embedded systems) profile for high level system representation. Gaspard2 is based on a Model-Driven Engineering (MDE) methodology allowing to move from the primary modeling form to an executable platform. In our work, we target SystemC code generation at the Timed Programmer View (PVT) level. To reach our objective, a compilation chain has been developed, made up of several model to model transformations.", "num_citations": "64\n", "authors": ["139"]}
{"title": "Measuring the fitness relationship\n", "abstract": " It is widely acknowledged that the system functionality captured in a system model has to match organisational requirements available in the business model. However, such a matching is rarely used to support design strategies. We believe that appropriate measures of what we refer to as the fitness relationship can facilitate design decisions. The paper proposes criteria and associated generic metrics to quantify to which extent there is a fit between the business and the system which supports it. In order to formulate metrics independent of specific formalisms to express the system and the business models, we base our proposal on the use of ontologies. This also contributes to provide a theoretical foundation to our proposal. In order to illustrate the use of the proposed generic metrics we show in the paper, how to derive a set of specific metrics from the generic ones and we illustrate the use of the specific\u00a0\u2026", "num_citations": "51\n", "authors": ["139"]}
{"title": "Ing\u00e9nierie de l'alignement: concepts, mod\u00e8les et processus: la m\u00e9thode ACEM pour l'alignement d'un syst\u00e8me d'information aux processus d'entreprise\n", "abstract": " Cette th\u00e8se s' inscrit dans le domaine de l'ing\u00e9nierie des syst\u00e8mes d'information et plus pr\u00e9cis\u00e9ment dans celui de l'ing\u00e9nierie de l'alignement. Elle propose une m\u00e9thode de correction et d'\u00e9volution de l'alignement entre un syst\u00e8me d'information et des processus d'entreprise. L'approche propose les points suivants:-Une d\u00e9finition formelle de la relation d'alignement qui repose sur deux types de liens ainsi que sur les concepts de deux m\u00e9ta-mod\u00e8les g\u00e9n\u00e9riques repr\u00e9sentant respectivement le syst\u00e8me et les processus.-Un ensemble de m\u00e9triques permettant de mesurer le degr\u00e9 d'alignement entre syst\u00e8me et processus. Ces m\u00e9triques sont d\u00e9finies \u00e0 un niveau g\u00e9n\u00e9riqu puis g\u00e9n\u00e9r\u00e9es pour deux meta-mod\u00e8les permettant respectivement de repr\u00e9senter chacune de ces deux entit\u00e9s.-Un mod\u00e8le pivot permettant de repr\u00e9senter conjointement syst\u00e8me et processus ainsi que de rendre explicite la relation d'alignement \u00e0 diff\u00e9rents niveaux d'abstraction.-La repr\u00e9sentation explicte d'exigences d'\u00e9volution permettant de se focaliser sur ce qui change entre la situation initiale et la situation finale sans red\u00e9finir ce qui reste inchang\u00e9. Ces exigences d'\u00e9volution sont d\u00e9finies sous forme d'\u00e9carts associ\u00e9s au m\u00e9ta-mod\u00e8le sp\u00e9cifique utilis\u00e9 pour repr\u00e9sente les deux situations.-Une d\u00e9marche guid\u00e9e, muti-d\u00e9marche qui aide l'ing\u00e9nieur \u00e0 corriger l'alignement ou \u00e0 faire \u00e9voluer conjointement syst\u00e8me et processus.", "num_citations": "48\n", "authors": ["139"]}
{"title": "A model driven design framework for high performance embedded systems\n", "abstract": " Modern embedded systems integrate more and more complex functionalities. At the same time, the semiconductor technology advances enable to increase the amount of hardware resources on a chip for the execution. High performance embedded systems specifically deal with the optimized usage of such hardware resources to efficiently execute their functionalities. The design of high performance embedded systems mainly relies on the following challenging issues: first, how to deal with the parallelism in order to increase the performances; second, how to abstract their implementation details in order to manage their complexity; third, how to refine these abstract representations in order to produce efficient implementations. This paper presents the Gaspard design framework for high performance embedded systems as a solution to the above issues. Gaspard uses the repetitive Model of Computation (MoC), which offers a powerful expression of the parallelism available in both system functionality and architecture. Embedded systems are designed at a high abstraction level with the MARTE (Modeling and Analysis of Real-time and Embedded systems) standard profile, in which our repetitive MoC is described by the so-called Repetitive Structure Modeling (RSM) package. Based on the Model-Driven Engineering (MDE) paradigm, MARTE models are refined towards lower abstraction levels, which make possible the design space exploration. By combining all these capabilities, Gaspard allows the designers to automatically generate code for formal verification, simulation and hardware synthesis from high level specifications of high\u00a0\u2026", "num_citations": "47\n", "authors": ["139"]}
{"title": "Traceability Mechanism for Error Localization in Model Transformation.\n", "abstract": " Model Driven Engineering (MDE) introduces the model paradigm as the basis of system design. It increases reusability in the development of complex systems. Nevertheless, with this new paradigm, traditional issues such as system debugging or system evolution management have to be performed in a different way. Existing techniques require to be adapted. We have shown the feasibility of traceability to solve these issues. However, system debugging can only be undertaken if the developer trusts the compiler. In MDE, the compiler is a transformation chain. It is hence important to test the transformations and possibly to debug them. In this paper, we demonstrate that our traceability mechanism coupled to our error localization algorithm eases the transformation test. Indeed, it highlights the succession of rule that leads to a faulty output element. This approach is illustrated in the context of embedded system development.", "num_citations": "24\n", "authors": ["139"]}
{"title": "Using feature model to build model transformation chains\n", "abstract": " Model transformations are intrinsically related to model-driven engineering. According to the increasing size of standardised meta-model, large transformations need to be developed to cover them. Several approaches promote separation of concerns in this context, that is, the definition of small transformations in order to master the overall complexity. Unfortunately, the decomposition of transformations into smaller ones raises new issues: organising the increasing number of transformations and ensuring their composition (i.e. the chaining). In this paper, we propose to use feature models to classify model transformations dedicated to a given business domain. Based on this feature models, automated techniques are used to support the designer, according to two axis: (i)the definition of a valid set of model transformations and (ii) the generation of an executable chain of model transformation that accurately\u00a0\u2026", "num_citations": "20\n", "authors": ["139"]}
{"title": "Using the uml profile for marte to mpsoc co-design\n", "abstract": " The increasing amount of hardware resources in next generation MultiProcessor Systems-on-Chip (MPSoC) calls for efficient design methodologies and tools to reduce their development complexity. This paper presents a candidate MPSoC design environment Gaspard2, which uses the MARTE (Modeling and Analysis of Real-Time and Embedded systems) standard profile for high-level system specification. Gaspard2 adopts a methodology based on Model-Driven Engineering. It promotes separation of concerns, reusability and automatic model refinement from higher abstraction levels to executable descriptions.", "num_citations": "19\n", "authors": ["139"]}
{"title": "A process for generating fitness measures\n", "abstract": " It is widely acknowledged that the system functionality captured in a system model has to match organisational requirements available in the business model. However, fitness measures are rarely integrated in design methodologies. The paper proposes a framework to ease the generation of fitness measures adapted to a given methodology in order to quantify to which extent there is fit between the business and the system. The framework comprises a generic level and a specific level. The former provides generic evaluation criteria and metrics expressed on the basis of business and system ontologies. The specific level is dealing with a specific set of metrics adapted to specific business and system models. The paper presents the process for generating a specific set of measures from the generic set, illustrates it with two specific models and shows how the use of the generated metrics can help in making\u00a0\u2026", "num_citations": "16\n", "authors": ["139"]}
{"title": "Using an alternative trace for QVT\n", "abstract": " Model transformations are the core of the MDE methodology. They can be expressed using various languages. One of them is QVT, the OMG standard for transformation languages. QVT also provides a traceability mechanism. In general, a trace can be used for many purposes. In this paper, we show the limitations of the trace provided by QVT through different scenarios. Furthermore, based on the QVT language elements, we highlight model transformation concepts that would require consideration. We also propose an alternative trace that takes into account these concepts. It allows us to gather information not provided by the QVT trace and thus fully performs the scenarios. The proposed trace is language independent and can be used without perturbing the QVT transformation execution or the trace generation/exploitation by the engine.", "num_citations": "15\n", "authors": ["139"]}
{"title": "Fine grained traceability for an mde approach of embedded system conception\n", "abstract": " MDE approaches are wide-spreading more and more. They allow the generation of code from high level abstraction models, using intermediary models. A development system based on an MDE approach often involves several model transformations composing one or more transformation chains. In order to deal with the complexity in such a system, it is necessary to introduce a traceability mechanism helping both the users and the developers keeping track of elements. Several traceability mechanisms and semantics have already been defined, but they are not appropriate to trace fine grained elements, like properties. In this paper, we have adapted existing traceability mechanisms in order to manage a richer semantics for traceability. We have implemented a generic and partially reusable traceability solution tested in Gaspard transformation chains.", "num_citations": "11\n", "authors": ["139"]}
{"title": "Towards a unified notation to represent model transformation\n", "abstract": " In order to unify our internal exchange and communication about transformations, we propose TrML (Transformation Modeling Language), a unified UML notation to design model transformations. This proposal aims to reify the synthesis of existing notations dedicated to transformation modeling. TrML is independent from implementation details and could be adapted to several transformation engines. To let TrML run on top of existing engine, we transform TrML model to a model accepted by the engine. But, which language should we use for the first transformation? TrML, the targeted engine or another one? In this article we will describe how we bootstrap our new language on top of existing transformation engines.", "num_citations": "11\n", "authors": ["139"]}
{"title": "Rotten green tests\n", "abstract": " Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A green (passing) test is usually taken as a robust sign that the code under test is valid. However, some green tests contain assertions that are never executed. We call such tests Rotten Green Tests. Rotten Green Tests represent a case worse than a broken test: they report that the code under test is valid, but in fact do not test that validity. We describe an approach to identify rotten green tests by combining simple static and dynamic call-site analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. DrTest reports no false negatives, yet it still reports some false positives due to conditional use or multiple test contexts. Using DrTest we conducted an empirical evaluation of 19,905 real\u00a0\u2026", "num_citations": "8\n", "authors": ["139"]}
{"title": "Using trace to situate errors in model transformations\n", "abstract": " Model Driven Engineering (MDE) promotes models as main artifacts in software development process. Each model represents a viewpoint of a system. MDE aims to automatically generate code from an abstract model, using various intermediary models. Such a generation relies on successive model transformations shifting a source model to a target one. The resulting transformation sequence corresponds to the skeleton of an MDE based approach, similarly to compiler in traditional ones.               Transformations are used many times in order to justify their development effort. If their are faulty, they can largely spread errors to models. Thus, it is indispensable to test them and possibly debug them. In this paper, we propose an error localization algorithm based on a traceability mechanism in order to ease the transformations debugging. We illustrate this approach in the context of embedded system\u00a0\u2026", "num_citations": "6\n", "authors": ["139"]}
{"title": "Traceability for mutation analysis in model transformation\n", "abstract": " Model transformation can\u2019t be directly tested using program techniques. Those have to be adapted to model characteristics. In this paper we focus on one test technique: mutation analysis. This technique aims to qualify a test data set by analyzing the execution results of intentionally faulty program versions. If the degree of qualification is not satisfactory, the test data set has to be improved. In the context of model, this step is currently relatively fastidious and manually performed.               We propose an approach based on traceability mechanisms in order to ease the test model set improvement in the mutation analysis process. We illustrate with a benchmark the quick automatic identification of the input model to change. A new model is then created in order to raise the quality of the test data set.", "num_citations": "5\n", "authors": ["139"]}
{"title": "Using traceability to enhance mutation analysis dedicated to model transformation\n", "abstract": " Techniques initially used for programs require modifications to be properly used with to model transformation characteristics. Mutation analysis is one of these techniques. It aims to qualify a test data set by analyzing the execution results of intentionally faulty program versions. If the degree of qualification is not satisfactory, the test data set has to be improved. This step is currently relatively fastidious and manually performed. In this paper, we propose an approach based on traceability mechanisms to ease the test model set improvement in the mutation analysis process. A benchmark shows that the part of the input model to change is automatically and quickly identified. A new model is then created in order to raise the quality of the test data set.", "num_citations": "3\n", "authors": ["139"]}
{"title": "Challenges for layout validation: Lessons learned\n", "abstract": " Companies are migrating their software systems. The migration process contemplates many steps, UI migration is one of them. To validate the UI migration, most existing approaches rely on visual structure (DOM) comparison. However, in previous work, we experimented such validation and reported that it is not sufficient to ensure a result that is equivalent or even identical to the visual structure of the interface to be migrated. Indeed, two similar DOM may be rendered completely differently. So, we decide to focus on the layout migration validation. We propose a first visual comparison approach for migrated layout validation and experiment it on an industrial case. Hence, from this first experiment and already existing studies on image comparison field, we highlight challenges for layout comparison. For each challenge, we propose possible solutions, and we detail the three main features we need to create a\u00a0\u2026", "num_citations": "2\n", "authors": ["139"]}
{"title": "Business process/information system co-evolution\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "2\n", "authors": ["139"]}
{"title": "D\u00e9finition et identification des tables de nomenclatures\n", "abstract": " Dans une base de donn\u00e9es relationnelle, certaines tables ont pour finalit\u00e9 de rassem- bler et d\u2019apporter des informations compl\u00e9mentaires aux lignes des tables constituant le coeur de la base. Ces donn\u00e9es sont stock\u00e9es dans des tables que nous d\u00e9signons \u201ctables de nomen- clatures\u201d. Pouvoir les distinguer pr\u00e9sente de nombreux int\u00e9r\u00eats dans le cadre de l\u2019\u00e9tude, la maintenance et l\u2019\u00e9volution d\u2019une base de donn\u00e9es. Nous proposons des propri\u00e9t\u00e9s permettant de d\u00e9finir la nature de ces tables. Une exp\u00e9rience permettant de valider les propri\u00e9t\u00e9s propo- s\u00e9es est d\u00e9crite puis appliqu\u00e9e \u00e0 un cas d\u2019\u00e9tude. Un mod\u00e8le de classification pour les tables de nomenclatures est construit \u00e0 l\u2019aide d\u2019un algorithme d\u2019exploration de donn\u00e9es (datamining). Son \u00e9valuation montre une pr\u00e9cision 88, 6% et un rappel de 88, 7%. ABSTRACT. In a relational database, some tables are used to gather additional information to rows of tables forming the core of the database. This data is stored in tables that we call \u201cno- menclature tables\u201d. Being able to distinguish them offers many interests in the study, mainte- nance and evolution of databases. We propose properties to define the nature of these tables. Then, an experiment to validate the proposed properties is described and applied on a case study. A classification model for nomenclature tables is built using a datamining algorithm. Its evaluation shows a precision of 88.6% and a recall of 88.7%.", "num_citations": "1\n", "authors": ["139"]}
{"title": "Measuring the progress of an Industrial Reverse Engineering Process\n", "abstract": " In an industrial process of production, project managers look for ways to visualise the progress of their project. Reverse engineering projects do not escape this requirement. These projets have the particularity to provide information, more or less accurate, about the whole project, from documentation to source code. Comparison between the number of treated entities (lines of code or entities) and the global corresponding number should ease the task of computing project progress. However, in large projects, studying all entities can be an endless task. Engineers need ways to help them in such a task. This paper sets up the general issue of how to follow progress in a reverse engineering process. We also propose an early solution to this issue and discuss about its improvements.", "num_citations": "1\n", "authors": ["139"]}
{"title": "R\u00e9cuperation de Composants \u00e0 partir d\u2019un syst\u00e8me patrimonial\n", "abstract": " De nombreuses techniques ont \u00e9t\u00e9 d\u00e9velopp\u00e9es dans le contexte de la r\u00e9tro-ing\u00e9nierie de systeme patrimonial. Une de ces techniques, appel\u00e9e component recovery, permet l\u2019extraction de composanta partir du code source. Afin d\u2019assurer une modernisation efficace, les composants se doivent d\u2019\u00eatre bien d\u00e9finis. Les composants possedent tres souvent des informations sur le domaine d\u2019application du systeme, informations qui sont r\u00e9cup\u00e9r\u00e9esa travers des entrevues avec les experts du domaines. Ainsi, ces experts et ing\u00e9nieurs doivent tre inclus dans la d\u00e9marche de r\u00e9tro-ing\u00e9nierie afin de fournir leurs connaissances aux techniques de r\u00e9tro-ing\u00e9nierie. Notre pr\u00e9sentation montre la d\u00e9marche que nous avons imagin\u00e9e afin de r\u00e9cup\u00e9rer des composants,a la fois m\u00e9tier et respectant la d\u00e9finition d\u2019un composant,a partir d\u2019un code source patrimonial. Ce code patrimonial est celui d\u2019une application critique, temps r\u00e9\u00e9l, embarqu\u00e9e et \u00e9crite en Ada.", "num_citations": "1\n", "authors": ["139"]}
{"title": "Goal/Strategy Maps-Methods, Techniques and Tools to Specify Requirements in Different Evolutionary Contexts\n", "abstract": " Archive ouverte HAL - Goal / Strategy Maps - Methods, Techniques and Tools to Specify Requirements in Different Evolutionary Contexts Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00706457, version 1 Communication dans un congr\u00e8s Goal / Strategy Maps - Methods, Techniques and Tools to Specify Requirements in Different Evolutionary Contexts Camille Salinesi 1 Anne Etien 1 Iyad Zoukar 1 D\u00e9tails 1 CRI - Centre de Recherche en Informatique de Paris 1 Type de document : Communication un \u2026", "num_citations": "1\n", "authors": ["139"]}