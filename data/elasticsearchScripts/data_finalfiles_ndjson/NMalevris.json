{"title": "Reducing the effects of infeasible paths in branch testing\n", "abstract": " Branch testing, which is one of the most widely used methods for program testing, see White [1] for example, involves executing a selected set of program paths in an attempt to exercise all program branches. Criteria for selecting such paths have, to date, received scant attention in the literature and it is the issue of developing a suitable path selection strategy to which this paper is addressed. Specifically, a selection strategy, which aims at reducing the number of infeasible paths generated during the branch testing exercise is proposed. The strategy is founded on an assertion concerning the likely feasibility of program paths. Statistical evidence in support of the assertion is provided, a method implementing the strategy is described, and the results obtained from applying the method to a set of program units are reported and analysed.", "num_citations": "89\n", "authors": ["485"]}
{"title": "Predictive metric for likely feasibility of program paths\n", "abstract": " The paper advances a claim about the nature of infeasible paths in programs and provides significant statistical evidence to support its validity. The characteristics of the claim permit the definition of an easily derived metric that, in view of the results of the statistical analysis presented, should provide a good predictor of the likely feasibility of program paths.", "num_citations": "28\n", "authors": ["485"]}
{"title": "The collateral coverage of data flow criteria when branch testing\n", "abstract": " When exercising program code with test data in an attempt to satisfy a given testing criterion, there will be a concurrent accrual of coverage in respect of other testing criteria. Knowledge of the extent of such \u2018collateral coverage\u2019 can be used to advantage both in providing better estimates of the overheads entailed by the overall testing exercise, and in helping to determine an optimal sequence for the application of a set of testing methods.In this paper, the results deriving from a set of experiments are reported. The aim of the experiments was to investigate the extent of the collateral coverage that is achieved in respect of the data-flow testing criteria when branch testing is undertaken.", "num_citations": "25\n", "authors": ["485"]}
{"title": "A two-folded impact analysis of schema changes on database applications\n", "abstract": " Database applications are becoming increasingly popular, mainly due to the advanced data management facilities that the underlying database management system offers compared against traditional legacy software applications. The interaction, however, of such applications with the database system introduces a number of issues, among which, this paper addresses the impact analysis of the changes performed at the database schema level. Our motivation is to provide the software engineers of database applications with automated methods that facilitate major maintenance tasks, such as source code corrections and regression testing, which should be triggered by the occurrence of such changes. The presented impact analysis is thus two-folded: the impact is analysed in terms of both the affected source code statements and the affected test suites concerning the testing of these applications. To\u00a0\u2026", "num_citations": "22\n", "authors": ["485"]}
{"title": "A structural approach towards the maintenance of database applications\n", "abstract": " The evolving nature of a database imposes continuous changes in both its structure and data that may respectively affect any dependent application. Within such a dynamic environment, there is a growing demand for methodologies focused on testing and maintaining database applications. Towards this direction a new approach is introduced that initially applies reverse engineering on the application in order to move the embedded SQL statements from the application code into the database. Subsequently, database schema modifications are classified according to their criticality to database related code. Critical changes are isolated and their impact is analyzed by using data flow information specifically tailored for the data manipulation language.", "num_citations": "17\n", "authors": ["485"]}
{"title": "Non-english web search: an evaluation of indexing and searching the Greek web\n", "abstract": " The study reports on a longitudinal and comparative evaluation of Greek language searching on the web. Ten engines, five global (A9, AltaVista, Google, MSN Search, and Yahoo!) and five Greek (Anazitisi, Ano-Kato, Phantis. Trinity, and Visto), were evaluated using (a) navigational queries in 2004 and 2006; and (b) by measuring the freshness of the search engine indices in 2005 and 2006. Homepage finding queries for known Greek organizations were created and searched. Queries included the name of the organization in its Greek and non-Greek, English or transliterated equivalent forms. The organizations represented ten categories: government departments, universities, colleges, travel agencies, museums, media (TV, radio, newspapers), transportation, and banks. The freshness of the indices was evaluated by examining the status of the returned URLs (live versus dead) from the navigational\u00a0\u2026", "num_citations": "15\n", "authors": ["485"]}
{"title": "A path generation method for testing LCSAJs that restrains infeasible paths\n", "abstract": " The testing of all LCSAJs (Linear Code Sequences and Jumps) in a given code unit has been regarded as a very useful and important method for program testing that goes beyond testing program branches. It involves the generation of a set of paths and execution of these paths with sets of data. Thus it can be regarded as a path testing method too; see Woodward et al.1 for example. Criteria for selecting such paths have, to date, received scant attention in the literature. In this paper, a suitable path selection strategy which aims at reducing the number of infeasible paths generated is proposed. The methods embodying this strategy are discussed and their application to a set of program units is reported and analysed. The ability of the methods in providing a high coverage for the LCSAJs in a program is also exposed.", "num_citations": "15\n", "authors": ["485"]}
{"title": "Location of facilities producing airborne pollution\n", "abstract": " The location of a facility producing an airborne pollutant is considered and the 4-wind model introduced by Karkazis and Papadimitriou is described briefly. Ways in which the model may be enhanced are discussed; in particular, it is shown how the restriction to four wind directions may be removed. The applicability of the approach is tested on data relating to the Salonica district of Greece.", "num_citations": "15\n", "authors": ["485"]}
{"title": "An evaluation of how search engines respond to greek language queries\n", "abstract": " Over 20 billion Web pages from around the world have been indexed by search engines. This study investigates how search engines respond to non-English queries and more specifically to Greek language queries. To address this we conducted an evaluation using Greek queries in ten search engines: five \"global\" (A9, AltaVista, Google, MSN Search, and Yahoo!) and five Greek (Anazitisi, Ano-Kato, Phantis. Trinity, and Visto). A set of navigational queries for known Greek organizations was created. The organizations correspond to ten categories: government departments, universities, colleges, travel agencies, museums, media (TV, radio, newspapers), transportation, and banks. Searches were performed using the Greek and its corresponding English, Latin, or transliterated name of each organization. The ideal retrieval would be to get the website of that organization ranked first in the result set. The results of\u00a0\u2026", "num_citations": "13\n", "authors": ["485"]}
{"title": "DaSIAn: a tool for estimating the impact of database schema modifications on web applications\n", "abstract": " In the light of the extraordinary and continuous growth of the Web, there is a significant development shift from traditional software applications to web applications. The spread of this type of applications raises a demand for new approaches towards their testing and maintenance. Contrary to most previous proposals our interest focuses on the interaction between a web application and its underlying database. This paper describes an approach for the estimation of the impact that database schema modifications imply to the operability of a web application. In addition, a software tool called DaSIAn that is based upon this proposal is presented and its experimental results are being discussed.", "num_citations": "11\n", "authors": ["485"]}
{"title": "An agent-based approach for the maintenance of database applications\n", "abstract": " Database systems lie at the core of almost every modern software application. The interaction between the application source code and the underlying database schema results in a dependency relationship that affects the application 's maintainability by raising a number of additional maintenance issues. To assess this effect and facilitate the maintenance process, a software engineering approach based on software agents is introduced. The distributed and cooperative nature of a software agent system provides the flexibility required to analyze modern multi-tier database applications such as web-based applications. A prototype system, which employs agent architecture in order to satisfy the requirements of the suggested approach, is presented.", "num_citations": "10\n", "authors": ["485"]}
{"title": "Program Analysis and Testing of Database Applications\n", "abstract": " During the last decades database applications are undoubtedly among the most widely used types of software applications. The presence of database statements in their source code is one of their typical characteristics that however introduces many difficulties in their code-level analysis and testing. This paper describes an approach that resolves such issues and facilitates the employment of traditional software testing techniques. The approach involves two alternative methods and is founded on the execution plan that the underlying database management system derives for each SQL statement. To support this approach a prototype tool called DATeM has been developed and the experimental results from its usage are reported and analyzed", "num_citations": "10\n", "authors": ["485"]}
{"title": "A unified symbolic execution system\n", "abstract": " Test data generation is one of the hardest tasks in the software life-cycle. Many testing methods try to answer this question, all in a heuristic way. Symbolic execution is one such software testing method that can be used either for program evaluation or in order to assist the automated test data generation process. A number of systems employing symbolic execution for test data generation have already been built. In this paper, a new symbolic execution system is presented, which can be used regardless of the language in which the program under test is written. The system is called VOLCANO and the scripts are written in SYMEXLAN (SYMbolic EXecution LANguage), a scripting language that can be either an intermediate representation for many other languages or a symbolic execution language that facilitates the symbolic execution process.", "num_citations": "10\n", "authors": ["485"]}
{"title": "Employing agents towards database applications testing\n", "abstract": " Testing multi-tier database applications can be viewed as a distributed task performed at each tier by a number of agents. From this point of view, an agent based approach, originally introduced for the software maintenance of such applications, is extended to provide an effective, intelligent and extensible solution suitable for their testing.", "num_citations": "9\n", "authors": ["485"]}
{"title": "An objective comparison of the cost effectiveness of three testing methods\n", "abstract": " Branch testing is a well established method for exercising software. JJ-path testing, whilst employed by some practitioners, is less popular, and the testing of JJ-pairs finds few adherents. In this paper an objective, practical study of the cost-effectiveness of these three testing methods is reported. The effectiveness of each method is assessed, in the presence of infeasible paths, not only on its ability to cover the specific structural element of code that it targets, but also on its ability to cover the structural elements targeted by the other two methods \u2013 the collateral coverage it achieves. The assessment is based on the results derived from experiments in which each of the three methods is applied to 35 units of program code.", "num_citations": "9\n", "authors": ["485"]}
{"title": "The effort required by LCSAJ testing: an assessment via a new path generation strategy\n", "abstract": " In general, LCSAJ testing more thoroughly exercises the control structure of a piece of software than does either statement or branch testing. Despite this, the exceptionally small number of papers which detail experience of using LCSAJ testing clearly indicates that its popularity falls considerably short of that of the other two methods. One factor that has contributed to this situation is the apparent absence of any attempt to assess the effort entailed by LCSAJ testing in practice, thereby precluding any meaningful cost-effectiveness analysis of the method. Such an attempt is reported in this paper.               A significant influence on the effort associated with LCSAJ testing is the number of test paths that must be generated to achieve a specified level of cover, and this is determined by the number of such paths that are found to be infeasible. Effort, therefore, is dependent upon the effectiveness of the path\u00a0\u2026", "num_citations": "6\n", "authors": ["485"]}
{"title": "Inclusion, subsumption, JJ\u2010paths, and structured path testing: a Redress\n", "abstract": " Introduced in 1976 by Hennell, Woodward, and Hedley, the Linear Code Sequence and Jump (LCSAJ) has since been named the jump\u2010to\u2010jump path (JJ\u2010path). If all JJ\u2010paths in a piece of code have been tested, then it is guaranteed, for example, that all of the code's branches and all of its statements will likewise have been tested. JJ\u2010path testing is thus said to include both branch and statement testing. Over the years, much work has been carried out on the inclusion relation, and this is also true of a closely\u2010linked relation that is known as subsumption. Not surprisingly, some of the work in the literature has focussed on the criteria of executing all JJ\u2010paths and sequences of such, and how these criteria relate to other path coverage and test data criteria. Unfortunately, certain results involving JJ\u2010paths in the context of inclusion, as portrayed in a widely referenced and influential paper, are in error. Consequently, the\u00a0\u2026", "num_citations": "5\n", "authors": ["485"]}
{"title": "Rules and criteria for when to stop testing a piece of software\n", "abstract": " The problem of defining an optimum software release-time has been a challenge to everyone involved in software production. Software testers define criteria measuring the quality of the testing process rather than the achieved reliability levels. Statisticians use theoretical stopping rules ignoring the applied testing strategies and finally cost analysts suggest the termination of testing within predefined cost and time - schedule commitments. A review of rules and criteria that suggest the finishing of testing is presented, emhasizing the need to link all the above approaches to software reliability through a universally understood concept, that of time.", "num_citations": "4\n", "authors": ["485"]}
{"title": "Evolution and maintenance of database applications.\n", "abstract": " With current software technology trends, databases lie on the heart of almost every modern software system. The evolving nature of the environment under which a database is developed imposes continuous changes in both its structure and data that may respectively affect the validity of any application interacting with the database. In this paper we present a quantitative evaluation of the evolution of a database application as a result of database schema modifications. To increase the maintainability of such applications we have employed a reverse engineering strategy for transforming any part of the database related code that is written outside the DBMS into modules stored inside the DBMS. In addition, we provide a classification of schema modifications according to their criticality on database code invalidation that will further facilitate the maintenance process of database applications.", "num_citations": "3\n", "authors": ["485"]}
{"title": "An effective metrod for mutating java programs\n", "abstract": " AN EFFECTIVE METHOD FOR MUTATING JAVA PROGRAMS M. Mastorantonakis and N. Malevris Department of Informatics Athens University of Economics and Business 76 Patission St., Athens Greece Abstract Testing is a very crucial phase of the software development cycle. There have been developed a number of testing methods during the past years, each one contributing a different merit in the attempt to reveal errors and establish the credibility of the software under test. Of these methods one that has received important attention due to its ability of detecting faults in a program is mutation. Corresponding to that is the logic of creating mutants by changing, usually slightly, the source code only and not the data that are used for tests. The purpose of the present research is to develop a system that performs mutation testing to programs written in the Java language in such a way that it also generates a reduced , . \u2026", "num_citations": "3\n", "authors": ["485"]}
{"title": "On the determination of an appropriate time for ending the software testing process\n", "abstract": " Software testing is widely used as a means of increasing software reliability. The prohibitive nature of exhaustive testing has given rise to the problem of determining when a system has reached an acceptable reliability slate and can be released. This has probably become the hardest problem facing a project manager. In this paper, a stopping rule that indicates the appropriate time at which to stop testing is presented. The rule automatically adapts to modifications in the assumptions, since it can be applied under any software error-counting model. An investigation of the properties of the rule is described and the results obtained after applying it to a set of real data in conjunction with two statistical models are presented.", "num_citations": "3\n", "authors": ["485"]}
{"title": "Agent systems in software engineering\n", "abstract": " During the last decade the continuous growth of the Web resulted in a significant development shift from simple types of software applications to distributed multi-tier web-based applications. In general, distributed systems are by nature more complex than centralized systems. As a result, the software engineering tasks of these systems are also complicated. Unlike traditional software applications, Web-based applications are associated with a plethora of special characteristics that impede the appliance of conventional software engineering techniques. Among them, the most important include the distributed and stateless nature of the Web, the impressively high changing frequency of implementation technologies and the spread of dynamic Web pages. Furthermore, the vital role of databases in both web and distributed applications raises a demand for introducing software engineering techniques tailored for these applications. These applications, known as database applications (DA), contain embedded SQL statements in the source code. Similarly to web applications, the presence of such special statements turns out to impose a number of limitations to the applicability of existing software engineering techniques while also originating new issues.In this chapter, the use of agent technology to confront with the software engineering task will be illustrated. More precisely, the focus will be on the application of agent systems in order to confront with the requirements of the software engineering process for distributed software systems in general, paying particular attention to distributed database applications and web applications.", "num_citations": "2\n", "authors": ["485"]}
{"title": "How do Search Engines Handle Greek Queries?\n", "abstract": " General or Global Search Engines maintain that have indexed over 20 billion pages worldwide [10]. But, how well do they respond to non-English queries? And, how well do they index the content of specific domains? To address this we selected the Greek web (. gr) domain and conducted an evaluation using Greek language queries involving ten search engines. These were five \u201cglobal\u201d namely A9, AltaVista, Google, MSN Search, and Yahoo!, and five Greek search engines, namely Anazitisi, Ano-Kato, Phantis. Trinity, and Visto. In the evaluation we used the methodology of searching for the name of a known organization. Eighty (80) organizations were selected and used for searching. These organizations were divided into ten (10) categories: government departments, universities, colleges, travel agencies, museums, media (TV, radio, newspapers), transportation, and banks. A table was created with the names of the organizations and their corresponding URL that uniquely identifies them. Searches were run using the Greek and English names of each organization. The ideal retrieval would be to get the website of that organization ranked first in the result set. We present the results of this evaluation, reporting on how the engines respond to Greek and Romanized or Anglicized queries, and on the best performing global and Greek search engines.", "num_citations": "2\n", "authors": ["485"]}
{"title": "A new script language applicable to symbolic execution systems\n", "abstract": " The problem of test data generation in software testing is well referenced. Of the various methods used in the literature, symbolic execution appears to be a promising approach. It can be used either for software verification or to facilitate the automated test data generation process. A number of symbolic systems that employ symbolic execution to generate test data have already been constructed. However, these systems analyze programs written in specific programming languages. Thus, although some of them use an internal representation for performing symbolic execution, each one can only deal with programs in a single language. In this paper a script language called SYMEXLAN is presented. It can be adapted in order to construct a general symbolic execution testing system independent of the language in which the software under test is written.", "num_citations": "2\n", "authors": ["485"]}
{"title": "An assessment of the number of paths needed for control flow testing\n", "abstract": " Generating test data does require a great amount of effort. The estimation of this effort beforehand is difficult and unclear when generating test data for exercising certain program structural characteristics. Methods that try to generate test data based on a minimum number of paths fail to estimate a lower bound in advance. When some of the paths they generate are infeasible, this situation is worsened. Thus, the generation of the test paths is important due to the presence of infeasible paths. Knowing the effort involved in deriving the appropriate test paths is a very useful exercise. This effort is linked directly to the estimation of the effort involved in achieving a high level of reliability. In this paper methods that do suggest a lower bound and an experimental upper bound are presented. Their ability of circumventing the incidence of infeasible paths is discussed and the lower and upper bounds of the cost and\u00a0\u2026", "num_citations": "2\n", "authors": ["485"]}
{"title": "Metallaxis: An automated framework for weak mutation\n", "abstract": " Mutation testing is highly regarded as a key method towards fault revealing. Despite this advantage, it has proved to be rather impractical for industrial use because of the expenses involved. To this extend, automated techniques have proved suitable for applying and reducing the method\u2019s demands. Whilst there is much evidence that automated test data generation techniques can effectively automate the testing process, there has been little work on applying them in the context of mutation testing. In this paper an automatic mutation based test data generation framework called \u201cMetallaxis\u201d is proposed. The framework uses a novel dynamic execution scheme in order to both introduce the required mutants and to effectively generate test cases able to kill those mutants. A conducted case study employing the proposed approach reveals the feasibility, practicality and effectiveness of the proposed approach.", "num_citations": "2\n", "authors": ["485"]}
{"title": "Software Testing\n", "abstract": " Software Testing Software Engineering is a discipline that deals with the development of Software, which in turn, has always been regarded as the means of producing appropriate information when processing data. This identifies the importance of Software for delivering \u201cgood\u201d results. Software can be very difficult to develop depending on the circumstances and certainly on the specifications set.", "num_citations": "1\n", "authors": ["485"]}
{"title": "On structurally testing Java programs effectively\n", "abstract": " Software testing remains the basic means of locating errors in program code. Although there is no single testing method that can isolate all sources of errors, practitioners usually adhere to these techniques in order to establish a high level of confidence at the predelivery phase. Structural testing constitutes the most popular dynamic testing method that exercises the software with test data. Most commercial tools employ this technique as the basis in order to establish a level of confidence in the software under test. In this paper a method to perform structural testing effectively is presented which also reduces the incidence of infeasible paths.", "num_citations": "1\n", "authors": ["485"]}
{"title": "Testing a communications driver for the IEEE 1394 high speed serial bus standard\n", "abstract": " Software testing is a difficult and tedious task. For a network driver, software testing is still more laborious. The main reason for this is that a communications driver does not act as a stand-alone application used by an end user. A communications driver acts as a part of the operating system kernel and is used by other operating system components and/or applications through a general purpose Application Programming Interface (API). This paper discusses the experience that has been gained by testing a communications driver that provided a general purpose API to both kernel and user mode components. The driver was implemented on the Windows NT 4.0 and Windows 98 operating systems, and its underlying medium was an IEEE 1394 network.", "num_citations": "1\n", "authors": ["485"]}