{"title": "Type theory and functional programming\n", "abstract": " Constructive Type theory has been a topic of research interest to computer scientists, mathematicians, logicians and philosophers for a number of years. For computer scientists it provides a framework which brings together logic and programming languages in a most elegant and fertile way: program development and verification can proceed within a single system. Viewed in a different way, type theory is a functional programming language with some novel features, such as the totality of all its functions, its expressive type system allowing functions whose result type depends upon the value of its input, and sophisticated modules and abstract types whose interfaces can contain logical assertions as well as signature information. A third point of view emphasizes that programs (or functions) can be extracted from proofs in the logic.Up until now most of the material on type theory has only appeared in proceedings of conferences and in research papers, so it seems appropriate to try to set down the current state of development in a form accessible to interested final-year undergraduates, graduate students, research workers and teachers in computer science and related fields\u2013hence this book.", "num_citations": "393\n", "authors": ["1052"]}
{"title": "Erlang programming\n", "abstract": " This book is an in-depth introduction to Erlang, a programming language ideal for any situation where concurrency, fault tolerance, and fast response is essential. Erlang is gaining widespread adoption with the advent of multi-core processors and their new scalable approach to concurrency. With this guide you'll learn how to write complex concurrent programs in Erlang, regardless of your programming background or experience. Written by leaders of the international Erlang community--and based on their training material--Erlang Programming focuses on the language's syntax and semantics, and explains pattern matching, proper lists, recursion, debugging, networking, and concurrency. This book helps you: Understand the strengths of Erlang and why its designers included specific features Learn the concepts behind concurrency and Erlang's way of handling it Write efficient Erlang programs while keeping code neat and readable Discover how Erlang fills the requirements for distributed systems Add simple graphical user interfaces with little effort Learn Erlang's tracing mechanisms for debugging concurrent and distributed systems Use the built-in Mnesia database and other table storage features Erlang Programming provides exercises at the end of each chapter and simple examples throughout the book.", "num_citations": "327\n", "authors": ["1052"]}
{"title": "Tool support for refactoring functional programs\n", "abstract": " Refactorings are source-to-source program transformations which change program structure and organisation, but not program functionality. Documented in catalogues and supported by tools, refactoring provides the means to adapt and improve the design of existing code, and has thus enabled the trend towards modern agile software development processes. Refactoring has taken a prominent place in software development and maintenance, but most of this recent success has taken place in the OO and XP communities. In our project, we explore the prospects for'Refactoring Functional Programs', taking Haskell as a concrete case-study. This paper discusses the variety of pragmatic and implementation issues raised by our work on the Haskell Refactorer. We briefly introduce the ideas behind refactoring, and a set of elementary functional refactorings. The core of the paper then outlines the main challenges that\u00a0\u2026", "num_citations": "155\n", "authors": ["1052"]}
{"title": "Podcasting by synchronising PowerPoint and voice: What are the pedagogical benefits?\n", "abstract": " The purpose of this study was to investigate the efficacy of audio\u2013visual synchrony in podcasting and its possible pedagogical benefits. \u2018Synchrony\u2019 in this study refers to the simultaneous playback of audio and video data streams, so that the transitions between presentation slides occur at \u201clecturer chosen\u201d points in the audio commentary. Manufacturers of lecture recording software (e.g. ProfCast) would have us believe that the synchrony of image and audio should improve the learning experience. We have yet to see in the literature any empirical evidence to support this hypothesis. In our study, 90 participants in two groups undertook two electronic lectures (e-lectures) on two separate topics, the subject matter of neither was familiar to them beforehand. Each group experienced one \u201csynchronous\u201d presentation (e-lecture) of one of the topics, and one \u201cseparate\u201d presentation (i.e. PowerPoint and audio files\u00a0\u2026", "num_citations": "147\n", "authors": ["1052"]}
{"title": "A decision procedure and complete axiomatization of finite interval temporal logic with projection\n", "abstract": " This paper presents a complete axiomatization for propositional interval temporal logic (PITL) with projection. The axiomatization is based on a tableau decision procedure for the logic, which in turn is founded upon a normal form for PITL formluae. The construction of the axiomatization provides a general mechanism for generating axiomatizations thus: given a normal form for a new connective, axioms can be generated for the connective from the tableau construction using that normal form. The paper concludes with a discussion of aspects of compositionality for PITL with projection.", "num_citations": "79\n", "authors": ["1052"]}
{"title": "Scripting smart contracts for distributed ledger technology\n", "abstract": " We give an overview of the scripting languages used in existing cryptocurrencies, and in particular we review in some detail the scripting languages of Bitcoin, Nxt and Ethereum, in the context of a high-level overview of Distributed Ledger Technology and cryptocurrencies. We survey different approaches, and give an overview of critiques of existing languages. We also cover technologies that might be used to underpin extensions and innovations in scripting and contracts, including technologies for verification, such as zero knowledge proofs, proof-carrying code and static analysis, as well as approaches to making systems more efficient, eg Merkelized Abstract Syntax Trees.", "num_citations": "76\n", "authors": ["1052"]}
{"title": "Clone detection and removal for Erlang/OTP within a refactoring environment\n", "abstract": " A well-known bad code smell in refactoring and software maintenance is duplicated code, or code clones. A code clone is a code fragment that is identical or similar to another. Unjustified code clones increase code size, make maintenance and comprehension more difficult, and also indicate design problems such as lack of encapsulation or abstraction.", "num_citations": "63\n", "authors": ["1052"]}
{"title": "A Domain-Specific Language for Scripting Refactoring In Erlang\n", "abstract": " Refactoring is the process of changing the design of a program without changing its behaviour. Many refactoring tools have been developed for various programming languages; however, their support for composite refactorings \u2013 refactorings that are composed from a number of primitive refactorings \u2013 is limited. In particular, there is a lack of powerful and easy-to-use frameworks that allow users to script their own large-scale refactorings efficiently and effectively.               This paper introduces the domain-specific language framework of Wrangler \u2013 a refactoring and code inspection tool for Erlang programs \u2013that allows users to script composite refactorings, test them and apply them on the fly. The composite refactorings are fully integrated into Wrangler and so can be previewed, applied and \u2018undone\u2019 interactively.", "num_citations": "61\n", "authors": ["1052"]}
{"title": "The Haskell refactorer, HaRe, and its API\n", "abstract": " We demonstrate the Haskell Refactorer, HaRe, both as an example of a fully-functional tool for a complete (functional) programming language, and to show the API which HaRe provides for building source-level program transformations for Haskell. We comment on the challenges presented by the construction of this and similar tools for language frameworks and processors.", "num_citations": "60\n", "authors": ["1052"]}
{"title": "The expressiveness of spider diagrams\n", "abstract": " Spider diagrams are a visual language for expressing logical statements. In this paper we identify a well-known fragment of first-order predicate logic that we call MFOL=, equivalent in expressive power to the spider diagram language. The language MFOL= is monadic and includes equality but has no constants or function symbols. To show this equivalence, in one direction, for each diagram we construct a sentence in MFOL= that expresses the same information. For the more challenging converse we prove that there exists a finite set of models for a sentence S that can be used to classify all the models for S. Using these classifying models we show that there is a diagram expressing the same information as S.", "num_citations": "59\n", "authors": ["1052"]}
{"title": "Miranda: the craft of functional programming\n", "abstract": " Miranda | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksMiranda: The Craft of Functional Programming ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide books cover image Miranda: The Craft of Functional Programming July 1995 480 pages ISBN:0201422794 Author: Simon Thompson Copyright \u00a9 1995 Publisher Addison-Wesley Longman Publishing Co., Inc. United States Publication History Published: 1 July \u2026", "num_citations": "54\n", "authors": ["1052"]}
{"title": "Refactoring with Wrangler, updated: Data and process refactorings, and integration with Eclipse\n", "abstract": " Wrangler is a refactoring tool for Erlang, implemented in Erlang. This paper reports the latest developments in Wrangler, which include improved user experience, the introduction of a number of data-and process-related refactorings, and also the implementation of an Eclipse plug-in which, together with Erlide, provides refactoring support for Erlang in Eclipse.", "num_citations": "53\n", "authors": ["1052"]}
{"title": "Similar code detection and elimination for Erlang programs\n", "abstract": " A well-known bad code smell in refactoring and software maintenance is duplicated code, that is the existence of code clones, which are code fragments that are identical or similar to one another. Unjustified code clones increase code size, make maintenance and comprehension more difficult, and also indicate design problems such as a lack of encapsulation or abstraction.               This paper describes an approach to detecting \u2018similar\u2019 code based on the notion of anti-unification, or least-general common abstraction. This mechanism is used for detecting code clones in Erlang programs, and is supplemented by a collection of refactorings to support user-controlled automatic clone removal. The similar code detection algorithm and refactorings are integrated within Wrangler, a tool developed at the University of Kent for interactive refactoring of Erlang programs. We conclude with a report on case studies\u00a0\u2026", "num_citations": "50\n", "authors": ["1052"]}
{"title": "Introductory problem solving in computer science\n", "abstract": " This paper describes our experiences in devising a lightweight, informal methodology for problem solving in introductory, university level, computer science. We first describe the original context of the experiment and the background to the methodology. We then give the details of the steps of the Problem Solving Cycle - Understanding, Designing, Writing and Reviewing - and the lessons we learned about our teaching from devising the material. We also present practical examples of how it has been applied in a variety of units in our programme.", "num_citations": "50\n", "authors": ["1052"]}
{"title": "Laws in miranda\n", "abstract": " We discuss the Miranda programming language, giving a brief tour of its major features before we narrow down to considering laws in the language. Laws provide a means of implementing non-free data types--two particular classes of examples are constrained data types and data types with memoised information. We discuss these examples and then go on to look at how we can derive laws from function definitions, giving an example which incorporates both of the above ideas. Finally we show how we can prove properties of these'lawful'types and functions over them.", "num_citations": "48\n", "authors": ["1052"]}
{"title": "Mechanical verification of refactorings\n", "abstract": " In this paper we describe the formal verification of refactorings for untyped and typed lambda-calculi. This verification is performed in the proof assistant Isabelle/HOL.", "num_citations": "44\n", "authors": ["1052"]}
{"title": "Refactoring functional programs\n", "abstract": " Refactoring is the process of improving the design of existing programs without changing their functionality. These notes cover refactoring in functional languages, using Haskell as the medium, and introducing the HaRe tool for refactoring in Haskell.", "num_citations": "40\n", "authors": ["1052"]}
{"title": "Interactive functional programs: a method and a formal semantics\n", "abstract": " In this paper we present a model of interactive programs in a purely functional style. We exploit lazy evaluation in the modelling of streams as lazy lists. We show how programs may be constructed in an ad hoc way, and then present a small set of interactions and combinators which form the basis for a disciplined approach to writing such programs. One of the difficulties of the ad hoc approach is that the way in which input and output are interleaved by the functions can be unpredictable. In the second half of the paper we use traces, i.e. partial histories of behaviour, to explain the interleaving of input and output, and give a formal explanation of our combinators. We argue that this justifies our claim that the combinators have the intuitively expected behaviour, and finally contrast our approach with another.", "num_citations": "40\n", "authors": ["1052"]}
{"title": "The expressiveness of spider diagrams augmented with constants\n", "abstract": " Spider diagrams are a visual language for expressing logical statements or constraints. Several sound and complete spider diagram systems have been developed and it has been shown that they are equivalent in expressive power to monadic first order logic with equality. However, these sound and complete spider diagram systems do not contain syntactic elements analogous to constants in first order predicate logic. We extend the spider diagram language to include constant spiders which represent specific individuals. Formal semantics are given for the extended diagram language. We prove that this extended system is equivalent in expressive power to the language of spider diagrams without constants and, hence, equivalent to monadic first order logic with equality.", "num_citations": "39\n", "authors": ["1052"]}
{"title": "A logic for Miranda\n", "abstract": " We formulate a logical description of the functional programming language Miranda. Distinctive features include a full treatment of pattern matching with repeated variables and the characterisation of various (sub-)domains, like the defined natural numbers and finite definite lists, by means of new quantifiers. These quantifiers are introduced by induction rules, and also carry elimination rules. We also discuss the r\u00f4le of fixed point induction and issues of modularisation and scale.", "num_citations": "39\n", "authors": ["1052"]}
{"title": "Marlowe: Financial contracts on blockchain\n", "abstract": " Blockchains allow the specification of contracts in the form of programs that guarantee their fulfilment. Nevertheless, errors in those programs can cause important, and often irretrievable, monetary loss. General-purpose languages provide a platform on which contracts can be built, but by their very generality they have the potential to exhibit behaviours of an unpredictable kind, and are also not easy to read or comprehend for general users.                 An alternative solution is provided by domain-specific languages (DSLs), which are designed to express programs in a particular field. This paper explores the design of one DSL, Marlowe, targeted at the execution of financial contracts in the style of Peyton Jones et al. on blockchains. We present an executable semantics of Marlowe in Haskell, an example of Marlowe in practice, and describe the Meadow tool that allows users to interact in-browser with\u00a0\u2026", "num_citations": "36\n", "authors": ["1052"]}
{"title": "A tableau method for Interval Temporal Logic with projection\n", "abstract": " This paper introduces a tableau method for propositional interval temporal logic (ITL) [14]. Beyond the usual operators of linear temporal logic, ITL contains sequencing and iterative operators, \u2018;\u2019 and proj akin to programming combinators. Central to our approach is a normal form for the formulas of ITL, particularly \u2018;\u2019 and proj, in terms of the \u2018\u25ef\u2019 operator of the logic.", "num_citations": "36\n", "authors": ["1052"]}
{"title": "Behavioral reactivity and real time programming in XML: functional programming meets SMIL animation\n", "abstract": " XML and its associated languages are emerging as powerful authoring tools for multimedia and hypermedia web content. Furthermore intelligent presentation generation engines have begun to appear as have models and platforms for adaptive presentations. However XML-based models are limited by their lack of expressiveness in presentation and animation. As a result authors of dynamic adaptive web content must often use considerable amounts of script or code. The use of such script or code has two serious drawbacks. First such code undermines the declarative description possible in the original presentation language and second the scripting/coding approach does not readily lend itself to authoring by non programmers. In this paper we describe a set of XML language extensions inspired by features from the functional programming world which are designed to widen the class of reactive systems which\u00a0\u2026", "num_citations": "33\n", "authors": ["1052"]}
{"title": "Let's make refactoring tools user-extensible!\n", "abstract": " We present a framework for making a refactoring tool extensible, allowing users to define refactorings from scratch using the concrete syntax of the language, as well as to describe complex refactorings in a domain-specific language for scripting. We demonstrate the approach in practice through a series of examples.", "num_citations": "29\n", "authors": ["1052"]}
{"title": "Comparative study of refactoring haskell and erlang programs\n", "abstract": " Refactoring is about changing the design of existing code without changing its behaviour, but with the aim of making code easier to understand, modify, or reuse. Taking Haskell and Erlang as examples, we investigate the application of refactoring techniques to functional programs, and building tools for supporting interactive refactoring. Although both Haskell and Erlang are general-purpose functional programming languages, they have many differences in their language design and programming idioms. As a result, program refactoring in the two languages has much in common, but also considerable differences. This paper makes this comparison, and in particular looks in more detail at the refactorings applicable in each language, the program analysis required by typical refactorings, and at tool support for refactoring Haskell and Erlang programs.", "num_citations": "29\n", "authors": ["1052"]}
{"title": "A logic for Miranda, revisited\n", "abstract": " This paper expands upon work begun in [Tho89], in building a logic for the Miranda functional programming language. After summarising the work in that paper, a translation of Miranda definitions into logical formulas is presented, and illustrated by means of examples. This work expands upon [Tho89] in giving a complete treatment of sequences of equations, and by examining how to translate the local definitions introduced by where clauses.               The status of the logic is then examined, and it is argued that the logic extends a natural operational semantics of Miranda, given by the translations of definitions into conditional equations.               Finally it is shown how the logic can be implemented in the Isabelle proof tool.", "num_citations": "26\n", "authors": ["1052"]}
{"title": "Mexitl: Multimedia in executable interval temporal logic\n", "abstract": " This paper explores a formalism for describing a wide class of multimedia document constraints, based on an interval temporal logic. We describe the requirements that arise from the multimedia documents application area, and we illustrate these requirements using several examples. Then we present the temporal logic formalism that we use. This logic extends existing interval temporal logic with a number of new features: actions, framing of actions, past operators, a projection-like operator called filter and a new handling of interval length. The notation is applied to the specification of the examples, and in particular a set of logical manipulations, providing feedback to an author, is presented. A model theory, logic and satisfaction relation are defined for the notation.", "num_citations": "25\n", "authors": ["1052"]}
{"title": "Specification and prototyping of structured multimedia documents using interval temporal logic\n", "abstract": " This paper explores a formalism for describing a wide class of multimedia document constraints. We outline the requirements on temporal logic specification that arise from the multimedia documents application area. In particular, we highlight a canonical document example. Then we present the temporal logic formalism that we use. This formalism extends existing interval temporal logic with a number of new features: actions, framing of actions, past operators, a projection-like operator called filter and a new handling of interval length. A model theory and satisfaction relation are defined for the logic and a specification of the canonical example is presented.", "num_citations": "25\n", "authors": ["1052"]}
{"title": "Higher-order+ polymorphic= reusable\n", "abstract": " This paper explores how certain ideas in object oriented languages have their correspondents in functional languages. In particular we look at the analogue of the iterators of the C++ standard template library. We also give an example of the use of constructor classes which feature in Haskell 1.3 and Gofer.", "num_citations": "24\n", "authors": ["1052"]}
{"title": "Testing erlang refactorings with QuickCheck\n", "abstract": " Refactoring is a technique for improving the design of existing programs without changing their behaviour. Wrangler is a tool built at the University of Kent to support Erlang program refactoring; the Wrangler tool is written in Erlang.             In this paper we present the use of a novel testing tool, Quviq QuickCheck, for testing the implementation of Wrangler. QuickCheck is a specification-based testing tool for Erlang. With QuickCheck, programs are tested by writing properties in a restricted logic, and using the tool these properties are tested in randomly generated test cases.             This paper first gives overviews of Wrangler and Quviq QuickCheck, then discusses the various ways in which refactorings can be validated, and finally shows how QuickCheck can be used to test the correctness of refactorings in an efficient way.", "num_citations": "23\n", "authors": ["1052"]}
{"title": "Software metrics: measuring Haskell.\n", "abstract": " Software metrics have been used in software engineering as a mechanism for assessing code quality and for targeting software developmentactivities, such as testing or refactoring, at areas of a program that will most bene\ufb01t from them. Haskell [PJ03] has many tools for software engineering, such as testing, debugging and refactoring tools, but software metrics have been neglected. This paper identi\ufb01es a collection of software metrics for use with Haskell programs. These metrics are subjected to statistical analysis to assess the correlation between their values and the number of bug \ufb01xing changes occurring during the development of two case study programs. In addition, the relationships between the metrics are also explored, showing how combinations of metrics can be used to improve their accuracy.", "num_citations": "23\n", "authors": ["1052"]}
{"title": "Formalisation of Haskell refactorings.\n", "abstract": " Refactoring is a technique for improving the design of existing programs without changing their external behaviour. HaRe is the refactoring tool we have built to support refactoring Haskell 98 programs. Along with the development of HaRe, we have also investigated the formal speci\ufb01cation and proof of validity of refactorings. This formalisation process helps to clarify the meaning of refactorings, improves our con\ufb01dence in the behaviour-preservation of refactorings, and reduces the need for testing. This paper gives an overview of HaRe, and shows our approach to the formalisation of refactorings.", "num_citations": "23\n", "authors": ["1052"]}
{"title": "Adding the axioms to Axiom: Towards a system of automated reasoning in Aldor\n", "abstract": " A number of combinations of theorem proving and computer algebra systems have been proposed; in this paper we describe another, namely a way to incorporate a logic in the computer algebra system Axiom. We examine the type system of Aldor -- the Axiom Library Compiler -- and show that with some modifications we can use the dependent types of the system to model a logic, under the Curry-Howard isomorphism. We give a number of example applications of the logic we construct.", "num_citations": "22\n", "authors": ["1052"]}
{"title": "A User-extensible Refactoring Tool for Erlang Programs\n", "abstract": " Refactoring is the process of changing the design of a program without changing what it does. While it is possible to refactor a program by hand, tool support is considered invaluable as it allows large-scale refactorings to be performed easily. However, most refactoring tools are black boxes, supporting a fixed set of `core' refactorings. This paper reports the framework built into Wrangler \u00e2?? a refactoring and code inspection tool for Erlang programs", "num_citations": "21\n", "authors": ["1052"]}
{"title": "Formulating haskell\n", "abstract": " The functional programming language Haskell is examined from the point of view of proving programs correct. Particular features explored include the data type definition facilities, classes, the behaviour of patterns and guards and the monad approach to IO in the Glasgow Haskell compiler.", "num_citations": "21\n", "authors": ["1052"]}
{"title": "Incremental clone detection and elimination for erlang programs\n", "abstract": " A well-known bad code smell in refactoring and software maintenance is the existence of code clones, which are code fragments that are identical or similar to one another. This paper describes an approach to incrementally detecting \u2018similar\u2019 code based on the notion of least-general common abstraction, or anti-unification, as well as a framework for user-controlled incremental elimination of code clones within the context of Erlang programs. The clone detection algorithm proposed in this paper achieves 100% precision, high recall rate, and is user-customisable regarding the granularity of the clone classes reported. By detecting and eliminating clones in an incremental way, we make it possible for the tool to be used in an interactive way even with large codebases. Both the clone detection and elimination functionalities are integrated with Wrangler, a tool for interactive refactoring of Erlang programs. We\u00a0\u2026", "num_citations": "20\n", "authors": ["1052"]}
{"title": "The categorical multi-combinator machine: Cmcm\n", "abstract": " Implementations of functional programming languages can take a number of different forms, and many different machines have been developed for this purpose. This paper introduces another abstract machine, the Categorical Multi-Combinator Machine (CMCM). A thorough introduction to the machines is given, particularly as far as the discussion of the starting of computational information is concerned.", "num_citations": "20\n", "authors": ["1052"]}
{"title": "Lawful functions and program verification in Miranda\n", "abstract": " Laws in the Miranda programming language provide a means of implementing non-free algebraic types, by means of term rewriting. In this paper we investigate program verification in such a context. Specifically, we look at how to deduce properties of functions over these \u201clawful\u201d types. After examining the general problem, we look at a particular class of functions, the faithful functions. For such functions we are able, in a direct manner, to transfer properties of functions from free types to non-free types. We introduce sufficient model theory to explain these transfer results, and then find characterisations of various classes of faithful functions. Then we investigate an application of this technique to general, unfaithful, situations. In conclusion we survey Wadler's work on views and assess the utility of laws and views.", "num_citations": "20\n", "authors": ["1052"]}
{"title": "Quickchecking refactoring tools\n", "abstract": " Refactoring is the transformation of program source code in a way that preserves the behaviour of the program. Many tools exist for automating a number of refactoring steps, but these tools are often poorly tested. We present an automated testing framework based on QuickCheck for testing refactoring tools written for the Erlang programming language.", "num_citations": "19\n", "authors": ["1052"]}
{"title": "Where do I begin? A problem solving approach in teaching functional programming\n", "abstract": " This paper introduces a problem solving method for teaching functional programming, based on Polya's How To Solve It, an introductory investigation of mathematical method. We first present the language independent version, and then show in particular how it applies to the development of programs in Haskell. The method is illustrated by a sequence of examples and a larger case study.", "num_citations": "18\n", "authors": ["1052"]}
{"title": "Towards property-based testing of RESTful web services\n", "abstract": " Web Services, and in particular REST Web Services [5], are expected to follow a series of conventions, and so it should be possible to create a framework that abstracts the parts of the testing model which are applicable to all such services. This way we would not have to develop tests from scratch for each project but, instead, it would be sufficient to adapt the framework to each set of particular requirements.As a first step, we have developed a simple property-based test model in Quviq QuickCheck [7] giving an idealised model of a REST Web Service. We have adapted this to test two existing Web Services that broadly follow REST principles: Storage Room [15] and Google Tasks [6]. This has shown us how the systems deviate from pure REST, and how to adapt the model accordingly. Quviq\u2019s QuickCheck provides some specific tools that simplify the generation of input data for certain scenarios. In the style of [3] we\u00a0\u2026", "num_citations": "17\n", "authors": ["1052"]}
{"title": "Modeling reactive multimedia: Events and behaviors\n", "abstract": " This paper explores the idea of reactivity in multimedia, and proposes systems which can react to continuously-evolving behaviors as well as to more traditional discrete events. The idea is presented in a scenario as well as in a number of small programming examples.               The illustrative examples are written in the Fran system. Fran provides a high-level programming model for animations, built in the Haskell functional programming language. Whilst we use Fran for illustration\u2014and indeed we argue that the functional paradigm is a natural choice of host for such a system\u2014we should stress that the notion of external behaviors within multimedia is independent of the programming environment chosen and could be incorporated into other systems such as SMIL.", "num_citations": "17\n", "authors": ["1052"]}
{"title": "Implementing SASL using categorical multi-combinators\n", "abstract": " Categorical multi-combinators form a rewriting system developed with the aim of providing efficient implementations of lazy functional languages. The core of the system of categorical multi-combinators consists of only two rewriting laws with a very low pattern-matching complexity. This system allows the equivalent of several-reductions to be performed at once, and avoids the generation of trivially reducible sub-expressions. In this paper we present a method of introducing algebraic data-types and local recursion to categorical multi-combinators which is both efficient and in harmony with the original system. We also show how to compile a subset of SASL into categorical combinators. Some implementation issues are also addressed here. The performance of implementations of categorical multi-combinator SASL machines is analysed here and compared with other implementations of functional languages.", "num_citations": "17\n", "authors": ["1052"]}
{"title": "Evaluating scalable distributed Erlang for scalability and reliability\n", "abstract": " Large scale servers with hundreds of hosts and tens of thousands of cores are becoming common. To exploit these platforms software must be both scalable and reliable, and distributed actor languages like Erlang are a proven technology in this area. While distributed Erlang conceptually supports the engineering of large scale reliable systems, in practice it has some scalability limits that force developers to depart from the standard language mechanisms at scale. In earlier work we have explored these scalability limitations, and addressed them by providing a Scalable Distributed (SD) Erlang library that partitions the network of Erlang Virtual Machines (VMs) into scalable groups (s_groups). This paper presents the first systematic evaluation of SD Erlang s_groups and associated tools, and how they can be used. We present a comprehensive evaluation of the scalability and reliability of SD Erlang using three\u00a0\u2026", "num_citations": "16\n", "authors": ["1052"]}
{"title": "Multicore profiling for Erlang programs using Percept2\n", "abstract": " Erlang is a functional programming language with built-in support for concurrency based on share-nothing processes and asynchronous message passing. The design of Erlang makes it suitable for writing concurrent and parallel applications, taking full advantage of the computing power of modern multicore machines. However many existing Erlang applications are sequential, in need of parallelisation.", "num_citations": "16\n", "authors": ["1052"]}
{"title": "Evolving recursive programs using non-recursive scaffolding\n", "abstract": " Genetic programming has proven capable of evolving solutions to a wide variety of problems. However, the successes have largely been with programs without iteration or recursion; evolving recursive programs has turned out to be particularly challenging. The main obstacle to evolving recursive programs seems to be that they are particularly fragile to the application of search operators: a small change in a correct recursive program generally produces a completely wrong program. In this paper, we present a simple and general method that allows us to pass back and forth from a recursive program to an associated non-recursive program. Finding a recursive program can be reduced to evolving non-recursive programs followed by converting the optimum non-recursive program found to the associated optimum recursive program. This avoids the fragility problem above, as evolution does not search the space of\u00a0\u2026", "num_citations": "16\n", "authors": ["1052"]}
{"title": "A case study in refactoring functional programs\n", "abstract": " Refactoring is the process of redesigning existing code without changing its functionality. Refactoring has recently come to prominence in the OO community. In this paper we explore the prospects for refactoring functional programs. Our paper centres on the case study of refactoring a 400 line Haskell program written by one of our students. The case study illustrates the type and variety of program manipulations involved in refactoring. Similarly to other program transformations, refactorings are based on program equivalences, and thus ultimately on language semantics. In the context of functional languages, refactorings can be based on existing theory and program analyses. However, the use of program transformations for program restructuring emphasises a different kind of transformation from the more traditional derivation or optimisation: characteristically, they often require wholesale changes to a collection of modules, and although they are best controlled by programmers, their application may require nontrivial semantic analyses. The paper also explores the background to refactoring, provides a taxonomy for describing refactorings and draws some conclusions about refactoring for functional programs.", "num_citations": "16\n", "authors": ["1052"]}
{"title": "The type system of Aldor\n", "abstract": " This paper gives a formal description of (at least a part of) the type system of Aldor, the extension language of the computer algebra system AXIOM. In the process of doing this a critique of the design of the system emerges.", "num_citations": "16\n", "authors": ["1052"]}
{"title": "A Normal Form for Spider Diagrams of Order\n", "abstract": " We develop a reasoning system for an Euler diagram based visual logic, called spider diagrams of order. We de- fine a normal form for spider diagrams of order and provide an algorithm, based on the reasoning system, for producing diagrams in our normal form. Normal forms for visual log- ics have been shown to assist in proving completeness of associated reasoning systems. We wish to use the reasoning system to allow future direct comparison of spider diagrams of order and linear temporal logic.", "num_citations": "15\n", "authors": ["1052"]}
{"title": "Refactoring tools for functional languages\n", "abstract": " Refactoring is the process of changing the design of a program without changing what it does. Typical refactorings, such as function extraction and generalisation, are intended to make a program more amenable to extension, more comprehensible and so on. Refactorings differ from other sorts of program transformation in being applied to source code, rather than to a \u2018core\u2019 language within a compiler, and also in having an effect across a code base, rather than to a single function definition, say. Because of this, there is a need to give automated support to the process. This paper reflects on our experience of building tools to refactor functional programs written in Haskell (HaRe) and Erlang (Wrangler). We begin by discussing what refactoring means for functional programming languages, first in theory, and then in the context of a larger example. Next, we address system design and details of system implementation\u00a0\u2026", "num_citations": "15\n", "authors": ["1052"]}
{"title": "From test cases to FSMs: augmented test-driven development and property inference\n", "abstract": " This paper uses the inference of finite state machines from EUnit test suites for Erlang programs to make two contributions. First, we show that the inferred FSMs provide feedback on the adequacy of the test suite that is developed incrementally during the test-driven development of a system. This is novel because the feedback we give is independent of the implementation of the system.", "num_citations": "15\n", "authors": ["1052"]}
{"title": "A functional reactive animation of a lift using Fran\n", "abstract": " This paper uses the Fran system for functional reactive animation to give a simulation of a lift \u2013 or elevator \u2013 with many floors. The paper first introduces a two-floor version, and then indicates in detail how this is extended to give a simulation with an arbitrary number of floors and featuring more realistic animated graphics. The paper introduces those aspects of Fran relevant to the simulation, making it a self-contained tutorial on parts of Fran and how it is applied in practice. The full code for the system is available on the World Wide Web.", "num_citations": "15\n", "authors": ["1052"]}
{"title": "On the equivalence between CMC and TIM\n", "abstract": " In this paper we present an equivalence between TIM, a machine developed to implement non-strict functional programming languages, and the set of Categorical Multi-Combinators, a rewriting system developed with similar aims. These two models of computation at first appear to be quite different, but we show a direct equivalence between them, thereby adding some new structure to the \u2018design-space\u2019 of abstract machines for non-strict languages.", "num_citations": "15\n", "authors": ["1052"]}
{"title": "Improving the network scalability of Erlang\n", "abstract": " As the number of cores grows in commodity architectures so does the likelihood of failures. A distributed actor model potentially facilitates the development of reliable and scalable software on these architectures. Key components include lightweight processes which \u2018share nothing\u2019and hence can fail independently. Erlang is not only increasingly widely used, but the underlying actor model has been a beacon for programming language design, influencing for example Scala, Clojure and Cloud Haskell. While the Erlang distributed actor model is inherently scalable, we demonstrate that it is limited by some pragmatic factors. We address two network scalability issues here: globally registered process names must be updated on every node (virtual machine) in the system, and any Erlang nodes that communicate maintain an active connection. That is, there is a fully connected O (n 2) network of n nodes. We present\u00a0\u2026", "num_citations": "14\n", "authors": ["1052"]}
{"title": "Safe concurrency introduction through slicing\n", "abstract": " Traditional refactoring is about modifying the structure of existing code without changing its behaviour, but with the aim of making code easier to understand, modify, or reuse. In this paper, we introduce three novel refactorings for retrofitting concurrency to Erlang applications, and demonstrate how the use of program slicing makes the automation of these refactorings possible.", "num_citations": "14\n", "authors": ["1052"]}
{"title": "Extracting quickcheck specifications from eunit test cases\n", "abstract": " Writing EUnit tests is more common than writing QuickCheck specifications, although QuickCheck specifications potentially explore far more scenarios than manually written unit tests. In particular for implementations that have side-effects, writing a good set of EUnit tests is often difficult and labour intensive.", "num_citations": "14\n", "authors": ["1052"]}
{"title": "Refactoring in automatically generated programs\n", "abstract": " Refactoring aims at improving the design of ex- isting code by introducing structural modifications without changing its behaviour. It is used to adjust a system\u2019s design in order to facilitate its maintenance and extendability. Since deciding which refactoring to apply and where it should be applied is not a straightforward decision, search-based approaches to automating the task of software refactoring have been proposed recently. So far, these approaches have been applied only to human-written code. Despite many years of computer programming experience, certain problems are very difficult for programmers to solve. To address this, researches have developed methods where computers automatically create program code from a description of the problem to be solved. One of the most popular forms of automated program creation is called Genetic Programming (GP). The aim of this work is to make GP more effective by introducing an automated refactoring step, based on the refactoring work in the software engineering community. We believe that the refactoring step will enhance the ability of GP to produce code that solves more complex problems, as well as result in evolved code that is both simpler and more idiomatically structured than that produced by traditional GP methods.", "num_citations": "14\n", "authors": ["1052"]}
{"title": "A new language for the visualization of logic and reasoning\n", "abstract": " Many visual languages based on Euler diagrams have emerged for expressing relationships between sets. The expressive power of these languages varies, but the majority can only express statements involving unary relations and, sometimes, equality. We present a new visual language called Visual First Order Logic (VFOL) that was developed from work on constraint diagrams which are designed for software specification. VFOL is likely to be useful for software specification, because it is similar to constraint diagrams, and may also fit into a Z-like framework. We show that for every First Order Predicate Logic (FOPL) formula there exists a semantically equivalent VFOL diagram. The translation we give from FOPL to VFOL is natural and, as such, VFOL could also be used to teach FOPL, for example.", "num_citations": "14\n", "authors": ["1052"]}
{"title": "Functional programming: executable specifications and program transformations\n", "abstract": " In this paper we give an example of the use of functional programming language in the specification and development of a program to solve a non-trivial problem. In particular, we show how we can give a direct implementation of a constructive specification (an execuiable specification, in other words) and then show how program transformation can be used to turn this specification into an efficient version of the program, using techniques from a standard library of transformations. We introduce the paper with a short review of functional programming.", "num_citations": "14\n", "authors": ["1052"]}
{"title": "A task-based evaluation of combined set and network visualization\n", "abstract": " This paper addresses the problem of how best to visualize network data grouped into overlapping sets. We address it by evaluating various existing techniques alongside a new technique. Such data arise in many areas, including social network analysis, gene expression data, and crime analysis. We begin by investigating the strengths and weakness of four existing techniques, namely Bubble Sets, EulerView, KelpFusion, and LineSets, using principles from psychology and known layout guides. Using insights gained, we propose a new technique, SetNet, that may overcome limitations of earlier methods. We conducted a comparative crowdsourced user study to evaluate all five techniques based on tasks that require information from both the network and the sets. We established that EulerView and SetNet, both of which draw the sets first, yield significantly faster user responses than Bubble Sets, KelpFusion and\u00a0\u2026", "num_citations": "13\n", "authors": ["1052"]}
{"title": "Spider diagrams of order and a hierarchy of star-free regular languages\n", "abstract": " The spider diagram logic forms a fragment of the constraint diagram logic and was designed to be primarily used as a diagrammatic software specification tool. Our interest is in using the logical basis of spider diagrams and the existing known equivalences between certain logics, formal language theory classes and some automata to inform the development of diagrammatic logics. Such developments could have many advantages, one of which would be aiding software engineers who are familiar with formal languages and automata to more intuitively understand diagrammatic logics. In this paper we consider relationships between spider diagrams of order (an extension of spider diagrams) and the star-free subset of regular languages. We extend the concept of the language of a spider diagram to encompass languages over arbitrary alphabets. Furthermore, the product of spider diagrams is introduced\u00a0\u2026", "num_citations": "13\n", "authors": ["1052"]}
{"title": "Declarative extensions of XML languages\n", "abstract": " We present a set of XML language extensions that bring notions from functional programming to web authors, extending the power of declarative modelling for the web. Our previous work discussed expressions and user-defined events. In this paper, we discuss how one may extend XML by adding definitions and parameterization; complex data and data types; and reactivity, events and continuous\" behaviours\". We consider these extensions in the light of World Wide Web Consortium standards, and illustrate their utility by a variety of use cases.", "num_citations": "13\n", "authors": ["1052"]}
{"title": "Functional programming through the curriculum\n", "abstract": " This paper discusses our experience in using a functional language in topics across the computer science curriculum. After examining the arguments for taking a functional approach, we look in detail at four case studies from different areas: programming language semantics, machine architectures, graphics and formal languages.", "num_citations": "13\n", "authors": ["1052"]}
{"title": "Modelling reactive multimedia: Design and authoring\n", "abstract": " Multimedia document authoring is a multifaceted activity, and authoring tools tend to concentrate on a restricted set of the activities involved in the creation of a multimedia artifact. In particular, a distinction may be drawn between the design and the implementation of a multimedia artifact.               This paper presents a comparison of three different authoring paradigms, based on the common case study of a simple interactive animation. We present details of its implementation using the three different authoring tools, MCF, Fran and SMIL 2.0, and we discuss the conclusions that may be drawn from our comparison of the three approaches.", "num_citations": "12\n", "authors": ["1052"]}
{"title": "Tableaux for diagrammatic reasoning\n", "abstract": " Diagrammatic notations, such as the Unified Modeling Language (UML), are in common use in software development. They allow many aspects of software systems to be described diagrammatically, but typically they rely on textual notations for logical constraints. In contrast, spider diagrams provide a visual notation for expressing a natural class of set- theoretic statements in a diagrammatic form. In this paper we present a tableau system for spider diagrams, and describe an implementation of the system. In a software development context, the system allows users to explore the implications of design choices, and thus to validate specifications; beyond this, the tableau algorithm and system are of general interest to visual reasoners.", "num_citations": "12\n", "authors": ["1052"]}
{"title": "Synchronization in multimedia documents\n", "abstract": " This paper presents a taxonomy of possible synchronization relationships between pairs of items in multimedia documents. Several existing approaches to the synchronization of entire items are reviewed. We then discuss classes of synchronization based upon dynamic events or conditions occurring within media items and their internal structure. We present a taxonomy of seventy-two possible such relations, which are illustrated by numerous examples and which are formalized in the authors' temporal logic notation, Mexitl. The ideas are then applied to provide a description of the lip-synchronization problem.", "num_citations": "12\n", "authors": ["1052"]}
{"title": "Automating property-based testing of evolving web services\n", "abstract": " Web services are the most widely used service technology that drives the Service-Oriented Computing~(SOC) paradigm. As a result, effective testing of web services is getting increasingly important. In this paper, we present a framework and toolset for testing web services and for evolving test code in sync with the evolution of web services. Our approach to testing web services is based on the Erlang programming language and QuviQ QuickCheck, a property-based testing tool written in Erlang, and our support for test code evolution is added to Wrangler, the Erlang refactoring tool.", "num_citations": "11\n", "authors": ["1052"]}
{"title": "Refactoring support for modularity maintenance in Erlang\n", "abstract": " Low coupling between modules and high cohesion inside each module are key features of good software architecture. Systems written in modern programming languages generally start with some reasonably well-designed module structure, however with continuous feature additions, modifications and bug fixes, software modularity gradually deteriorates. So, there is a need for incremental improvements to modularity to avoid the situation when the structure of the system becomes too complex to maintain. We demonstrate how Wrangler, a general-purpose refactoring tool for Erlang, can be used to maintain and improve the modularity of programs written in Erlang without dramatically changing the existing module structure. We identify a set of \"modularity smells\", and show how they can be detected by Wrangler and removed by way of a variety of refactorings implemented in Wrangler. Validation of the approach\u00a0\u2026", "num_citations": "11\n", "authors": ["1052"]}
{"title": "Regular expressions and automata using Haskell\n", "abstract": " The paper begins with definitions of regular expressions, and how strings are matched to them; this also gives our first Haskell treatment also. After describing the abstract data type of sets we define non-deterministic finite automata, and their implementation in Haskell. We then show how to build an NFA corresponding to each regular expression, and how such a machine can be optimised, first by transforming it into a deterministic machine, and then by minimising the state space of the DFA. We conclude with a discussion of regular definitions, and show how recognisers for strings matching regular definitions can be built.", "num_citations": "11\n", "authors": ["1052"]}
{"title": "Automated API migration in a user-extensible refactoring tool for Erlang programs\n", "abstract": " Wrangler is a refactoring and code inspection tool for Erlang programs. Apart from providing a set of built-in refactorings and code inspection functionalities, Wrangler allows users to define refactorings, code inspections, and general program transformations for themselves to suit their particular needs. These are defined using a template- and rule-based program transformation and analysis framework built into Wrangler. This paper reports an extension to Wrangler's extension framework, supporting the automatic generation of API migration refactorings from a user-defined adapter module.", "num_citations": "10\n", "authors": ["1052"]}
{"title": "Incremental code clone detection and elimination for Erlang programs\n", "abstract": " A well-known bad code smell in refactoring and software maintenance is the existence of code clones, which are code fragments that are identical or similar to one another. This paper describes an approach to incrementally detecting 'similar' code based on the notion of least-general common abstraction, or anti-unification, as well as a framework for user-controlled incremental elimination of code clones within the context of Erlang programs. The clone detection algorithm proposed in this paper achieves 100 precision, high recall rate, and is user-customisable regarding the granularity of the clone classes reported. By detecting and eliminating clones in an incremental way, we make it possible for the tool to be used in an interactive way even with large codebases. Both the clone detection and elimination functionalities are integrated with Wrangler, a tool for interactive refactoring of Erlang programs. We evaluate the approach with various case studies.", "num_citations": "10\n", "authors": ["1052"]}
{"title": "Improving your test code with Wrangler\n", "abstract": " In this paper we show how the 'similar code' detection facilities of Wrangler, combined with its portfolio of refactorings, allow test code to be shrunk dramatically, under the guidance of the test engineer. This is illustrated by a sequence of refactorings of a test suite taken from an Erlang project at Ericsson AB.", "num_citations": "10\n", "authors": ["1052"]}
{"title": "Extracting properties from test cases by refactoring\n", "abstract": " A Quick Check property is a logical statement of aspects of the behaviour of a system. We report on how similar test cases in a test suite written in Erlang can be identified and then refactored into properties, giving a generalisation of the specification implicit in the test suite. Properties give more concise, easier to maintain test suites and better test coverage. A preliminary evaluation of the techniques in industry demonstrates feasibility as well as potential benefits.", "num_citations": "9\n", "authors": ["1052"]}
{"title": "Integrating computer algebra and reasoning through the type system of Aldor\n", "abstract": " A number of combinations of reasoning and computer algebra systems have been proposed; in this paper we describe another, namely a way to incorporate a logic in the computer algebra system Axiom. We examine the type system of Aldor \u2013 the Axiom Library Compiler \u2013 and show that with some modifications we can use the dependent types of the system to model a logic, under the Curry-Howard isomorphism. We give a number of example applications of the logic we construct and explain a prototype implementation of a modified type-checking system written in Haskell.", "num_citations": "9\n", "authors": ["1052"]}
{"title": "A complete axiomatization of Interval Temporal Logic with projection\n", "abstract": " This paper presents a complete axiomatisation for propositional interval temporal logic (PITL) with projection. The axiomatisation is based on a tableau procedure for the logic, which in turn is founded upon a normal form for PITL formluae. The construction of the axiomatisation is modular, in the sense that given a normal form for a new connective, axioms can be generated for the connective from the tableau construction. The paper concludes with a discussion of aspects of compositionality for PITL with projection.", "num_citations": "9\n", "authors": ["1052"]}
{"title": "Are subsets necessary in Martin-L\u00f6f type theory?\n", "abstract": " To summarise, there are two responses to the use of subsets in type theory. Their use in separating the computational from the proof theoretic can be achieved using the appropriate names for functions whose existence is assured by the validity of the axiom of choice in type theory.             If proof theoretic information remains in an expression, we contend that if it is indeed irrelevant to the computational behaviour of a function, it will not be evaluated under a lazy evaluation strategy, and so we advocate this as an implementation technique which avoids the unnecessary evaluation which is a consequence of a strict evaluation scheme. As we mentioned earlier, there will be some cases in which structures are formed needlessly \u2014 we see their elimination as the role of the implementation of the system, and would view abstract interpretation as an ideal tool for this purpose.             Using the subset type to\u00a0\u2026", "num_citations": "9\n", "authors": ["1052"]}
{"title": "Towards Trustworthy Refactoring in Erlang\n", "abstract": " Tool-assisted refactoring transformations must be trustworthy if programmers are to be confident in applying them on arbitrarily extensive and complex code in order to improve style or efficiency. We propose a simple, high-level but rigorous, notation for defining refactoring transformations in Erlang, and show that this notation provides an extensible, verifiable and executable specification language for refactoring. To demonstrate the applicability of our approach, we show how to define and verify a number of example refactorings in the system.", "num_citations": "8\n", "authors": ["1052"]}
{"title": "Constructive interval temporal logic in Alf\n", "abstract": " This paper gives an implementation of an interval temporal logic in a constructive type theory, using the Alf proof system. After explaining the constructive approach, its relevance to interval temporal logic and potential applications of our work, we explain the fundamentals of the Alf system. We then present the implementation of the logic and give a number of examples of its use. We conclude by exploring how the work can be extended in the future.", "num_citations": "8\n", "authors": ["1052"]}
{"title": "Functional programming in education\u2013Introduction\n", "abstract": " //static.cambridge.org/content/id/urn%3Acambridge.org%3Aid%3Aarticle%3AS0956796800000563/resource/name/firstPage-S0956796800000563a.jpg", "num_citations": "8\n", "authors": ["1052"]}
{"title": "Marlowe: implementing and analysing financial contracts on blockchain\n", "abstract": " Marlowe is a DSL for financial contracts. We describe the implementation of Marlowe on the Cardano blockchain, and the Marlowe Playground web-based development and simulation environment. Contracts in Marlowe can be exhaustively analysed prior to running them, thus providing strong guarantees to participants in the contract. The Marlowe system itself has been formally verified using the Isabelle theorem prover, establishing such properties as the conservation of money.", "num_citations": "7\n", "authors": ["1052"]}
{"title": "From ACT-ONE to Miranda, a translation experiment\n", "abstract": " It is now almost universally acknowledged that the data language ACT-ONE associated with the formal description technique LOTOS is inappropriate for the purpose of OSI formal description. In response to this the LOTOS restandardisation activity plans to replace ACT-ONE with a functional language. Thus, compatibility between ACT-ONE and the replacement data language becomes an issue. In response to this, we present an experimental investigation of backward compatibility between ACT-ONE and the new LOTOS data language. Specifically, we investigate translating ACT-ONE data types into the functional language Miranda. Miranda has been chosen as it is a widely used functional programming language and it is close in form to the anticipated new data language. This work serves as a `verification of concept' for translating ACT-ONE to the E-LOTOS data language. It identifies the bounds on embedding\u00a0\u2026", "num_citations": "7\n", "authors": ["1052"]}
{"title": "Multi-level visualization of concurrent and distributed computation in Erlang\n", "abstract": " This paper describes a prototype visualization system for concurrent and distributed applications programmed using Erlang, providing two levels of granularity of view. Both visualizations are animated to show the dynamics of aspects of the computation.  At the low level, we show the concurrent behaviour of the Erlang schedulers on a single instance of the Erlang virtual machine, which we call an Erlang node. Typically there will be one scheduler per core on a multicore system. Each scheduler maintains a run queue of processes to execute, and we visualize the migration of Erlang concurrent processes from one run queue to another as work is redistributed to fully exploit the hardware. The schedulers are shown as a graph with a circular layout. Next to each scheduler we draw a variable length bar indicating the current size of the run queue for the scheduler.  At the high level, we visualize the distributed aspects of the system, showing interactions between Erlang nodes as a dynamic graph drawn with a force model. Speci?cally we show message passing between nodes as edges and lay out nodes according to their current connections. In addition, we also show the grouping of nodes into \u201cs_groups\u201d using an Euler diagram drawn with circles.", "num_citations": "6\n", "authors": ["1052"]}
{"title": "Interactive functional programming\n", "abstract": " CiNii \u8ad6\u6587 - Interactive functional programming CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3 ] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7 \u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 Interactive functional programming THOMPSON Simon \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 THOMPSON Simon \u53ce\u9332\u520a\u884c\u7269 Research Topics in Functional Programming Research Topics in Functional Programming, 1990 Addison-Wesley Publishing Company \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u64ec\u30c7\u30fc\u30bf\u3068\u95a2\u6570\u306b\u3088\u308b\u4e26\u884c\u30d7\u30ed\u30bb\u30b9\u7fa4\u306e\u8a18\u8ff0 \u77f3\u4e95 \u88d5\u4e00\u90ce , \u6b66\u5e02 \u6b63\u4eba \u96fb\u5b50\u60c5\u5831\u901a\u4fe1\u5b66\u4f1a\u6280\u8853\u7814\u7a76 \u5831\u544a. COMP, \u30b3\u30f3\u30d4\u30e5\u30c6\u30fc\u30b7\u30e7\u30f3 96(487), 1-8, 1997-01-23 \u53c2\u8003\u6587\u732e25\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10022187362 \u8cc7\u6599\u7a2e\u5225 \u56f3\u66f8\u306e\u4e00\u90e8 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u2026", "num_citations": "6\n", "authors": ["1052"]}
{"title": "Characterising renaming within ocaml\u2019s module system: theory and implementation\n", "abstract": " We present an abstract, set-theoretic denotational semantics for a significant subset of OCaml and its module system, allowing to reason about the correctness of renaming value bindings. Our semantics captures information about the binding structure of programs, as well as about which declarations are related by the use of different language constructs (eg functors, module types and module constraints). Correct renamings are precisely those that preserve this structure. We show that our abstract semantics is sound with respect to a (domain-theoretic) denotational model of the operational behaviour of programs, and that it allows us to prove various high-level, intuitive properties of renamings. This formal framework has been implemented in a prototype refactoring tool for OCaml that performs renaming.", "num_citations": "5\n", "authors": ["1052"]}
{"title": "Testing-framework-aware Refactoring\n", "abstract": " Testing is the predominant way of establishing evidence that a program meets it requirements. When both test code and the application under test are written in the same programming language, a refactoring tool for this language should be able to refactor both application code and testing code together. However, testing frameworks normally come with particular programming idioms, such as their use of naming conventions, coding patterns, meta-programming techniques and the like. A refactoring tool needs to be aware of those programming idioms in order to refactor test code properly. Meanwhile the particularities of test code also suggest refactorings that are particularly applicable to test code. In this paper we present our experience of extending Wrangler, a refactoring tool for the Erlang programming language, so as to handle the three common testing frameworks for Erlang, as well as discussing the refactoring of test code in its own right.", "num_citations": "5\n", "authors": ["1052"]}
{"title": "Logic and dependent types in the Aldor Computer Algebra System\n", "abstract": " We show how the Aldor type system can represent propositions of first-order logic, by means of the \u2018propositions as types\u2019 correspondence. The representation relies on type casts (using pretend) but can be viewed as a prototype implementation of a modified type system with type evaluation reported elsewhere/9]. The logic is used to provide an a\u017fpiomatisation of a number of familiar Aldor categories as well as a type of vectors.", "num_citations": "5\n", "authors": ["1052"]}
{"title": "Behavioral Reactivity and Real Time Programming in XML\n", "abstract": " XML and its associated languages are emerging as powerful authoring tools for multimedia and hypermedia web content. Furthermore, intelligent presentation generation engines have begun to appear, as have models and platforms for adaptive presentations. However, XML-based models are limited by their lack of expressiveness in presentation and animation. As a result, authors of dynamic, adaptive web content must often use considerable amounts of script or code. The use of such script or code has two serious drawbacks. First, such code undermines the declarative description possible in the original presentation language, and second, the scripting/coding approach does not readily lend itself to authoring by non-programmers. In this paper we describe a set of XML language extensions, inspired by features from the functional programming world, which are designed to widen the class of reactive systems which could be described in languages such as SMIL. The features which we discuss extend the power of declarative modeling for the web by allowing the introduction of web media items which may dynamically react to continuously varying inputs, both in a continuous way and by triggering discrete, user-defined, events. The two extensions described herein are discussed in the context of SMIL Animation and SVG, but could be applied to many XML-based languages.", "num_citations": "5\n", "authors": ["1052"]}
{"title": "Making Property-Based Testing Easier To Read For Humans.\n", "abstract": " Software stakeholders who do not have a technical profile (ie users, clients) but do want to take part in the development and/or quality assurance process of software, have an unmet need for communication on what is being tested during the development life-cycle. The transformation of test properties and models into semi-natural language representations is one way of responding to such need. Our research has demonstrated that these transformations are challenging but feasible, and they have been implemented into a prototype tool called readSpec. The readSpec tool transforms universally-quantified test properties and stateful test models\u2013the two kinds of test artifacts used in property-based testing\u2013into plain text interpretations. The tool has been successfully evaluated on the PBT artifacts produced and used within the FP7 PROWESS project by industrial partners.", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Model extraction and test generation from JUnit test suites\n", "abstract": " In this paper we describe how to infer state machine models of systems from legacy unit test suites, and how to generate new tests from those models. The novelty of our approach is to combine control dependencies and data dependencies in the same model, in contrast to most other work in this area. Combining both kinds of dependency helps us to build more expressive models, which in turn allows us to produce smarter tests. We illustrate those techniques with examples from our implementation, the James tool, designed to apply these techniques in practice to Java code and tests.", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Fragments of spider diagrams of order and their relative expressiveness\n", "abstract": " Investigating the expressiveness of a diagrammatic logic provides insight into how its syntactic elements interact at the semantic level. Moreover, it allows for comparisons with other notations. Various expressiveness results for diagrammatic logics are known, such as the theorem that Shin\u2019s Venn-II system is equivalent to monadic first order logic. The techniques employed by Shin for Venn-II were adapted to allow the expressiveness of Euler diagrams to be investigated. We consider the expressiveness of spider diagrams of order (SDoO), which extend spider diagrams by including syntax that provides ordering information between elements. Fragments of SDoO are created by systematically removing each aspect of the syntax. We establish the relative expressiveness of the various fragments. In particular, one result establishes that spiders are syntactic sugar in any fragment that contains order, negation\u00a0\u2026", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Porting HaRe to the GHC API\n", "abstract": " This technical report details a project occurring between February and July of 2005. The aim of the project was to assess the effort required to port the Haskell [6] refactoring tool, HaRe [4], from its current compiler front-end system, Programmatica, to the newly developed GHC [5] API.", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Programming language semantics using Miranda\n", "abstract": " This paper explains the use of the functional programming language Miranda as a vehicle for describing the semantics of imperative programming languages. In particular we give a Miranda denotational description of a substantial subset of a Pascal-like language, describing a number of variants of the semantics, including parameter passing by value-result, dynamic binding of values to names and a simple semantics of jumps. We also give an executable operational semantics of our basic language, as well as a compiler for this language into a simple stack machine, which is itself modelled in Miranda.", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Miranda in Isabelle\n", "abstract": " This paper describes our experience in formalising arguments about the Miranda functional programming language in Isabelle. After explaining some of the problems of reasoning about Miranda, we explain our two different approaches to encoding Miranda in Isabelle. We conclude by discussing some shorter examples and a case study of reasoning about hardware.", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Regular expressions and automata using Miranda\n", "abstract": " In these notes Miranda is used as a vehicle to introduce regular expressions, pattern matching, and their implementations by means of non-deterministic and deterministic automata. As part of the material, we give an implementation of the ideas, contained in a set of files. References to this material are scattered through the text. The files can be obtained by following the instructions in medskip noindent tt http://www.ukc.ac.uk/computer_science/Miranda_craft/regExp.html medskip noindent This material is based on the treatment of the subject in `the Dragon book', but provides full implementations rather than their pseudo-code versions of the algorithms. The material gives an illustration of many of the features of Miranda, including polymorphism (the states of an NFA can be represented by objects of any type); modularisation (the system is split across a number of modules); higher-order functions (used in finding limits of processes, for example) and other features.", "num_citations": "4\n", "authors": ["1052"]}
{"title": "Machine-checked natural semantics for Core Erlang: exceptions and side effects\n", "abstract": " This research is part of a wider project that aims to investigate and reason about the correctness of scheme-based source code transformations of Erlang programs. In order to formally reason about the definition of a programming language and the software built using it, we need a mathematically rigorous description of that language.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "A Proof Assistant Based Formalisation of a Subset of Sequential Core Erlang\n", "abstract": " We present a proof-assistant-based formalisation of a subset of Erlang, intended to serve as a base for proving refactorings correct. After discussing how we reused concepts from related work, we show the syntax and semantics of our formal description, including the abstractions involved (e.g. the concept of a closure). We also present essential properties of the formalisation (e.g. determinism) along with the summary of their machine-checked proofs. Finally, we prove expression pattern equivalences which can be interpreted as simple local refactorings.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "Improved semantics and implementation through property-based testing with QuickCheck\n", "abstract": " Testing is the primary method to validate that a software implementation meets its specification. In this paper, we demonstrate an approach to validating an executable semantics using property-and model-based random testing in QuickCheck to automate and unify the testing of the semantics and its implementation. Our approach shows the use of executable semantics to bridge the gap between formal mathematical specification and implementation, as well as emphasising the suitability of functional programming languages--in this case Erlang--for writing executable semantics.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "On the completeness of spider diagrams augmented with constants\n", "abstract": " Diagrammatic reasoning can be described formally by a number of diagrammatic logics; spider diagrams are one of these, and are used for expressing logical statements about set membership and containment. Here, existing work on spider diagrams is extended to include constant spiders that represent specific individuals. We give a formal syntax and semantics for the extended diagram language before introducing a collection of reasoning rules encapsulating logical equivalence and logical consequence. We prove that the resulting logic is sound, complete and decidable.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "Erlang behaviours: programming with process design patterns\n", "abstract": " Erlang processes run independently of each other, each using separate memory and communicating with each other by message passing. These processes, while executing different code, do so following a number of common patterns. By examining different examples of Erlang-style concurrency in client/server architectures, we identify the generic and specific parts of the code and extract the generic code to form a process skeleton. In Erlang, the most commonly used patterns have been implemented in library modules, commonly referred to as OTP behaviours. They contain the generic code framework for concurrency and error handling, simplifying the complexity of concurrent programming and protecting the developer from many common pitfalls.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "A Certified Refactoring Engine\n", "abstract": " The paper surveys how software tools such as refactoring systems can be validated, and introduces a new mechanism, namely the extraction of a refactoring engine for a functional programming language from an Isabelle/HOL theory in which it is verified. This research is a first step in a programme to construct certified programming tools from verified theories. We also provide some empirical evidence of how refactoring can be of significant benefit in reshaping automatically-generated program code for use in larger systems.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "A tableau method for interval temporal logic\n", "abstract": " In this paper we present a complete tableau method for interval temporal logic including the projection operator. Central to our strategy is the identification of normal forms for all the operators of our logic. In effect, these normal forms give inductive definitions of the ITL operators. Then, in the style of Wolper, we define a tableau decision procedure to check satisfiability of our logic. For simplicity of presentation we work in the propositional setting.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "How to program it\n", "abstract": " The Mathematics Education program is a joint program between the College of Education (which teaches the content-specific pedagogy courses) and the College of Arts and Sciences (which teaches the content courses). At present, there is no separate middle grades program for mathematics education; rather, all prospective secondary mathematics teachers complete a program designed to provide certification for grades 6\u201312. Consequently, preservice teachers participate in courses that focus on middle grades issues as well as on those that focus on high school issues. Because the program covers 6\u201312, all prospective middle school and high school teachers receive the same mathematics background, differing only slightly from that of a mathematics major.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "Axiomatic recursion theory and the continuous functionals\n", "abstract": " We define, in the spirit of Fenstad [2], a higher type computation theory, and show that countable recursion over the continuous functionals forms such a theory. We also discuss Hyland's proposal from [4] for a scheme with which to supplement S1\u2013S9, and show that this augmented set of schemes fails to generate countable recursion. We make another proposal to which the methods of this section do not apply.", "num_citations": "3\n", "authors": ["1052"]}
{"title": "Recursion theories on the continuous functionals.\n", "abstract": " British Library EThOS: Recursion theories on the continuous functionals. New search | Advanced search | Search results Login / Register | About | Help | FAQ | Follow dividing line Use this URL to cite or link to this record in EThOS: https://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.353131 Title: Recursion theories on the continuous functionals. Author: Thompson, S. Awarding Body: University of Oxford Current Institution: University of Oxford Date of Award: 1984 Availability of Full Text: Full text unavailable from EThOS. Please contact the current institution\u2019s library for further details. Abstract: No abstract available Supervisor: Not available Sponsor: Not available Qualification Name: Thesis (Ph.D.) Qualification Level: Doctoral EThOS ID: uk.bl.ethos.353131 DOI: Not available Keywords: Functional analysis Share: Terms and Conditions | Notice and Takedown Policy | Privacy Policy | Sitemap | Contact us Copyright \u00a9 \u2026", "num_citations": "3\n", "authors": ["1052"]}
{"title": "A Comparison of Big-step Semantics Definition Styles\n", "abstract": " Formal semantics provides rigorous, mathematically precise definitions of programming languages, with which we can argue about program behaviour and program equivalence by formal means; in particular, we can describe and verify our arguments with a proof assistant. There are various approaches to giving formal semantics to programming languages, at different abstraction levels and applying different mathematical machinery: the reason for using the semantics determines which approach to choose. In this paper we investigate some of the approaches that share their roots with traditional relational big-step semantics, such as (a) functional big-step semantics (or, equivalently, a definitional interpreter), (b) pretty-big-step semantics and (c) traditional natural semantics. We compare these approaches with respect to the following criteria: executability of the semantics definition, proof complexity for typical properties (e.g. determinism) and the conciseness of expression equivalence proofs in that approach. We also briefly discuss the complexity of these definitions and the coinductive big-step semantics, which enables reasoning about divergence. To enable the comparison in practice, we present an example language for comparing the semantics: a sequential subset of Core Erlang, a functional programming language, which is used in the intermediate steps of the Erlang/OTP compiler. We have already defined a relational big-step semantics for this language that includes treatment of exceptions and side effects. The aim of this current work is to compare our big-step definition for this language with a variety of other equivalent semantics in\u00a0\u2026", "num_citations": "2\n", "authors": ["1052"]}
{"title": "The pragmatics of clone detection and elimination\n", "abstract": " The occurrence of similar code, or `code clones', can make program code difficult to read, modify and maintain. This paper describes industrial case studies of clone detection and elimination using a refactoring and clone detection tool. We discuss how the studies have informed the design of the tool; more importantly, we use the studies to illustrate the complex set of decisions that have to be taken when performing clone elimination in practice. The case studies were performed in collaboration with engineers from Ericsson AB, and used the refactoring tool Wrangler for Erlang. However, the conclusions we draw are largely language-independent, and set out the pragmatics of clone detection and elimination in real-world projects as well as design principles for clone detection decision-support tools.", "num_citations": "2\n", "authors": ["1052"]}
{"title": "Rotor: First steps towards a refactoring tool for ocaml\n", "abstract": " Dedicated tools for automatically performing program refactorings bring major improvements in productivity and reliability during refactoring [1, 6]. Although some tools provide limited support for localised refactoring tasks (eg merlin\u2019s identifier renaming), there is currently no general purpose automatic refactoring tool for the OCaml language. In this talk, we report on our efforts in developing Rotor1, a prototype of such a tool [5]. The OCaml setting brings its own collection of unique challenges for refactoring, and we discuss some of these with reference to a concrete refactoring\u2014the renaming of a value binding in a given module\u2014and in the context of a real-world codebase, namely Jane Street\u2019s Core library [4].", "num_citations": "2\n", "authors": ["1052"]}
{"title": "Euler diagram-based notations\n", "abstract": " Euler diagrams have been used for centuries as a means for conveying logical statements in a simple, intuitive way. They form the basis of many diagrammatic notations used to represent set-theoretic relationships in a wide range of contexts including software modelling, logical reasoning systems, statistical data representation, database search queries and file system management. In this paper we survey notations based on Euler diagrams with particular emphasis on formalization and the development of software tool support.", "num_citations": "2\n", "authors": ["1052"]}
{"title": "Progress on HaRe: the Haskell Refactorer\n", "abstract": " Li, Huiqing and Reinke, Claus and Thompson, Simon (2004) Progress on HaRe: the Haskell Refactorer. Other. kent university (Unpublished)(The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided)(KAR id: 14111)", "num_citations": "2\n", "authors": ["1052"]}
{"title": "Aldor meets Haskell\n", "abstract": " As part of a project to include reasoning capabilities in the Aldor computer algebra system it is necessary to modify the type checking algorithm in Aldor. This paper reports on work to write Aldor abstract syntax trees as elements of Haskell data types, and to implement a prototype modified type checker for Aldor in Haskell.", "num_citations": "2\n", "authors": ["1052"]}
{"title": "Efficient Static Analysis of Marlowe Contracts\n", "abstract": " SMT solvers can verify properties automatically and efficiently, and they offer increasing flexibility on the ways those properties can be described. But it is hard to predict how those ways of describing the properties affect the computational cost of verifying them. In this paper, we discuss what we learned while implementing and optimising the static analysis for Marlowe, a domain specific language for self-enforcing financial smart-contracts that can be deployed on a blockchain.", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Validating Formal Semantics by Property-Based Cross-Testing\n", "abstract": " To describe the behaviour of programs in a programming language we can define a formal semantics for the language, and formalise it in a proof assistant. From this semantics we can derive the behaviour of each particular program in the language. But there remains the question of validating the formal semantics: have we got the formalisation right?", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Identifying and introducing interfaces and callbacks using Wrangler\n", "abstract": " Duplicating code can make it easier to read in some contexts, but in general it is detrimental in several ways: it increases the compilation time, the size of the source code and, more critically, the cost of maintenance and the probability of introducing new bugs during maintenance.", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Scalable SD Erlang reliability model\n", "abstract": " This technical report presents the work we have conducted to support SD Erlang reliability and to formally specify the semantics of s groups. We have considered the following aspects of SD Erlang reliability: node recovery after failures and s group name uniqueness.", "num_citations": "1\n", "authors": ["1052"]}
{"title": "On the expressiveness of spider diagrams and commutative star-free regular languages\n", "abstract": " Spider diagrams provide a visual logic to express relations between sets and their elements, extending the expressiveness of Venn diagrams. Sound and complete inference systems for spider diagrams have been developed and it is known that they are equivalent in expressive power to monadic first-order logic with equality, MFOL [=]. In this paper, we further characterize their expressiveness by articulating a link between them and formal languages. First, we establish that spider diagrams define precisely the languages that are finite unions of languages of the form K \u0393\u204e, where K is a finite commutative language and \u0393 is a finite set of letters. We note that it was previously established that spider diagrams define commutative star-free languages. As a corollary, all languages of the form K \u0393\u204e are commutative star-free languages. We further demonstrate that every commutative star-free language is also such a finite\u00a0\u2026", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Erlang by Example\n", "abstract": " Cesarini, Francesco and Thompson, Simon (2011) Erlang by Example. UNSPECIFIED.(The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided)(KAR id: 30718)", "num_citations": "1\n", "authors": ["1052"]}
{"title": "HaRe\u2013The Haskell Refactorer\n", "abstract": " HaRe The Haskell Refactorer Page 1 HaRe The Haskell Refactorer Huiqing Li Claus Reinke Simon Thompson Computing Lab, University of Kent www.cs.kent.ac.uk/projects/refactor-fp/ Page 2 2 Outline \u2022 Introduction \u2022 HaRe: The Haskell Refactorer \u2022 Demo of HaRe \u2022 The Implementation of HaRe \u2022 Current Work \u2022 Future Work Page 3 3 Outline \u2022 Introduction \u2022 HaRe: The Haskell Refactorer \u2022 Demo of HaRe \u2022 The Implementation of HaRe \u2022 Current Work \u2022 Future Work Page 4 4 Refactoring \u2022 What? Changing the structure of existing code \u2026 \u2026 without changing its meaning. \u2022 Essential part of the functional programming process. \u2022 Where? Development, maintenance, \u2026 -- to make the code easier to understand and modify -- to improve code reuse, quality and productivity. \u2022 Not just programming \u2026 also proof, presentation, \u2026 Page 5 5 A Simple Example module Main where pow = 2 f [] = 0 f (h:t) = h^pow + f t main = print $ f [1..\u2026", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Mobile robot localization using circular correlations of panoramic images\n", "abstract": " In order to determine both location and orientation of a mobile robot, we use omni-directional view images from a camera mounted on top of the robot. Images are sampled circularly on rings at various radii.Correlation values between rings of different images are regarded as the similarity of the image, therefore the similarity of locations. Using real images taken at different times in navigation experiments, we computed correlation values normalized by bright-ness, and confirmed the robot can be localized in 50cm to 100cm range with 3-10 degree orientation accuracy. The idea of using aggregated sum of circular samples for representing landmarks at multi-ple levels is also presented.", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Verifying Fran Programs\n", "abstract": " Fran is a system for functional reactive animation. This note explores the way that some of the features of Fran can be interpreted as logical formulas, referring in particular to the example of a lift animation written in Fran.[First written November 1998; revised February and April 1999.]", "num_citations": "1\n", "authors": ["1052"]}
{"title": "Proving properties of functions defined on lawful types\n", "abstract": " Thompson, Simon (1986) Proving properties of functions defined on lawful types. Technical report. Computing Laboratory, University of Kent, University of Kent, Canterbury, UK (The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided)(KAR id: 20917)", "num_citations": "1\n", "authors": ["1052"]}