{"title": "Secure Information Flow and Pointer Confinement in a Java-like Language.\n", "abstract": " We consider a sequential object-oriented language with pointers and mutable state, private fields and classbased visibility, dynamic binding and inheritance, recursive classes, casts and type tests, and recursive methods. Programs are annotated with security levels, constrained by security typing rules. A noninterference theorem shows how the rules ensure pointer confinement and secure information flow.", "num_citations": "233\n", "authors": ["676"]}
{"title": "Stack-based access control and secure information flow\n", "abstract": " Access control mechanisms are often used with the intent of enforcing confidentiality and integrity policies, but few rigorous connections have been made between information flow and runtime access control. The Java virtual machine and the .NET runtime system provide a dynamic access control mechanism in which permissions are granted to program units and a runtime mechanism checks permissions of code in the calling chain. We investigate a design pattern by which this mechanism can be used to achieve confidentiality and integrity goals: a single interface serves callers of more than one security level and dynamic access control prevents release of high information to low callers. Programs fitting this pattern would be rejected by previous flow analyses. We give a static analysis that admits them, using permission-dependent security types. The analysis is given for a class-based object-oriented language\u00a0\u2026", "num_citations": "198\n", "authors": ["676"]}
{"title": "Friends need a bit more: Maintaining invariants over shared state\n", "abstract": " In the context of a formal programming methodology and verification system for ownership-based invariants in object-oriented programs, a friendship system is defined. Friendship is a flexible protocol that allows invariants expressed over shared state. Such invariants are more expressive than those allowed in exisiting ownership type systems because they link objects that are not in the same ownership domain. Friendship permits the modular verification of cooperating classes. This paper defines friendship, sketches a soundness proof, and provides several realistic examples.", "num_citations": "150\n", "authors": ["676"]}
{"title": "Regional logic for local reasoning about global invariants\n", "abstract": " Shared mutable objects pose grave challenges in reasoning, especially for data abstraction and modularity. This paper presents a novel logic for error-avoiding partial correctness of programs featuring shared mutable objects. Using a first order assertion language, the logic provides heap-local reasoning about mutation and separation, via ghost fields and variables of type \u2018region\u2019 (finite sets of object references). A new form of modifies clause specifies write, read, and allocation effects using region expressions; this supports effect masking and a frame rule that allows a command to read state on which the framed predicate depends. Soundness is proved using a standard program semantics. The logic facilitates heap-local reasoning about object invariants: disciplines such as ownership are expressible but not hard-wired in the logic.", "num_citations": "139\n", "authors": ["676"]}
{"title": "Expressive declassification policies and modular static enforcement\n", "abstract": " This paper provides a way to specify expressive declassification policies, in particular, when, what, and where policies that include conditions under which downgrading is allowed. Secondly, an end-to-end semantic property is introduced, based on a model that allows observations of intermediate low states as well as termination. An attacker's knowledge only increases at explicit declassification steps, and within limits set by policy. Thirdly, static enforcement is provided by combining type-checking with program verification techniques applied to the small subprograms that carry out declassifications. Enforcement is proved sound for a simple programming language and the extension to object-oriented programs is described.", "num_citations": "138\n", "authors": ["676"]}
{"title": "Representation independence, confinement and access control\n", "abstract": " Denotational semantics is given for a Java-like language with pointers, subclassing and dynamic dispatch, class oriented visibility control, recursive types and methods, and privilege-based access control. Representation independence (relational parametricity) is proved, using a semantic notion of confinement similar to ones for which static disciplines have been recently proposed.", "num_citations": "136\n", "authors": ["676"]}
{"title": "Ownership confinement ensures representation independence for object-oriented programs\n", "abstract": " Representation independence formally characterizes the encapsulation provided by language constructs for data abstraction and justifies reasoning by simulation. Representation independence has been shown for a variety of languages and constructs but not for shared references to mutable state; indeed it fails in general for such languages. This article formulates representation independence for classes, in an imperative, object-oriented language with pointers, subclassing and dynamic dispatch, class oriented visibility control, recursive types and methods, and a simple form of module. An instance of a class is considered to implement an abstraction using private fields and so-called representation objects. Encapsulation of representation objects is expressed by a restriction, called confinement, on aliasing. Representation independence is proved for programs satisfying the confinement condition. A static\u00a0\u2026", "num_citations": "124\n", "authors": ["676"]}
{"title": "Information flow monitor inlining\n", "abstract": " In recent years it has been shown that dynamic monitoring can be used to soundly enforce information flow policies. For programs distributed in source or bytecode form, the use of just-in-time (JIT) compilation makes it difficult to implement monitoring by modifying the language runtime system. An inliner avoids this problem and also serves to provide monitoring for more than one runtime. We show how to inline an information flow monitor, specifically a flow sensitive one previously proved to enforce termination insensitive noninterference. We prove that the inlined version is observationally equivalent to the original.", "num_citations": "96\n", "authors": ["676"]}
{"title": "Deriving an information flow checker and certifying compiler for java\n", "abstract": " Language-based security provides a means to enforce end-to-end confidentiality and integrity policies in mobile code scenarios, and is increasingly being contemplated by the smart-card and mobile phone industry as a solution to enforce information flow and resource control policies. Two threads of work have emerged in research on language-based security: work that focuses on enforcing security policies for source code, which is tailored towards developers that want to increase confidence in their applications, and work that focuses on efficiently verifying similar policies for byte-code, which is tailored to code consumers that want to protect themselves against hostile applications. These lines of work serve different purposes - and thus have been developed independently - but connecting them is a key step towards the deployment of language-based security in practical applications. This paper introduces a\u00a0\u2026", "num_citations": "83\n", "authors": ["676"]}
{"title": "From coupling relations to mated invariants for checking information flow\n", "abstract": " This paper investigates a technique for using automated program verifiers to check conformance with information flow policy, in particular for programs acting on shared, dynamically allocated mutable heap objects. The technique encompasses rich policies with forms of declassification and supports modular, invariant-based verification of object-oriented programs. The technique is based on the known idea of self-composition, whereby noninterference for a command is reduced to an ordinary partial correctness property of the command sequentially composed with a renamed copy of itself. The first contribution is to extend this technique to encompass heap objects, which is difficult because textual renaming is inapplicable. The second contribution is a systematic means to validate transformations on self-composed programs. Certain transformations are needed for effective use of existing automated program\u00a0\u2026", "num_citations": "74\n", "authors": ["676"]}
{"title": "History-based access control and secure information flow\n", "abstract": " This paper addresses the problem of static checking of programs to ensure that they satisfy confidentiality policies in the presence of dynamic access control in the form of Abadi and Fournet\u2019s history-based access control mechanism. The Java virtual machine\u2019s permission-based stack inspection mechanism provides dynamic access control and is useful in protecting trusted callees from untrusted callers. In contrast, history-based access control provides a stateful view of permissions: permissions after execution are at most the permissions before execution. This allows protection of both callers and callees.             The main contributions of this paper are to provide a semantics for history-based access control and a static analysis for confidentiality that takes history-based access control into account. The static analysis is a type and effects analysis where the chief novelty is the use of security types dependent\u00a0\u2026", "num_citations": "73\n", "authors": ["676"]}
{"title": "A weakest precondition semantics for refinement of object-oriented programs\n", "abstract": " We define a predicate-transformer semantics for an object oriented language that includes specification constructs from refinement calculi. The language includes recursive classes, visibility control, dynamic binding, and recursive methods. Using the semantics, we formulate notions of refinement. Such results are a first step toward a refinement calculus.", "num_citations": "71\n", "authors": ["676"]}
{"title": "A weakest precondition semantics for an object-oriented language of refinement\n", "abstract": " We define a predicate-transformer semantics for an object- oriented language that includes specification constructs from refinement calculi. The language includes recursive classes, visibility control, dynamic binding, and recursive methods. Using the semantics, we formulate notions of refinement. Such results are a first step towards a refinement calculus.", "num_citations": "69\n", "authors": ["676"]}
{"title": "Using access control for secure information flow in a Java-like language\n", "abstract": " Access control mechanisms are widely used with the intent of enforcing confidentiality and other policies, but few formal connections have been made between information flow and access control. Java and C# are object-oriented languages that provide fine-grained access control. An access control list specifies local policy by authorizing permissions for principals (code sources) associated with class declarations; a mechanism called stack inspection checks permissions at run time. An example is given to show how this mechanism can be used to achieve confidentiality goals in situations where a single system call serves callers of differing confidentiality levels and dynamic access control prevents release of high information to low callers. A static analysis is given which applies to such examples. The analysis is shown to ensure a noninterference property formalizing confidentiality.", "num_citations": "64\n", "authors": ["676"]}
{"title": "Towards imperative modules: Reasoning about invariants and sharing of mutable state\n", "abstract": " Imperative and object-oriented programs make ubiquitous use of shared mutable objects. Updating a shared object can and often does transgress a boundary that was supposed to be established using static constructs such as a class with private fields. This paper shows how auxiliary fields can be used to express two state-dependent encapsulation disciplines: ownership, a kind of separation, and friendship, a kind of sharing. A methodology is given for specification and modular verification of encapsulated object invariants and shown sound for a class-based language. As an example the methodology is used to specify iterators, which are problematic for previous ownership systems.", "num_citations": "62\n", "authors": ["676"]}
{"title": "99.44% pure: Useful abstractions in specifications\n", "abstract": " Specification languages that use the same expression language as the implementation language must decide whether or not to permit functional abstraction, ie, method calls in specification expressions. The difficulty is that a specification must not change the functional behavior of the associated program. There are three main current approaches: a) forbid the use of functions in specifications, b) allow only provably pure functions, or c) allow programmers free use of functions. The first approach is not scalable, the second overly restrictive and the third unsound. We propose a definition of observational purity for a class of benevolent functions and a sound static analysis for detecting them.", "num_citations": "61\n", "authors": ["676"]}
{"title": "Guiding a general-purpose C verifier to prove cryptographic protocols\n", "abstract": " We describe how to verify security properties of C code for cryptographic protocols by using a general-purpose verifier. We prove security theorems in the symbolic model of cryptography. Our techniques include: use of ghost state to attach formal algebraic terms to concrete byte arrays and to detect collisions when two distinct terms map to the same byte array; decoration of a crypto API with contracts based on symbolic terms; and expression of the attacker model in terms of C programs. We rely on the general-purpose verifier VCC; we guide VCC to prove security simply by writing suitable header files and annotations in implementation files, rather than by changing VCC itself. We formalize the symbolic model in Coq in order to justify the addition of axioms to VCC.", "num_citations": "54\n", "authors": ["676"]}
{"title": "Inlined information flow monitoring for JavaScript\n", "abstract": " Extant security mechanisms for web apps, notably the\" same-origin policy\", are not sufficient to achieve confidentiality and integrity goals for the many apps that manipulate sensitive information. The trend in web apps is\" mashups\" which integrate JavaScript code from multiple providers in ways that can undercut existing security mechanisms. Researchers are exploring dynamic information flow controls (IFC) for JavaScript, but there are many challenges to achieving strong IFC without excessive performance cost or impractical browser modifications. This paper presents an inlined IFC monitor for ECMAScript 5 with web support, using the no-sensitive-upgrade (NSU) technique, together with experimental evaluation using synthetic mashups and performance benchmarks. On this basis it should be possible to conduct experiments at scale to evaluate feasibility of both NSU and inlined monitoring.", "num_citations": "53\n", "authors": ["676"]}
{"title": "Modular and constraint-based information flow inference for an object-oriented language\n", "abstract": " This paper addresses the problem of checking programs written in an object-oriented language to ensure that they satisfy the information flow policies, confidentiality and integrity. Policy is specified using security types. An algorithm that infers such security types in a modular manner is presented. The specification of the algorithm involves inference for libraries. Library classes and methods maybe parameterized by security levels. It is shown how modular inference is achieved in the presence of method inheritance and override. Soundness and completeness theorems for the inference algorithm are given.", "num_citations": "51\n", "authors": ["676"]}
{"title": "Observational purity and encapsulation\n", "abstract": " Practical specification languages for imperative and object-oriented programs, such as JML, Eiffel, and Spec#, allow the use of program expressions including method calls in specification formulas. For coherent semantics of specifications, and to avoid anomalies with runtime assertion checking, expressions in specifications and assertions are typically required to be weakly pure in the sense that their evaluation has no effect on the state of preexisting objects. For specification of large systems using standard libraries this restriction is impractical: it disallows many standard methods that mutate state for purposes such as caching or lazy initialization. Calls of such methods can sensibly be used for specifications and annotations in contexts where their effects cannot be observed. This paper formalizes a notion of observational purity, justifies the use of weakly and observationally pure methods in specifications, and\u00a0\u2026", "num_citations": "49\n", "authors": ["676"]}
{"title": "A commonsense management model\n", "abstract": " A description is given of a process-management model, called cosmos, which combines the best of existing models by incorporating three perspectives: activity, communication, and infrastructure. Cosmos is designed to manage a large software system from beginning to end. Current problems in system development are reviewed, and the principles on which cosmos is based are outlined. The reasons for using such a three-dimensional model are examined. The use of cosmos is described.< >", "num_citations": "47\n", "authors": ["676"]}
{"title": "State based ownership, reentrance, and encapsulation\n", "abstract": " A properly encapsulated data representation can be revised for refactoring or other purposes without affecting the correctness of client programs and extensions of a class. But encapsulation is difficult to achieve in object-oriented programs owing to heap based structures and reentrant callbacks. This paper shows that it is achieved by a discipline using assertions and auxiliary fields to manage invariants and transferrable ownership. The main result is representation independence: a rule for modular proof of equivalence of class implementations.", "num_citations": "45\n", "authors": ["676"]}
{"title": "Boogie meets regions: A verification experience report\n", "abstract": " We use region logic specifications to verify several programs exhbiting the classic hard problem for object-oriented systems: the framing of heap updates. We use BoogiePL and its associated SMT solver, Z3, to prove both implementations and client code.", "num_citations": "39\n", "authors": ["676"]}
{"title": "Predicate transformer semantics of an Oberon-like language\n", "abstract": " Predicate Transformer Semantics of an Oberon-Like Language | Proceedings of the IFIP TC2/WG2.1/WG2.2/WG2.3 Working Conference on Programming Concepts, Methods and Calculi ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsPROCOMET '94Predicate Transformer Semantics of an Oberon-Like Language Article Predicate Transformer Semantics of an Oberon-Like Language Share on Author: David A. Naumann View Profile Authors Info & Affiliations PROCOMET '94: Proceedings of the IFIP TC2/WG2./WG2./WG2.Working Conference on Programming Concepts, Methods and CalculiJune 1994 Pages 467\u2013487 \u2026", "num_citations": "39\n", "authors": ["676"]}
{"title": "Local reasoning for global invariants, part I: Region logic\n", "abstract": " Dedicated to the memory of Stephen L. Bloom (1940--2010). Shared mutable objects pose grave challenges in reasoning, especially for information hiding and modularity. This article presents a novel technique for reasoning about error-avoiding partial correctness of programs featuring shared mutable objects, and investigates the technique by formalizing a logic. Using a first-order assertion language, the logic provides heap-local reasoning about mutation and separation, via ghost fields and variables of type \u201cregion\u201d (finite sets of object references). A new form of frame condition specifies write, read, and allocation effects using region expressions; this supports a frame rule that allows a command to read state on which the framed predicate depends. Soundness is proved using a standard program semantics. The logic facilitates heap-local reasoning about object invariants, as shown here by examples. Part II of\u00a0\u2026", "num_citations": "37\n", "authors": ["676"]}
{"title": "Forward simulation for data refinement of classes\n", "abstract": " Simulation is the most widely used technique to prove data refinement. We define forward simulation for a language with recursive classes, inheritance, type casts and tests, dynamic binding, class based visibility, mutable state (without aliasing), and specification constructs from refinement calculi. It is a language based on sequential Java, but it also includes specification and deseign mechanisms appropriate for the construction of programs based on refinement. We show simulation to be sound for data refinement of classes in this language.", "num_citations": "36\n", "authors": ["676"]}
{"title": "Relational logic with framing and hypotheses\n", "abstract": " Relational properties arise in many settings: relating two versions of a program that use different data representations, noninterference properties for security, etc. The main ingredient of relational verification, relating aligned pairs of intermediate steps, has been used in numerous guises, but existing relational program logics are narrow in scope. This paper introduces a logic based on novel syntax that weaves together product programs to express alignment of control flow points at which relational formulas are asserted. Correctness judgments feature hypotheses with relational specifications, discharged by a rule for the linking of procedure implementations. The logic supports reasoning about program-pairs containing both similar and dissimilar control and data structures. Reasoning about dynamically allocated objects is supported by a frame rule based on frame conditions amenable to SMT provers. We prove soundness and sketch how the logic can be used for data abstraction, loop optimizations, and secure information flow.", "num_citations": "35\n", "authors": ["676"]}
{"title": "Predicate transformer semantics of a higher-order imperative language with record subtyping\n", "abstract": " Using a set-theoretic model of predicate transformers and ordered data types, we give a total-correctness semantics for a typed higher-order imperative programming language that includes record extension, local variables, and procedure-type variables and parameters. The language includes infeasible specification constructs, for a calculus of refinement. Procedures may have global variables, subject to mild syntactic restrictions to avoid the semantic complications of Algol-like languages. The semantics is used to validate simple proof rules for non-interference, type extension, and calls of procedure variables and constants.", "num_citations": "33\n", "authors": ["676"]}
{"title": "Observational purity and encapsulation\n", "abstract": " Practical specification languages for imperative and object-oriented programs, such as JML, Eiffel, and Spec#, allow the use of program expressions including method calls in specification formulas. For coherent semantics of specifications, and to avoid anomalies with runtime assertion checking, expressions in specifications and assertions are typically required to be strongly pure in the sense that their evaluation has no effect on the state of preexisting objects. For specification of large systems using standard libraries this restriction is impractical: it disallows many standard methods that mutate state for purposes such as caching or lazy initialization. Calls of such methods can sensibly be used for specifications and annotations in contexts where their effects cannot be observed. This paper formalizes and extends a recently proposed notion of observational purity, reducing the proof obligation to a familiar one\u00a0\u2026", "num_citations": "31\n", "authors": ["676"]}
{"title": "Verifying a secure information flow analyzer\n", "abstract": " Denotational semantics for a substantial fragment of Java is formalized by deep embedding in PVS, making extensive use of dependent types. A static analyzer for secure information flow for this language is proved correct, that is, it enforces noninterference.", "num_citations": "30\n", "authors": ["676"]}
{"title": "Information flow monitoring as abstract interpretation for relational logic\n", "abstract": " A number of systems have been developed for dynamic information flow control (IFC). In such systems, the security policy is expressed by labeling input and output channels, it is enforced by tracking and checking labels on data. Systems have been proven to enforce some form of noninterference (NI), formalized as a property of two runs of the program. In practice, NI is too strong and it is desirable to enforce some relaxation of NI that allows downgrading under constraints that have been classified as 'what', 'where', 'who', or 'when' policies. To encompass a broad range of policies, relational logic has been proposed as a means to specify and statically enforce policy. This paper shows how relational logic policies can be dynamically checked. To do so, we provide a new account of monitoring, in which the monitor state is viewed as an abstract interpretation of sets of pairs of program runs.", "num_citations": "29\n", "authors": ["676"]}
{"title": "Calculating sharp adaptation rules\n", "abstract": " Adaptation rules adapt the pre-post specification of a procedure to contexts where it is called. Such rules are important for practical reasons and necessary for completeness for languages with recursive procedures. A sharp rule is one that gives the weakest precondition with respect to a given postcondition. A number of rules have been proposed, most unsound or incomplete or non-sharp. Using refinement algebra, we clarify and extend the applicability of previously proposed sharp rules for total correctness and show how further rules may be found.", "num_citations": "28\n", "authors": ["676"]}
{"title": "A simple semantics and static analysis for Java security\n", "abstract": " Security in Java depends on an access control mechanism specified operationally in terms of run-time stack inspection. We give a denotational semantics in \u201ceager\u201d form, and show that it is equivalent to the \u201clazy\u201d semantics using stack inspection. We give a static analysis of safety, ie, the absence of security errors, that is significantly simpler than previous proposals. We identify several program transformations that can be used to remove run-time checks. We give complete, detailed proofs for safety of the analysis and for the transformations, exploiting compositionality of the \u201ceager\u201d semantics.", "num_citations": "27\n", "authors": ["676"]}
{"title": "A categorical model for higher order imperative programming\n", "abstract": " The order-enriched category of monotonic predicate transformers over posets is a model of the refinement calculus of higher order imperative programs and pre-post specifications. This category is shown to be equivalent to the category of spans over ideal relations, and ideal relations are shown to be spans over monotonic functions between posets. To do this we use a skew span construction because the standard categorical span constructions are inapplicable. Axioms are given for products and coproducts of underlying posets as well as the homset as a coexponent, using inequations (for various kinds of lax adjunctions) and conditional equations (for adjunctions in subcategories) that are shown to uniquely determine the structures. The model is described in elementary terms using power allegories, an axiomatic calculus of relations, which makes the proofs accessible to non-specialists and shows that the\u00a0\u2026", "num_citations": "25\n", "authors": ["676"]}
{"title": "Two-categories and program structure: Data types, refinement calculi, and predicate transformers\n", "abstract": " Degree: Ph. D.DegreeYear: 1992Institute: The University of Texas at AustinThe theory of two-categories is used to develop the foundations of programming calculi. Two-categorical tools are used to augment the calculus of predicate transformers with new constructs and to extend algorithmic refinement calculi to data refinement. The presentation is expository and detailed, to help bridge the wide gap between category theory and computing science. The algorithmic refinement calculus of predicate transformers is extended to include constructs for large scale system structure: products and disjoint unions of state spaces along with higher order programs. The preordered category of monotonic predicate transformers is shown to have products, lax exponents, and lax coexponents. Lax coproducts are constructed for disjunctive and for strict finitely conjunctive predicate transformers. A continuous lax coproduct is\u00a0\u2026", "num_citations": "24\n", "authors": ["676"]}
{"title": "CodeBLUE: A bluetooth interactive dance club system\n", "abstract": " This paper examines the use of Bluetooth for a collaborative music creation system called codeBLUE where the low cost, low power and small dimensions of Bluetooth technology are critical. Dancers using the codeBLUE system wear clothing incorporating Bluetooth-enabled sensors that measure and transmit information about the dancers' movements to a Bluetooth access point positioned in the demonstration area, which in turn forwards the information to a control system. The system software transforms the simple dance movements into musical modifications in real time, altering the melodic, rhythmic, and dynamic properties of the music stream in terms of MIDI parameters. A configuration console allows the DJ to modify the effects that each type of sensor produces, providing him or her yet another channel of creativity and keeping the codeBLUE experience fresh for participants. The paper describes the\u00a0\u2026", "num_citations": "23\n", "authors": ["676"]}
{"title": "Soundness of data refinement for a higher-order imperative language\n", "abstract": " Using a set-theoretic model of predicate transformers and ordered data types, we give a semantics for an Oberon-like higher-order imperative language with record subtyping and procedure-type variables and parameters. Data refinement is shown to be sound for this language: It implies algorithmic refinement when suitably localized. All constructs are shown to preserve simulation, so data refinement can be carried out piecewise.", "num_citations": "22\n", "authors": ["676"]}
{"title": "Predicate transformers and higher-order programs\n", "abstract": " Example higher-order programs are presented in the style of Hoare logic and refinement calculus, as motivation for a study of weak (lax) coexponents in categories of predicate transformers. The preordered category of monotonic predicate transformers between powersets is shown to have weak components that give an operationally sound predicate transformer semantics to higher-order programs and designs. The semantics is for stored programs, orthogonal to (but compatible with) procedures and parameter passing. The weak coexponent is not unique, and may be chosen to represent all designs in refinement calculus, or to represent only feasible programs, or only total deterministic programs. For the latter alternative there is a complete axiomatization in terms of program level laws of refinement, for positively conjunctive predicate transformers. A different alternative makes all program specifications\u00a0\u2026", "num_citations": "20\n", "authors": ["676"]}
{"title": "Analysis of authentication and key establishment in inter-generational mobile telephony\n", "abstract": " Second (GSM), third (UMTS), and fourth-generation (LTE) mobile telephony protocols are all in active use, giving rise to a number of interoperation situations. Although the standards address roaming by specifying switching and mapping of established security context, there is not a comprehensive specification of which are the possible interoperation cases. Nor is there comprehensive specification of the procedures to establish security context (authentication and short-term keys) in the various interoperation scenarios. This paper systematically enumerates the cases, classifying them as allowed, disallowed, or uncertain with rationale based on detailed analysis of the specifications. We identify the authentication and key agreement procedure for each of the possible cases. We formally model these scenarios and analyze their security, in the symbolic model, using the tool Prove if. We find two scenarios that inherit a\u00a0\u2026", "num_citations": "18\n", "authors": ["676"]}
{"title": "Data refinement, call by value and higher order programs\n", "abstract": " Using 2-categorical laws of algorithmic refinement, we show soundness of data refinement for stored programs and hence for higher order procedures with value/result parameters. The refinement laws hold in a model that slightly generalizes the standard predicate transformer semantics for the usual imperative programming constructs including prescriptions.", "num_citations": "18\n", "authors": ["676"]}
{"title": "Local reasoning for global invariants, part II: Dynamic boundaries\n", "abstract": " Dedicated to the memory of John C. Reynolds (1935--2013). The hiding of internal invariants creates a mismatch between procedure specifications in an interface and proof obligations on the implementations of those procedures. The mismatch is sound if the invariants depend only on encapsulated state, but encapsulation is problematic in contemporary software due to the many uses of shared mutable objects. The mismatch is formalized here in a proof rule that achieves flexibility via explicit restrictions on client effects, expressed using ghost state and ordinary first order assertions. The restrictions amount to a stateful frame condition that must be satisfied by any client; this dynamic encapsulation boundary complements conventional scope-based encapsulation. The technical development is based on a companion article, Part I, that presents Region Logic---a programming logic with stateful frame conditions for\u00a0\u2026", "num_citations": "17\n", "authors": ["676"]}
{"title": "Local reasoning and dynamic framing for the composite pattern and its clients\n", "abstract": " The Composite design pattern is an exemplar of specification and verification challenges for sequential object-oriented programs. Region logic is a Hoare logic augmented with state dependent \u201dmodifies\u201d specifications based on simple notations for object sets. Using ordinary first order logic assertions, it supports local reasoning and also the hiding of invariants on encapsulated state, in ways similar to separation logic but suited to off-the-shelf SMT solvers. This paper uses region logic to specify and verify a representative implementation of the Composite design pattern. To evaluate efficacy of the specification, it is used in verifications of several sample client programs including one with hiding. Verification is performed using a verifier for region logic built on top of an existing verification condition generator which serves as a front end to an SMT solver.", "num_citations": "17\n", "authors": ["676"]}
{"title": "Towards a logical account of declassification\n", "abstract": " Declassification is a vital ingredient for practical use of secure systems. Several recent efforts to formulate an end-to-end policy for declassification seem inconclusive and have focused on apparently different aspects.(eg, what values are involved, where in the code declassification occurs, when declassification happens and who (which principal) releases information.) In this informal paper, we argue that key security goals addressed by the proposed notions can be expressed using assertions and auxiliary state (such as event history), building on a recently developed logic for noninterference that provides for local reasoning about the heap", "num_citations": "17\n", "authors": ["676"]}
{"title": "Decision procedures for region logic\n", "abstract": " Region logic is Hoare logic for object-based programs. It features local reasoning with frame conditions expressed in terms of sets of heap locations. This paper studies tableau-based decision procedures for RL, the quantifier-free fragment of the assertion language. This fragment combines sets and (functional) images with the theories of arrays and partial orders. The procedures are of practical interest because they can be integrated efficiently into the satisfiability modulo theories (SMT) framework. We provide a semi-decision procedure for RL and its implementation as a theory plugin inside the SMT solver Z3. We also provide a decision procedure for an expressive fragment of RL termed restricted-RL. We prove that deciding satisfiability of restricted-RL formulas is NP-complete. Both procedures are proven sound and complete. Preliminary performance results indicate that the semi-decision procedure has\u00a0\u2026", "num_citations": "16\n", "authors": ["676"]}
{"title": "A Logical Analysis of Framing for Specifications with Pure Method Calls\n", "abstract": " For specifying and reasoning about object-based programs, it is often attractive for contracts to be expressed using calls to pure methods. It is useful for pure methods to have contracts, including read effects, to support local reasoning based on frame conditions. This leads to puzzles such as the use of a pure method in its own contract. These ideas have been explored in connection with verification tools based on axiomatic semantics, guided by the need to avoid logical inconsistency, and focusing on encodings that cater for first-order automated provers. This article adds pure methods and read effects to region logic, a first-order program logic that features frame-based local reasoning and provides modular reasoning principles for end-to-end correctness. Modular reasoning is embodied in a proof rule for linking a module\u2019s method implementations with a client that relies on the method contracts. Soundness is\u00a0\u2026", "num_citations": "14\n", "authors": ["676"]}
{"title": "Allowing state changes in specifications\n", "abstract": " We provide a static analysis (using both dataflow analysis and theorem proving) to allow state changes within specifications. This can be used for specification languages that share the same expression sub-language with an implementation language so that method calls can appear in preconditions, postconditions, and object invariants without violating the soundness of the system.", "num_citations": "13\n", "authors": ["676"]}
{"title": "Calculational design of information flow monitors\n", "abstract": " Fine grained information flow monitoring can in principle address a wide range of security and privacy goals, for example in web applications. But it is very difficult to achieve sound monitoring with acceptable runtime cost and sufficient precision to avoid impractical restrictions on programs and policies. We present a systematic technique for design of monitors that are correct by construction. It encompasses policies with downgrading. The technique is based on abstract interpretation which is a standard basis for static analysis of programs. This should enable integration of a wide range of analysis techniques, enabling more sophisticated engineering of monitors to address the challenges of precision and scaling to widely used programming languages.", "num_citations": "12\n", "authors": ["676"]}
{"title": "Dynamic boundaries: Information hiding by second order framing with first order assertions\n", "abstract": " The hiding of internal invariants creates a mismatch between procedure specifications in an interface and proof obligations on the implementations of those procedures. The mismatch is sound if the invariants depend only on encapsulated state, but encapsulation is problematic in contemporary software due to the many uses of shared mutable objects. The mismatch is formalized here in a proof rule that achieves flexibility via explicit restrictions on client effects, expressed using ghost state and ordinary first order assertions.", "num_citations": "12\n", "authors": ["676"]}
{"title": "A recursion theorem for predicate transformers on inductive data types\n", "abstract": " The calculus of predicate transformers has proved fruitful for the derivation of state-transformation programs in conventional languages with general recursion and demonic nondeterminacy [8, 10, 11]. Derivations involving direct manipulation of predicates can be unwieldy, so it is hoped that the algebraic, program-level style [5] that has proved so successful in the simpler calculus of functions can be extended to predicate transformers. In the calculus of functions, structural recursion on inductive data types\u2014homomorphisms from initial algebras\u2014is used to great effect. De Moor showed that inductive data types can be lifted from the category Fun of functions to the ordered category of predicate transformers [7]. This paper takes another step towards extending the function calculus to predicate transformers, proving a generalization of Lawvere\u2019s recursion theorem (eg,[9]) for predicate transformers. This gives a form of recursion more general than the defining property for inductive types but with similar algebraic properties. It applies to both programs and specifications, ie, the full \u201crefinement calculus\u201d(eg,[1, 14]). We introduce the theorem by giving a special case, in the calculus of functions; first at the data level, then at the program (ie, function) level. Then section 2 gives prerequisites and section 3 proves the theorem.", "num_citations": "12\n", "authors": ["676"]}
{"title": "Derivation of programs for freshmen\n", "abstract": " The first year of computer science instruction typically consists of a two-course sequence in which students are taught(1) programming in some high level language and (2) an introduction to algorithms and data structures. Our first two courses introduce in addition(3) methods for deriving algorithms and verifying their correctness. These methods provide a central theme for the curriculum and a unified approach to the traditional topics.", "num_citations": "12\n", "authors": ["676"]}
{"title": "Refactoring and representation independence for class hierarchies\n", "abstract": " Refactoring transformations are important for productivity and quality in software evolution. Modular reasoning about semantics preserving transformations is difficult even in typed class-based languages because transformations can change the internal representations for multiple interdependent classes and because encapsulation can be violated by pointers to mutable objects. In this paper, an existing theory of representation independence for a single class, based on a simple notion of ownership confinement, is generalized to a hierarchy of classes and used to prove refactoring rules that embody transformations of complete class trees. This allows us to formalize refactorings that inherently involve class inheritance, such as Pull Up or Push Down Field; moreover, this makes it possible to generalize refactorings previously restricted to change of data representation of private attributes (like Extract Class and\u00a0\u2026", "num_citations": "11\n", "authors": ["676"]}
{"title": "Symbolic analysis for security of roaming protocols in mobile networks\n", "abstract": " Both GSM (2G) and UMTS (3G) wireless standards are deployed worldwide. Like the 4G standard now appearing, these standards provide for mobile devices with differing capabilities to roam between providers or technologies. This poses serious challenges in ensuring authentication and other security properties. Automated analysis of security properties is needed to cope with the large number of possible scenarios. While some attacks exploit weaknesses in cryptographic functions, many attacks exploit flaws or other features of the protocol design. The latter attacks can be found using symbolic (Dolev-Yao) models. This paper demonstrates the use of a fully automatic tool to exhaustively analyze symbolic models of GSM, UMTS, and the respective roaming protocols. The results include the demonstration of known attacks as well as the confirmation of expected properties.", "num_citations": "11\n", "authors": ["676"]}
{"title": "Ideal models for pointwise relational and state-free imperative programming\n", "abstract": " Point-freerelation calculus and its categorical generalizations have been fruitful in development of calculi of functional programming, especially for general principles, eg, polytypic patterns of recursion on inductive data. But in specific applications, pointwise formulations can be more convenient and comprehensible than point-free combinators. A typed lambda calculus including non-injective pattern-matching was given by de Moor and Gibbons, but their relational semantics has shortcomings. We give an alternative based on a categorical axiomatization of ideal relations. We give a second semantics based on predicate transformers, and show how the pattern construct offers a new integration of imperative and functional programming. Simulation results justify the semantics.", "num_citations": "10\n", "authors": ["676"]}
{"title": "Ownership: transfer, sharing, and encapsulation\n", "abstract": " Ownership confinement expresses encapsulation in heap structures, in support of modular reasoning about effects, representation independence, and other properties. Most previous proposals for static enforcement of ownership confinement require annotations of whole programs using intricate type systems that are difficult to validate. Moreover, few proposals deal with transfer and sharing of ownership. We show how consideration of a reasoning objective suggests a particular pattern of ownership amenable to lightweight and modular imposition of confinement. We show how the pattern extends to handle transfer, at the cost of a heavier analysis.", "num_citations": "9\n", "authors": ["676"]}
{"title": "Towards squiggly refinement algebra\n", "abstract": " The algebra of functions and relations has been used so successfully in program construction that textbooks have appeared. Despite the importance of predicate transformers in imperative programming, the algebra of transformers has been less explored. To show its promise, we prove results on exponents and recursion on inductive data types, sufficient for carrying out a polytypic derivation that has been given as a substantial example for functions and relations. We also give a data refinement from exponents of specifications to the concrete exponents needed for program semantics.", "num_citations": "9\n", "authors": ["676"]}
{"title": "On the essence of oberon\n", "abstract": " Reynolds described the \u201cessence of Algol\u201d as the simple imperative language combined with the typed lambda calculus. We provide a similar description of Wirth's language Oberon as the simple imperative language combined with procedure types and record extension. Whereas the semantics of Algol has been given in terms of a (domain theoretic) model using an explicit representation of storage, our semantics uses predicate transformers; this is possible thanks to recent advances in the theory of predicate transformers. Predicate transformer semantics connects one of the most successful methods of rigorous program development with one of the most successful pragmatically-designed programming languages.", "num_citations": "9\n", "authors": ["676"]}
{"title": "Category theoretic models of data refinement\n", "abstract": " We give an account of the use of category theory in modelling data refinement over the past twenty years. We start with Tony Hoare's formulation of data refinement in category theoretic terms, explain how the category theory may be made precise in generality and with elegance, using the notion of structure respecting lax transformation, for a first order imperative language, then study two main alternatives for extending that category theoretic analysis in order to account for higher order languages. The first is given by adjoint simulations; the second is given by the notion of lax logical relation. These provide techniques that can be used for a combined language, such as an imperative language with procedure passing.", "num_citations": "8\n", "authors": ["676"]}
{"title": "Assertion-based encapsulation, object invariants and simulations\n", "abstract": " In object-oriented programming, reentrant method invocations and shared references make it difficult to achieve adequate encapsulation for sound modular reasoning. This tutorial paper surveys recent progress using auxiliary state (ghost fields) to describe and achieve encapsulation. Encapsulation is assessed in terms of modular reasoning about invariants and simulations.", "num_citations": "8\n", "authors": ["676"]}
{"title": "Beyond Fun: Order and membership in polytypic imperative programming\n", "abstract": " We argue that the category of transformers of monotonic predicates on posets is superior to the category of transformers on powersets, as the basis for a calculus of higher order imperative programming. We show by an example polytypic program derivation that such transformers (and the underlying categories of order-compatible relations and monotonic functions) model a calculus quite similar to the more familiar calculus of functional programs and relations. The derived program uses as a data type an exponent of transformers; unlike function-space, this transformer-space is adequate for semantics of higher order imperative programs.", "num_citations": "8\n", "authors": ["676"]}
{"title": "State based encapsulation for modular reasoning about behavior-preserving refactorings\n", "abstract": " A properly encapsulated data representation can be revised for refactoring or other purposes without affecting the correctness of client programs and extensions of a class. But encapsulation is difficult to achieve in object-oriented programs owing to heap based structures and reentrant callbacks. This chapter shows that it is achieved by a discipline using assertions and auxiliary fields to manage invariants and transferrable ownership. The main result is representation independence: a rule for modular proof of equivalence of class implementations.", "num_citations": "7\n", "authors": ["676"]}
{"title": "Ownership transfer and abstraction\n", "abstract": " Ownership confinement expresses encapsulation in heap structures, in support of modular reasoning about e# ects, representation independence, and other properties. This paper studies heap encapsulation from the perspective of substitutability for the class construct of Java-like languages and a particular form of confinement is justified by a representation independence result. A syntax-directed static analysis is specified and proved sound for checking confinement in the presence of ownership transfer.", "num_citations": "7\n", "authors": ["676"]}
{"title": "Simulation and class refinement for java\n", "abstract": " This document is an extended abstract of ongoing work on reasoning about correctness and behavioral subclassing for programs using some of the challenging features of Java. We include dynamic binding and inheritance, visibility control, and mutually recursive classes and recursive methods (but not pointers or concurrency). In [CN99a, CN99b, CN00] we give a predicate-transformer semantics for a language with these features as well as specification constructs from refinement calculi [Mor94, BvW98]. Here we discuss intrinsic notions of behavioral subclassing and refinement, and we discuss soundness of proof by forward simulation.This section describes the context and objectives for our project. \u00cbection 2 presents the language and semantics; \u00cbection 3 discusses refinement; \u00cbection 4 sketches the background of the authors and our expectations for the workshop. Our work is part of an ongoing collaboration involving others at UFPE (P. Borba and A. \u00cbampaio) and Birmingham (U. Reddy) and our research assistants. A long-term goal is to use refinement laws as the basis both for a development method and for tools supporting program analysis, verification, and compilation. In our current project the focus is on semantics, behavioral subclassing and refinement, and laws of refinement that are sufficient to reduce programs to a normal form. Laws, however, are beyond the scope of this abstract. The specification statement x:[pre, post] is treated as a command (albeit one that is not executable). The relation \u00c7 of (algorithmic) refinement subsumes the usual notion of satisfaction of specifications; in particular, x:[\u03c6, \u03c6] \u00c7 c holds just if c meets the\u00a0\u2026", "num_citations": "7\n", "authors": ["676"]}
{"title": "On assertion-based encapsulation for object invariants and simulations\n", "abstract": " In object-oriented programming, reentrant method invocations and shared references make it difficult to achieve adequate encapsulation for sound modular reasoning. This tutorial paper surveys recent progress using auxiliary state (ghost fields) to describe and achieve encapsulation. It also compares this technique with encapsulation in the forms provided by separation logic. Encapsulation is assessed in terms of modular reasoning about invariants and simulations.", "num_citations": "6\n", "authors": ["676"]}
{"title": "State based encapsulation and generics\n", "abstract": " A properly encapsulated data representation can be revised without affecting the correctness of client programs and extensions but encapsulation is difficult to achieve for heap based structures and object-oriented (OO) programs with reentrant callbacks. Building on a discipline that uses assertions and auxiliary fields to manage invariants and transferrable ownership, we give a rule for modular reasoning based on simulations. This representation independence result is proved for a sequential OO language with recursive, generic classes.", "num_citations": "6\n", "authors": ["676"]}
{"title": "Assuming you know: Epistemic semantics of relational annotations for expressive flow policies\n", "abstract": " Many high-level security requirements are about the allowed flow of information in programs, but are difficult to make precise because they involve selective downgrading. Quite a few mutually incompatible and ad-hoc approaches have been proposed for specifying and enforcing downgrading policies. Prior surveys of these approaches have not provided a unifying technical framework. Notions from epistemic logic have emerged as a good approach to policy semantics but are considerably removed from well developed static and dynamic enforcement techniques. We develop a unified framework for expressing, giving meaning and enforcing information downgrading policies that builds on commonly known and widely deployed concepts and techniques, especially static and dynamic assertion checking. These concepts should make information flow accessible and enable developers without special training to\u00a0\u2026", "num_citations": "5\n", "authors": ["676"]}
{"title": "Spartan Jester: end-to-end information flow control for hybrid Android applications\n", "abstract": " Web-based applications are attractive due to their portability. To leverage that, many mobile applications are hybrid, incorporating a web component that implements most of their functionality. While solutions for enforcing security exist for both mobile and web applications, enforcing and reasoning about the security of their combinations is difficult. We argue for a combination of static and dynamic analysis for assurance of end-to-end confidentiality in hybrid apps. We show how information flows in hybrid Android applications can be secured through use of SPARTA, a static analyzer for Android/Java, and JEST, a dynamic monitor for JavaScript, connected by a compatibility layer that translates policies and value representations. This paper reports on our preliminary investigation using a case study.", "num_citations": "5\n", "authors": ["676"]}
{"title": "Verified sequential malloc/free\n", "abstract": " We verify the functional correctness of an array-of-bins (segregated free-lists) single-thread malloc/free system with respect to a correctness specification written in separation logic. The memory allocator is written in standard C code compatible with the standard API; the specification is in the Verifiable C program logic, and the proof is done in the Verified Software Toolchain within the Coq proof assistant. Our\" resource-aware\" specification can guarantee when malloc will successfully return a block, unlike the standard Posix specification that allows malloc to return NULL whenever it wants to. We also prove subsumption (refinement): the resource-aware specification implies a resource-oblivious spec.", "num_citations": "4\n", "authors": ["676"]}
{"title": "A weakest precondition semantics for an object-oriented language of refinement, vol. 1709 of Lecture Notes in Computer Science\n", "abstract": " Electron tomography is a powerful tool for investigating the three-dimensional (3d) structure of biological objects at a resolution in the nanometer range. however, visualization and interpretation of the resulting volumetric data is a very difficult task due to the extremely low signal to noise ratio (< 0db). in this paper, an approach for noise reduction in volumetric data is presented, based on nonlinear anisotropic diffusion, using a hybrid of the edge enhancing and the coherence enhancing techniques. when applied to both, artificial or real data sets, the method turns out to be superior to conventional filters. in order to assess noise reduction and structure preservation experimentally, resolution tests commonly used in structure analysis are applied to the data in the frequency domain.", "num_citations": "4\n", "authors": ["676"]}
{"title": "Towards patterns for heaps and imperative lambdas\n", "abstract": " In functional programming, pointfree relation calculi have been fruitful for general theories of program construction, but for specific applications pointwise expressions can be more convenient and comprehensible. In imperative programming, refinement calculi have been tied to pointwise expression in terms of state variables, with the curious exception of the ubiquitous but invisible heap. To integrate pointwise with pointfree, de Moor and Gibbons [12] extended lambda calculus with non-injective pattern matching interpreted using relations. This article gives a semantics of that language using \u201cideal relations\u201d between partial orders, and a second semantics using predicate transformers. The second semantics is motivated by its potential use with separation algebra, for pattern matching in programs acting on the heap. Laws including lax beta and eta are proved in these models and a number of open problems are\u00a0\u2026", "num_citations": "3\n", "authors": ["676"]}
{"title": "Deriving sharp rules of adaptation for Hoare logics\n", "abstract": " Adaptation rules adapt the pre-post specification of a procedure to contexts where it is called. Such rules are important for practical reasons, and are necessary for completeness of proof systems for languages with recursive procedures. A sharp rule is one that gives the weakest precondition with respect to a given postcondition. A number of rules have been proposed for simple imperative languages with recursive procedures, most unsound or incomplete or non-sharp. Taking an algebraic approach, we clarify and extend the applicability of previously proposed sharp rules for total correctness, and show how further rules may be found.", "num_citations": "3\n", "authors": ["676"]}
{"title": "Thirty-seven years of relational hoare logic: remarks on its principles and history\n", "abstract": " Relational Hoare logics extend the applicability of modular, deductive verification to encompass important 2-run properties including dependency requirements such as confidentiality and program relations such as equivalence or similarity between program versions. A considerable number of recent works introduce different relational Hoare logics without yet converging on a core set of proof rules. This paper looks backwards to little known early work. This brings to light some principles that clarify and organize the rules as well as suggesting a new rule and a new notion of completeness.", "num_citations": "2\n", "authors": ["676"]}
{"title": "Whither specifications as programs\n", "abstract": " Unifying theories distil common features of programming languages and design methods by means of algebraic operators and their laws. Several practical concerns\u2014e.g., improvement of a program, conformance of code with design, correctness with respect to specified requirements\u2014are subsumed by the beautiful notion that programs and designs are special forms of specification and their relationships are instances of logical implication between specifications. Mathematical development of this idea has been fruitful but limited to an impoverished notion of specification: trace properties. Some mathematically precise properties of programs, dubbed hyperproperties, refer to traces collectively. For example, confidentiality involves knowledge of possible traces. This article reports on both obvious and surprising results about lifting algebras of programming to hyperproperties, especially in connection with\u00a0\u2026", "num_citations": "2\n", "authors": ["676"]}
{"title": "Some observations on hypercollecting semantics and subset closed hyperproperties\n", "abstract": " This note is based on Assaf\u2019s dissertation work [Ass15] as presented in [ANS+ 17]. We explore the sense in which the technique is suited to subset closed hyperproperties. The hypercollecting semantics is introduced as basis for the calculational derivation of abstract interpretations of hyperproperties. It is formulated (almost) compositionally, at the level of sets of sets.", "num_citations": "2\n", "authors": ["676"]}
{"title": "A simple semantics and static analysis for stack inspection\n", "abstract": " The Java virtual machine and the .NET common language runtime feature an access control mechanism specified operationally in terms of run-time stack inspection. We give a denotational semantics in \"eager\" form, and show that it is equivalent to the \"lazy\" semantics using stack inspection. We give a static analysis of safety, i.e., the absence of security errors, that is simpler than previous proposals. We identify several program transformations that can be used to remove run-time checks. We give complete, detailed proofs for safety of the analysis and for the transformations, exploiting compositionality of the eager semantics.", "num_citations": "2\n", "authors": ["676"]}
{"title": "Refactoring and representation independence for class hierarchies\n", "abstract": " Refactoring transformations are important for productivity and quality in software evolution. Modular reasoning about semantics preserving transformations is difficult even in typed class-based languages because transformations can change the internal representations for multiple interdependent classes and because encapsulation can be violated by pointers to mutable objects. In this paper, an existing theory of representation independence for a single class, based on a simple notion of ownership confinement, is generalized to a hierarchy of classes and used to prove several refactoring laws. Soundness of these laws was an open problem in an ongoing project on formal refactoring tools. The utility of the laws is shown in a case study. Shortcomings of the theory are described as a challenge to other approaches to heap encapsulation and relational reasoning for classes.", "num_citations": "2\n", "authors": ["676"]}
{"title": "Data Abstraction and Relational Program Logic\n", "abstract": " In a paper published in 1972 Hoare articulated the fundamental notions of hiding invariants and simulations. Hiding: invariants on encapsulated data representations need not be mentioned in specifications that comprise the API of a module. Simulation: correctness of a new data representation and implementation can be established by proving simulation between the old and new implementations using a coupling relation defined on the encapsulated state. These results were formalized semantically and for a simple model of state, though the paper claimed this could be extended to encompass dynamically allocated objects. In recent years, progress has been made towards formalizing the claim, for simulation, though mainly in semantic developments. In this paper, the ideas are combined with the idea in Hoare's 1969 paper: a logic of programs. For a language with dynamically allocated shared mutable objects\u00a0\u2026", "num_citations": "1\n", "authors": ["676"]}
{"title": "Unifying Theories of Programming: 5th International Symposium, UTP 2014, Singapore, May 13, 2014, Revised Selected Papers\n", "abstract": " This book constitutes the refereed proceedings of the 5th International Symposium on Unifying Theories of Programming, UTP 2014, held in Singapore, Singapore, in May 13, 2014, co-located with the 19th International Symposium on Formal Methods, FM 2014. The 7 revised full papers presented together with one invited talk were carefully reviewed and selected from 11 submissions. They deal with numerous formal notations and theories of programming, such as abstraction, refinement, choice, termination, feasibility, locality, concurrency and communication.", "num_citations": "1\n", "authors": ["676"]}
{"title": "Laws of Programming for References\n", "abstract": " We propose a set of algebraic laws for reasoning with sequential imperative programs that use object references like in Java. The theory is based on previous work by adding laws to cope with object references. The incrementality of the algebraic method is fundamental; with a few exceptions, existing laws for copy semantics are entirely reused, as they are not affected by the proposed laws for reference semantics. As an evidence of relative completeness, we show that any program can be transformed, through the use of our laws, to a normal form which simulates it using an explicit heap with copy semantics.", "num_citations": "1\n", "authors": ["676"]}
{"title": "On a specification-oriented model for object-orientation\n", "abstract": " Approach: refinement mixed specifications and code: specification statement y:[x>= 0, x= y] means requires x>= 0, ensures x= y, modifies only y correctness as refinement: y:[x>= 0, x= y] y:= x specify callbacks using code with method calls; avoid over-specification using spec statements refactoring as refinement class Person {int phone; String street;...} class Addr {int phone; String street;...} class Person {Addr a;...}", "num_citations": "1\n", "authors": ["676"]}