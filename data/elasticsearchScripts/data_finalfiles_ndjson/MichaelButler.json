{"title": "ProB: A model checker for B\n", "abstract": " We present PROB, an animation and model checking tool for the B method. PROB\u2019s animation facilities allow users to gain confidence in their specifications, and unlike the animator provided by the B-Toolkit, the user does not have to guess the right values for the operation arguments or choice variables. PROB contains a model checker and a constraint-based checker, both of which can be used to detect various errors in B specifications. We present our first experiences in using PROB on several case studies, highlighting that PROB enables users to uncover errors that are not easily discovered by existing tools.", "num_citations": "766\n", "authors": ["1880"]}
{"title": "Rodin: an open toolset for modelling and reasoning in Event-B\n", "abstract": " Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels. In this article we present the Rodin modelling tool that seamlessly integrates modelling and proving. We outline how the Event-B language was designed to facilitate proof and how the tool has been designed to support changes to models while minimising the impact of changes on existing proofs. We outline the important features of the prover architecture and explain how well-definedness is treated. The tool is extensible and configurable so that it can be adapted more easily to different application domains and development methods.", "num_citations": "724\n", "authors": ["1880"]}
{"title": "ProB: an automated analysis toolset for the B method\n", "abstract": " We present ProB, a validation toolset for the B method. ProB\u2019s automated animation facilities allow users to gain confidence in their specifications. ProB also contains a model checker and a refinement checker, both of which can be used to detect various errors in B specifications. We describe the underlying methodology of ProB, and present the important aspects of the implementation. We also present empirical evaluations as well as several case studies, highlighting that ProB enables users to uncover errors that are not easily discovered by existing tools.", "num_citations": "430\n", "authors": ["1880"]}
{"title": "UML-B: Formal modeling and design aided by UML\n", "abstract": " The emergence of the UML as a de facto standard for object-oriented modeling has been mirrored by the success of the B method as a practically useful formal modeling technique. The two notations have much to offer each other. The UML provides an accessible visualization of models facilitating communication of ideas but lacks formal precise semantics. B, on the other hand, has the precision to support animation and rigorous verification but requires significant effort in training to overcome the mathematical barrier that many practitioners perceive. We utilize a derivation of the B notation as an action and constraint language for the UML and define the semantics of UML entities via a translation into B. Through the UML-B profile we provide specializations of UML entities to support model refinement. The result is a formally precise variant of UML that can be used for refinement based, object-oriented behavioral\u00a0\u2026", "num_citations": "407\n", "authors": ["1880"]}
{"title": "An open extensible tool environment for Event-B\n", "abstract": " We consider modelling indispensable for the development of complex systems. Modelling must be carried out in a formal notation to reason and make meaningful conjectures about a model. But formal modelling of complex systems is a difficult task. Even when theorem provers improve further and get more powerful, modelling will remain difficult. The reason for this that modelling is an exploratory activity that requires ingenuity in order to arrive at a meaningful model. We are aware that automated theorem provers can discharge most of the onerous trivial proof obligations that appear when modelling systems. In this article we present a modelling tool that seamlessly integrates modelling and proving similar to what is offered today in modern integrated development environments for programming. The tool is extensible and configurable so that it can be adapted more easily to different application domains\u00a0\u2026", "num_citations": "269\n", "authors": ["1880"]}
{"title": "An operational semantics for StAC, a language for modelling long-running business transactions\n", "abstract": " This paper presents the StAC language and its operational semantics. StAC (Structured Activity Compensation) is a\u00a0business process modelling language and a\u00a0distinctive feature of the language is its support for compensation. A\u00a0compensation is an action taken to recover from error or cope with a\u00a0change of plan, especially when rollback of a\u00a0process is not possible. StAC is similar to a\u00a0process algebraic language such as Hoare\u2019s CSP or Milner\u2019s CCS but has additional operators dealing with compensation and with exception handling. In this paper we present an operational semantics for the language.", "num_citations": "193\n", "authors": ["1880"]}
{"title": "Decomposition structures for Event-B\n", "abstract": " Event-B provides a flexible approach to modelling and refinement of systems. In this paper we outline two important ways in which Event-B refinement can be augmented with additional structuring to support further the management of complex refinements. Firstly we show how event refinement diagrams can be used to structure refinement steps involving decomposition of atomicity. Secondly we outline a technique for decomposing models into sub-models to allow for independent refinement. We show how these two structuring techniques can be used together.", "num_citations": "175\n", "authors": ["1880"]}
{"title": "Combining CSP and B for specification and property verification\n", "abstract": " ProB is a model checking tool for the B Method. In this paper we present an extension of ProB that supports checking of specifications written in a combination of CSP and B. We explain how the notations are combined semantically and give an overview of the implementation of the combination. We illustrate the benefit that appropriate use of CSP, in conjunction with our tool, gives to B developments both for specification and for verification purposes.", "num_citations": "153\n", "authors": ["1880"]}
{"title": "csp2B: A practical approach to combining CSP and B\n", "abstract": " This paper describes the tool csp2B, which provides a means of combining CSP-like descriptions with standard B specifications. The notation of CSP provides a convenient way of describing the order in which the operations of a B machine may occur. The function of the tool is to convert CSP-like specifications into standard machine-readable B specifications, which means that they may be animated and appropriate proof obligations may be generated. Use of csp2B means that abstract specifications and refinements may be specified purely using CSP or using a combination of CSP and B. The translation is justified in terms of an operational semantics.", "num_citations": "134\n", "authors": ["1880"]}
{"title": "An approach to the design of distributed systems with B AMN\n", "abstract": " In this paper, we describe an approach to the design of distributed systems with B AMN. The approach is based on the action-system formalism which provides a framework for developing state-based parallel reactive systems. More specifically, we use the so-called CSP approach to action systems in which interaction between subsystems is by synchronised message passing and there is no sharing of state. We show that the abstract machines of B may be regarded as action systems and show how reactive refinement and decomposition of action systems may be applied to abstract machines. The approach fits in closely with the stepwise refinement method of B.", "num_citations": "107\n", "authors": ["1880"]}
{"title": "A CSP approach to action systems\n", "abstract": " The communicating sequential processes (CSP) formalism, introduced by Hoare, is an event-based approach to distributed computing. The action-system formalism, introduced by Back & Kurki-Suonio, is a state-based approach to distributed computing. Using weakest-precondition formulae, Morgan has defined a correspondence between action systems and the failures-divergences model for CSP. Simulation is a proof technique for showing refinement of action systems. Using the correspondence of Morgan, Woodcock & Morgan have shown that simulation is sound and complete in the CSP failures-divergences model. In this thesis, Morgan's correspondence is extended to the CSP infinite- traces model in order to deal more properly with unbounded nondeterminism. It is shown that simulation is sound in the infinite-traces model, though completeness is lost in certain cases. The new correspondence is then extended to include a notion of internal action. This allows the definition of a hiding operator for action systems that is shown to correspond to the CSP hiding operator. Rules for simulation steps involving internal actions are developed. A parallel operator for action systems is defined, in which interaction is based on synchronisation over shared actions. This operator is shown to correspond to the CSP parallel operator. The correspondence between action systems and CSP is extended again so that actions may have input and output parameters. This allows parallel action- systems to pass values on synchronisation. The original motivation for the work described in this thesis was the use of the action system formalism in the development of\u00a0\u2026", "num_citations": "107\n", "authors": ["1880"]}
{"title": "UML-B and Event-B: an integration of languages and tools\n", "abstract": " UML-B is a graphical front end for Event-B. It adds support for class-oriented modelling but retains the Event-B concept of a closed system characterized by families of spontaneous events. UML-B is similar to UML but is essentially a new notation based on a separate meta-model. We provide tool support for UML-B, including drawing tools and a translator to generate Event-B models. The tools are closely integrated with the Event-B verification tools so that when a drawing is saved the translator automatically generates the corresponding Event-B model. The Event-B verification tools (syntax checker and prover) then run automatically providing an immediate display of problems. We introduce the UML-B notation its tool support and its integration with Event-B.", "num_citations": "105\n", "authors": ["1880"]}
{"title": "An incremental development of the Mondex system in Event-B\n", "abstract": " A development of the Mondex system was undertaken using Event-B and its associated proof tools. An incremental approach was used whereby the refinement between the abstract specification of the system and its detailed design was verified through a series of refinements. The consequence of this incremental approach was that we achieved a very high degree of automatic proof. The essential features of our development are outlined. We also present some modelling and proof guidelines that we found helped us gain a deep understanding of the system and achieve the high degree of automatic proof.", "num_citations": "99\n", "authors": ["1880"]}
{"title": "Stepwise refinement of communicating systems\n", "abstract": " The action system formalism [6] is a state-based approach to distributed computing. In this paper, it is shown how the action system formalism may be used to describe systems that communicate with their environment through synchronised value-passing. Definitions and rules are presented for refining and decomposing such action systems into distributed implementations in which internal communication is also based on synchronised value-passing. An important feature of the composition rule is that parallel components of a distributed system may be refined independently of the rest of the system. Specification and refinement is similar to the refinement calculus approach [4, 26, 28]. The theoretical basis for communication and distribution is Hoare's CSP [16]. Use of the refinement and decomposition rules is illustrated by the design of an unordered buffer, and then of a distributed message-passing system.", "num_citations": "95\n", "authors": ["1880"]}
{"title": "Decomposition tool for event\u2010B\n", "abstract": " Two methods have been identified for Event\u2010B model decomposition: shared variable and shared event. The purpose of this paper is to introduce the two approaches and the respective tool support in the Rodin platform. Besides alleviating the complexity for large systems and respective proofs, decomposition allows team development in parallel over the same Event\u2010B project which is very attractive in the industrial environment. Copyright \u00a9 2011 John Wiley & Sons, Ltd.", "num_citations": "93\n", "authors": ["1880"]}
{"title": "Distributed system development in B\n", "abstract": " \u041e\u041a\u041d \u0438 \u0433\u0432 \u042b\u043d\u0437\u0438 \u0431\u0437 \u0432 \u0438 \u0433\u0432 \u0437\u043d\u0437\u0438 \u0431 \u0437 \u0437\u0438 \u0438 \u0431 \u0432\u0438 \u0433 \u0438 \u0433\u0436\u0431 \u043a \u0436 \u043c \u043c \u043c\u041c \u0433 \u041d\u2104\u2104 \u0431 \u0433\u2104 \u043e \u0433\u0432 \u0438 \u0437\u0438 \u0438 \u043a \u0436 \u0430 \u0437 \u043c \u0432 \u043e\u0418 \u043b \u0436 \u0438 \u043a \u0436 \u0430 \u0437 \u043e \u0436 \u0438 \u0430\u0433 \u0430 \u043a \u0436 \u0430 \u0437 \u0432 \u043c \u0436 \u0438 \u0430\u0433 \u0430 \u043a \u0436 \u0430 \u0437\u041a \u043a \u0436 \u0430 \u0437 \u0437\u0437\u0433 \u0438 \u043b \u0438 \u0437\u0433\u0431 \u0433\u0431 \u0432 \u0433 \u043a \u0430\u0439 \u0437\u041a \u042c \u0437 \u0438 \u0433 \u0434\u0433\u0437\u0437 \u0430 \u0437\u0437 \u0432\u0431 \u0432\u0438\u0437 \u0433 \u043a \u0430\u0439 \u0437 \u0438\u0433 \u0438 \u0437\u0438 \u0438 \u043a \u0436 \u0430 \u0437 \u0433\u0432\u0437\u0438 \u0438\u0439\u0438 \u0437 \u0438 \u0437\u0438 \u0438 \u0437\u0434 \u041a \u042c \u0432 \u0438 \u0430 \u0437 \u0438 \u0433\u0432 \u0437\u0438 \u0438 \u0431 \u0432\u0438 \u043c \u043c\u041c \u0437\u0437 \u0432\u0437 \u0432 \u0438 \u0430 \u043a \u0430\u0439 \u0437 \u0438\u0433 \u0438 \u0430\u0433 \u0430 \u043a \u0436 \u0430 \u0437 \u043c\u041a \u042c \u0430\u0433 \u0430 \u043a \u0436 \u0430 \u0437 \u043e \u0436 \u0439\u0437 \u0433\u0436 \u0432\u0438 \u0436 \u0438 \u0433\u0432 \u043b \u0438 \u0438 \u0432\u043a \u0436\u0433\u0432\u0431 \u0432\u0438\u041a \u0438 \u0433\u0432 \u0437 \u0433 \u0438 \u0433\u0436\u0431 \u042b \u043b \u0436 \u0438 \u0439 \u0436 \u0437 \u0433\u0433\u0430 \u0432 \u043c\u0434\u0436 \u0437\u0437 \u0433\u0432 \u0433\u0432 \u0438 \u0437\u0438 \u0438 \u043a \u0436 \u0430 \u0437 \u0432 \u0438 \u0433 \u043d \u042b \u0437 \u0437\u0438 \u0438 \u0431 \u0432\u0438 \u0433\u0432 \u0438 \u0437\u0438 \u0438 \u043a \u0436 \u0430 \u0437\u041a \u042f \u0432\u0433\u0438 \u0438 \u0439 \u0436 \u0433 \u043d \u0432 \u0438 \u0433 \u043d \u042b \u043d \u0437\u041a \u0439\u0436\u0438 \u0431\u0433\u0436 \u0418 \u043b \u0437 \u043d \u0438 \u0438 \u0432 \u0438 \u0433\u0432 \u0437 \u0432 \u0430 \u0432 \u0437\u0438 \u0438 \u043b \u0432 \u0438\u0437 \u0439 \u0436 \u043a \u0430\u0439 \u0438 \u0437 \u0438\u0433 \u0438\u0436\u0439 \u0432 \u0438 \u0438 \u0437\u0438 \u0438 \u041a \u042c \u043a \u0433\u0436 \u0433 \u0432 \u0438 \u0433\u0432 \u0437\u043d\u0437\u0438 \u0431 \u0437 \u0438 \u0438 \u0433 \u0437\u0438\u0436 \u0413\u0437 \u0439 \u0436 \u0438 \u0436 \u0438 \u0433\u0432 \u0437\u0438 \u0438 \u0431 \u0432\u0438\u2104 \u0433\u0432 \u0438 \u0437\u0438 \u0438 \u043a \u0436 \u0430 \u0437 \u0438 \u0432 \u0438 \u0430 \u0437 \u0438 \u0433\u0432 \u0437\u0438 \u0438 \u0431 \u0432\u0438 \u0437 \u043c \u0439\u0438 \u040c\u0436\u0437\u0438\u0418 \u0438 \u0436 \u0438 \u0436\u0418 \u0437 \u0430\u0433\u0432 \u0437 \u0438 \u0436 \u0436 \u0432 \u0430 \u0438 \u0433\u0432\u0437\u0418 \u0433\u0432 \u0438 \u0433\u0432 \u0438 \u0438 \u0431 \u0437 \u0432\u0433\u0432 \u0438 \u0436\u0431 \u0432 \u0437\u0438 \u0430\u0430\u043d \u0433\u0437 \u0432 \u0432 \u043c \u0439\u0438 \u041a \u042f \u0432 \u0430\u0430 \u0438 \u0438 \u0433\u0432\u0437 \u0436 \u0437 \u0430 \u0438 \u0438 \u0433\u0432 \u0437\u043d\u0437\u0438 \u0431 \u0438 \u0436\u0431 \u0432 \u0438 \u0437\u041a \u0421 \u0438\u043b\u0433 \u0438 \u0433\u0432\u0437 \u0436 \u0432 \u0434 \u0432 \u0432\u0438\u0418 \u041a \u041a\u0418 \u0438 \u043d \u0433 \u0432\u0433\u0438 \u043a \u0432\u043d \u043a \u0436 \u0430 \u0437 \u0432 \u0433\u0431\u0431\u0433\u0432\u0418 \u0438 \u043d \u0432 \u043c \u0439\u0438 \u0432 \u0434 \u0436 \u0430\u0430 \u0430\u041a \u042c \u0436 \u0434 \u0436 \u0430\u0430 \u0430 \u043c \u0439\u0438 \u0433\u0432 \u0437 \u0438 \u0432 \u0435\u0439 \u043a \u0430 \u0432\u0438 \u0438\u0433 \u043c \u0439\u0438 \u0432 \u0438 \u0438 \u0433\u0432\u0437 \u0433\u0432 \u0438 \u0436 \u0438 \u0433\u0438 \u0436\u0418 \u0432 \u0438 \u0436 \u0433\u0436 \u0436\u041a", "num_citations": "90\n", "authors": ["1880"]}
{"title": "csp2B: A practical approach to combining CSP and B\n", "abstract": " This paper describes the tool csp2B which provides a means of combining CSP-like descriptions with standard B specifications. The notation of CSP provides a convenient way of describing the order in which the operations of a B machine may occur. The function of the tool is to convert CSP-like specifications into standard machine-readable B specifications which means that they may be animated and appropriate proof obligations may be generated. Use of csp2B means that abstract specifications and refinements may be specified purely using CSP or using a combination of CSP and B. The translation is justified in terms of an operational semantics.", "num_citations": "89\n", "authors": ["1880"]}
{"title": "The refinement calculator: Proof support for program refinement\n", "abstract": " We describe the Re nement Calculator, a tool which supports the application of the re nement calculus to program development. The tool uses a general mechanism for transformational reasoning with HOL as the underlying proof system. A graphical user interface provides the user with menus of transformations and the ability to select and focus on subcomponents of a speci cation using simple mouse operations. The re nement-oriented transformations are illustrated with a case study.", "num_citations": "86\n", "authors": ["1880"]}
{"title": "The Rodin formal modelling tool\n", "abstract": " We present a software tool, the Rodin tool, for formal modelling in Event-B. Event-B is a notation and method developed from the B-Method and is intended to be used with an incremental style of modelling. The idea of incremental modelling has been taken from programming: modern programming languages come with integrated development environments that make it easy to modify and improve programs. The Rodin tool provides such an environment for Event-B. The two main characteristics of the Rodin tool are its ease of use and its extensibility. The tool focuses on modelling. It is easy to modify models and try out variations of a model. The tool can also be extended easily. This will make it possible to adapt the tool specific needs. So the tool can be adapted to fit into existing development processes instead demanding the opposite. We believe that these two characteristics are major points for industrial uptake.", "num_citations": "84\n", "authors": ["1880"]}
{"title": "Practical theory extension in Event-B\n", "abstract": " The Rodin tool for Event-B supports formal modelling and proof using a mathematical language that is based on predicate logic and set theory. Although Rodin has in-built support for a rich set of operators and proof rules, for some application areas there may be a need to extend the set of operators and proof rules supported by the tool. This paper outlines a new feature of the Rodin tool, the theory component, that allows users to extend the mathematical language supported by the tool. Using theories, Rodin users may define new data types and polymorphic operators in a systematic and practical way. Theories also allow users to extend the proof capabilities of Rodin by defining new proof rules that get incorporated into the proof mechanisms. Soundness of new definitions and rules is provided through validity proof obligations.", "num_citations": "82\n", "authors": ["1880"]}
{"title": "A process compensation language\n", "abstract": " This paper presents a formal language for the design of component-based enterprise system. The language (StAC) allows the usual parallel and sequential behaviours, but most significant is the concept of compensation that allows a previous action to be undone. The semantics of the language is given by an operational approach. The specification of a system is composed by a set of StAC processes that describe the behaviour of the system and a set of B operations that describe basic computations. Operational semantics is used to justified the integration of StAC processes with B operations.", "num_citations": "82\n", "authors": ["1880"]}
{"title": "Towards formalizing UML state diagrams in CSP\n", "abstract": " The UML (Unified Modeling Language) state diagram notation by M. Fowler and K. Scott (2000) is a graphical language which comprises an extensive set of constructs with good structural semantics but lack of a formal behavioral semantics. With this regard, we have used the Hoare's CSP (Communicating and Sequential Processes) to formalize the behavior of UML SD. The fact that CSP is supported by model-checkers such as FDR enables a system design using a state diagram to be formally checked during design stage. This paper presents the formalization which would allow us to reason about the behavior of UML SD in CSP.", "num_citations": "81\n", "authors": ["1880"]}
{"title": "Extending the concept of transaction compensation\n", "abstract": " The ability to compensate for previous activities, often in the case of failure or exceptional events, is an important feature of long-running business transactions. In this paper, we present several extensions to existing notions of compensation for business transactions. The extensions are described using a business process modeling language called StAC (Structured Activity Compensation) but are also placed in the context of IBM's BPBeans (Business Process Beans) enterprise technology. The meaning of the compensation mechanisms is made precise, as are issues of compensation scoping in multilevel transactions. The compensation extensions result in flexible and powerful mechanisms for modeling and implementing long-running business transactions.", "num_citations": "72\n", "authors": ["1880"]}
{"title": "Precise Modelling of Compensating Business Transactions and its Application to BPEL.\n", "abstract": " We describe the StAC language which can be used to specify the orchestration of activities in long running business transactions. Long running business transactions use compensation to cope with exceptions. StAC supports sequential and parallel behaviour as well as exception and compensation handling. We also show how the B notation may be combined with StAC to specify the data aspects of transactions. The combination of StAC and B provides a rich formal notation which allows for succinct and precise specification of business transactions. BPEL is an industry standard language for specifying business transactions and includes compensation constructs. We show how a substantial subset of BPEL can be mapped to StAC thus demonstrating the expressiveness of StAC and providing a formal semantics for BPEL.", "num_citations": "71\n", "authors": ["1880"]}
{"title": "U2B-A tool for translating UML-B models into B\n", "abstract": " U2B - A tool for translating UML-B models into B - ePrints Soton The University of Southampton Courses University life Research Business Global About Visit Alumni Departments News Events Contact \u00d7 Search the Site Search Filter your search: All Courses Projects Staff University of Southampton Institutional Repository Search Advanced Search Policies & Help Latest Download Statistics Browse by Year Browse by Divisions LeftRight U2B - A tool for translating UML-B models into B Snook, Colin and Butler, Michael (2004) U2B - A tool for translating UML-B models into B. In, Mermet, J. (ed.) UML-B Specification for Proven Embedded Systems Design. Springer. Record type: Book Section Full text not available from this repository. More information Published date: April 2004 Additional Information: Chapter: 6 Keywords: UML Profile UML-B U2B Organisations: Electronic & Software Systems Learn more about Cyber \u2026", "num_citations": "70\n", "authors": ["1880"]}
{"title": "Core hybrid Event-B I: single hybrid Event-B machines\n", "abstract": " Faced with the increasing need for correctly designed hybrid and cyber-physical systems today, the problem of including provision for continuously varying behaviour as well as the usual discrete changes of state is considered in the context of Event-B. An extension of Event-B called Hybrid Event-B is presented, that accommodates continuous behaviours (called pliant events) in between familiar discrete transitions (called mode events in this context). The continuous state change can be specified by a combination of indirect specification via ordinary differential equations, or direct specification via assignment of variables to values that depend on time, or indirect specification by demanding that behaviour obeys a time dependent predicate. The syntactic elements of the extension are discussed, and the semantics is described in terms of the properties of time dependent valuations of variables. Refinement is\u00a0\u2026", "num_citations": "67\n", "authors": ["1880"]}
{"title": "Executable semantics for compensating CSP\n", "abstract": " Compensation is an error recovery mechanism for long-running transactions. Compensating CSP is a variant of the CSP process algebra with constructs for orchestration of compensations. We present a simple operational semantics for Compensating CSP and outline an encoding of this semantics in Prolog. This provides a basis for implementation and model checking of the language.", "num_citations": "65\n", "authors": ["1880"]}
{"title": "ProTest: An automatic test environment for B specifications\n", "abstract": " We present ProTest, an automatic test environment for B specifications. B is a model-oriented notation where systems are specified in terms of abstract states and operations on abstract states. ProTest first generates a state coverage graph of a B specification through exhaustive model checking, and the coverage graph is traversed to generate a set of test cases, each being a sequence of B operations. For the model checking to be exhaustive, some transformations are applied to the sets used in the B machine. The approach also works if it is not exhaustive; one can stop at any point in time during the state space exploration and generate test cases from the coverage graph obtained so far. ProTest then simultaneously performs animation of the B machine and the execution of the corresponding implementation in Java, and assigns verdicts on the test results. With some restrictions imposed on the B operations, the\u00a0\u2026", "num_citations": "61\n", "authors": ["1880"]}
{"title": "Shared event composition/decomposition in Event-B\n", "abstract": " The construction of specifications is often a combination of smaller sub-components. Composition and decomposition are techniques supporting reuse and allowing formal combination of sub-components through refinement steps. Sub-components can result from a design or architectural goal and a refinement framework should allow them to be further developed, possibly in parallel. We propose the definition of composition and decomposition in the Event-B formalism following a shared event approach where sub-components interact via synchronised shared events and shared states are not allowed. We define the necessary proof obligations to ensure valid compositions and decompositions. We also show that shared event composition preserves refinement proofs, that is, in order to maintain refinement of compositions, it is sufficient to prove refinement between corresponding sub-components. A case\u00a0\u2026", "num_citations": "60\n", "authors": ["1880"]}
{"title": "Automatic refinement checking for B\n", "abstract": " Refinement is a key concept in the B-Method. While refinement is at the heart of the B Method, so far no automatic refinement checker has been developed for it. In this paper we present a refinement checking algorithm and implementation for B. It is based on using an operational semantics of B, obtained in practice by the ProB animator. The refinement checker has been integrated into ProB toolset and we present various case studies and empirical results in the paper, showing the algorithm to be surprisingly effective. The algorithm checks that a refinement preserves the trace properties of a specification. We also compare our tool against the refinement checker FDR for CSP and discuss an extension for singleton failure refinement.", "num_citations": "60\n", "authors": ["1880"]}
{"title": "Language and tool support for class and state machine refinement in UML-B\n", "abstract": " UML-B is a \u2018UML-like\u2019 graphical front end for Event-B that provides support for object-oriented modelling concepts. In particular, UML-B supports class diagrams and state machines, concepts that are not explicitly supported in plain Event-B. In Event-B, refinement is used to relate system models at different abstraction levels. The same abstraction-refinement concepts can also be applied in UML-B. This paper introduces the notions of refined classes and refined state machines to enable refinement of classes and state machines in UML-B. Together with these notions, a technique for moving an event between classes to facilitate abstraction is also introduced. Our work makes explicit the structures of class and state machine refinement in UML-B. The UML-B drawing tool and Event-B translator are extended to support the new refinement concepts. A case study of an auto teller machine (ATM) is presented to\u00a0\u2026", "num_citations": "59\n", "authors": ["1880"]}
{"title": "Modelling and proof of a tree-structured file system in Event-B and Rodin\n", "abstract": " Event-B is a formalism used for specifying and reasoning about complex discrete systems. The Rodin platform is a new tool for specification, refinement and proof in Event-B. In this paper, we present a verified model of a tree-structured file system which was carried out using Event-B and the Rodin platform. The model is focused on basic functionalities affecting the tree structure including create, copy, delete and move. This work is aimed at constructing a clear and accurate model with all proof obligations discharged. While constructing the model of a file system, we begin with an abstract model of a file system and subsequently refine it by adding more details through refinement steps. We have found that careful formulation of invariants and useful theorems that can be reused for discharging similar proof obligations make models simpler and easier to prove.", "num_citations": "59\n", "authors": ["1880"]}
{"title": "An action system approach to the steam boiler problem\n", "abstract": " This paper presents an approach to the specification of control programs based on action systems and refinement. The system to be specified and its physical environment are first modelled as one initial action system. This allows us to abstract away from the communication mechanism between the two entities. It also allows us to state and use clearly the assumptions that we make about how the environment behaves. In subsequent steps the specifications of control program and the environment are further elaborated by refinement and are separated. We use the refinement calculus to structure and reason about the specification. The operators in this calculus allow us to achieve a high degree of modularity in the development.", "num_citations": "58\n", "authors": ["1880"]}
{"title": "Tasking Event-B: An extension to Event-B for generating concurrent code\n", "abstract": " The Event-B method is a formal approach for modelling systems in safety-, and business-critical, domains. Initially, system specification takes place at a high level of abstraction; detail is added in refinement steps as the development proceeds toward implementation. Our aim has been to develop a novel approach for generating code, for concurrent programs, from Event-B. We formulated the approach so that it integrates well with the existing Event-B methodology and tools. In this paper we introduce a tasking extension for Event-B, with Tasking and Shared Machines. We make use of refinement, decomposition, and the extension, to structure projects for code generation for multitasking implementations. During the modelling phase decomposition is performed; decomposition reduces modelling complexity and makes proof more tractable. The decomposed models are then extended with sufficient information to enable generation of code. A task body describes a task\u2019s behaviour, mainly using imperative, programming-like constructs. Task priority and life-cycle (periodic, triggered, etc.) are also specified, but timing aspects are not modelled formally. We provide tool support in order to validate the practical aspects of the approach.", "num_citations": "53\n", "authors": ["1880"]}
{"title": "Integrated Formal Methods: 6th International Conference, IFM 2007, Oxford, UK, July 2-5, 2007, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 6th International Conference on Integrated Formal Methods, IFM 2007, held in Oxford, UK. It addresses all aspects of formal methods integration, including of a process of analysis or design application of formal methods to analysis or design, extension of one method based upon the inclusion of ideas or concepts from others, and semantic integration or practical application.", "num_citations": "51\n", "authors": ["1880"]}
{"title": "Supporting reuse of Event-B developments through generic instantiation\n", "abstract": " It is believed that reusability in formal development should reduce the time and cost of formal modelling within a production environment. Along with the ability to reuse formal models, it is desirable to avoid unnecessary re-proof when reusing models. Event-B is a formal method that allows modelling and refinement of systems. Event-B supports generic developments through the context construct. Nevertheless Event-B lacks the ability to instantiate and reuse generic developments in other formal developments. We propose a way of instantiating generic models and extending the instantiation to a chain of refinements. We define sufficient proof obligations to ensure that the proofs associated to a generic development remain valid in an instantiated development thus avoiding re-proofs.", "num_citations": "50\n", "authors": ["1880"]}
{"title": "Incremental design of distributed systems with Event-B\n", "abstract": " It is shown how Event-B can be use to model and reason about distributed systems from a high-level global view down to a detailed distributed architectural view. It is shown how refinement and decomposition can be used to introduce distribution of state and control and to introduce message passing between components. Distribution is treated as a special case of concurrency. Techniques are presented for decomposing abstract atomic events into smaller atomic steps in refinement and for decomposing models into sub-models.", "num_citations": "49\n", "authors": ["1880"]}
{"title": "A proposal for records in Event-B\n", "abstract": " The B method is a well known approach to the formal specification and development of sequential computer programs. Inspired by action systems, the B method has evolved to incorporate system modelling and distributed system development. This extension is called Event-B. Even though several of the structuring mechanisms of the original B method are absent from Event-B, the desire to define and maintain structured data persists. We propose the introduction of records to Event-B for this purpose. Our approach upholds the refinement principles of Event-B by allowing the stepwise development of records too.", "num_citations": "49\n", "authors": ["1880"]}
{"title": "On the use of data refinement in the development of secure communications systems\n", "abstract": " We report on experiences gained from the application of data refinement techniques to the development of examples of secure communications systems. The aim was to the carry the development from initial abstract specification of security services through to detailed designs. The development approach was based on action systems, with B and CSP being used as concrete notations. The security services in question are a confidential communications service and an authenticated transaction service. Refinements include explicit representations of intruder behaviour. The paper makes several interrelated contributions. It demonstrates the feasibility of applying a refinement approach to this type of problem, including an effective way of combining B and CSP in refinements. It introduces a more systematic approach to the development of abstraction invariants and refinement checking. Finally, it illustrates the\u00a0\u2026", "num_citations": "47\n", "authors": ["1880"]}
{"title": "Exploring summation and product operators in the refinement calculus\n", "abstract": " Product and summation operators for predicate transformers were introduced by Naumann [23] and by Martin [18] using category theoretic considerations. In this paper, we formalise these operators in the higher order logic approach to the refinement calculus of [5], prove various algebraic properties of these operators, and look at several of their applications. We look at how the product operator provides a model of simultaneous execution of statements, while the summation operator provides a simple model of late binding. We also generalise the product operator slightly to form an operator that corresponds to conjunction of specifications. We show how the product operator may be used to model extension and modification operators for programs, and how a combination of the product and summation operators may be used to model inheritance in an object-oriented programming language.", "num_citations": "47\n", "authors": ["1880"]}
{"title": "Specification and refinement of discrete timing properties in Event-B\n", "abstract": " Event-B is a formal language for systems modeling, based on set theoryand predicate logic. It has the advantage of mechanized proof, and it is possible tomodel a system in several levels of abstraction by using refinement. Discrete timingproperties are important in many critical systems. However, modeling of timingproperties is not directly supported in Event-B. In this paper we identify three maincategories of discrete timing properties for trigger-response pattern, deadline, delayand expiry. We introduce language constructs for each of these timing properties thataugment the Event-B language. We describe how these constructs can be mappedto standard Event-B constructs. To ease the process of using the timing constructsin a refinement-based development, we introduce patterns for refining the timingconstructs that allow timing properties on abstract models to be replaced by timingproperties on refined models. The language constructs and refinement patternsare illustrated through some generic examples. Event-B refinement allows atomicevents at the abstract level to be broken down into sub-steps at the refined level. The goal of our refinement patterns is to provide an easy way to represent and correctlyrefine timing constraints on abstract atomic events with more elaborate timingconstraints on the refined events. This paper presents an initial set of patterns.", "num_citations": "46\n", "authors": ["1880"]}
{"title": "Applying atomicity and model decomposition to a space craft system in Event-B\n", "abstract": " Event-B is a formal method for modeling and verifying consistency of systems. In formal methods such as Event-B, refinement is the process of enriching or modifying an abstract model in a step-wise manner in order to manage the development of complex and large systems. To further alleviate the complexity of developing large systems, Event-B refinement can be augmented with two techniques, namely atomicity decomposition and model decomposition. Our main objective in this paper is to investigate and evaluate the application of these techniques when used in a refinement based development. These techniques have been applied to the formal development of a space craft system. The outcomes of this experimental work are presented as assessment results. The experience and assessment can form the basis for some guidelines in applying these techniques in future cases.", "num_citations": "44\n", "authors": ["1880"]}
{"title": "Event-B patterns for specifying fault-tolerance in multi-agent interaction\n", "abstract": " Interaction in a multi-agent system is susceptible to failure. A rigorous development of a multi-agent system must include the treatment of fault-tolerance of agent interactions for the agents to be able to continue to function independently. Patterns can be used to capture fault-tolerance techniques. A set of modelling patterns is presented that specify fault-tolerance in Event-B specifications of multi-agent interactions. The purpose of these patterns is to capture common modelling structures for distributed agent interaction in a form that is re-usable on other related developments. The patterns have been applied to a case study of the contract net interaction protocol.", "num_citations": "44\n", "authors": ["1880"]}
{"title": "A system-based approach to the formal development of embedded controllers for a railway\n", "abstract": " We describe a formal approach to the development of embedded controllers for a railway. The approach starts with a system-level specification modeling the system under control and the desired control behavior. Correctness-preserving refinement is then used to add more and more implementation detail to the models and to decompose the models into sub-systems to arrive at models of individual controllers. The B Method is used as the formal notation and methodology.", "num_citations": "44\n", "authors": ["1880"]}
{"title": "Verifying dynamic properties of UML models by translation to the B language and toolkit\n", "abstract": " Formal languages such as the B language, enable the dynamic behaviour of a system to be investigated and verified. B is particularly suitable for this because of its good level of tool support. A model\u2019s behaviour can be explored using the animation facilities in the B Toolkit. It\u2019s behaviour can be proven to conform to its specified invariants using the proof tools available in the B tools. The equivalence of two alternative expressions of a model could be established using the tool. By expressing invariants and dynamic behaviour suitably in a UML class diagram the model can be translated into B automatically in order to obtain these benefits.", "num_citations": "43\n", "authors": ["1880"]}
{"title": "Applying event and machine decomposition to a flash-based filestore in Event-B\n", "abstract": " Event-B is a formal method used for specifying and reasoning about systems. Rodin is a toolset for developing system models in Event-B. Our experiment which is outlined in this paper is aimed at applying Event-B and Rodin to a flash-based filestore. Refinement is a useful mechanism that allows developers to sharpen models step by step. Two uses of refinement, feature augmentation and structural refinement, were employed in our development. Event decomposition and machine decomposition are structural refinement techniques on which we focus in this work. We present an outline of a verified refinement chain for the flash filestore. We also outline evidence of the applicability of the method and tool together with some guidelines.", "num_citations": "42\n", "authors": ["1880"]}
{"title": "Using a Graphical Design Tool for Formal Specification.\n", "abstract": " Department of Electronics and Computer Science University of Southampton Highfield, Southampton, SO17 1BJ, United Kingdom.{cfs98r, MJ Butler}@ ecs. soton. ac. uk", "num_citations": "39\n", "authors": ["1880"]}
{"title": "Fusion and simultaneous execution in the refinement calculus\n", "abstract": " In the refinement calculus, program statements are modelled as predicate transformers. A product operator for predicate transformers was introduced by Martin [18] and Naumann [25] using category theoretic considerations. In this paper, we look more closely at the refinement-oriented properties of this operator and at its applications. We also generalise the definition of the product operator to form what we call a fusion operator. Together, the fusion and product operators provide us with algebraic ways of composing program statements in the refinement calculus in order to model effects such as conjunction of specifications, simultaneous execution, and embedding of smaller programs into larger contexts.", "num_citations": "39\n", "authors": ["1880"]}
{"title": "A method of refinement in UML-B\n", "abstract": " UML-B is a \u2018UML-like\u2019 graphical front-end for Event-B that provides support for object-oriented and state machine modelling concepts, which are not available in Event-B. In particular, UML-B includes class diagram and state machine diagram editors with automatic generation of corresponding Event-B. In Event-B, refinement is used to relate system models at different abstraction levels. The same refinement concepts are also applicable in UML-B but require special consideration due to the higher-level modelling concepts. In previous work, we described a case study to introduce support for refinement in UML-B. We now provide a more complete presentation of the technique of refinement in UML-B including a formalisation of the refinement rules and a definition of the extensions to the abstract syntax of UML-B notation. The provision of gluing invariants to discharge the proof obligations associated with a\u00a0\u2026", "num_citations": "37\n", "authors": ["1880"]}
{"title": "Tool support for visualizing CSP in UML\n", "abstract": " In this paper, we propose an approach to translating UML to CSP that allows one to utilize both UML and CSP in a system design. To do so, we divide the visualization task based on three aspects of CSP: (i) the dynamics behavior, (ii) the static architecture, and (iii) the refinement assertions. In doing so we are able to visualize CSP via UML in a hierarchical manner which enhances understanding in the design process. In a way, we also provide a formal verification for the UML diagrams using CSP, since there are model checkers like FDR available. We have adopted the use of UML state diagram and class diagram for our work. In addition, we have outlined a prototyped tool that translates these diagrams to CSP that could be model-checked in FDR.", "num_citations": "37\n", "authors": ["1880"]}
{"title": "An approach to combining B and Alloy\n", "abstract": " In this paper we propose to combine two software verification approaches, theorem proving and model checking. We focus on the B-method and a theorem proving tool associated with it, and the Alloy specification notation and its model checker \u201cAlloy Constraint Analyser\u201d. We consider how software development in B can be assisted using Alloy and how Alloy can be used for verifying refinement of abstract specifications. We demonstrate our approach with an example.", "num_citations": "35\n", "authors": ["1880"]}
{"title": "Action systems, unbounded nondeterminism, and infinite traces\n", "abstract": " Morgan [Mor90a] has described a correspondence between Back's action systems [BKS83] and the conventionalfailures-divergences model of Hoare'scommunicating sequential processes (CSP) formalism [Hoa85]. However, the CSP failures-divergences model does not treat unbounded nondeterminism, although unbounded nondeterminism arises quite naturally in action systems; to that extent, the correspondence between the two approaches is inadequate.               Fortunately there is an extendedinfinite traces model of CSP [RoB89] which treats unbounded nondeterminism. We extend the CSP-action system correspondence, using that model instead, to take the unbounded nondeterminism of action systems properly into account.               In passing, we develop a definition of the weakest precondition under which an infinite heterogeneous trace of actions is enabled.", "num_citations": "35\n", "authors": ["1880"]}
{"title": "Automatic testing from formal specifications\n", "abstract": " In this article, we consider model oriented formal specification languages. We generate test cases by performing symbolic execution over a model, and from the test cases obtain a Java program. This Java program acts as a test driver and when it is run in conjunction with the implementation then testing is performed in an automatic manner. Our approach makes the testing cycle fully automatic. The main contribution of our work is that we perform automatic testing even when the models are non-deterministic.", "num_citations": "34\n", "authors": ["1880"]}
{"title": "Evaluation of a guideline by formal modelling of cruise control system in Event-B\n", "abstract": " Recently a set of guidelines, or cookbook, has been developed for modelling and refinement of control problems in Event-B. The Event-B formal method is used for system-level modelling by defining states of a system and events which act on these states. It also supports refinement of models. This cookbook is intended to systematise the process of modelling and refining a control problem system by distinguishing environment, controller and command phenomena. Our main objective in this paper is to investigate and evaluate the usefulness and effectiveness of this cookbook by following it throughout the formal modelling of cruise control system found in cars. The outcomes are identifying the benefits of the cookbook and also giving guidance to its future users.", "num_citations": "33\n", "authors": ["1880"]}
{"title": "Composing Event-B specifications-case-study experience\n", "abstract": " Event-B is a formal method, based on set theory and first-order logic, for specification and verification of reactive systems supported by the Rodin tool kit. Feature modelling is a well-known technique for managing variability and configuring products within software product lines (SPLs). Our objective is to explore whether we can use existing Event-B composition techniques and tooling for feature-based product line development. If case-study experiments reveal these mechanisms to be inadequate, then they also should suggest further research directions. The main objective is to maximise the amount of reuse. This includes avoiding as far as possible having to reprove a composed specification when the models being composed have already been proven. We have modelled two case-studies in Event-B using both horizontal and vertical refinements. This work contributes by analysing existing tools and\u00a0\u2026", "num_citations": "32\n", "authors": ["1880"]}
{"title": "Linking Event-B and concurrent object-oriented programs\n", "abstract": " The Event-B method is a formal approach to modelling systems, using refinement. Initial specification is done at a high level of abstraction; detail is added in refinement steps as the development proceeds toward implementation. In software systems that use concurrent processing it is necessary to provide details of concurrent features before implementation. Our contribution is to show how Event-B models can be linked to concurrent, object-oriented implementations using an intermediate, object-oriented style specification notation. To validate our approach and gain further insight we automated the translation process with an Eclipse plug-in which produces an Event-B model and Java code. We call the new notation Object-oriented Concurrent-B (OC-B). The notation facilitates specification of the concurrent aspects of a development, and facilitates reasoning about concurrency issues in an abstract manner. We\u00a0\u2026", "num_citations": "32\n", "authors": ["1880"]}
{"title": "Symmetry reduction for B by permutation flooding\n", "abstract": " Symmetry reduction is an established method for limiting the amount of states that have to be checked during exhaustive model checking. The idea is to only verify a single representative of every class of symmetric states. However, computing this representative can be non-trivial, especially for a language such as B with its involved data structures and operations. In this paper, we propose an alternate approach, called permutation flooding. It works by computing permutations of newly encountered states, and adding them to the state space. This turns out to be relatively unproblematic for B\u2019s data structures and we have implemented the algorithm inside the ProB model checker. Empirical results confirm that this approach is effective in practice; speedups exceed an order of magnitude in some cases. The paper also contains correctness results of permutation flooding, which should also be applicable for\u00a0\u2026", "num_citations": "32\n", "authors": ["1880"]}
{"title": "The hybrid ERTMS/ETCS level 3 case study\n", "abstract": " This document presents a description of the European Rail Traffic Management System (ERTMS) case study. ERTMS is a system of standards for management and interoperation of signalling for railways by the European Union (EU). The case study focuses on the ERTMS Level 3 Hybrid principle, which accommodates different types of trains including ERTMS trains equiped with the Train Integrity Monitoring System (TIMS), ERTMS trains without TIMS, and non-ERTMS trains.", "num_citations": "31\n", "authors": ["1880"]}
{"title": "Questions and answers about ten formal methods\n", "abstract": " An abstract model of an industrial distributed data base application has been studied using process based, state based, and queueing theory based methods. The methods supported by graphical notations and/or integrated development environments were found to be easiest to work with. The methods supported by model checkers were the most successful in obtaining relevant information about the application. Applying a number of different methods to study one particular model encourages a problem to be viewed from different angles. This gives complementary information about the model. We report on a variety of problems of the model found through various routes. Our main conclusion is that asking experts to apply different methods and tools at a sufficiently abstract level can be done effectively revealing a broad range of information about the considered application.", "num_citations": "31\n", "authors": ["1880"]}
{"title": "Rigorous design of fault-tolerant transactions for replicated database systems using Event B\n", "abstract": " System availability is improved by the replication of data objects in a distributed database system. However, during updates, the complexity of keeping replicas identical arises due to failures of sites and race conditions among conflicting transactions. Fault tolerance and reliability are key issues to be addressed in the design and architecture of these systems. Event B is a formal technique which provides a framework for developing mathematical models of distributed systems by rigorous description of the problem, gradually introducing solutions in refinement steps, and verification of solutions by discharge of proof obligations. In this paper, we present a formal development of a distributed system using Event B that ensures atomic commitment of distributed transactions consisting of communicating transaction components at participating sites. This formal approach carries the development of the system from\u00a0\u2026", "num_citations": "30\n", "authors": ["1880"]}
{"title": "Tool support for Event-B code generation\n", "abstract": " The Event-B method is a formal approach to modelling systems, using refinement. Initial specification is done at a high level of abstraction; detail is added in refinement steps as the development proceeds toward implementation. In previous work we developed an approach to bridge the gap between abstract specifications and implementations using an implementation level specification notation. In this paper we present details of the tool support for our notation and some of our experiences using the tool.", "num_citations": "29\n", "authors": ["1880"]}
{"title": "Symmetry reduced model checking for B\n", "abstract": " Symmetry reduction is a technique that can help alleviate the problem of state space explosion in model checking. The idea is to verify only a subset of states from each class (orbit) of symmetric states. This paper presents a framework for symmetry reduced model checking of B machines, which verifies a unique representative from each orbit. Symmetries are induced by the deferred set; a key component of the B language. This contrasts with strategies that require the introduction of a special data type into a language, to indicate symmetry. An extended version of the graph isomorphism program, nauty, is used to detect symmetries, and the symmetry reduction package has been integrated into the PROB model checker. Relevant algorithms are presented, and experimental results illustrate the effectiveness of the method, where exponential speedups are sometimes possible.", "num_citations": "29\n", "authors": ["1880"]}
{"title": "Language and tool support for event refinement structures in Event-B\n", "abstract": " Event-B is a formal method for modelling and verifying the consistency of chains of model refinements. The event refinement structure (ERS) approach augments Event-B with a graphical notation which is capable of explicit representation of control flows and refinement relationships. In previous work, the ERS approach has been evaluated manually in the development of two large case studies, a multimedia protocol and a spacecraft sub-system. The evaluation results helped us to extend the ERS constructors, to develop a systematic definition of ERS, and to develop a tool supporting ERS. We propose the ERS language which systematically defines the semantics of the ERS graphical notation including the constructors. The ERS tool supports automatic construction of the Event-B models in terms of control flows and refinement relationships. In this paper we outline the systematic definition of ERS including\u00a0\u2026", "num_citations": "28\n", "authors": ["1880"]}
{"title": "Co-simulating Event-B and continuous models via FMI\n", "abstract": " We present a generic co-simulation approach between discrete-event models, developed in the Event-B formal method, and continuous models, exported via the Functional Mock-up Interface for Co-simulation standard. The concept is implemented into a simulation extension for the Rodin platform, thus leveraging powerful capabilities of refinement-based modelling and deductive verification in Event-B while introducing a continuous-time aspect and simulation-based validation for the development of complex hybrid systems.", "num_citations": "28\n", "authors": ["1880"]}
{"title": "Redevelopment of an industrial case study using Event-B and Rodin\n", "abstract": " CDIS is a commercial air traffic information system that was developed using formal methods 15 years ago by Praxis, and it is still in operation today. This system is an example of an industrial scale system that has been developed using formal methods. In particular, the functional requirements of the system were specified using VVSL \u2013 a variant of VDM. A subset of the original specification has been chosen to be reconstructed on the Rodin platform based on the new Event-B formalism. The goal of our reconstruction was to overcome three key difficulties of the original formalisation, namely the difficulty of comprehending the original specification, the lack of any mechanical proof of the consistency of the specification and the difficulty of dealing with distribution and atomicity refinement. In this paper we elucidate how a new formal notation and tool can help to overcome these difficulties.", "num_citations": "28\n", "authors": ["1880"]}
{"title": "Rigorous development of reusable, domain-specific components, for complex applications\n", "abstract": " The reuse of reliable, domain-specific software components is a strategy commonly used in the avionics industry to develop safety critical airborne systems. One method of achieving reuse is to use domain specific languages that map closely onto abstractions in the problem domain. While this works well for control algorithms, it is less successful for some complex ancillary functions such as failure management. The characteristics of device failures are often difficult to predict resulting in late requirements changes. Hence a small semantic gap is especially desirable but difficult to achieve. Object-oriented design techniques include mechanisms, such as inheritance, that cater well for variations in behaviour. However, object-oriented notations such as the UML lack the precision, and rigor, needed for safety critical software. UML-B is a profile of the UML for formal modelling. In this paper we show how UML-B can be used to model failure management systems via progressive refinement, and indicate how this approach could utilise UML concepts to cope with high variability, while providing rigorous verification.", "num_citations": "28\n", "authors": ["1880"]}
{"title": "An approach to modelling and refining timing properties in B\n", "abstract": " The work described in this extended abstract is being undertaken as part of the EU-funded MATISSE project (IST-1999-11435). One of the major case studies of MATISSE involves the application of the B Method [2] to a railway control system. The emphasis of the work is on system-level modelling and analysis. This means we are not just modelling pieces of control software in B, but we are using B to model relevant aspects of an entire network. For example, a system-level model would include physical connections between track sections, the positions of trains in terms of the sections they currently occupy, and under what system-level conditions the emergency brakes should be applied to ensure safety. This system-level model has been decomposed and refined into distributed trackside and on-board controllers with messages passing between them. This allows us to derive the software specifications for the individual controllers in a way that increases our confidence that the combination of the software and physical components achieve the desired system-level safety properties.While taking a systems approach to the development of the railway controllers, it became clear that it was important to model timing constraints in some form. For example, without any model of time we could represent a requirement on the emergency brakes in B in one of two forms:", "num_citations": "28\n", "authors": ["1880"]}
{"title": "The operational semantics of a Java secure processor\n", "abstract": " A formal specification of a Java Secure Processor is presented, which is mechanically checked for type consistency, well formedness and operational conservativity. The specification is executable and it is used to animate and study the behaviour of sample Java programs. The purpose of the semantics is to document the behaviour of the complete JSP for the benefit of implementors.", "num_citations": "28\n", "authors": ["1880"]}
{"title": "The UML-B profile for formal systems modelling in UML\n", "abstract": " The UML is a popul\u00e4r modelling notation that has a natural appeal to hardware and Software engineers and is adaptable through extension mechanisms. Formal (mathematical) modelling languages, on the other hand, are seen as difficult and costly to use and have achieved only limited use despite the benefits that they offer. In previous work, we have proposed an Integration of UML and the formal notation, B and provided an automatic translator that produces a B specification. The integrated modelling notation, UML-B, inherits from both UML and B but primarily, is a specialisation of the UML. To achieve this Integration we have specialised UML modelling elements via stereotypes, added tagged values to represent B modelling features and imposed constraints to ensure that UML-B modeis are translated into usable B. Here we describe ongoing work to define UML-B as a profile in accordance with the\u00a0\u2026", "num_citations": "27\n", "authors": ["1880"]}
{"title": "UML-B: A plug-in for the Event-B tool set\n", "abstract": " UML-B provides a graphical front end for Event-B. It adds support for class-oriented and state machine modelling. UML-B is similar to UML but has its own meta-model. UML-B provides tool support, including drawing tools and a translator to generate Event-B models. The tools are closely integrated with the Event-B tools. When a drawing is saved the translator automatically generates the corresponding Event-B model. The Event-B verification tools (syntax checker and prover) then run automatically providing an immediate display of problems which are indicated on the relevant UML-B diagram. We introduce the UML-B notation, tool support and integration with Event-B.UML-B is a graphical formal modelling notation based on UML [1]. It relies on Event-B [2] for its underlying semantics and is closely integrated with the Event-B verification tools [3]. UML-B and Event-B are implemented within the Eclipse [4] environment. This paper gives a brief introduction to UML-B. A more detailed description is provided in [5].", "num_citations": "26\n", "authors": ["1880"]}
{"title": "Refinement and decomposition of value-passing action systems\n", "abstract": " The action system formalism [3] is a state-based approach to distributed computing. In this paper, it is shown how the action system formalism may be used to describe systems that interact with their environment through synchronised value-passing. Definitions and rules are presented for refining and decomposing such action systems into distributed implementations in which internal communication is also based on synchronised value-passing. Specification and refinement is similar to the refinement calculus approach [1, 10, 12]. The theoretical basis for communication and distribution is Hoare's CSP [6]. Use of the refinement and decomposition rules is illustrated by the design of an unordered buffer.", "num_citations": "26\n", "authors": ["1880"]}
{"title": "Validating the requirements and design of a hemodialysis machine using iUML-B, BMotion studio, and co-simulation\n", "abstract": " We present a formal specification of a hemodialysis machine (HD machine) using Event-B. We model the HD machine using iUML-B state-machines and class diagrams and build a corresponding BMotion Studio visualisation. We focus on validation using (i) diagrams to aid the modelling of the sequential properties of the requirements, and (ii) ProB-based animation and visualisation tools to explore the system\u2019s behaviour. Some of the safety properties involve dynamic behaviour which is difficult to verify in Event-B. For these properties we use co-simulation tools to validate against a continuous model of the physical behaviour.", "num_citations": "25\n", "authors": ["1880"]}
{"title": "Proposals for mathematical extensions for Event-B\n", "abstract": " In this document we propose an approach to support user-defined extension of the mathematical language and theory of Event-B. The proposal consists of considering three kinds of extension:", "num_citations": "25\n", "authors": ["1880"]}
{"title": "Formal analysis of safety and security requirements of critical systems supported by an extended STPA methodology\n", "abstract": " Cyber-physical systems represent an engineering challenge due to their safety and security concerns, particularly those systems involved in critical infrastructure which require some of the highest standards of safety, availability, integrity and security. The complexity of these systems makes the identification and analysis of safety and security requirements challenging. In this paper, we present a methodology for identifying and formally analysing safety and security requirements, based on the STPA methodology and combined with modelling, traceability and formal verification through use of the Event-B formal method. Our STPA approach is then leveraged to generate 'critical requirements' to mitigate against undesirable system states, which are subsequently translated into constraints on an Event-B representation of the system. The Rodin toolset allows us to demonstrate that these critical requirements fully mitigate\u00a0\u2026", "num_citations": "24\n", "authors": ["1880"]}
{"title": "A systematic approach to atomicity decomposition in Event-B\n", "abstract": " Event-B is a state-based formal method that supports a refinement process in which an abstract model is elaborated towards an implementation in a step-wise manner. One weakness of Event-B is that control flow between events is typically modelled implicitly via variables and event guards. While this fits well with Event-B refinement, it can make models involving sequencing of events more difficult to specify and understand than if control flow was explicitly specified. New events may be introduced in Event-B refinement and these are often used to decompose the atomicity of an abstract event into a series of steps. A second weakness of Event-B is that there is no explicit link between such new events that represent a step in the decomposition of atomicity and the abstract event to which they contribute. To address these weaknesses, atomicity decomposition diagrams support the explicit modelling of control\u00a0\u2026", "num_citations": "24\n", "authors": ["1880"]}
{"title": "Structuring functional requirements of control systems to facilitate refinement-based formalisation\n", "abstract": " Good requirements structure can greatly facilitate the construction of formal models of systems. This paper describes an approach to requirements structuring for control systems that aims to facilitate refinement-based formalisation. In addition to the well-known monitored and controlled phenomena used to analyse control systems, we also identify commanded phenomenon reflecting the special role that an operator plays in system control. These system phenomena guide the structure of the requirements analysis and documentation as well as the structure of the formal models.", "num_citations": "24\n", "authors": ["1880"]}
{"title": "A trust analysis methodology for pervasive computing systems\n", "abstract": " We present an analysis Trust Analysis Methodology for finding trust issues within pervasive computing systems. It is based on a systematic analysis of scenarios that describe the typical use of the pervasive system by using a Trust Analysis Grid. The Trust Analysis Grid is composed of eleven Trust Issue Categories that cover the various aspects of the concept of trust in pervasive computing systems. The Trust Analysis Grid is then used to guide the design of the pervasive computing system.", "num_citations": "24\n", "authors": ["1880"]}
{"title": "Calculational derivation of pointer algorithms from tree operations\n", "abstract": " We describe an approach to the derivation of correct algorithms on tree-based pointer structures. The approach is based on enriching trees in a way that allows us to model commonly used pointer manipulations on tree structures. We provide rules which allow recursive functions on trees to be transformed into imperative algorithms on enriched trees. In addition, we provide rules which allow algorithms on enriched trees to be mechanically transformed into efficient pointer algorithms. All transformations are correctness-preserving. A key point of our approach is that we avoid aliasing through the way in which trees are enriched and through some simple syntactic restrictions on transformable programs.", "num_citations": "24\n", "authors": ["1880"]}
{"title": "Modelling and refining hybrid systems in Event-B and Rodin\n", "abstract": " We outline an approach to modelling and reasoning about hybrid systems with the Event-B method supported by the Rodin toolset. The approach uses continuous functions over real intervals to model the evolution of continuous values over time. Nondeterministic interval events are used to specify how continuous variables evolve within an operating mode. Refinement is used to constrain the choice of continuous functions and to decompose a non-deterministic interval event into a series of periodic interval events.", "num_citations": "23\n", "authors": ["1880"]}
{"title": "Verification of UML models by translation to UML-B\n", "abstract": " UML-B is a \u2018UML like\u2019 notation based on the Event-B formalism which allows models to be progressively detailed through refinements that are proven to be consistent and to satisfy safety invariants using the Rodin platform and its automatic proof tools. UML, on the other hand, encourages large models to be expressed in a single, detailed level and relies on simulation and model testing techniques for verification. The advantage of proof over model-testing is that the proof is valid for all instantiations of the model whereas a simulation must choose a typical instantiation. In the INESS project we take an extant UML model of a railway interlocking system and explore methodical ways to translate it into UML-B in such a way as to facilitate proof that the model satisfies certain safety properties which are expressed as invariants. We describe the translation attempted so far and insights that we have gained from\u00a0\u2026", "num_citations": "23\n", "authors": ["1880"]}
{"title": "UML-B Specification for Proven Embedded Systems Design\n", "abstract": " AII Rights Reserved\u00a9 2004 Springer Science+ Business Media New York Originally published by Kluwer Academic Publishers, Boston in 2004 Softcover reprint ofthe hardcover lst edition 2004 No part of this work may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, electronic, mechanical, photocopying, microfilming, recording or otherwise, without written permis sion from the Publisher, with the exception of any material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work.", "num_citations": "23\n", "authors": ["1880"]}
{"title": "Program derivation using the refinement calculator\n", "abstract": " The refinement calculus provides a theory for the stepwise refinement of programs and this theory has been formalised in HOL. TkWinHOL is a powerful graphical user interface (GUI) that can be used to drive the HOL window Library. In this paper, we describe a tool called the Refinement Calculator which combines TkWinHOL and the HOL Refinement Calculus theory, to provide support for formal program development. The tool improves the usability of the HOL Refinement Calculus theory considerably through its window-inference based GUI and by supporting a conventional programming syntax.", "num_citations": "23\n", "authors": ["1880"]}
{"title": "Building traceable Event-B models from requirements\n", "abstract": " Bridging the gap between informal requirements and formal specifications is a key challenge in systems engineering. Constructing appropriate abstractions in formal models requires skill and managing the complexity of the relationships between requirements and formal models can be difficult. In this paper we present an approach that aims to address the twin challenges of finding appropriate abstractions and managing traceability between requirements and models. Our approach is based on the use of semi-formal structures to bridge the gap between requirements and Event-B models and retain traceability to requirements in Event-B models. In the stepwise refinement approach, design details are gradually introduced into formal models. Stepwise refinement allows each requirement to be introduced at the most appropriate stage in the development. Our approach makes use of the UML-B and Event Refinement\u00a0\u2026", "num_citations": "21\n", "authors": ["1880"]}
{"title": "Some guidelines for formal development of web-based applications in b-method\n", "abstract": " Web-based applications are the most common form of distributed systems that have gained a lot of attention in the past ten years. Today many of us are relying on scores of mission-critical Web-based systems in different areas such as banking, finance, e-commerce and government. The development process of these systems needs a sound methodology, which ensures quality, consistency and integrity. Formal Methods provide systematic and quantifiable approaches to create coherent systems. Despite this there has been limited work on the formal modelling of Web-based applications. In this paper our aim is to provide researchers with some guidelines based on results from ongoing work to model a Web-based system using the B-Method. Session and state management, developing formal models for complex data types, abstraction of distributed database systems and formal representation of\u00a0\u2026", "num_citations": "21\n", "authors": ["1880"]}
{"title": "Cruise control in hybrid Event-B\n", "abstract": " A case study on automotive cruise control originally done in (conventional, discrete) Event-B is reexamined in Hybrid Event-B (an extension of Event-B that includes provision for continuously varying behaviour as well as the usual discrete changes of state). A significant case study such as this has various benefits. It can confirm that the Hybrid Event-B design allows appropriately fluent application level modelling (as is needed for serious industrial use). It also permits a critical comparison to be made between purely discrete and genuinely hybrid modelling. The latter enables application requirements to be covered in a more natural way. It also enables some inconvenient modelling metaphors to be eliminated.", "num_citations": "20\n", "authors": ["1880"]}
{"title": "Reasoned modelling critics: turning failed proofs into modelling guidance\n", "abstract": " The activities of formal modelling and reasoning are closely related. But while the rigour of building formal models brings significant benefits, formal reasoning remains a major barrier to the wider acceptance of formalism within design. Here we propose reasoned modelling critics \u2013 a technique which aims to abstract away from the complexities of low-level proof obligations, and provide high-level modelling guidance to designers when proofs fail. Inspired by proof planning critics, the technique combines proof-failure analysis with modelling heuristics. Here, we present the details of our proposal and outline future plans.", "num_citations": "20\n", "authors": ["1880"]}
{"title": "Applying Event-B atomicity decomposition to a multi media protocol\n", "abstract": " Atomicity Decomposition is a technique in the Event-B formal method, which augments Event-B refinement with additional structuring in a diagrammatic notation to support complex refinement in Event-B. This paper presents an evaluation of Event-B atomicity decomposition technique in modeling a multi media case study with the diagrammatic notation. Firstly the existing technique and the diagrammatic notation are shown. Secondly an evaluation is performed by developing a model of a Media Channel System. A Media Channel is established between two endpoints for transferring multi-media data. Finally some extensions to the existing diagrammatic notation are proposed and applied to the multi-media case study.", "num_citations": "20\n", "authors": ["1880"]}
{"title": "Application of Event B to global causal ordering for fault tolerant transactions\n", "abstract": " d {qn wmzh|{mwn mwrVsqik d {h ikfQsq hkmw l& pqo hkn mwl pvmwn hjikmg qtqhkf pqo njf% n mgn tun& hk ikfQsq hkfT pqo o hknU qfQl hji lunko hkmg mwnU svikf rVmgluo ldhk ikf) fQysf pvtqikmwlutusrpqo hkfQnQ H hk rVsq vmwh sfQfQsqmglqikf o& mgpqf lHhkmw ikmwnjfQni pqtuf wtqikfQn lHtur susqik ufQn& fQfQl sqik r5o sf5 n hkfQrVn e rVfQnjnko sqik uf ikf tunko ikmglq lV rVfQnjnko qfW o ikmzhk urVn fQlqnjtqikmwlu z {T pT pvfQ wmwysf rVfQnjnko r5oQ {tusu mwhk% hk uf svik yHmwnjmw lqni hk V svik yHmgpqfh f& mwlT fQy fQldh gtvikfQn qf& Hp svik yHmgpqf hkf% njfQp ikr5o hkmw lun& ikmzhkmwlu njs hkmw ikfT n hkfQrVn ysfQldh# sqik yHmgpqfQn ikr5o susvik y pvfQysfQ surVfQldh& njtq rVsq l hk umwn suo) fV svikfQnjfQldh suo mwlq mwl qmgn% o ikfQo qf njs hkmw ikmwlu rVfQnjnko fQn% mwn sqikf njfQldhkf umwlqf ikmwlu e rVfQnjnko fQni r5oQ {fo umwfQy p d {& mgrVsq wfQrVfQldhkmwlu nko rVfi o sqsqik V r5oQ {& HhkfQlupvf p& hk hk ikr5o A pvfQysfQ surVfQldh io% zh& hk ldh& pqmwn hjikmw utvhkf py pqo o% ikfQsq hkmw l n hkfQr", "num_citations": "20\n", "authors": ["1880"]}
{"title": "Reasoning about Grover's quantum search algorithm using probabilistic wp\n", "abstract": " Grover's search algorithm is designed to be executed on a quantum-mechanical computer. In this article, the probabilistic wp-calculus is used to model and reason about Grover's algorithm. It is demonstrated that the calculus provides a rigorous programming notation for modeling this and other quantum algorithms and that it also provides a systematic framework of analyzing such algorithms.", "num_citations": "20\n", "authors": ["1880"]}
{"title": "Mastering System Analysis and Design through Abstraction and Refinement.\n", "abstract": " The complexity of requirements and complexity of operating environments make error detection in early stages of software system development difficult. This paper makes an argument for the use of formal modelling and verification in early stages of system development to identify and eliminate errors in a timely fashion. Precision is key to eliminating errors in requirements while abstraction is key to mastering requirements complexity. The paper outlines the way in which precision and abstraction may be achieved through modelling and how refinement allows the complexity to be managed through layering. The role of model validation and model verification in improving the quality of formal models and in improving the quality of the requirements is also outlined. The formalism used throughout is Event-B supported by the Rodin toolset.", "num_citations": "19\n", "authors": ["1880"]}
{"title": "Core hybrid Event-B II: multiple cooperating hybrid Event-B machines\n", "abstract": " Hybrid Event-B, initially introduced for single machines to add continuously varying behaviour to discrete change of state in Event-B, is extended to cater for multiple cooperating machines. Multiple machine working is mediated by INTERFACE and PROJECT constructs. The former encapsulates a set of variables, their invariants and initialisations, in a form that several machines can exploit simultaneously. The latter organises the set of cooperating machines and interfaces into a coherent system. Machine instantiation and composition via interfaces are discussed. Machine decomposition is explored in this framework. Multi-machine refinement is described. A hypergraph project architecture is proposed. Two small case studies, on power switching and on the European Train Control System (the latter treated earlier within the single machine formalism), illustrate these mechanisms. The semantics of interacting multi\u00a0\u2026", "num_citations": "18\n", "authors": ["1880"]}
{"title": "A refinement-based correctness proof of symmetry reduced model checking\n", "abstract": " Symmetry reduction is a model checking technique that can help alleviate the problem of state space explosion, by preventing redundant state space exploration. In previous work, we have developed three effective approaches to symmetry reduction for B that have been implemented into the ProB model checker, and we have proved the soundness of our state symmetries. However, it is also important to show our techniques are sound with respect to standard model checking, at the algorithmic level. In this paper, we present a retrospective B development that addresses this issue through a series of B refinements. This work also demonstrates the valuable insights into a system that can be gained through formal modelling.", "num_citations": "18\n", "authors": ["1880"]}
{"title": "A roadmap for the Rodin toolset\n", "abstract": " Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels.", "num_citations": "18\n", "authors": ["1880"]}