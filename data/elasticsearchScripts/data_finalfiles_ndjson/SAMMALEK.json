{"title": "Evodroid: Segmented evolutionary testing of android apps\n", "abstract": " Proliferation of Android devices and apps has created a demand for applicable automated software testing techniques. Prior research has primarily focused on either unit or GUI testing of Android apps, but not their end-to-end system testing in a systematic manner. We present EvoDroid, an evolutionary approach for system testing of Android apps. EvoDroid overcomes a key shortcoming of using evolutionary techniques for system testing, ie, the inability to pass on genetic makeup of good individuals in the search. To that end, EvoDroid combines two novel techniques:(1) an Android-specific program analysis technique that identifies the segments of the code amenable to be searched independently, and (2) an evolutionary algorithm that given information of such segments performs a step-wise search for test cases reaching deep into the code. Our experiments have corroborated EvoDroid\u2019s ability to achieve\u00a0\u2026", "num_citations": "307\n", "authors": ["335"]}
{"title": "FUSION: a framework for engineering self-tuning self-adaptive software systems\n", "abstract": " Self-adaptive software systems are capable of adjusting their behavior at run-time to achieve certain objectives. Such systems typically employ analytical models specified at design-time to assess their characteristics at run-time and make the appropriate adaptation decisions. However, prior to system's deployment, engineers often cannot foresee the changes in the environment, requirements, and system's operational profile. Therefore, any analytical model used in this setting relies on underlying assumptions that if not held at run-time make the analysis and hence the adaptation decisions inaccurate. We present and evaluate FeatUre-oriented Self-adaptatION (FUSION) framework, which aims to solve this problem by learning the impact of adaptation decisions on the system's goals. The framework (1) allows for automatic online fine-tuning of the adaptation logic to unanticipated conditions,(2) reduces the upfront\u00a0\u2026", "num_citations": "256\n", "authors": ["335"]}
{"title": "Uncertainty in self-adaptive software systems\n", "abstract": " The ever-growing complexity of software systems coupled with their stringent availability requirements are challenging the manual management of software after its deployment. This has motivated the development of self-adaptive software systems. Self-adaptation endows a software system with the ability to satisfy certain objectives by automatically modifying its behavior at runtime. While many promising approaches for the construction of self-adaptive software systems have been developed, the majority of them ignore the uncertainty underlying the adaptation. This has been one of the key inhibitors to widespread adoption of self-adaption techniques in risk-averse real-world applications. Uncertainty in this setting is a vaguely understood term. In this paper, we characterize the sources of uncertainty in self-adaptive software system, and demonstrate its impact on the system\u2019s ability to satisfy its objectives\u00a0\u2026", "num_citations": "251\n", "authors": ["335"]}
{"title": "Testing android apps through symbolic execution\n", "abstract": " There is a growing need for automated testing techniques aimed at Android apps. A critical challenge is the systematic generation of test cases. One method of systematically generating test cases for Java programs is symbolic execution. But applying symbolic execution tools, such as Symbolic Pathfinder (SPF), to generate test cases for Android apps is challenged by the fact that Android apps run on the Dalvik Virtual Machine (DVM) instead of JVM. In addition, Android apps are event driven and susceptible to path-divergence due to their reliance on an application development framework. This paper provides an overview of a two-pronged approach to alleviate these issues. First, we have developed a model of Android libraries in Java Pathfinder (JPF) to enable execution of Android apps in a way that addresses the issues of incompatibility with JVM and path-divergence. Second, we have leveraged program\u00a0\u2026", "num_citations": "194\n", "authors": ["335"]}
{"title": "Taming uncertainty in self-adaptive software\n", "abstract": " Self-adaptation endows a software system with the ability to satisfy certain objectives by automatically modifying its behavior. While many promising approaches for the construction of self-adaptive software systems have been developed, the majority of them ignore the uncertainty underlying the adaptation decisions. This has been one of the key obstacles to wide-spread adoption of self-adaption techniques in risk-averse real-world settings. In this paper, we describe an approach, called POssIbilistic SElf-aDaptation (POISED), for tackling the challenge posed by uncertainty in making adaptation decisions. POISED builds on possibility theory to assess both the positive and negative consequences of uncertainty. It makes adaptation decisions that result in the best range of potential behavior. We demonstrate POISED's application to the problem of improving a software system's quality of service via runtime\u00a0\u2026", "num_citations": "172\n", "authors": ["335"]}
{"title": "A systematic survey of self-protecting software systems\n", "abstract": " Self-protecting software systems are a class of autonomic systems capable of detecting and mitigating security threats at runtime. They are growing in importance, as the stovepipe static methods of securing software systems have been shown to be inadequate for the challenges posed by modern software systems. Self-protection, like other self-* properties, allows the system to adapt to the changing environment through autonomic means without much human intervention, and can thereby be responsive, agile, and cost effective. While existing research has made significant progress towards autonomic and adaptive security, gaps and challenges remain. This article presents a significant extension of our preliminary study in this area. In particular, unlike our preliminary study, here we have followed a systematic literature review process, which has broadened the scope of our study and strengthened the validity of our\u00a0\u2026", "num_citations": "142\n", "authors": ["335"]}
{"title": "A learning-based framework for engineering feature-oriented self-adaptive software systems\n", "abstract": " Self-adaptive software systems are capable of adjusting their behavior at runtime to achieve certain functional or quality-of-service goals. Often a representation that reflects the internal structure of the managed system is used to reason about its characteristics and make the appropriate adaptation decisions. However, runtime conditions can radically change the internal structure in ways that were not accounted for during their design. As a result, unanticipated changes at runtime that violate the assumptions made about the internal structure of the system could degrade the accuracy of the adaptation decisions. We present an approach for engineering self-adaptive software systems that brings about two innovations: 1) a feature-oriented approach for representing engineers' knowledge of adaptation choices that are deemed practical, and 2) an online learning-based approach for assessing and reasoning about\u00a0\u2026", "num_citations": "116\n", "authors": ["335"]}
{"title": "Sig-droid: Automated system input generation for android applications\n", "abstract": " Pervasiveness of smartphones and the vast number of corresponding apps have underlined the need for applicable automated software testing techniques. A wealth of research has been focused on either unit or GUI testing of smartphone apps, but little on automated support for end-to-end system testing. This paper presents SIG-Droid, a framework for system testing of Android apps, backed with automated program analysis to extract app models and symbolic execution of source code guided by such models for obtaining test inputs that ensure covering each reachable branch in the program. SIG-Droid leverages two automatically extracted models: Interface Model and Behavior Model. The Interface Model is used to find values that an app can receive through its interfaces. Those values are then exchanged with symbolic values to deal with constraints with the help of a symbolic execution engine. The Behavior\u00a0\u2026", "num_citations": "72\n", "authors": ["335"]}
{"title": "Guidearch: guiding the exploration of architectural solution space under uncertainty\n", "abstract": " A system's early architectural decisions impact its properties (e.g., scalability, dependability) as well as stakeholder concerns (e.g., cost, time to delivery). Choices made early on are both difficult and costly to change, and thus it is paramount that the engineer gets them \u201cright\u201d. This leads to a paradox, as in early design, the engineer is often forced to make these decisions under uncertainty, i.e., not knowing the precise impact of those decisions on the various concerns. How could the engineer make the \u201cright\u201d choices in such circumstances? This is precisely the question we have tackled in this paper. We present GuideArch, a framework aimed at quantitative exploration of the architectural solution space under uncertainty. It provides techniques founded on fuzzy math that help the engineer with making informed decisions.", "num_citations": "70\n", "authors": ["335"]}
{"title": "Energy-aware test-suite minimization for android apps\n", "abstract": " The rising popularity of mobile apps deployed on battery-constrained devices has motivated the need for effective energy-aware testing techniques. Energy testing is generally more labor intensive and expensive than functional testing, as tests need to be executed in the deployment environment and specialized equipment needs to be used to collect energy measurements. Currently, there is a dearth of automatic mobile testing techniques that consider energy as a program property of interest. This paper presents an energy-aware test-suite minimization approach to significantly reduce the number of tests needed to effectively test the energy properties of an Android app. It relies on an energy-aware coverage criterion that indicates the degree to which energy-greedy segments of a program are tested. We describe and evaluate two complementary algorithms for test-suite minimization. Experiments over test suites\u00a0\u2026", "num_citations": "57\n", "authors": ["335"]}
{"title": "\u00b5droid: an energy-aware mutation testing framework for android\n", "abstract": " The rising popularity of mobile apps deployed on battery-constrained devices underlines the need for effectively evaluating their energy properties. However, currently there is a lack of testing tools for evaluating the energy properties of apps. As a result, for energy testing, developers are relying on tests intended for evaluating the functional correctness of apps. Such tests may not be adequate for revealing energy defects and inefficiencies in apps. This paper presents an energy-aware mutation testing framework, called \u03bcDROID, that can be used by developers to assess the adequacy of their test suite for revealing energy-related defects. \u03bcDROID implements fifty energy-aware mutation operators and relies on a novel, automatic oracle to determine if a mutant can be killed by a test. Our evaluation on real-world Android apps shows the ability of proposed mutation operators for evaluating the utility of tests in\u00a0\u2026", "num_citations": "55\n", "authors": ["335"]}
{"title": "Analysis of android inter-app security vulnerabilities using covert\n", "abstract": " The state-of-the-art in securing mobile software systems are substantially intended to detect and mitigate vulnerabilities in a single app, but fail to identify vulnerabilities that arise due to the interaction of multiple apps, such as collusion attacks and privilege escalation chaining, shown to be quite common in the apps on the market. This paper demonstrates COVERT, a novel approach and accompanying tool-suite that relies on a hybrid static analysis and lightweight formal analysis technique to enable compositional security assessment of complex software. Through static analysis of Android application packages, it extracts relevant security specifications in an analyzable formal specification language, and checks them as a whole for inter-app vulnerabilities. To our knowledge, COVERT is the first formally-precise analysis tool for automated compositional analysis of Android apps. Our study of hundreds of Android\u00a0\u2026", "num_citations": "49\n", "authors": ["335"]}
{"title": "Practical, formal synthesis and automatic enforcement of security policies for android\n", "abstract": " As the dominant mobile computing platform, Android has become a prime target for cyber-security attacks. Many of these attacks are manifested at the application level, and through the exploitation of vulnerabilities in apps downloaded from the popular app stores. Increasingly, sophisticated attacks exploit the vulnerabilities in multiple installed apps, making it extremely difficult to foresee such attacks, as neither the app developers nor the store operators know a priori which apps will be installed together. This paper presents an approach that allows the end-users to safeguard a given bundle of apps installed on their device from such attacks. The approach, realized in a tool, called SEPAR, combines static analysis with lightweight formal methods to automatically infer security-relevant properties from a bundle of apps. It then uses a constraint solver to synthesize possible security exploits, from which fine-grained\u00a0\u2026", "num_citations": "47\n", "authors": ["335"]}
{"title": "Detection of design flaws in the android permission protocol through bounded verification\n", "abstract": " The ever increasing expansion of mobile applications into nearly every aspect of modern life, from banking to healthcare systems, is making their security more important than ever. Modern smartphone operating systems (OS) rely substantially on the permission-based security model to enforce restrictions on the operations that each application can perform. In this paper, we perform an analysis of the permission protocol implemented in Android, a popular OS for smartphones. We propose a formal model of the Android permission protocol in Alloy, and describe a fully automatic analysis that identifies potential flaws in the protocol. A study of real-world Android applications corroborates our finding that the flaws in the Android permission protocol can have severe security implications, in some cases allowing the attacker to bypass the permission checks entirely.", "num_citations": "46\n", "authors": ["335"]}
{"title": "Patdroid: permission-aware gui testing of android\n", "abstract": " Recent introduction of a dynamic permission system in Android, allowing the users to grant and revoke permissions after the installation of an app, has made it harder to properly test apps. Since an app's behavior may change depending on the granted permissions, it needs to be tested under a wide range of permission combinations. At the state-of-the-art, in the absence of any automated tool support, a developer needs to either manually determine the interaction of tests and app permissions, or exhaustively re-execute tests for all possible permission combinations, thereby increasing the time and resources required to test apps. This paper presents an automated approach, called PATDroid, for efficiently testing an Android app while taking the impact of permissions on its behavior into account. PATDroid performs a hybrid program analysis on both an app under test and its test suite to determine which tests should\u00a0\u2026", "num_citations": "41\n", "authors": ["335"]}
{"title": "Dealing with uncertainty in early software architecture\n", "abstract": " Changing early architectural decisions of a system is both difficult and costly. It is very important for the architect to get them\" right\". However, in early design, the architect is often forced to make these decisions under uncertainty, ie, not knowing the precise impact of those decisions on system's properties (eg, scalability) as well as stakeholder concerns (eg, cost). In this paper, we provide an overview of GuideArch, a framework aimed at systematic exploration of the architectural solution space under uncertainty to help with making early architectural decisions.", "num_citations": "38\n", "authors": ["335"]}
{"title": "A user-centric approach for improving a distributed software system's deployment architecture\n", "abstract": " The quality of service (QoS) provided by a distributed software system depends on many system parameters, such as network bandwidth, reliability of links, frequencies of software component interactions, etc. A distributed system's allocation of software components to hardware nodes (ie, deployment architecture) can have a significant impact on its QoS. At the same time, often times there are many deployment architectures that provide the same functionality in large-scale software systems. Furthermore, the impact of deployment architecture on the QoS dimensions (eg, availability, latency) of the services (functionalities) provisioned by the system could vary. In fact, some QoS dimensions may be conflicting, such that a deployment architecture that improves one QoS dimension, degrades another dimension.", "num_citations": "35\n", "authors": ["335"]}
{"title": "RESISTing reliability degradation through proactive reconfiguration\n", "abstract": " Situated software systems are an emerging class of systems that are predominantly pervasive, embedded, and mobile. They are marked with a high degree of unpredictability and dynamism in the execution context. At the same time, such systems often need to satisfy strict reliability requirements. Most current software reliability analysis approaches are not suitable for situated software systems. We propose an approach geared to such systems, which continuously furnishes refined reliability predictions at runtime by incorporating various sources of information. The reliability predictions are leveraged to proactively place the software in the optimal configuration with respect to changing conditions. Our approach considers two representative architectural reconfiguration decisions that impact the system's reliability: reallocation of components to processes and changing the architectural style. We have realized the\u00a0\u2026", "num_citations": "34\n", "authors": ["335"]}
{"title": "A formal approach for detection of security flaws in the android permission system\n", "abstract": " The ever increasing expansion of mobile applications into nearly every aspect of modern life, from banking to healthcare systems, is making their security more important than ever. Modern smartphone operating systems (OS) rely substantially on the permission-based security model to enforce restrictions on the operations that each application can perform. In this paper, we perform an analysis of the permission protocol implemented in Android, a popular OS for smartphones. We propose a formal model of the Android permission protocol in Alloy, and describe a fully automatic analysis that identifies potential flaws in the protocol. A study of real-world Android applications corroborates our finding that the flaws in the Android permission protocol can have severe security implications, in some cases allowing the attacker to bypass the permission checks entirely.", "num_citations": "33\n", "authors": ["335"]}
{"title": "A taxonomy and survey of self-protecting software systems\n", "abstract": " Self-protecting software systems are a class of autonomic systems capable of detecting and mitigating security threats at runtime. They are growing in importance, as the stovepipe static methods of securing software systems have shown inadequate for the challenges posed by modern software systems. While existing research has made significant progress towards autonomic and adaptive security, gaps and challenges remain. In this paper, we report on an extensive study and analysis of the literature in this area. The crux of our contribution is a comprehensive taxonomy to classify and characterize research efforts in this arena. We also describe our experiences with applying the taxonomy to numerous existing approaches. This has shed light on several challenging issues and resulted in interesting observations that could guide the future research.", "num_citations": "33\n", "authors": ["335"]}
{"title": "Proactive self-adaptation for improving the reliability of mission-critical, embedded, and mobile software\n", "abstract": " Embedded and mobile software systems are marked with a high degree of unpredictability and dynamism in the execution context. At the same time, such systems are often mission-critical, meaning that they need to satisfy strict reliability requirements. Most current software reliability analysis approaches are not suitable for these types of software systems, as they do not take the changes in the execution context of the system into account. We propose an approach geared to such systems which continuously furnishes refined reliability predictions at runtime by incorporating various sources of information, including the execution context of the system. The reliability predictions are leveraged to proactively place the software in the (near-)optimal configuration with respect to changing conditions. Our approach considers two representative architectural reconfiguration decisions that impact the system's reliability\u00a0\u2026", "num_citations": "27\n", "authors": ["335"]}
{"title": "Accessibility issues in android apps: state of affairs, sentiments, and ways forward\n", "abstract": " Mobile apps are an integral component of our daily life. Ability to use mobile apps is important for everyone, but arguably even more so for approximately 15% of the world population with disabilities. This paper presents the results of a large-scale empirical study aimed at understanding accessibility of Android apps from three complementary perspectives. First, we analyze the prevalence of accessibility issues in over 1, 000 Android apps. We find that almost all apps are riddled with accessibility issues, hindering their use by disabled people. We then investigate the developer sentiments through a survey aimed at understanding the root causes of so many accessibility issues. We find that in large part developers are unaware of accessibility design principles and analysis tools, and the organizations in which they are employed do not place a premium on accessibility. We finally investigate user ratings and\u00a0\u2026", "num_citations": "25\n", "authors": ["335"]}
{"title": "A temporal permission analysis and enforcement framework for android\n", "abstract": " Permission-induced attacks, ie, security breaches enabled by permission misuse, are among the most critical and frequent issues threatening the security of Android devices. By ignoring the temporal aspects of an attack during the analysis and enforcement, the state-of-the-art approaches aimed at protecting the users against such attacks are prone to have low-coverage in detection and high-disruption in prevention of permission-induced attacks. To address this shortcomings, we present Terminator, a temporal permission analysis and enforcement framework for Android. Leveraging temporal logic model checking, Terminator's analyzer identifies permission-induced threats with respect to dynamic permission states of the apps. At runtime, Terminator's enforcer selectively leases (ie, temporarily grants) permissions to apps when the system is in a safe state, and revokes the permissions when the system moves to\u00a0\u2026", "num_citations": "25\n", "authors": ["335"]}
{"title": "Titanium: efficient analysis of evolving alloy specifications\n", "abstract": " The Alloy specification language, and the corresponding Alloy Analyzer, have received much attention in the last two decades with applications in many areas of software engineering. Increasingly, formal analyses enabled by Alloy are desired for use in an on-line mode, where the specifications are automatically kept in sync with the running, possibly changing, software system. However, given Alloy Analyzer's reliance on computationally expensive SAT solvers, an important challenge is the time it takes for such analyses to execute at runtime. The fact that in an on-line mode, the analyses are often repeated on slightly revised versions of a given specification, presents us with an opportunity to tackle this challenge. We present Titanium, an extension of Alloy for formal analysis of evolving specifications. By leveraging the results from previous analyses, Titanium narrows the state space of the revised specification\u00a0\u2026", "num_citations": "23\n", "authors": ["335"]}
{"title": "Automated dynamic enforcement of synthesized security policies in android\n", "abstract": " As the dominant mobile computing platform, Android has become a prime target for cyber-security attacks. Many of these attacks are manifested at the application level, and through the exploitation of vulnerabilities in apps downloaded from the popular app stores. Increasingly, sophisticated attacks exploit the vulnerabilities in multiple installed apps, making it extremely difficult to foresee such attacks, as neither the app developers nor the store operators know a priori which apps will be installed together. This paper presents an approach that allows the end-users to safeguard a given bundle of apps installed on their device from such attacks. The approach, realized in a tool, called DROIDGUARD, combines static code analysis with lightweight formal methods to automatically infer security-relevant properties from a bundle of apps. It then uses a constraint solver to synthesize possible security exploits, from which fine-grained security policies are derived and automatically enforced to protect a given device. In our experiments with over 4,000 Android apps, DROIDGUARD has proven to be highly effective at detecting previously unknown vulnerabilities as well as preventing their exploitation.", "num_citations": "23\n", "authors": ["335"]}
{"title": "Mining the execution history of a software system to infer the best time for its adaptation\n", "abstract": " An important challenge in dynamic adaptation of a software system is to prevent inconsistencies (failures) and disruptions in its operations during and after change. Several prior techniques have solved this problem with various tradeoffs. All of them, however, assume the availability of detailed component dependency models. This paper presents a complementary technique that solves this problem in settings where such models are either not available, difficult to build, or outdated due to the evolution of the software. Our approach first mines the execution history of a software system to infer a stochastic component dependency model, representing the probabilistic sequence of interactions among the system's components. We then demonstrate how this model could be used at runtime to infer the\" best time\" for adaptation of the system's components. We have thoroughly evaluated this research on a multi-user real\u00a0\u2026", "num_citations": "21\n", "authors": ["335"]}
{"title": "Determination and enforcement of least-privilege architecture in android\n", "abstract": " Modern mobile platforms rely on a permission model to guard the system's resources and apps. In Android, since the permissions are granted at the granularity of apps, and all components belonging to an app inherit those permissions, an app's components are typically over-privileged, i.e., components are granted more privileges than they need to complete their tasks. Systematic violation of least-privilege principle in Android has shown to be the root cause of many security vulnerabilities. To mitigate this issue, we have developed DELDROID, an automated system for determination of least privilege architecture in Android and its enforcement at runtime. A key contribution of our approach is the ability to limit the privileges granted to apps without the need to modify them. DELDROID utilizes static program analysis techniques to extract the exact privileges each component needs for providing its functionality. A\u00a0\u2026", "num_citations": "19\n", "authors": ["335"]}
{"title": "Inferring software component interaction dependencies for adaptation support\n", "abstract": " A self-managing software system should be able to monitor and analyze its runtime behavior and make adaptation decisions accordingly to meet certain desirable objectives. Traditional software adaptation techniques and recent \u201cmodels@runtime\u201d approaches usually require an a priori model for a system\u2019s dynamic behavior. Oftentimes the model is difficult to define and labor-intensive to maintain, and tends to get out of date due to adaptation and architecture decay. We propose an alternative approach that does not require defining the system\u2019s behavior model beforehand, but instead involves mining software component interactions from system execution traces to build a probabilistic usage model, which is in turn used to analyze, plan, and execute adaptations. In this article, we demonstrate how such an approach can be realized and effectively used to address a variety of adaptation concerns. In particular, we\u00a0\u2026", "num_citations": "18\n", "authors": ["335"]}
{"title": "Improving the reliability of mobile software systems through continuous analysis and proactive reconfiguration\n", "abstract": " Most of the current software reliability analysis approaches are geared to traditional desktop software systems, which are relatively stable and static throughout their execution. In this paper, we present a framework targeted at mobile computing domain that addresses the uncertainties associated with the reliability analysis in this setting. Moreover, the framework's architecture-centric reliability estimates are leveraged to improve the runtime reliability of the system through dynamic architectural reconfiguration.", "num_citations": "18\n", "authors": ["335"]}
{"title": "Mining software component interactions to detect security threats at the architectural level\n", "abstract": " Conventional security mechanisms at network, host, and source code levels are no longer sufficient in detecting and responding to increasingly dynamic and sophisticated cyber threats today. Detecting anomalous behavior at the architectural level can help better explain the intent of the threat and strengthen overall system security posture. To that end, we present a framework that mines software component interactions from system execution history and applies a detection algorithm to identify anomalous behavior. The framework uses unsupervised learning at runtime, can perform fast anomaly detection \"on the fly\", and can quickly adapt to system load fluctuations and user behavior shifts. Our evaluation of the approach against a real Emergency Deployment System has demonstrated very promising results, showing the framework can effectively detect covert attacks, including insider threats, that may be easily\u00a0\u2026", "num_citations": "17\n", "authors": ["335"]}
{"title": "Automated mining of software component interactions for self-adaptation\n", "abstract": " A self-adaptive software system should be able to monitor and analyze its runtime behavior and make adaptation decisions accordingly to meet certain desirable objectives. Traditional software adaptation techniques and recent\"[email protected]\" approaches usually require an a priori model for a system's dynamic behavior. Oftentimes the model is difficult to define and labor-intensive to maintain, and tends to get out of date due to adaptation and architecture decay. We propose an alternative approach that does not require defining the system's behavior model beforehand, but instead involves mining software component interactions from system execution traces to build a probabilistic usage model, which is in turn used to analyze, plan, and execute adaptations. Our preliminary evaluation of the approach against an Emergency Deployment System shows that the associations mining model can be used to\u00a0\u2026", "num_citations": "17\n", "authors": ["335"]}
{"title": "On the role of features in analyzing the architecture of self-adaptive software systems\n", "abstract": " In traditional software families, feature-orientation has been shown effective for bridging the semantic gap between a software system\u2019s requirements and its architecture. Over the past few years, the emergence of self-adaptive software systems, which are significantly more challenging to build than traditional systems, has gained the attention of the software engineering research community. In this paper, we show that using features at runtime could alleviate some of the key challenges of building such systems. The underlying insights are that:(1) features allow representation of the engineer\u2019s knowledge about some facets of the system that can be used to enhance the adaptation logic, and (2) features can serve as an abstraction to deal with the heterogeneity of the underlying architectural models, analytical algorithms, and implementation platforms. We describe the role of features in a self-adaptive framework that we have developed, entitled FeatUre-oriented Self-adaptatION (FUSION). We also report on our preliminary experience with FUSION that demonstrates the benefits of using features in different stages of self-adaptation.", "num_citations": "16\n", "authors": ["335"]}
{"title": "On the role of architectural styles in improving the adaptation support of middleware platforms\n", "abstract": " Modern middleware platforms provide the applications deployed on top of them with facilities for their adaptation. However, the level of adaptation support provided by the state-of-the-art middleware solutions is often limited to dynamically loading and off-loading of software components. Therefore, it is left to the application developers to handle the details of change such that the system\u2019s consistency is not jeopardized. In this paper, we present an approach that addresses the current shortcomings by utilizing the information encoded in a software system\u2019s architectural style. This information drives the development of adaptation patterns, which could be employed to enhance the adaptation support in middleware platforms. The patterns specify both the exact sequence of changes and the time at which those changes need to occur.", "num_citations": "15\n", "authors": ["335"]}
{"title": "DelDroid: an automated approach for determination and enforcement of least-privilege architecture in android\n", "abstract": " Android is widely used for the development and deployment of autonomous and smart systems, including software targeted for IoT and mobile devices. Security of such systems is an increasingly important concern. Android relies on a permission model to secure the system\u2019s resources and apps. In Android, since the permissions are granted at the granularity of apps, and all components in an app inherit those permissions, an app\u2019s components are over-privileged, i.e., components are granted more privileges than they actually need. Systematic violation of least-privilege principle in Android is the root cause of many security vulnerabilities. To mitigate this issue, we have developed DelDroid, an automated system for determination of least privilege architecture in Android and its enforcement at runtime. A key contribution of DelDroid is the ability to limit the privileges granted to apps without modifying them. DelDroid\u00a0\u2026", "num_citations": "13\n", "authors": ["335"]}
{"title": "Mining the categorized software repositories to improve the analysis of security vulnerabilities\n", "abstract": " Security has become the Achilles\u2019 heel of most modern software systems. Techniques ranging from the manual inspection to automated static and dynamic analyses are commonly employed to identify security vulnerabilities prior to the release of the software. However, these techniques are time consuming and cannot keep up with the complexity of ever-growing software repositories (e.g., Google Play and Apple App Store). In this paper, we aim to improve the status quo and increase the efficiency of static analysis by mining relevant information from vulnerabilities found in the categorized software repositories. The approach relies on the fact that many modern software systems are developed using rich application development frameworks (ADF), allowing us to raise the level of abstraction for detecting vulnerabilities and thereby making it possible to classify the types of vulnerabilities that are encountered\u00a0\u2026", "num_citations": "13\n", "authors": ["335"]}
{"title": "Social computing networks: a new paradigm for engineering self-adaptive pervasive software systems\n", "abstract": " Software systems are increasingly permeating a variety of domains including medical, industrial automation, and emergency response. The advances in portable and embedded computing devices and the recent advances in wireless network connectivity have paved the way for the proliferation of smart spaces in such domains. At the same time, the emergence of service-oriented technology (eg, web services [10]) and interoperability standards (eg, WSDL [11], UDDI [5]) has made it possible to develop pervasive software systems intended for execution in smart spaces that were not even conceivable a few years back.", "num_citations": "13\n", "authors": ["335"]}
{"title": "Test transfer across mobile apps through semantic mapping\n", "abstract": " GUI-based testing has been primarily used to examine the functionality and usability of mobile apps. Despite the numerous GUI-based test input generation techniques proposed in the literature, these techniques are still limited by (1) lack of context-aware text inputs; (2) failing to generate expressive tests; and (3) absence of test oracles. To address these limitations, we propose CraftDroid, a framework that leverages information retrieval, along with static and dynamic analysis techniques, to extract the human knowledge from an existing test suite for one app and transfer the test cases and oracles to be used for testing other apps with the similar functionalities. Evaluation of CraftDroid on real-world commercial Android apps corroborates its effectiveness by achieving 73% precision and 90% recall on average for transferring both the GUI events and oracles. In addition, 75% of the attempted transfers successfully\u00a0\u2026", "num_citations": "12\n", "authors": ["335"]}
{"title": "A user-centric framework for improving a distributed software system\u2019s deployment architecture\n", "abstract": " A distributed system's deployment architecture can have a significant impact on its QoS. Furthermore, the deployment architecture will influence users\u2019 satisfaction, as users typically have varying QoS preferences for the system services they access. Finding a deployment architecture that will maximize the users' overall satisfaction is a challenging, multi-faceted problem. We propose to develop a framework that can be tailored and instantiated to address this problem in its many variations. The framework is accompanied with tool support, which allows it to be used in practice and evaluated in many representative scenarios.", "num_citations": "12\n", "authors": ["335"]}
{"title": "Enhancing middleware support for architecture-based development through compositional weaving of styles\n", "abstract": " Architecture-based software development has been shown as an effective approach for managing the implementation complexity of large-scale software systems. Architecture-based development is often achieved with the help of a middleware, which provides implementation-level counterparts for the architectural modeling constructs. Such a middleware automatically ensures that implemented system accurately embodies the properties encoded in its architectural models. However, existing middlewares do not provide sufficient support for architectural styles. This is due to the crosscutting structure of styles that impacts the behavior of every other architectural construct, and hence the corresponding middleware facilities. We present an aspect-oriented approach that alleviates this problem by weaving the stylistic concerns with the rest of the middleware. The approach decouples stylistic concerns from other\u00a0\u2026", "num_citations": "11\n", "authors": ["335"]}
{"title": "Utilizing architectural styles to enhance the adaptation support of middleware platforms\n", "abstract": " ContextModern middleware platforms provide the applications deployed on top of them with facilities for their adaptation. However, the level of adaptation support provided by the state-of-the-art middleware solutions is often limited to dynamically loading and off-loading of software components. Therefore, it is left to the application developers to handle the details of change such that the system\u2019s consistency is not jeopardized.ObjectiveWe aim to change the status quo by providing the middleware facilities necessary to ensure the consistency of software after adaptation. We would like these facilities to be reusable across different applications, such that the middleware can streamline the process of achieving safe adaptation.MethodOur approach addresses the current shortcomings by utilizing the information encoded in a software system\u2019s architectural style. This information drives the development of reusable\u00a0\u2026", "num_citations": "9\n", "authors": ["335"]}
{"title": "Efficient, evolutionary security analysis of interacting android apps\n", "abstract": " In parallel with the increasing popularity of mobile software, an alarming escalation in the number and sophistication of security threats is observed on mobile platforms, remarkably Android as the dominant platform. Such mobile software, further, evolves incrementally, and especially so when being maintained after it has been deployed. Yet, most security analysis techniques lack the ability to efficiently respond to incremental system changes. Instead, every time the system changes, the entire security analysis has to be repeated from scratch, making it too expensive for practical use, given the frequency with which apps are updated, installed, and removed in such volatile environments as the Android ecosystem. To address this limitation, we present a novel technique, dubbed FLAIR, for efficient, yet formally precise, security analysis of Android apps in response to incremental system changes. Leveraging the fact\u00a0\u2026", "num_citations": "8\n", "authors": ["335"]}
{"title": "Guided exploration of the architectural solution space in the face of uncertainty\n", "abstract": " A system\u2019s early architectural decisions impact its properties (eg, scalability, dependability) as well as stakeholder concerns (eg, cost, time to delivery). Choices made early on are both difficult and costly to change, and thus it is paramount that the engineer gets them \u201cright\u201d. This leads to a paradox, as in early design, the engineer is often forced to make these decisions under uncertainty, ie, not knowing the precise impact of those decisions on the various concerns. How could the engineer make the \u201cright\u201d choices in such circumstances? This is precisely the question we have tackled in this paper. We present GuideArch, a framework aimed at guiding the exploration of the architectural solution space under uncertainty. It provides techniques and tools that help the engineer to make informed decisions. The approach has been thoroughly evaluated in a project aimed at reengineering a mobile software system.", "num_citations": "8\n", "authors": ["335"]}
{"title": "Advancing energy testing of mobile applications\n", "abstract": " The rising popularity of mobile apps deployed on battery-constrained devices has motivated the need for effective energy-aware testing techniques. However, currently there is a lack of test generation tools for exercising the energy properties of apps. Automated test generation is not useful without tools that help developers to measure the quality of the tests. Additionally, the collection of tests generated for energy testing could be quite large, as it may involve a test suite that covers all the energy hotspots under different use cases. Thereby, there is a need for techniques to manage the size of test suite, while maintaining its effectiveness in revealing energy defects. Our research plan to advance energy testing for mobile applications include various techniques for energy-aware test generation, energy-aware test-suite adequacy assessment, and energy-aware test-suite minimization.", "num_citations": "7\n", "authors": ["335"]}
{"title": "Effective realization of software architectural styles with aspects\n", "abstract": " Architecture-based software development is the implementation of a software system in terms of its architectural constructs (e.g., components, connectors, ports). It has been shown as an effective approach to realizing and managing the architecture of large scale software systems. Several techniques and tools have been developed that are intended to aid with the architecture-based development of software systems. While these approaches provide adequate implementation support for some aspects of software architectures, they often lack sufficient support for implementing and enforcing the system's software architectural style. In this paper, we argue that the lack of sufficient support for architectural styles is a by-product of its crosscutting structure. In turn, making it impossible to realize styles using the object-oriented programming methodology. We propose a new approach to implementing architectural styles\u00a0\u2026", "num_citations": "6\n", "authors": ["335"]}
{"title": "Mining mobile app markets for prioritization of security assessment effort\n", "abstract": " Like any other software engineering activity, assessing the security of a software system entails prioritizing the resources and minimizing the risks. Techniques ranging from the manual inspection to automated static and dynamic analyses are commonly employed to identify security vulnerabilities prior to the release of the software. However, none of these techniques is perfect, as static analysis is prone to producing lots of false positives and negatives, while dynamic analysis and manual inspection are unwieldy, both in terms of required time and cost. This research aims to improve these techniques by mining relevant information from vulnerabilities found in the app markets. The approach relies on the fact that many modern software systems, in particular mobile software, are developed using rich application development frameworks (ADF), allowing us to raise the level of abstraction for detecting vulnerabilities and\u00a0\u2026", "num_citations": "5\n", "authors": ["335"]}
{"title": "Automated detection and mitigation of inter-application security vulnerabilities in android (invited talk)\n", "abstract": " Android is the most popular platform for mobile devices. It facilitates sharing data and services between applications by providing a rich inter-application communication system. While such sharing can be controlled by the Android permission system, enforcing permissions is not sufficient to prevent security violations, since permissions may be mismanaged, intentionally or unintentionally, which can compromise user privacy. In this paper, we provide an overview of a novel approach for compositional analysis of Android inter-application vulnerabilities, entitled COVERT. Our analysis is modular to enable incremental analysis of applications as they are installed on an Android device. It extracts security specifications from application packages, captures them in an analyzable formal specification language, and checks whether it is safe for a combination of applications-holding certain permissions and potentially\u00a0\u2026", "num_citations": "5\n", "authors": ["335"]}
{"title": "Dealing with the crosscutting structure of software architectural styles\n", "abstract": " Architecture-based software development is the implementation of a software system in terms of its architectural constructs (e.g., components, connectors, ports). It has been shown as an effective approach to realizing and managing the architecture of large-scale software systems. Several techniques and tools have been developed that are intended to aid with the architecture-based development of software systems. While these approaches provide adequate implementation support for some aspects of software architectures, they often lack sufficient support for implementing and enforcing the systempsilas software architectural style. In this paper, we argue that the lack of sufficient support for architectural styles is a by-product of its crosscutting structure. In turn, this makes it impossible to realize styles using the object-oriented programming methodology. We present a new approach to implementing architectural\u00a0\u2026", "num_citations": "5\n", "authors": ["335"]}
{"title": "Test automation in open-source android apps: A large-scale empirical study\n", "abstract": " Automated testing of mobile apps has received significant attention in recent years from researchers and practitioners alike. In this paper, we report on the largest empirical study to date, aimed at understanding the test automation culture prevalent among mobile app developers. We systematically examined more than 3.5 million repositories on GitHub and identified more than 12,000 non-trivial and real-world Android apps. We then analyzed these non-trivial apps to investigate (1) the prevalence of adoption of test automation; (2) working habits of mobile app developers in regards to automated testing; and (3) the correlation between the adoption of test automation and the popularity of projects. Among others, we found that (1) only 8% of the mobile app development projects leverage automated testing practices; (2) developers tend to follow the same test automation practices across projects; and (3) popular\u00a0\u2026", "num_citations": "4\n", "authors": ["335"]}
{"title": "Latte: Use-Case and Assistive-Service Driven Automated Accessibility Testing Framework for Android\n", "abstract": " For 15% of the world population with disabilities, accessibility is arguably the most critical software quality attribute. The ever-growing reliance of users with disability on mobile apps further underscores the need for accessible software in this domain. Existing automated accessibility assessment techniques primarily aim to detect violations of predefined guidelines, thereby produce a massive amount of accessibility warnings that often overlook the way software is actually used by users with disability. This paper presents a novel, high-fidelity form of accessibility testing for Android apps, called Latte, that automatically reuses tests written to evaluate an app\u2019s functional correctness to assess its accessibility as well. Latte first extracts the use case corresponding to each test, and then executes each use case in the way disabled users would, ie, using assistive services. Our empirical evaluation on real-world Android apps\u00a0\u2026", "num_citations": "3\n", "authors": ["335"]}
{"title": "Ensuring the consistency of adaptation through inter-and intra-component dependency analysis\n", "abstract": " Dynamic adaptation should not leave a software system in an inconsistent state, as it could lead to failure. Prior research has used inter-component dependency models of a system to determine a safe interval for the adaptation of its components, where the most important tradeoff is between disruption in the operations of the system and reachability of safe intervals. This article presents Savasana, which automatically analyzes a software system\u2019s code to extract both inter- and intra-component dependencies. In this way, Savasana is able to obtain more fine-grained models compared to previous approaches. Savasana then uses the detailed models to find safe adaptation intervals that cannot be determined using techniques from prior research. This allows Savasana to achieve a better tradeoff between disruption and reachability. The article demonstrates how Savasana infers safe adaptation intervals for\u00a0\u2026", "num_citations": "2\n", "authors": ["335"]}
{"title": "DELDroid: Determination and enforcement of least-privilege architecture in android\n", "abstract": " The Android system implements the principle of least privilege. That is, each app, by default, has access only to the components that it requires to do its work and no more. This creates a very secure environment in which an app cannot access parts of the system for which it is not given permission.", "num_citations": "2\n", "authors": ["335"]}
{"title": "Towards multi-design of situated service-oriented systems\n", "abstract": " This paper discusses ongoing changes to the boundaries and roles of design and run time in the software lifecycle. Specifically, it focuses on changes caused by the emergence of situated systems in open pervasive computing environments. Clearly, such changes have a direct repercussion on the roles and tasks of system developers, stakeholders, and users.", "num_citations": "2\n", "authors": ["335"]}
{"title": "Automated construction of energy test oracles for Android\n", "abstract": " Energy efficiency is an increasingly important quality attribute for software, particularly for mobile apps. Just like any other software attribute, energy behavior of mobile apps should be properly tested prior to their release. However, mobile apps are riddled with energy defects, as currently there is a lack of proper energy testing tools. Indeed, energy testing is a fledgling area of research and recent advances have mainly focused on test input generation. This paper presents ACETON, the first approach aimed at solving the oracle problem for testing the energy behavior of mobile apps. ACETON employs Deep Learning to automatically construct an oracle that not only determines whether a test execution reveals an energy defect, but also the type of energy defect. By carefully selecting features that can be monitored on any app and mobile device, we are assured the oracle constructed using ACETON is highly reusable\u00a0\u2026", "num_citations": "1\n", "authors": ["335"]}
{"title": "ER catcher: a static analysis framework for accurate and scalable event-race detection in Android\n", "abstract": " Android platform provisions a number of sophisticated concurrency mechanisms for the development of apps. The concurrency mechanisms, while powerful, are quite difficult to properly master by mobile developers. In fact, prior studies have shown concurrency issues, such as event-race defects, to be prevalent among real-world Android apps. In this paper, we propose a flow-, context-, and thread-sensitive static analysis framework, called ER Catcher, for detection of event-race defects in Android apps. ER Catcher introduces a new type of summary function aimed at modeling the concurrent behavior of methods in both Android apps and libraries. In addition, it leverages a novel, statically constructed Vector Clock for rapid analysis of happens-before relations. Altogether, these design choices enable ER Catcher to not only detect event-race defects with a substantially higher degree of accuracy, but also in a\u00a0\u2026", "num_citations": "1\n", "authors": ["335"]}
{"title": "Refining reliability estimation of mobile software systems\n", "abstract": " In this short paper, we propose an approach for incorporating runtime analysis of components communications and interactions into architecture-level reliability models. The goal is to offer a more refined reliability analysis for mobile and distributed software systems.", "num_citations": "1\n", "authors": ["335"]}
{"title": "Improving Availability of Distributed Event-Based Systems via Run-Time Monitoring and Analysis\n", "abstract": " Improving Availability of Distributed Event-Based Systems via Run-Time Monitoring and Analysis Page 1 Improving Availability of Distributed Event-Based Systems via Run-Time Monitoring and Analysis Sam Malek and Marija Mikic-Rakic Nels Beckman Nenad Medvidovic University of Southern California WADS 2004 Page 2 May 25th ICSE-WADS 2004 2 Outline \u27a2 Motivation \u25a1 Problem description \u25a1 Prism-MW \u25a1 DeSi \u25a1 Algorithms \u25a1 Concluding remarks Page 3 May 25th ICSE-WADS 2004 3 Motivation Deployment architecture: distribution (ie, assignment) of software components onto hardware nodes. How good is this deployment architecture? What are its properties? How should it be modified to ensure higher availability? Page 4 May 25th ICSE-WADS 2004 4 Outline \u2751 Motivation \u27a2 Problem description \u25a1 Prism-MW \u25a1 DeSi \u25a1 Algorithms \u25a1 Concluding remarks Page 5 May 25th ICSE-WADS 2004 5 Problem ,\u2026", "num_citations": "1\n", "authors": ["335"]}