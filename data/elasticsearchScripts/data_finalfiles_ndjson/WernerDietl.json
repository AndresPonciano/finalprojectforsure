{"title": "EnerJ: Approximate data types for safe and general low-power computation\n", "abstract": " Energy is increasingly a first-order concern in computer systems. Exploiting energy-accuracy trade-offs is an attractive choice in applications that can tolerate inaccuracies. Recent work has explored exposing this trade-off in programming models. A key challenge, though, is how to isolate parts of the program that must be precise from those that can be approximated so that a program functions correctly even as quality of service degrades. We propose using type qualifiers to declare data that may be subject to approximate computation. Using these types, the system automatically maps approximate variables to low-power storage, uses low-power operations, and even applies more energy-efficient algorithms provided by the programmer. In addition, the system can statically guarantee isolation of the precise program component from the approximate component. This allows a programmer to control explicitly how\u00a0\u2026", "num_citations": "884\n", "authors": ["1756"]}
{"title": "Building and using pluggable type-checkers\n", "abstract": " This paper describes practical experience building and using pluggable type-checkers. A pluggable type-checker refines (strengthens) the built-in type system of a programming language. This permits programmers to detect and prevent, at compile time, defects that would otherwise have been manifested as run-time errors. The prevented defects may be generally applicable to all programs, such as null pointer dereferences. Or, an application-specific pluggable type system may be designed for a single application.", "num_citations": "115\n", "authors": ["1756"]}
{"title": "Static analysis of implicit control flow: Resolving java reflection and android intents (t)\n", "abstract": " Implicit or indirect control flow is a transfer of control between procedures using some mechanism other than an explicit procedure call. Implicit control flow is a staple design pattern that adds flexibility to system design. However, it is challenging for a static analysis to compute or verify properties about a system that uses implicit control flow. This paper presents static analyses for two types of implicit control flow that frequently appear in Android apps: Java reflection and Android intents. Our analyses help to resolve where control flows and what data is passed. This information improves the precision of downstream analyses, which no longer need to make conservative assumptions about implicit control flow. We have implemented our techniques for Java. We enhanced an existing security analysis with a more precise treatment of reflection and intents. In a case study involving ten real-world Android apps that use\u00a0\u2026", "num_citations": "95\n", "authors": ["1756"]}
{"title": "ReIm & ReImInfer: Checking and inference of reference immutability and method purity\n", "abstract": " Reference immutability ensures that a reference is not used to modify the referenced object, and enables the safe sharing of object structures. A pure method does not cause side-effects on the objects that existed in the pre-state of the method execution. Checking and inference of reference immutability and method purity enables a variety of program analyses and optimizations. We present ReIm, a type system for reference immutability, and ReImInfer, a corresponding type inference analysis. The type system is concise and context-sensitive. The type inference analysis is precise and scalable, and requires no manual annotations. In addition, we present a novel application of the reference immutability type system: method purity inference. To support our theoretical results, we implemented the type system and the type inference analysis for Java. We include a type checker to verify the correctness of the inference\u00a0\u2026", "num_citations": "73\n", "authors": ["1756"]}
{"title": "Verification games: Making verification fun\n", "abstract": " Program verification is the only way to be certain that a given piece of software is free of (certain types of) errors---errors that could otherwise disrupt operations in the field. To date, formal verification has been done by specially-trained engineers. Labor costs have heretofore made formal verification too costly to apply beyond small, critical software components.", "num_citations": "62\n", "authors": ["1756"]}
{"title": "Inference and checking of object ownership\n", "abstract": " Ownership type systems describe a heap topology and enforce an encapsulation discipline; they aid in various program correctness and understanding tasks. However, the annotation overhead of ownership type systems has hindered their widespread use. We present a unified framework for specification, type inference and type checking of ownership type systems, and instantiate the framework for two such systems: Universe Types and Ownership Types. We present an objective metric defining a \u201cbest typing\u201d for these type systems, and develop an inference approach that maximizes the metric. The programmer can influence the inference by adding partial annotations to the program. We implemented the approach on top of the Checker Framework and present the results of an experimental evaluation.", "num_citations": "57\n", "authors": ["1756"]}
{"title": "Protection of wavelet-based watermarking systems using filter parametrization\n", "abstract": " We discuss wavelet filter parametrization as a means to add security to wavelet-based watermarking schemes. It turns out that our proposed scheme is resistant to unauthorized detection and unauthorized removal attacks and is equally robust as compared to the use of standard wavelet filters in case the underlying watermarking scheme is spread-spectrum based. Quantization-based watermarking techniques are not suited to be enhanced by this approach. We assess the security, quality and robustness of our approach in the light of four selected watermarking algorithms. Furthermore, we present an attack tailored to exploit a common weakness in image-adaptive watermarking and propose filter parametrization as a suitable countermeasure.", "num_citations": "57\n", "authors": ["1756"]}
{"title": "Watermark security via wavelet filter parametrization\n", "abstract": " We propose to use secret, key-dependent, parametric, wavelet filters to improve the security of digital watermarking schemes operating in the wavelet transform domain. We show that the parametrization of wavelet filters can be easily integrated into existing wavelet-based watermarking algorithms, resulting in improved security without additional computational complexity. Both robustness and imperceptibility are adequate for many applications.", "num_citations": "53\n", "authors": ["1756"]}
{"title": "A type system for regular expressions\n", "abstract": " Regular expressions are used to match and extract text. It is easy for developers to make syntactic mistakes when writing regular expressions, because regular expressions are often complex and different across programming languages. Such errors result in exceptions at run time, and there is currently no static support for preventing them.", "num_citations": "51\n", "authors": ["1756"]}
{"title": "Tunable static inference for generic universe types\n", "abstract": " Object ownership is useful for many applications, including program verification, thread synchronization, and memory management. However, the annotation overhead of ownership type systems hampers their widespread application. This paper addresses this issue by presenting a tunable static type inference for Generic Universe Types. In contrast to classical type systems, ownership types have no single most general typing. Our inference chooses among the legal typings via heuristics. Our inference is tunable: users can indicate a preference for certain typings by adjusting the heuristics or by supplying partial annotations for the program. We present how the constraints of Generic Universe Types can be encoded as a boolean satisfiability (SAT) problem and how a weighted Max-SAT solver finds a correct Universe typing that optimizes the weights. We implemented the static inference tool, applied our\u00a0\u2026", "num_citations": "49\n", "authors": ["1756"]}
{"title": "Java                                UI               : Effects for Controlling UI Object Access\n", "abstract": " Most graphical user interface (GUI) libraries forbid accessing UI elements from threads other than the UI event loop thread. Violating this requirement leads to a program crash or an inconsistent UI. Unfortunately, such errors are all too common in GUI programs.               We present a polymorphic type and effect system that prevents non-UI threads from accessing UI objects or invoking UI-thread-only methods. The type system still permits non-UI threads to hold and pass references to UI objects. We implemented this type system for Java and annotated 8 Java programs (over 140KLOC) for the type system, including several of the most popular Eclipse plugins. We confirmed bugs found by unsound prior work, found an additional bug and code smells, and demonstrated that the annotation burden is low.               We also describe code patterns our effect system handles less gracefully or not at all, which we\u00a0\u2026", "num_citations": "33\n", "authors": ["1756"]}
{"title": "Universe Types Topology, Encapsulation, Genericity, and Tools\n", "abstract": " We present Generic Universe Types, a sound, lightweight ownership type system for type-generic object-oriented programming languages, which cleanly separates the ownership topology from the owner-as-modifier encapsulation discipline and is supported by a comprehensive set of tools.Mutable references give object-oriented programming languages the power to build complex object structures and to efficiently modify them. However, this power comes at the cost of aliasing: two or more references to the same object can exist, and the modifications performed through one reference are visible through all other references. In main-stream object-oriented languages, like Java and C\u266f, objects and references build a complicated mesh and there is no support to structure the heap. Visibility modifiers (such as private and protected in Java) only deal with information hiding, for example, ensuring that a field is only accessible from within its declaring class. However, the object referenced by that field might still be aliased and modified by other objects at runtime. There is no support to encapsulate object structures and to ensure that objects at runtime are only accessed in a controlled fashion. Aliasing and the unstructured nature of the heap lead to problems with, for example, understanding the behavior of a program, adapting a consistent locking discipline to ensure correct concurrent behavior, exchanging the implementation of an interface, and the formal verification of properties.", "num_citations": "28\n", "authors": ["1756"]}
{"title": "Exceptions in ownership type systems\n", "abstract": " Ownership type systems are used to structure the object store into contexts and to restrict references between contexts. How to handle exceptions in these type systems has not been described in the literature. In this paper we analyze four viable designs for supporting exceptions in ownership type systems:(1) cloning exception objects during propagation;(2) using unique references to transfer exceptions between contexts during propagation;(3) treating exceptions as global data;(4) handling exceptions by read-only references that may cross context boundaries. We briefly describe our implementation of the fourth approach in the Universe type system.", "num_citations": "26\n", "authors": ["1756"]}
{"title": "Object ownership in program verification\n", "abstract": " Dealing with aliasing is one of the key challenges for the verification of imperative programs. For instance, aliases make it difficult to determine which abstractions are potentially affected by a heap update and to determine which locks need to be acquired to avoid data races. Object ownership was one of the first approaches that allowed programmers to control aliasing and to restrict the operations that can be applied to a reference. It thus enabled sound, modular, and automatic verification of heap-manipulating programs. In this paper, we present two ownership systems that have been designed specifically to support program verification\u2014Universe Types and Spec#\u2019s Dynamic Ownership\u2014and explain their applications in program verification, illustrated through a series of Spec# examples.", "num_citations": "25\n", "authors": ["1756"]}
{"title": "Runtime universe type inference\n", "abstract": " The Universe type system is an ownership type system for objectoriented languages that enforces the owner-as-modifier discipline. One strength of the Universe type system is its low annotation overhead. Still, annotating existing software is a considerable effort. In this paper, we describe how we can analyze the execution of programs and infer ownership modifiers from the execution. These modifiers help to understand the organization of a system and can also be re-inserted into the original source code. This allows a programmer to enforce the maintenance of a specific ownership structure. We implemented runtime Universe type inference as a C program that traces the JVM execution, a Java application that infers the Universe annotations, and a set of Eclipse plug-ins that integrates the interaction with the other tools.", "num_citations": "22\n", "authors": ["1756"]}
{"title": "Robustness against unauthorized watermark removal attacks via key-dependent wavelet packet subband structures\n", "abstract": " We propose the use of random wavelet packet decompositions as a way to increase the security of watermarking systems against unauthorized removal attacks. Experimental attacks based on coefficient quantization show that using a secret key-dependent subband structure to hide the watermarking domain significantly increases the watermark correlation under an attack as compared to a classical pyramidal wavelet watermark.", "num_citations": "19\n", "authors": ["1756"]}
{"title": "A type system for checking applet isolation in Java Card\n", "abstract": " A Java Card applet is, in general, not allowed to access fields and methods of other applets on the same smart card. This applet isolation property is enforced by dynamic checks in the Java Card Virtual Machine. This paper describes a refined type system for Java Card that enables static checking of applet isolation. With this type system, firewall violations are detected at compile time. Only a special kind of downcast requires dynamic checks.", "num_citations": "12\n", "authors": ["1756"]}
{"title": "Watermark security via secret wavelet packet subband structures\n", "abstract": " Wavelet packet decompositions generalize the classical pyramidal wavelet structure. We use the vast amount of possible wavelet packet decomposition structures to create a secret wavelet domain and discuss how this idea can be used to improve the security of watermarking schemes. Two methods to create random wavelet packet trees are discussed and analyzed. The security against unauthorized detection is investigated. Using JPEG and JPEG2000 compression we assess the normalized correlation and Peak Signal to Noise Ratio (PSNR) behavior of the watermarks. We conclude that the proposed systems show improved robustness against compression and provide around 21046 possible keys. The security against unauthorized detection is greatly improved.", "num_citations": "12\n", "authors": ["1756"]}
{"title": "Granullar: gradual nullable types for Java\n", "abstract": " Object-oriented languages like Java and C# allow the null value for all references. This supports many flexible patterns, but has led to many errors, security vulnerabilities, and system crashes.% Static type systems can prevent null-pointer exceptions at compile time, but require annotations, in particular for used libraries. Conservative defaults choose the most restrictive typing, preventing many errors, but requiring a large annotation effort. Liberal defaults choose the most flexible typing, requiring less annotations, but giving weaker guarantees. Trusted annotations can be provided, but are not checked and require a large manual effort. None of these approaches provide a strong guarantee that the checked part of the program is isolated from the unchecked part: even with conservative defaults, null-pointer exceptions can occur in the checked part.", "num_citations": "11\n", "authors": ["1756"]}
{"title": "Key-dependent pyramidal wavelet domains for secure watermark embedding\n", "abstract": " Wavelet filters can be parametrized to create an entire family of different wavelet filters. We discuss wavelet filter parametrization as a means to add security to wavelet based watermarking schemes. We analyze the influence of the number of filter parameters and use non-stationary multi-resolution decomposition where different wavelet filters are used at different levels of the decomposition. Using JPEG and JPEG2000 compression we assess the normalized correlation and Peak Signal to Noise Ratio (PSNR) behavior of the watermarks. The security against unauthorized detection is also investigated. We conclude that the proposed systems show good robustness against compression and depending on the resolution we choose for the parameters we get between 299 and 2185 possible keys.", "num_citations": "11\n", "authors": ["1756"]}
{"title": "Key-dependency for a wavelet-based blind watermarking algorithm\n", "abstract": " When a host image is watermarked multiple times by the same algorithm collisions can occur. This makes it difficult for an image to host multiple watermarks. But this hosting is necessary for an image distribution chain, where several persons all watermark the same image. Wavelet domain transformations provide several possibilities to customize the transformation process. We discuss the applicability of the methods of wavelet filter parametrization and wavelet packet decomposition for secret watermark embedding on the algorithm of Dugad et al. We conclude that filter parametrization is not suited while wavelet packet decomposition shows good results.", "num_citations": "10\n", "authors": ["1756"]}
{"title": "Ownership type systems and dependent classes\n", "abstract": " Ownership type systems structure the heap and enforce restrictions on the behavior of a program. Benefits of ownership type systems include simplified program verification, absence of race conditions and deadlocks, and enforcement of architectural styles. Dependent classes are a generalization of virtual class systems that allows one class to depend on multiple objects. Dependency is expressed by explicit declaration of the depended-upon objects as class parameters. This allows one to declare dependencies independently of the nesting of classes, which increases the expressive power and reduces the coupling between classes. In this paper, we describe how ownership type systems can be expressed on top of dependent classes. The ownership type systems are split into two parts:(1) ensuring the topological structure of the heap and (2) enforcing restrictions on the behavior of the program. We present an encoding of the topological part in dependent classes and describe how to enforce the restrictions of ownership type systems directly on the dependent classes program. Finally, we present the encoding of some examples for the MVC interpreter and discuss future work.", "num_citations": "6\n", "authors": ["1756"]}
{"title": "Precise inference of expressive units of measurement types\n", "abstract": " Ensuring computations are unit-wise consistent is an important task in software development. Numeric computations are usually performed with primitive types instead of abstract data types, which results in very weak static guarantees about correct usage and conversion of units. This paper presents PUnits, a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. PUnits can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exists, and (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. Compared to prior work, PUnits strikes a novel balance between expressiveness, inference\u00a0\u2026", "num_citations": "5\n", "authors": ["1756"]}
{"title": "EnerJ: Approximate Data Types for Safe and General Low-Power Computation\u2014Full Proofs\n", "abstract": " This section introduces the core type system, which is made up of type qualifiers that extend Featherweight Java [1]. Section 2 describes the big-step operational semantics that define the language\u2019s runtime system. Section 3 proves a number of properties about the language, the most important of which is non-interference (intuitively, that the precise part of the program is unaffected by the approximate part). The appendices contain complete listings, generated by the Ott tool, of the language\u2019s grammar and definitions. 1", "num_citations": "5\n", "authors": ["1756"]}
{"title": "Don\u2019t miss the end: Preventing unsafe end-of-file comparisons\n", "abstract": " Reading from an InputStream or Reader in Java either returns the read byte/character or  if the end-of-file (EOF) has been reached. To support the additional  as return value, the read methods return an int. For correct usage, the return value should be compared to  before being converted to byte or char. If the conversion was performed before the comparison, it can cause a read-until-EOF-loop to either exit prematurely or be stuck in an infinite loop. The SEI CERT Oracle Coding Standard for Java rule FIO08-J \u201cDistinguish between characters or bytes read from a stream and \u201d describes this issue in detail. This paper presents a type system that prevents unsafe EOF value comparisons statically and is implemented for Java using the Checker Framework. In an evaluation of 35 projects (9\u00a0million LOC) it detected 3 defects in production software, 8 bad coding practices, and no false positives. The\u00a0\u2026", "num_citations": "4\n", "authors": ["1756"]}
{"title": "Comparing universes and existential ownership types\n", "abstract": " Ownership types and Universe types are two type systems used to structure the heap and enforce encapsulation disciplines. The parametricity of ownership types allows a finergrained description of heap topologies, whereas the flexibility of any references in Universe types allows sharing between data structures. No direct encoding of one type system in the other has been possible. Parametric ownership has recently been extended with existential quantification of contexts. We formalise such a language and give a formal translation between programs written in this language and using Universe types. We show that this translation is sound and complete.", "num_citations": "4\n", "authors": ["1756"]}
{"title": "Tunable Universe type inference\n", "abstract": " Object ownership is useful for many applications such as program verification, thread synchronization, and memory management. However, even lightweight ownership type systems impose considerable annotation overhead, which hampers their widespread application. This paper address this issue by presenting a tunable static type inference for Universe types. In contrast to classical type systems, ownership types have no single most general typing. Therefore, our inference is tunable: users can indicate a preference for certain typings by configuring heuristics through weights. A particularly effective way of tuning the static inference is to obtain these weights automatically through runtime ownership inference. We present how the constraints of the Universe type system can be encoded as a boolean satisfiability (SAT) problem, how the runtime ownership inference produces weights from program executions, and how a weightedMax-SAT solver finds a correct Universe typing that optimizes the weights. Our implementation provides the static and runtime inference engines, as well as a visualization tool.", "num_citations": "4\n", "authors": ["1756"]}
{"title": "Universe Type System-Quick-Reference\n", "abstract": " The Universe type system is a lightweight ownership type system that hierarchically structures the object store. It enforces the owner-as-modifier discipline that allows the modular verification of objectoriented programs. The Universe type system is part of the Java Modeling Language (JML) and supported by several tools.", "num_citations": "3\n", "authors": ["1756"]}
{"title": "A computational complexity analysis of tunable type inference for Generic Universe Types\n", "abstract": " We address questions related to the computational complexity of inferring types for a particular type system, Generic Universe Types (GUT)[1],[2], for Java programs. GUT is useful for many applications, such as program verification [3], thread synchronization, and memory management. However, requiring the programmer to explicitly provide type information is onerous, which motivates the problem of automatically inferring types. In contrast to classical type systems, ownership type systems such as GUT may have multiple typings that satisfy the type system's rules. It is therefore appropriate for the inference to be tunable\u2014that is, the programmer can indicate preferences for certain typings via breakable constraints and/or by partial annotations. A question then is whether efficient algorithms exist for the type inference problem. In this work we establish the following results for the type inference problem for GUT [2].(1\u00a0\u2026", "num_citations": "2\n", "authors": ["1756"]}
{"title": "Improving the security of wavelet-based watermarking systems\n", "abstract": " The protection of Intellectual Property Rights has become one of the main interests of content owners. Many different terms are in use: Intellectual Property Rights IPR, Digital Rights Management DRM, Copyright Protection, Access Control Schemes and others. The basic goal of the content owners is to regain their power over the media they own. In the time of analog reproduction private copies of media were not a big problem. The quality of analog copies degraded significantly and therefore widespread distribution of works did not occur. Digital technology changed this. The use of the Internet and the availability of powerful personal computers made it possible for the layman to download digital content from the Internet, manipulate it on the local machine and redistribute it. Peer-to-Peer systems allow easy and fast distribution of works over the Internet.This has effects on all kinds of media: audio, images and videos. Over the last several years a widespread discussion about the consumers\u2019 and producers\u2019 rights has occured. No real solution has been found yet and the very political discussion is likely to continue for some time.", "num_citations": "2\n", "authors": ["1756"]}
{"title": "Watermark security via high-resolution wavelet filter parametrization\n", "abstract": " Watermark security via high-resolution wavelet filter parametrization \u2014 Paris-Lodron-Universit\u00e4t Salzburg Zur Hauptnavigation wechseln Zur Suche wechseln Zum Hauptinhalt wechseln Paris-Lodron-Universit\u00e4t Salzburg Logo Hilfe und FAQ Deutsch English Home Profile Organisationseinheiten Drittmittelprojekte Publikationen Pr\u00e4mien Verwandte T\u00e4tigkeiten Presseberichte Watermark security via high-resolution wavelet filter parametrization Titel in \u00dcbersetzung : Watermark security via high-resolution wavelet filter parametrization W. Dietl, Peter Meerwald, Andreas Uhl Computerwissenschaften Publikation: Beitrag in Buch/Bericht/Konferenzband \u203a Konferenzbeitrag \u203a Forschung \u203a Peer-reviewed \u00dcbersicht (Administrator/-in) Originalsprache Englisch Titel Proceedings of 7th International Scientific Conference, Section 1: Applied Mathematics Seiten 21-28 Publikationsstatus Ver\u00f6ffentlicht - 2002 Bibliographische Notiz \u2026", "num_citations": "2\n", "authors": ["1756"]}
{"title": "Scalability and precision by combining expressive type systems and deductive verification\n", "abstract": " Type systems and modern type checkers can be used very successfully to obtain formal correctness guarantees with little specification overhead. However, type systems in practical scenarios have to trade precision for decidability and scalability. Tools for deductive verification, on the other hand, can prove general properties in more cases than a typical type checker can, but they do not scale well. We present a method to complement the scalability of expressive type systems with the precision of deductive program verification approaches. This is achieved by translating the type uses whose correctness the type checker cannot prove into assertions in a specification language, which can be dealt with by a deductive verification tool. Type uses whose correctness the type checker can prove are instead turned into assumptions to aid the verification tool in finding a proof.Our novel approach is introduced both\u00a0\u2026", "num_citations": "1\n", "authors": ["1756"]}
{"title": "Ensuring correct cryptographic algorithm and provider usage at compile time\n", "abstract": " Using cryptographic APIs to encrypt and decrypt data, calculate digital signatures, or compute hashes is error prone. Weak or unsupported cryptographic algorithms can cause information leakage and runtime exceptions, such as a NoSuchAlgorithmException in Java. Using the wrong cryptographic service provider can also lead to unsupported cryptographic algorithms. Moreover, for Android developers who want to store their key material in the Android Keystore, misused cryptographic algorithms and providers make the key material unsafe.", "num_citations": "1\n", "authors": ["1756"]}
{"title": "UJ: type soundness for universe types\n", "abstract": " Universe types characterise aliasing in object oriented programming languages and are used to reason modularly about programs. In this report we formalise prior work by M \u0308uller and Poetzsch-Heffter, who designed the Universe Type System for a core subset of Java. We present our work in two steps. We first give a Topological Universe Type System and show subject reduction to a small-step dynamic semantics for our language. Motivated by concerns of Modular verification, we then give an Encapsulation Universe Type System (based on the owner-as-modifier principle), prove subject reduction with respect to the former small-step semantics, and show how the type system can be used for modular verification.", "num_citations": "1\n", "authors": ["1756"]}