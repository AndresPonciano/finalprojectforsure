{"title": "ASBTAT: Linked Data Summaries with ABstraction and STATistics\n", "abstract": " While much work has focused on continuously publishing Linked Open Data, little work considers how to help consumers to better understand existing datasets. ABSTAT framework aims at providing a better understanding of big and complex datasets by extracting summaries of linked data sets based on an ontology-driven data abstraction model. Our ABSTAT framework takes as input a data set and an ontology and returns an ontology-driven data summary as output. The summary is exported into RDF and then made accessible through a SPARQL endpoint and a web interface to support the navigation.", "num_citations": "34\n", "authors": ["1947"]}
{"title": "A Container-centric Methodology for Benchmarking Workflow Management Systems\n", "abstract": " Trusted benchmarks should provide reproducible results obtained following a transparent and well-defined process. In this paper, we show how Containers, originally developed to ease the automated deployment of Cloud application components, can be used in the context of a benchmarking methodology. The proposed methodology focuses on Workflow Management Systems (WfMSs), a critical service orchestration middleware, which can be characterized by its architectural complexity, for which Docker Containers offer a highly suitable approach. The contributions of our work are: 1) a new benchmarking approach taking full advantage of containerization technologies; and 2) the formalization of the interaction process with the WfMS vendors described clearly in a written agreement. Thus, we take advantage of emerging Cloud technologies to address technical challenges, ensuring the performance measurements can be trusted. We also make the benchmarking process transparent, automated, and repeatable so that WfMS vendors can join the benchmarking effort.", "num_citations": "24\n", "authors": ["1947"]}
{"title": "Is it a Real Code Smell to be Removed or not?\n", "abstract": " Several kinds of smells have been defined in the literature, but no formal definition exists. Hence, the code smells detection tools provide different results, because the smells can be interpreted and detected in different ways. Moreover, other aspects related to the domain of the system under analysis, or its size and other design features are not usually taken into account. For these reasons the detected smells may not always be real smells and symptoms of problems to be solved. In this paper we address this question on the evaluation of smells. We focus our attention on the detection of two smells, God Class and Data Class on different systems, with the aim to identify possible filters to be used to improve or refine the detection rules of these smells. By identifying only real smells, the refactoring effort to inspect and remove them is reduced.", "num_citations": "16\n", "authors": ["1947"]}
{"title": "Code Smells and their Collocations A Large-scale Experiment on Open-source Systems\n", "abstract": " Code smells indicate possible flaws in software design, that could negatively affect system\u2019s maintainability. Interactions among smells located in the same classes (i.e., collocated smells) have even more detrimental effect on quality. Extracted frequent patterns of collocated smells could help to understand practical consequences of collocations. In this paper we identify and empirically validate frequent collocations of 14 code smells detected in 92 Java systems, using three approaches: pairwise correlation analysis, PCA and associative rules. To cross-validate the results, we used up to 6 detectors for each smell. Additionally, we examine and compare techniques used to extract the relationships. The contribution is three-fold: (1) we identify and empirically validate relationships among the examined code smells on a large dataset that we made publicly available, (2) we discuss how the choice of code smell\u00a0\u2026", "num_citations": "14\n", "authors": ["1947"]}
{"title": "JCodeOdor: A Software Quality Advisor Through Design Flaws Detection\n", "abstract": " Nobody has a perfect life; everyone has his or her own problems. Everyone during his or her life did some blood tests and took them to their doctor. When the doctor looks at blood tests, uses as a reference some indicators and a corresponding range of values to assess our health. To make a detailed assessment the doctor never evaluates the various indicators individually, but always looking at groups of them as a whole. For software, it is very similar. Each software has its problems, we have instruments to analyse it using some indicators, software metrics, and we can determine reference values to understand whether the software is\" sick\" or not. The main difference between humans and software is that humans have similar physical characteristics, with some exceptions, and software are very different, with some exceptions. In this chapter, we discuss how we deal with software\" health\" assessment, evaluating metrics as a whole as indicators, using code smells (a particular kind of design flaw), and the problems that we have to tackle with for doing that. We particularly refer to object-oriented software design assessment.", "num_citations": "11\n", "authors": ["1947"]}
{"title": "Towards Generating Elastic Microservices: A Declarative Specification for Consistent Elasticity Configurations\n", "abstract": " The adoption of Microservice architectures deployed using containers has increased over the last years. This deployment and operation stack brings new challenges in exploiting Cloud elasticity. Currently, the generation and maintenance of configuration rules that specify when and how to scale containers are human-driven-thus error-prone-and wholly decoupled from continuous delivery pipelines. Considering frequent changes, the deployed Microservice might diverge from its elasticity configuration rules which either inquires unforeseen costs or degrades its performance. We tackle this problem by leveraging declarative performance approaches to keep elasticity configuration artefacts aligned with the deployment and their requirements through the entire software development life-cycle. In this paper we propose an extension of a state of the art approach for declarative performance test definition, to enable\u00a0\u2026", "num_citations": "2\n", "authors": ["1947"]}
{"title": "BPMeter: Web Service and Application for Static Analysis of BPMN 2.0 Collections\n", "abstract": " The number of business process models is constantly increasing as companies realize the competitive advantage of managing their processes. Measuring their size and structural properties can give useful insights. With the BPMeter tool, process owners can quickly compare their process with company\u2019s process portfolio, researchers can statically analyze a process to see which modeling language features have been used in practice, while modelers can obtain an aggregated view over their processes. In this demonstration we show how to use BPMeter, which provides a simple Web application to visualize the results of applying over 100 different size and structure metrics to BPMN 2.0 process models. The visualization features measurements, statistics and the possibility to compare the measurements with the ones obtained from the entire portfolio. Moreover we show how to invoke its RESTful Web API so that the BPMeter analyzer can be easily integrated with existing process management tools.", "num_citations": "2\n", "authors": ["1947"]}
{"title": "\u201cBPELanon\u201d: Protect Business Processes on the Cloud\n", "abstract": " The advent of Cloud computing supports the offering of many Business Process Management applications on a distributed, per-use basis environment through its infrastructure. Due to the fact that privacy is still an open issue in the Cloud, many companies are reluctant to move their Business Processes on a public Cloud. Since the Cloud environment can be beneficiary for the Business Processes, the investigation of privacy issues needs to be further examined. In order to enforce the Business Process sharing on the Cloud we propose a methodology (\u201cBPELanon\u201d) for the anonymization of Business Processes expressed in the Web Service Business Process Execution Language (BPEL). The method transforms a process to preserve its original structure and run-time behavior, while completely anonymizing its business semantics. In this work we set the theoretical framework of the method and define a five management layers architecture to support its realization. We developed a tool that implements the \u201cBPELanon\u201d method, validate its functionality and evaluate its performance against a collection of real-world process models that were conducted in the scope of research projects.", "num_citations": "2\n", "authors": ["1947"]}