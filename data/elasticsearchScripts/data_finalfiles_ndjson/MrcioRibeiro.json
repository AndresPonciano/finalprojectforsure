{"title": "Intraprocedural dataflow analysis for software product lines\n", "abstract": " Software product lines (SPLs) are commonly developed using annotative approaches such as conditional compilation that come with an inherent risk of constructing erroneous products. For this reason, it is essential to be able to analyze SPLs. However, as dataflow analysis techniques are not able to deal with SPLs, developers must generate and analyze all valid methods individually, which is expensive for non-trivial SPLs. In this paper, we demonstrate how to take any standard intraprocedural dataflow analysis and automatically turn it into a feature-sensitive dataflow analysis in three different ways. All are capable of analyzing all valid methods of an SPL without having to generate all of them explicitly. We have implemented all analyses as extensions of SOOT's intraprocedural dataflow analysis framework and experimentally evaluated their performance and memory characteristics on four qualitatively different\u00a0\u2026", "num_citations": "69\n", "authors": ["797"]}
{"title": "Investigating preprocessor-based syntax errors\n", "abstract": " The C preprocessor is commonly used to implement variability in program families. Despite the widespread usage, some studies indicate that the C preprocessor makes variability implementation difficult and error-prone. However, we still lack studies to investigate preprocessor-based syntax errors and quantify to what extent they occur in practice. In this paper, we define a technique based on a variability-aware parser to find syntax errors in releases and commits of program families. To investigate these errors, we perform an empirical study where we use our technique in 41 program family releases, and more than 51 thousand commits of 8 program families. We find 7 and 20 syntax errors in releases and commits of program families, respectively. They are related not only to incomplete annotations, but also to complete ones. We submit 8 patches to fix errors that developers have not fixed yet, and they accept 75\u00a0\u2026", "num_citations": "53\n", "authors": ["797"]}
{"title": "Intraprocedural dataflow analysis for software product lines\n", "abstract": " Software product lines (SPLs) developed using annotative approaches such as conditional compilation come with an inherent risk of constructing erroneous products. For this reason, it is essential to be able to analyze such SPLs. However, as dataflow analysis techniques are not able to deal with SPLs, developers must generate and analyze all valid products individually, which is expensive for non-trivial SPLs.             In this paper, we demonstrate how to take any standard intraprocedural dataflow analysis and automatically turn it into a feature-sensitive dataflow analysis in five different ways where the last is a combination of the other four. All analyses are capable of analyzing all valid products of an SPL without having to generate all of them explicitly.             We have implemented all analyses using SOOT\u2019s intraprocedural dataflow analysis framework and experimentally evaluated four of them according to\u00a0\u2026", "num_citations": "52\n", "authors": ["797"]}
{"title": "Emergent feature modularization\n", "abstract": " Virtual Separation of Concerns reduces the drawbacks of implementing product line variability with preprocessors. Developers can focus on certain features and hide others of no interest. However, these features eventually share elements between them, which might break feature modularization, since modifications in a feature result in problems for another. We present the concept of emergent feature modularization, which aims to establish contracts between features, to prevent developers from breaking other features when performing a maintenance task. These interfaces are product-line-aware, in the sense that it only considers valid feature combinations. We also present a prototype tool that implements the concept.", "num_citations": "47\n", "authors": ["797"]}
{"title": "Experience report: Evaluating the effectiveness of decision trees for detecting code smells\n", "abstract": " Developers continuously maintain software systems to adapt to new requirements and to fix bugs. Due to the complexity of maintenance tasks and the time-to-market, developers make poor implementation choices, also known as code smells. Studies indicate that code smells hinder comprehensibility, and possibly increase change- and fault-proneness. Therefore, they must be identified to enable the application of corrections. The challenge is that the inaccurate definitions of code smells make developers disagree whether a piece of code is a smell or not, consequently, making difficult creation of a universal detection solution able to recognize smells in different software projects. Several works have been proposed to identify code smells but they still report inaccurate results and use techniques that do not present to developers a comprehensive explanation how these results have been obtained. In this\u00a0\u2026", "num_citations": "46\n", "authors": ["797"]}
{"title": "Feature maintenance with emergent interfaces\n", "abstract": " Hidden code dependencies are responsible for many complications in maintenance tasks. With the introduction of variable features in configurable systems, dependencies may even cross feature boundaries, causing problems that are prone to be detected late. Many current implementation techniques for product lines lack proper interfaces, which could make such dependencies explicit. As alternative to changing the implementation approach, we provide a tool-based solution to support developers in recognizing and dealing with feature dependencies: emergent interfaces. Emergent interfaces are inferred on demand, based on feature-sensitive intraprocedural and interprocedural data-flow analysis. They emerge in the IDE and emulate modularity benefits not available in the host language. To evaluate the potential of emergent interfaces, we conducted and replicated a controlled experiment, and found, in the\u00a0\u2026", "num_citations": "44\n", "authors": ["797"]}
{"title": "Assessing fine-grained feature dependencies\n", "abstract": " Context: Maintaining software families is not a trivial task. Developers commonly introduce bugs when they do not consider existing dependencies among features. When such implementations share program elements, such as variables and functions, inadvertently using these elements may result in bugs. In this context, previous work focuses only on the occurrence of intraprocedural dependencies, that is, when features share program elements within a function. But at the same time, we still lack studies investigating dependencies that transcend the boundaries of a function, since these cases might cause bugs as well.Objective: This work assesses to what extent feature dependencies exist in actual software families, answering research questions regarding the occurrence of intraprocedural, global, and interprocedural dependencies and their characteristics.Method: We perform an empirical study covering 40\u00a0\u2026", "num_citations": "31\n", "authors": ["797"]}
{"title": "An empirical study on configuration-related issues: Investigating undeclared and unused identifiers\n", "abstract": " The variability of configurable systems may lead to configuration-related issues (i.e., faults and warnings) that appear only when we select certain configuration options. Previous studies found that issues related to configurability are harder to detect than issues that appear in all configurations, because variability increases the complexity. However, little effort has been put into understanding configuration-related faults (e.g., undeclared functions and variables) and warnings (e.g., unused functions and variables). To better understand the peculiarities of configuration-related undeclared/unused variables and functions, in this paper we perform an empirical study of 15 systems to answer research questions related to how developers introduce these issues, the number of configuration options involved, and the time that these issues remain in source files. To make the analysis of several projects feasible, we propose a\u00a0\u2026", "num_citations": "28\n", "authors": ["797"]}
{"title": "The discipline of preprocessor-based annotations-does# ifdef TAG n't# endif matter\n", "abstract": " The C preprocessor is a simple, effective, and language-independent tool. Developers use the preprocessor in practice to deal with portability and variability issues. Despite the widespread usage, the C preprocessor suffers from severe criticism, such as negative effects on code understandability and maintainability. In particular, these problems may get worse when using undisciplined annotations, i.e., when a preprocessor directive encompasses only parts of C syntactical units. Nevertheless, despite the criticism and guidelines found in systems like Linux to avoid undisciplined annotations, the results of a previous controlled experiment indicated that the discipline of annotations has no influence on program comprehension and maintenance. To better understand whether developers care about the discipline of preprocessor-based annotations and whether they can really influence on maintenance tasks, in this\u00a0\u2026", "num_citations": "26\n", "authors": ["797"]}
{"title": "Ontology-based feature modeling: An empirical study in changing scenarios\n", "abstract": " A software product line (SPL) is a set of software systems that have a particular set of common features and that satisfy the needs of a particular market segment or mission. Feature modeling is one of the key activities involved in the design of SPLs. The feature diagram produced in this activity captures the commonalities and variabilities of SPLs. In some complex domains (e.g., ubiquitous computing, autonomic systems and context-aware computing), it is difficult to foresee all functionalities and variabilities a specific SPL may require. Thus, Dynamic Software Product Lines (DSPLs) bind variation points at runtime to adapt to fluctuations in user needs as well as to adapt to changes in the environment. In this context, relying on formal representations of feature models is important to allow them to be automatically analyzed during system execution. Among the mechanisms used for representing and analyzing feature\u00a0\u2026", "num_citations": "21\n", "authors": ["797"]}
{"title": "Colligens: A Tool to Support the Development of Preprocessor-Based Software Product Lines in C\n", "abstract": " A Software Product Line (SPL) is a set of products developed from reusable assets. These products share a common platform and we can customize them for specific customers. In an SPL, developers use the concept of features. They are the semantic units by which we can differentiate products. In C programming, we can implement features by mapping them to preprocessor directives, such as# ifdef and# endif. In this context, although there are tools to deal with C preprocessors and SPLs, they are not integrated, which hinders their usage in product line development. In this paper, we propose a tool that provides an integrated environment based on the Eclipse platform to support the development of preprocessor-based SPLs in C. Thus, developers can create feature models, see SPL metrics, and generate SPL products automatically after checking for the absence of invalid products.", "num_citations": "21\n", "authors": ["797"]}
{"title": "AutoRefactoring: A platform to build refactoring agents\n", "abstract": " Software maintenance may degrade the software quality. One of the primary ways to reduce undesired effects of maintenance is refactoring, which is a technique to improve software code quality without changing its observable behavior. To safely apply a refactoring, several issues must be considered: (i) identify the code parts that should be improved; (ii) determine the changes that must be applied to the code in order to improve its; (iii) evaluate the corrections impacts on code quality; and (iv) check that the observable behavior of the software will be preserved after applying the corrections. Given the amount of issues to consider, refactoring by hand has been assumed to be an expensive and error-prone task. Therefore, in this paper, we propose an agent-based platform that enables to implement an agent able to autonomously deal with the above mentioned refactoring issues. To evaluate our approach, we\u00a0\u2026", "num_citations": "17\n", "authors": ["797"]}
{"title": "A Catalogue of Refactorings to Remove Incomplete Annotations.\n", "abstract": " Developers use the C Preprocessor (CPP) to handle portability and variability in program families of different sizes and domains. However, despite the widely use of the CPP in practice, it is often criticised due to its negative impact on code quality and maintainability, tool development, and its error-prone characteristics. In particular, developers aggravate these problems when using incomplete annotations, ie, directives encompassing only parts of syntactical units. In a previous work, we performed an empirical study on 41 C program family releases and found that almost 90% of syntax errors occur in incomplete annotations. There are some refactorings to remove incomplete annotations proposed in the literature. However, they clone code and increase Lines of Code (LOC). To avoid incomplete annotations and their intrinsic problems, in this article we propose a catalogue of refactorings that converts incomplete\u00a0\u2026", "num_citations": "16\n", "authors": ["797"]}
{"title": "Improving Guidance when Restructuring Variabilities in Software Product Lines\n", "abstract": " Software product lines (SPLs) encompass a family of software systems developed from reusable assets. One issue during SPL maintenance is the decision about which mechanism should be used to restructure variabilities aiming at improving the modularity of the SPL artifacts. Due to the great variety of mechanisms (inheritance, configuration files, aspect-oriented programming), selecting the incorrect ones may produce negative effects on the cost to evolve the SPL. To reduce this problem, we propose a decision model to help developers to choose mechanisms to restructure variabilities in SPLs. The domain analyzed by this work consists of test scripts. We also developed a prototype tool to support developers by recommending mechanisms according to the decision model. Using our model and tool may improve the tests variabilitiespsila modularity and remove bad smells such as cloned code.", "num_citations": "16\n", "authors": ["797"]}
{"title": "A design rule language for aspect-oriented programming\n", "abstract": " Aspect-oriented programming is known as a technique for modularizing crosscutting concerns. However, constructs aimed to support crosscutting modularity might actually break class modularity. As a consequence, class developers face changeability, parallel development and comprehensibility problems, because they must be aware of aspects whenever they develop or maintain a class. At the same time, aspects are vulnerable to changes in classes, since there is no contract specifying the points of interaction amongst these elements. These problems can be mitigated by using adequate design rules between classes and aspects. We present a design rule specification language and explore its benefits since the initial phases of the development process, specially with the aim of supporting modular development of classes and aspects. We discuss how our language improves crosscutting modularity without\u00a0\u2026", "num_citations": "15\n", "authors": ["797"]}
{"title": "Regenerative responses and axon pathfinding of retinal ganglion cells in chronically injured mice\n", "abstract": " Purpose: Enhanced regeneration of retinal ganglion cell (RGC) axons can be achieved by modification of numerous neuronal-intrinsic factors. However, axon growth initiation and the pathfinding behavior of these axons after traumatic injury remain poorly understood outside of acute injury paradigms, despite the clinical relevance of more chronic settings. We therefore examined RGC axon regeneration following therapeutic delivery that is postponed until 2 months after optic nerve crush injury.Methods: Optic nerve regeneration was induced by virally mediated (adeno-associated virus) ciliary neurotrophic factor (AAV-CNTF) administered either immediately or 56 days after optic nerve crush in wild-type or Bax knockout (KO) mice. Retinal ganglion nerve axon regeneration was assessed 21 and 56 days after viral injection. Immunohistochemical analysis of RGC injury signals and extrinsic factors in the optic nerve were also examined at 5 and 56 days post crush.Results: In addition to sustained expression of injury response proteins in surviving RGCs, we observe axon regrowth in wild-type and apoptosis-deficient Bax KO mice following AAV-CNTF treatment. Fewer instances of aberrant axon growth are seen, at least in the area near the lesion site, in animals given treatment 56 days after crush injury compared to the animals given treatment immediately after injury. We also find evidence of long distance growth into a visual target in Bax KO mice despite postponed initiation of this regenerative program.Conclusions: These studies provide evidence against an intrinsic critical period for RGC axon regeneration or degradation of injury signals\u00a0\u2026", "num_citations": "14\n", "authors": ["797"]}
{"title": "Emergo: A tool for improving maintainability of preprocessor-based product lines\n", "abstract": " When maintaining a feature in preprocessor-based Software Product Lines (SPLs), developers are susceptible to introduce problems into other features. This is possible because features eventually share elements (like variables and methods) with the maintained one. This scenario might be even worse when hiding features by using techniques like Virtual Separation of Concerns (VSoC), since developers cannot see the feature dependencies and, consequently, they become unaware of them. Emergent Interfaces was proposed to minimize this problem by capturing feature dependencies and then providing information about other features that can be impacted during a maintenance task. In this paper, we present Emergo, a tool capable of computing emergent interfaces between the feature we are maintaining and the others. Emergo relies on feature-sensitive dataflow analyses in the sense it takes features and\u00a0\u2026", "num_citations": "14\n", "authors": ["797"]}
{"title": "On the modularity of aspect-oriented and other techniques for implementing product lines variabilities\n", "abstract": " Software Product Lines (SPLs) encompass a family of softwareintensive systems developed from reusable assets. One major issue during SPL development is the decision about which technique should be used to implement variabilities. Although Aspect-Oriented Programming (AOP) has been used to this purpose, we still need to identify in which situations it is suitable or not. We propose a catalog of variabilities at the source code level and a set of patterns for implementing them. After analyzing these patterns, we concluded that AOP is not the best technique to implement some kinds of variabilities from our catalog. We argue that our approach is useful to find the most suitable techniques to handle specific variabilities at the source code level.", "num_citations": "14\n", "authors": ["797"]}
{"title": "Unveiling and reasoning about co-change dependencies\n", "abstract": " Product flexibility is one of the expected benefits of a modular design, and thus\" it should be possible to make drastic changes to a module without changing others.\" Accordingly, the data available on version control systems might help software architects to reason about some quality attributes of the modular decomposition of a system. In this paper we investigate the impact of co-change dependencies into system stability, that is, the potential ripple effect that might occur during maintenance tasks. Here we use (a) Design Structure Matrices (DSMs) for visualizing dependencies motivated by assets\u2019 co-change and (b) two metrics for estimating system stability: Propagation Cost of Changes and Clustered Cost of a Decomposition. We conducted a comprehensive study about co-change dependencies and their effects on system stability, considering the change history of six open-source Java systems: Derby, Eclipse\u00a0\u2026", "num_citations": "13\n", "authors": ["797"]}
{"title": "Optimizing mutation testing by discovering dynamic mutant subsumption relations\n", "abstract": " One recent promising direction on reducing costs of mutation analysis is to identify redundant mutations, i.e., mutations that are subsumed by some other mutations. Previous works found out redundant mutants manually through the truth table. Although the idea is promising, it can only be applied for logical and relational operators. In this paper, we propose an approach to discover redundancy in mutations through dynamic subsumption relations among mutants. We focus on subsumption relations among mutations of an expression or statement, named here as \u201cmutation target:\u201d By focusing on targets and relying on automatic test generation tools, we define subsumption relations for dozens of mutation targets in which the MUJAVA tool can apply mutations. We then implemented these relations in a tool, named MUJAVA-M, that generates a reduced set of mutants for each target, avoiding redundant mutants. We\u00a0\u2026", "num_citations": "11\n", "authors": ["797"]}
{"title": "AspectJ-based idioms for flexible feature binding\n", "abstract": " In Software Product Lines (SPL), we can bind reusable features to compose a product at different times, which in general are static or dynamic. The former allows customizability without any overhead at runtime. On the other hand, the latter allows feature activation or deactivation while running the application with the cost of performance and memory consumption. To implement features, we might use aspect-oriented programming (AOP), in which aspects enable a clear separation between base code and variable code. In this context, recent work provides AspectJ-based idioms to implement flexible feature binding. However, we identified some design deficiencies. Thus, to solve the issues of these idioms, we incrementally create three new AspectJ-based idioms. Moreover, to evaluate our new idioms, we quantitatively analyze them with respect to code cloning, scattering, tangling, and size by means of software\u00a0\u2026", "num_citations": "11\n", "authors": ["797"]}
{"title": "Assessing Idioms for Implementing Features with Flexible Binding Times\n", "abstract": " Maintainability of a software product line depends on the possibility to modularize its variations, often expressed in terms of optionally selected features. Conventional modularization techniques bind variations either statically or dynamically, but ideally it should be possible to flexibly choose between both. In this paper, we propose improved solutions for modularizing and flexibly binding varying features in form of idioms in aspect-oriented languages AspectJ and CaesarJ. We evaluate the idioms qualitatively by discussing their advantages and deficiencies and quantitatively by means of metrics.", "num_citations": "11\n", "authors": ["797"]}
{"title": "How Does Incomplete Composite Refactoring Affect Internal Quality Attributes?\n", "abstract": " Program refactoring consists of code changes applied to improve the internal structure of a program and, as a consequence, its comprehensibility. Recent studies indicate that developers often perform composite refactorings, ie, a set of two or more interrelated single refactorings. Recent studies also recommend certain patterns of composite refactorings to fully remove poor code structures, ie, code smells, thus further improving the program comprehension. However, other recent studies report that composite refactorings often fail to fully remove code smells. Given their failure to achieve this purpose, these composite refactorings are considered incomplete, ie, they are not able to entirely remove a smelly structure. Unfortunately, there is no study providing an in-depth analysis of the incompleteness nature of many composites and their possibly partial impact on improving, maybe decreasing, internal quality attributes\u00a0\u2026", "num_citations": "10\n", "authors": ["797"]}
{"title": "Considerations on performance, cost and power consumption of candidate 100G EPON architectures\n", "abstract": " An overview of several candidate architectures for 100 Gb/s capable optical access networks is presented. Considerations for their system requirements are outlined in regards to performance, cost and energy efficiency, towards addressing the design issues for the next generation EPON.", "num_citations": "10\n", "authors": ["797"]}
{"title": "Java reflection API: revealing the dark side of the mirror\n", "abstract": " Developers of widely used Java Virtual Machines (JVMs) implement and test the Java Reflection API based on a Javadoc, which is specified using a natural language. However, there is limited knowledge on whether Java Reflection API developers are able to systematically reveal i) underdetermined specifications; and ii) non-conformances between their implementation and the Javadoc. Moreover, current automatic test suite generators cannot be used to detect them. To better understand the problem, we analyze test suites of two widely used JVMs, and we conduct a survey with 130 developers who use the Java Reflection API to see whether the Javadoc impacts on their understanding. We also propose a technique to detect underdetermined specifications and non-conformances between the Javadoc and the implementations of the Java Reflection API. It automatically creates test cases, and executes them using\u00a0\u2026", "num_citations": "8\n", "authors": ["797"]}
{"title": "Does aspectj provide modularity when implementing features with flexible binding times?\n", "abstract": " Dynamic configuration has been receiving increased attention in the Software Product Lines community, which means that features with different binding times are becoming important and required. Although aspects have been considered to implement product lines features, some study must be done in order to evaluate whether aspects are also suitable for implementing features with flexible binding times, such as dynamic and static. Thus, this paper presents an exploratory study that investigates whether the most popular AOP language (AspectJ) provides modularity in the flexible binding time context. The results suggest that it depends on the features peculiarities like size and heterogeneity.", "num_citations": "8\n", "authors": ["797"]}
{"title": "Characterizing safe and partially safe evolution scenarios in product lines: an empirical study\n", "abstract": " Evolving software product lines is often error-prone. Previous works have proposed classifying product line evolution into safe or partially safe, depending on the number of products that have their behavior preserved after evolution. Based on these notions, it is possible to derive transformation templates that abstract common evolution scenarios, such as adding an optional feature. However, existing works are focused on evaluating either safe or partially safe templates. Hence, in this work we aim to characterize product line evolution as a whole, measuring to what extent the evolution history is safe compared to partially safe, to better understand how product lines evolve. We measure how often existing templates happen using 2,300 commits from an open-source product line. According to our study, 91.7% of the commits represent partially safe evolution scenarios. Our results also show that 1,800 of these commits\u00a0\u2026", "num_citations": "7\n", "authors": ["797"]}
{"title": "The love/hate relationship with the C preprocessor: An interview study (artifact)\n", "abstract": " This appendix presents detailed information about the research methods we used in the study, subject characterization, grounded theory process that we followed strictly, and the survey we performed in the study. It provides helpful data for understanding the subtler points of the companion paper and for reproducibility.", "num_citations": "7\n", "authors": ["797"]}
{"title": "The contract enforcement aspect pattern\n", "abstract": " The most fundamental motivation for employing contracts in the development of OO applications is to improve the reliability. Contract enforcement is a well-known established technique in object-oriented (OO) programming. However, the need to intercept well defined points in the execution of a program to check design constraints makes the enforcement of contracts a crosscutting concern. Thus, contract enforcement code is interwined with the business code, hindering maintenance. Moreover, because of the difficulty in separating contract enforcement code and business code, the former is often duplicated across several different places within a system. In this paper we present the Contract Enforcement Aspect pattern, which documents an aspect-oriented solution for the modularization of the contract concern.", "num_citations": "7\n", "authors": ["797"]}
{"title": "On the conceptual cohesion of co-change clusters\n", "abstract": " The analysis of co-change clusters as an alternative software decomposition can provide insights on different perspectives of modularity. But the usual approach using coarse-grained entities does not provide relevant information, like the conceptual cohesion of the modular abstractions that emerge from co-change clusters. This work presents a novel approach to analyze the conceptual cohesion of the source-code associated with co-change clusters of fine-grained entities. We obtain from the change history information found in version control systems. We describe the use of our approach to analyze six well established and currently active open-source projects from different domains and one of the most relevant systems of the Brazilian Government for the financial domain. The results show that co-change clusters offer a new perspective on the code based on groups with high conceptual cohesion between its\u00a0\u2026", "num_citations": "6\n", "authors": ["797"]}
{"title": "Diagnosis and prognosis of wheezing disorders in young children in the city of S\u00e3o Paulo, Southeast Brazil\n", "abstract": " Three\u2010hundred\u2010and\u2010ninety\u2010seven children aged 2\u201359 mo presenting to the paediatric emergency departments of five public hospitals in S\u00e3o Paulo, Brazil, with an acute episode of lower respiratory disease were examined. The children were classified into the following diagnostic categories: acute bronchitis, acute bronchiolitis, pneumonia, asthma, post\u2010bronchiolitis wheezing and wheezing of uncertain aetiology. Three years after the initial study, the homes of the children diagnosed as asthmatic or as having wheezing of uncertain aetiology were visited to collect information on subsequent episodes of lower respiratory disease. This paper reports the proportional incidence of different categories of lower respiratory disease and the results of an analysis to investigate clinical features that might distinguish wheezing children between those with asthma and those with an infectious disease. The predictions made for\u00a0\u2026", "num_citations": "6\n", "authors": ["797"]}
{"title": "On the performance and adoption of search-based microservice identification with tomicroservices\n", "abstract": " The expensive maintenance of legacy systems leads companies to migrate such systems to microservice architectures. This migration requires the identification of system\u2019s legacy parts to become microservices. However, the successful identification of microservices, which are promising to be adoptable in practice, requires the simultaneous satisfaction of many criteria, such as coupling, cohesion, reuse and communication overhead. Search-based microservice identification has been recently investigated to address this problem. However, state-of-the-art search-based approaches are limited as they only consider one or two criteria (namely cohesion and coupling), possibly not fulfilling the practical needs of developers. To overcome these limitations, we propose toMicroservices, a many-objective search-based approach that considers five criteria, the most cited by practitioners in recent studies. Our approach was\u00a0\u2026", "num_citations": "5\n", "authors": ["797"]}
{"title": "Ontology-based software product line for building semantic web applications\n", "abstract": " The Software Product Lines (SPL) has proved very effective in building large-scale software. However, few works seek to adjust the approach of software product line to applications in the context of semantic web. This is because applications in this context assume the use of semantic services and intelligent agents. As a result, it is necessary that there are assets that provide adequate interoperability both semantic services and intelligent agents. In this sense, it is proposed in this paper the use of ontologies for the specification of entire a project of a SPL. With this, it can be a sufficiently formal specification that can be interpreted by both software engineers and computational algorithms.", "num_citations": "5\n", "authors": ["797"]}
{"title": "On Relating Technical, Social Factors, and the Introduction of Bugs\n", "abstract": " As collaborative coding environments make it easier to contribute to software projects, the number of developers involved in these projects keeps increasing. This increase makes it more difficult for code reviewers to deal with buggy contributions. Collaborative environments like GitHub provide a rich source of data on developers' contributions. Such data can be used to extract information about developers regarding technical (e.g., their experience) and social (e.g., their interactions) factors. Recent studies analyzed the influence of these factors on different activities of software development. However, there is still room for improvement on the relation between these factors and the introduction of bugs. We present a broader study, including 8 projects from different domains and 6,537 bug reports, on relating five technical, three social factors, and the introduction of bugs. The results indicate that technical and social\u00a0\u2026", "num_citations": "4\n", "authors": ["797"]}
{"title": "An IoT based smart utility pole and street lighting system\n", "abstract": " Multifunctional Intelligent utility poles can increase urban efficiency while reducing energy costs, due to their ability to incorporate electronics, software controls and sensors that can receive and transmit data. This paper presents the design and analysis of an integrated solution for sustainable smart cities ecosystems. The system is comprised of three major components: a smart utility pole, street-lighting and an off-grid photovoltaic systems for powering the solution. Cloud-based Internet of Things (IoT) applications receive, analyze and manage data in real time for controlling and supervising. The system is installed in the Institute of Computing building at the Federal University of Alagoas in the city of Macei\u00f3 - Brazil and is mainly used to recharge mobile devices, digital signage display totem and street-lighting. The discussion in this paper is based on implementation of a smart system based on IoT to remotely\u00a0\u2026", "num_citations": "4\n", "authors": ["797"]}
{"title": "A decision model for implementing product lines variabilities\n", "abstract": " Software Product Lines (SPLs) encompass a family of software systems developed from reusable assets. One issue during SPL development is the decision about which technique should be used to implement variabilities and improve the Separation of Concerns (SoC) of the SPL. In this paper, we present an initial decision model based on both qualitative and quantitative analysis to guide developers on choosing suitable techniques for implementing SPL variabilities.", "num_citations": "4\n", "authors": ["797"]}
{"title": "Brazilian Data Scientists: Revealing their Challenges and Practices on Machine Learning Model Development\n", "abstract": " Data scientists often develop machine learning models to solve a variety of problems in the industry and academy. To build these models, these professionals usually perform activities that are also performed in the traditional software development lifecycle, such as eliciting and implementing requirements. One might argue that data scientists could rely on the engineering of traditional software development to build machine learning models. However, machine learning development presents certain characteristics, which may raise challenges that lead to the need for adopting new practices. The literature lacks in characterizing this knowledge from the perspective of the data scientists. In this paper, we characterize challenges and practices addressing the engineering of machine learning models that deserve attention from the research community. To this end, we performed a qualitative study with eight data\u00a0\u2026", "num_citations": "3\n", "authors": ["797"]}
{"title": "Refactoring test smells: A perspective from open-source developers\n", "abstract": " Test smells are symptoms in the test code that indicate possible design or implementation problems. Their presence, along with their harmfulness, has already been demonstrated by previous researches. However, we do not know to what extent developers acknowledge the presence of test smells and how to refactor existing code to eliminate them in practice. This study aims to assess open-source developers' awareness about the existence of test smells and their refactoring strategies. We conducted a mixed-method study with two parts:(i) a survey with 73 experienced open-source developers to assess their preference and motivation to choose between 10 different smelly test code samples, found in 272 open-source projects, and their refactored versions; and (ii) the submission of 50 pull requests to assess developers' acceptance of the proposed refactorings. As a result, most surveyed developers preferred the\u00a0\u2026", "num_citations": "3\n", "authors": ["797"]}
{"title": "Search-based many-criteria identification of microservices from legacy systems\n", "abstract": " The expensive maintenance of legacy systems lead companies to migrate such systems to a microservice architecture. This migration requires the identification of microservice candidates, which requires analysis of many criteria. Existing search-based approaches to solve this problem are only based on the coupling and cohesion criteria. To overcome these limitations, we propose a many-objective search-based approach for identifying microservice candidates. Its five objectives correspond to criteria pointed as useful by experienced developers. Our approach was evaluated in the context of a legacy system. The results show that our approach is very similar on optimizing the traditional criteria of coupling and cohesion, but much better when taking into account the additional criteria.", "num_citations": "3\n", "authors": ["797"]}
{"title": "Towards feature modularization\n", "abstract": " Virtual Separation of Concerns was introduced as a way to reduce drawbacks of implementing product line variability with preprocessors. Developers can focus on certain features and hide others of no interest. However, features eventually share elements, which might break feature modularity, since modifications in a feature result in problems for another. In this thesis we propose the concept of emergent feature modularization. The idea consists of establishing contracts among features to prevent the developer from breaking other features when performing a maintenance task.", "num_citations": "3\n", "authors": ["797"]}
{"title": "Recommending refactorings when restructuring variabilities in software product lines\n", "abstract": " When restructuring variabilities in Software Product Lines (SPL), due to the great variety of existing mechanisms-such as Inheritance, Configuration Files, Aspect-Oriented Programming etc, developers may spend time and effort to decide which mechanism to use and which refactorings should be applied. To help on this task, we propose in this paper a tool capable of recommending refactorings based on some mechanisms. By applying the recommendations of our tool, bad smells such as cloned code may be removed and the modularity of the features is improved.", "num_citations": "3\n", "authors": ["797"]}
{"title": "Atoms of Confusion: The Eyes Do Not Lie\n", "abstract": " Code comprehension is crucial in software maintenance activities, though it can be hindered by misunderstandings and confusion patterns, namely, atoms of confusion. They are small pieces of code using specific programming language constructs, such as Conditional Operators and Comma Operators. A previous study showed that these atoms of confusion impact developers' performance, ie, time and accuracy, and increase code misunderstandings. However, empirical knowledge of the impact of such atoms on code comprehension is still scarce, especially when it comes to analyzing that impact on developers' visual attention. The present study evaluates whether developers misunderstand the code in the presence of atoms of confusion with an eye tracker. For this purpose, we measure the tasks' completion time, the accuracy of the answers, and analyze the distribution of visual attention. We conducted a\u00a0\u2026", "num_citations": "2\n", "authors": ["797"]}
{"title": "Understanding and Detecting Harmful Code\n", "abstract": " Code smells typically indicate poor design implementation and choices that may degrade software quality. Hence, they need to be carefully detected to avoid such poor design. In this context, some studies try to understand the impact of code smells on the software quality, while others propose rules or machine learning-based techniques to detect code smells. However, none of those studies or techniques focus on analyzing code snippets that are really harmful to software quality. This paper presents a study to understand and classify code harmfulness. We analyze harmfulness in terms of CLEAN, SMELLY, BUGGY, and HARMFUL code. By HARMFUL CODE, we define a SMELLY code element having one or more bugs reported. These bugs may have been fixed or not. Thus, the incidence of HARMFUL CODE may represent a increased risk of introducing new defects and/or design problems during its fixing. We\u00a0\u2026", "num_citations": "2\n", "authors": ["797"]}
{"title": "Software Families, Software Products Lines, and Dataflow Analyses\n", "abstract": " In this chapter we review essential concepts we explore in this work. Firstly, we review software families and software product lines, since the problem we address here is critical in these contexts. We show the basic concepts and then move towards conditional compilation with preprocessors, a widely used mechanism to implement features in industrial practice. Despite the widespread usage, conditional compilation has several drawbacks. We then present the Virtual Separation of Concerns (VSoC) approach, which can minimize some of these drawbacks. In this work, we intend to address the lack of feature modularity. Thus, we need to catch dependencies between features and inform developers about them. To do so, we rely on dataflow analyses, the last topic we review in this chapter.", "num_citations": "2\n", "authors": ["797"]}
{"title": "Flexible Feature Binding with AspectJ-based Idioms.\n", "abstract": " In Software Product Lines (SPL), we can bind reusable features to compose a product at different times, which in general are static or dynamic. The former allows customizability without any overhead at runtime. On the other hand, the latter allows feature activation or deactivation while running the application with the cost of performance and memory consumption. To implement features, we might use aspect-oriented programming (AOP), in which aspects enable a clear separation between invariable code and variable code. In this context, recent work provides AspectJ-based idioms to implement flexible feature binding. However, we identified some design deficiencies. Thus, to solve the issues of these idioms, we incrementally create three AspectJ-based idioms. We apply these idioms to provide flexible binding for 16 features from five different product lines. Moreover, to evaluate our idioms, we quantitatively\u00a0\u2026", "num_citations": "2\n", "authors": ["797"]}
{"title": "Bug reports retrieval using Self-organizing Map\n", "abstract": " An important process when implementing complex software systems consist of documenting the bugs found in that software. However, since many developers are working at the same time on the project, a bug may easily be reported multiple times, resulting in duplicated bug reports. Therefore, developers responsible for fixing bugs may spend time and effort reading and trying to understand two bugs that actually are the same. This way, we propose in this paper an approach for identifying duplicated bug reports that combines document indexing and self-organizing maps (SOM). The results of our experiments show that at most 69% of duplicated bug reports were identified, representing saving of time and effort for the developers.", "num_citations": "2\n", "authors": ["797"]}
{"title": "Revealing the Social Aspects of Design Decay\n", "abstract": " The pull-based development model is widely used in source-code enviroments like GitHub. In this model, developers actively communicate and share their knowledge or opinions through the exchange of comments. Their goal is to improve the change under development, including its positive impact on design structure. In this context, two central social aspects may contribute to combating or adversely amplifying design decay. First, design decay may be avoided, reduced or accelerated depending whether the communication dynamics among developers\u2013who play specific roles\u2013is fluent and consistent along a change. Second, the discussion content itself may be decisive to either improve or deteriorate the structural design of a system. Unfortunately, there is no study on the the role that key social aspects play on avoiding or amplifying design decay. Previous work either investigates technical aspects of design decay or confirms the high frequency of design discussions in pullbased software development. This paper reports a retrospective study aimed at understanding the role of communication dynamics and discussion content on design decay. We focused our analysis on 11 social metrics related to these two aspects as well as 4 control technical metrics typically used as indicators of design decay. We analyzed more than 11k pull request discussions mined from five large open-source software systems. Our findings reveal that many social metrics can be used to discriminate between design impactful and unimpactful pull requests. Second, various factors of communication dynamics are related to design decay. However, temporal factors of\u00a0\u2026", "num_citations": "1\n", "authors": ["797"]}
{"title": "30 Days After Introducing Programming: Which of My Students Are Likely to Fail?\n", "abstract": " Predictors to identify whether a student will succeed or fail in introductory programming courses have been provided by previous research. However, they rely on time-consuming aptitude tests and surveys. This way, setting, executing, and replicating these studies is hard and increase the professor effort. Other predictors rely on automatic procedures, but they either do not identify the failing students early or do not provide high effectiveness. To minimize these problems, we propose a strategy to early predict the potential failing students during introductory programming courses automatically, reducing effort and allowing professors to use it in every course. By having this set of students in the first days of the course, professors and mentors would have time to act and potentially avoid such failings. The strategy consists of three steps: the use of an online judge system; the collection of metrics from this system; and the use of a clustering algorithm. To evaluate our strategy, we conduct an empirical study regarding 358 freshmen students of 12 introductory programming courses. We consider the first 30 days of the course. From the group of students our strategy points as\" likely to fail,\" 80% of the students on average indeed fail.", "num_citations": "1\n", "authors": ["797"]}
{"title": "Assessing idioms for a flexible feature binding time\n", "abstract": " In software product lines development, it is sometimes important to provide a flexible binding time for features such that developers can choose between static or dynamic feature activation. For example, software products designed for devices with constrained resources may use a static binding time to avoid the performance overhead introduced by dynamic binding time activation. However, other devices can exploit binding time flexibility to support products with a dynamic binding time for some of their features. To implement this kind of flexibility in a modular way, we can define AspectJ-based idioms. Researchers have proposed Edicts, an idiom based on AspectJ and design patterns. In this article, we argue that this idiom leads to an increase in code duplication, scattering, tangling and size, which can hamper code reuse, maintenance and understanding. To mitigate such issues, this paper proposes three idioms\u00a0\u2026", "num_citations": "1\n", "authors": ["797"]}
{"title": "Using jason to develop refactoring agents\n", "abstract": " Refactoring is one of the main techniques used when maintaining and evolving the software. It works by changing the software in such way that improves its internal structure without changing its external behavioral. This paper focuses on issues around software refactoring, such as: (i) figure out where the software should be refactored, (ii) define which refactoring(s) should be applied, (iii) ensure that the external behavior of the software will be preserved after applying the refactoring, (iv) evaluate the gains and losses on the software quality resulting of the refactoring, (v) apply the refactoring, and, (vi) maintain the consistence between the refactored program code and other artifacts. Given the amount of issues to be considered, the refactoring activities when done in a manual way are an error-prone and extremely expensive. This paper provides an extension of the Jason platform to enable the development of\u00a0\u2026", "num_citations": "1\n", "authors": ["797"]}
{"title": "Emergent Feature Modularization\n", "abstract": " Desenvolvedores comumente introduzem erros em sistemas de software quando nao reconhecem depend\u00eancias entre m\u00f3dulos e features. Esse problema \u00e9 particularmente cr\u0131tico para fam\u0131lias de software, onde as features podem ser habilitadas e desabilitadas em tempo de compila\u00e7ao e execu\u00e7ao. Nesse contexto, features entrela\u00e7am-se umasas outras e compartilham elementos de c\u00f3digo como vari\u00e1veis e m\u00e9todos, levando a depend\u00eancias tais como quando uma feature atribui um valor a uma vari\u00e1vel que \u00e9 lida por outra feature. Devido a essas depend\u00eancias, desenvolvedores podem facilmente nao estar cientes sobre essas depend\u00eancias e, por exemplo, podem atribuir um novo valor a uma vari\u00e1vel correto para a feature sendo mantida mas incorreto para outra que usa tal vari\u00e1vel. Assim sendo, desenvolvedores podem manter uma feature e quebrar outras. Neste trabalho, apresentamos o conceito de Modulariza\u00e7ao Emergente de Features, que objetiva estabelecer, sob demanda, interfaces (contratos) entre features, evitando, assim, que desenvolvedores quebrem outras features durante uma tarefa de manuten\u00e7ao. Desse modo, as Interfaces Emergentes (Emergent Interfaces) podem capturar depend\u00eancias entre a feature sendo mantida e as outras, deixando os desenvolvedores cientes acerca de tais depend\u00eancias.Para capturar essas depend\u00eancias, utilizamos an\u00e1lises de fluxo de dados (dataflow analyses). Entretanto, as an\u00e1lises de fluxo de dados tradicionais nao conseguem lidar com fam\u0131lias de software, a menos que todos os poss\u0131veis sistemas da fam\u0131lia sejam gerados para que, posteriormente, a an\u00e1lise seja feita em\u00a0\u2026", "num_citations": "1\n", "authors": ["797"]}
{"title": "Assessing the Impact of Aspects on Design By Contract Effort: A Quantitative Study.\n", "abstract": " Although it is assumed that the implementation of design by contract is better modularized by means of aspectoriented (AO) programming, there is no empirical evidence on the effectiveness of AO for modularizing non-trivial design by contract code in well-understood modularity attributes. This paper reports a quantitative case study of the adequacy of aspects for modularizing design by contract concern. The study consisted of refactoring a real-life application so that the code responsible for implementing the contract enforcement strategies was moved to aspects. Our analysis was driven by fundamental modularity attributes, such as separation of concerns, coupling, and size. We have found that AO techniques improved separation of concerns between the design by contract code and base application code. However, contradicting the general intuition, the AO version of the system did not present significant gains regarding four classical size metrics we employed.", "num_citations": "1\n", "authors": ["797"]}
{"title": "Modularizing variabilities with CaesarJ collaboration interfaces\n", "abstract": " Software product lines (SPLs) aim at reducing the time to marketing of applications in a common domain [5]. To achieve that, products are generated by means of weaving common behavior, shared by all members of a SPL, with variant behavior that, in fact, implements the variability of each SPL member.Although several techniques have been used to implement variability in SPLs, an extended notion of interfaces for decoupling common and variant behavior during development is still a challenge. For instance, annotative style [3] for SPL development does not provide a clear separation between common and variant assets\u2014thus, it is not possible, using such a style, to develop both concerns in an independent way.", "num_citations": "1\n", "authors": ["797"]}
{"title": "Restructuring test variabilities in software product lines\n", "abstract": " Software Product Lines (SPLs) encompass a family of software-intensive systems developed from reusable assets. One issue during SPL maintenance is the decision about which mechanism should be used to restructure product line variabilities aiming at improving the modularity of the SPL artifacts. Due to the great variety of mechanisms, selecting the correct ones may be a difficult task. On the other hand, selecting the incorrect ones may produce negative effects on the cost to evolve the SPL. It is important to note that this problem exists not only at source code, but also in other artifacts such as requirements and tests. Therefore, in order to reduce the problem at the testing level, we propose in this work a decision model to help developers on the task of choosing mechanisms to restructure test variabilities in SPLs. In order to construct our decision model, we have analyzed some variabilities of real automated test cases developed by Motorola Industrial for testing mobile phone software. The test cases handle the phone\u2019s variabilities by using if-else statements. Therefore, given an if-else based variability, the model is able to suggest mechanisms which provide better modularity. We also developed a tool to support developers when restructuring these test variabilities by recommending mechanisms according to the decision model. Applying the decision model and the mechanisms suggested by it may improve the tests variabilities\u2019 modularity and remove bad smells such as cloned code. Furthermore, we illustrate in this work that when using the tool, the task of restructuring some variabilities may be realized faster and precisely.", "num_citations": "1\n", "authors": ["797"]}