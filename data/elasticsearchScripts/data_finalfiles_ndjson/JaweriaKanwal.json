{"title": "Bug prioritization to facilitate bug report triage\n", "abstract": " The large number of new bug reports received in bug repositories of software systems makes their management a challenging task. Handling these reports manually is time consuming, and often results in delaying the resolution of important bugs. To address this issue, a recommender may be developed which automatically prioritizes the new bug reports. In this paper, we propose and evaluate a classification based approach to build such a recommender. We use the Na\u00efve Bayes and Support Vector Machine (SVM) classifiers, and present a comparison to evaluate which classifier performs better in terms of accuracy. Since a bug report contains both categorical and text features, another evaluation we perform is to determine the combination of features that better determines the priority of a bug. To evaluate the bug priority recommender, we use precision and recall measures and also propose two new\u00a0\u2026", "num_citations": "89\n", "authors": ["1002"]}
{"title": "Managing open bug repositories through bug report prioritization using SVMs\n", "abstract": " Managing the incoming deluge of new bug reports received in bug repository of a large open source project is a challenging task. Handling these reports manually by developers, consume time and resources which results in delaying the resolution of crucial (important) bugs which need to be identified and resolved earlier to prevent major losses in a software project. In this paper, we present a machine learning approach to develop a bug priority recommender which automatically assigns an appropriate priority level to newly arrived bugs, so that they are resolved in order of importance and an important bug is not left untreated for a long time. Our approach is based on the classification technique, for which we use Support Vector Machines. Experimental evaluation of our recommender using precision and recall measures reveals the feasibility of our approach for automatic bug priority assignment.", "num_citations": "31\n", "authors": ["1002"]}
{"title": "Supervised Learning For Orphan Adoption Problem In Software Architecture Recovery\n", "abstract": " Maintenance of architectural documentation is a prime requirement for evolving software systems. New versions of software systems are launched after making the changes that take place in a software system over time. The orphan adoption problem, which deals with the issue of accommodation of newly introduced resources (orphan resources) in appropriate subsystems in successive versions of a software system, is a significant problem. The orphan adoption algorithm has been developed to address this problem. For evolving software systems, it would be useful to recover the architecture of subsequent versions of a software system by using existing architectural information. In this paper, we explore supervised learning techniques (classifiers) for recovering the architecture of subsequent versions of a software system by taking benefit of existing architectural information. We use three classifiers, ie, Bayesian classifier, k-Nearest Neighbor classifier and Neural Network for orphan adoption. We conduct experiments to compare the performance of the classifiers using various dependencies between entities in a software system. Our experiments highlight correspondence between the orphan adoption algorithm and the classifiers, and also reveal their strengths and weaknesses. To combine strengths of individual classifiers, we propose using a multiclassifier approach in which classifiers work cooperatively to improve classification accuracy. Experiments show that there is significant improvement in results when our proposed multiclassifier approach is used.", "num_citations": "5\n", "authors": ["1002"]}
{"title": "Structural clones: An evolution perspective\n", "abstract": " Structural clones are recurring patterns of simple code clones in software that represent a bigger picture of similarity in software (e.g. software design). Elevating the analysis of cloning to structural clone level helps in better clone management in terms of clone understanding, maintenance and evolution. In this paper, we propose a systematic approach to study structural clone evolution in software versions. We use our approach to analyze the evolutionary behavior of structural clones and also compare it with the evolution of simple clones. We performed experiments on different versions of three Java systems. Our analysis of structural clone evolution reveals interesting evolutionary characteristics of clones. For example, one finding is that simple clones are more frequently changed than structural clones whereas average lifetime of structural clones is less than that of simple clones. Study of clone evolution is helpful\u00a0\u2026", "num_citations": "4\n", "authors": ["1002"]}
{"title": "Evolutionary Perspective of Structural Clones in Software\n", "abstract": " Cloning in software represents similar program structures having its own benefits and drawbacks. Proper clone analysis is required to exploit the benefits of clones. A study of software clone evolution serves the purpose of understanding the maintenance implications of clones, which leads to their appropriate management. Structural clones (recurring patterns of simple clones) represent design level similarities in software. Evolutionary characteristics of clones can assess the relevance of those clones for software developers and maintainers. Although the evolution of simple clones has been thoroughly studied by researchers, the evolution of structural clones is still to be explored. In this paper, we study the evolution of structural clones by performing a longitudinal study on multiple versions of five Java systems. To perform a systematic study of the structural clone evolution, we define structural clones and their\u00a0\u2026", "num_citations": "2\n", "authors": ["1002"]}
{"title": "Network analysis of software change history for understanding software evolution\n", "abstract": " When software systems grow large and complex, understanding the dependencies in the system and making changes become difficult. History-based analysis of change dependencies (i.e. co-changing relation among entities) can facilitate system understanding, maintenance and prediction of evolutionary trends. In this paper we propose techniques to understand evolution in software change dependencies. Version repository data of Android platform is used as a case study and analysis of change dependencies is presented. Experimental analysis shows that the proposed approach provides an interesting view of software evolution in the context of change dependencies that reveals previously unknown facts about changing files in the system.", "num_citations": "2\n", "authors": ["1002"]}