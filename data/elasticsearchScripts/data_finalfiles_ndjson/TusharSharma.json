{"title": "A survey on software smells\n", "abstract": " ContextSmells in software systems impair software quality and make them hard to maintain and evolve. The software engineering community has explored various dimensions concerning smells and produced extensive research related to smells. The plethora of information poses challenges to the community to comprehend the state-of-the-art tools and techniques.ObjectiveWe aim to present the current knowledge related to software smells and identify challenges as well as opportunities in the current practices.MethodWe explore the definitions of smells, their causes as well as effects, and their detection mechanisms presented in the current literature. We studied 445 primary studies in detail, synthesized the information, and documented our observations.ResultsThe study reveals five possible defining characteristics of smells \u2014 indicator, poor solution, violates best-practices, impacts quality, and recurrence. We\u00a0\u2026", "num_citations": "127\n", "authors": ["803"]}
{"title": "Does your configuration code smell?\n", "abstract": " Infrastructure as Code (IaC) is the practice of specifying computing system configurations through code, and managing them through traditional software engineering methods. The wide adoption of configuration management and increasing size and complexity of the associated code, prompt for assessing, maintaining, and improving the configuration code's quality. In this context, traditional software engineering knowledge and best practices associated with code quality management can be leveraged to assess and manage configuration code quality. We propose a catalog of 13 implementation and 11 design configuration smells, where each smell violates recommended best practices for configuration code. We analyzed 4,621 Puppet repositories containing 8.9 million lines of code and detected the cataloged implementation and design configuration smells. Our analysis reveals that the design configuration\u00a0\u2026", "num_citations": "100\n", "authors": ["803"]}
{"title": "Designite - A Software Design Quality Assessment Tool\n", "abstract": " Poor design quality and huge technical debt are common issues perceived in real-life software projects. Design smells are indicators of poor design quality and the volume of design smells found could be treated as the design debt of the software system. The existing smell detection tools focus largely on implementation smells and do not reveal a comprehensive set of smells that arise at design level. In this paper, we present Designite-a software design quality assessment tool. It not only supports comprehensive design smells detection but also provides a detailed metrics analysis. Further, it offers various features to help identify issues contributing to design debt and improve the design quality of the analyzed software system.", "num_citations": "60\n", "authors": ["803"]}
{"title": "An empirical investigation on the relationship between design and architecture smells\n", "abstract": " Context: Architecture of a software system represents the key design decisions and therefore its quality plays an important role to keep the software maintainable. Code smells are indicators of quality issues in a software system and are classified based on their granularity, scope, and impact. Despite a plethora of existing work on smells, a detailed exploration of architecture smells, their characteristics, and their relationships with smells in other granularities is missing.   Objective: The paper aims to study architecture smells characteristics, investigate correlation, collocation, and causation relationships between architecture and design smells.   Method: We implement smell detection support for seven architecture smells. We mine 3 073 open-source repositories containing more than 118 million lines of C# code and empirically investigate the relationships between seven architecture and 19 design smells\u00a0\u2026", "num_citations": "20\n", "authors": ["803"]}
{"title": "Smelly Relations: Measuring and Understanding Database Schema Quality\n", "abstract": " Context: Databases are an integral element of enterprise applications. Similarly to code, database schemas are also prone to smells-best practice violations.Objective: We aim to explore database schema quality, associated characteristics and their relationships with other software artifacts.Method: We present a catalog of 13 database schema smells and elicit developers' perspective through a survey. We extract embedded sql statements and identify database schema smells by employing the DbDeo tool which we developed. We analyze 2925 production-quality systems (357 industrial and 2568 well-engineered open-source projects) and empirically study quality characteristics of their database schemas. In total, we analyze 629 million lines of code containing more than 393 thousand sql statements.Results: We find that the index abuse smell occurs most frequently in database code, that the use of an orm\u00a0\u2026", "num_citations": "19\n", "authors": ["803"]}
{"title": "Identifying extract-method refactoring candidates automatically\n", "abstract": " Refactoring becomes an essential activity in software development process especially for large and long life projects. Extract-method is one of the most frequently used refactorings to address code smells such as long and incohesive methods, and duplicated code. Automated means of identifying opportunities for refactoring can make the software development process faster and more efficient. In this paper, an abstraction for methods viz. Data and Structure Dependency (DSD) graph and an algorithm viz. longest edge removal algorithm to find extract-method refactoring candidates is proposed.", "num_citations": "19\n", "authors": ["803"]}
{"title": "On the Feasibility of Transfer-learning Code Smells using Deep Learning\n", "abstract": " Context: A substantial amount of work has been done to detect smells in source code using metrics-based and heuristics-based methods. Machine learning methods have been recently applied to detect source code smells; however, the current practices are considered far from mature. Objective: First, explore the feasibility of applying deep learning models to detect smells without extensive feature engineering, just by feeding the source code in tokenized form. Second, investigate the possibility of applying transfer-learning in the context of deep learning models for smell detection. Method: We use existing metric-based state-of-the-art methods for detecting three implementation smells and one design smell in C# code. Using these results as the annotated gold standard, we train smell detection models on three different deep learning architectures. These architectures use Convolution Neural Networks (CNNs) of one or two dimensions, or Recurrent Neural Networks (RNNs) as their principal hidden layers. For the first objective of our study, we perform training and evaluation on C# samples, whereas for the second objective, we train the models from C# code and evaluate the models over Java code samples. We perform the experiments with various combinations of hyper-parameters for each model. Results: We find it feasible to detect smells using deep learning methods. Our comparative experiments find that there is no clearly superior method between CNN-1D and CNN-2D. We also observe that performance of the deep learning models is smell-specific. Our transfer-learning experiments show that transfer-learning is definitely feasible for\u00a0\u2026", "num_citations": "10\n", "authors": ["803"]}
{"title": "Code smell detection by deep direct-learning and transfer-learning\n", "abstract": " Context:An excessive number of code smells make a software system hard to evolve and maintain. Machine learning methods, in addition to metric-based and heuristic-based methods, have been recently applied to detect code smells; however, current methods are considered far from mature.Objective:First, explore the feasibility of applying deep learning models to detect smells without extensive feature engineering. Second, investigate the possibility of applying transfer-learning in the context of detecting code smells.Methods:We train smell detection models based on Convolution Neural Networks and Recurrent Neural Networks as their principal hidden layers along with autoencoder models. For the first objective, we perform training and evaluation on C# samples, whereas for the second objective, we train the models from C# code and evaluate the models over Java code samples and vice-versa.Results:We\u00a0\u2026", "num_citations": "6\n", "authors": ["803"]}
{"title": "Designite: A customizable tool for smell mining in C# repositories\n", "abstract": " Code smells indicate the presence of quality issues in a software system. For a thorough large scale smell mining study, researchers require tools that not only allow them to detect a wide range of smells in a large number of repositories automatically but also offer mechanisms to customize the analysis. In this paper, we present a tool Designite that detects 19 design and 11 implementation smells for source code written in C# programming language. Designite provides a command line tool, in addition to an interactive user interface, to support automation required for a large scale mining study. Furthermore, the tool allows customization of quality analysis parameters, such as metric thresholds, to serve a wider range of users.", "num_citations": "6\n", "authors": ["803"]}
{"title": "Augur: incorporating hidden dependencies and variable granularity in change impact analysis\n", "abstract": " Software change impact analysis (CIA) methods enable developers to understand potential impacts of a code change so that the change can be executed confidently without affecting reliability of the software. However, existing CIA approaches do not support CIA for all source code granularities. Additionally, they lack support for inter-granular change impact queries and hidden dependencies. This paper introduces Augur, an automated static code analysis-based CIA approach that addresses these shortcomings. Augur infers and maintains semantic and environment dependencies along with data and control dependencies between source code entities across granularities. Additionally, Augur uses Change Impact Query Language, a novel query language for impact analysis proposed in this paper, to support inter-granular CIA queries with batch querying feature. Augur has been realized as a Visual Studio\u00a0\u2026", "num_citations": "6\n", "authors": ["803"]}
{"title": "Quality model driven dynamic analysis\n", "abstract": " Release managers often face a dilemma about the quality of software under delivery before a release. The presence of run-time errors such as memory leaks, buffer overflows, and deadlocks affects quality attributes such as efficiency, security, and reliability. Such errors are detected using dynamic analysis methods in practice. However, the dynamic analysis methods employed in practice are by and large ad hoc. It is essential to use dynamic analysis focusing on finding the right set of run-time errors in a software component that have the maximum impact on quality. There exists a need to identify quality attributes such as reliability, efficiency, and security that are important for a software component, or, a system. In this paper, a quality model driven dynamic analysis methodology is proposed. Various run-time errors that can arise during the execution of programs written in a language such as C++ are mapped to the\u00a0\u2026", "num_citations": "6\n", "authors": ["803"]}
{"title": "Inferring design patterns using the ReP graph.\n", "abstract": " Periodic refactoring of a large source code often becomes a necessity especially for long-lived projects. In order to increase maintainability and extensibility of such projects, design pattern based refactoring can be seen as an emerging alternative. Manual inspection of source code to find candidate spots where patterns can be introduced is time consuming. Therefore automated tools can help in identifying candidate spots where patterns can be introduced. The level of source code abstraction plays an important role for building such tools. We propose a new abstraction for object oriented source code that is named as \u201cRefactoring Pattern (ReP) Graph\u201d to realize an effective design pattern based refactoring tool. The ReP graph abstracts the source code information thereby making the process of design pattern inference easier. The proposed tool identifies candidate spots in a given source code to introduce design patterns.", "num_citations": "6\n", "authors": ["803"]}
{"title": "Quantifying quality of software design to measure the impact of refactoring\n", "abstract": " Software design plays a vital role in a software system. A flexible, maintainable, extensible, and re-usable software design enables easier integration of new requirements. In the current era of software development, refactoring is used periodically to fine-tune a software design. Refactoring limits technical debt and improves overall quality of a software design. However, providing a quantitative measure to estimate the impact of a refactoring exercise on a software design is a non-trivial challenge. In this paper, we present a method to estimate the quality (extendibility, and flexibility aspects) of a software design. The method proposes an index namely Software Design Quality Index (SDQI) to estimate the quality of a software design. The index can be employed to measure the impact of a refactoring exercise on software design. Moreover, the method can be used to benchmark and compare software design quality of\u00a0\u2026", "num_citations": "4\n", "authors": ["803"]}
{"title": "Extending Maintainability Analysis Beyond Code Smells\n", "abstract": " Code smells indicate the presence of quality problems impacting many facets of software quality such as maintainability, reliability, and testability. The presence of an excessive number of smells in a software system makes it hard to maintain and evolve.Our first aim in this thesis is to understand the characteristics of code smells, such as their occurrence frequency, and relationships such as correlation and collocation among smells arising at different granularities. We aim to perform an exploratory study to investigate the feasibility of detecting smells using deep learning methods without carrying out extensive feature engineering. We would also like to explore whether transfer-learning can be employed in the smell detection context. Apart from the production source code, other sub-domains of software such as configuration code in Infrastructure as Code (IaC) paradigm and database code are also prone to maintainability issues. Our next goal is to propose a method to identify quality issues in configuration code and carry out a maintainability analysis.We perform a large-scale empirical study to analyze production code written in C# from maintainability perspective. We mine seven architecture, 19 design, 11 implementation smells from a large set of 3,209 open-source repositories containing more than 83 million lines of code. Our exploration with deep learning techniques establishes that deep learning methods can be used for smell detection though the performance of individual models varies significantly. We extend the maintainability analysis to configuration code. We analyze 4,621 Puppet repositories containing 142,662 Puppet files and\u00a0\u2026", "num_citations": "3\n", "authors": ["803"]}
{"title": "ESA: the exclusive-similarity algorithm for identifying extract-class refactoring candidates automatically\n", "abstract": " Refactoring has become an essential part of software development process especially for large and long lasting projects. Extract-class is one of the vital refactorings that is used to improve cohesion of a class by splitting large in-cohesive classes into more cohesive ones. Providing automated means of identifying opportunities for extract-class refactoring could make the software maintenance efficient. In this paper, a novel algorithm viz. ESA (\" Exclusive-Similarity\" Algorithm) is proposed to identify extract-class refactoring candidates automatically. The algorithm proposes new metrics viz. Exclusive-Similarity metric (ESM), Cohesion among Method-Clusters,(CMC) and Method-Similarity with Attribute-Clusters (MSAC). The proposed algorithm has been realized into a tool as an add-in to Visual Studio and the tool is exercised with 3 open-source projects to demonstrate applicability.", "num_citations": "2\n", "authors": ["803"]}
{"title": "System and method for refactoring a block of software\n", "abstract": " A system for refactoring a block of software may include an analyzer for receiving a set of workflows via a user interface and configured to analyze each of the workflows one at a time to determine a set of refactoring opportunity, the user interface configured to transfer the set of workflows from a user to the analyzer and to transfer a set of refactoring opportunity from the analyzer to said user after said analysis of said set of workflows. The system also includes set of refactoring opportunity into a step-wise arrangement of implementation of said set of refactoring opportunity on said block of software, an implementation device for implementing said set of refactoring opportunity on said block of software to produce a refactored block of software and over a design associated to said block of software to produce a refactored design associated to said refactored block of software.", "num_citations": "2\n", "authors": ["803"]}
{"title": "Architecture Smells and Pareto Principle: A Preliminary Empirical Exploration\n", "abstract": " Architecture smells represent violations of best practices recommended for software architecture that adversely impact various quality attributes of a software system. Though architecture quality is considered very important by the software engineering community, architecture refactoring, given involved high risk and effort, is often avoided by software development teams. In this paper, we empirically explore the properties of architecture smells in the context of the Pareto principle. We investigate the degree of adherence of architecture smell occurrences to the Pareto principle and explore the influence of other related factors i.e., programming language and size of the repositories. To this end, we analyzed 750 Java and 361 C# repositories containing more than 50 million lines of code to detect seven kinds of architecture smells. We found that approximately 45% of the Java repositories follow the Pareto principle\u00a0\u2026", "num_citations": "1\n", "authors": ["803"]}
{"title": "QScored: A Large Dataset of Code Smells and Quality Metrics\n", "abstract": " Code quality aspects such as code smells and code quality metrics are widely used in exploratory and empirical software engineering research. In such studies, researchers spend a substantial amount of time and effort to not only select the appropriate subject systems but also to analyze them to collect the required code quality information. In this paper, we present QScored dataset; the dataset contains code quality information of more than 86 thousand C# and Java GitHub repositories containing more than 1.1 billion lines of code. The code quality information contains seven kinds of detected architecture smells, 20 kinds of design smells, eleven kinds of implementation smells, and 27 commonly used code quality metrics computed at project, package, class, and method levels. Availability of the dataset will facilitate empirical studies involving code quality aspects by making the information readily available for a large number of active GitHub repositories.", "num_citations": "1\n", "authors": ["803"]}
{"title": "Oracle Certified Professional Java SE 7 Programmer Exams 1Z0-804 and 1Z0-805: A Comprehensive OCPJP 7 Certification Guide\n", "abstract": " Oracle Certified Professional Java SE 7 Programmer Exams 1Z0-804 and 1Z0-805 is a concise, comprehensive, step-by-step, and one-stop guide for the Oracle Certified Professional Java SE 7 Programmer Exam. The first two chapters set the stage for exam preparation and let the reader get started quickly. The first chapter answers frequently asked questions about the OCPJP exam. This book assumes that the reader is already familiar with Java fundamentals which is in line with the prerequisite of having a OCAJP certification. The book sports considerable supportive material to help the reader in effective exam preparation in the form of appendices: 2 mock tests to give the reader a sense of a real-exam. An instant refresher summarizing the most important concepts (with tips on answering questions) to revise just before the exam. This book will be a delectable read for any OCPJP aspirant because of its simple language, example driven approach, and easy-to-read style. Further, given its 100% focus on the exam and helpful supportive material, this book is clearly an attractive buy to OCPJP aspirants worldwide.", "num_citations": "1\n", "authors": ["803"]}
{"title": "Revisiting LCOM\n", "abstract": " ResultsThe following table shows computed LCOM for all three cases using the above described methods.", "num_citations": "1\n", "authors": ["803"]}