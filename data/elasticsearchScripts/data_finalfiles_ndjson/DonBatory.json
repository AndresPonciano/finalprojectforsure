{"title": "Feature models, grammars, and propositional formulas\n", "abstract": " Feature models are used to specify members of a product-line. Despite years of progress, contemporary tools often provide limited support for feature constraints and offer little or no support for debugging feature models. We integrate prior results to connect feature models, grammars, and propositional formulas. This connection allows arbitrary propositional constraints to be defined among features and enables off-the-shelf satisfiability solvers to debug feature models. We also show how our ideas can generalize recent results on the staged configuration of feature models.", "num_citations": "1612\n", "authors": ["788"]}
{"title": "Scaling step-wise refinement\n", "abstract": " Step-wise refinement is a powerful paradigm for developing a complex program from a simple program by adding features incrementally. We present the AHEAD (algebraic hierarchical equations for application design) model that shows how step-wise refinement scales to synthesize multiple programs and multiple noncode representations. AHEAD shows that software can have an elegant, hierarchical mathematical structure that is expressible as nested sets of equations. We review a tool set that supports AHEAD. As a demonstration of its viability, we have bootstrapped AHEAD tools from equational specifications, refining Java and nonJava artifacts automatically; a task that was accomplished only by ad hoc means previously.", "num_citations": "1250\n", "authors": ["788"]}
{"title": "The design and implementation of hierarchical software systems with reusable components\n", "abstract": " We present a domain-independent model of hierarchical software system design and construction that is based on interchangeable software components and large-scale reuse. The model unifies the conceptualizations of two independent projects, Genesis and Avoca, that are successful examples of software component/building-block technologies and domain modeling. Building-block technologies exploit large-scale reuse, rely on open architecture software, and elevate the granularity of programming to the subsystem level. Domain modeling formalizes the similarities and differences among systems of a domain. We believe our model is a blueprint for achieving software component technologies in many domains.", "num_citations": "878\n", "authors": ["788"]}
{"title": "Mixin layers: an object-oriented implementation technique for refinements and collaboration-based designs\n", "abstract": " A \"refinement\" is a functionality addition to a software project that can affect multiple dispersed implementation entities (functions, classes, etc.). In this paper, we examine large-scale refinements in terms of a fundamental object-oriented technique called collaboration-based design. We explain how collaborations can be expressed in existing programming languages or can be supported with new language constructs (which we have implemented as extensions to the Java language). We present a specific expression of large-scale refinements called mixin layers, and demonstrate how it overcomes the scalability difficulties that plagued prior work. We also show how we used mixin layers as the primary implementation technique for building an extensible Java compiler, JTS.", "num_citations": "423\n", "authors": ["788"]}
{"title": "Modeling concepts for VLSI CAD objects\n", "abstract": " VLSI CAD applications deal with design objects that have an interface description and an implementation description. Versions of design objects have a common interface but differ in their implementations. A molecular object is a modeling construct which enables a database entity to be represented by two sets of heterogeneous records, one set describes the object's interface and the other describes its implementation. Thus a reasonable starting point for modeling design objects is to begin with the concept of molecular objects. In this paper, we identify modeling concepts that are fundamental to capturing the semantics of VLSI CAD design objects and versions in terms of molecular objects. A provisional set of user operations on design objects, consistent with these modeling concepts, is also defined. The modeling framework that we present has been found useful for investigating physical storage techniques and\u00a0\u2026", "num_citations": "411\n", "authors": ["788"]}
{"title": "Implementing layered designs with mixin layers\n", "abstract": " Mixin layers are a technique for implementing layered object-oriented designs (e.g., collaboration-based designs). Mixin layers are similar to abstract subclasses (mixin classes) but scaled to a multiple-class granularity. We describe mixin layers from a programming language viewpoint, discuss checking the consistency of a mixin layer composition, and analyze the language support issues involved.", "num_citations": "389\n", "authors": ["788"]}
{"title": "Evolving object-oriented designs with refactorings\n", "abstract": " Refactorings are behavior-preserving program transformations that automate design evolution in object-oriented applications. Three kinds of design evolution are: schema transformations, design pattern microarchitectures, and the hot-spot-driven-approach. This research shows that all three are automatable with refactorings. A comprehensive list of refactorings for design evolution is provided and an analysis of supported schema transformations, design patterns, and hot-spot meta patterns is presented. Further, we evaluate whether refactoring technology can be transferred to the mainstream by restructuring non-trivial C++ applications. The applications that we examine were evolved manually by software engineers. We show that an equivalent evolution could be reproduced significantly faster and cheaper by applying a handful of general-purpose refactorings. In one application, over 14K lines of code\u00a0\u2026", "num_citations": "347\n", "authors": ["788"]}
{"title": "GENESIS: An extensible database management system\n", "abstract": " A novel yet simple technology is presented that enables customized database management systems (DBMSs) to be developed rapidly. The authors are designing an extensible DBMS, called GENESIS, which is based on this theory. They give a detailed description of their first operational prototype. DBMS software components in GENESIS can be written in a few months. When all components for a target DBMS are present, writing the architecture specification of the DBMS and reconfiguring GENESIS takes a few hours and can be accomplished with negligible cost.< >", "num_citations": "332\n", "authors": ["788"]}
{"title": "Safe composition of product lines\n", "abstract": " Programs of a software product line can be synthesized by composing modules that implement features. Besides high-level domain constraints that govern the compatibility of features, there are also low-level implementation constraints: a feature module can reference elements that are defined in other feature modules. Safe composition is the guarantee that all programs in a product line are type safe: ie, absent of references to undefined elements (such as classes, methods, and variables). We show how safe composition properties can be verified for AHEAD product lines using feature models and SAT solvers.", "num_citations": "306\n", "authors": ["788"]}
{"title": "Feature oriented refactoring of legacy applications\n", "abstract": " Feature oriented refactoring (FOR) is the process of decomposinga program into features, where a feature is an increment in programfunctionality. We develop a theory of FOR that relates code refac-toring to algebraic factoring. Our theory explains relationshipsbetween features and their implementing modules, and why fea-tures in different programs of a product-line can have differentimplementations. We describe a tool and refactoring methodologybased on our theory, and present a validating case study.", "num_citations": "300\n", "authors": ["788"]}
{"title": "JTS: Tools for implementing domain-specific languages\n", "abstract": " The Jakarta Tool Suite (JTS) aims to reduce substantially the cost of generator development by providing domain-independent tools for creating domain-specific languages and component-based generators called GenVoca generators. JTS is a set of precompiler-compiler tools for extending industrial programming languages (e.g., Java) with domain-specific constructs. JTS is itself a GenVoca generator where precompilers for JTS-extended languages are constructed from components.", "num_citations": "281\n", "authors": ["788"]}
{"title": "Composition validation and subjectivity in GenVoca generators\n", "abstract": " GenVoca generators synthesize software systems by composing components from reuse libraries. GenVoca components are designed to export and import standardized interfaces, and thus be plug-compatible, interchangeable, and interoperable with other components. We examine two different but important issues in software system synthesis. First, not all syntactically correct compositions of components are semantically correct. We present simple, efficient, and domain-independent algorithms for validating compositions of GenVoca components. Second, components that export and import immutable interfaces are too restrictive for software system synthesis. We show that the interfaces and bodies of GenVoca components are subjective, i.e., they mutate and enlarge upon instantiation. This mutability enables software systems with customized interfaces to be composed from components with \"standardized\"\u00a0\u2026", "num_citations": "266\n", "authors": ["788"]}
{"title": "TSQL2 language specification\n", "abstract": " This docuinent specifies a temporal extension to the SQL-92 language standard. The language is designated TSQLZ. The document is organized as follows. The next section indicates the starting point of the design, the SQL-92 language. Section 4 lists the desired features on which the TSQL2 Language Design Committee reached consensus. Section 5 presents the major concepts underlying TSQL2. Compatibility with SQL-92 is the topic of Section 6. Section 7 briefly discusses how the language can be implemented. Subsequent sections specify the syntax of the language extensions.", "num_citations": "257\n", "authors": ["788"]}
{"title": "Feature-oriented programming and the AHEAD tool suite\n", "abstract": " Feature oriented programming (FOP) is an emerging paradigm for application synthesis, analysis, and optimization. A target application is specified declaratively as a set of features, like many consumer products (e.g., personal computers, automobiles). FOP technology translates such declarative specifications into efficient programs.", "num_citations": "249\n", "authors": ["788"]}