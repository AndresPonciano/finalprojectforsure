{"title": "Symbolic path cost analysis for side-channel detection\n", "abstract": " Side-channels in software are an increasingly significant threat to the confidentiality of private user information, and the static detection of such vulnerabilities is a key challenge in secure software development. In this paper, we introduce a new technique for scalable detection of side-channels in software. Given a program and a cost model for a side-channel (such as time or memory usage), we decompose the control flow graph of the program into nested branch and loop components, and compositionally assign a symbolic cost expression to each component. Symbolic cost expressions provide an over-approximation of all possible observable cost values that components can generate. Queries to a satisfiability solver on the difference between possible cost values of a component allow us to detect the presence of imbalanced paths (with respect to observable cost) through the control flow graph. When combined\u00a0\u2026", "num_citations": "27\n", "authors": ["2122"]}
{"title": "Variable dependency analysis of a computer program\n", "abstract": " To keep pace with the advancement of technology, software products are overlooking the chances of soft errors in the program. Program analysis to check program execution flow is an effective way to detect soft errors. High level language computer program execution can be analyzed on the basis of the dependence of the variables used in the program. This paper illustrates a novel method to analyze variable dependencies of program based on automated generation of dependence graph. Dependence graph depicts the connectivity between the program variables where variables works as the vertices and dependence between variables perform as edges. The automated generated dependence graph also discovers the critical variables of a program and these critical variables perform as the key to detect the sequential execution of a program outperforming the existing methods of program analysis.", "num_citations": "9\n", "authors": ["2122"]}
{"title": "Jvm fuzzing for jit-induced side-channel detection\n", "abstract": " Timing side channels arise in software when a program's execution time can be correlated with security-sensitive program input. Recent results on software side-channel detection focus on analysis of program's source code. However, runtime behavior, in particular optimizations introduced during just-in-time (JIT) compilation, can impact or even introduce timing side channels in programs. In this paper, we present a technique for automatically detecting such JIT-induced timing side channels in Java programs. We first introduce patterns to detect partitions of secret input potentially separable by side channels. Then we present an automated approach for exploring behaviors of the Java Virtual Machine (JVM) to identify states where timing channels separating these partitions arise. We evaluate our technique on three datasets used in recent work on side-channel detection. We find that many code variants labeled\"\u00a0\u2026", "num_citations": "7\n", "authors": ["2122"]}
{"title": "Incremental Attack Synthesis\n", "abstract": " Information leakage is a signi cant problem in modern software systems. Information leaks due to side channels are especially hard to detect and analyze. In recent years, techniques have been developed for automated synthesis of adaptive side-channel attacks that recover secret values by iteratively generating inputs to reveal partial information about the secret based on the sidechannel observations. Prominent approaches of attack synthesis use symbolic execution, model counting, and meta-heuristics to maximize information gain. These approaches could bene t by reusing results from prior steps in each step. In this paper, we present an incremental approach to attack synthesis that reuses model counting results from prior iterations in each attack step to improve efficiency. Experimental evaluation demonstrates that our approach drastically improves performance, reducing the attack synthesis time by an order\u00a0\u2026", "num_citations": "5\n", "authors": ["2122"]}
{"title": "Subformula caching for model counting and quantitative program analysis\n", "abstract": " Quantitative program analysis is an emerging area with applications to software reliability, quantitative information flow, side-channel detection and attack synthesis. Most quantitative program analysis techniques rely on model counting constraint solvers, which are typically the bottleneck for scalability. Although the effectiveness of formula caching in expediting expensive model-counting queries has been demonstrated in prior work, our key insight is that many subformulas are shared across non-identical constraints generated during program analyses. This has not been utilized by prior formula caching approaches. In this paper we present a subformula caching framework and integrate it into a model counting constraint solver. We experimentally evaluate its effectiveness under three quantitative program analysis scenarios: 1) model counting constraints generated by symbolic execution, 2) reliability analysis\u00a0\u2026", "num_citations": "5\n", "authors": ["2122"]}
{"title": "Synthesizing fault tolerant safety critical systems\n", "abstract": " To keep pace with today's nano-technology, safety critical embedded systems are becoming less tolerant to errors. Research into techniques to cope with errors in these systems has mostly focused on transformational approach, replication of hardware devices, parallel program design, component based design and/or information redundancy. It would be better to tackle the issue early in the design process that a safety critical system never fails to satisfy its strict dependability requirements. A novel method is outlined in this paper that proposes an efficient approach to synthesize safety critical systems. The proposed method outperforms dominant existing work by introducing the technique of run time detection and completion of proper execution of the system in presence of faults.", "num_citations": "3\n", "authors": ["2122"]}