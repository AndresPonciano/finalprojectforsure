{"title": "Generative software visualization: Automatic generation of user-specific visualizations\n", "abstract": " Software visualization provides tools and methods to create role-and task-specific views on software systems to enhance the development and maintenance process. However, the effort to produce customized and optimized visualizations is still high. Hence, we present our approach of combining the generative and the model driven paradigm and applying it to the field of software visualization. Based on this approach we want to implement a generator that allows to automatically generate software visualizations in 2D, 2.5 D, 3D, or for virtual reality environments according to user-specific requirements.", "num_citations": "15\n", "authors": ["954"]}
{"title": "Towards an open source stack to create a unified data source for software analysis and visualization\n", "abstract": " The beginning of every software analysis and visualization process is data acquisition. However, there are various sources of data about a software system. The methods used to extract the relevant data are as diverse as the sources are. Furthermore, integration and storage of heterogeneous data from different software artifacts to form a unified data source are very challenging. In this paper, we introduce an extensible open source stack to take the first step to solve these challenges. We show its feasibility by analyzing and visualizing JUnit and provide answers regarding the schema, selection, and implementation of software artifacts' data.", "num_citations": "13\n", "authors": ["954"]}
{"title": "Past, present, and future of 3d software visualization-a systematic literature analysis\n", "abstract": " The ongoing 2D vs. 3D research debate from information visualization also affects software visualization. There are many 2D, 3D, and combinations of 2D and 3D visualizations for software representing its structure, behavior, or evolution. This study contributes findings to this debate and presents the results of analyzing the applications of 3D in software visualization with the objectives to outline the state-of-the-art, to reveal trends, and to identify research gaps. The analysis combined a systematic mapping study to get an overview and a systematic literature review to gain deeper insights. The relevant papers were identified by three different search strategies (manual browsing, keyword, and backward search). Starting with a set of 4386 publications from the fields of information and software visualization 155 relevant papers dealing with 2D & 3D or 3D software visualizations were identified. These papers were\u00a0\u2026", "num_citations": "12\n", "authors": ["954"]}
{"title": "A structured approach for conducting a series of controlled experiments in software visualization\n", "abstract": " In the field of software visualization controlled experiments are an important instrument to investigate the specific reasons, why some software visualizations excel the expectations on providing insights and ease task solving while others fail doing so. Despite this, controlled experiments in software visualization are rare. A reason for this is the fact that performing such evaluations in general, and particularly performing them in a way that minimizes the threats to validity, is hard to accomplish. In this paper, we present a structured approach on how to conduct a series of controlled experiments in order to give empirical evidence for advantages and disadvantages of software visualizations in general and of 2D vs. 3D software visualizations in particular.", "num_citations": "11\n", "authors": ["954"]}
{"title": "A Graph-Based Feature Location Approach Using Set Theory\n", "abstract": " The ArgoUML SPL benchmark addresses feature location in Software Product Lines (SPLs), where single features as well as feature combinations and feature negations have to be identified. We present a solution for this challenge using a graph-based approach and set theory. The results are promising. Set theory allows to exactly define which parts of feature locations can be computed and which precision and which recall can be achieved. This has to be complemented by a reliable identification of feature-dependent class and method traces as well as refinements. The application of our solution to one scenario of the benchmark supports this claim.", "num_citations": "6\n", "authors": ["954"]}
{"title": "How to master challenges in experimental evaluation of 2D versus 3D software visualizations\n", "abstract": " Software visualizations in 3D and virtual reality are an interesting and debated research topic in academia. However, the benefits and drawbacks of 3D software visualizations in immersive environments compared to its 2D counterparts are not very well understood due to the lack of empirical evaluations. The challenge is to plan valid experiments with analogous 2D and 3D visualization techniques, while avoiding various influence factors and minimizing the threats to validity. In this paper, we present an experiment as part of a series using a structured approach to meet these challenges.", "num_citations": "5\n", "authors": ["954"]}
{"title": "Exposing Proprietary Virtual Reality Software to Nontraditional Displays\n", "abstract": " Nontraditional displays just started their triumph. In contrast to traditional displays, which are plane and rectangular, they do not only differ in design and architecture; they also implicate different semantics and pragmatics in the rendering pipeline. We strive for a generic solution that couples legacy applications with nontraditional displays. In this paper, we present an architecture and a respective experiment, which exposes a proprietary virtual reality software to a 360 degree virtual environment. Therefore we introduce a rigorous master-slave design. The proposed architecture requires discussion of the following details: how to access a proprietary application\u2019s OpenGL stream; how to transmit the OpenGL stream efficiently in a clustered rendering setup; how to process the OpenGL stream for adaption to nontraditional display semantics; and how to deal with the arising code complexity, withal. Our design decisions are highly interdependent. The presented architecture overcomes limitations, which were implied by client-server design in earlier work. The proposed rigorous master-slave design is totally transparent to the client software, and reduces interdependencies between rendering software and rendering clusters. Thus, it inherently reduces network round trips and promotes the use of scalable multicast. Our architecture is tested in a reproducible experiment, which provides a qualitative proof of concept.", "num_citations": "3\n", "authors": ["954"]}
{"title": "Graph-Based Performance Analysis at System- and Application-Level\n", "abstract": " The Kieker plugin for jQAssistant transforms monitored log data into graphs to support software engineers with performance analysis. In this paper, we describe how we have extended and improved this plugin to support performance analysis at system-and application-level and how we have evaluated its correctness and scalability using data from recent experiments. This is a first step to replicate complete experiments in the field of performance analysis using graphs.", "num_citations": "1\n", "authors": ["954"]}