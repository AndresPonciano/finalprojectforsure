{"title": "Engineering security requirements.\n", "abstract": " Most requirements engineers are poorly trained to elicit, analyze, and specify security requirements, often confusing them with the architectural security mechanisms that are traditionally used to fulfill them. They thus end up specifying architecture and design constraints rather than true security requirements. This article defines the different types of security requirements and provides associated examples and guildlines with the intent of enabling requirements engineers to adequately specify security requirements without unnecessarily constraining the security and architecture teams from using the most appropriate security mechanisms for the job.", "num_citations": "334\n", "authors": ["1480"]}
{"title": "The OPEN process framework: An introduction\n", "abstract": " \"[The authors] have done an excellent job of bringing forth the power and the flexibility of this most useful framework in an easy to read and understand introduction. Although it has been written to be an introductory text in OPF, I found [it] also readily useable as a handbook for initial process definition, an accessible treatment of important issues in software process design, and a textbook in OPF.\" Houman Younessi Associate Professor of Computer Science, Rensselaer Polytechnic Institute The OPEN Process Framework provides a template for generating flexible, yet disciplined, processes for developing high-quality software and system applications within a predictable schedule and budget. Using this framework as a starting point, you can create and tailor a process to meet the specific needs of the project.", "num_citations": "330\n", "authors": ["1480"]}
{"title": "Security use cases\n", "abstract": " Although use cases are a popular modeling approach for engineering functional requirements, they are often misused when it comes to engineering security requirements because requirements engineers unnecessarily specify security architectural mechanisms instead of security requirements. After discussing the relationships between misuse cases, security use cases, and security mechanisms, this column provides examples and guidelines for properly specifying essential (ie, requirements-level) security use cases.", "num_citations": "305\n", "authors": ["1480"]}
{"title": "Specifying reusable security requirements.\n", "abstract": " Unlike typical functional requirements, security requirements can potentially be highly reusable, especially if specified as instances of reusable templates. In this column, I will discuss the concepts underlying security engineering including its quality subfactors. I will then address the issue of security requirements and how they differ from the architectural mechanisms that will fulfill them. Then, I will discuss the value of reusable parameterized templates for specifying security requirements and provide an example of such a template and its associated usage. Finally, I will outline an asset-based riskdriven analysis approach for determining the appropriate actual parameters to use when reusing such parameterized templates to specify security requirements.", "num_citations": "274\n", "authors": ["1480"]}
{"title": "Prioritizing requirements.\n", "abstract": " In this column, I address the often difficult task of prioritizing requirements so that the highest priority requirements can be implemented first as part of the scheduling of an incremental, iterative, and time-boxed development cycle. After defining the meaning of the term \u201cpriority\u201d, the purpose and benefits of requirements prioritization are listed. This is followed by a brief discussion of the challenges and risks that a requirements team must face when prioritizing requirements. Then, various techniques for prioritizing requirements are identified, and finally a set of recommendations (including a recommended prioritization process) are made.", "num_citations": "233\n", "authors": ["1480"]}
{"title": "Common concepts underlying safety security and survivability engineering\n", "abstract": " This technical note presents a consistent set of information models that identify and define the foundational concepts underlying safety, security, and survivability engineering. In addition, it shows how quality requirements are related to quality factors, subfactors, criteria, and metrics, and it emphasizes the similarities between the concepts that underlie safety, security, and survivability engineering. The information models presented in this technical note provide a standard terminology and set of concepts that explain the similarities between the asset-based, risk-driven methods for identifying and analyzing safety, security, and survivability requirements as well as a rationale for the similarity in architectural mechanisms that are commonly used to fulfill these requirements.Descriptors:", "num_citations": "223\n", "authors": ["1480"]}
{"title": "OPEN modeling language (OML) reference manual\n", "abstract": " OPEN (Object-oriented Process, Environment and Notation) is an international de facto standard object-oriented development method developed and maintained by the OPEN Consortium. OPEN consists of the OPEN Modeling Language (OML) as well as process, metrics, etc. This book specifies OML, a small but vital component of the complete OPEN method. It uses diagrams, tables, Web references and text to present the syntax, semantics and rationale behind OML. It documents version 1.0 of OML so that object-oriented modelers can learn and use it, and upperCASE vendors can support it.", "num_citations": "220\n", "authors": ["1480"]}
{"title": "Object-oriented requirements analysis and logical design: a software engineering approach\n", "abstract": " Object-oriented Requirements Analysis And Logical Design: A Software Engineering Approach Digital Text & eBook Resources Don Page 1 Object-oriented Requirements Analysis And Logical Design: A Software Engineering Approach Donald G. Firesmith Donald Firesmith - Wikipedia, the free encyclopedia Publication \u00bb Object-oriented Requirements, Analysis and Logical Design: a Software Engineering Approach. Object-Oriented Requirements Analysis and Logical Design Software Engineering: A Practitioner's Approach - Google Books Result Object Oriented Requirements Analysis and Logical Design SKU. This paper reviews requirements analysis paradigms from the 1980s through 2008. We conclude by examining more formal paradigms object-oriented, goal Balzer investigated a software paradigm based on automation, which would. 1983: 1 conceptual design 2 logical design 3 validation and 4 formal \u2026", "num_citations": "171\n", "authors": ["1480"]}
{"title": "Common Requirements Problems, Their Negative Consequences, and the Industry Best Practices to Help Solve Them.\n", "abstract": " In this column, I summarize the 12 worst of the most common requirements engineering problems I have observed over many years working on and with real projects as a requirements engineer, consultant, trainer, and evaluator. I also list the negative consequences of these problems, and most importantly suggest some industry best practices that can help you avoid these problems, or at least fix them once they have raised their ugly heads. Although there is nothing really new here, these problems are well worth revisiting because they are still far too common, probably because the associated industry best practices are still far from being widely put into practice.", "num_citations": "144\n", "authors": ["1480"]}
{"title": "Specifying good requirements\n", "abstract": " Many of the characteristics of properly specified requirements have been well known for many years, at least among professional requirements engineers. Yet most requirements specifications seen today in industry still include many poor-quality requirements. Far too many requirements are ambiguous, incomplete, inconsistent, incorrect, infeasible, unusable, and/or not verifiable (eg, not testable). To combat this sad state of affairs, this column provides a questionnaire that can be used when specifying and technically evaluating requirements.", "num_citations": "130\n", "authors": ["1480"]}
{"title": "A reuse-based approach to determining security requirements\n", "abstract": " The paper proposes a reuse-based approach to determining security requirements. Development for reuse involves identifying security threats and associated security requirements during application development and abstracting them into a repository of generic threats and requirements. Development with reuse involves identifying security assets, setting security goals for each asset, identifying threats to each goal, analysing risks and determining security requirements, based on reuse of generic threats and requirements from the repository. Advantages of the proposed approach include building and managing security knowledge through the shared repository, assuring the quality of security work by reuse, avoiding over-specification and premature design decisions by reuse at the generic level and focussing on security early in the requirements stage of development.", "num_citations": "117\n", "authors": ["1480"]}
{"title": "Engineering safety requirements, safety constraints, and safety-critical requirements\n", "abstract": " As software-intensive systems become more pervasive, more and more safety-critical systems are being developed. In this column, I will use the concept of a quality model to define safety as a quality factor. Thus, safety (like security and survivability) is a kind of defensibility, which is a kind of dependability, which is a kind of quality. Next, I discuss the structure of quality requirements and show how safety requirements can be engineered based on safety\u2019s numerous quality subfactors. Then, I define and discuss safety constraints (ie, mandated safeguards) and safety-critical requirements (ie, functional, data, and interface requirements that can cause accidents if not implemented correctly). Finally, I pose a set of questions regarding the engineering of these three kinds of safety-related requirements for future research and experience to answer.", "num_citations": "79\n", "authors": ["1480"]}
{"title": "A taxonomy of security-related requirements\n", "abstract": " Safety and security are closely related subtypes of defensibility, another quality factor in a quality model. The close similarity between these two quality factors implies that a taxonomy of safety-related requirements is a good place to begin when developing an analogous taxonomy of security-related requirements. The resulting taxonomy consists of pure security requirements specifying minimum acceptable amounts of security, security-significant requirements which are non-security requirements with important security ramifications, security system requirements specifying requirements for security architectural components, and security constraints.", "num_citations": "74\n", "authors": ["1480"]}
{"title": "Are your requirements complete?\n", "abstract": " Good requirements have several useful properties, such as being consistent, necessary, and unambiguous. Another essential characteristic that is almost always listed is that \u2018requirements should be complete.\u2019But just what does completeness mean, and how should you ensure that your requirements are complete? In this column, we will begin to address these two questions by looking at (1) the importance of requirements completeness,(2) the completeness of requirements models,(3) the completeness of various types of individual requirements,, and (4) the completeness of requirements metadata. In next issue\u2019s column, we will continue by addressing (5) the completeness of requirements repositories,(6) the completeness of requirements documents derived from such repositories of requirements,(7) the completeness of sets of requirements documents,(8) the completeness of requirements baselines, and finally (9) determining how complete is complete enough when using an incremental and iterative development cycle.", "num_citations": "71\n", "authors": ["1480"]}
{"title": "Using quality models to engineer quality requirements\n", "abstract": " There are a great number of different kinds of quality requirements. Consisting of a hierarchy of quality factors including associated quality characteristics and quality measures, a quality model provides a structured foundation on which to identify, analyze, and specify these quality requirements.", "num_citations": "69\n", "authors": ["1480"]}
{"title": "Use cases: the pros and cons\n", "abstract": " ORIENTED SOFTWARE ENGINEERING: A USE CASE DRIVEN APPROACH2 in 1992 that marked the true beginning of use cases\u2019 meteoric rise in popularity. Possibly in reaction to the previous structured methods, early object-oriented (00) development methods overemphasized static architecture and partially ignored dynamic behavior issues during requirements analysis, especially above the individual class level where state modeling provides an important technique for dynamic behavior specification. Use cases provide a great many benefits in addition to correcting this overemphasis, and designers of most major OO development methods (including my own) have jumped on the bandwagon and added use cases during the last few years. In the resulting hoopla and hype, however, there has been little discussion of the limitations and potential pitfalls associated with use cases. In this column I attempt to provide a more balanced presentation and to caution against the uncritical acceptance of use cases as the latest patent medicine for all software ailments.", "num_citations": "62\n", "authors": ["1480"]}
{"title": "Profiling systems using the defining characteristics of systems of systems (SoS)\n", "abstract": " The concept of a system of systems SoS has become very popular over the last decade, resulting in books, conferences, technical papers, and reports. However, there is no consensus as to exactly what the term means, and it has been given many different, though re-lated, definitions. This technical note identifies and describes the characteristics that have been used in various definitions of the term system of systems. These SoS characteristics vary along corresponding scales and can form the basis of corresponding meters that serve as indicators of where a system lies along the associated scale. This technical note also discusses two other classes of system characteristics quality characteristics and programmatic characteristics and how similar meters can be used to describe where systems lie along the scales associated with these two additional sets of system characteristics. Finally, this technical note discusses the various benefits of using these system of systems characteristics to profile systems.Descriptors:", "num_citations": "61\n", "authors": ["1480"]}
{"title": "Towards service-oriented enterprise architectures for big data applications in the cloud\n", "abstract": " Applications with Service-oriented Enterprise Architectures in the Cloud are emerging and will shape future trends in technology and communication. The development of such applications integrates Enterprise Architecture and Management with Architectures for Services & Cloud Computing, Web Services, Semantics and Knowledge-based Systems, Big Data Management, among other Architecture Frameworks and Software Engineering Methods. In the present work in progress research, we explore Service-oriented Enterprise Architectures and application systems in the context of Big Data applications in cloud settings. Using a Big Data scenario, we investigate the integration of Services and Cloud Computing architectures with new capabilities of Enterprise Architectures and Management. The underlying architecture reference model can be used to support semantic analysis and program comprehension of\u00a0\u2026", "num_citations": "60\n", "authors": ["1480"]}
{"title": "Analyzing and specifying reusable security requirements\n", "abstract": " A system cannot have high assurance if it has poor security, and thus, requirements for high assurance systems will logically include security requirements as well as availability, reliability, and robustness requirements. Unlike typical functional requirements, security requirements can potentially be highly reusable, especially if specified as instances of reusable templates. This paper discusses the value of reusable parameterized templates for specifying security requirements, provides an example of such a template and its associated usage, and outlines an asset-based analysis approach for determining the appropriate actual parameters to use when reusing parameterized templates to specify security requirements.Descriptors:", "num_citations": "53\n", "authors": ["1480"]}
{"title": "Engineering safety-and security-related requirements for software-intensive systems\n", "abstract": " Safety Engineering the engineering discipline within systems engineering concerned with lowering the risk of unintentional unauthorized harm to valuable assets to a level that is acceptable to the system\u2019s stakeholders by preventing, detecting, and reacting to accidental harm, mishaps (ie, accidents and incidents), hazards, and safety risks", "num_citations": "52\n", "authors": ["1480"]}
{"title": "The method framework for engineering system architectures\n", "abstract": " The architects of today's large and complex systems all too often struggle with the lack of a consistent set of principles and practices that adequately address the entire breadth of systems architecture. The Method Framework for Engineering System Architectures (MFESA) enables system architects and process engineers to create methods for effective", "num_citations": "51\n", "authors": ["1480"]}
{"title": "Modern requirements specification\n", "abstract": " Requirements specification is the requirements engineering task during which analyzed requirements are properly documented for use by their intended audiences. Traditionally, this involved the requirements team using a word processing program to produce a single requirements specification document during an initial requirements phase of a project. However, trends in system development have made the numerous problems with this approach abundantly clear. Improvements in requirements tools have not only enabled better requirements management; they have also enabled the automatic generation of consistent, current, audience-specific requirements specifications that far better meet the needs of their individual audiences.", "num_citations": "46\n", "authors": ["1480"]}
{"title": "Testing object-oriented software\n", "abstract": " Software implemented in an object-oriented programming language (OOPL) has a radically different structure and behavior than does software implemented in a traditional procedural language such as C, COBOL, FORTRAN, and Pascal. This is true regardless of whether it is implemented in a pure object-oriented language (eg, Eiffel, Smalltalk), a hybrid object-oriented language (eg, Ada9X, C++), or an object-based language (eg, Ada 83, Modula-2). Rather than being functionally decomposed into separate procedures and common global data, object-oriented software is composed of objects and classes which interact via message passing and share definitions via inheritance. Rather than being developed according to the classic waterfall development cycle, object-oriented software is most often incrementally analyzed, designed, coded, and tested in accordance with iterative and recursive development cycles\u00a0\u2026", "num_citations": "45\n", "authors": ["1480"]}
{"title": "A taxonomy of safety-related requirements\n", "abstract": " As software-intensive systems become more pervasive, more and more safety-critical systems are being developed and deployed. Yet when most people think about safety requirements, they think of safety-critical functional requirements, which are requirements that have critical safety ramifications if not correctly implemented. However, there are actually four major classifications of safety-related requirements:(1) pure safety requirements,(2) safety-significant requirements,(3) safety constraints, and (4) requirements for safety systems. This paper describes a taxonomy of these different kinds of safetyrelated requirements, and clearly and briefly defines and describes each of the above categories of safety-related requirements.", "num_citations": "40\n", "authors": ["1480"]}
{"title": "Use case modeling guidelines\n", "abstract": " Use case modeling has become the most popular de facto standard technique for performing software requirements analysis and specification. However, use case modeling has its well known problems, and different requirements engineers typically perform use case modeling differently. The paper provides a hierarchically organized set of detailed guidelines for use case modeling.", "num_citations": "40\n", "authors": ["1480"]}
{"title": "Comparing OPEN and UML: the two third-generation OO development approaches\n", "abstract": " Recent efforts have been made to coalesce object-oriented methods and object-oriented modelling languages and, at the same time, to put them on a more rigorous footing by the use of metamodelling techniques. Two so-called third-generation approaches, OPEN (a full methodology) and UML (a modelling language) are described and compared here. These two approaches are compared by focusing on two main areas: (1) process and lifecycle support and, predominantly, (2) metamodel and notation.", "num_citations": "38\n", "authors": ["1480"]}
{"title": "Dictionary of object technology: The definitive desk reference\n", "abstract": " The authors have created a 603-page hardcover book that is detailed, yet succinct. In the preface they state:\u201cThis dictionary included all of the terms and definitions that we could include given the time and resources that we had available.\u201d I do not argue with this statement. The entries conform to the usual dictionary formats, including alphabetical presentation, terms with multiple definitions, part of speech, usage information, and the source of each definition. Additional information for a term is provided when multiple derived versions exist. For example, the word \u201cclass\u201d is the source for the terms \u201cabstract class,\u201d\u201cactive class,\u201d\u201caggregate class,\u201d and so on. The definition for each of these terms is provided within the \u201cclass\u201d entry as a bulleted item. Some terms have five or more levels of nested derivatives. In most cases, the derived term also has its own entry elsewhere in the dictionary. More than 20 sources for the\u00a0\u2026", "num_citations": "37\n", "authors": ["1480"]}
{"title": "Quality Requirements Checklist.\n", "abstract": " On an individual requirement by requirement basis, quality requirements are typically much more important than functional requirements because they most strongly drive the architecture of software-intensive systems. Thus, it is how well the quality requirements are engineered and implemented that tends to determine the success or failure of mission critical systems. Yet, missing or poorly specified quality requirements can all too commonly be identified during effective evaluations of the requirements specifications and the resulting architectures. This column provides a short checklist for use during the engineering and evaluation of quality requirements to help the requirements team develop better quality requirements and to help evaluators of these requirements identify defects in the associated requirements specifications.", "num_citations": "35\n", "authors": ["1480"]}
{"title": "Creating a project-specific requirements engineering process\n", "abstract": " In this column, I use a common situation facing many requirements engineers to illustrate that \u201cone size does not fit all\u201d when it comes to selecting a project-specific requirements engineering process. I then recommend a metaprocess for constructing such a process based on the use of a preexisting process framework and its associated repository of reusable process components. I conclude the column with a brief discussion of some of the benefits and risks associated with this approach.", "num_citations": "32\n", "authors": ["1480"]}
{"title": "Analyzing the security significance of system requirements\n", "abstract": " Safety and security are highly related concepts [1] [2] [3]. Both deal with the protection of valuable assets from harm, and both do this by avoiding, detecting, and responding to incidents that can cause such harm. In both cases, the dangers (hazards and threats respectively) that can cause or enable such incidents to occur are identified and the associated risks are analyzed in order to ensure that these risks are mitigated to acceptable levels. Safety engineering is typically concerned less with requirements than with its downstream activities (e.g., architecting, design, coding, testing) because much of hazard analysis is based on the existence of an architecture, the components of which can cause accidents if they fail. Yet one central safety engineering technique is to categorize the system requirements based on their safety significance and use this categorization to determine the associated level of development processes necessary to assure a corresponding acceptable level of safety risk. Based on the similarity between safety and security, this position paper advocates using a similar process to categorize the security significance of non-security requirements and use this information to ensure that an adequate development process is used to assure an acceptable level of security risk.", "num_citations": "30\n", "authors": ["1480"]}
{"title": "Generating Complete, Unambiguous, and Verifiable Requirements from Stories, Scenarios, and Use Cases.\n", "abstract": " Simple scenarios and stories are typically used for requirements engineering in the Agile community (eg, eXtreme Programming). Use case modeling has also been a popular requirements elicitation and analysis technique for many years. However, stories, scenarios, and use cases typically exhibit a great informality that violates the traditional guidance in the requirements engineering community that requirements should be complete, unambiguous, and verifiable. This is why many professional requirements engineers use these techniques only as tools for informal requirements elicitation, analysis, and validation. Instead during requirements analysis and specification, more experienced requirements engineers tend to develop and specify more formal textual requirements that are complete, unambiguous, and verifiable.", "num_citations": "30\n", "authors": ["1480"]}
{"title": "Engineering safety-related requirements for software-intensive systems\n", "abstract": " Many software-intensive systems have significant safety ramifications and need to have their associated safety-related requirements properly engineered. However, there is little effective interaction and collaboration between the requirements and safety teams on most projects. This paper is intended to improve such collaboration by providing clear definitions of the different kinds of safety-related requirements, examples of such requirements, and a generic process for producing them.", "num_citations": "29\n", "authors": ["1480"]}
{"title": "Pattern language for testing objectoriented software\n", "abstract": " CiNii \u8ad6\u6587 - Pattern language for testing objectoriented software CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853 \u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f \u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u306e\u30b5\u30fc\u30d3\u30b9 \u306b\u95a2\u3059\u308b\u30a2\u30f3\u30b1\u30fc\u30c8\u3092\u5b9f\u65bd\u4e2d\u3067\u3059\uff0811/11(\u6c34)-12/23(\u6c34)\uff09 Pattern language for testing objectoriented software FIRESMITH DG \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 FIRESMITH DG \u53ce\u9332\u520a\u884c\u7269 Object Magazine Object Magazine 5(9), 42-45, 1996 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 Scenario-Based Web Services Testing with Distributed Agents TSAI Wei-Tek , PAUL Ray , YU Lian , SAIMI Akihiro , CAO Zhibin IEICE transactions on information and systems 86(10), 2130-2144, 2003-10-01 \u53c2\u8003\u6587\u732e59\u4ef6 \u88ab\u5f15\u7528\u6587\u732e2\u4ef6 CiNii\u5229\u7528\u8005\u30a2\u30f3\u30b1\u30fc\u30c8 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID\u2026", "num_citations": "29\n", "authors": ["1480"]}
{"title": "Method engineering and COTS evaluation\n", "abstract": " This position paper argues that a successful COTS evaluation process should be based on the principles of method engineering (ME). Following a brief description of an ME approach underpinned by a metamodel, some method fragments related to component-based software engineering are offered as the starting point for the creation of a complete suite of method fragments for future COTS evaluation processes.", "num_citations": "21\n", "authors": ["1480"]}
{"title": "Structured analysis and object-oriented development are not compatible\n", "abstract": " Since its introduction in 1978, traditional Structured Analysis has been an industry standar d method for software requirements analysis that is supported by numerous CASE tools. Since their introduction in the early 1980s, various forms of Object-Oriented Development (OOD) have also become the preferred approach for the design and coding of Ada software. More recently, OOD has included various forms of Object-Oriented Requirements Analysis. OOD has therefor e come into direct competition with Structured Analysis. While some methodologists have advocated retaining Structured Analysis and have worked to merge the two paradigms, others have pointed out significant disadvantages of combining them and urge the use of a unifie d object-oriented paradigm throughout all development activities. A recent article published in Ada Letters by Ken Shumate [SH 1991] is illustrative of this controversy and has\u00a0\u2026", "num_citations": "21\n", "authors": ["1480"]}
{"title": "Achieving quality requirements with reused software components: Challenges to successful reuse\n", "abstract": " \u2022 Our subject is the development of softwareintensive systems that incorporate some reused component containing or consisting of software.\u2022 We are not talking about developing software for reuse in such systems (ie, this is not a \u2018design for reuse\u2019discussion).\u2022 The scope is all reusable software, not just COTS software.", "num_citations": "18\n", "authors": ["1480"]}
{"title": "COMMA: Proposed core model\n", "abstract": " In previous columns1; 2, we described the overall project structure for COMMA (the Common Object Methodology Metamodel Architecture) and some sample results from our metamodelling e\u017dort of fourteen methodologies. Based on these 14 models, in this article, we make some tentative proposals for a common, core metamodel.", "num_citations": "18\n", "authors": ["1480"]}
{"title": "Viewing the OML as a variant of the UML\n", "abstract": " The OPEN Modelling Language, OML, was published during the standardization process which finally led to UML version 1.3. While being contributory to this process, there are still some features of the OML which have not been adopted in the current version of the UML. These features offer capabilities which are complementary to those of the UML. This paper describes how these features of the OML can be made available to UML developers by viewing the OML as a variant of the UML.", "num_citations": "17\n", "authors": ["1480"]}
{"title": "OML metamodel: Relationships and state modeling\n", "abstract": " Metamodelling has provided a tool to facilitate the convergence between object oriented methodologies. Building on top of the Common Object Methodology Metamodel Architecture (COMMA) metamodel, the Object-oriented Process, Environment, and Notation (OPEN) methodology provides a metamodel for relationships as well as for the dynamic and use case aspects of an object model. These metamodels together with the Common Object Modelling Notation (COMN) notation, comprise the OPEN Modelling Language (OML).", "num_citations": "17\n", "authors": ["1480"]}
{"title": "Common system and software testing pitfalls: how to prevent and mitigate them: descriptions, symptoms, consequences, causes, and recommendations\n", "abstract": " \u201cDon\u2019s book is a very good addition both to the testing literature and to the literature on quality assurance and software engineering\u2026.[It] is likely to become a standard for test training as well as a good reference for professional testers and developers. I would also recommend this book as background material for negotiating outsourced software contracts. I often work as an expert witness in litigation for software with very poor quality, and this book might well reduce or eliminate these lawsuits\u2026.\u201d\u2013Capers Jones, VP and CTO, Namcook Analytics LLC Software and system testers repeatedly fall victim to the same pitfalls. Think of them as \u201canti-patterns\u201d: mistakes that make testing far less effective and efficient than it ought to be. In Common System and Software Testing Pitfalls, Donald G. Firesmith catalogs 92 of these pitfalls. Drawing on his 35 years of software and system engineering experience, Firesmith shows testers and technical managers and other stakeholders how to avoid falling into these pitfalls, recognize when they have already fallen in, and escape while minimizing their negative consequences. Firesmith writes for testing professionals and other stakeholders involved in large or medium-sized projects. His anti-patterns and solutions address both \u201cpure software\u201d applications and \u201csoftware-reliant systems,\u201d encompassing heterogeneous subsystems, hardware, software, data, facilities, material, and personnel. For each pitfall, he identifies its applicability, characteristic symptoms, potential negative consequences and causes, and offers specific actionable recommendations for avoiding it or limiting its consequences. This guide will help\u00a0\u2026", "num_citations": "15\n", "authors": ["1480"]}
{"title": "Requirements engineering\n", "abstract": " As an activity, requirements engineering exists in order to produce the requirements work products that are the foundation upon which the majority of the other major activities (eg, architecting, design, implementation, testing) are built. Thus in many ways, they are some of the most critical work products produced during development endeavors.As the following paragraphs will show, there are a great many reusable requirements work products that can be produced on an endeavor. However, not every endeavor will require every one of these work products. The process engineers working with others on the endeavor will select only those work products that are appropriate and cost effective.", "num_citations": "14\n", "authors": ["1480"]}
{"title": "Common testing problems: Pitfalls to prevent and mitigate\n", "abstract": " Suzanne Miller: Welcome to the SEI podcast series, a production of the Carnegie Mellon Software Engineering Institute. The SEI is a federally funded research and development center at Carnegie Mellon University in Pittsburgh, Pennsylvania. A transcript of today\u2019s podcast is posted on the SEI website at sei. cmu. edu/podcasts. I am Suzanne Miller, a principal researcher here at the SEI, and today I\u2019m very pleased to introduce you to one of my friends and colleagues, Don Firesmith. Don\u2019s work focuses on testing requirements, engineering, system architecting, and product lines. He\u2019s kind of a jack-of-all-trades. Aren\u2019t you, Don?", "num_citations": "13\n", "authors": ["1480"]}
{"title": "Upgrading OML to Version 1.1: Part 2-Additional Concepts and Notation\n", "abstract": " In this second instalment describing the new, updated version of the OPEN Modelling Language (OML), we describe clarifications and extensions to the book published describing OML Version 1.0 (ref. 1). In particular, we focus on the crucial support for responsibilities, the underpinning concepts (and notation) for classes, instances, r^ oles and types, extensions regarding patterns, packages, scenario types, stereotypes and interaction diagrams. We also extend the modelling language to cater for the important areas of concurrency and distribution.", "num_citations": "12\n", "authors": ["1480"]}
{"title": "The business case for requirements engineering\n", "abstract": " The Business Case for Requirements Engineering Page 1 \u00a9 2003 by Carnegie Mellon University page 1 The Business Case for Requirements Engineering RE\u20192003 12 September 2003 Donald Firesmith Acquisition Improvement Team Acquisition Support Program Software Engineering Institute (SEI) Carnegie Mellon University Pittsburgh, PA 15213 Page 2 \u00a9 2003 by Carnegie Mellon University page 2 In a Nut Shell \u2022 Requirements first opportunity to screw up \u2022 Many requirements engineers aren\u2019t \u2022 Requirements typically contain many defects \u2022 Requirements impact all down-stream work \u2022 Cost to fix defects increases rapidly the earlier they are introduced \u2022 Requirements primary reason for failure Page 3 \u00a9 2003 by Carnegie Mellon University page 3 First Opportunity to Fail There are many chances to fail on any project: \u2022 Contracting \u2022 Requirements Engineering \u2022 Architecting \u2022 Design \u2022 Implementation \u2022 Integration \u2022 \u2026", "num_citations": "10\n", "authors": ["1480"]}
{"title": "Mixing apples and oranges: or what is an Ada line of code anyway?\n", "abstract": " The Ada Community has long recognized that the full benefits of the Ada language can only be achieved through the application of sound, modern software engineering principles and methods. Numerous examples of this recognition include: the name of the ASEET Team (i. e., Ada Software Engineering Education and Training), CREASE (i. e., Catalogue of Resources for Education in Ada an d Software Engineering), Department of Defense Directive DODD 3405. 2 which states\" Software engineering principles that facilitate the use of the Ada language... shall be fully exploited...\", and books such as Grady Booch's SOFTWARE ENGINEERIN G WITH ADA.Although engineering is based on mathematics, it is definitely not engineering when every engineer uses his or her own private mathematics. Unless there is a standard approach to measurement, developers are reduced to talking apples an d oranges--a sure\u00a0\u2026", "num_citations": "10\n", "authors": ["1480"]}
{"title": "Requirements Engineering Tasks.\n", "abstract": " Many managers and others who are not professional requirements engineers tend to greatly over-simplify requirements engineering (RE). Based on their observations that requirements specifications primarily contain narrative English textual statements of individual requirements and that all members of the engineering team are reasonably literate, there is a common myth that practically anyone with little or no specialized training or expertise can be a requirements engineer. After all, what is there to do but ask a few stakeholders what they want (requirements elicitation), study the resulting requirements to make sure they are understood (requirements analysis), write the requirements down in a document (requirements specification), and then ask the customer if they\u2019re right (requirements validation). Just give the team a short class in use case modeling, and they are ready to go.Unfortunately, the preceding is a misleading, if much too prevalent, myth. While these four RE tasks (not sequential phases!) are commonly performed with varying degrees of completeness, rigor, and success on most projects, a list of tasks containing only these four is far from complete. The purpose of this paper is to provide a brief introduction to all of the major tasks comprising RE, as well as to three essential and highly related tasks from the management, configuration management, and quality engineering disciplines. Depending on the top-most goals of the system development project or product line development projects, the RE teams need to ensure that the actual RE method to be used contains all of the essential and cost-effective RE tasks, tailored to meet the\u00a0\u2026", "num_citations": "9\n", "authors": ["1480"]}
{"title": "An expanded view of messages\n", "abstract": " Most software developers have a strong tendency to define object-oriented concepts in terms of the specific object-oriented programming languages (OOPLs) they know. Unfortunately, these definitions also soffer the same limitations of the OOPLs. This, in turn, has tended to limit the power of object-oriented requirements analysis and logical design, which should be language independent. Many examples of this phenomenon exist, including lack of support for dynamic and multiple classification, equating objects and classes with encapsulations of attributes and operations (which is how many OOPLs implement then) rather than as software models of application domain entities, and defining a message as a dynamically bound call to a corresponding operation (a.k.a., method) of an object or class. This paper addresses this latter, arbitrary forced, one-to-one mapping of messages to operations.", "num_citations": "8\n", "authors": ["1480"]}
{"title": "Engineering safety-and security-related requirements for software-intensive systems: tutorial summary\n", "abstract": " This full-day tutorial introduces the attendee to the engineering of safety-and security-related requirements for software-intensive systems. It provides a consistent, effective, and efficient method for identifying, analyzing, specifying, verifying, and validating the four different types of safety-and security-related requirements.", "num_citations": "7\n", "authors": ["1480"]}
{"title": "Method engineering using opfro\n", "abstract": " \u2022 A cohesive part of a method Method should contain all types of method components:\u2022 Work products to be produced or modified\u2022 Work units to be performed on work products\u2022 Producers who perform work units on work products\u2022 Stages during which work units are performed\u2022 Endeavors staffed by producers and organized by stages", "num_citations": "7\n", "authors": ["1480"]}
{"title": "QUASAR: A Method for the QUality Assessment of Software-Intensive System ARchitectures\n", "abstract": " This handbook documents the QUASAR (QUality Assessment of System ARchitectures) method for assessing the quality of the architecture of a software-intensive system. It begins by discussing the challenges that are faced when assessing a system's architecture and outlines the development history of the method. The next section of the handbook documents the concept of quality cases and the claims, arguments, and evidence that compose them. This is followed by a description of the teams that collaborate to perform QUASAR tasks. Next, individual tasks and associated steps performed as part of the QUASAR method are documented. Next, the work products produced by these teams when performing these tasks are described. Finally, lessons learned during the development and use of the method when assessing the quality of major subsystems during the development of a very large, software-intensive system of systems are presented. Also provided are appendices that define common quality factors and subfactors, offer reusable checklists, and give examples of quality cases. The example quality cases illustrate valid quality goals and requirements that compose claims, example architecture decisions and associated rationales that compose arguments, and the types of evidence that architects might provide.", "num_citations": "6\n", "authors": ["1480"]}
{"title": "A comparison of Defensive Development and Design by Contract/sup TM\n", "abstract": " The paper briefly defines and discusses assertions and their uses before summarizing Design by Contract and Defensive Development. This provides a foundation for the following comparison of their similarities as well as their respective strengths and weaknesses. The paper concludes by arguing that Defensive Development is superior to Design by Contract, largely because of how they differ in assigning the responsibility for checking and ensuring preconditions.", "num_citations": "6\n", "authors": ["1480"]}
{"title": "Methods unification: the OPEN methodology\n", "abstract": " It is clear that there are currently too many OO development methods and many (but not all!) of the di\u00ae erences between them are more cosmetic than substantive. Whilst competition may be fun, it soon becomes clear that to those of us who really believe that OT is\\a good thing\", the more important goal should be to create an environment in which the majority of software developers can move safely from their traditional development environments into the new age of object technology. Consequently, most of the world's leading methodologists have been actively pursuing a goal of method unification. This led, in part, to the research work of the COMMA project which I have been reporting in this JOOP/ROAD column over the past year or so. The aim of COMMA, in a nutshell, has been to \u00b2 produce a metamodel of the leading OO methodologies; \u00b2 extract from these metamodels ideas from which to construct a\\core metamodel\"| this was discussed by Henderson-Sellers and Firesmith1; \u00b2 deliver this core to the OMG via the OADTF's RFP. This has been accomplished in terms of its major contribution to the metamodel submitted by the OPEN Object Alliance via Platinum in January 19972; \u00b2 permit this core model to be common to all methodologies whilst permitting extensions beyond the core so that each methodology can be directed at its own market. Whilst the last point is still to be fully realized, there are two unification projects which have inuenced and been inuenced by all this e\u00ae ort on metamodelling. In the first, Grady Booch and Jim Rumbaugh collaborated to create the Unified Method, Version 0.8 1 which later became the Unified Modeling\u00a0\u2026", "num_citations": "6\n", "authors": ["1480"]}
{"title": "Object-oriented regression testing\n", "abstract": " EGRESSION TESTING\u2014THE REPETITION OF TESTING FOR THE PURPOSE OF finding new errors in previously tested software\u2014is an absolutely critical requirement if object technology is to achieve its promised benefits. This article discusses the increased need for regression testing due to object technology and stresses the need for regression testing to be automated. It then presents three major techniques for automating regression testing, along with a discussion of their pros and cons.", "num_citations": "6\n", "authors": ["1480"]}
{"title": "Should the DOD mandate a standard software development process?\n", "abstract": " Thls paper addresses the questxon of whether the DoD should mandate v1a\" Defense System Software Development\"(DOD\u2014STD\u20142l67) a standard software development process and l1\u00a3 e\u2014cycle on prlvate industry. It also quest1ons the cost\u2014ef\u00a3 ect1veness of establ1sh1ng e1ther requlred or default software development methods. It dEt811S both BpEC1flC problems relatlng to DOD\u2014STD\u20142167 as well as general problems wlth process standards for software development. It provides the author's recommendatlons tor solv1ng some of these problems.", "num_citations": "6\n", "authors": ["1480"]}
{"title": "Documenting a complete Java application using OPEN\n", "abstract": " Object-oriented Process, Environment, and Notation (OPEN) is an object-oriented development method and process framework. Firesmith was a key contributor to the development of OPEN. The book is divided into two parts. The relatively short Part 1 consists of three chapters (47 pages), which define the OPEN Modeling Language (OML) and its graphical representation, Common Object Modeling Notation; the incremental, iterative, and parallel OPEN development process; and the content and format for the project documentation. The documentation discussed here is not the user documentation, but rather the development and maintenance specification for the project, covering requirements, design, and testing. Part 2 is much longer (at more than 300 pages) and provides an example of complete documentation, according to the standard explained in Part 1, of controlling software for a hypothetical vending\u00a0\u2026", "num_citations": "5\n", "authors": ["1480"]}
{"title": "Object-oriented state modeling using ADM4\n", "abstract": " HIS ARTICLE SUMMARIZES the state modeling approach of Version 4.5 of the ASTS Development Method (ADM), which includes several major advances over that of ADM3. We begin by defining the basic concepts of state modeling (eg, states, transitions, triggers) in terms of object-oriented concepts, and then introduce ADM's state transition diagrams and state operation tables, followed by two examples. We then briefly address the issue of the inheritance and documentation of state models, before concluding with a comparison of ADM's state model to those of other methods.ADM4 is a fourth-generation, general-purpose, object-oriented system development method that emphasizes software development and provides both static architecture and dynamic behavior modeling. While designed for use on large, complex, real-time applications, ADM4 can be easily tailored down for small, simple applications. The\u00a0\u2026", "num_citations": "5\n", "authors": ["1480"]}
{"title": "Managing Ada projects: the people issues\n", "abstract": " In order to successfully manage the new Ada technology, the software manager must be able to: successfully interact with upper management, negotiate with and educate the contracting agency, user, and Independent Verification and Validation (IV & V) personnel, and lead an often diverse group of developers using new software development methods and tools in addition to a new language. This paper points out problems and offers solutions for dealing with project politics, sociology, and psychology that often have a larger impact on the success of Ada projects than do the technical issues.", "num_citations": "5\n", "authors": ["1480"]}
{"title": "Common system and software testing pitfalls\n", "abstract": " NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN \u201cAS-IS\u201d BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.", "num_citations": "4\n", "authors": ["1480"]}
{"title": "Resolution of Ada-related concerns in DoD-STD-2167, revision A\n", "abstract": " The purpose of this article is to report to the Ada Communit y important actions concerning the revision of DOD-STD-2167, Defense System Software Development. DOD-STD-2167 standardizes the development of Mission-Critical Computer Resources software by establishing a uniform software development process which is applicable throughout the system life-cycle. Its purpose is to improve the government's management and oversight of this proces s and to result in the delivery of high quality software that wil l accomplish its intended mission. DOD-STD-2167 was released on June 4, 1985 as a tri-service coordinated standard. Revision A of this standard will be released for formal government and industry review on September 1, 1986. Revision A is scheduled for approval and release during the fall of 1987.", "num_citations": "4\n", "authors": ["1480"]}
{"title": "Two Impediments to the proper use of Ada\n", "abstract": " CONCLUSION: These impediments must be removed if Ada is to achiev e its goals of increased reusability, reliability, and maintainability. In the long run. the compiler vendors must solve these problems if we are to be able to use Ada as intended. In the mean time, we may be forced to write more ADATRAN than we would like. vii. 5-104", "num_citations": "3\n", "authors": ["1480"]}
{"title": "Object-oriented development\n", "abstract": " Object Oriented Development (OOD) is one of the extremely few software development methods actually designed for modern Ada language, real-time, embedded applications. OOD is a significant improvement over more traditional functional decomposition and modeling methods in that ODD: Better manages the size, complexity, and concurrancy of today's systems; Better addresses important software engineering principles such as abstract data types, levels of abstraction, and information hiding; Produces a better design that more closely matches reality; Produces more maintainable software by better localizing data and thus limiting the impact of requirements changes; and Specifically exploits the power of Ada. OOD is further explored in detail.", "num_citations": "3\n", "authors": ["1480"]}
{"title": "Quality assessment of system architectures and their requirements (QUASAR)\n", "abstract": " The quality of a software-intensive system is largely determined by the quality of its architecture and the quality of the architecturally significant requirements that drive its development. Unfortunately, although quality requirements typically have critical architectural ramifications, requirements engineers using such popular techniques as use case modelling tend to emphasize functional requirements over non-functional quality requirements, with the result that the quality requirements are often poorly specified or not specified at all. Similarly, system architects tend to emphasize a system's logical decomposition structure into major functions and subfunctions and the corresponding static physical decomposition structure into a hierarchy of subsystems. The system architects often do not adequately document how (or even if) these subsystems and subsubsystems collaborate to sufficiently support the achievement of\u00a0\u2026", "num_citations": "2\n", "authors": ["1480"]}
{"title": "QUality Assessment of System ARchitectures (QUASAR)\n", "abstract": " QUality Assessment of System ARchitectures (QUASAR) Page 1 Sponsored by the US Department of Defense \u00a9 2006 by Carnegie Mellon University Version 0.1 QUASAR Method. - page 1 Pittsburgh, PA 15213-3890 QUality Assessment of System ARchitectures (QUASAR) Donald Firesmith Acquisition Support Program (ASP) Page 2 Report Documentation Page Form Approved OMB No. 0704-0188 Public reporting burden for the collection of information is estimated to average 1 hour per response, including the time for reviewing instructions, searching existing data sources, gathering and maintaining the data needed, and completing and reviewing the collection of information. Send comments regarding this burden estimate or any other aspect of this collection of information, including suggestions for reducing this burden, to Washington Headquarters Services, Directorate for Information Operations and Reports, \u2026", "num_citations": "2\n", "authors": ["1480"]}
{"title": "Object-oriented graphics for requirements analysis and logical design\n", "abstract": " Numerous graphic notations have been proposed during the last 5 years for use during Object-Oriented Requirements Analysis and Logical Design. The following article describes the consistent set of tool-supported object-oriented graphics that are part of ASTS Development Method 2 (ADM_2), a full development cycle method in use on various projects in the United States, Canada, and England.", "num_citations": "2\n", "authors": ["1480"]}
{"title": "FAA Research Project on System Complexity Effects on Aircraft Safety: Identifying the Impact of Complexity on Safety\n", "abstract": " This draft report organizes our work on this topic to date. The work will continue. Hence, the bulk of this report is an unfinished appendix. We have organized this work on the impact that software complexity has for aircraft safety by looking in two directions. Backward tracing asks the question,\u201cWhat aspects of safety, V&V, and certification can be complicated by complexity?\u201d Forward tracing asks the question,\u201cWhat about complexity can lead to problems with certification, V&V, and flight safety?\u201d", "num_citations": "1\n", "authors": ["1480"]}
{"title": "The Method Framework for Engineering System Architecture (MFESA): A Practical Way to Generate Effective and Efficient Project-Specific System Architecture Engineering Methods\n", "abstract": " This 1/2 day tutorial presents a new proposed method framework and associated repository of reusable method components for creating appropriate project-specific methods for engineering system architectures. Several MFESA tasks directly involve component-based software-intensive systems in that they involve the identification and analysis of potential reusable architectural work products including patterns, models, and architectural components.", "num_citations": "1\n", "authors": ["1480"]}
{"title": "Security and Safety Requirements for Software-Intensive Systems\n", "abstract": " Security and Safety Requirements for Software-Intensive Systems | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSecurity and Safety Requirements for Software-Intensive Systems ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide books cover image Security and Safety Requirements for Software-Intensive Systems November 2007 ISBN:1420045067 Author: Donald G. Firesmith Copyright \u00a9 2007 Publisher \u2026", "num_citations": "1\n", "authors": ["1480"]}
{"title": "Architecture-Related Requirements.\n", "abstract": " The engineering of architecture-related requirements has proven to be a very difficult task for requirements engineers. It is also a task that experience has shown could use significant improvements in practice. These requirements are critically important because they drive the development of the system and software architectures, which in turn largely determine if major product qualities are adequately achieved. They also form the basis against which the architectures are assessed. In this column, we describe the three major kinds of architecture-related requirements, discuss the most important characteristics they should have, describe the responsibilities of their stakeholders, and warn of the major negative consequences they can have on downstream activities when they are not properly engineered.", "num_citations": "1\n", "authors": ["1480"]}