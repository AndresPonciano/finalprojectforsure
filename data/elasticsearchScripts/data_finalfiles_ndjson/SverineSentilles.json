{"title": "Pride-an environment for component-based development of distributed real-time embedded systems\n", "abstract": " Settling down the software architecture for embedded system is a complex and time consuming task. Specific concerns that are generally issued from implementation details must be captured in the software architecture and assessed to ensure system correctness. The matter is further complicated by the inherent complexity and heterogeneity of the targeted systems, platforms and concerns. In addition, tools capable of conjointly catering for the complete design-verification deployment cycle, extra-functional properties and reuse are currently lacking. To address this, we have developed Pride, an integrated development environment for component-based development of embedded systems. Pride is based on an architecture relying on components with well-defined semantics that serve as the central development entity, and as means to support and aggregate various analysis and verification techniques throughout\u00a0\u2026", "num_citations": "20\n", "authors": ["599"]}
{"title": "Evolution management of extra-functional properties in component-based embedded systems\n", "abstract": " As software complexity increases in embedded systems domain, component-based development becomes increasingly attractive. A main challenge in this approach is however to analyze the system's extra-functional properties (such as timing properties, or resource requirements), an important step in a development of embedded systems. Analysis of such properties are computational and time consuming, and often difficult. For this reason reuse of the results of the analysis is as important as the reuse of the component itself, especially in case of modifications of the context in which the component is used. This paper presents concepts and mechanisms that allow to automatically discover whether a property value is still valid when related components evolve: a value context language is proposed to formally define the validity conditions and identify possible threats.", "num_citations": "17\n", "authors": ["599"]}
{"title": "Towards software assets origin selection supported by a knowledge repository\n", "abstract": " Software architecture is no more a mere system specification as resulting from the design phase, but it includes the process by which its specification was carried out. In this respect, design decisions in component-based software engineering play an important role: they are used to enhance the quality of the system, keep the current market level, keep partnership relationships, reduce costs, and so forth. For non trivial systems, a recurring situation is the selection of an asset origin, that is if going for in-house, outsourcing, open-source, or COTS, when in the need of a certain missing functionality. Usually, the decision making process follows a case-by-case approach, in which historical information is largely neglected: hence, it is avoided the overhead of keeping detailed documentation about past decisions, but it is hampered consistency among multiple, possibly related, decisions.The ORION project aims at\u00a0\u2026", "num_citations": "16\n", "authors": ["599"]}
{"title": "The black pearl: An autonomous underwater vehicle\n", "abstract": " The Black Pearl is a custom made autonomous underwater vehicle developed at M\u00e4lardalen University, Sweden. It is built in a modular fashion, including its mechanics, electronics and software. After a successful participation at the RoboSub competition in 2012 and winning the prize for best craftsmanship, this year we made minor improvements to the hardware, while the focus of the robot's evolution shifted to the software part. In this paper we give an overview of how the Black Pearl is built, both from the hardware and software point of view.", "num_citations": "15\n", "authors": ["599"]}
{"title": "Component allocation optimization for heterogeneous CPU-GPU embedded systems\n", "abstract": " In a quest to improve system performance, embedded systems are today increasingly relying on heterogeneous platforms that combine different types of processing units such as CPUs, GPUs and FPGAs. However, having better hardware capability alone does not guarantee higher performance, how functionality is allocated onto the appropriate processing units strongly impacts the system performance as well. Yet, with this increase in hardware complexity, finding suitable allocation schemes is becoming a challenge as many new constraints and requirements must now be taken into consideration. In this paper, we present a formal model for allocation optimization of embedded systems which contains a mix of CPU and GPU processing nodes. The allocation takes into consideration the software and hardware architectures, the system requirements and criteria upon which the allocation should be optimized. In its\u00a0\u2026", "num_citations": "14\n", "authors": ["599"]}
{"title": "Towards the architecture of a decision support ecosystem for system component selection\n", "abstract": " When developing complex software-intensive systems, it is nowadays common practice to base the solution partly on existing software components. Selecting which components to use becomes a critical decision in development, but it is currently not well supported through methods and tools. This paper discusses how a decision support system for this problem could benefit from a software ecosystem approach, where participants share knowledge across organizations both through reuse of analysis models, and through partially disclosed past decision cases. We show how the ecosystem architecture becomes fundamental to deal with efficient knowledge sharing, while respecting constraints on integrity of intellectual property. A concrete architecture proposal is outlined, which is a web-based distributed system-of-systems. Experiences of a proof-of-concept implementation are also described.", "num_citations": "12\n", "authors": ["599"]}
{"title": "Extending the Rubus component model with GPU-aware components\n", "abstract": " To support the complex functionality expected of modern embedded systems, the trend is to supplement CPUs with Graphical Processing Units (GPUs), thus creating heterogeneous embedded systems. However, taking full advantage of GPUs increases the complexity of the development and requires dedicated support, and no such support exists in the component models currently available. The only solution today is to completely encapsulate all GPU-specific information and operations within the components, which increases the communication overhead and reduces component reusability, thus significantly limiting the applicability of component-based development to heterogeneous embedded systems. In this paper, we propose to extend Rubus, an industrial component model for embedded systems, with dedicated support for GPUs. We introduce new constructs, including GPU ports and automatically\u00a0\u2026", "num_citations": "12\n", "authors": ["599"]}
{"title": "Architecture logicielle pour capteurs sans-fil en r\u00e9seau\n", "abstract": " Les avanc\u00e9es technologiques r\u00e9centes confortent la pr\u00e9sence de l\u2019informatique et de l\u2019\u00e9lectronique au coeur du monde r\u00e9el. De plus en plus d\u2019objets se voient ainsi \u00e9quiper de processeurs et de moyens de communication mobiles leur permettant de traiter des informations mais \u00e9galement de les transmettre. Cette \u00e9volution s\u2019 inscrit dans le cadre de l\u2019informatique pervasive, plus connue sous le nom d\u2019ubiquitous computing [Wei96]. Un des objectifs de ce domaine est de combler le foss\u00e9 entre les mondes r\u00e9el et virtuel en rendant les objets \u00abintelligents\u00bb. Pour cela, ceux-ci doivent \u00eatre capables de d\u00e9tecter un changement dans leur environnement et d\u2019y r\u00e9agir en fonction notamment des besoins de l\u2019utilisateur.Les r\u00e9seaux de capteurs sans-fil entrent dans ce cadre. En effet, ceux-ci sont constitu\u00e9s d\u2019un ensemble de petits appareils, ou capteurs, poss\u00e9dant des ressources particuli\u00e8rement limit\u00e9es mais qui leur\u00a0\u2026", "num_citations": "12\n", "authors": ["599"]}
{"title": "Flexible semantic-preserving flattening of hierarchical component models\n", "abstract": " Hierarchical component models allow to better manage system design complexity compared to flat component models. However, many analysis techniques lack support for dealing with hierarchical models. This paper presents a general approach to use existing analysis on hierarchical component systems by means of a flattening transformation. The transformation can be partially applied, which provides a possibility for tradeoffs between analysis scalability, result precision and reusability concerns. The general approach has been implemented and evaluated in the context of ProCom, a hierarchical component model for real-time embedded systems. As a result, the paper describes a flattening transformation which preserves the ProCom operational semantics and presents the related optimizations.", "num_citations": "11\n", "authors": ["599"]}
{"title": "Integrating behavioral descriptions into a component model for embedded systems\n", "abstract": " When component-based development is applied to distributed embedded systems, which are often safety-critical and subject to real-time constraints, it is of significant importance that reliable predictions of functional and extra functional properties can be derived at design-time. Preferably, analysis should be performed in early development phases, where the cost of modifying the design is lower. Centered on an example application from the automation domain, we show how a component model specifically intended for embedded systems can be combined with a language for high-level formal behavior modeling. This permits analysis of system properties, while also supporting reuse of behavioral models when components are reused.", "num_citations": "11\n", "authors": ["599"]}
{"title": "A systematic literature study on definition and modeling of service-level agreements for cloud services in IoT\n", "abstract": " The cloud computing paradigm provides remote computing resources to the cloud service consumers and businesses. When combined with Internet of Things (IoT), both technologies open up a wide range of new possibilities for more agile and flexible applications. However, guaranteed quality of service is essential in provisioning of cloud services, which makes Service Level Agreements (SLAs) a focal point in the cloud computing and IoT ecosystem. The SLA definition and modeling phase is crucial in establishing SLAs between service providers and consumers. This paper identifies that the research on definition and modeling of SLAs for cloud services in IoT is widely dispersed and there is a lack of a systematic and comprehensive literature review. Thus, in this paper we build on top of a previously conducted systematic mapping study on management of SLAs for cloud computing and IoT to perform a\u00a0\u2026", "num_citations": "7\n", "authors": ["599"]}
{"title": "Developing CPU-GPU embedded systems using platform-agnostic components\n", "abstract": " Nowadays, there are many embedded systems with different architectures that have incorporated GPUs. However, it is difficult to develop CPU-GPU embedded systems using component-based development (CBD), since existing CBD approaches have no support for GPU development. In this context, when targeting a particular CPU-GPU platform, the component developer is forced to construct hardware-specific components, which are problematic to (re-)use in different contexts. Moreover, hard-coding specific GPU-usage characteristics (e.g., the number of utilized GPU threads) inside the component is not possible without making detailed assumptions about the system in which the component is used, which conflicts with separation-of-concerns CBD principle. The paper presents a solution to allow component-based development of platform-agnostic CPU-GPU embedded systems through: i) high-level API, ii\u00a0\u2026", "num_citations": "7\n", "authors": ["599"]}
{"title": "Valentine: A dynamic and adaptive operating system for wireless sensor networks\n", "abstract": " In this paper, we present an approach allowing dynamic reconfiguration in wireless sensor networks (WSNs). This proposition is based on a twofold work. First we propose Valentine, a new component-based operating system (OS) for WSNs, allowing dynamic administration of components at runtime. This OS will be generated from the Think framework. Second, we discuss and present a specific mechanism for dynamic reconfiguration in the constrained context of WSNs.", "num_citations": "7\n", "authors": ["599"]}
{"title": "Flexible components for development of embedded systems with GPUs\n", "abstract": " Today, embedded systems incorporate GPUs through a multitude of different architectures. When it comes to the development of these systems with GPUs, component-based development is ill-equipped as it does not provide support for GPUs. Instead, the component developer needs to encapsulate inside the component, besides functionality, settings and environment information that are specific to a particular GPU architecture. This binds the component this GPU architecture. Using these hardware-specific components characterized by restricted reusability, the system developer is confined to a limited design-space which may negatively impact the overall system feasibility. In this paper, we introduce the concept of flexible components, which are components that can be executed indifferently on CPU or GPU, regardless of the architecture. Using flexible components, component developers are relieved from the\u00a0\u2026", "num_citations": "6\n", "authors": ["599"]}
{"title": "A GPU-aware Component Model Extension for Heterogeneous Embedded Systems\n", "abstract": " One way for modern embedded systems to tackle the demand for more complex functionality requiring more computational power is to take advantage of heterogeneous hardware. These hardware platforms are constructed from the combination of different processing units including both traditional CPUs and for example Graphical Processing Units (GPUs). However, there is a lack of efficient approaches supporting software development for such systems. In particular, modern software development approaches, such as component-based development, do not provide sufficient support for heterogeneous hardware platforms. This paper presents a component model extension, which defines specific features for components with GPU capabilities. The benefits of the proposed solution include an increased system performance by accelerating the communication between GPU-aware components and the possibility to control the distribution of GPU computation resources at system level.", "num_citations": "6\n", "authors": ["599"]}
{"title": "Refining extra-functional property values in hierarchical component models\n", "abstract": " It is nowadays widely accepted that extra-functional properties (EFPs) are as important as functional properties for system correctness, especially when considering systems such as safety-critical embedded systems. The criticality and resource-constrained nature of these systems necessitate to be able to predict tight and accurate extra-functional property values all along the development, from early estimations to measurements. By using a hierarchical component model that allows implementing components as an assembly of subcomponent instances, the same component can be instantiated in several assemblies, ie in different usage contexts. Many EFP values are sensitive to the usage context and knowing information about the enclosing assembly enables refining the values of the properties on the subcomponents. Such refinement is usually not supported and the consistency between refined values and the\u00a0\u2026", "num_citations": "6\n", "authors": ["599"]}
{"title": "Allocation optimization for component-based embedded systems with GPUs\n", "abstract": " Platforms equipped with GPU processors help mitigating the ever-increasing computational demands of modern embedded systems. Such systems can be specifically developed by using component-based development thanks to the concept of flexible components. Through this concept, a component can be transparently executed either on a CPU or a GPU. However, this flexibility complicates the allocation process because it adds additional complexity (i.e., due to the undecided CPU or GPU execution) and constraints to consider (i.e., CPUs and GPUs properties) In this work, we address this problem by providing an optimization model for component-based embedded systems executing on both CPU and GPU. The model addresses important optimization goals, characteristic to the embedded system domain, such as memory usage, energy usage and execution time. A novelty of this work is the formal description\u00a0\u2026", "num_citations": "4\n", "authors": ["599"]}
{"title": "What do we know about software security evaluation? A preliminary study\n", "abstract": " In software development, software quality is nowadays acknowledged to be as important as software functionality and there exists an extensive body-of-knowledge on the topic. Yet, software quality is still marginalized in practice: there is no consensus on what software quality exactly is, how it is achieved and evaluated. This work investigates the state-of-the-art of software quality by focusing on the description of evaluation methods for a subset of software qualities, namely those related to software security. The main finding of this paper is the lack of information regarding fundamental aspects that ought to be specified in an evaluation method description. This work follows up the authors\u2019 previous work on the Property Model Ontology by carrying out a systematic investigation of the state-of-the-art on evaluation methods for software security. Results show that only 25% of the papers studied provide enough information on the security evaluation methods they use in their validation processes, whereas the rest of the papers lack important information about various aspects of the methods (eg, benchmarking and comparison to other properties, parameters, applicability criteria, assumptions and available implementations). This is a major hinder to their further use.", "num_citations": "4\n", "authors": ["599"]}
{"title": "PROMOpedia: A Web-Content Management-Based Encyclopedia of Software Property Models\n", "abstract": " The way software properties are defined, described, and measured, is different across different domains. When addressing these properties, several challenges commonly emerge, among which: synonymity, polysemy, paronymy, incomplete and inconsistent specification. In this paper we introduce PROMOpedia, an online encyclopedia, to tackle these challenges. PROMOpedia uses a web-content management system coupled with crowd-sourcing of scientific contents related to properties and their evaluation methods. The core concepts of PROMOpedia are built upon a property models ontology previously proposed by the authors, and is intended to target the needs of both researchers and practitioners.", "num_citations": "2\n", "authors": ["599"]}
{"title": "Towards Efficient Component-Based Software Development of Distributed Embedded Systems\n", "abstract": " The traditional ways of developing embedded systems are pushed to their limits, largely due to the rapid increase of software in these systems. Developers now have difficulties to handle simultaneously all the factors involved in the development such as increasing complexity, limited and shared resources, distribution, timing or dependability issues. These limitations make the development of embedded systems a rather complex and time consuming task, and call for new solutions that can efficiently and predictably cope with the new specifics and requirements of embedded systems to ensure their final quality. Component-based software engineering is an attractive approach that aims at building software systems out of independent and well-defined pieces of software. This approach has already shown advantages in managing software complexity, and reducing production time while increasing software quality. However, directly applying component-based software engineering principles to embedded system development is not straightforward. It requires a considerable adaptation to fit the specifics of the domain, since guaranteeing the extra-functional aspects, such as real-time concerns, safety-criticality and resource limitations, is essential for the majority of embedded systems. Arguing that component-based software engineering is suitable for embedded system development, we introduce a component-based approach adjusted for embedded system development. This approach is centered around a dedicated component model, called ProCom, which through its two-layer structure addresses the different concerns that exist at different levels\u00a0\u2026", "num_citations": "2\n", "authors": ["599"]}
{"title": "The realization of flexible GPU components in Rubus\n", "abstract": " This technical report collects details on the realization of flexible GPU components in Rubus, including i) the automatically generated code of adapters, ii) the generated code implementing a component group, and iii) the generic API providing transparent access to multiple platforms and OpenCL versions.", "num_citations": "1\n", "authors": ["599"]}
{"title": "Optimized Realization of Software Components with Flexible OpenCL Functionality.\n", "abstract": " Today, the newly available embedded boards with GPUs provide a solution to satisfy the ever-increasing requirements of modern embedded systems. Component-based development is a well-known paradigm used to develop embedded systems. However, this paradigm lacks GPU support to address the specifics of these new boards. This leads to components that typically have reduced reusability, poor maintainability and portability. One way to tackle the existing shortcomings is through flexible components, ie, platform-agnostic components that, at design time, offer the possibility to be executed either on CPU or GPU. The current realization of flexible components, ie, as regular components with functionality tailored for the selected hardware, introduces additional overheads such as component communication overhead. In order to tackle the introduced overheads, our solution groups connected flexible components under a flexible group that conceptually behaves as a component. We introduce an algorithm to identify the existing groups in a given component-based system and the generation rules that automatically realizes groups as regular components. To evaluate the feasibility of the new concept, the flexible group is implemented using a state-of-the-practice component model (ie, Rubus) and examined through the vision system of an underwater robot.", "num_citations": "1\n", "authors": ["599"]}
{"title": "Connecting ProCom and REMES\n", "abstract": " When component-based development is applied in the domain of distributed embedded systems, where applications are often safety-critical and subject to real-time constraints, it is of significant importance that reliable predictions of functional and extra-functional properties can be derived at design-time. Preferably, analysis should be performed in early development phases, where the cost of modifying the design is lower. Centered on an example application from the automation domain, we show how a component model specifically intended for embedded systems can be combined with a language for high-level formal behavior modeling. This allows modeling the behavior of individual components, in terms of functionality, timing and resource usage. In turn, this permits analysis of system level properties, while also supporting reuse of behavioral models when components are reused.", "num_citations": "1\n", "authors": ["599"]}