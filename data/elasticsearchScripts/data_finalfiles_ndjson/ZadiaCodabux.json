{"title": "Managing Technical Debt: An Industrial Case Study\n", "abstract": " Technical debt is the consequence of trade-offs made during software development to ensure speedy releases. The research community lacks rigorously evaluated guidelines to help practitioners characterize, manage and prioritize debt. This paper describes a study conducted with an industrial partner during their implementation of Agile development practices for a large software development division within the company. The report contains our initial findings based on ethnographic observations and semi-structured interviews. The goal is to identify the best practices regarding managing technical debt so that the researchers and the practitioners can further evaluate these practices to extend their knowledge of the technical debt metaphor. We determined that the developers considered their own taxonomy of technical debt based on the type of work they were assigned and their personal understanding of the\u00a0\u2026", "num_citations": "104\n", "authors": ["1329"]}
{"title": "Novel algorithms and techniques in telecommunications and networking\n", "abstract": " This book includes the proceedings of the 2008 International Conference on Telecommunications and Networking (TeNe).", "num_citations": "19\n", "authors": ["1329"]}
{"title": "Technical debt prioritization using predictive analytics\n", "abstract": " Recently, Technical Debt (TD) has gained popularity in the Software Engineering community to describe design decisions that allow software development teams to achieve short term benefits such as expedited release of code. Technical debt accrued should be managed to avoid the disastrous consequences of these temporary workarounds. Management of technical debt involve documenting the debt item in the backlog including some type of quantification in terms of person-hours or story points for example. Subsequently, the debt items are prioritized and addressed.Developers or project managers face problems to decide which debt is higher priority or more \u201cproblematic\u201d and which one needs to be addressed first. This decision-making process is not standardized and is currently context dependent in most organizations. This paper bridge this gap by proposing a framework which makes use of a plethora of\u00a0\u2026", "num_citations": "18\n", "authors": ["1329"]}
{"title": "An empirical assessment of technical debt practices in industry\n", "abstract": " Context Technical debt refers to the consequences of taking shortcuts when developing software. These consequences can impede the software growth and have financial implications. The software engineering research community needs to explore technical debt further from a practitioner standpoint.   Objective This study gathers insights from practitioners on key components of technical debt such as its definition, characterization, consequences, benefits, and how it is communicated.   Method We conducted semi\u2010structured interviews with a convenience sample of 17 practitioners and a survey of 67 participants.   Results Despite the lack of consensus, we identified the most commonly accepted definition, method to measure technical debt (as person hours), and method to reduce debt (by allocating time in iterations to address the debt). Defects were also identified as type of debt and the cost of technical debt is\u00a0\u2026", "num_citations": "12\n", "authors": ["1329"]}
{"title": "A Quality Assurance Approach to Technical Debt\n", "abstract": " Technical debt is a metaphor used to reason about lingering issues in software development. It is the result of decisions taken during the development process, which are often made due to resource constraints and aggressive schedules. The consequences of technical debt are that it can impede future development and incur increasing costs. However, technical debt is not always bad as, in some cases, respecting deadlines is more important than clean code. Nevertheless, for achieving quality software, it is crucial to prevent the amount of debt from increasing. In this paper, we describe a method for addressing technical debt using a quality assurance (QA) classification scheme and focus on prevention, reduction, and containment activities. We also highlight techniques and processes that are used to apply quality assurance to technical debt.", "num_citations": "10\n", "authors": ["1329"]}
{"title": "AES CCMP Algorithm with N-Way Interleaved Cipher Block Chaining\n", "abstract": " Nowadays, the increased use of battery-powered mobile appliances and the urge to access time-sensitive data anytime anywhere has fuelled a high demand for wireless networks. However, wireless networks are susceptible to intrusion and security problems. There is an inherent need to secure the wireless data communication to ensure the confidentiality, authenticity, integrity and non repudiation of the data being exchanged. On the other hand, the computation and the resultant energy consumption to achieve sufficient security can be high. Encryption algorithms are generally computationally intensive, and consume a significant amount of computing resources (such as CPU time, memory, and battery power). Considering the limited resources on wireless devices, it is crucial that security protocols be implemented efficiently. This manuscript focuses on how energy consumption is impacted by the use of unoptimised AES-CCMP algorithms and proposes an optimized AES CCMP algorithm using 2-way interleaving that does not compromise the security of wireless communication sessions. There is also analysis of the performance of AES (aka Rijndael) in its AES\u2013CCMP implementation. The 2-way interleaving technique is an optimization of the CBC-MAC that is investigated using two performance metrics (namely encryption time and throughput).", "num_citations": "8\n", "authors": ["1329"]}
{"title": "The relationship between code smells and traceable patterns\u2014are they measuring the same thing?\n", "abstract": " It is important to maintain software quality as a software system evolves. Managing code smells in source code contributes towards quality software. While metrics have been used to pinpoint code smells in source code, we present an empirical study on the correlation of code smells with class-level (micro pattern) and method-level (nano-pattern) traceable code patterns. This study explores the relationship between code smells and class-level and method-level structural code constructs. We extracted micro patterns at the class level and nano-patterns at the method level from three versions of Apache Tomcat, three versions of Apache CXF and two J2EE web applications namely PersonalBlog and Roller from Stanford SecuriBench and then compared their distributions in code smell versus noncode smell classes and methods. We found that Immutable and Sink micro patterns are more frequent in classes having\u00a0\u2026", "num_citations": "7\n", "authors": ["1329"]}
{"title": "The Relationship between Traceable Code Patterns and Code Smells\n", "abstract": " Context: It is important to maintain software quality as a software system evolves. Managing code smells in source code contributes towards quality software. While metrics have been used to pinpoint code smells in source code, we present an empirical study on the correlation of code smells with class-level (micro pattern) and methodlevel (nano-pattern) traceable patterns of code. Objective: This study explores the relationship between code smells and class-level and method-level structural code constructs. Method: We extracted micro patterns at the class level and nano-patterns at the method level from three versions of Apache Tomcat and PersonalBlog and Roller from Standford SecuriBench and compared their distributions in code smell versus non-code smell classes and methods. Result: We found that DataManager, Record and Outline micro patterns are more frequent in classes having code smell compared to non-code smell classes in the applications we analyzed. localReader, localW riter, Switcher, and ArrReader nano-patterns are more frequent in code smell methods compared to the non-code smell methods. Conclusion: We conclude that code smells are correlated with both micro and nano-patterns.", "num_citations": "5\n", "authors": ["1329"]}
{"title": "Performance of interleaved cipher block chaining in CCMP\n", "abstract": " Nowadays, the increased use of battery-powered mobile appliances and the urge to access sensitive data anywhere has fuelled the demand for wireless networks. However, wireless network is susceptible to intrusion and security problems. There is an inherent need to secure the wireless data communication to ensure the confidentiality, authenticity, integrity and non repudiation of the data being exchanged. On the other hand, the computation and energy cost to achieve security can be high as encryption algorithms are generally computationally intensive, thus consuming a significant amount of computing resources such as CPU time, memory, and battery power. Considering the very limited resources on wireless devices, it is crucial implement security protocols efficiently. This work focuses on how the energy consumption of execution is impacted by the use of unoptimzsed AES-CCMP algorithm and\u00a0\u2026", "num_citations": "5\n", "authors": ["1329"]}
{"title": "Profiling Developers Through the Lens of Technical Debt\n", "abstract": " Context: Technical Debt needs to be managed to avoid disastrous consequences, and investigating developers' habits concerning technical debt management is invaluable information in software development. Objective: This study aims to characterize how developers manage technical debt based on the code smells they induce and the refactorings they apply. Method: We mined a publicly-available Technical Debt dataset for Git commit information, code smells, coding violations, and refactoring activities for each developer of a selected project. Results: By combining this information, we profile developers to recognize prolific coders, highlight activities that discriminate among developer roles (reviewer, lead, architect), and estimate coding maturity and technical debt tolerance.", "num_citations": "2\n", "authors": ["1329"]}
{"title": "Examining the Relationship of Code and Architectural Smells with Software Vulnerabilities\n", "abstract": " Context: Security is vital to software developed for commercial or personal use. Although more organizations are realizing the importance of applying secure coding practices, in many of them, security concerns are not known or addressed until a security failure occurs. The root cause of security failures is vulnerable code. While metrics have been used to predict software vulnerabilities, we explore the relationship between code and architectural smells with security weaknesses. As smells are surface indicators of a deeper problem in software, determining the relationship between smells and software vulnerabilities can play a significant role in vulnerability prediction models. Objective: This study explores the relationship between smells and software vulnerabilities to identify the smells. Method: We extracted the class, method, file, and package level smells for three systems: Apache Tomcat, Apache CXF, and\u00a0\u2026", "num_citations": "1\n", "authors": ["1329"]}