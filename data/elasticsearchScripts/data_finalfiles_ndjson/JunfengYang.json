{"title": "MODIST: Transparent model checking of unmodified distributed systems\n", "abstract": " MODIST is the first model checker designed for transparently checking unmodified distributed systems running on unmodified operating systems. It achieves this transparency via a novel architecture: a thin interposition layer exposes all actions in a distributed system and a centralized, OS-independent model checking engine explores these actions systematically. We made MODIST practical through three techniques: an execution engine to simulate consistent, deterministic executions and failures; a virtual clock mechanism to avoid false positives and false negatives; and a state exploration framework to incorporate heuristics for efficient error detection. We implemented MODIST on Windows and applied it to three well-tested distributed systems: Berkeley DB, a widely used open source database; MPS, a deployed Paxos implementation; and PACIFICA, a primary-backup replication protocol implementation. MODIST found 35 bugs in total. Most importantly, it found protocol-level bugs (ie, flaws in the core distributed protocols) in every system checked: 10 in total, including 2 in Berkeley DB, 2 in MPS, and 6 in PACIFICA.", "num_citations": "279\n", "authors": ["457"]}
{"title": "Stable deterministic multithreading through schedule memoization\n", "abstract": " A deterministic multithreading (DMT) system eliminates nondeterminism in thread scheduling, simplifying the development of multithreaded programs. However, existing DMT systems are unstable; they may force a program to (ad) venture into vastly different schedules even for slightly different inputs or execution environments, defeating many benefits of determinism. Moreover, few existing DMT systems work with server programs whose inputs arrive continuously and nondeterministically. TERN is a stable DMT system. The key novelty in TERN is the idea of schedule memoization that memoizes past working schedules and reuses them on future inputs, making program behaviors stable across different inputs. A second novelty in TERN is the idea of windowing that extends schedule memoization to server programs by splitting continuous request streams into windows of requests. Our TERN implementation runs on Linux. It operates as user-space schedulers, requiring no changes to the OS and only a few lines of changes to the application programs. We evaluated TERN on a diverse set of 14 programs (eg, Apache and MySQL) with real and synthetic workloads. Our results show that TERN is easy to use, makes programs more deterministic and stable, and has reasonable overhead.", "num_citations": "133\n", "authors": ["457"]}
{"title": "Towards making systems forget with machine unlearning\n", "abstract": " Today's systems produce a rapidly exploding amount of data, and the data further derives more data, forming a complex data propagation network that we call the data's lineage. There are many reasons that users want systems to forget certain data including its lineage. From a privacy perspective, users who become concerned with new privacy risks of a system often want the system to forget their data and lineage. From a security perspective, if an attacker pollutes an anomaly detector by injecting manually crafted data into the training data set, the detector must forget the injected data to regain security. From a usability perspective, a user can remove noise and incorrect entries so that a recommendation engine gives useful recommendations. Therefore, we envision forgetting systems, capable of forgetting certain data and their lineages, completely and quickly. This paper focuses on making learning systems forget\u00a0\u2026", "num_citations": "123\n", "authors": ["457"]}
{"title": "Shuffler: Fast and deployable continuous code re-randomization\n", "abstract": " While code injection attacks have been virtually eliminated on modern systems, programs today remain vulnerable to code reuse attacks. Particularly pernicious are Just-In-Time ROP (JIT-ROP) techniques, where an attacker uses a memory disclosure vulnerability to discover code gadgets at runtime. We designed a code-reuse defense, called Shuffler, which continuously re-randomizes code locations on the order of milliseconds, introducing a real-time deadline on the attacker. This deadline makes it extremely difficult to form a complete exploit, particularly against server programs that often sit tens of milliseconds away from attacker machines.", "num_citations": "120\n", "authors": ["457"]}
{"title": "Practical software model checking via dynamic interface reduction\n", "abstract": " Implementation-level software model checking explores the state space of a system implementation directly to find potential software defects without requiring any specification or modeling. Despite early successes, the effectiveness of this approach remains severely constrained due to poor scalability caused by state-space explosion. DeMeter makes software model checking more practical with the following contributions:(i) proposing dynamic interface reduction, a new state-space reduction technique,(ii) introducing a framework that enables dynamic interface reduction in an existing model checker with a reasonable amount of effort, and (iii) providing the framework with a distributed runtime engine that supports parallel distributed model checking.", "num_citations": "112\n", "authors": ["457"]}
{"title": "Efficiently, effectively detecting mobile app bugs with appdoctor\n", "abstract": " Mobile apps bring unprecedented levels of convenience, yet they are often buggy, and their bugs offset the convenience the apps bring. A key reason for buggy apps is that they must handle a vast variety of system and user actions such as being randomly killed by the OS to save resources, but app developers, facing tough competitions, lack time to thoroughly test these actions. AppDoctor is a system for efficiently and effectively testing apps against many system and user actions, and helping developers diagnose the resultant bug reports. It quickly screens for potential bugs using approximate execution, which runs much faster than real execution and exposes bugs but may cause false positives. From the reports, AppDoctor automatically verifies most bugs and prunes most false positives, greatly saving manual inspection effort. It uses action slicing to further speed up bug diagnosis. We implement AppDoctor in\u00a0\u2026", "num_citations": "109\n", "authors": ["457"]}
{"title": "Efficient deterministic multithreading through schedule relaxation\n", "abstract": " Deterministic multithreading (DMT) eliminates many pernicious software problems caused by nondeterminism. It works by constraining a program to repeat the same thread interleavings, or schedules, when given same input. Despite much recent research, it remains an open challenge to build both deterministic and efficient DMT systems for general programs on commodity hardware. To deterministically resolve a data race, a DMT system must enforce a deterministic schedule of shared memory accesses, or mem-schedule, which can incur prohibitive overhead. By using schedules consisting only of synchronization operations, or sync-schedule, this overhead can be avoided. However, a sync-schedule is deterministic only for race-free programs, but most programs have races.", "num_citations": "100\n", "authors": ["457"]}
{"title": "Optimizing Data Partitioning for Data-Parallel Computing.\n", "abstract": " Performance of data-parallel computing (eg, MapReduce, DryadLINQ) heavily depends on its data partitions. Solutions implemented by the current state of the art systems are far from optimal. Techniques proposed by the database community to find optimal data partitions are not directly applicable when complex user-defined functions and data models are involved. We outline our solution, which draws expertise from various fields such as programming languages and optimization, and present our preliminary results.", "num_citations": "85\n", "authors": ["457"]}
{"title": "Metric learning for adversarial robustness\n", "abstract": " Deep networks are well-known to be fragile to adversarial attacks. We conduct an empirical analysis of deep representations under the state-of-the-art attack method called PGD, and find that the attack causes the internal representation to shift closer to the \"false\" class. Motivated by this observation, we propose to regularize the representation space under attack with metric learning to produce more robust classifiers. By carefully sampling examples for metric learning, our learned representation not only increases robustness, but also detects previously unseen adversarial samples. Quantitative experiments show improvement of robustness accuracy by up to 4% and detection efficiency by up to 6% according to Area Under Curve score over prior work. The code of our work is available at https://github.com/columbia/Metric_Learning_Adversarial_Robustness.", "num_citations": "78\n", "authors": ["457"]}
{"title": "Bypassing races in live applications with execution filters\n", "abstract": " Deployed multithreaded applications contain many races because these applications are difficult to write, test, and debug. Worse, the number of races in deployed applications may drastically increase due to the rise of multicore hardware and the immaturity of current race detectors. LOOM is a \u201clive-workaround\u201d system designed to quickly and safely bypass application races at runtime. LOOM provides a flexible and safe language for developers to write execution filters that explicitly synchronize code. It then uses an evacuation algorithm to safely install the filters to live applications to avoid races. It reduces its performance overhead using hybrid instrumentation that combines static and dynamic instrumentation. We evaluated LOOM on nine real races from a diverse set of six applications, including MySQL and Apache. Our results show that (1) LOOM can safely fix all evaluated races in a timely manner, thereby increasing application availability;(2) LOOM incurs little performance overhead;(3) LOOM scales well with the number of application threads; and (4) LOOM is easy to use.", "num_citations": "74\n", "authors": ["457"]}
{"title": "Concurrency attacks\n", "abstract": " Just as errors in sequential programs can lead to security exploits, errors in concurrent programs can lead to concurrency attacks. Questions such as whether these attacks are feasible and what characteristics they have remain largely unknown. In this paper, we present a preliminary study of concurrency attacks and the security implications of real world concurrency errors. Our study yields several interesting findings. For instance, we observe that the exploitability of a concurrency error depends on the duration of the timing window within which the error may occur. We further observe that attackers can increase this window through carefully crafted inputs. We also find that four out of five commonly used sequential defenses become unsafe when applied to concurrent programs. Based on our findings, we propose new defense directions and fixes to existing defenses.", "num_citations": "73\n", "authors": ["457"]}
{"title": "Verifying Systems Rules Using Rule-Directed Symbolic Execution\n", "abstract": " Systems code must obey many rules, such as \"opened files must be closed.\" One approach to verifying rules is static analysis, but this technique cannot infer precise runtime effects of code, often emitting many false positives. An alternative is symbolic execution, a technique that verifies program paths over all inputs up to a bounded size. However, when applied to verify rules, existing symbolic execution systems often blindly explore many redundant program paths while missing relevant ones that may contain bugs. Our key insight is that only a small portion of paths are relevant to rules, and the rest (majority) of paths are irrelevant and do not need to be verified. Based on this insight, we create WOODPECKER, a new symbolic execution system for effectively checking rules on systems programs. It provides a set of builtin checkers for common rules, and an interface for users to easily check new rules. It directs\u00a0\u2026", "num_citations": "71\n", "authors": ["457"]}
{"title": "Scalable and systematic detection of buggy inconsistencies in source code\n", "abstract": " Software developers often duplicate source code to replicate functionality. This practice can hinder the maintenance of a software project: bugs may arise when two identical code segments are edited inconsistently. This paper presents DejaVu, a highly scalable system for detecting these general syntactic inconsistency bugs.", "num_citations": "66\n", "authors": ["457"]}
{"title": "Kinesis: A new approach to replica placement in distributed storage systems\n", "abstract": " Kinesis is a novel data placement model for distributed storage systems. It exemplifies three design principles: structure (division of servers into a few failure-isolated segments), freedom of choice (freedom to allocate the best servers to store and retrieve data based on current resource availability), and scattered distribution (independent, pseudo-random spread of replicas in the system). These design principles enable storage systems to achieve balanced utilization of storage and network resources in the presence of incremental system expansions, failures of single and shared components, and skewed distributions of data size and popularity. In turn, this ability leads to significantly reduced resource provisioning costs, good user-perceived response times, and fast, parallelized recovery from independent and correlated failures. This article validates Kinesis through theoretical analysis, simulations, and\u00a0\u2026", "num_citations": "55\n", "authors": ["457"]}
{"title": "Paxos made transparent\n", "abstract": " State machine replication (SMR) leverages distributed consensus protocols such as Paxos to keep multiple replicas of a program consistent in face of replica failures or network partitions. This fault tolerance is enticing on implementing a principled SMR system that replicates general programs, especially server programs that demand high availability. Unfortunately, SMR assumes deterministic execution, but most server programs are multithreaded and thus nondeterministic. Moreover, existing SMR systems provide narrow state machine interfaces to suit specific programs, and it can be quite strenuous and error-prone to orchestrate a general program into these interfaces", "num_citations": "52\n", "authors": ["457"]}
{"title": "Optimizing data partitioning for data-parallel computing\n", "abstract": " Performance of data-parallel computing (eg, MapReduce, DryadLINQ) heavily depends on its data partitions. Solutions implemented by the current state of the art systems are far from optimal. Techniques proposed by the database community to find optimal data partitions are not directly applicable when complex user-defined functions and data models are involved. We outline our solution, which draws expertise from various fields such as programming languages and optimization, and present our preliminary results.", "num_citations": "51\n", "authors": ["457"]}
{"title": "Making parallel programs reliable with stable multithreading\n", "abstract": " Stable multithreading dramatically simplifies the interleaving behaviors of parallel programs, offering new hope for making parallel programming easier.", "num_citations": "42\n", "authors": ["457"]}
{"title": "Overload control for scaling wechat microservices\n", "abstract": " Effective overload control for large-scale online service system is crucial for protecting the system backend from overload. Conventionally the design of overload control is ad-hoc for individual service. However, service-specific overload control could be detrimental to the overall system due to intricate service dependencies or flawed implementation of service. Service developers usually have difficulty to accurately estimate the dynamics of actual workload during the development of service. Therefore, it is essential to decouple the overload control from service logic. In this paper, we propose DAGOR, an overload control scheme designed for the account-oriented microservice architecture. DAGOR is service agnostic and system-centric. It manages overload at the microservice granule such that each microservice monitors its load status in real time and triggers load shedding in a collaborative manner among its\u00a0\u2026", "num_citations": "41\n", "authors": ["457"]}
{"title": "Sound and precise analysis of parallel programs through schedule specialization\n", "abstract": " Parallel programs are known to be difficult to analyze. A key reason is that they typically have an enormous number of execution interleavings, or schedules. Static analysis over all schedules requires over-approximations, resulting in poor precision; dynamic analysis rarely covers more than a tiny fraction of all schedules. We propose an approach called schedule specialization to analyze a parallel program over only a small set of schedules for precision, and then enforce these schedules at runtime for soundness of the static analysis results. We build a schedule specialization framework for C/C++ multithreaded programs that use Pthreads. Our framework avoids the need to modify every analysis to be schedule-aware by specializing a program into a simpler program based on a schedule, so that the resultant program can be analyzed with stock analyses for improved precision. Moreover, our framework provides a\u00a0\u2026", "num_citations": "39\n", "authors": ["457"]}
{"title": "AppFlow: using machine learning to synthesize robust, reusable UI tests\n", "abstract": " UI testing is known to be difficult, especially as today\u2019s development cycles become faster. Manual UI testing is tedious, costly and error-prone. Automated UI tests are costly to write and maintain. This paper presents AppFlow, a system for synthesizing highly robust, highly reusable UI tests. It leverages machine learning to automatically recognize common screens and widgets, relieving developers from writing ad hoc, fragile logic to use them in tests. It enables developers to write a library of modular tests for the main functionality of an app category (eg, an \u201cadd to cart\u201d test for shopping apps). It can then quickly test a new app in the same category by synthesizing full tests from the modular ones in the library. By focusing on the main functionality, AppFlow provides \u201csmoke testing\u201d requiring little manual work. Optionally, developers can customize AppFlow by adding app-specific tests for completeness. We evaluated\u00a0\u2026", "num_citations": "35\n", "authors": ["457"]}
{"title": "Pervasive detection of process races in deployed systems\n", "abstract": " Process races occur when multiple processes access shared operating system resources, such as files, without proper synchronization. We present the first study of real process races and the first system designed to detect them. Our study of hundreds of applications shows that process races are numerous, difficult to debug, and a real threat to reliability. To address this problem, we created RacePro, a system for automatically detecting these races. RacePro checks deployed systems in-vivo by recording live executions then deterministically replaying and checking them later. This approach increases checking coverage beyond the configurations or executions covered by software vendors or beta testing sites. RacePro records multiple processes, detects races in the recording among system calls that may concurrently access shared kernel objects, then tries different execution orderings of such system calls to\u00a0\u2026", "num_citations": "34\n", "authors": ["457"]}
{"title": "Android malware static analysis techniques\n", "abstract": " During 2014, Business Insider announced that there are over a billion users of Android worldwide. Government officials are also trending towards acquiring Android mobile devices. Google's application architecture is already ubiquitous and will keep expanding. The beauty of an application-based architecture is the flexibility, interoperability and customizability it provides users. This same flexibility, however, also allows and attracts malware development.", "num_citations": "31\n", "authors": ["457"]}
{"title": "Egalito: Layout-agnostic binary recompilation\n", "abstract": " For comprehensive analysis of all executable code, and fast turn-around time for transformations, it is essential to operate directly on binaries to enable profiling, security hardening, and architectural adaptation. Disassembling binaries is difficult, and prior work relies on a process virtual machine to translate references on the fly or inefficient binary code patching. Our Egalito recompiler leverages metadata present in current stripped x86_64 and ARM64 binaries to generate a complete disassembly, and allows arbitrary modifications that may affect program layout without any constraints from the original binary. We utilize our own layout-agnostic intermediate representation, which is low-level enough to make the regeneration of output code predictable, yet supports a dual high-level representation for sophisticated analysis. We demonstrate nine binary tools including a novel continuous code randomization technique\u00a0\u2026", "num_citations": "30\n", "authors": ["457"]}
{"title": "Multitask learning strengthens adversarial robustness\n", "abstract": " Although deep networks achieve strong accuracy on a range of computer vision benchmarks, they remain vulnerable to adversarial attacks, where imperceptible input perturbations fool the network. We present both theoretical and empirical analyses that connect the adversarial robustness of a model to the number of tasks that it is trained on. Experiments on two datasets show that attack difficulty increases as the number of target tasks increase. Moreover, our results suggest that when models are trained on multiple tasks at once, they become more robust to adversarial attacks on individual tasks. While adversarial defense remains an open challenge, our results suggest that deep networks are vulnerable partly because they are trained on too few tasks.", "num_citations": "25\n", "authors": ["457"]}
{"title": "Reducing crash recoverability to reachability\n", "abstract": " Software applications run on a variety of platforms (filesystems, virtual slices, mobile hardware, etc.) that do not provide 100% uptime. As such, these applications may crash at any unfortunate moment losing volatile data and, when re-launched, they must be able to correctly recover from potentially inconsistent states left on persistent storage. From a verification perspective, crash recovery bugs can be particularly frustrating because, even when it has been formally proved for a program that it satisfies a property, the proof is foiled by these external events that crash and restart the program. In this paper we first provide a hierarchical formal model of what it means for a program to be crash recoverable. Our model captures the recoverability of many real world programs, including those in our evaluation which use sophisticated recovery algorithms such as shadow paging and write-ahead logging. Next, we introduce a\u00a0\u2026", "num_citations": "24\n", "authors": ["457"]}
{"title": "Secure deduplication of general computations\n", "abstract": " The world\u2019s fast-growing data has become highly concentrated on enterprise or cloud storage servers. Data deduplication reduces redundancy in this data, saving storage and simplifying management. While existing systems can deduplicate computations on this data by memoizing and reusing computation results, they are insecure, not general, or slow.", "num_citations": "24\n", "authors": ["457"]}
{"title": "Effective dynamic detection of alias analysis errors\n", "abstract": " Alias analysis is perhaps one of the most crucial and widely used analyses, and has attracted tremendous research efforts over the years. Yet, advanced alias analyses are extremely difficult to get right, and the bugs in these analyses are one key reason that they have not been adopted to production compilers. This paper presents NeonGoby, a system for effectively detecting errors in alias analysis implementations, improving their correctness and hopefully widening their adoption. NeonGoby detects the worst type of bugs where the alias analysis claims that two pointers never alias, but they actually alias at runtime. NeonGoby works by dynamically observing pointer addresses during the execution of a test program and then checking these addresses against an alias analysis for errors. It is explicitly designed to (1) be agnostic to the alias analysis it checks for maximum applicability and ease of use and (2) detect\u00a0\u2026", "num_citations": "24\n", "authors": ["457"]}
{"title": "Methods, systems, and media for providing determinism in multithreaded programs\n", "abstract": " Methods, systems, and media for providing determinism in multithreaded programs are provided. In some embodiments, methods for providing determinism in multithreaded programs are provided, the methods comprising: instrumenting a program with: a proxy that: receives inputs to the program; and determines whether a schedule corresponding to a set of input constraints satisfied by the inputs has been memoized; and a replayer that: if it is determined that a schedule corresponding to a set of input constraints satisfied by the inputs has been memoized, processes the inputs by the program according to the schedule.", "num_citations": "20\n", "authors": ["457"]}
{"title": "FIRED: frequent inertial resets with diversification for emerging commodity cyber-physical systems\n", "abstract": " A Cyber-Physical System (CPS) is defined by its unique characteristics involving both the cyber and physical domains. Their hybrid nature introduces new attack vectors, but also provides an opportunity to design new security defenses. In this paper, we present a new domain-specific security mechanism, FIRED, that leverages physical properties such as inertia of the CPS to improve security. FIRED is simple to describe and implement. It goes through two operations: Reset and Diversify, as frequently as possible -- typically in the order of seconds or milliseconds. The combined effect of these operations is that attackers are unable to gain persistent control of the system. The CPS stays safe and stable even under frequent resets because of the inertia present. Further, resets simplify certain diversification mechanisms and makes them feasible to implement in CPSs with limited computing resources. We evaluate our idea on two real-world systems: an engine management unit of a car and a flight controller of a quadcopter. Roughly speaking, these two systems provide typical and extreme operational requirements for evaluating FIRED in terms of stability, algorithmic complexity, and safety requirements. We show that FIRED provides robust security guarantees against hijacking attacks and persistent CPS threats. We find that our defense is suitable for emerging CPS such as commodity unmanned vehicles that are currently unregulated and cost sensitive.", "num_citations": "17\n", "authors": ["457"]}
{"title": "Data and replica placement using r-out-of-k hash functions\n", "abstract": " A distributed data store employs replica placement techniques in which a number k hash functions are used to compute k potential locations for a data item. A number r of the k locations are chosen for storing replicas. These replica placement techniques provide a system designer with the freedom to choose r from k, are structured in that they are determined by a straightforward functional form, and are diffuse such that the replicas of the items on one server are scattered over many other servers. The resulting storage system exhibits excellent storage balance and request load balance in the presence of incremental system expansions, server failures, and load changes. Data items may be created, read, and updated or otherwise modified.", "num_citations": "17\n", "authors": ["457"]}
{"title": "Efficient repair of polluted machine learning systems via causal unlearning\n", "abstract": " Machine learning systems, though being successful in many real-world applications, are known to remain prone to errors and attacks. A major attack, called data pollution, injects maliciously crafted training data samples into the training set, causing the system to learn an incorrect model and subsequently misclassify testing samples. A natural solution to a data pollution attack is to remove the polluted data from the training set and relearn a clean model. Unfortunately, the training set of a real-world machine learning system can contain millions of samples; it is thus hopeless for an administrator to manually inspect all of them to weed out the polluted ones.", "num_citations": "16\n", "authors": ["457"]}
{"title": "Systems and methods for efficiently and effectively detecting mobile app bugs\n", "abstract": " The disclosed subject matter provides techniques for detecting and diagnosing mobile app bugs. An approximate execution mode screens for potential bugs, which can expose bugs but can generate false positives. From the generated bug reports, certain bugs can be automatically validated and false positives pruned, reducing the need for manual inspection.", "num_citations": "16\n", "authors": ["457"]}
{"title": "Determinism is overrated: What really makes multithreaded programs hard to get right and what can be done about it\n", "abstract": " Our accelerating computational demand and the rise of multicore hardware have made parallel programs, especially shared-memory multithreaded programs, increasingly pervasive and critical. Yet, these programs remain extremely difficult to write, test, analyze, debug, and verify. Conventional wisdom has attributed these difficulties to nondeterminism, and researchers have recently dedicated much effort to bringing determinism into multithreading. In this paper, we argue that determinism is not as useful as commonly perceived: it is neither sufficient nor necessary for reliability. We present our view on why multithreaded programs are difficult to get right, describe a promising approach we call stable multithreading to dramatically improve reliability, and summarize our last four years\u2019 research on building and applying stable multithreading systems.", "num_citations": "12\n", "authors": ["457"]}
{"title": "Live Trojan attacks on deep neural networks\n", "abstract": " Like all software systems, the execution of deep learning models is dictated in part by logic represented as data in memory. For decades, attackers have exploited traditional software programs by manipulating this data. We propose a live attack on deep learning systems that patches model parameters in memory to achieve predefined malicious behavior on a certain set of inputs. By minimizing the size and number of these patches, the attacker can reduce the amount of network communication and memory overwrites, with minimal risk of system malfunctions or other detectable side effects. We demonstrate the feasibility of this attack by computing efficient patches on multiple deep learning models. We show that the desired trojan behavior can be induced with a few small patches and with limited access to training data. We describe the details of how this attack is carried out on real systems and provide sample code for patching TensorFlow model parameters in Windows and in Linux. Lastly, we present a technique for effectively manipulating entropy on perturbed inputs to bypass STRIP, a state-of-the-art run-time trojan detection technique.", "num_citations": "11\n", "authors": ["457"]}
{"title": "Partial order aware concurrency sampling\n", "abstract": " We present POS, a concurrency testing approach that samples the partial order of concurrent programs. POS uses a novel priority-based scheduling algorithm that dynamically reassigns priorities regarding the partial order information and formally ensures that each partial order will be explored with significant probability. POS is simple to implement and provides a probabilistic guarantee of error detection better than state-of-the-art sampling approaches. Evaluations show that POS is effective in covering the partial-order space of micro-benchmarks and finding concurrency bugs in real-world programs, such as Firefox\u2019s JavaScript engine SpiderMonkey.", "num_citations": "11\n", "authors": ["457"]}
{"title": "Lambdata: Optimizing Serverless Computing by Making Data Intents Explicit\n", "abstract": " Serverless computing emerges as a new paradigm to build cloud applications, in which developers write small functions that react to cloud infrastructure events, and cloud providers maintain all resources and schedule the functions in containers. Serverless computing thus enables developers to focus on their core business logic and leave server management and scaling to cloud providers. Unfortunately, existing serverless computing systems suffer from a key limitation that deprives them of enjoying significant speedups. Specifically, they treat each cloud function as a black box and are blind to which data the function reads or writes, therefore missing potentially huge optimization opportunities, such as caching data and colocating functions. We present Lambdata, a novel serverless computing system that enables developers to declare a cloud function's data intents, including both data read and data written. Once\u00a0\u2026", "num_citations": "10\n", "authors": ["457"]}
{"title": "Owl: Understanding and detecting concurrency attacks\n", "abstract": " Just like bugs in single-threaded programs can lead to vulnerabilities, bugs in multithreaded programs can also lead to concurrency attacks. We studied 31 real-world concurrency attacks, including privilege escalations, hijacking code executions, and bypassing security checks. We found that compared to concurrency bugs' traditional consequences (e.g., program crashes), concurrency attacks' consequences are often implicit, extremely hard to be observed and diagnosed by program developers. Moreover, in addition to bug-inducing inputs, extra subtle inputs are often needed to trigger the attacks. These subtle features make existing tools ineffective to detect concurrency attacks. To tackle this problem, we present OWL, the first practical tool that models general concurrency attacks' implicit consequences and automatically detects them. We implemented OWL in Linux and successfully detected five new\u00a0\u2026", "num_citations": "10\n", "authors": ["457"]}
{"title": "Methods, systems, and media for protecting applications from races\n", "abstract": " Methods, systems, and media for protecting applications from races are provided. In some embodiments, methods for protecting applications from races are provided, the methods comprising: adding to at least one cycle of the application an update check to determine when an update to the application is to be made; adding an update engine to the application, wherein the update engine is configured to: receive an update plan that is based on an execution filter that specifies how operations of the application are to be synchronized; and cause synchronization operations to be added to the application based on the update plan that prevent the race from occurring.", "num_citations": "10\n", "authors": ["457"]}
{"title": "Systems and methods for improving performance of mobile applications\n", "abstract": " Systems and methods for improving the performance of mobile applications are disclosed. An exemplary method can include receiving a request for the application, where the request can include target device information. The method can also determine whether the application has been cached before. If the application has not been cached, the method can download the application as a bytecode and process the bytecode into the native code format, using an Ahead-of-time compiler. The method can also provide the application in the native code format to the target device over the network.", "num_citations": "7\n", "authors": ["457"]}
{"title": "Effective Concurrency Testing for Distributed Systems\n", "abstract": " Despite their wide deployment, distributed systems remain notoriously hard to reason about. Unexpected interleavings of concurrent operations and failures may lead to undefined behaviors and cause serious consequences. We present Morpheus, the first concurrency testing tool leveraging partial order sampling, a randomized testing method formally analyzed and empirically validated to provide strong probabilistic guarantees of error-detection, for real-world distributed systems. Morpheus introduces conflict analysis to further improve randomized testing by predicting and focusing on operations that affect the testing result. Inspired by the recent shift in building distributed systems using higher-level languages and frameworks, Morpheus targets Erlang. Evaluation on four popular distributed systems in Erlang including RabbitMQ, a message broker service, and Mnesia, a distributed database in the Erlang standard\u00a0\u2026", "num_citations": "6\n", "authors": ["457"]}
{"title": "Grandet: A unified, economical object store for web applications\n", "abstract": " Web applications are getting ubiquitous every day because they offer many useful services to consumers and businesses. Many of these web applications are quite storage-intensive. Cloud computing offers attractive and economical choices for meeting their storage needs. Unfortunately, it remains challenging for developers to best leverage them to minimize cost. This paper presents Grandet, an extensible storage system that significantly reduces storage cost for web applications deployed in the cloud. Grandet provides both a key-value interface and a file system interface, supporting a broad spectrum of web applications. Under the hood, it supports multiple heterogeneous stores and unifies them by placing each data object at the store deemed most economical. We implemented Grandet on Amazon Web Services and evaluated Grandet on a diverse set of four popular open-source web applications. Our results\u00a0\u2026", "num_citations": "6\n", "authors": ["457"]}
{"title": "The sparchs project: Hardware support for software security\n", "abstract": " The SPARCHS project is considering a new computer systems design methodology that considers security as a first-order design requirement at all levels, starting from hardware, in addition to the usual design requirements such as programmability, usability, speed, and power/energy- efficiency. The rest of the paper describes the proposed hardware security mechanisms and the current status of the project.", "num_citations": "6\n", "authors": ["457"]}
{"title": "Codemason: Binary-level profile-guided optimization\n", "abstract": " Optimizing a program for a specific machine or a specific workload is possible with today's compilers, but infrequently used, despite significant performance gains. We implement workload specialization, or Profile-Guided Optimization (PGO), at the binary level. Our system CodeMason runs on x86_64 Linux and is based on a binary rewriting platform called Egalito. CodeMason performs static binary rewriting to obtain program profiles, then adjusts function ordering, alignment, and other binary-level details to achieve faster performance (particularly on the given workload). We obtain 1.98% average performance speedup on SPEC CPU 2006, and 11.8% speedup in the best case. These substantial performance improvements suggest that binary-level PGO may be widely useful when compiler-based PGO is impossible because the source code is inaccessible.", "num_citations": "5\n", "authors": ["457"]}
{"title": "YOLO: frequently resetting cyber-physical systems for security\n", "abstract": " A Cyber-Physical System (CPS) is defined by its unique interactions between digital (cyber) computation and physical motion. Their hybrid nature introduces new attack vectors, but also provides an opportunity to design new security defenses. In this paper, we present a new domain-specific security mechanism, YOLO, that leverages physical properties such as inertia to improve security. YOLO is simple to describe. It goes through two operations: Reset and Diversify, as frequently as possible \u2013 typically in the order of a few seconds. Resets mitigate attacks that aim to achieve persistence and enhance the power of diversification techniques. Due to inertia, CPSs can remain safe even under frequent resets. We introduce an analytical approach to evaluate the feasibility of a YOLO-ized system. Using this analytical model we define the constraints on reset periods in order to maintain the CPS\u2019s stability. We evaluate our\u00a0\u2026", "num_citations": "5\n", "authors": ["457"]}
{"title": "Finding Concurrency Errors in Sequential Code-OS-level, In-vivo Model Checking of Process Races.\n", "abstract": " While thread races have drawn huge attention from the research community, little has been done for process races, where multiple\u2014possibly sequential\u2014processes access a shared resource, such as a file, without proper synchronization. We present a preliminary study of real process races and show that they are numerous, dangerous, and difficult to detect. To address this problem, we present the design of RACEPRO, an in-vivo model checking system for automatically detecting process races in deployed systems, along with preliminary results from a RACEPRO prototype. To the best of our knowledge, we are the first to study real process races, and RACEPRO is the first system to detect them.", "num_citations": "5\n", "authors": ["457"]}
{"title": "Repframe: An efficient and transparent framework for dynamic program analysis\n", "abstract": " Dynamic program analysis frameworks greatly improve software quality as they enable a wide range of powerful analysis tools (eg, reliability, profiling, and logging) at runtime. However, because existing frameworks run only one actual execution for each software application, the execution is fully or partially coupled with an analysis tool in order to transfer execution states (eg, accessed memory and thread interleavings) to the analysis tool, easily causing a prohibitive slowdown for the execution. To reduce the portions of execution states that require transfer, many frameworks require significantly carving analysis tools as well as the frameworks themselves. Thus, these frameworks significantly trade off transparency with analysis tools and allow only one type of tools to run within one execution.", "num_citations": "4\n", "authors": ["457"]}
{"title": "Generative interventions for causal learning\n", "abstract": " We introduce a framework for learning robust visual representations that generalize to new viewpoints, backgrounds, and scene contexts. Discriminative models often learn naturally occurring spurious correlations, which cause them to fail on images outside of the training distribution. In this paper, we show that we can steer generative models to manufacture interventions on features caused by confounding factors. Experiments, visualizations, and theoretical results show this method learns robust representations more consistent with the underlying causal relationships. Our approach improves performance on multiple datasets demanding out-of-distribution generalization, and we demonstrate state-of-the-art performance generalizing from ImageNet to ObjectNet dataset.", "num_citations": "3\n", "authors": ["457"]}
{"title": "BPF for storage: an exokernel-inspired approach\n", "abstract": " The overhead of the kernel storage path accounts for half of the access latency for new NVMe storage devices. We explore using BPF to reduce this overhead, by injecting user-defined functions deep in the kernel's I/O processing stack. When issuing a series of dependent I/O requests, this approach can increase IOPS by over 2.5 and cut latency by half, by bypassing kernel layers and avoiding user-kernel boundary crossings. However, we must avoid losing important properties when bypassing the file system and block layer such as the safety guarantees of the file system and translation between physical blocks addresses and file offsets. We sketch potential solutions to these problems, inspired by exokernel file systems from the late 90s, whose time, we believe, has finally come!", "num_citations": "2\n", "authors": ["457"]}
{"title": "Advspade: Realistic unrestricted attacks for semantic segmentation\n", "abstract": " Due to the inherent robustness of segmentation models, traditional norm-bounded attack methods show limited effect on such type of models. In this paper, we focus on generating unrestricted adversarial examples for semantic segmentation models. We demonstrate a simple and effective method to generate unrestricted adversarial examples using conditional generative adversarial networks (CGAN) without any hand-crafted metric. The na\\\"ive implementation of CGAN, however, yields inferior image quality and low attack success rate. Instead, we leverage the SPADE (Spatially-adaptive denormalization) structure with an additional loss item to generate effective adversarial attacks in a single step. We validate our approach on the popular Cityscapes and ADE20K datasets, and demonstrate that our synthetic adversarial examples are not only realistic, but also improve the attack success rate by up to 41.0\\% compared with the state of the art adversarial attack methods including PGD.", "num_citations": "2\n", "authors": ["457"]}
{"title": "Understanding and Detecting Concurrency Attacks\n", "abstract": " Just like bugs in single-threaded programs can lead to vulnerabilities, bugs in multithreaded programs can also lead to concurrency attacks. Unfortunately, there is little quantitative data on how well existing tools can detect these attacks. This paper presents the first quantitative study on concurrency attacks and their implications on tools. Our study on 10 widely used programs reveals 26 concurrency attacks with broad threats (eg, OS privilege escalation), and we built scripts to successfully exploit 10 attacks. Our study further reveals that, only extremely small portions of inputs and thread interleavings (or schedules) can trigger these attacks, and existing concurrency bug detectors work poorly because they lack help to identify the vulnerable inputs and schedules. Our key insight is that the reports in existing detectors have implied moderate hints on what inputs and schedules will likely lead to attacks and what will not (eg, benign bug reports). With this insight, this paper presents a new directed concurrency attack detection approach and its implementation, OWL. It extracts hints from the reports with static analysis, augments existing detectors by pruning out the benign inputs and schedules, and then directs detectors and its own runtime vulnerability verifiers to work on the remaining, likely vulnerable inputs and schedules. Evaluation shows that OWL reduced 94.3% reports caused by benign inputs or schedules and detected 7 known concurrency attacks. OWL also detected 3 previously unknown concurrency attacks, including a use-after-free attack in SSDB confirmed as CVE-2016-1000324, an integer overflow, HTML integrity violation in Apache\u00a0\u2026", "num_citations": "2\n", "authors": ["457"]}
{"title": "BPF for storage: an exokernel-inspired approach\n", "abstract": " The overhead of the kernel storage path accounts for half of the access latency for new NVMe storage devices. We explore using BPF to reduce this overhead, by injecting user-defined functions deep in the kernel's I/O processing stack. When issuing a series of dependent I/O requests, this approach can increase IOPS by over 2.5 X and cut latency by half, by bypassing kernel layers and avoiding user-kernel boundary crossings. However, we must avoid losing important properties when bypassing the file system and block layer such as the safety guarantees of the file system and translation between physical blocks addresses and file offsets. We sketch potential solutions to these problems, inspired by exokernel file systems from the late 90s, whose time, we believe, has finally come!", "num_citations": "1\n", "authors": ["457"]}
{"title": "What Does CNN Shift Invariance Look Like? A Visualization Study\n", "abstract": " Feature extraction with convolutional neural networks (CNNs) is a popular method to represent images for machine learning tasks. These representations seek to capture global image content, and ideally should be independent of geometric transformations. We focus on measuring and visualizing the shift invariance of extracted features from popular off-the-shelf CNN models. We present the results of three experiments comparing representations of millions of images with exhaustively shifted objects, examining both local invariance (within a few pixels) and global invariance (across the image frame). We conclude that features extracted from popular networks are not globally invariant, and that biases and artifacts exist within this variance. Additionally, we determine that anti-aliased models significantly improve local invariance but do not impact global invariance. Finally, we provide a code repository for\u00a0\u2026", "num_citations": "1\n", "authors": ["457"]}
{"title": "Unrestricted Adversarial Attacks for Semantic Segmentation\n", "abstract": " Despite the rapid development of adversarial attacks for machine learning models, many types of new adversarial examples still remain unknown. Uncovered types of adversarial attacks pose serious concern for the safety of the models, which raise the question about the effectiveness of current adversarial robustness evaluation. Semantic segmentation is one of the most impactful applications of machine learning; however, their robustness under adversarial attack is not well studied. In this paper, we focus on generating unrestricted adversarial examples for semantic segmentation models. We demonstrate a simple yet effective method to generate unrestricted adversarial examples using conditional generative adversarial networks (CGAN) without any hand-crafted metric. The naive implementation of CGAN, however, yields inferior image quality and low attack success rate. Instead, we leverage the SPADE\u00a0\u2026", "num_citations": "1\n", "authors": ["457"]}
{"title": "The SPARCHS Project\n", "abstract": " Current security research is largely oriented to top-down design, where the most exposed layers---the network/application layers---are first studied assuming the lower layers are secure, even when they are not. The lower layers are studied when new threats appear at those layers. Security, thus, has become an arms race to the bottom. For every software mitigation strategy today, vulnerabilities in the software layer below it can be used to attack and weaken the mitigation strategy. There are many examples of such attacks in the literature including those attacks that target anti-virus, libraries, operating systems, hypervisors, and BIOS routines.A solution to the above problem is to push the security mechanisms down to hardware, which is typically immutable. Growing on-chip transistor budgets provide the opportunity to explore this possibility. In addition to offering immutable security, there are two further advantages to implementing security mechanisms in hardware. First, hardware supported security mechanisms can be much more energy-efficient compared to software only mechanisms. Given that energy-and power-efficiency significantly influence computing today, hardware support could very well be necessary for security mechanisms to gain traction in many real world settings. Second, implementing security mechanisms in hardware can provide unmatched visibility into execution. This provides an opportunity for new security techniques.", "num_citations": "1\n", "authors": ["457"]}