{"title": "A fast and cache-timing resistant implementation of the AES\n", "abstract": " This work presents a fast bitslice implementation of the AES with 128-bit keys on processors with x64-architecture processing 4 blocks of input data in parallel. In contrast to previous work on this topic, our solution is described in detail from the general approach to the actual implementation. As the implementation does not need table-lookups it is immune to cache-timing attacks while being only 5% slower than the widely used optimized reference implementation. Outspeeding other approaches for making an implementation cache-timing resistant, the solution needs 8% less code memory and 93% less data memory than the reference implementation. Further improvements are possible.", "num_citations": "91\n", "authors": ["2109"]}
{"title": "Symbolically synthesizing small circuits\n", "abstract": " Reactive synthesis, where a finite-state system is automatically generated from its specification, is a particularly ambitious way to engineer correct-by-construction systems. In this paper, we propose implementation-extraction based on computational learning of Boolean functions as a final synthesis step in order to obtain small and fast circuits for realizable specifications in a symbolic way. Our starting point is a restriction of the system player's choices in a synthesis game such that all remaining strategies are winning. Such games are used in most symbolic synthesis tools, and hence, our technique is not tied to one specific synthesis workflow, but rather supports a large variety of these. We present several variants of our implementation-learning approach, including one based on Bshouty's monotone theory. The key idea is the efficient use of the system player's freedom in the game. Our experimental results show a\u00a0\u2026", "num_citations": "28\n", "authors": ["2109"]}
{"title": "Synthesis of admissible shields\n", "abstract": " Shield synthesis is an approach to enforce a set of safety-critical properties of a reactive system at runtime. A shield monitors the system and corrects any erroneous output values instantaneously. The shield deviates from the given outputs as little as it can and recovers to hand back control to the system as soon as possible. This paper takes its inspiration from a case study on mission planning for unmanned aerial vehicles (UAVs) in which k-stabilizing shields, which guarantee recovery in a finite time, could not be constructed. We introduce the notion of admissible shields, which improves k-stabilizing shields in two ways: (1) whereas k-stabilizing shields take an adversarial view on the system, admissible shields take a collaborative view. That is, if there is no shield that guarantees recovery within k steps regardless of system behavior, the admissible shield will attempt to work with the system to recover\u00a0\u2026", "num_citations": "7\n", "authors": ["2109"]}
{"title": "Debugging formal specifications with simplified counterstrategies\n", "abstract": " A formal specification is typically derived manually from an informal design intent. Due to mistakes in this process, the resulting specification may be incomplete, unrealizable, or in conflict with the design intent. This work proposes debugging techniques for the latter two cases in the context of temporal specifications for reactive systems.In order to debug conflicts between the formal specification and the informal design intent, the user has to understand the conflicts first. We show how the explanation of such conflicts can be reduced to the explanation of the unrealizability of a specification. Unrealizability is also interesting in its own right. Again, the user has to understand the problem before she can fix it. Our method for explaining unrealizability is based on the presentation of a counterstrategy, which illustrates the problem: If the input is chosen according to the counterstrategy, no behavior of the system can fulfill the specification. Counterstrategies may be complex and hard to understand for the user, especially for large specifications. Hence, we propose several ways to simplify them. First, we remove those requirements and signals from the specification which are not part of the problem. Second, we heuristically search for a countertrace. A countertrace is a single input trace for which no system can fulfill the specification. It can be thought of as a counterstrategy that is independent of the behavior of the system. Finally, we present the countertrace or the counterstrategy to the user in form of an interactive game and as a graph that summarizes all plays in this game. Our debugging method operates solely on the specification, ie, it does not require an\u00a0\u2026", "num_citations": "4\n", "authors": ["2109"]}
{"title": "Satisfiability-based methods for controller synthesis\n", "abstract": " Synthesis is an appealing approach to construct hardware or software programs: a correct implementation is computed automatically from a declarative specification. Controller synthesis is a variant where (most) parts of the implementation are given, and only certain signals need to be synthesized. This allows for a mix of imperative and declarative programming, often referred to as program sketching, but also other applications such as automatic program repair. This thesis focuses on efficient controller synthesis methods for both hardware and software using decision procedures for the satisfiability of formulas.In the hardware context, we focus on safety specifications. Existing synthesis approaches mostly use Binary Decision Diagrams (BDD s) as reasoning engine. In contrast, we present a number of novel algorithms that use decision procedures for propositional formulas (SAT solvers), Quantified Boolean Formulas (QBF solvers), or solvers for Effectively Propositional Logic (EPR). Our synthesis approach consists of two steps. The first step is to compute a strategy to satisfy the specification, where we present algorithms based on query learning, templates, reduction to EPR, and a parallelization that combines different methods. The second step is to compute a circuit implementing the strategy. Here, we present methods based on QBF certification, interpolation, query learning, and a parallelization as well. Our methods are augmented with numerous optimizations, including heuristics to expand quantifiers and to utilize unreachable states and variable independencies, down to low-level optimizations in the formula encoding. In an extensive\u00a0\u2026", "num_citations": "2\n", "authors": ["2109"]}
{"title": "Eine 8-bit Highspeed Softwareimplementierung von Whirlpool\n", "abstract": " Eine 8-bit Highspeed Softwareimplementierung von Whirlpool \u2014 Technische Universit\u00e4t Graz Zur Hauptnavigation wechseln Zur Suche wechseln Zum Hauptinhalt wechseln Technische Universit\u00e4t Graz Logo English Deutsch Home Personen Forschungsgruppen Ver\u00f6ffentlichungen Projekte Verwandte T\u00e4tigkeiten Pr\u00e4mien Presseberichte Eine 8-bit Highspeed Softwareimplementierung von Whirlpool Robert K\u00f6nighofer, Stefan Berger, Christoph Herbst Institut f\u00fcr Angewandte Informationsverarbeitung und Kommunikationstechnologie (7050) Publikation: Beitrag in Buch/Bericht/Konferenzband \u203a Beitrag in einem Konferenzband \u00dcbersicht (Administrator/-in) Originalsprache deutsch Titel DACH Security 2007 Herausgeber (Verlag) Syssec Seiten 459-470 ISBN (Print) 978-3-00-021600-8 Publikationsstatus Ver\u00f6ffentlicht - 2007 Veranstaltung Arbeitskonferenz DACH Security - Klagenfurt, \u00d6sterreich Dauer: 12 Jun 2007 \u2026", "num_citations": "1\n", "authors": ["2109"]}