{"title": "Detection strategies: Metrics-based rules for detecting design flaws\n", "abstract": " In order to support the maintenance of an object-oriented software system, the quality of its design must be evaluated using adequate quantification means. In spite of the current extensive use of metrics, if used in isolation metrics are oftentimes too fine grained to quantify comprehensively an investigated design aspect (e.g., distribution of system's intelligence among classes). To help developers and maintainers detect and localize design problems in a system, we propose a novel mechanism - called detection strategy - for formulating metrics-based rules that capture deviations from good design principles and heuristics. Using detection strategies an engineer can directly localize classes or methods affected by a particular design flaw (e.g., God Class), rather than having to infer the real design problem from a large set of abnormal metric values. We have defined such detection strategies for capturing around ten\u00a0\u2026", "num_citations": "721\n", "authors": ["65"]}
{"title": "Assessing technical debt by identifying design flaws in software systems\n", "abstract": " Tough time-to-market constraints and unanticipated integration or evolution issues lead to design tradeoffs that usually cause flaws in the structure of a software system. Thus, maintenance costs grow significantly. The impact of these design decisions, which provide short-term benefits at the expense of the system\u2019s design integrity, is usually referred to as technical debt. In this paper, I propose a novel framework for assessing technical debt using a technique for detecting design flaws, i.e., specific violations of well-established design principles and rules. To make the framework comprehensive and balanced, it is built on top of a set of metrics-based detection rules for well-known design flaws that cover all of the major aspects of design such as coupling, complexity, and encapsulation. I demonstrate the effectiveness of the framework by assessing the evolution of technical debt symptoms over a total of 63 releases of\u00a0\u2026", "num_citations": "193\n", "authors": ["65"]}
{"title": "Detecting design flaws via metrics in object-oriented systems\n", "abstract": " The industry is nowadays confronted with large-scale monolithic and inflexible object-oriented software. Because of their high business value, these legacy systems must be re-engineered. One of the important issues in re-engineering is the detection and location of design flaws, which prevent the efficient maintenance and further development of the system. In this paper, we present a metrics-based approach for detecting design problems, and we describe two concrete techniques for the detection of two well-known design flaws found in the literature. We apply our technique to an industrial case study and discuss the findings. The proposed technique indeed found real flaws in the system and the experiment suggests that, based on the same approach, further detection techniques for other common design flaws could be defined.", "num_citations": "160\n", "authors": ["65"]}
{"title": "Quantifying the quality of object-oriented design: The factor-strategy model\n", "abstract": " The quality of a design has a decisive impact on the quality of a software product; but due to the diversity and complexity of design properties (e.g., coupling, encapsulation), their assessment and correlation with external quality attributes (e.g., maintenance, portability) is hard. In contrast to traditional quality models that express the \"goodness\" of design in terms of a set of metrics, the novel Factor-Strategy model proposed by This work, relates explicitly the quality of a design to its conformance with a set of essential principles, rules and heuristics. This model is based on a novel mechanism, called detection strategy, that raises the abstraction level in dealing with metrics, by allowing to formulate good-design rules and heuristics in a quantifiable manner, and to detect automatically deviations from these rules. This quality model provides a twofold advantage: (i) an easier construction and understanding of the model as\u00a0\u2026", "num_citations": "94\n", "authors": ["65"]}
{"title": "Diagnosing design problems in object oriented systems\n", "abstract": " Software decay is a phenomenon that plagues aging software systems. While in recent years, there has been significant progress in the area of automatic detection of \"code smells\" on one hand, and code refactorings on the other hand, we claim that existing restructuring practices are seriously hampered by their symptomatic and informal (non-repeatable) nature. This paper makes a clear distinction between structural problems and structural symptoms (also known as code smells), and presents a novel, causal approach to restructuring object oriented systems. Our approach is based on two innovations: the encapsulation of correlations of symptoms and additional contextual information into higher-level design problems, and the univocal, explicit mapping of problems to unique refactoring solutions. Due to its explicit, repeatable nature, the approach shows high potential for increased levels of automation in the\u00a0\u2026", "num_citations": "90\n", "authors": ["65"]}
{"title": "Using concept analysis to detect co-change patterns\n", "abstract": " Software systems need to change over time to cope with new requirements, and due to design decisions, the changes happen to crosscut the system's structure. Understanding how changes appear in the system can reveal hidden dependencies between different entities of the system. We propose the usage of concept analysis to identify groups of entities that change in the same way and in the same time. We apply our approach at different levels of abstraction (ie, method, class, package) and we detect fine grained changes (ie, statements were added in a class, but no method was added there). Concept analysis is a technique that identifies entities that have the same properties, but it requires manual inspection due to the large number of candidates it detects. We propose a heuristic that dramatically eliminate the false positives. We apply our approach on two case studies and we show how we can identify\u00a0\u2026", "num_citations": "66\n", "authors": ["65"]}
{"title": "How developers copy\n", "abstract": " Copy-paste programming is dangerous as it may lead to hidden dependencies between different parts of the system. Modifying clones is not always straight forward, because we might not know all the places that need modification. This is even more of a problem when several developers need to know about how to change the clones. In this paper, we correlate the code clones with the time of the modification and with the developer that performed the modification to detect patterns of how developers copy from one another. We develop visualization, named clone evolution view, to represent the evolution of the duplicated code. We show the relevance of our approach on several large case studies and we distill our experience in forms of interesting copy patterns", "num_citations": "63\n", "authors": ["65"]}
{"title": "Incode: Continuous quality assessment and improvement\n", "abstract": " While significant progress has been made over the last ten years in the research field of quality assessment, developers still can't take full advantage of the benefits of these new tools and technique. We believe that there at least two main causes for this lack of adoption: (i) the lack of integration in mainstream IDEs and (ii) the lack of support for a continuous (daily) usage of QA tools. In this context we created INCODE as an Eclipe plug in that would transform quality assessment and code inspections from a standalone activity, into a continuous, agile process, fully integrated in the development life-cycle. But INCODE not only assesses continuously the quality of Java systems, it also assists developers in taking restructuring decisions, and even supports them in triggering refactorings.", "num_citations": "53\n", "authors": ["65"]}
{"title": "Towards the optimization of automatic detection of design flaws in object-oriented software systems\n", "abstract": " In order to increase the maintainability and the flexibility of a software, its design and implementation quality must be properly assessed. For this purpose a large number of metrics and several higher-level mechanisms based on metrics are defined in literature. But the accuracy of these quantification means is heavily dependent on the proper selection of threshold values, which is oftentimes totally empirical and unreliable. In this paper we present a novel method for establishing proper threshold values for metrics-based rules used to detect design flaws in object-oriented systems. The method, metaphorically called \"tuning machine\", is based on inferring the threshold values based on a set of reference examples, manually classified in \"flawed\" respectively \"healthy\" design entities (e.g., classes, methods). More precisely, the \"tuning machine\" searches based on a genetic algorithm, for those thresholds, which\u00a0\u2026", "num_citations": "48\n", "authors": ["65"]}
{"title": "Using object-oriented metrics for automatic design flaws detection in large scale systems\n", "abstract": " In the last decade the object-oriented paradigm has decisively influenced the world of software engineering. On the other hand, in spite of the large acceptance of this paradigm, at the beginning, the design principles and the intimate mechanisms of object-orientation were not yet precisely known, and this fact conducted to a lot of poor designed large scale OO systems. In other words, these applications mostly proved to be critical exactly in those aspects where object-oriented design should have offered its most expected benefits\u2013eg high degree of code reuse, higher maintainability or flexibility, etc. The general tendency manifested in the last time is to redesign these older industrial object-oriented systems, so that they may take full advantage of the today\u2019s knowledge in objectorientation, and thus improve the quality of their design.In the first stage of a redesign process it is needful to detect what are the design-flaws contained in the application and where are this flaws located. This diagnose task is usually called problem detection. The detection of design problems for large or very large systems is impossible to be fulfilled manually and must therefore be accomplished by automated methods.", "num_citations": "37\n", "authors": ["65"]}
{"title": "Continuous quality assessment with inCode\n", "abstract": " In spite of the progress that has been made over the last ten years in the research fields of software evolution and quality assessment, developers still do not take full advantage of the benefits of new assessment techniques that have been proposed by researchers. Beyond social factors, we believe that there are at least two main elements that contribute to this lack of adoption: (i) the insufficient integration of existing techniques in mainstream IDEs and (ii) the lack of support for a continuous (daily) usage of QA tools. In this context this paper introduces inCode, an Eclipse plugin aimed at transforming quality assessment and code inspections from a standalone activity, into a continuous process, fully integrated in the development life-cycle. But inCode not only assesses continuously the quality of Java systems; it also assists developers in taking restructuring decisions, and even supports them in triggering non\u00a0\u2026", "num_citations": "30\n", "authors": ["65"]}
{"title": "Are the clients of flawed classes (also) defect prone?\n", "abstract": " Design flaws are those characteristics of design entities (e.g., methods, classes) which make them harder to maintain. Existing studies show that classes revealing particular design flaws are more change and defect prone than the other classes. Since various collaborations are found among the instances of classes, classes are not isolated within the source code of object-oriented systems. In this paper we investigate if classes using classes revealing design flaws are more defect prone than classes which do not use classes revealing design flaws. We detect four design flaws in three releases of Eclipse and investigate the relation between classes that use/do not use flawed classes and defects. The results show that classes that use flawed classes are defect prone and this does not depend on the number of the used flawed classes. This findings show a new type of correlation between design flaws and defects\u00a0\u2026", "num_citations": "24\n", "authors": ["65"]}
{"title": "Towards a simplified implementation of object-oriented design metrics\n", "abstract": " In order to compute metrics automatically, these must be implemented as software programs. As metrics become increasingly complex, implementing them using imperative and interrogative programming is oftentimes cumbersome. Consequently, their understanding, testing and reuse are severely hampered. In this paper we identify a set of key mechanisms that are involved in the implementation of design metrics and, more general, of design-related structural analyses: navigation, selection, set arithmetic, filtering and property aggregation. We show that neither of the aforementioned approaches offers a simple support for all these mechanisms and, as a result, an undesirable overhead of complexity is added to the implementation of metrics. The paper introduces SAIL, a language designed to offer a proper support to a simplified writing of design metrics and similar design-related analyses, with special emphasis\u00a0\u2026", "num_citations": "21\n", "authors": ["65"]}