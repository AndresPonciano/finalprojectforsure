{"title": "Hierarchies of place/transition refinements in Petri nets\n", "abstract": " Place and transition refinements provide a convenient method of structuring complex net models by replacing single elements (places and transitions) at a \"higher-level\" of abstraction with \"lower-level\", more detailed, subnets. The concepts of static and dynamic place/transition refinements are introduced. Dynamic refinements do not increase the size of the (refined) model because no \"expansion\" of the model is performed; instead, only a \"logical\" association of higher-level elements with lower-level subnets is maintained and used in model analysis. Multiple applications of place/transition refinements results in hierarchical net models. The paper formalizes the concept of hierarchies of refinements in Petri nets and shows simple applications of the hierarchical approach to modeling of manufacturing cells.", "num_citations": "35\n", "authors": ["1238"]}
{"title": "Object oriented metrics useful in the prediction of class testing complexity\n", "abstract": " Adequate metrics of object-oriented software enable one to determine the complexity of a system and estimate the effort needed for testing already in the early stage of system development. The metrics values enable to locate parts of the design that could be error prone. Changes in these parts could significantly, improve the quality of the final product and decrease testing complexity. Unfortunately only few of the existing Computer Aided Software Engineering tools (CASE) calculate object metrics. In this paper methods allowing proper calculation of class metrics for some commercial CASE tool have been developed. New metric, calculable on the basis of information kept in CASE repository and useful in the estimation of testing effort have also been proposed. The evaluation of all discussed metrics does not depend on object design method and on the implementation language.", "num_citations": "15\n", "authors": ["1238"]}
{"title": "A tool supporting C code parallelization\n", "abstract": " In this paper a tool, called ParaGraph, supporting C code parallelization is presented. ParaGraph is a plug-in in Eclipse IDE and enables manual and automatic parallelization. A parallelizing compiler inserts automatically OpenMP directives into the outputted source code. OpenMP directives can be also manually inserted by a programmer. ParaGraph shows C code after parallelization. Visualization of parallelized code can be used to understand the rules and constraints of parallelization and to tune the parallelized code as well.", "num_citations": "11\n", "authors": ["1238"]}
{"title": "Reduction in mutation testing of Java classes\n", "abstract": " In mutation analysis many simple modification of the original program called \u201cmutants\u201d are created. Test cases which are supposed to identify the introduced program changes are designed. Each mutant must be \u201ckilled\u201d by a test case, i.e. the test case should detect the purposely introduced modification. Mutation testing is known to be effective but computationally demanding and time consuming because a large number of mutants has to be tested. Mutation score, which is the fraction of mutants that are killed by a test set, is often used to evaluate the effectiveness of mutation testing. An interesting research question is if the number of mutants can be reduced without significantly decreasing the effectiveness of the test. We were exploring selective reductions of mutants generated for Java programs. The results of several experiments conducted in the Eclipse environment are presented in this paper. These results\u00a0\u2026", "num_citations": "10\n", "authors": ["1238"]}
{"title": "Dataflow approach to testing Java programs\n", "abstract": " Code based (ldquowhite boxrdquo) approach to testing can be divided into two main types: control flow coverage and data flow coverage methods. Dataflow testing was introduced for structural programming languages and later adopted for object languages. Among many tools supporting code based testing of object programs, only JaBUTi and DFC (data flow coverage) support dataflow testing of Java programs. DFC is a tool implemented at the Institute of Computer Science Warsaw University of Technology as an Eclipse plug-in. The objective of this paper is to present dataflow coverage testing of Java programs supported by DFC. DFC finds all definition-uses pairs in tested unit and provides also the definition-uses graph for methods. After the execution of test information which def-uses pairs were covered is shown. An example of data flow testing of Java program is also presented.", "num_citations": "8\n", "authors": ["1238"]}
{"title": "Aspects in the maintenance of compiled programs\n", "abstract": " Aspect oriented approach to the maintenance of programs with unavailable source code and documentation is proposed. Aspects are used to trace the program execution and identify points, in which aspects implementing new functionalities may be applied. A special tool for aspect oriented program tracing was designed and implemented. This tool is necessary to use the proposed approach. A modification of GIU interface of a compiled program without source code and documentation is presented. Advantages and disadvantages of described concepts are pointed out.", "num_citations": "8\n", "authors": ["1238"]}
{"title": "Selection of metrics for the defect prediction\n", "abstract": " The ability to estimate if a module or a class or a method is faulty, or not, is called the defect prediction. Prediction can be used to target the improvement efforts to those modules or classes that need it the most. We investigated the classification process (deciding if an element is faulty or not) in which the set of software metrics and several data mining algorithms were used. We conducted an experiment on ten open source projects. The data concerning defects were extracted from the repository of the control version system. In this study the process of choosing appropriate metrics for the defect prediction is described. In the selection process we use unique approach by random forest.", "num_citations": "7\n", "authors": ["1238"]}
{"title": "Tool for automatic testing of web services\n", "abstract": " The Web Services technology has received a significant amount of attention in recent years because it allows to easily utilize and integrate existing software applications to create new business services. With the increase of interest and popularity of Web Services, Web applications are developed. This way of software development causes new issues for Web Service testing to ensure the quality of service that are published. This paper describes the tool (named WSDLTest) for automatic testing of Web services. The tool can be used for testing of Web services for which WSDL 1.1 or WSDL 2.0 document are available. WSDLTest parses the WSDL document, and based on, it tests the Web service by sending automatically generated messages. Some examples of the usage of our tool are given.", "num_citations": "7\n", "authors": ["1238"]}
{"title": "A Comparison of Dataflow and Mutation Testing of Java Methods\n", "abstract": " The objective of this chapter is to compare the dataflow and the mutation testing of several Java programs. Experiments were conducted in the Eclipse environment. DFC plugin was used to support the dataflow testing while MuClipse and Jumble plugins were used for the mutation testing. The results of testing six Java programs using data flow and mutation techniques are presented. Experiment shown, that the effectiveness of mutation testing is higher than the effectiveness of dataflow testing. Mutation technique appeared also to be more expensive than the data flow one, if time and effort are considered.", "num_citations": "7\n", "authors": ["1238"]}
{"title": "C code parallelization with paragraph\n", "abstract": " Parallel programming has been attracting attention of programmers and researchers for many years. Parallelization is a very difficult task and may cause many runtime errors so some methods and tools facilitating this process are necessary. Parallel code can be prepared by a programmer or automatically by some compilers. As both approaches have advantages and disadvantages, it seems that a tool enabling manual and automatic parallelization can be very useful in the production of fast programs. Such a tool, called ParaGraph, was designed and implemented at the Institute of Computer Science, Warsaw University of Technology. ParaGraph is platform independent and plug-in in Eclipse IDE. In this paper an experiment comparing the effectiveness of manual and automatic parallelization of a program with Paragraph is described.", "num_citations": "7\n", "authors": ["1238"]}
{"title": "Reduction of computational cost in mutation testing by sampling mutants\n", "abstract": " The objective of this chapter is to explore the reduction of computational costs of mutation testing by randomly sampling mutants. Several experiments were conducted in the Eclipse environment using MuClipse and CodePro plugins and especially designed and implemented tools: Mutants Remover and Console Output Analyser. Six types of mutant\u2019 subsets were generated and examined. Mutation score and the source code coverage were used to evaluate the effectiveness of mutation testing with subsets of mutants. The ability to detect errors introduced \u201con purpose\u201d in the source code was also examined.", "num_citations": "6\n", "authors": ["1238"]}
{"title": "Data mining algorithms in the analysis of security logs from a honeypot system\n", "abstract": " Today many applications move to the Internet as web applications. This phenomenon causes new opportunities for attackers to take over servers or steal sensitive data such as credit card numbers, personal or corporate data. In this paper some analyses of data from a honeypot system of web application, implemented at the Institute of Computer Science, Warsaw University of Technology, are presented. The implemented honeypot has its own management software that helps to analyze the stored data. The honeypot was operating almost one year. Several data mining techniques were used to analyze the data collected by the honeypot and to detect important patterns and attacks. In this paper the results of the usage of algorithms MaxMiner and SED in the analysis of logs are presented.", "num_citations": "5\n", "authors": ["1238"]}
{"title": "Reductions of operators in Java mutation testing\n", "abstract": " The objective of this chapter is to explore the reduction of computational costs of mutation testing of Java programs by selective mutations \u2013 omitting mutants generated for a mutation operator. The approaches to reduce the effort in mutation testing are briefly described. The idea of choosing a mutations operator and omitting mutants generated by it is described, next several experiments, conducted in the Eclipse environment using MuClipse and CodePro plugins, are presented in details. Two especially designed and implemented tools: Mutants Remover and Console Output Analyser were also used in experiments. Mutation score was used to evaluate the effectiveness of selective mutation testing.", "num_citations": "5\n", "authors": ["1238"]}
{"title": "Detection of Anomalies in a SOA System by Learning Algorithms\n", "abstract": " The objective of this chapter is to present the detection of anomalies in SOA system by learning algorithms. As it was not possible to inject errors into the \u201creal\u201d SOA system and to measure them, a special model of SOA system was designed and implemented. In this systems several anomalies were introduced and the effectiveness of algorithms in detecting them were measured. The results of experiments may be used to select efficient algorithm for anomaly detection. Two algorithms: K-Means clustering and emerging patterns were used to detect anomalies in the frequency of service call. The results of this experiment are discussed.", "num_citations": "5\n", "authors": ["1238"]}
{"title": "Metrics for assessing complexity and testability of object oriented software\n", "abstract": " In this paper some widely known object-oriented metrics are described. The metrics are presented in two groups: class-level and system-level. Some sets of metrics dedicated to the C++ programming language are also shown. The correlation is given between metrics and quality attributes of a system, such as reliability and testability.", "num_citations": "5\n", "authors": ["1238"]}
{"title": "Structural modelling with Petri nets\n", "abstract": " An example of structural modelling with Petri nets with refinements is discussed. A simple assembly line consisting of two machines is considered. The assembly line model is made more precise by refining each transition representing the machine, by the Petri net defining its operation. The Petri net model of the assembly line is used as a building block while modelling an entire factory unit. The descriptions of all Petri nets used are given in the new high-level language.", "num_citations": "5\n", "authors": ["1238"]}
{"title": "Tool for assessment of testing effort\n", "abstract": " Testing, being one of crucial factors in providing high quality software, needs a significant amount of resources of the whole project. Estimation of amount of expenditures required to test the software, called testing effort, would considerably facilitate the project management process. Early estimation of the test effort, e.g. during design process, can significantly facilitate project management and resources distribution optimization. We made an attempt to prepare such an estimate. The tool estimating time necessary to test the system, on the basis of its UML model, called IoTEAM, was designed and developed. The tool is based on two methods: mapping UML class and sequence diagrams into the results of Function Point Analysis and Test Point Analysis. The choice of those methods was preceded by a comprehensive study of the current state of art. Some results of this study are presented in this paper. The\u00a0\u2026", "num_citations": "4\n", "authors": ["1238"]}
{"title": "On the performance of some C# constructions\n", "abstract": " In some types of dependable applications (e.g. controlling some electronic devices) the execution time of a program has to be very short to enable the appropriate control of the device. Implementing code for Kamika\u2019s device that measures small particles in the air or in the liquid we are using C# language. Some parts of the code were also transformed into C++ to find overheads. The main part of the paper are results of some comparative experiments measuring the performance of alternative C# constructions. We were especially interested in extension methods which enable to \u201cadd\u201d methods to existing types without creating a new derived type, recompiling, or modifying the original type.", "num_citations": "3\n", "authors": ["1238"]}
{"title": "The Function-Behaviour-Structure Diagram for Modelling Workflow of Information Systems\n", "abstract": " Currently, no single UML diagram provides the satisfactory completeness and consistency of the system description. There is also no BPMN diagram to satisfy such requirements. The satisfactory completeness means that the model enables to describe fully a function, a structure, and a behaviour of the IT system. With BPMN diagram one cannot provide a complete data model i.e. the structure of the IT system. The proposed Function-Behaviour-Structure activity diagram introduced in this paper enables to develop consistent and satisfactorily complete models.", "num_citations": "3\n", "authors": ["1238"]}
{"title": "Dataflow testing of Java programs with DFC\n", "abstract": " The objective of this paper is to present a tool supporting dataflow coverage testing of Java programs. Code based (\u201dwhite box\u201d) approach to testing can be divided into two main types: control flow coverage and data flow coverage methods. Dataflow testing was introduced for structural programming languages and later adopted for object languages. Among many tools supporting code based testing of object programs, only JaBUTi and DFC (Data Flow Coverage) support dataflow testing of Java programs. DFC is a tool implemented at the Institute of Computer Science Warsaw University of Technology as an Eclipse plug-in. DFC finds all definition-uses (def\u2009\u2212\u2009u) pairs in tested unit and provides also the def\u2009\u2212\u2009u graph DUG for methods. After the execution of tests the information which def\u2009\u2212\u2009u pairs were covered is shown. An example of usage of DFC and the comparison with JaBUTi data flow testing\u00a0\u2026", "num_citations": "3\n", "authors": ["1238"]}
{"title": "Aspect modification of an EAR application\n", "abstract": " We propose aspect modification of compiled Java programs for which source code and documentation are not available. Aspect oriented programming is used to trace the program execution and identify points, in which aspects implementing new functionalities should be applied. A special tool for aspect oriented program tracing was designed and implemented. A modification in an real Enterprise Application Archive (EAR), compiled, without source code and documentation is presented in this paper. Advantages and disadvantages of described concepts are pointed out.", "num_citations": "3\n", "authors": ["1238"]}
{"title": "Monitoring services on  enterprise service bus\n", "abstract": " ABSTRACT At the Institute of Computer Science Warsaw University of Technology a module for monitoring services in Service Oriented Architectures (SOA) was designed and implemented. The module is able to monitor services on the ESB (Enterprise Service Bus) level even, if the services are executed on different servers. The whole context of the flow is provided to the user. The architecture of this module is briefly presented. This tool was used to measure several parameters in real enterprise integrated architecture eg: the effectiveness and the usage of resources in some flows. These experiments are described and some conclusions are given. The monitoring module may be very useful in the maintenance of complex SOA systems.", "num_citations": "3\n", "authors": ["1238"]}
{"title": "Tool for Metamorphic Testing\n", "abstract": " Metamorphic testing is an approach to test case generation and also to the test result verification. It is a testing technique that can be successfully used in many domains e.g. web services, computer graphics, simulation and even embedded systems. In metamorphic testing checks are performed to verify whether multiple executions of the program under test fulfil certain necessary properties, called metamorphic relations. Since its first publication, many papers on different aspects of metamorphic appeared in the literature but only one tool for this type of testing was described. We decided to design and implement our own tool and with this tool to examine some properties and challenges of metamorphic testing. In this paper we briefly review metamorphic relations and describe our tool. We also present an example of metamorphic testing with our tool.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "ISO 25010 support in test point analysis for testing effort estimation\n", "abstract": " Estimation of the testing effort prepared on the early stage of software development process (e.g. in the design phase) could be a significant help for both project management and resources distribution optimization. We designed and implemented a tool, called IoTEAM, estimating time necessary to test the system, on the basis of its UML model (class and sequence diagrams). That tool is a unique combination of two methods: transformation from UML class and sequence diagrams to the results of Function Point Analysis and Test Point Analysis (TPA). The resulting approach\u00a0can be used for estimation of time of the whole testing process \u2013 from unit tests to acceptance tests. Unfortunately, TPA was proposed almost twenty years ago, so is not consistent with contemporary\u00a0quality standards. In this paper, we present how to incorporate ISO 25010 standard in TPA method.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Experiment on defect prediction\n", "abstract": " It is important to be able to predict if a module or a class or a method is faulty, or not. Such predictions can be used to target improvement efforts to those modules or classes that need it the most. We investigated the classification process (deciding if an element is faulty or not) in which the set of software metrics is used and examined several data mining algorithms. We conducted an experiment in which ten open source projects were evaluated by ten chosen metrics. The data concerning defects were extracted from the repository of the control version system. For each project two versions of code were used in the classification process. In this study the results of two algorithms i.e. k- NN and decision trees used in the classification process are presented.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Learning algorithms in the detection of unused functionalities in SOA systems\n", "abstract": " The objective of this paper is to present an application of learning algorithms to the detection of anomalies in SOA system. As it was not possible to inject errors into the \u201creal\u201d SOA system and to analyze the effect of these errors, a special model of SOA system was designed and implemented. In this system several anomalies were introduced and the effectiveness of algorithms in detecting them were measured. The results of experiments can be used to select efficient algorithm for anomaly detection. Two algorithms: K-means clustering and Kohonen networks were used to detect the unused functionalities and the results of this experiment are discussed.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Modeler modelu przestrzennego DOD w \u015arodowisku TOPCASED\n", "abstract": " In this paper a modeler, named Dodocum, of three dimensional Document Circulation Diagram (DOD) implemented in the TOPCASED environment is presented. This tool generates appropriate UML diagrams from a DOD model. Three dimensional DOD model, briefly described in the paper, enables to design the functionality, structure and even the behavior of an application. Automatically generated UML diagrams are consistent and well enough describe the logical view of software. Metamodel of three dimensional Document Circulation Diagram (DOD) is also presented and the transformation from DOD into UML diagrams are shown.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Aspects modification in business logic of compiled Java programs\n", "abstract": " We propose aspect modification of compiled Java programs for which source code and documentation is not available. Aspect oriented programming is used to trace the program execution and identify points, in which aspects implementing new functionalities may be applied. A special tool supporting this approach was designed and implemented. A modification in business logic of an real, compiled program without source code and documentation is presented in this paper. Advantages and disadvantages of described concepts are pointed out.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Evaluation of class testing complexity with object metrics\n", "abstract": " Any activities enabling one to determine the complexity of object oriented software and estimate the effort needed for testing already in the early stage of system development are very useful. Some object metrics can be used to locate parts of the design that could be error prone or complex to test. In this paper methods allowing proper calculation of class metrics for some commercial CASE tool have been described. Metrics, calculable on the basis of information kept in CASE repository and useful in the estimation of testing effort have been presented. A new class metric was also proposed.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Podstawy testowania oprogramowania obiektowego\n", "abstract": " W pracy przedstawiono podstawy testowania oprogramowania napisanego w j\u0119zykach obiektowych. Zwr\u00f3cono uwag\u0119 na fakt, \u017ce testowanie program\u00f3w obiektowych wymaga nie mniejszego wysi\u0142ku, ni\u017c testowanie program\u00f3w napisanych w j\u0119zykach strukturalnych. Wzrost z\u0142o\u017cono\u015bci testowania wynika z podstawowych cech j\u0119zyk\u00f3w obiektowych takich jak hermetyzacja, dziedziczenie, polimorfizm czy dynamiczne wi\u0105zanie. Podano tak\u017ce pewne wskaz\u00f3wki praktyczne dotycz\u0105ce testowania klas.", "num_citations": "2\n", "authors": ["1238"]}
{"title": "Software Testing Effort Estimation and Related Problems: A Systematic Literature Review\n", "abstract": " Although testing effort estimation is a very important task in software project management, it is rarely described in the literature. There are many difficulties in finding any useful methods or tools for this purpose. Solutions to many other problems related to testing effort calculation are published much more often. There is also no research focusing on both testing effort estimation and all related areas of software engineering. To fill this gap, we performed a systematic literature review on both questions. Although our primary objective was to find some tools or implementable metods for test effort estimation, we have quickly discovered many other interesting topics related to the main one. The main contribution of this work is the presentation of the testing effort estimation task in a very wide context, indicating the relations with other research fields. This systematic literature review presents a detailed overview of testing\u00a0\u2026", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Usage of UML Combined Fragments in Automatic Function Point Analysis.\n", "abstract": " Combined fragments, introduced in UML 2.0 and allowing to express complex communication scenarios in sequence diagrams, are rarely the subject of research. In this paper, we present a method to transform nine of UML 2. x combined fragments, ie alt, opt, break, neg, ignore, consider, assert, strict and critical, into the set of interaction variants. Our proposition takes advantage of the simple fact that each sequence diagram containing any number of combined fragments can be replaced with some number of simpler diagrams representing single scenarios and not containing any combined fragments. This transformation can be fully automated. Our method was developed as a pre-processing stage in the automatic FPA analysis, which is used in test effort estimation approach, but can be used independently as well.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Tool for Mutation Testing of Web Services\n", "abstract": " The Web Services technology becomes more and more popular because it allows to easily utilize and integrate existing software applications even working on different platforms, and to create new services. This way of software development causes new issues for Web Service testing to ensure the quality of service that is published. Mutation analysis can be used to measure the adequacy of tests or to reveal errors. In mutation testing the original code is modified using set of mutation operators. For Web Services the mutation operators can modify SOAP messages or WSDL documents. A tool named Exodus, supporting the mutation testing of Web Services is presented. This tool accepts files describing Web Services in WSDL (Web Services Description Language) format and generates altered (mutated) versions of them using some mutation operators. The architecture and the implementation of Exodus tool\u00a0\u2026", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Mutant generation for WSDL\n", "abstract": " Web Service technology is becoming increasingly popular because it simplifies the use and integration of existing applications and creation of new services. Because available services should be of high quality effective testing of Web Services is essential. The idea of mutation testing of Web Services is discussed in this paper and some mutation operators are described. A tool named Web Services Mutant Generator (WSMG), supporting the mutation testing of Web Services, is also presented. This tool accepts files with the description of Web Services written in WSDL (Web Services Description Language) and generates altered (mutated) versions of services using four mutation operators: OTCE, OTCA, STCE and STCA. The architecture and the implementation of the WSMG tool is shortly described and an example of its application is included.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Experiences with DCI pattern\n", "abstract": " The DCI architectural pattern for software, introduced by Reenskaug, contains three parts: Data, Context and Interaction. Data represent domain knowledge while Context and Interaction represent the business logic by implementing communication between objects. Context dynamically injects roles into objects. This design pattern is especially appropriate for agile software development. The goal of our paper is to present some practical experiences with the DCI design pattern. We used the DCI pattern in an exemplary application. We proposed and described the association and cooperation between the DCI and MVC (Model View Controller) pattern. Some remarks on the usage of the DCI design pattern in the software development are also given.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "From Three Dimensional Document Circulation Diagram into UML Diagrams\n", "abstract": " In most projects UML models are systematically modified and refined in the software development process. Existing software development methodologies are not explicitly describing transitions between different views, models, and appropriate elements of models. The three dimensional Document Circulation Diagram (3D DCD) enables to design the functionality, structure and even the behavior of an application. From the 3D DCD model, consistent and complete UML diagrams may be automatically generated. In this paper a modeler, named Dodocum, automatically generating UML models from 3D DCD model is also presented.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Modelling and performance analysis of component-based systems\n", "abstract": " Assessment of dependability of component-based systems must include verification of temporal and performance requirements as they can be of primary importance for many real-time and embedded systems. This paper uses labelled timed Petri nets as models of the behaviour of components at their interfaces. These component models are systematically composed into an integrated model of the system which is used for verification of temporal characteristics and performance analysis.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "System for knowledge mining in data from interactions between user and application\n", "abstract": " The problem of knowledge extraction from the data left by web users during their interactions is a very attractive research task. The extracted knowledge can be used for different goals such as service personalization, site structure simplification, web server performance improvement or even for studying the human behavior. The objective of this paper is to present a system, called ELM (Event Logger Manager), able to register and analyze data from different applications. The registered data can be specified in an experiment. Currently ELM system provides several knowledge mining algorithms, i.e., apriori, ID3, C4.5 but easily other mining algorithms can be added.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Performance analysis of component-based systems\n", "abstract": " Dependability assessment of component-based systems must include verification of temporal and performance requirements as they can be of primary importance for many real-time and embedded systems. This paper uses labeled timed Petri nets as models of the behavior of components at their interfaces. These component models are systematically composed into an integrated model of the system which is used for verification of temporal characteristics and performance analysis.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Diagramy obiegu dokument\u00f3w a UML w modelowaniu proces\u00f3w biznesowych\n", "abstract": " W niniejszym rozdziale przedstawiono diagramy obiegu dokument\u00f3w (DOD) s\u0142u\u017c\u0105ce do opisu system\u00f3w obiegu dokument\u00f3w. Zaproponowano prost\u0105 metod\u0119 por\u00f3wnywania metod modelowania proces\u00f3w biznesowych opart\u0105 na szacowaniu widoczno\u015bci takich cech jak przep\u0142yw sterowania i danych, wykonywane czynno\u015bci, wizualizacja obiekt\u00f3w, system\u00f3w, aktor\u00f3w. Metod\u0119 t\u0119 u\u017cyto do por\u00f3wnania mo\u017cliwo\u015bci modelowania proces\u00f3w biznesowych za pomoc\u0105 diagram\u00f3w DOD oraz diagram\u00f3w UML. Do por\u00f3wnania wykorzystano wybrany fragment przemys\u0142owego modelu systemu informatycznego.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Aspekty w \u015bledzeniu i modyfikowaniu skompilowanych program\u00f3w\n", "abstract": " W pracy zaprezentowana zosta\u0142a nowa metoda \u015bledzenia i modyfikacji program\u00f3w skompilowanych wykorzystuj\u0105ca programowania aspektowe. Specjalne narz\u0119dzie, nazwane platform\u0105 Crusader [1], zosta\u0142o zaprojektowane i zaimplementowane w Instytucie Informatyki PW. Narz\u0119dzie to wspiera proces aspektowego \u015bledzenia i modyfikowania program\u00f3w. Przeprowadzono eksperymenty pokazuj\u0105ce zakres stosowania zaproponowanych metod.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "A Soft Real-Time Precise Tracing Garbage Collector for C++\n", "abstract": " The paper presents an efficient garbage collector that can be used in soft real-time and interactive applications written in C++. The garbage collector is tuned to best meet requirements of Internet server-side applications. It collects and sweeps garbage concurrently to application threads, thus it minimizes unpredictable execution delays and can increase applications\u2019 performance. The article shows how such garbage collector is built, what data structures and algorithms are used, and how they can be efficiently implemented in C++.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Internet laboratory instructions for advanced software engineering course\n", "abstract": " In this paper a new software engineering laboratory introduced in the Institute of Computer Science Warsaw University of Technology in the fall 2004 is presented. Advanced Software Engineering 2 (SE-2) laboratory consists of seven exercises. Theses exercises are dedicated to requirements engineering, system design with UML [11], reuse, precise modelling with OCL\u2013Object Constraint Language [12], code coverage testing, memory leaks detection and improving application efficiency. Six out of ten SWEBOK [4] knowledge areas are practiced. For each laboratory exercise a set of training materials and instructions were developed. These materials are stored on a department server and are available for all students and lecturers of advanced Software Engineering 2 (SE-2) course. Rational Suite tools are used in laboratory.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Evaluation of object metrics in a case.\n", "abstract": " Any activities enabling one to determine the complexity of object software in the early stage of system development are very useful. Some object metrics can be used to locate parts of the design that could be error prone or complex to test. In this paper methods allowing calculation of system-level metrics for commercial CASE tool, Rational Rose, have been described. Abreu et al proposed [1] MOOD metrics (metrics for object-oriented design). MOOD metrics are calculated on the basis of information kept in Rose project repository and they are very useful in the estimation of system complexity. The correlation between metrics and quality attributes of a system designed in Rose, such as reliability, testability is also given.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Miary oprogramowania obiektowego (pozwalaj\u0105ce oszacowa\u0107 z\u0142o\u017cono\u015b\u0107 testowania)\n", "abstract": " PL Poni\u017cej przedstawiono miary oprogramowania obiektowego, kt\u00f3re mo\u017cna stosowa\u0107 ju\u017c we wczesnym stadium powstawania oprogramowania i na ich podstawie mo\u017cna wnioskowa\u0107 o wysi\u0142ku zwi\u0105zanym z testowaniem klasy i ca\u0142ego systemu.", "num_citations": "1\n", "authors": ["1238"]}
{"title": "Miary oprogramowania obiektowego\n", "abstract": " PL Poni\u017cej przedstawiono miary oprogramowania obiektowego, kt\u00f3re mo\u017cna stosowa\u0107 ju\u017c we wczesnym stadium powstawania oprogramowania i na ich podstawie mo\u017cna wnioskowa\u0107 o wysi\u0142ku zwi\u0105zanym z testowaniem klasy i ca\u0142ego systemu.", "num_citations": "1\n", "authors": ["1238"]}