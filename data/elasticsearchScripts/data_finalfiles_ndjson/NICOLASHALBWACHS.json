{"title": "The synchronous data flow programming language LUSTRE\n", "abstract": " The authors describe LUSTRE, a data flow synchronous language designed for programming reactive systems-such as automatic control and monitoring systems-as well as for describing hardware. The data flow aspect of LUSTRE makes it very close to usual description tools in these domains (block-diagrams, networks of operators, dynamical sample-systems, etc.), and its synchronous interpretation makes it well suited for handling time in programs. Moreover, this synchronous interpretation allows it to be compiled into an efficient sequential program. The LUSTRE formalism is very similar to temporal logics. This allows the language to be used for both writing programs and expressing program properties, which results in an original program verification methodology.< >", "num_citations": "2459\n", "authors": ["258"]}
{"title": "Synchronous programming of reactive systems\n", "abstract": " This book will attempt to give a first synthesis of recent works con cerning reactive system design. The term\" reactive system\" has been introduced in order to at'oid the ambiguities often associated with by the term\" real-time system,\" which, although best known and more sugges tive, has been given so many different meanings that it is almost in evitably misunderstood. Industrial process control systems, transporta tion control and supervision systems, signal-processing systems, are ex amples of the systems we have in mind. Although these systems are more and more computerized, it is sur prising to notice that the problem of time in computer science has been studied only recently by\" pure\" computer scientists. Until the early 1980s, time problems were regarded as the concern of performance evalu ation, or of some (unjustly scorned)\" industrial computer engineering,\" or, at best, of operating systems. A second surprising fact, in contrast, is the growth of research con cerning timed systems during the last decade. The handling of time has suddenly become a fundamental goal for most models of concurrency. In particular, Robin Alilner's pioneering works about synchronous process algebras gave rise to a school of thought adopting the following abstract point of view: As soon as one admits that a system can instantaneously react to events, ie", "num_citations": "1439\n", "authors": ["258"]}
{"title": "The synchronous languages 12 years later\n", "abstract": " Twelve years ago, Proceedings of the IEEE devoted a special section to the synchronous languages. This paper discusses the improvements, difficulties, and successes that have occured with the synchronous languages since then. Today, synchronous languages have been established as a technology of choice for modeling, specifying, validating, and implementing real-time embedded applications. The paradigm of synchrony has emerged as an engineer-friendly design method based on mathematically sound tools.", "num_citations": "1310\n", "authors": ["258"]}
{"title": "LUSTRE: A declarative language for programming synchronous systems\n", "abstract": " LUSTRE is a synchronous data-flow language for programming systems which interact with their environments in real-time. After an informal presentation of the language, we describe its semantics by means of structural inference rules. Moreover, we show how to use this semantics in order to generate efficient sequential code, namely, a finite state automaton which represents the control of the program. Formal rules for program transformation are also presented.", "num_citations": "854\n", "authors": ["258"]}
{"title": "Programming and verifying real-time systems by means of the synchronous data-flow language LUSTRE\n", "abstract": " We investigate the bene ts of using a synchronous data-ow language for programming critical real-time systems. These bene ts concern ergonomy| since the data ow approach meets traditional description tools used in this domain|, and ability to support formal design and veri cation methods. We show, on a simple example, how the language Lustre and its associated veri cation tool Lesar, can be used to design a program, to specify its critical properties, and to verify these properties. As the language Lustre and its use have been already published in several papers (eg, 11, 18]), we put particular emphasis on program veri cation. A preliminary version of this paper has been published in 28].", "num_citations": "407\n", "authors": ["258"]}
{"title": "Synchronous observers and the verification of reactive systems\n", "abstract": " Synchronous programming [20, 14] is a useful approach to design reactive systems. A synchronous program is supposed to instantly and deterministically react to events coming from its environment. The advantages of this approach have been pointed out elsewhere [20]. Synchronous languages are simple and clean, they have been given simple and precise formal semantics, they allow especially elegant programming style. They conciliate concurrency (at least at the description level) with determinism. They can be compiled into a very efficient sequential code, by means of a specific compiling technique: The control structure of the object code is a finite automaton which is synthesized by an exhaustive simulation of a finite abstraction of the program.", "num_citations": "385\n", "authors": ["258"]}
{"title": "Verification of real-time systems using linear relation analysis\n", "abstract": " Linear Relation Analysis [11] is an abstract interpretation devoted to the automatic discovery of invariant linear inequalities among numerical variables of a program. In this paper, we apply such an analysis to the verification of quantitative time properties of two kinds of systems: synchronous programs and linear hybrid systems.", "num_citations": "353\n", "authors": ["258"]}
{"title": "LUSTRE: a declarative language for real-time programming\n", "abstract": " LUSTRE is a synchronous data-flow language for programming systems which interact with their environments in real-time. After an informal presentation of the language, we describe its semantics by means of structural inference rules. Moreover, we show how to use this semantics in order to generate efficient sequential code, namely, a finite state automaton which represents the control of the program. Formal rules for program transformation are also presented.", "num_citations": "337\n", "authors": ["258"]}
{"title": "Verification of linear hybrid systems by means of convex approximations\n", "abstract": " We present a new application of the abstract interpretation by means of convex polyhedra, to a class of hybrid systems, i.e., systems involving both discrete and continuous variables. The result is an efficient automatic tool for approximate, but conservative, verification of reachability properties of these systems.", "num_citations": "262\n", "authors": ["258"]}
{"title": "Delay analysis in synchronous programs\n", "abstract": " Linear relation analysis [CH78, Hal79] has been proposed a long time ago as an abstract interpretation which permits to discover linear relations invariantly satisfied by the variables of a program. Here, we propose to apply this general method to variables used to count delays in synchronous programs. The \u201cregular\u201d behavior of these counters makes the results of the analysis especially precise. These results can be applied to code optimization and to the verification of real-time properties of programs.", "num_citations": "242\n", "authors": ["258"]}
{"title": "Automatic testing of reactive systems\n", "abstract": " The paper addresses the problem of automatizing the production of test sequences for reactive systems. We particularly focus on two points: (1) generating relevant inputs, with respect to some knowledge about the environment in which the system is intended to run; (2) checking the correctness of the test results, according to the expected behavior of the system. We propose to use synchronous observers to express both the relevance and the correctness of the test sequences. In particular, the relevance observer is used to randomly choose inputs satisfying temporal assumptions about the environment. These assumptions may involve both Boolean and linear numerical constraints. A prototype tool called LURETTE has been developed and experimented with, which works on observers written in the LUSTRE programming language.", "num_citations": "189\n", "authors": ["258"]}
{"title": "Discovering properties about arrays in simple programs\n", "abstract": " Array bound checking and array dependency analysis (for parallelization) have been widely studied. However, there are much less results about analyzing properties of array contents. In this paper, we propose a way of using abstract interpretation for discovering properties about array contents in some restricted cases: one-dimensional arrays, traversed by simple\" for\" loops. The basic idea, borrowed from [GRS05], consists in partitioning arrays into symbolic intervals (eg,[1, i--1],[i, i],[i+ 1, n]), and in associating with each such interval I and each array A an abstract variable A I; the new idea is to consider relational abstract properties \u03c8 (A I, B I,...) about these abstract variables, and to interpret such a property pointwise on the interval I:\u2200 l\u2208 I, \u03c8 (A [l], B [l],...). The abstract semantics of our simple programs according to these abstract properties has been defined and implemented in a prototype tool. The method is able\u00a0\u2026", "num_citations": "178\n", "authors": ["258"]}
{"title": "Generating efficient code from data-flow programs\n", "abstract": " This paper presents the techniques applied in compiling the synchronous data-flow language Lustre. The most original technique consists in synthesising an efficient control structure, by simulating the behavior of boolean variables at compile-time. Here, the techniques are explained on a small subset of Lustre.", "num_citations": "156\n", "authors": ["258"]}
{"title": "D\u00e9termination automatique de relations lin\u00e9aires v\u00e9rifi\u00e9es par les variables d'un programme\n", "abstract": " D\u00e9finitions et r\u00e9sultats fondamentaux sur les poly\u00e8dres convexes. Op\u00e9rations sur les poly\u00e8dres convexes. contextes abstraits. Syst\u00e8me d'\u00e9quations en avant associe \u00e0 un programme. Analyse approch\u00e9e en avant des programmes. Analyse approch\u00e9e en arri\u00e8re des programmes. Primitives \u00e9volu\u00e9es. Application de la m\u00e9thode. Note sur l'impl\u00e9mentation et les performances. comparaison avec des travaux voisins.", "num_citations": "154\n", "authors": ["258"]}
{"title": "Combining widening and acceleration in linear relation analysis\n", "abstract": " Linear Relation Analysis [CH78, Hal79] is one of the first, but still one of the most powerful, abstract interpretations working in an infinite lattice. As such, it makes use of a widening operator to enforce the convergence of fixpoint computations. While the approximation due to widening can be arbitrarily refined by delaying the application of widening, the analysis quickly becomes too expensive with the increase of delay. Previous attempts at improving the precision of widening are not completely satisfactory, since none of them is guaranteed to improve the precision of the result, and they can nevertheless increase the cost of the analysis. In this paper, we investigate an improvement of Linear Relation Analysis consisting in computing, when possible, the exact (abstract) effect of a loop. This technique is fully compatible with the use of widening, and whenever it applies, it improves both the precision and the\u00a0\u2026", "num_citations": "118\n", "authors": ["258"]}
{"title": "A synchronous language at work: the story of Lustre\n", "abstract": " We recall the story of the development of the synchronous data-flow language Lustre and of its industrial transfer inside the toolset SCADE. We try to analyse the reasons of its success, and to report the main lessons we got from the transfer of an academic concept into real industrial world.", "num_citations": "108\n", "authors": ["258"]}
{"title": "Automatic verification of parameterized linear networks of processes\n", "abstract": " This paper describes a method to verify safety properties of parameterized linear networks of processes. The method is based on the construction of a network invariant, defined as a fixpoint. Such invariants can often be automatically computed using heuristics based on Cousot's widening techniques. These techniques have been implemented and some non-trivial examples are presented.", "num_citations": "102\n", "authors": ["258"]}
{"title": "Dynamic partitioning in analyses of numerical properties\n", "abstract": " We apply linear relation analysis [CH78,HPR97] to the verification of declarative synchronous programs [Hal98]. In this approach, state partitioning plays an important role: on one hand the precision of the results highly depends on the fineness of the partitioning; on the other hand, a too much detailed partitioning may result in an exponential explosion of the analysis. In this paper, we propose to dynamically select a suitable partitioning according to the property to be proved.", "num_citations": "95\n", "authors": ["258"]}
{"title": "A functional model for describing and reasoning about time behaviour of computing systems\n", "abstract": " We present a mathematical model of parallel and real time systems behaviour, suitable for problem specification, and for implementation description, analysis and proof. On one hand, this model allows a pure behavioural description mode, and on the other hand it takes into account a metric notion of time. A system is considered as a history transformer, and the history of a variable consists of the sequence of values assigned to it, together with the sequence of times when these assignments take place. A set of tools is proposed, in order to describe such histories, and to perform proofs about them. This model is illustrated by the specification, the description and the proof of a distributed bus arbiter.", "num_citations": "71\n", "authors": ["258"]}
{"title": "Outline of a real time data flow language\n", "abstract": " Outline of a real time data flow language - OpenGrey fra | eng OpenGrey Open System for Information on Grey literature in Europe Home Search Subjects Partners Export Help Search XML To cite or link to this reference: http://hdl.handle.net/10068/48354 Title : Outline of a real time data flow language Authors : Bergerand, JL ; Caspi, P. ; Halbwachs, N. ; Pilaud, D. ; Pilaud, E. ; Corporate author : Centre National de la Recherche Scientifique (CNRS), 38 - Saint-Martin-d'Heres (France). Lab. des Circuits et Systemes ; Publication year : 1985 Language : English ; Pagination/Size : 26 p. ; SIGLE classification : 09H - Computer software, programming ; Document type : R - Report ; Report number : IMAG-RR--520 ; Other identifier : FR ; FR_ 1987:658 ; handle : http://hdl.handle.net/10068/48354 Provenance : SIGLE ; Get a copy : INIST-CNRS - Institut de l'Information Scientifique et Technique Availability : CNRS 17660 Country \u2026", "num_citations": "70\n", "authors": ["258"]}
{"title": "Validation of synchronous reactive systems: from formal verification to automatic testing\n", "abstract": " This paper surveys the techniques and tools developped for the validation of reactive systems described in the synchronous data-flow language Lustre [HCRP91]. These techniques are based on the specification of safety properties, by means of synchronous observers. The model checker Lsesar [RHR91] takes a Lustre program, and two observers \u2014 respectively describing the expected properties of the program, and the assumptions about the system environment under which these properties are intended to hold \u2014, and performs the verification on a finte state (Boolean) abstraction of the system. Recent work concerns extensions towards simple numerical aspects, which are ignored in the basic tool. Provided with the same kind of observers, the tool Lurette [RWNH98] is able to automatically generate test sequences satisfying the environment assumptions, and to run the test while checking the\u00a0\u2026", "num_citations": "68\n", "authors": ["258"]}
{"title": "Specifying, programming and verifying real-time systems using a synchronous declarative language\n", "abstract": " We advocate the use of the synchronous declarative language Lustre as a unique language for specifying and programming real-time systems. Furthermore, we show that the finite automaton produced by the Lustre compiler may be used for verifying many logical properties, by model checking. The paper deals with an example program, extracted from a railways regulation system.", "num_citations": "62\n", "authors": ["258"]}
{"title": "Data-flow synchronous languages\n", "abstract": " In this paper, we present a theory of synchronous data-flow languages. Our theory is supported by both some heuristic analysis of applications and some theoretical investigation of the data-flow paradigm. Our model covers both behavioural and operational aspects, and allows both synchronous and asynchronous styles of implementation for synchronous programs. This model served as a basis to establish the GC common format for synchronous data-flow languages.", "num_citations": "61\n", "authors": ["258"]}
{"title": "Synchronous modelling of asynchronous systems\n", "abstract": " We investigate the use of synchronous languages to model partially asynchronous systems. Through the use of intermittent activations and assertions, synchronous processes can be composed according to various asynchronous models. Common synchronization and communication mechanisms can be described. The resulting descriptions can be simulated and verified, using classical tools of synchronous programming.", "num_citations": "60\n", "authors": ["258"]}
{"title": "Simulation and verification of asynchronous systems by means of a synchronous model\n", "abstract": " Synchrony and asynchrony are commonly opposed to each other. Now, in embedded applications, actual solutions are often situated in between, with synchronous processes composed in a partially asynchronous way. Examples of such intermediate solutions are GALS, quasi-synchronous periodic processes, deadline-driven task scheduling. In this paper, we illustrate the use of the synchronous paradigm to model and validate such partially asynchronous applications. We show that, through the use of sporadic activation of processes and simulation of non-determinism by the way of auxiliary inputs, the synchronous paradigm allows a precise control of asynchrony. The approach is illustrated on a real case study, proposed in the framework of the European integrated project \"Assert\"", "num_citations": "59\n", "authors": ["258"]}
{"title": "Programming and verifying critical systems by means of the synchronous data-flow language LUSTRE\n", "abstract": " We investigate the benefits of using a synchronous dataflow language for programming critical real-time systems. These benefits concern ergonomy\u2014since the dataflow approach meets traditional description tools used in this domain\u2014, and ability to support formal design and verification methods. We show, on a simple example, how the language LUSTRE and its associated verification tool LESAR, can be used to design a program, to specify its critical properties, and to verify these properties.", "num_citations": "59\n", "authors": ["258"]}
{"title": "From a synchronous declarative language to a temporal logic dealing with multiform time\n", "abstract": " Temporal logics were first used in computer science to describe the behaviour of concurrent systems [7, 1 t, 14]. More recently, some efforts [10, 12, 16] have been devoted to the design of temporal logics wellsuited to the description of the real-time aspects of the behaviour of computer systems. These works are generally based on linear time logics, and consider the time grain of such logics as a physical time unit.At the same time, several authors [2, 4, 5, 8, 9] have argued that synchronous reactive systems form a suitable framework for model! ing and programming real-time systems. The basic idea is that, from a suitable level of abstraction, the only notion which is necessary for describing a real-time system is the notion of instantaneous reaction to external events. In this framework, physical time is considered as an external event, without any privileged role, and conversely, any external event may be viewed as\u00a0\u2026", "num_citations": "56\n", "authors": ["258"]}
{"title": "On the symbolic analysis of combinational loops in circuits and synchronous programs\n", "abstract": " Combinational loops are very likely to appear in circuits compiled from high level languages, especially imperative synchronous languages like Esterel, Statecharts or Argos.These loops result from the fact that, both in circuits and in synchronous languages, the response of the system to incoming events can be viewed as a xpoint of some function. Such a loop can be accepted if a unique xpoint exists in any state which is reachable from the initial state of the system. Moreover, some\\care-set\", which expresses an assumption about inputs, should be taken into account. In this paper, we propose a complete Bddbased procedure to check the consistency of combinational loops and, when possible, to remove these loops without changing the semantics of the circuit. The method is presented in the framework of Boolean-encoded nite state machines.", "num_citations": "55\n", "authors": ["258"]}
{"title": "An experience in proving regular networks of processes by modular model checking\n", "abstract": " This paper presents a complete example of the use of the synchronous declarative language LUSTRE for the specification, description and verification of a resource arbiter, which is a regular network of hardware devices. The fact that both programs and properties may be expressed in LUSTRE is used to perform an inductive verification. An invariant property of the network is found, and merged with the description program. Verification is performed by model checking.", "num_citations": "55\n", "authors": ["258"]}
{"title": "POLLUX: A Lustre based hardware design environment\n", "abstract": " This paper presents a high-level hardware design environment called Pollux. A design description is written with the Lustre data-flow language, and used by the different Pollux tools to produce the corresponding synchronous circuit or, for example, a simulation program, that can be compiled and executed on a sequential machine. Lustre has been chosen because it is well-suited to hardware description, but it has also been extended to become a full synchronous hardware description language. The first extension allows the description of a floorplan to be included in a Lustre program. Other extensions (arrays, recursion or parameterized subprograms) have been introduced in order to make simpler the description of large designs, without loosing the primitive advantages of the language, especially precision and clarity. The circuits generated by Pollux are currently used to configure a Programmable Active Memory, where they can be executed.", "num_citations": "50\n", "authors": ["258"]}
{"title": "When the decreasing sequence fails\n", "abstract": " The classical method for program analysis by abstract interpretation consists in computing a increasing sequence with widening, which converges towards a correct solution, then computing a decreasing sequence of correct solutions without widening. It is generally admitted that, when the decreasing sequence reaches a fixpoint, it cannot be improved further. As a consequence, all efforts for improving the precision of an analysis have been devoted to improving the limit of the increasing sequence. In this paper, we propose a method to improve a fixpoint after its computation. The method consists in projecting the solution onto well-chosen components and to start again increasing and decreasing sequences from the result of the projection.", "num_citations": "43\n", "authors": ["258"]}
{"title": "Implementing reactive programs on circuits a hardware implementation of LUSTRE\n", "abstract": " Synchronous languages constitute effective tools for programming real-time systems as far as they can be efficiently implemented. Implementing them by hardware is of course a good way for increasing their performances. Moreover, configurable hardware is now available which makes practical such an implementation. This paper describes an implementation of the synchronous declarative language Lustre on a \u201cprogrammable active memory\u201d.", "num_citations": "41\n", "authors": ["258"]}
{"title": "Programmation et v\u00e9rification des syst\u00e8mes r\u00e9actifs: le langage LUSTRE\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "41\n", "authors": ["258"]}
{"title": "Some ways to reduce the space dimension in polyhedra computations\n", "abstract": " Convex polyhedra are often used to approximate sets of states of programs involving numerical variables. The manipulation of convex polyhedra relies on the so-called double description, consisting of viewing a polyhedron both as the set of solutions of a system of linear inequalities, and as the convex hull of a system of generators, i.e., a set of vertices and rays. The cost of these manipulations is highly dependent on the number of numerical variables, since the size of each representation can be exponential in the dimension of the space. In this paper, we investigate some ways for reducing the dimension: On one hand, when a polyhedron satisfies affine equations, these equations can obviously be used to eliminate some variables. On the other hand, when groups of variables are unrelated with each other, this means that the polyhedron is in fact a Cartesian product of polyhedra of lower dimensions\u00a0\u2026", "num_citations": "40\n", "authors": ["258"]}
{"title": "A complete finite prefix for process algebra\n", "abstract": " In this paper we show how to use McMillan\u2019s complete finite prefix approach for process algebra. We present the model of component event structures as a semantics for process algebra, and show how to construct a complete finite prefix for this model. We present a simple adequate order (using an order on process algebra expressions) as an optimization to McMillan\u2019s original algorithm", "num_citations": "33\n", "authors": ["258"]}
{"title": "About synchronous programming and abstract interpretation\n", "abstract": " Synchronous programming has been proposed during the last decade, as a new point of view on concurrency. A family of synchronous languages [IEEgl, Hal93b](eg, ESTEREL, STATECHARTS, ARGOS, LUSTRE, SIGNAL) has been based on this point of view, and devoted to the design of reactive systems, ie, computer systems whose role is to maintain a continuous, real-time, interaction with their environment.In the synchronous approach, concurrency is not considered as an implementation constraint, but as a programming facility for logical structuring of programs. Since synchronous concurrency has nothing to do with parallel or distributed execution, it can be defined without taking into account physical constraints, like communication or task execution delays. A synchronous process is supposed to be able to react instantaneously to incoming events, and to communicate instantaneously with other processes\u00a0\u2026", "num_citations": "33\n", "authors": ["258"]}
{"title": "A tutorial of Lustre\n", "abstract": " This document is an introduction to the language Lustre V4 and its associated tools. We will not give a systematic presentation of the language, but a complete bibliography is added. The basic references are 8, 12]. The most recent features (arrays, recursive nodes) are described in 32].", "num_citations": "33\n", "authors": ["258"]}
{"title": "An abstract domain extending difference-bound matrices with disequality constraints\n", "abstract": " Knowing that two numerical variables always hold different values, at some point of a program, can be very useful, especially for analyzing aliases: if i\u2009\u2260\u2009j, then A[i] and A[j] are not aliased, and this knowledge is of great help for many other program analyses. Surprisingly, disequalities are seldom considered in abstract interpretation, most of the proposed numerical domains being restricted to convex sets. In this paper, we propose to combine simple ordering properties with disequalities. \u201cDifference-bound matrices\u201d (or DBMs) is a domain proposed by David Dill, for expressing relations of the form \u201cx\u2009\u2212\u2009y\u2009\u2264\u2009c\u201d or \u201cc                 1\u2009\u2264\u2009x\u2009\u2264\u2009c                 2\u201d. We define dDBMs (\u201cdisequalities DBMs\u201d) as conjunctions of DBMs with simple disequalities of the form \u201cx\u2009\u2260\u2009y\u201d or \u201cx\u2009\u2260\u20090\u201d. We give algorithms on dDBMs, for deciding the emptiness, computing a normal form, and performing the usual operations of an\u00a0\u2026", "num_citations": "32\n", "authors": ["258"]}
{"title": "Compiling ARGOS into boolean equations\n", "abstract": " In most imperative synchronous languages (Esterel, Argos, Statecharts,...), the semantics of the control structures may be conveniently described as compositions of Mealy machines. This constitutes the usual formal semantics of Argos, for instance, where basic components are Mealy machines. On the other hand, the compilation process should not be based upon an explicit generation of the Mealy machine that represents the behaviour of the whole program, because this machine may have a very large number of states. Hence we try to perform a symbolic compilation into a Mealy machine implicitly represented by a set of Boolean equations.             We give here the direct semantics of Argos in terms of such equations, and show that this semantics coincides with the usual one. The current implementation of the Argos compiler produces DC code, which is the common equational format for synchronous\u00a0\u2026", "num_citations": "32\n", "authors": ["258"]}
{"title": "An executable temporal logic to express safety properties and its connection with the language Lustre\n", "abstract": " This paper studies the expressive power of the synchronous data-flow language LUSTRE as a specification language, and its connection with temporal logic. After a brief overview of LUsTRE, we define a temporal logic, called SL, which is shown to have exactly the expressive power of regular safety properties. Directly inspired from Boolean LUsTRE, this logic is executable, in the sense that the accepting automaton of any SL formula can be constructed \u201con the fly\u201d, as the model is read. Then we consider a fragment of SL, called DSL, for the formulas of which the accepting automaton built by the previous technique is deterministic. DSL is shown to have the same expressive power as SL, and to be equivalent to Boolean", "num_citations": "31\n", "authors": ["258"]}
{"title": "Compositional semantics of non-deterministic synchronous languages\n", "abstract": " A key feature of synchronous languages is that they conciliate concurrency with determinism. This is achieved by detecting so-called causality errors [BG92, HM95, STB95], which occur when the composition of deterministic processes is not deterministic. Although the existing synchronous languages only deal with deterministic programs, it is not a restriction of the approach. We show how a synchronous language can be extended with non deterministic processes, while still ensuring that process composition will never introduce non-determinism. We give an operational semantics of the language, and show that the equivalence relation induced by this semantics is a congruence for all the language constructs.", "num_citations": "30\n", "authors": ["258"]}
{"title": "Cartesian factoring of polyhedra in linear relation analysis\n", "abstract": " Linear Relation Analysis [CH78] suffers from the cost of operations on convex polyhedra, which can be exponential with the number of involved variables. In order to reduce this cost, we propose to detect when a polyhedron is a Cartesian product of polyhedra of lower dimensions, i.e., when groups of variables are unrelated with each other. Classical operations are adapted to work on such factored polyhedra. Our implementation shows encouraging experimental results.", "num_citations": "29\n", "authors": ["258"]}
{"title": "Abstract acceleration in linear relation analysis\n", "abstract": " Linear relation analysis is a classical abstract interpretation based on an over-approximation of reachable numerical states of a program by convex polyhedra. Since it works with a lattice of infinite height, it makes use of a widening operator to enforce the convergence of fixed point computations. Abstract acceleration is a method that computes the precise abstract effect of loops wherever possible and uses widening in the general case. Thus, it improves both the precision and the efficiency of the analysis. This article gives a comprehensive tutorial on abstract acceleration: its origins in Presburger-based acceleration including new insights w.r.t. the linear accelerability of linear transformations, methods for simple and nested loops, recent extensions, tools and applications, and a detailed discussion of related methods and future perspectives.", "num_citations": "27\n", "authors": ["258"]}
{"title": "Counter-example generation in symbolic abstract model-checking\n", "abstract": " The boundaries of model-checking have been extended through the use of abstraction. These techniques are conservative, in the following sense: when the verification succeeds, the verified property is guaranteed to hold; but when it fails, it may result either from the non satisfaction of the property, or from a too rough abstraction. In case of failure, it is, in general, undecidable whether an abstract trace corresponding to a counter-example has any concrete counterparts. For debugging purposes, one usually desires to go further than giving a \u201cyes/no\u201d answer (actually, a \u201cyes/don\u2019t know\u201d answer!), and look for such concrete counter-examples. We propose a solution in which we apply standard test-pattern generation technology to search for concrete instances of abstract traces.", "num_citations": "26\n", "authors": ["258"]}
{"title": "About synchronous programming and abstract interpretation\n", "abstract": " This paper intends to highlight the connection between synchronous programming and abstract interpretation. First, the specific technique for compiling synchronous programs into interpreted automata can be seen as a partial evaluation. The second point concerns program verification. Most critical properties of reactive systems are safety properties, which can be translated into invariants, through the use of synchronous observers. Invariants can be proved by means of approximate reachability analysis, which is probably the most studied application of abstract interpretation.", "num_citations": "26\n", "authors": ["258"]}
{"title": "An analysis of permutations in arrays\n", "abstract": " This paper is concerned with the synthesis of invariants in programs with arrays. More specifically, we consider properties concerning array contents up to a permutation. For instance, to prove a sorting procedure, one has to show that the result is sorted, but also that it is a permutation of the initial array. In order to analyze this kind of properties, we define an abstract interpretation working on multisets of values, and able to discover invariant equations about such multisets.", "num_citations": "20\n", "authors": ["258"]}
{"title": "Computer Aided Verification: 11th International Conference, CAV'99, Trento, Italy, July 6-10, 1999, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 11th International Conference on Computer Aided Verification, CAV'99, held in Trento, Italy in July 1999 as part of FLoC'99. The 34 revised full papers presented were carefully reviewed and selected from a total of 107 submissions. Also included are six invited contributions and five tool presentations. The book is organized in topical sections on processor verification, protocol verification and testing, infinite state spaces, theory of verification, linear temporal logic, modeling of systems, symbolic model checking, theorem proving, automata-theoretic methods, and abstraction.", "num_citations": "20\n", "authors": ["258"]}
{"title": "The synchronous languages 12 years later\n", "abstract": " Twelve years ago, PROCEEDINGS OF THE IEEE devoted a special section to the synchronous languages. This paper discusses the improvements, difficulties, and successes that have occured with the synchronous languages since then. Today, synchronous languages have been established as a technology of choice for modeling, specifying, validating, and implementing real-time embedded applications. The paradigm of synchrony has emerged as an engineerfriendly design method based on mathematically sound tools.", "num_citations": "17\n", "authors": ["258"]}
{"title": "Design of a multi-formalism application and distribution in a data-flow context: An example\n", "abstract": " This paper describes a multi-formalism experiment design in the domain of realtime control systems. It uses several synchronous languages on a case study which is a realistic industrial example. Co-simulation is provided through the use of a common format, and automatic distributed code generation is experimented in the context of the graphical environment of the data-flow language SIGNAL.", "num_citations": "17\n", "authors": ["258"]}
{"title": "Array indices relational semantic analysis using rational cosets and trapezoids\n", "abstract": " CiteSeerX \u2014 Array Indices Relational Semantic Analysis using Rational Cosets and Trapezoids Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Array Indices Relational Semantic Analysis using Rational Cosets and Trapezoids (1993) Cached Download as a PDF Download Links [www.cri.ensmp.fr] [www.cri.ensmp.fr] [chailly.ensmp.fr] Save to List Add to Collection Correct Errors Monitor Changes by Fran\u00e7ois Masdupuy Citations: 6 - 0 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases array index relational semantic analysis rational cosets Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us -\u2026", "num_citations": "17\n", "authors": ["258"]}
{"title": "Automatic control systems programming using a real time declarative language\n", "abstract": " LUSTRE is a declarative programming language based on the same principle as LUCID, i.e., programs operate over infinite sequences of values. The difference between LUSTRE and LUCID comes from the fact that LUSTRE is intended to be interpreted synchronously, i.e.. each variable is intended to possess the n-th value of its associated sequence at the n-th execution step of the program. This interpretation provides LUSTRE with real-time capabilities, since the execution steps of a program may be viewed as a physical time scale. This paper briefly presents the language and illustrates its use on several examples taken from the field of logical and numerical process control.", "num_citations": "17\n", "authors": ["258"]}
{"title": "A tutorial of Lustre\n", "abstract": " This document is an introduction to the language Lustre V4 and its associated tools. We will not give a systematic presentation of the language, but a complete bibliography is added. The basic references are [8, 12]. The most recent features (arrays, recursive nodes) are described in [32].", "num_citations": "16\n", "authors": ["258"]}
{"title": "Automatic verification of parameterized networks of processes\n", "abstract": " This paper describes a method to verify safety properties of parameterized networks of processes defined by network grammars. The method is based on the construction of a network invariant, defined as a fixpoint. We propose heuristics, based on Cousot's extrapolation techniques (widening), which often allow suitable invariants to be automatically constructed. We successively consider linear and binary tree networks. These techniques have been implemented in a verification tool, and several non-trivial examples are presented.", "num_citations": "14\n", "authors": ["258"]}
{"title": "From discrete duration calculus to symbolic automata\n", "abstract": " The goal of this paper is to translate (fragments of) the quantified discrete duration calculus QDDC, proposed by P. Pandya, into symbolic acceptors with counters. Acceptors are written in the synchronous programming language Lustre, in order to allow available symbolic verification tools (model-checkers, abstract interpreters) to be applied to properties expressed in QDDC. We show that important constructs of QDDC need non-deterministic acceptors, in order to be translated with a bounded number of counters, and an expressive fragment of the logic is identified and translated. Then, we consider a more restricted fragment, which only needs deterministic acceptors.", "num_citations": "12\n", "authors": ["258"]}
{"title": "Algebra of events: a model for parallel and real time systems.\n", "abstract": " CENTRE NATIONAL DE LA RECHERCHE SCIENTIFIQUE, LA 7, LABORATOIRE D'INFORMATIQUE ET DE MATHEMATIQUES APPLIQUEES DE GRENOBLE/GRENOBLE/FRA UNIVERSITY DE GRENOBLE 1, INSTITUT NATIONAL POLYTECHNIQUE DE GRENOBLE/GRENOBLE/FRA", "num_citations": "11\n", "authors": ["258"]}
{"title": "BAC: A boolean automaton checker\n", "abstract": " Bac is a Bdd-based symbolic verication tool devoted to\\Boolean automata\". A Boolean automaton is a nite state machine, where the next state is uniquely determined by the current state and the current values of inputs. A state is a vector of Boolean variables. The behavior of the automaton can be restricted by an\\assertion\", a Boolean formula which must be always true during any execution of the automaton. More precisely, the behaviors of the machine are exactly all the innite behaviors of the automaton (without assertion) which continuously satisfy the assertion. An\\invariant\" can also be specied, which will be veried by the tool. The transition function, the assertion and the invariant are given as Boolean formulas involving current state variables, current input variables, and possibly local variables which must be dened in turn. The denitions of local variables may present loops. Such automata appeared very\u00a0\u2026", "num_citations": "10\n", "authors": ["258"]}
{"title": "Use of time functions to describe and explain circuit behaviour\n", "abstract": " The paper illustrates the use of a mechanical model for describing the time behaviour of hardware. In this model, any variable is represented by a function of time, giving the value of the variable at each instant. Some tools are introduced for describing such functions, and the use of function algebra, for reasoning about hardware descriptions, is illustrated.", "num_citations": "10\n", "authors": ["258"]}
{"title": "Mod\u00e9lisation et analyse du comportement des systemes informatiques temporis\u00e9s\n", "abstract": " \u00c9tude d'un mod\u00e8le math\u00e9matique pour formaliser le comportement des syst\u00e8mes parall\u00e8les et temps r\u00e9el, \u00e0 des fins de sp\u00e9cification de probl\u00e8mes, de description, d'analyse et de preuve de r\u00e9alisations. Construction, \u00e0 partir des m\u00eames notions, d'un calcul formel conduisant \u00e0 des m\u00e9thodes syst\u00e9matiques d'analyse de syst\u00e8mes logiques temporis\u00e9s, au niveau algorithmique", "num_citations": "7\n", "authors": ["258"]}
{"title": "An application of Laplace transform techniques to the analysis of timed Petri nets\n", "abstract": " An Application of Laplace Transform Techniques to the Analysis of Timed Petri Nets | International Workshop on Timed Petri Nets ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsInternational Workshop on Timed Petri NetsAn Application of Laplace Transform Techniques to the Analysis of Timed Petri Nets Article An Application of Laplace Transform Techniques to the Analysis of Timed Petri Nets Share on Authors: Paul Caspi profile image Paul Caspi View Profile , Nicolas Halbwachs profile image Nicolas Halbwachs View Profile Authors Info & Affiliations Publication: International Workshop on Timed Petri NetsJuly 1985 40(\u2026", "num_citations": "6\n", "authors": ["258"]}
{"title": "Disjunctive relational abstract interpretation for interprocedural program analysis\n", "abstract": " Program analysis by abstract interpretation using relational abstract domains\u2014like polyhedra or octagons\u2014easily extends from state analysis (construction of reachable states) to relational analysis (construction of input-output relations). In this paper, we exploit this extension to enable interprocedural program analysis, by constructing relational summaries of procedures. In order to improve the accuracy of procedure summaries, we propose a method to refine them into disjunctions of relations, these disjunctions being directed by preconditions on input parameters.", "num_citations": "5\n", "authors": ["258"]}
{"title": "Abstract acceleration to improve precision of linear relation analysis\n", "abstract": " This work deals with verification of safety properties of programs, and more specifically with numerical properties. Linear Relation Analysis, which is an abstract interpretation based on a approximation of numerical states by convex polyhedra, has proved its efficiency. It consists in generating polyhedral overapproximations of the set of valuations associated to each control point. The introduction of a widening operator ensures the convergence of the analyses. However in some cases the invariants generated are not precise enough and improving the precision by delaying the widening is too costly. That is why we have considered so-called acceleration methods, which consist in computing the exact effect of one or several loops (as Presburger formulae). The main drawback of these methods is that they apply only to a restricted class of programs. In this thesis, we propose an approach combining the classical Linear Relation Analysis (with widening) and the notion of Abstract Acceleration which is useful in order to compute a precise overapproximation of the iterate application of certain types of loops. We aim at improving the precision of the analyses while always guaranteeing termination. The first experimental results obtained thanks to our tool Aspic have allowed to validate the method, which increase both precision and efficacity.;Abstract: Le travail d\u00e9crit dans cette th\u00e8se s' inscrit dans le contexte de la validation de propri\u00e9t\u00e9s de s\u00fbret\u00e9 de programmes, et plus particuli\u00e8rement des propri\u00e9t\u00e9s num\u00e9riques. L'utilisation de la technique d'Analyse des Relations Lin\u00e9aires, une interpr\u00e9tation abstraite fond\u00e9e sur une approximation des \u00e9tats\u00a0\u2026", "num_citations": "5\n", "authors": ["258"]}
{"title": "On the timed automata-based verification of Ravenscar systems\n", "abstract": " The Ravenscar profile for Ada enforces several restrictions on the usage of general-purpose tasking constructs, thereby facilitating most analysis tasks and in particular functional and timing verification using model checking. This paper presents an experiment in translating the Ravenscar fragment of Ada into the input language of a timed model checker (IF [7, 8]), discusses the difficulties and proposes solutions for most constructs supported by the profile. The technique is evaluated in a small case study issued from a space application, on which we present verification results and conclusions.", "num_citations": "5\n", "authors": ["258"]}
{"title": "M ethodes de v erification des syst emes finis\n", "abstract": " Historique, Floyd, Hoare [Flo67, Hoa69] Principes: pre-post-conditions, semantique axiomatique. Invariants de boucles. Non automatique, necessite des demonstrateurs, dedie aux programmes terminants. Extensions paralleles compliquees [OG76, Lam80]. Il est bien connu que la verication formelle des programmes pose des problemes indecidables. En consequence, on est place devant un choix incontournable: Ou bien appliquer des methodes de verication generales, et donc necessairement non automatiques; ou alors se contenter de methodes partielles ou applicables dans des domaines particuliers, methodes dont l\u2019automatisation est possible. Les premieres consistent a raisonner dans un systeme formel (methodes syntaxiques) alors que les secondes sont fondees sur l\u2019analyse d\u2019un modele semantique du programme.Les methodes syntaxiques (VDM, Z, B, methodes algebriques, etc.) consistenta\u00a0\u2026", "num_citations": "5\n", "authors": ["258"]}
{"title": "Synchronous modeling and validation of schedulers dealing with shared resources\n", "abstract": " Architecture Description Languages (ADLs) allow embedded systems to be described as assemblies of hardware and software components. It is attractive to use such a global modelling as a basis for early system analysis. However, in such descriptions, the applicative software is often abstracted away, and is supposed to be developed in some host programming language. This forbids to take the applicative software into account in such early validation. To overcome this limitation, a solution consists in translating the ADL description into an executable model, which can be simulated and validated together with the software. In a previous paper [8], we proposed such a translation of AADL (Architecture Analysis & Design Language) specifications into an executable synchronous model. The present paper is a continuation of this work, and deals with expressing the behavior of complex scheduling policies managing shared resources. We provide a synchronous specification for two shared resource scheduling protocols: the well-known basic priority inheritance protocol (BIP), and the priority ceiling protocol (PCP). This results in an automated translation of AADL models into a purely Boolean synchronous (Lustre) scheduler, that can be directly model-checked, possibly with the actual software.", "num_citations": "4\n", "authors": ["258"]}
{"title": "Stability of discrete sampled systems\n", "abstract": " We consider the wide class of real-time systems that periodically sample their inputs. A desirable property of such systems is that their outputs should be, in some sense, more precise when the sampling period gets shorter. An approximation of this property consists in requiring that, whenever the inputs don\u2019t change, the outputs stabilize after a finite number of steps. We present a set of heuristics to check this stability property, in the case of purely Boolean systems. These heuristics have been experimented on a nuclear plant control software, and have been shown to dramatically reduce the cost of stability analysis.", "num_citations": "4\n", "authors": ["258"]}
{"title": "An Approach to Real Time Systems Modeling.\n", "abstract": " In this paper, real time discrete systems are considered in a rather restrictive sense: In ordi-nary systems, only functional and temporal ordering relationships between input/output variables are relevant for the user, and time appears only as a speed criterion that allows to compare different functionally equivalent systems. In real time systems, time relationships between external variables are also important in order to decide of the adequacy of the system to its requirements. For instance, many logical or numerical automatic control systems, signal and picture processing systems, that were formerly realized using analog or discrete technologies, are now implemented on (multi\u2013) mini or microcomputers, for evident reasoms of cost, versatility, computing power and reliability. In most of these systems, furdamental time constraints appear.(frequencies, response times...).", "num_citations": "4\n", "authors": ["258"]}
{"title": "04491 Executive Summary--Synchronous Programming-SYNCHRON'04\n", "abstract": " This seminar was the 11th in a series of semi-annual workshops on the Synchronous Languages (Esterel, Lustre, and Signal). These languages were invented in the early 1980's to make the programming of reactive systems easier. The goal of the seminar was to bring together researchers and practitioners of synchronous programming, and furthermore to reach out to relevant related areas and industrial users.", "num_citations": "3\n", "authors": ["258"]}
{"title": "Automatic construction of network invariants\n", "abstract": " We describe a method to verify safety properties of parameterized linear networks of processes. A network invariant is de ned as a xpoint, and computed using heuristics based on Cousot's widening techniques.", "num_citations": "3\n", "authors": ["258"]}
{"title": "ANALYSE APPROCHEE DU COMPORTEMENT ASYMPTOMATIQUE DE SYSTEMES TEMPORISES\n", "abstract": " CENTRE NATIONAL DE LA RECHERCHE SCIENTIFIQUE, LA 7, LABORATOIRE D'INFORMATIQUE ET DE MATHEMATIQUES APPLIQUEES DE GRENOBLE, EQUIPE CONCEPTION ET SECURITE DES SYSTEMES/GRENOBLE/FRA UNIVERSITE DE GRENOBLE 1, INSTITUT NATIONAL POLYTECHNIQUE DE GRENOBLE/GRENOBLE/FRA", "num_citations": "3\n", "authors": ["258"]}
{"title": "Improving the results of program analysis by abstract interpretation beyond the decreasing sequence\n", "abstract": " The classical method for program analysis by abstract interpretation consists in computing first an increasing sequence using an extrapolation operation, called widening, to correctly approximate the limit of the sequence. Then, this approximation is improved by computing a decreasing sequence without widening, the terms of which are all correct, more and more precise approximations. It is generally admitted that, when the decreasing sequence reaches a fixpoint, it cannot be improved further. As a consequence, most efforts for improving the precision of an analysis have been devoted to improving the limit of the increasing sequence. In a previous paper, we proposed a method to improve a fixpoint after its computation. This method consists in computing from the obtained solution a new starting value from which increasing and decreasing sequences are computed again. The new starting value is\u00a0\u2026", "num_citations": "2\n", "authors": ["258"]}
{"title": "When the worst-case execution time estimation gains from the application semantics\n", "abstract": " Critical embedded systems are generally composed of repetitive tasks that must meet drastic timing constraints, such as termination deadlines. Providing an upper bound of the worst-case execution time (WCET) of such tasks at design time is thus necessary to prove the correctness of the system. Static timing analysis methods compute safe WCET upper bounds, but at the cost of a potentially large over-approximation. Over-approximation may come from the fact that WCET analysis may consider as potential worst-cases some executions that are actually infeasible, because of the semantics of the program and/or because they correspond to unrealistic inputs. In this paper, we introduce a complete semantic-aware WCET estimation workflow. We introduce some program analysis to find infeasible paths: they can be performed at design, C or binary level, and may take into account information provided by the user. We design an annotation-aware compilation process that enables to trace the infeasible path properties through the program transformations performed by the compilers. Finally, we adapt the WCET estimation tool to take into account the kind of annotations produced by the workflow.", "num_citations": "2\n", "authors": ["258"]}
{"title": "On the design of widening operators\n", "abstract": " Automatic verification mainly consists in computing fixpoints of monotone functions on lattices.Example: computation of reachable states", "num_citations": "2\n", "authors": ["258"]}
{"title": "Synchronous programming\n", "abstract": " Synchronous programming languages are programming languages with an abstract (logical) notion of time: The execution of such programs is divided into discrete reaction steps, and in each of these reactions steps, the program reads new inputs and reacts by computing corresponding outputs of the considered reaction step. The programs are called synchronous because all outputs are computed together in zero time within a step and because parallel components synchronize their reaction steps by the semantics of the languages. For this reason, the synchronous composition is deterministic, which is a great advantage concerning predictability, verification of system design, and embedded code generation. Starting with the definition of the classic synchronous languages Esterel, Lustre and Signal in the late 1980\u2019s, the research during the past 20 years was very fruitful and lead to new languages, compilation\u00a0\u2026", "num_citations": "2\n", "authors": ["258"]}
{"title": "Lecture Notes in Computer Science: Preface\n", "abstract": " Lecture Notes in Computer Science: Preface \u2014 Penn State Skip to main navigation Skip to search Skip to main content Penn State Logo Help & FAQ Home Researchers Research Output Research Units Core Facilities Grants & Projects Prizes Activities Lecture Notes in Computer Science: Preface Chita Das, Hequan Wu School of Electrical Engineering and Computer Science Research output: Contribution to journal \u203a Editorial Overview Fingerprint Original language English (US) Pages (from-to) v Journal Lecture Notes in Computer Science Volume 3619 State Published - Oct 19 2005 Event Third International Conference on Computer Network and Mobile Computing, ICCNMC 2005 - Zhangjiajie, China Duration: Aug 2 2005 \u2192 Aug 4 2005 All Science Journal Classification (ASJC) codes Theoretical Computer Science Computer Science(all) Access to Document Link to publication in Scopus Link to citation list in Cite .'\u2026", "num_citations": "2\n", "authors": ["258"]}
{"title": "Tools and Algorithms for the Construction and Analysis of Systems: 11th International Conference, TACAS 2005, Held as Part of the Joint European Conference on Theory and\u00a0\u2026\n", "abstract": " ETAPS 2005 was the eighth instance of the European Joint Conferences on Theory and Practice of Software. ETAPS is an annual federated conference that was established in 1998 by combining a number of existing and new conf-ences. This year it comprised? ve conferences (CC, ESOP, FASE, FOSSACS, TACAS), 17 satellite workshops (AVIS, BYTECODE, CEES, CLASE, CMSB, COCV, FAC, FESCA, FINCO, GCW-DSE, GLPL, LDTA, QAPL, SC, SLAP, TGC, UITP), seven invited lectures (not including those that were speci? c to the satellite events), and several tutorials. We received over 550 submissions to the? ve conferences this year, giving acceptance rates below 30% for each one. Congratulations to all the authors who made it to the? nal program! I hope that most of the other authors still found a way of participating in this exciting event and I hope you will continue submitting. The events that comprise ETAPS address various aspects of the system-velopment process, including speci? cation, design, implementation, analysis and improvement. The languages, methodologies and tools which support these-tivities are all well within its scope. Di? erent blends of theory and practice are represented, with an inclination towards theory with a practical motivation on the one hand and soundly based practice on the other. Many of the issues involved in software design apply to systems in general, including hardware s-tems, andtheemphasisonsoftwareisnotintendedtobeexclusive.", "num_citations": "2\n", "authors": ["258"]}
{"title": "Proceedings of the 11th International Conference on Computer Aided Verification\n", "abstract": " Proceedings of the 11th International Conference on Computer Aided Verification | Guide Proceedings ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsCAV '99 Export Citation Select Citation format Download citation Copy citation Categories Journals Magazines Books Proceedings SIGs Conferences Collections People About About ACM Digital Library Subscription Information Author Guidelines Using ACM Digital Library All Holdings within the ACM Digital Library ACM Computing Classification System Join Join ACM Join SIGs Subscribe to Publications Institutions and Libraries Connect Contact Facebook Twitter The is . , \u2026", "num_citations": "2\n", "authors": ["258"]}
{"title": "Test automatique de syst\u00e8mes r\u00e9actifs\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "2\n", "authors": ["258"]}
{"title": "Synchronous observers and the verification of reactive systems\n", "abstract": " Synchronous programming (20, 14) is a useful approach to design reactive sys-tems. A synchronous program is supposed to instantly and deterministically react to events coming from its environment. The advantages of this approach have been pointed out elsewhere (20). Synchronous languages are simple and clean, they have been given simple and precise formal semantics, they allow especially elegant programming style. They conciliate concurrency (at least at the description level) with determinism. They can be compiled into a very effi-cient sequential code, by means of as pecific compiling technique: The control structure of the object code is a finite automaton which is synthesized by an exhaustive simulation of a finite abstraction of the program. Concerning program verification, it has been argued (8, 16, 29) that the practical goal, for reactive programs, is generally to verify some simple logical safety properties: By a safety property, we mean, as usual, a property which expresses that something will never happen, and by a simple logical property, we mean a property which depends on logical dependences between events, rather than on complex relations between numerical values. For the verification of such properties also, the synchronous approach has some advantages: Since the parallel composition is synchronous, the desired properties of a program can be easily and modularly expressed by means of an observer, ie, another program which observes the behavior of the first one and decides whether it is correct. Thus, the same language is used to write the program and its desired properties. The verification then consists in\u00a0\u2026", "num_citations": "2\n", "authors": ["258"]}
{"title": "a Lustre-based hardware design environment\n", "abstract": " The range of applications that can be implemented by hardware have been extended by the generalization of the use of ASICs and the apparition of new kinds of components like programmable gate arrays, which reduce both design time and cost. These solutions, which result from the increasing VLSI chip density, give alternative solutions to custom hardware limited to specific applications. An other way to reduce the design time is the development of powerful automatic tools (for logic minimization, placement, routing,...) and very high level CAD systems. These tools have many other advantages and become absolutely necessary since designs are more and more complex; they simplify design descriptions, make them as independent as possible of the technology or limit design errors. The key element of such a CAD system is the description language, which must be adapted to this use. For Pollux, we choose the synchronous declarative language", "num_citations": "2\n", "authors": ["258"]}
{"title": "Techniques d \u2018interaction avec de grands graphes\n", "abstract": " Le projet de recherche a traita la conception ergonomique eta la realisation logicielle de techniques d\u2019interaction avec de grands graphes. L\u2019\u00e9ude en prenant en compte la specificite des donnees manipulees, des graphes, visea contribuera l\u2019amelioration de\u201d l\u2019utilisabilite\u201d des systemes qui exploitent des graphes. De tres nombreux domaines d\u2019application reposent sur la manipulation, l\u2019exploration et la navigation dans de grands graphes comme la navigation dans les bases de donnees video, l\u2019exploration de cartes ou reseaux semantiques et la visualisation de structures biologiques.", "num_citations": "1\n", "authors": ["258"]}
{"title": "Lustre program verification: the tool Lesar\n", "abstract": " As noted in the introduction, reactive systems often concern critical applications, and thus program verification is a key issue. However, many practitioners in the field are skeptical about the use of formal verification methods, and convincing arguments need to be provided in order to support the claim that such methods are indeed of practical interest. This is the object of the following discussion.", "num_citations": "1\n", "authors": ["258"]}
{"title": "The synchronous data-flow language Lustre\n", "abstract": " The synchronous language Lustre was designed in the eighties, and resulted in the industrial software development tool Scade1, which is now in use in many major companies developing embedded software (avionics, transportation, energy,...).[Hal05] tells the story of Lustre and Scade.Lustre is based on the synchronous paradigm [IEE91, Hal93, BCE+03]: the behaviour of a program is a sequence of reactions, each reaction consisting of reading the current inputs, computing the current outputs, and updating the internal state. So, a program typically implements an automaton: the states are the valuations of the memory, and each reaction corresponds to a transition of the automaton. Such a transition may involve many computations, which, from the automaton point of view, are considered atomic (ie, input changes are only taken into account between two reactions). This is the essence of the synchronous paradigm, where such a reaction is often said to take no time. An atomic reaction is called an instant (logical time), and all the events occurring during such a reaction are considered simultaneous. The way this logical time scale is defined, ie, the way these reactions are triggered, is left to the environment: a program can be either event-triggered or time-triggered.", "num_citations": "1\n", "authors": ["258"]}
{"title": "The synchronous data-\ufb02ow programming language Lustre\n", "abstract": " This paper describes the language LUSTRE, Which is a data\ufb02oW synchronous language, designed for programming reactive systems* such as automatic control and monitoring systems* as Well as for describing hardware. The data\ufb02oW aspect of LUSTRE makes it very close to usual description tools in these domains (block-diagrams, networks of operators, dynamical samples-systems, etc...), and its synchronous interpretation makes it Well suited for handling time in programs. Moreover, this synchronous interpretation alloWs it to be compiled into an e\ufb02icient sequential program. Finally, the LUSTRE formalism is very similar to temporal logics. This alloWs the language to be used for both Writing programs and expressing program properties, Which results in an original program veri\ufb01cation methodology.", "num_citations": "1\n", "authors": ["258"]}
{"title": "Specification and validation of embedded systems: A case study of a fault-tolerant data acquisition system with Lustre programming environment\n", "abstract": " We show how to specify and validate an embedded system using the Lustre programming environment. The case-study considered is a fault-tolerant system for the acquisition of gyroscopic data in a military aircraft. We illustrate the use of Lustre tools for describing, simulating, and verifying the system. Beside, we show how the formalization of the requirements by means of an executable language allows ambiguities to be removed, and how the system can be developed step by step, while simulation and validation take place at each step. We believe that this example is representative of a wide class of embedded systems.", "num_citations": "1\n", "authors": ["258"]}