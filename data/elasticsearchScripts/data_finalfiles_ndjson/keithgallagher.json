{"title": "Using program slicing in software maintenance\n", "abstract": " Software maintenance is the process of designing and integrating consistent changes to an existing software system. Doing effective maintenance is a complex task due in part to the size and complexity of the maintained software, and the widely varying maintenance support tools and environments that are available. For the maintainer, these problems are compounded since most existing software was produced prior to the use of structured techniques. It is difficult for the maintainer to ascertain the complete effect of a code change. This in turn, requires robust regression testing even when the change is small.", "num_citations": "978\n", "authors": ["984"]}
{"title": "Software architecture visualization: An evaluation framework and its application\n", "abstract": " In order to characterize and improve software architecture visualization practice, the paper derives and constructs a qualitative framework, with seven key areas and 31 features, for the assessment of software architecture visualization tools. The framework is derived by the application of the Goal Question Metric paradigm to information obtained from a literature survey and addresses a number of stakeholder issues. The evaluation is performed from multiple stakeholder perspectives and in various architectural contexts. Stakeholders can apply the framework to determine if a particular software architecture visualization tool is appropriate to a given task. The framework is applied in the evaluation of a collection of six software architecture visualization tools. The framework may also be used as a design template for a comprehensive software architecture visualization tool.", "num_citations": "74\n", "authors": ["984"]}
{"title": "Overlapping community detection by collective friendship group inference\n", "abstract": " There has been considerable interest in improving the capability to identify communities within large collections of social networking data. However, many of the existing algorithms will compartment an actor (node) into a single group, ignoring the fact that in real-world situations people tend to belong concurrently to multiple groups. Our work focuses on the ability to find overlapping communities by aggregating the community perspectives of friendship groups, derived from egonets. We will demonstrate that our algorithm not only finds overlapping communities, but additionally helps identify key members, which bind communities together. Additionally, we will highlight the parallel feature of the algorithm as a means of improving runtime performance.", "num_citations": "60\n", "authors": ["984"]}
{"title": "An architecture for interoperable program understanding tools\n", "abstract": " Program understanding tools are currently not interoperable, leading researchers to waste significant resources reinventing already existing tools. Even commercial environments that have been designed to support the construction of program understanding tools have serious flaws in this regard. This paper discusses CORUM (Common Object-based Re-engineering Unified Model), an architecture to support interoperability between program understanding tools, and it provides several examples of CORUM's use in the construction of new tools for concept recognition and program visualization.", "num_citations": "50\n", "authors": ["984"]}
{"title": "Visual Impact Analysis.\n", "abstract": " The Surgeon's Assistant is a case tool for software maintainers and developers of ansi C programs. It is based on the premises that maintainers need to be able to limit the scope of changes and that (most) development starts from some existing, similar systems.The Decomposition Slice Display System (dsds xvcg), a component of the Surgeon's Assistant, automates and visualizes impact analysis by displaying the relationships among a program's decomposition slices. It allows the software maintainer to visually comprehend the relationships between the decomposition slices. The dsds xvcg uses the interface of a tool for Visualizing Compiler Graphs, VCG, to present the lattice of the decomposition slices for the user's perusal. It allows the user to manipulate the graph by deleting and coloring nodes, and by collapsing regions. The software maintainer is provided with an visualization of the impact of proposed changes and can plan maintenance accordingly.", "num_citations": "46\n", "authors": ["984"]}
{"title": "Evaluating the surgeon's assistant: Results of a pilot study\n", "abstract": " The author reports on an empirical evaluation of decomposition slicing as a maintenance method as implemented in the Surgeon's Assistant. The improvement-oriented software maintenance model presented by HD Rombach and BT Ulery (1988) is used as the foundation. A reprise of software process modeling, a short introduction to software maintenance process modeling, and the definition of the evaluation model are presented. Decomposition slicing induces changes in the standard maintenance model; the evaluation attempts to measure the effectiveness of the induced model as compared with the standard one. The evaluation is a pilot study. A preliminary comparison is made using certain defined metrics. This yields some insights into the strengths and weaknesses of the tool and its applicability in certain scenarios.<>", "num_citations": "42\n", "authors": ["984"]}
{"title": "Overlapping community detection using a community optimized graph swarm\n", "abstract": " Detection of communities within social networks is a nontrivial problem. Allowing communities to overlap\u2014i.e. nodes can belong to more than one community simultaneously\u2014further complicates the problem. Nevertheless, people do belong to multiple social groups simultaneously and being able to detect overlapping communities is an important step into being able to understand and analyze social networks. A common practice in community detection (clustering) is to view the network (graph) as a whole and have a central control process determine how nodes are clustered. That central control, we believe, is a limitation to performance. In our previous work, we showed that the individual\u2019s view of his or hers social groups could be aggregated to produce communities. In this paper, we propose a unique approach to community detection that combines the individual\u2019s view of a community, not having the\u00a0\u2026", "num_citations": "40\n", "authors": ["984"]}
{"title": "Program slicing\n", "abstract": " Program slicing is a decomposition technique that elides program components not relevant to a chosen computation, referred to as a slicing criterion. The remaining components form an executable program called a slice that computes a projection of the original program\u2019s semantics. Using examples coupled with fundamental principles, a tutorial introduction to program slicing is presented. Then applications of program slicing are surveyed, ranging from its first use as a debugging technique to current applications in property verification using finite state models. Finally, a summary of research challenges for the slicing community is discussed.", "num_citations": "37\n", "authors": ["984"]}
{"title": "Improving visual impact analysis\n", "abstract": " Visual impact analysis is a software visualisation technique that lets software maintainers judge the impact of proposed changes and plan maintenance accordingly. An existing CASE tool uses a directed acyclic graph display derived from decomposition slicing of a program for visual impact analysis. In this paper, we analyse the graph display and show that it is semantically ambiguous and fails to show important information. We propose requirements for an improved display based on a definition of \"interference\" between variables in a maintenance context. The design for a new display is presented with a series of examples to illustrate its effectiveness. The display is focused on providing a straightforward method to analyse the impact of changes.", "num_citations": "37\n", "authors": ["984"]}
{"title": "A program decomposition scheme with applications to software modification and testing\n", "abstract": " The authors use M. Weisers (1984) technique, to approximate the notion of direct-sum decomposition for the flowgraph representation of a program. Given a program slice, they define its complement and demonstrate how to obtain it; the slices and complements are used to define the components of the decomposition. These components are independent in the sense that they are executable projections of a subset of the program's specification and can have nonempty intersections. The authors characterize those projections that give a nontrivial decomposition and demonstrate how to extend any given projection to a maximal component with respect to the decomposition. Statements and variables within the components are characterized according to their appearance in other components. Variables and/or statements that appear in more than one component can be combined into one component that will\u00a0\u2026", "num_citations": "32\n", "authors": ["984"]}
{"title": "Using program decomposition to guide modifications\n", "abstract": " The authors use data-flow techniques to form a notion of direct sum decomposition for programs. The decomposition yields a method and guidelines for software maintainers to use so that changes can be assured to be completely contained in the modules under consideration and that there are no undetected linkages between the modified and unmodified code. Thus, the impact of small changes can be gauged. The decomposition can also be used to limit the amount of testing required to assure that the change is correct; under suitable conditions, modification testing will be required only for the changed code. Moreover, if these hypotheses are violated, the modifier can be virtually assured that proposed changes will have a wider impact than that which is contemplated.<>", "num_citations": "25\n", "authors": ["984"]}
{"title": "A Framework for Software Architecture Visualisation Assessment\n", "abstract": " In order to assess software architecture visualisation strategies, we qualitatively characterize then construct an assessment framework with 7 key areas and 31 features. The framework is used for evaluation and comparison of various strategies from multiple stakeholder perspectives. Six existing software architecture visualisation tools and a seventh research tool were evaluated. All tools exhibited shortcomings when evaluated in the framework", "num_citations": "21\n", "authors": ["984"]}
{"title": "Reducing visualization complexity using decomposition slices\n", "abstract": " Program comprehension is the process in which software engineers gain an understanding of a system. A program comprehension environment provides tools to capture and manipulate information to carry out understanding tasks. We describe an information model and framework for program understanding and show how decomposition slicing (a maintenance method) can be incorporated into this framework. In so doing we discovered a way to signi cantly simplify the presentation of the decomposition slices while not losing information content proportional to the size of the reduction. We report some preliminary data in applying the reduction technique.", "num_citations": "19\n", "authors": ["984"]}
{"title": "Listening to program slices\n", "abstract": " Comprehending a computer program can be a daunting task. There is much to understand, including the interaction among different portions of the code. Program slicing can help one to understand this interaction. Because present-day visual development environments tend to become cluttered, the authors have explored sonification of program slices in an attempt to determine if it is practical to offload some of the visual information. Three slice sonification techniques were developed, resulting in an understanding of how to sonify slices in a manner appropriate for the software developer undertaking program comprehension activities. The investigation has also produced a better understanding of sonification techniques that are musical yet non-melodic and non-harmonic. These techniques were demonstrated to a small set of developers, each reporting that the techniques are promising and useful.", "num_citations": "18\n", "authors": ["984"]}
{"title": "Some notes on interprocedural program slicing\n", "abstract": " Weiser's algorithm for computing interprocedural slices has a serious drawback: it generates spurious criteria which are not feasible in the control flow of the program. When these extraneous criteria are used the slice becomes imprecise in that it has statements that are not relevant to the computation. Horwitz, Reps and Binkley solved this problem by devising the system dependence graph with an associated algorithm that produced more precise interprocedural slices. We take a \"step backward'' and show how to generate exactly the interprocedural slicing criteria needed, using the program's call graph or a stack. This technique can also be used on a family of program dependence graphs that represent all procedures in a program and are not interconnected by a system dependence graph. Then we show how to use the Horwitz, Reps and Binkley interprocedural slicing algorithm to generate criteria and show that\u00a0\u2026", "num_citations": "14\n", "authors": ["984"]}
{"title": "EgoClustering: overlapping community detection via merged friendship-groups\n", "abstract": " There has been considerable interest in identifying communities within large collections of social networking data. Existing algorithms will classify an actor (node) into a single group, ignoring the fact that in real-world situations people tend to belong concurrently to multiple (overlapping) groups. Our work focuses on the ability to find overlapping communities. We use egonets to form friendship-groups. A friendship-group is a localized community as seen from an individual\u2019s perspective that allows an actor to belong to multiple communities. Our algorithm finds overlapping communities and identifies key members that bind communities together. Additionally, we will highlight the parallel feature of the algorithm as a means of improving runtime performance, and the ability of the algorithm to run within a database and not be constrained by system memory.", "num_citations": "11\n", "authors": ["984"]}
{"title": "Detecting overlapping communities in complex networks using swarm intelligence for multi-threaded label propagation\n", "abstract": " We propose a unique approach to finding overlapping communities within complex networks that leverages swarm intelligence, for decentralized multi-threading processing, with label propagation, for its fast identification of communities. The combination of the two technologies offers a high performance approach to overlapped community detection that allow for the processing of very large networks in tractable time.", "num_citations": "11\n", "authors": ["984"]}
{"title": "Guaranteed inconsistency avoidance during software evolution\n", "abstract": " The attempt to design and integrate consistent changes to an existing system is the essence of software maintenance. Software developers also confront similar problems: there are changes during testing and the release of new system builds. Whether in development or maintenance, changes to evolving systems must be made consistently; that is, without damaging correct computations. It is difficult for the programmer to ascertain the complete effect of a code change; the programmer may make a change to a program that is syntactically and semantically legal, but which has ripples into the parts of the program that were intended to remain unchanged. Using the standard denotational semantics for procedural programming languages, this paper formalizes decomposition slicing, which identifies interferences between software components and isolates the components to be changed. We enumerate the conditions\u00a0\u2026", "num_citations": "10\n", "authors": ["984"]}
{"title": "Conditions to assure semantically consistent software merges in linear time\n", "abstract": " Software maintenance is the process of designing and integrating consistent changes to an existing software system. It is difficult for the maintainer to ascertain the complete effect of a code change; the maintainer may make a change to a program that is syntactically and semantically legal, but has ripples into the parts of the program that were to remain unchanged. A decomposition slice is the union of certain program slices and can be used to decompose a program into a fixed part and and changing part. A decomposition slice induces guidelines for maintainers to use so that changes can be assured to be completely contained in the modules under consideration and that there are no undetected linkages between the modified and unmodified code. In this paper we review the conditions for changing on component in ways that will guarantee that the two components will not interact in any untoward fashion. What\u00a0\u2026", "num_citations": "9\n", "authors": ["984"]}
{"title": "Using sound to understand software architecture\n", "abstract": " Use of non-speech sound can facilitate the understanding of a software program. Non-speech sound has been shown to be useful in dynamic program comprehension, that is, understanding the dynamic behavior of a program. We have developed a sonification scheme to describe static software entities in Java programs, and we show that it is useful in static program comprehension, notably concerning low-level architecture. The scheme is implemented via a tool in which an Eclipse IDE is integrated with a CSound synthesis engine. The tool is intended for use by sighted software developers in a static browsing/editing environment.", "num_citations": "8\n", "authors": ["984"]}
{"title": "Certifying software robustness using program slicing\n", "abstract": " Robustness of a program is the degree of system correctness of all parts. Measuring robustness is a goal for many researchers. In this paper, program slicing is used to build a robustness hierarchy, where this hierarchy will be used to test, and build a robust program.", "num_citations": "7\n", "authors": ["984"]}
{"title": "Regression test selection by exclusion using decomposition slicing\n", "abstract": " This research uses an exclusive technique to reduce the regression tests size. Exclusive technique means that a large number of tests will be excluded and leave a relatively small but safe test set. Decomposition slicing is used to empirically investigate whether it can reduce regression tests by an exclusive technique. Decomposition slicing provides a technique to identify the unchanged parts of the system. An exclusive technique will be analysed using an existing analysing framework to compare with its counterpart, the inclusive technique. This research expects to propose a new safe regression test selection by an exclusion technique using decomposition slicing.", "num_citations": "7\n", "authors": ["984"]}
{"title": "Teaching software maintenance\n", "abstract": " This paper outlines the content and techniques used to teach software maintenance to American university sophomores (second year students) who have had 3 semesters of programming. The course uses an introductory text that is geared to the maturity of the audience. By turning the project of the introductory course into a large software evolution exercise, the major topics of software engineering can still be easily introduced and examined. We present the course organization, evaluation rubrics, and student and instructor experiences from six offerings of the course to demonstrate that treating the project in an introductory course as a software evolution exercise on a large, mature system is a viable alternative to the usual (greenfield) approaches. As an added benefit, meaningful contributions to the open source community can be made.", "num_citations": "5\n", "authors": ["984"]}
{"title": "The Decomposition Slice Display System.\n", "abstract": " The Surgeon's Assistant is a case tool for software maintainers and developers of ansi C programs. It is based on the premises that maintainers need to be able to limit the scope of changes and that (most) development starts from some existing, similar systems. The Decomposition Slice Display System (dsds), a component of the Surgeon's Assistant, automates the task of inspecting the relationships between a program's decomposition slices. It allows the software maintainer to visually comprehend the relationships between the decomposition slices. The dsds has a powerful interface that easily represents decomposition slices for the user's perusal. It allows the user to manipulate the graph by moving and deleting nodes. The interface assists the software maintainer by providing an easy visualization of the software. The maintainer can see the importance that various decomposition slices have to the program and plan maintenance accordingly.", "num_citations": "5\n", "authors": ["984"]}
{"title": "Software safety and program slicing\n", "abstract": " Describes a novel application of program slicing to two issues of software safety: functional diversity and the validation and verification of safety-critical components. Software quality assurance auditors are faced with a myriad of difficulties, ranging from inadequate time to inadequate CASE tools. One particular problem is the localization of safety-critical code that may be interleaved throughout the entire system. Once this code is located, its effects throughout the system are difficult to ascertain. A method is presented that uses program slicing to mitigate these difficulties in two ways. First, it is shown that program slicing can be used to locate all code that contributes to the value of variables that might be part of a safety-critical component. Second, it is shown that slicing-based techniques can be used to validate functional diversity, i.e. that there are no interactions of one critical component with another critical\u00a0\u2026", "num_citations": "5\n", "authors": ["984"]}
{"title": "A Static Robustness Grid Using MISRA C2 Language Rules\n", "abstract": " Program robustness is the ability of software to behave correctly under stress. Measuring program robustness allows programmers to find the program\u2019s vulnerable points, repair them, and avoid similar mistakes in the future. In this paper, a Robustness Grid will be introduced as a program robustness measuring technique. A Robustness Grid is a table that contains rules classified into categories, with respect to a program\u2019s function names and calculates robustness degree. The Motor Industry Software Reliability Association (MISRA) rules will be used as the basis for the robustness measurement mechanism. In the Robustness Grid, for every MISRA rule a score will be given to a function every time it satisfies or breaches a rule. The Robustness Grid shows how much each part of the program is robust, and assists developers to measure and evaluate robustness degree for each part of a program.", "num_citations": "4\n", "authors": ["984"]}
{"title": "The law and reverse engineering\n", "abstract": " Almost all software contracts that are not open-source contain broad bans on reverse engineering, but as far as we can tell, almost all professional software development does reverse engineering to some degree. This is a fundamental, unresolved conflict. Every student and practitioner of software of engineering will face reverse engineering issues and they will have to make their own decisions about what is fair and reasonable in their situation, what risks they are willing to accept, and what corporate policies they should follow, support, or challenge. The industry is polarized and it will probably be a decade or more before the next generation of leadership revisits this conflict in a constructive way. For now, the statutes and the courts offer insufficient guidance. We plan to highlight the the issues of the law and reverse engineering through examples. Each exemplar case will be drawn either from an actual lawsuit or\u00a0\u2026", "num_citations": "2\n", "authors": ["984"]}
{"title": "Regression test selection model using decomposition slicing\n", "abstract": " Software systems change and evolve over time. Each time a system is changed regression tests have to be run to validate these changes. The aim of this research is to significantly reduce the number of test cases that need to be run after system changes have been made. Decomposition slicing provides a technique that is capable of identifying the unchanged parts of a system. A model based on decomposition slicing has been developed. The validity of the model is explored through the application of an example. Application of this model has shown that significant reductions in the number of test cases can be achieved. The example have limited themselves to relatively small programs and the next step is to apply the model to larger systems with more complex changes to ascertain if the method scales. While some parts of the model have been automated, tools will be required when carrying out the larger case studies.", "num_citations": "2\n", "authors": ["984"]}
{"title": "MonkeySort\n", "abstract": " Monkeysort is a pedagogical program that turns the usual concern of efficiency upside down by attempting to be as \u201cdumb\u201d as possible, yet still correct. In this program, whose inner workings are accessible to all students, monkeysort exhibits significant ideas that are central to computer science: partial correctness, generate-and-test solutions to NP-hard problems, Stirling\u2019s approximation of n!, and subtle applications of the use of permutations. It also demonstrates central software engineering ideas: integer overflow; the use of coverage tools; CPU monitoring tools; and timing analysis approaches more sophisticated than mere statement counting. An appropriately tailored classroom discussion of monkeysort can be used as fodder for graduate student homeworks, or to illustrate to the non-scientist exactly what it is that Computer Scientists do.", "num_citations": "2\n", "authors": ["984"]}
{"title": "Preface to the special issue on program comprehension\n", "abstract": " Give up? It is a (ham-handed) attempt to use Newton\u2019s method to find a root of the polynomial g, to within accuracy acc. Without the right background, or even a helpful comment, it may take a while to comprehend what the function does, albeit", "num_citations": "1\n", "authors": ["984"]}
{"title": "Working Session: Tools for Program Comprehension: Building a Comprehender's Workbench\n", "abstract": " Comprehension, the primordial task, has not changed much in 40 years. Whether the comprehension task is global (architectural) or atomic (single statement effect), the approach is the same. We run it. We read it. We grep (search) it. An electronic search on the criteria comprehension and tools yielded no results. Therefore, while there is programmer's workbench, a maintainer's workbench, and a tester's workbench, the comprehender's workbench is evidently barren. While borrowing tools from other engineers gives a toehold, the question still arises: What tools belong in a comprehender's workbench, per se__ __ This workshop session will try to answer this question.", "num_citations": "1\n", "authors": ["984"]}