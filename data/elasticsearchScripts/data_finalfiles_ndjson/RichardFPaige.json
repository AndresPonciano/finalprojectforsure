{"title": "The epsilon transformation language\n", "abstract": " Support for automated model transformation is essential for realizing a Model Driven Development (MDD) process. However, model transformation is only one of the many tools in a model engineering toolkit. To apply MDD in the large, automated support for a number of additional tasks such as model comparison, merging, validation and model-to-text transformation, is essential. While a number of successful model transformation languages have been currently proposed, the majority of them have been developed in isolation and as a result, they face consistency and integration difficulties with languages that support other model management tasks. We present the Epsilon Transformation Language (ETL), a hybrid model transformation language that has been developed atop the infrastructure provided by the Epsilon model management platform. By building atop Epsilon, ETL is seamlessly integrated with\u00a0\u2026", "num_citations": "479\n", "authors": ["1610"]}
{"title": "The epsilon object language (EOL)\n", "abstract": " Model-Driven Development requires model management languages and tools for supporting model operations such as editing, consistency checking, and transformation. At the core of these model management techniques is a set of facilities for model navigation and modification. A subset of the Object Constraint Language can be used for some of these tasks, but it has limitations as a general-purpose language to be used in a variety of model management tasks. We present the metamodel independent Epsilon Object Language (EOL) which builds on OCL. EOL can be used both as a standalone generic model management language or as infrastructure on which task-specific languages can be built. We describe how it has been used to construct a selection of languages, such as model merging, comparison, and text generation languages.", "num_citations": "316\n", "authors": ["1610"]}
{"title": "Different models for model matching: An analysis of approaches to support model differencing\n", "abstract": " Calculating differences between models is an important and challenging task in Model Driven Engineering. Model differencing involves a number of steps starting with identifying matching model elements, calculating and representing their differences, and finally visualizing them in an appropriate way. In this paper, we provide an overview of the fundamental steps involved in the model differencing process and summarize the advantages and shortcomings of existing approaches for identifying matching model elements. To assist potential users in selecting one of the existing methods for the problem at stake, we investigate the trade-offs these methods impose in terms of accuracy and effort required to implement each one of them.", "num_citations": "250\n", "authors": ["1610"]}
{"title": "Merging models with the epsilon merging language (eml)\n", "abstract": " In the context of Model Engineering, work has focused on operations such as model validation and model transformation. By contrast, other model management operations of significant importance remain underdeveloped. One of the least elaborated operations is model merging. In this paper we discuss the special requirements of model merging and introduce the Epsilon Merging Language (EML), a rule-based language, with tool support, for merging models of diverse metamodels and technologies. Moreover, we identify special cases of model merging that are of particular interest and provide a working example through which we demonstrate the practicality and usefulness of the proposed language.", "num_citations": "242\n", "authors": ["1610"]}
{"title": "Towards synchronizing models with evolving metamodels\n", "abstract": " Metamodel evolution poses a threat to the applicability of Model-Driven Development to large scale projects. The problem is caused by incompatibilities between metamodel revisions. These render models that conform to the older version of the metamodel non-conformant to the newer version. An approach to addressing this problem is co-evolution of models with their respective metamodels. In this paper we introduce the problem of synchronizing models with evolving metamodels and outline an approach to addressing it efficiently. The aim of the proposed approach is to minimize the effort required to perform model migration in face of metamodel changes. To provide deeper insights into the envisioned approach, we demonstrate preliminary solutions to the problem of change detection between two metamodel revisions. Furthermore, we present an approach to model-to-model transformations, using a conservative copying algorithm, which regulates the retainment of instances during model migration.", "num_citations": "192\n", "authors": ["1610"]}
{"title": "Model migration with epsilon flock\n", "abstract": " In their recent book, Mens and Demeyer state that Model-Driven Engineering introduces additional challenges for controlling and managing software evolution. Today, tools exist for generating model editors and for managing models with transformation, validation, merging and weaving. There is limited support, however, for model migration - a development activity in which instance models are updated in response to metamodel evolution. In this paper, we describe Epsilon Flock, a model-to-model transformation language tailored for model migration that contributes a novel algorithm for relating source and target model elements. To demonstrate its conciseness, we compare Flock to other approaches.", "num_citations": "189\n", "authors": ["1610"]}
{"title": "Metamodel-based model conformance and multiview consistency checking\n", "abstract": " Model-driven development, using languages such as UML and BON, often makes use of multiple diagrams (e.g., class and sequence diagrams) when modeling systems. These diagrams, presenting different views of a system of interest, may be inconsistent. A metamodel provides a unifying framework in which to ensure and check consistency, while at the same time providing the means to distinguish between valid and invalid models, that is, conformance. Two formal specifications of the metamodel for an object-oriented modeling language are presented, and it is shown how to use these specifications for model conformance and multiview consistency checking. Comparisons are made in terms of completeness and the level of automation each provide for checking multiview consistency and model conformance. The lessons learned from applying formal techniques to the problems of metamodeling, model\u00a0\u2026", "num_citations": "189\n", "authors": ["1610"]}
{"title": "The epsilon generation language\n", "abstract": " We present the Epsilon Generation Language (EGL), a model-to-text (M2T) transformation language that is a component in a model management tool chain. The distinctive features of EGL are described, in particular its novel design which inherits a number of language concepts and logical features from a base model navigation and modification language. The value of being able to use a M2T language as part of an extensible model management tool chain is outlined in a case study, and EGL is compared to other M2T languages.", "num_citations": "183\n", "authors": ["1610"]}
{"title": "Model comparison: a foundation for model composition and model transformation testing\n", "abstract": " In the context of Model Driven Development, Model Transformation and Model Composition are two essential model management tasks. In this paper, we demonstrate how both tasks can benefit, in different ways, from the automation of another fundamental task: Model Comparison. We derive requirements for a model comparison solution incrementally, and demonstrate a concrete rule-based model comparison approach we have developed in the context of a generic model merging language.", "num_citations": "160\n", "authors": ["1610"]}
{"title": "Process-centered review of object oriented software development methodologies\n", "abstract": " We provide a detailed review of existing object-oriented software development methodologies, focusing on their development processes. The review aims at laying bare their core philosophies, processes, and internal activities. This is done by using a process-centered template for summarizing the methodologies, highlighting the activities prescribed in the methodology while describing the modeling languages used (mainly diagrams and tables) as secondary to the activities. The descriptions produced using this template aim not to offer a critique on the methodologies and processes, but instead provide an abstract and structured description in a way that facilitates their elaborate analysis for the purposes of improving understanding, and making it easier to tailor, select, and evaluate the processes.", "num_citations": "155\n", "authors": ["1610"]}
{"title": "A canonical scheme for model composition\n", "abstract": " There is little agreement on terminology in model composition, and even less on key characteristics of a model composition solution. We present three composition frameworks: the Atlas Model Weaver, the Epsilon Merging Language, and the Glue Generator Tool, and from them derive a core set of common definitions. We use this to outline the key requirements of a model composition solution, in terms of language and tool support.", "num_citations": "145\n", "authors": ["1610"]}
{"title": "Fault trees for security system design and analysis\n", "abstract": " The academic literature concerning fault tree analysis relates almost entirely to the design and development of safety-critical systems. This paper illustrates how similar techniques can be applied to the design and analysis of security-critical systems. The application of this technique is illustrated in an example inspired by a current public-key cryptosystem.", "num_citations": "121\n", "authors": ["1610"]}
{"title": "Principles for modeling language design\n", "abstract": " Modeling languages, like programming languages, need to be designed if they are to be practical, usable, accepted, and of lasting value. We present principles for the design of modeling languages. To arrive at these principles, we consider the intended use of modeling languages. We conject that the principles are applicable to the development of new modeling languages, and for improving the design of existing modeling languages that have evolved, perhaps through a process of unification. The principles are illustrated and explained by several examples, drawing on object-oriented and mathematical modeling languages.", "num_citations": "118\n", "authors": ["1610"]}
{"title": "On the evolution of OCL for capturing structural constraints in modelling languages\n", "abstract": " The Object Constraint Language (OCL) can be used to capture structural constraints in the context of the abstract syntax of modelling languages (metamodels) defined in the MOF metamodelling architecture. While the expression language of OCL has been revised and updated a number of times since its inception, the constructs used for capturing constraints (invariants) have remained unchanged. In this paper we argue that the abstract and concrete syntax of OCL invariants should also be updated to address a number of shortcomings and render OCL more usable in a contemporary modelling environment. To support our arguments we have implemented the proposed extensions in the prototype Epsilon Validation Language (EVL). To demonstrate the benefits delivered, we present and discuss a concrete example.", "num_citations": "112\n", "authors": ["1610"]}
{"title": "An analysis of approaches to model migration\n", "abstract": " Changing a metamodel can cause inconsistency with instance models. Modelling frameworks such as EMF that implement the OMG\u2019s metamodelling architecture cannot be used to manipulate models that are inconsistent with their metamodel: inconsistent models cannot be loaded. Consequently, developers have to invest effort in migrating inconsistent models, to re-establish consistency. This is an example of model and metamodel evolution\u2013indeed, of co-evolution. In their recent book, Mens and Demeyer note that there are new challenges for MDE in controlling and managing model and metamodel evolution. Various approaches to automating model migration have been proposed. In this paper, we demonstrate some of the important limitations of automatic generation of model migration strategies, and identify requirements for improved model and metamodel co-evolution support.", "num_citations": "100\n", "authors": ["1610"]}
{"title": "Engineering model transformations with transML\n", "abstract": " Model transformation is one of the pillars of model-driven engineering (MDE). The increasing complexity of systems and modelling languages has dramatically raised the complexity and size of model transformations as well. Even though many transformation languages and tools have been proposed in the last few years, most of them are directed to the implementation phase of transformation development. In this way, even though transformations should be built using sound engineering principles\u2014just like any other kind of software\u2014there is currently a lack of cohesive support for the other phases of the transformation development, like requirements, analysis, design and testing. In this paper, we propose a unified family of languages to cover the life cycle of transformation development enabling the engineering of transformations. Moreover, following an MDE approach, we provide tools to partially\u00a0\u2026", "num_citations": "93\n", "authors": ["1610"]}
{"title": "Weaving an assurance case from design: a model-based approach\n", "abstract": " Assurance cases are used to demonstrate confidence in properties of interest for a system, e.g. For safety or security. A model-based assurance case seeks to bring the benefits of model-driven engineering, such as automation, transformation and validation, to what is currently a lengthy and informal process. In this paper we develop a model-based assurance approach, based on a weaving model, which allows integration between assurance case, design and process models and meta-models. In our approach, the assurance case itself is treated as a structured model, with the aim that all entities in the assurance case become linked explicitly to the models that represent them. We show how it is possible to exploit the weaving model for automated generation of assurance cases. Building upon these results, we discuss how a seamless model-driven approach to assurance cases can be achieved and examine the\u00a0\u2026", "num_citations": "90\n", "authors": ["1610"]}
{"title": "Eclipse development tools for epsilon\n", "abstract": " Epsilon is a platform that provides the necessary infrastructure for developing task-specific languages to support model management tasks such as transformation, merging, comparison and validation. Currently, a number of taskspecific languages are implemented atop Epsilon. Each language is supported by an execution engine and a set of development tools for the Eclipse platform, that enable developers to compose, execute and debug specifications in a user-friendly and practical environment. In this paper, we provide an overview of the Epsilon infrastructure and the languages build atop it and demonstrate the supporting development tools.", "num_citations": "86\n", "authors": ["1610"]}
{"title": "Requirements for domain-specific languages\n", "abstract": " A domain-specific language (DSL), whether used for model-driven development or programming, is a piece of critical infrastructure that is developed during the system engineering process. As such, a DSL has its own lifecycle, which in turn may encapsulate the lifecycles of many other system development projects. Understanding the requirements for DSLs in general, and in specific project contexts, is critical in order to improve DSL quality and ensure a direct correspondence between the requirements for system engineering projects and the functionality provided by the language. The quality attributes of a DSL\u2013and its supporting environment (eg, virtual machines, debuggers, integrated environments)\u2013will have an impact on the quality attributes of the overall systems development process, and the resulting products.We present a partial requirements analysis for DSLs in general, focusing on relevant stakeholders, the system boundary (ie, where DSLs end and general purpose languages start), and a core set of requirements that are relevant for any DSL. We then discuss open questions, particularly focusing on requirements refinement, wherein more specific domain information needs to be used.", "num_citations": "86\n", "authors": ["1610"]}
{"title": "An iterative approach for development of safety-critical software and safety arguments\n", "abstract": " The benefits ascribed to Agile methods are attractive to software engineers working in the safety-critical software domain. There is limited industrial experience and evidence of successful applications of Agile methods in this domain, however, academic research has identified some of the key challenges of their adoption and application, and has started to present feasibility studies. In this paper, we propose an iterative approach for developing safety-critical software, making two novel contributions. Firstly, we address the notion of up-front design in safety-critical software development, and describe the characteristics fan up-front design that is minimal from the perspective of achieving safety objectives. Secondly, we identify a key difficulty of using iterative development for building safety-critical software, and present a way to develop both a software system and a safety argument iteratively. We also give details of a\u00a0\u2026", "num_citations": "84\n", "authors": ["1610"]}
{"title": "A novel approach to the detection of cheating in multiplayer online games\n", "abstract": " Modern online multiplayer games are complex heterogeneous distributed systems comprised of servers and untrusted clients, which are often engineered under considerable commercial pressures. Under these conditions, security breaches allowing clients to employ illegal behaviours have become common; current commercial approaches have limited capabilities for reacting rapidly to such threats. This paper presents an approach to the detection of a cheating player, and describes a proof-of-concept system designed to detect cheating play (specifically wall-hacking) through the analysis of player behaviour. This approach differs from current methods in that it does not rely on knowledge about specific vulnerabilities and their method of exploitation in order to protect the system, but instead monitors player behaviour for indications of cheating play. Statistical evidence is presented which shows that the proof-of\u00a0\u2026", "num_citations": "81\n", "authors": ["1610"]}
{"title": "Knowledge\u2010based systems: a re\u2010evaluation\n", "abstract": " Purpose \u2013 The goal of this paper is to re\u2010evaluate the role of knowledge\u2010based systems (KBS) in knowledge management (KM). While knowledge\u2010based systems and expert systems were widely used in the past, they have now fallen from favor and are largely ignored in the knowledge management literature. This paper aims to argue that several factors have changed and it is now time to re\u2010evaluate the contribution that such systems can make to knowledge management.Design/methodology/approach \u2013 The role of KBS in KM is explored through a comprehensive analysis of both the management and the technical literature on knowledge. The literature on KBS and expert systems is reviewed and some of the problems faced by them are highlighted. Some of the probable causes of these problems and some of the solutions that might be used to overcome them are indicated. The paper describes how knowledge\u00a0\u2026", "num_citations": "81\n", "authors": ["1610"]}
{"title": "Update transformations in the small with the epsilon wizard language\n", "abstract": " In this paper, we present the Epsilon Wizard Language (EWL), a tool-supported language for specifying and executing automated update transformations in the small based on existing model elements and input from the user. We discuss on the requirements and the design decisions, as well as on the infrastructure on which the language has been developed. We also provide concrete working examples to demonstrate how EWL can be used to automate the process of constructing and refactoring models in practice.", "num_citations": "81\n", "authors": ["1610"]}
{"title": "Agile development of secure web applications\n", "abstract": " A secure system is one that is protected against specific undesired outcomes. Delivering a secure system, and particularly a secure web application, is not easy. Integrating general-purpose information systems development methods withsecurity development activities could be a useful means to surmount thesedifficulties Agile processes, such as Extreme Programming, are of increasing interest insoftware development. Most significantly for web applications, agile processesencourage and embrace requirements change, which is a desirable characteristicfor web application development. In this paper, we present an agile process to deliver secure web applications. The contribution of the research is not the development of a new method or processthat addresses security concerns. Rather, we investigate general-purpose informationsystemdevelopment methods (eg, Feature-Driven Development (FDD)) and mature\u00a0\u2026", "num_citations": "80\n", "authors": ["1610"]}
{"title": "On-demand merging of traceability links with models\n", "abstract": " Model management operations such as refinement and transformation modify existing or produce new models. To assist both engineers and tools in tracing the path of changes and decisions, maintenance of traceability information is essential. There are two main approaches for storing traceability; in the first, traceability information is embedded inside the models, while in the second, traces form separate models. The former allows users to inspect traceability information in a visual manner, but pollutes the models, while the latter keeps the models clean, but visualization is troublesome. In this paper, we propose a unification of the two approaches via model merging. We suggest that traceability information should be maintained in separate models, which can be merged with the primary model (s) on demand to produce annotated models for inspection purposes. We present a concrete example that demonstrates the practicality of our approach.", "num_citations": "80\n", "authors": ["1610"]}
{"title": "A comparison of model migration tools\n", "abstract": " Modelling languages and thus their metamodels are subject to change. When a metamodel evolves, existing models may no longer conform to the evolved metamodel. To avoid rebuilding them from scratch, existing models must be migrated to conform to the evolved metamodel. Manually migrating existing models is tedious and error-prone. To alleviate this, several tools have been proposed to build a migration strategy that automates the migration of existing models. Little is known about the advantages and disadvantages of the tools in different situations. In this paper, we thus compare a representative sample of migration tools \u2013 AML, COPE, Ecore2Ecore and Epsilon Flock \u2013 using common migration examples. The criteria used in the comparison aim to support users in selecting the most appropriate tool for their situation.", "num_citations": "74\n", "authors": ["1610"]}
{"title": "Detecting and repairing inconsistencies across heterogeneous models\n", "abstract": " With the advent of domain specific languages for model engineering, detecting inconsistencies between models is becoming increasingly challenging. Nowadays, it is not uncommon for models participating in the same development process to be captured using different modelling languages and even different modelling technologies. We present a classification of the types of relationships that can arise between models participating in a software development process and outline the types of inconsistencies each relationship can suffer from. From this classification we identify a set of requirements for a generic inconsistency detection and reconciliation mechanism and use a case study to demonstrate how those requirements are implemented in the Epsilon validation language (EVL), a task-specific language developed in the context of the Epsilon GMT component.", "num_citations": "66\n", "authors": ["1610"]}
{"title": "Operational semantics for traceability\n", "abstract": " Traceability is a relationship between entities that are produced during development. Different types of traceability are used in practice, with different characteristics and properties: there is no single notion of traceability that is usable in all situations. In this paper we present an approach for defining an operational semantics for traceability in UML, in order to more precisely capture the intended meaning of different types of traceability, and to enable richer tool support for managing and monitoring traceability, perhaps by making use of consistency checking technology.", "num_citations": "63\n", "authors": ["1610"]}
{"title": "Agile security using an incremental security architecture\n", "abstract": " The effective provision of security in an agile development requires a new approach: traditional security practices are bound to equally traditional development methods. However, there are concerns that security is difficult to build incrementally, and can prove prohibitively expensive to refactor. This paper describes how to grow security, organically, within an agile project, by using an incremental security architecture which evolves with the code. The architecture provides an essential bridge between system-wide security properties and implementation mechanisms, a focus for understanding security in the project, and a trigger for security refactoring. The paper also describes criteria that allow implementers to recognize when refactoring is needed, and a concrete example that contrasts incremental and \u2018top-down\u2019 architectures.", "num_citations": "62\n", "authors": ["1610"]}
{"title": "A meta-method for formal method integration\n", "abstract": " We describe a meta-method for formal method integration [Pai97]. The approach is applied to combining formal methods with other formal and semiformal methods. We discuss the theory behind formal method integration, present two example combinations, and use an integrated method in solving a small problem.", "num_citations": "62\n", "authors": ["1610"]}
{"title": "Raising the level of abstraction in the development of GMF-based graphical model editors\n", "abstract": " The Eclipse graphical modeling framework (GMF) provides substantial infrastructure and tooling for developing diagram-based editors for modelling languages atop the Eclipse platform. It is widely accepted that implementing a visual editor using the built-in GMF facilities is a particularly complex and error-prone task and requires a steep learning curve. We present an approach that raises the level of abstraction at which a visual editor is specified. The approach uses annotations at the metamodel level. Annotations are used for producing the required low-level intermediate GMF models necessary for generating an editor via model-to-model transformations.", "num_citations": "61\n", "authors": ["1610"]}
{"title": "transML: A family of languages to model model transformations\n", "abstract": " Model transformation is one of the pillars of Model-Driven Engineering (MDE). The increasing complexity of systems and modelling languages has dramatically raised the complexity and size of model transformations. Even though many transformation languages and tools have been proposed in the last few years, most of them are directed to the implementation phase of transformation development. However, there is a lack of cohesive support for the other phases of the transformation development, like requirements, analysis, design and testing.               In this paper, we propose a unified family of languages to cover the life-cycle of transformation development. Moreover, following an MDE approach, we provide tools to partially automate the progressive refinement of models between the different phases and the generation of code for specific transformation implementation languages.", "num_citations": "60\n", "authors": ["1610"]}
{"title": "The grand challenge of scalability for model driven engineering\n", "abstract": " Scalability is particularly important for the adoption of Model Driven Engineering (MDE) in an industrial context. The current focus of research in MDE is on declarative languages for model management, and scalable mechanisms for persisting models (e.g., using databases). In this paper we claim that, instead, modularity and encapsulation in modelling languages should be the main focus. We justify this claim by demonstrating how these two principles apply to a related domain \u2013 code development \u2013 where the issue of scalability has been addressed to a much greater extent than in MDE.", "num_citations": "59\n", "authors": ["1610"]}
{"title": "Eugenia: towards disciplined and automated development of GMF-based graphical model editors\n", "abstract": " EMF and GMF are powerful frameworks for implementing tool support for modelling languages in Eclipse. However, with power comes complexity, implementing a graphical editor for a modelling language using EMF and GMF requires developers to handcraft and maintain several detailed interconnected models through a loosely guided, labour-intensive, and error-prone process. We demonstrate how the application of metamodel annotation and model transformation techniques can help to manage the complexity of GMF and EMF and deliver significant productivity, quality, and maintainability benefits. We present Eugenia, an open-source tool that implements the proposed approach, illustrate its functionality with an example, evaluate it through an empirical study, and report on the community\u2019s response to the tool.", "num_citations": "58\n", "authors": ["1610"]}
{"title": "EUnit: A unit testing framework for model management tasks\n", "abstract": " Validating and transforming models are essential steps in model-driven engineering. These tasks are often implemented as operations in general purpose programming languages or task-specific model management languages. Just like other software artefacts, these tasks must be tested to reduce the risk of defects. Testing model management tasks requires testers to select and manage the relevant combinations of input models, tasks and expected outputs. This is complicated by the fact that many technologies may be used in the same system, each with their own integration challenges. In addition, advanced test oracles are required: tests may need to compare entire models or directory trees.               To tackle these issues, we propose creating an integrated unit testing framework for model management operations. We have developed the EUnit unit testing framework to validate our approach. EUnit tests\u00a0\u2026", "num_citations": "55\n", "authors": ["1610"]}
{"title": "Building model-driven engineering traceability\n", "abstract": " Model-Driven Engineering involves the application of many different model management operations, some automated, some manual. For developers to stay in control of their models and codebase, trace information must be maintained by all model management operations. This leads to a large number of trace links, which themselves need to be managed, queried, and evaluated. Classifications of traceability and trace links are an essential capability required for understanding and managing trace links. We present a process for building traceability classifications for a variety of widely used and accepted operations (both automated and manual) and show the results of applying the process to a rich traceability context.", "num_citations": "55\n", "authors": ["1610"]}
{"title": "Probabilistic failure propagation and transformation analysis\n", "abstract": " A key concern in safety engineering is understanding the overall emergent failure behaviour of a system, i.e., behaviour exhibited by the system that is outside its specification of acceptable behaviour. A system can exhibit failure behaviour in many ways, including that from failures of individual or a small number of components. It is important for safety engineers to understand how system failure behaviour relates to failures exhibited by individual components. In this paper, we propose a safety analysis technique, failure propagation and transformation analysis (FPTA), which automatically and quantitatively analyses failures based on a model of failure logic. The technique integrates previous work on automated failure analysis with probabilistic model checking supported by the PRISM tool. We demonstrate the technique and tool on a small, yet realistic safety-related application.", "num_citations": "48\n", "authors": ["1610"]}
{"title": "A tutorial on metamodelling for grammar researchers\n", "abstract": " A metamodel has been defined as: a model of a model; a definition of a language; a description of abstract syntax; and a description of a domain. Because of these varied definitions, it is difficult to explain why metamodels are constructed, what can be done with them, and how they are built. This tutorial introduces the key concepts, terminology and philosophy behind metamodelling, focusing on its use for language engineering, and expressed in a way that is intended to be accessible to researchers who may be more familiar with the use of traditional context-free grammar techniques. We highlight the main differences between metamodelling and grammar-based approaches, describe how to map metamodelling concepts and techniques to grammar concepts and techniques, and highlight some of the strengths and weaknesses of metamodelling via a set of small, but realistic examples.", "num_citations": "46\n", "authors": ["1610"]}
{"title": "Surveying Rule Inheritance in Model-to-Model Transformation Languages.\n", "abstract": " Abstract Model transformations play a significant role in Model-Driven Engineering. However, their reuse mechanisms have yet to receive much attention. In this paper, we propose a comparison framework for rule inheritance in model-to-model transformation languages, and provide an in-depth evaluation of prominent representatives of imperative, declarative and hybrid transformation languages. The framework provides criteria for comparison along orthogonal dimensions, covering static aspects, which indicate whether a set of inheriting transformation rules is well-formed at compile-time, and dynamic aspects, which describe how inheriting rules behave at run-time. The application of this framework to dedicated transformation languages shows that, while providing similar syntactical inheritance concepts, they exhibit different dynamic inheritance semantics and offer basic support for checking static inheritance semantics, only.", "num_citations": "46\n", "authors": ["1610"]}
{"title": "Big data+ politics= open data: The case of health care data in England\n", "abstract": " There is a great deal of enthusiasm about the prospects for Big Data held in health care systems around the world. Health care appears to offer the ideal combination of circumstances for its exploitation, with a need to improve productivity on the one hand and the availability of data that can be used to identify opportunities for improvement on the other. The enthusiasm rests on two assumptions. First, that the data sets held by hospitals and other organizations, and the technological infrastructure needed for their acquisition, storage, and manipulation, are up to the task. Second, that organizations outside health care systems will be able to access detailed datasets. We argue that both assumptions can be challenged. The article uses the example of the National Health Service in England to identify data, technology, and information governance challenges. The public acceptability of third party access to detailed\u00a0\u2026", "num_citations": "45\n", "authors": ["1610"]}
{"title": "Towards agile engineering of high-integrity systems\n", "abstract": " We describe the results of a pilot study on the application of an agile process to building a high-integrity software system. The challenges in applying an agile process in this domain are outlined, and potential solutions for dealing with issues of communication, scalability, and system complexity are proposed. We report on the safety process, argumentation generated to support the process, and the technology and tools used to strengthen the agile process in terms of support for verification and validation.", "num_citations": "44\n", "authors": ["1610"]}
{"title": "A visual specification language for model-to-model transformations\n", "abstract": " Model Driven Engineering promotes models as the core assets of projects and hence model transformations become first-class citizens in this approach. Likewise, the development of large scale transformations necessitates a systematic engineering process and supporting modelling notations. However, although many languages have been proposed to implement transformations, few allow their specification at a higher level of abstraction. In this paper we present a visual, formal, declarative specification language to express model-to-model transformations and their correctness properties. The language supports the two main approaches to model-to-model transformation -- trace-based and traceless -- with a unified formal semantics. Moreover, we provide a compilation of specifications into OCL as this has many practical applications, e.g. it allows injecting assertions and correctness properties for automated\u00a0\u2026", "num_citations": "43\n", "authors": ["1610"]}
{"title": "The single model principle\n", "abstract": " Modelling languages such as UML are increasingly used to describe software systems at different levels of abstraction. There are two very different ways of using such languages. One approach is based on the manifestation of a single model, with construction of different views from this model, and with automatic or semi-automatic consistency checking among these views. This follows what we term the single model principle. The second approach (of which unrestricted UML is an example) is based on the independent construction of multiple models of the same system, but with no guarantee of the consistency of the various models. We propose that to best support seamless, reversible software development of reliable software, it is preferable to follow the single model principle for a specific subset of development tasks. We describe the single model principle and its supporting infrastructure. We show how the BON/Eiffel description language, which supports both high-level abstract specifications as well as code implementations can be enhanced to satisfy the essential tenets of the single model principle, both for static and dynamic descriptions. We describe how a UML profile (including the use of Java) might provide weak support for the principle. We also consider situations and tasks when following the principle is insufficient, particularly when capturing early (goal-oriented) requirements.", "num_citations": "43\n", "authors": ["1610"]}
{"title": "Using a model merging language for reconciling model versions\n", "abstract": " A difficult challenge in the industrialisation of Model-Driven Development is managing different versions of models. Different versions may arise at any time during the development process, due to different individuals or teams working on different parts of the overall model. To manage these versions it is necessary to be able to identify differences and reconcile these differences in a single, integrated model. We describe the use of model merging technology for managing different versions of a model in an industrial software development process. The use of automated model merging technology is contrasted with an alternative, semi-automated approach. The contributions of model merging to helping to solve this problem are outlined.", "num_citations": "38\n", "authors": ["1610"]}
{"title": "Scalability: The holy grail of model driven engineering\n", "abstract": " Scalability is a desirable property in Model-Driven Engineering (MDE). The current focus of research in MDE is on declarative languages for model management, and scalable mechanisms for persisting models (eg, using databases). In this paper we claim that, instead, modularity and encapsulation in modelling languages should be the main focus. We justify this claim by demonstrating how those two principles apply to a related domain\u2013code development\u2013where the issue of scalability has been addressed to a much greater extent than in MDE.", "num_citations": "37\n", "authors": ["1610"]}
{"title": "Developing a UML profile for modelling knowledge-based systems\n", "abstract": " Knowledge engineers have favoured a diagrammatic approach for developing knowledge-based systems and have adopted those used in software engineering. However, these modelling techniques tend to be used in an ad hoc way and are highly dependent on the modelling experience of the engineers involved. This paper focuses on the use of profiles for knowledge modelling that are available in the Unified Modeling Language (UML). It identifies the shortcomings of current approaches to adopting UML and discusses the need for an extension to UML using the profile mechanism. A profile based on the eXecutable Modelling Framework (XMF) is also presented as work-in-progress.", "num_citations": "36\n", "authors": ["1610"]}
{"title": "ERC\u2013An object-oriented refinement calculus for Eiffel\n", "abstract": " We present a refinement calculus for transforming object-oriented (OO) specifications (or \u2018contracts\u2019) of classes into executable Eiffel programs. The calculus includes the usual collection of algorithmic refinement rules for assignments, if-statements, and loops. However, the calculus also deals with some of the specific challenges of OO, namely rules for introducing feature calls and reference types (involving aliasing). The refinement process is compositional in the sense that a class specification is refined to code based only on the specifications (not the implementations) of the classes that the specification depends upon. We discuss how automated support for such a process can be developed based on existing tools. This work is done in the context of a larger project involving methods for the seamless design of OO software in the graphical design notation BON (akin to UML). The goal is to maintain model\u00a0\u2026", "num_citations": "36\n", "authors": ["1610"]}
{"title": "A CSP model of Eiffel\u2019s SCOOP\n", "abstract": " The current informal semantics of the simple concurrent object-oriented programming (SCOOP) mechanism for Eiffel is described. We construct and discuss a model using the process algebra CSP. This model gives a more formal semantics for SCOOP than existed previously.               We implement the model mechanically via a new tool called CSPsim. We examine two semantic variations of SCOOP: when and how far to pass locks, and when to wait for child calls to complete. We provide evidence that waiting for child calls to complete both unnecessarily reduces parallelism without any increase in safety and increases deadlocks involving callbacks.               Through the creation and analysis of the model, we identify a number of ambiguities relating to reservations and the underlying run-time system and propose means to resolve them.", "num_citations": "35\n", "authors": ["1610"]}
{"title": "Refinement via consistency checking in MDA\n", "abstract": " Refinement is a key practice in the Model-Driven Architecture initiative of the Object Modelling Group. However, the practice is loosely defined, overloaded, and open to misinterpretation. In this paper, we outline ongoing work on providing a precise definition for refinement via consistency checking, not only in the context of MDA, but more generally for model-driven development in a variety of domains.", "num_citations": "35\n", "authors": ["1610"]}
{"title": "Constructing models with the human-usable textual notation\n", "abstract": " We present an implementation of the OMG\u2019s Human-Usable Textual Notation (HUTN) [6] that provides a generic concrete syntax for MOF-based metamodels. The notation is summarised. Ways in which HUTN can be applied in order to improve the productivity of Model-Driven Engineering are identified. The use of HUTN to improve the quality of test suites for verifying model management operations (such as model-to-model transformation) is described. We also present a comparison of generic and domain-specific concrete syntax with HUTN.", "num_citations": "34\n", "authors": ["1610"]}
{"title": "Metamodelling and conformance checking with PVS\n", "abstract": " A metamodel expresses the syntactic well-formedness constraints that all models written using the notation of a modelling language must obey. We formally capture the metamodel for an industrial-strength object-oriented modelling language, BON, using the PVS specification language.We discuss how the PVS system helped in debugging the metamodel, and show how to use the PVS theorem prover for conformance checking of models against the metamodel.We consider some of the benefits of using PVS\u2019s specification language, and discuss some lessons learned about formally specifying metamodels.", "num_citations": "34\n", "authors": ["1610"]}
{"title": "Guest editorial to the special issue on Success Stories in Model Driven Engineering.\n", "abstract": " Model-Driven Engineering (MDE) is an emerging software discipline which promotes a new way to develop and maintain software systems by using models as the primary artifacts of the software development process. The relevance of such a discipline is witnessed by the increasing interest in many scientic endeavors and industrial projects. Historically model transformations and code generation from abstract models have been among the main MDE applications. Nevertheless, they represent only a partial constituent of the MDE application ambit: recent advances in MDE have shown how differencing techniques, model management, megamodeling and interoperability are equally relevant to leverage the discipline of MDE while gaining acceptance in current practices. However, success stories about MDE applications rarely occur in the literature since many issues are still open and unresolved despite the maturity reached by a number of tools, including transformation languages. Thus, researchers tend to focus on investigating conceptual if not theoretical aspects disregarding the relevance of the assessment of the overall discipline in terms of its application to real scale and complexity scenarios. While such robust theoretical contributions are of paramount importance, applications emerging from the most disparate domains may reveal new directions for development of the theory as well as lessons of transferable value for future MDE practice. For this special issue, we selected contributions which show how MDE techniques can be successfully applied in practice showing experiences and providing insights on issues encountered when\u00a0\u2026", "num_citations": "33\n", "authors": ["1610"]}
{"title": "Inter-modelling: from theory to practice\n", "abstract": " We define inter-modelling as the activity of building models that describe how modelling languages should be related. This includes many common activities in Model Driven Engineering, like the specification of model-to-model transformations, the definition of model matching and model traceability constraints, the development of inter-model consistency maintainers and exogenous model management operators.               Recently, we proposed a formal approach to specify the allowed and forbidden relations between two modelling languages by means of bidirectional declarative patterns. Such specifications were used to generate graph rewriting rules able to enforce the relations in (forward and backward) model-to-model transformation scenarios. In this paper we extend the usage of patterns for two further inter-modelling scenarios \u2013 model matching and model traceability \u2013 and report on an EMF-based\u00a0\u2026", "num_citations": "32\n", "authors": ["1610"]}
{"title": "Building an efficient component for OCL evaluation\n", "abstract": " In this paper we report on our experience developing the Eye OCL Software (EOS) evaluator, a Java component for efficient OCL evaluation. We first motivate the need for an efficient implementation of OCL in order to cope with novel usages of the language. We then discuss some aspects that, based on our experience, should be taken into account when building an OCL evaluator for medium-large scenarios. Finally, we explore various approaches for evaluating OCL expressions on really large scenarios.", "num_citations": "32\n", "authors": ["1610"]}
{"title": "A framework for composing modular and interoperable model management tasks\n", "abstract": " The ability to compose modular and interoperable model management tasks into automated workflows is essential for the wide-spread use of Model Driven Development. Driven by this need, we present a framework that enables developers to define, execute and profile such workflows. The framework is based on the widely-used ANT tool and Epsilon, a platform of integrated task-specific model management languages. We present the design and implementation of the framework and demonstrate its practicality and usefulness through a concrete case study.", "num_citations": "32\n", "authors": ["1610"]}
{"title": "On demand data analysis and filtering for inaccurate flight trajectories\n", "abstract": " This paper reports on work performed in the context of the COMPASS SESAR-JU WP-E project, on developing an approach for identifying and filtering inaccurate trajectories (ghost flights) in historical data originating from the EUROCONTROL-operated Demand Data Repository (DDR).", "num_citations": "31\n", "authors": ["1610"]}
{"title": "Eugenia live: a flexible graphical modelling tool\n", "abstract": " Designing a domain-specific language (DSL) is a collaborative, iterative and incremental process between domain experts and software engineers. Existing tools for implementing DSLs produce powerful and interoperable domain-specific editors, but are resistant to language change and require considerable technical expertise to use. We present EuGENia Live, a tool for designing (graphical) DSLs. EuGENia Live runs in a web browser, supports on-the-fly meta-model editing, and produces DSLs that can be exported and used with the Eclipse Modeling Framework. As well as presenting the design and implementation of EuGENia Live, we discuss potential benefits to our underlying approach, and challenges for future work on flexible modelling tools.", "num_citations": "31\n", "authors": ["1610"]}
{"title": "Extreme programming security practices\n", "abstract": " Current practice suggests that security is considered through all stages of the software development life cycle, and that a risk-based and plan-driven approach is best suited to establish security criteria. Based on experience in applying security practices, this paper proposes two new security practices, security training and a fundamental security architecture, for applying Extreme Programming.", "num_citations": "31\n", "authors": ["1610"]}
{"title": "High-integrity extreme programming\n", "abstract": " We assess the applicability of Extreme Programming practices to engineering high-integrity systems, focusing on the characteristics of this problem domain that distinguish it from those considered more traditional for agile development. We suggest that Extreme Programming needs both extension and modification to be applicable to engineering high-integrity systems, and discuss promising extensions.", "num_citations": "31\n", "authors": ["1610"]}
{"title": "Proof vs testing in the context of safety standards\n", "abstract": " During software certification various forms of testing (e.g., unit, integration, regression) are undertaken. These testing processes are very important, but are also generally accepted as expensive, leading to a desire to replace testing with more cost-effective processes, where practicable. This paper is concerned with how such technology substitution can be justified, and presents a template for an argument that can be used to justify substitutions. It also instantiates the argument for a particular proof technology - the CLawZ toolset - and demonstrates how to argue for its safe substitution for testing in this context.", "num_citations": "27\n", "authors": ["1610"]}
{"title": "Epsilon Flock: a model migration language\n", "abstract": " Model-driven engineering introduces additional challenges for controlling and managing software evolution. Today, tools exist for generating model editors and for managing models with transformation, validation, merging and weaving. There is limited support, however, for model migration\u2014a development activity in which instance models are updated in response to metamodel evolution. In this paper, we propose conservative copy\u2014a style of model transformation that we believe is well-suited to model migration\u2014and Epsilon Flock\u2014a compact model-to-model transformation language tailored for model migration. The proposed structures are evaluated by comparing the conciseness of model migration strategies written in different styles of transformation language, using several examples of evolution taken from UML and the graphical modelling framework.", "num_citations": "26\n", "authors": ["1610"]}
{"title": "Lessons learned from building model-driven development tools\n", "abstract": " Tools to support modelling in system and software engineering are widespread, and have reached a degree of maturity where their use and availability are accepted. Tools to support model-driven development (MDD)\u2014where models are manipulated and managed throughout the system/software engineering lifecycle\u2014have, over the last 10\u00a0years, seen much research and development attention. Over the last 10\u00a0years, we have had significant experience in the design, development and deployment of MDD tools in practical settings. In this paper, we distill some of the important lessons we have learned in developing and deploying two MDD tools: Epsilon and VIATRA. In doing so, we aim to identify some of the key principles of developing successful MDD tools, as well as some hints of the pitfalls and risks.", "num_citations": "25\n", "authors": ["1610"]}
{"title": "FPTC: automated safety analysis for domain-specific languages\n", "abstract": " Critical systems must be shown to be acceptably safe to deploy and use in their environment. The size, scale, heterogeneity, and distributed nature of these increasingly complex systems makes them difficult to verify and analyse. Additionally, domain experts use a variety of languages to model and build their systems. We present an automated safety analysis technique, Fault Propagation and Transformation Analysis, and explain how it can be used for automatically calculating the failure behaviour of an entire system from the failure behaviours of its components. We outline an implementation of the technique in the Epsilon model management platform, allowing it to be used with state-of-the-art model management languages and tools, and making it applicable to a variety of different domain-specific modelling languages.", "num_citations": "25\n", "authors": ["1610"]}
{"title": "Abstracting complex languages through transformation and composition\n", "abstract": " Domain-specific languages (DSLs) can simplify the development of complex software systems by providing domain-specific abstractions. However, the complexity of some domains has led to a number of DSLs that are themselves complex, limiting the original benefits of using DSLs. We show how to develop DSLs as abstractions of other DSLs by transfering translational approaches for textual DSLs into the domain of modelling languages. We argue that existing model transformation languages are at too low a level of abstraction for succinctly expressing transformations between abstract and concrete DSLs. Patterns identified in such model transformations can be used to raise the level of abstraction. We show how we can allow part of the transformation to be expressed using the concrete syntax of the concrete DSL.", "num_citations": "24\n", "authors": ["1610"]}
{"title": "Towards an agile process for building software product lines\n", "abstract": " Software product lines are sets of software systems that share common features. Product lines are built as if they were a family of products, identifying those features that change and those that can be reused. There is an evident incompatibility between the requirements of software product lines and agile practices. We report on experiments that used Feature-Driven Development to build software product lines, and describe the minor extensions that were useful for developing software product lines.", "num_citations": "24\n", "authors": ["1610"]}
{"title": "A comparison of the business object notation and the unified modeling language\n", "abstract": " Seamlessness, reversibility, and software contracting have been proposed as important techniques to be supported by object-oriented methods. These techniques are used to provide a framework for the comparison of two modeling languages, the Business Object Notation (BON) and the Unified Modeling Language (UML). Elements of the UML and its constraint language that do not support these techniques are discussed. Suggestions for further improvements to both BON and UML are described.", "num_citations": "24\n", "authors": ["1610"]}
{"title": "Searching for model migration strategies\n", "abstract": " Metamodels, like many software artefacts, are subject to evolution. If a metamodel evolves, models that previously conformed to the metamodel may become non-conformant, and must be migrated to reestablish conformance. Manually migrating models can be tedious and error prone, and a number of solutions have arisen to aid in the creation of a migration strategy-a model transformation which automates the migration. This paper asks whether we can make use of research in the field of Search-Based Software Engineering to automatically discover migration strategies, and discusses the challenges involved. In particular, we explore how tools that provide coupled evolution of metamodels and models provide a suitable platform for which to apply search techniques.", "num_citations": "23\n", "authors": ["1610"]}
{"title": "Agile specification-driven development\n", "abstract": " We present an agile approach to Specification-Driven Development, which combines features of Test-Driven Development and the plan-based approach of Design-by-Contract. We argue that both tests and contracts are different types of specifications, and both are useful and complementary for building high quality software. We conclude that it is useful for being able to switch between writing tests and writing contracts, and explain how Specification-Driven Development supports this capability.", "num_citations": "23\n", "authors": ["1610"]}
{"title": "A comparison of rule inheritance in model-to-model transformation languages\n", "abstract": " Although model transformations presumably play a major role in Model-Driven Engineering, reuse mechanisms such as inheritance have received little attention so far. In this paper, we propose a comparison framework for rule inheritance in declarative model-to-model transformation languages, and provide an in-depth evaluation of three prominent representatives thereof, namely ATL, ETL (declarative subsets thereof), and TGGs. The framework provides criteria for comparison along orthogonal dimensions, covering static aspects, which indicate whether a set of inheriting transformation rules is well-formed at compile-time, and dynamic aspects, which describe how inheriting rules behave at run-time. The application of this framework to dedicated transformation languages shows that, while providing similar syntactical inheritance concepts, they exhibit different dynamic inheritance semantics and offer basic\u00a0\u2026", "num_citations": "22\n", "authors": ["1610"]}
{"title": "Enhanced automation for managing model and metamodel inconsistency\n", "abstract": " Model-driven engineering (MDE) introduces additional challenges for managing evolution. For example, a metamodel change may affect instance models. Existing tool supported approaches for updating models in response to a metamodel change assume extra effort from metamodel developers. When no existing approach is applicable, metamodel users must update their models manually, an error prone and tedious task. In this paper, we describe the technical challenges faced when using the eclipse modeling framework (EMF) and existing approaches for updating models in response to a metamodel change. We then motivate and describe alternative techniques, including: a mechanism for loading, storing and manipulating inconsistent models; a mapping of inconsistent models to a human-usable notation for semi-automated and collaborative co-evolution; and integration with an inter-model reference\u00a0\u2026", "num_citations": "22\n", "authors": ["1610"]}
{"title": "BON-CASE: an extensible CASE tool for formal specification and reasoning\n", "abstract": " We describe BON-CASE, an extensible tool for the BON modelling language. The tool\u2019s support for formal techniques\u2013in particular, for formal specification of contracts and frames, as a platform for verification of Eiffel code, for lightweight integration with existing reasoning tools (such as type checkers, theorem provers, and static assertion checkers), and its extensible architecture\u2013is discussed. We present the infrastructure provided with the tool, and support being added to the tool for reverse engineering and the single model principle, as well as for checking the consistency of static and dynamic views of a system.", "num_citations": "22\n", "authors": ["1610"]}
{"title": "Evaluating cloud database migration options using workload models\n", "abstract": " A key challenge in porting enterprise software systems to the cloud is the migration of their database. Choosing a cloud provider and service option (e.g., a database-as-a-service or a manually configured set of virtual machines) typically requires the estimation of the cost and migration duration for each considered option. Many organisations also require this information for budgeting and planning purposes. Existing cloud migration research focuses on the software components, and therefore does not address this need. We introduce a two-stage approach which accurately estimates the migration cost, migration duration and cloud running costs of relational databases. The first stage of our approach obtains workload and structure models of the database to be migrated from database logs and the database schema. The second stage performs a discrete-event simulation using these models to obtain the cost and\u00a0\u2026", "num_citations": "21\n", "authors": ["1610"]}
{"title": "Iterative criteria-based approach to engineering the requirements of software development methodologies\n", "abstract": " Software engineering endeavours are typically based on and governed by the requirements of the target software; requirements identification is therefore an integral part of software development methodologies. Similarly, engineering a software development methodology (SDM) involves the identification of the requirements of the target methodology. Methodology engineering approaches pay special attention to this issue; however, they make little use of existing methodologies as sources of insight into methodology requirements. The authors propose an iterative method for eliciting and specifying the requirements of a SDM using existing methodologies as supplementary resources. The method is performed as the analysis phase of a methodology engineering process aimed at the ultimate design and implementation of a target methodology. An initial set of requirements is first identified through analysing the\u00a0\u2026", "num_citations": "21\n", "authors": ["1610"]}
{"title": "Unit testing model management operations\n", "abstract": " A model management workflow typically consists of a number of interdependent model-management tasks such as model validation, transformation, merging, comparison and text generation. As such workflows are becoming more and more complex, errors in individual tasks are likely to be propagated to subsequent tasks and eventually compromise the operation of the entire workflow. Therefore, building confidence about the correctness of each individual task before integrating them is becoming increasingly important. In this paper we present an approach to uniform unit-testing of individual model management operations and a prototype for specifying and executing test-cases, implemented atop the infrastructure provided by the Epsilon model management platform.", "num_citations": "21\n", "authors": ["1610"]}
{"title": "When are methods complementary?\n", "abstract": " In this article, we address the issue of when software development methods are complementary, i.e., we determine when a method is capable of a task that another method cannot perform. Our intent is to examine complementarity in order to help determine when to carry out method integration. Here, we propose some factors for method complementarity, and suggest that context-dependent criteria, such as real-world domain and non-functional development requirements, may have a significant impact on method complementarity.", "num_citations": "21\n", "authors": ["1610"]}
{"title": "Formal method integration via heterogeneous notations\n", "abstract": " Software development is a challenging task. Brooks Broo95] suggests that this di culty may come from the\\essential complexity\" of software entities. As the study of the activity of building software has progressed, and our understanding of it has grown, a number of problems that may impact on this natural di culty have been identi ed.1. Scaling up. Software construction in the small is now well-understood. We have proven techniques to assist us in this activity, including: structured programming, high-level languages, programming theories, code libraries, etcetera. These standard methods are less useful when directly applied to building large software systems. In other words, our well-known facilities for software development in the small do not always scale up. For these situations, we need more powerful abstraction tools ISP88]. Recent research on topics such as software architecture GaSh93], process management Scha95], software tools BCM94], object-oriented methods Booc94], information systems engineering ILR95], and method integration Kron93], has aimed at helping to solve some of the problems associated with scaling up.", "num_citations": "21\n", "authors": ["1610"]}
{"title": "Agile requirements traceability using domain-specific modelling languages\n", "abstract": " Requirements traceability is an important mechanism for managing verification, validation and change impact analysis challenges in system engineering. Numerous model-based approaches have been proposed to support requirements traceability, but significant challenges remain, including finding the appropriate level of granularity for modelling traceability and coping with the lack of uniformity in requirements management tools. This paper argues for an agile modelling approach to managing requirements traceability and, in this context, proposes a domain/project-specific requirements traceability modelling approach. The preliminary approach is illustrated briefly in the context of the safety-critical systems engineering domain, where agile traceability from functional and safety requirements is necessary to underpin certification.", "num_citations": "20\n", "authors": ["1610"]}
{"title": "Model migration case for TTC 2010\n", "abstract": " Using an example from the Unified Modelling Language, we invite submissions to explore the ways in which model transformation languages can be used to update models in response to metamodel changes.", "num_citations": "20\n", "authors": ["1610"]}
{"title": "Security planning and refactoring in extreme programming\n", "abstract": " Security is a critical part of systems development, particularly for web-based systems. There is little known about how to effectively integrate security into incremental development processes such as Extreme Programming. This paper presents the results of a project that used Extreme Programming practices and deferred consideration of security until system functionality was complete. The findings suggest that refactorings within incremental development processes are capable of delivering high quality security solutions, and provide insights into how security requirements can be incorporated in the planning game.", "num_citations": "20\n", "authors": ["1610"]}
{"title": "An action semantics for MOF 2.0\n", "abstract": " We show how to extend MOF 2.0 to include an action semantics to support behavioural modelling. We explain why such an extension is useful, particularly for model transformation and consistency checking.", "num_citations": "20\n", "authors": ["1610"]}
{"title": "Requirements in digital forensics method definition: Observations from a UK study\n", "abstract": " During a project to examine the potential usefulness of evidence of tool verification as part of method validation for ISO 17025 accreditation, the authors have examined requirements statements in several digital forensic method descriptions and tools. They have identified that there is an absence of clear requirements statements in the methods and a reluctance or inability to disclose requirements on the part of tool producers. This leads to a break in evidence of correctness for both tools and methods, resulting in incomplete validation. They compare the digital forensics situation with other ISO 17025 accredited organisations, both forensic and non-forensic, and propose a means to close the gap and improve validation. They also review existing projects which may assist with their proposed solution.", "num_citations": "19\n", "authors": ["1610"]}
{"title": "Sensitivity analysis in model-driven engineering\n", "abstract": " Sensitivity analysis has been used in scientific research to explore the validity of models. Software engineering is inherently uncertain; we propose that sensitivity analysis can be used to analyse and quantify the effects of uncertainty when model management operations are applied to models. In this paper, we consider forms and measures of uncertainty in software engineering models. Focusing on data uncertainty, we present a framework for sensitivity analysis, and create an instantiation of the framework for the CATMOS decision-support tool. We show how this can be used to qualify the output of the entailed model management operations and thus improve both the confidence and understanding of models.", "num_citations": "19\n", "authors": ["1610"]}
{"title": "The role of dependency links in ensuring architectural view consistency\n", "abstract": " Modern systems modelling languages frequently support the use of multiple views in order to provide flexible, extensible, and rich mechanisms for capturing system characteristics. Architectural description languages (ADLs) often provide many useful capabilities but fail to provide support for ensuring view consistency simply because they present a single view of the system. An ADL used for building dependable systems must provide multiple views. For these kinds of systems, ensuring view consistency is critical so as to provide guarantees about the system as a whole. In this paper, we outline an architectural modelling language, AIM, which supports multiple views, but we focus on its first-class support for dependency links, which are used to ensure view consistency. We illustrate the principles on examples from a real engine control system.", "num_citations": "19\n", "authors": ["1610"]}
{"title": "Identifying desirable game character behaviours through the application of evolutionary algorithms to model-driven engineering metamodels\n", "abstract": " This paper describes a novel approach to the derivation of model-driven engineering (MDE) models using metaheuristic search, and illustrates it using a specific engineering problem: that of deriving computer game characters with desirable properties. The character behaviour is defined using a human-readable domain-specific language (DSL) that is interpreted using MDE techniques. We apply the search to the underlying MDE metamodels, rather than the DSL directly, and as a result our approach is applicable to a wide range of MDE models. An implementation developed using the Eclipse Modeling Framework, the most widely-used toolset for MDE, is evaluated. The results demonstrate not only the derivation of characters with the desired properties, but also the identification of unexpected features of the behavioural description language and the game itself.", "num_citations": "18\n", "authors": ["1610"]}
{"title": "SECG: The SCOOP-to-Eiffel Code Generator.\n", "abstract": " The Simple Concurrent Object-Oriented Programming (SCOOP) mechanism introduces inter-object concurrency to the Eiffel language, via addition of one new", "num_citations": "18\n", "authors": ["1610"]}
{"title": "Towards model transformation with TXL\n", "abstract": " We demonstrate the use of the transformation tool TXL in representing, but particularly for implementing efficient transformations between languages. The approach shows how to write and reuse language definitions, express rules for transformation based on patterns, and outlines how transformations can be developed in an agile way, compatible with the practices of test-driven development. The intention is to be able to use TXL as a behindthe-scenes technology for implementing efficient, scaleable transformations of models.", "num_citations": "18\n", "authors": ["1610"]}
{"title": "Solving acquisition problems using model-driven engineering\n", "abstract": " An acquisition problem involves the identification, procurement and management of resources that allow an organisation to achieve goals. Examples include through-life capability management (in the defense domain), and planning for the next release of a software system. The latter is representative of the challenges of acquisition, as solving the problem involves the assessment of the very many ways in which the different requirements of multiple heterogeneous customers may be satisfied. We present a novel approach to modelling acquisition problems, based on the use of Model-Driven Engineering principles and practices. The approach includes domain-specific modelling languages for acquisition problems, and uses model transformation to automatically generate potential solutions to the acquisition problem. We outline a prototype tool, built using the Epsilon model management framework. We\u00a0\u2026", "num_citations": "17\n", "authors": ["1610"]}
{"title": "Using unified modeling language for conceptual modelling of knowledge-based systems\n", "abstract": " This paper discusses extending the Unified Modelling Language by means of a profile for modelling knowledge-based system in the context of Model Driven Architecture (MDA) framework. The profile is implemented using the eXecutable Modelling Framework (XMF) Mosaic tool. A case study from the health care domain demonstrates the practical use of this profile; with the prototype implemented in Java Expert System Shell (Jess). The paper also discusses the possible mapping of the profile elements to the platform specific model (PSM) of Jess and provides some discussion on the Production Rule Representation (PRR) standardisation work.", "num_citations": "17\n", "authors": ["1610"]}
{"title": "A UML profile for knowledge-based systems modelling\n", "abstract": " The Knowledge engineering (KE) techniques are essentially based on the knowledge transfer approach, from domain experts directly to systems. However, this has been replaced by the modelling approach which emphasises using conceptual models to model the problem-solving skill of the domain expert. This paper discusses extending the Unified Modelling Language by means of a profile for modelling knowledge-based system in the context of Model Driven Architecture (MDA) framework. The profile is implemented using the executable Modelling Framework (XMF) Mosaic tool. A case study from the health care domain demonstrates the practical use of this profile; with the prototype implemented in Java Expert System Shell (Jess). The paper also discusses the possible mapping of the profile elements to the platform specific model (FSM) of Jess and provides some discussion on the Production Rule\u00a0\u2026", "num_citations": "17\n", "authors": ["1610"]}
{"title": "Checking the consistency of collaboration and class diagram using pvs\n", "abstract": " We present a formal, mechanically-checked specification of the consistency constraints between two views of object-oriented systems described in BON [17]: the static view provided by class diagrams, and the dynamic view provided by collaboration diagrams. The constraints are specified as an extension of the BON metamodel presented in [11], and are implemented in PVS. They ensure that the sequence of messages appearing in the dynamic view is legal, given the pre-and postconditions of methods appearing in the static view. A sketch of how the constraints might be implemented in a BON CASE tool is also provided. The constraints are used in the context of a method, based on BON, for building reliable object-oriented software systems [13] and integrating the use of modelling and Extreme Programming [1](XP) practices.", "num_citations": "17\n", "authors": ["1610"]}
{"title": "Developing BON as an industrial-strength formal method\n", "abstract": " The emerging Unified Modelling Language has been touted as merging the best features of existing modelling languages, and has been adopted by leading companies and vendors as a universal software modelling language. Some researchers are also looking to UML as a basis for formal methods development. A less known approach is BON (the Business Object Notation), which is based on the principles of seamlessness, reversibility and design by contract, making it an ideal basis for industrial-strength formal methods development of object-oriented software. In this paper, we argue that BON is much more suited for the application of formal methods than UML. We describe the properties that an industrial-strength formal method must have, show how algorithm refinement can be done in BON (as an example of using BON for formal development), and contrast BON with other approaches, including\u00a0\u2026", "num_citations": "17\n", "authors": ["1610"]}
{"title": "Modelling and comparing cloud computing service level agreements\n", "abstract": " Service-level agreements are a critical mechanism underpinning the pay-per-consumption model of business for cloud computing. Cloud providers make a variety of services of different qualities available on-demand for consumers. However, there is no standard ontology, vocabulary, or set of mechanisms that can be used for systematically and semi-automatically expressing and comparing cloud SLAs. We report on research investigating the use of MDE principles and technologies for making cloud SLAs easier to write, use and semi-automatically compare by domain experts. Our ultimate objective is to make it easier for non-experts to take decisions by programmatically comparing different cloud SLAs. We propose a metamodel for both cloud consumer requirement and cloud provider SLAs, and exploit model comparison technology for automating the comparison process.", "num_citations": "16\n", "authors": ["1610"]}
{"title": "Agile formal method engineering\n", "abstract": " Software development methods are software products, in the sense that they should be engineered by following a methodology to meet the behavioural and non-behavioural requirements of the intended users of the method. We argue that agile approaches are the most appropriate means for engineering new methods, and particularly for integrating formal methods. We show how agile principles and practices apply to engineering methods, and demonstrate their application by integrating parts of the Eiffel development method with CSP.", "num_citations": "16\n", "authors": ["1610"]}
{"title": "Modelling knowledge based systems using the executable modelling framework (XMF)\n", "abstract": " There is no standardised approach to modelling knowledge-based systems; where modelling is adopted, the techniques used are those from the software engineering domain. These tend to be used in an ad hoc way and are highly dependent on the experience of the knowledge engineers. This paper presents the adoption of a profile mechanism for the design of knowledge-based systems. The profile is created using the meta-model extension approach of UML and is based on XMF (executable Meta-modelling Framework). XMF is an extension to the existing standards for meta-models: MOFT OCL and QVT. XMF offers an alternative approach in profile design which allows modification or the addition of new modelling constructs that are easily integrated with the core meta-model of UML", "num_citations": "16\n", "authors": ["1610"]}
{"title": "Specification-driven design with Eiffel and agents for teaching lightweight formal methods\n", "abstract": " We report on our experiences in teaching lightweight formal methods with Eiffel. In particular, we discuss how we introduce formal methods via Eiffel\u2019s design-by-contract and agent technologies, and how we integrate these techniques with test-driven development, in an approach called specification-driven design. This approach demonstrates how formal methods techniques fit with industrial software engineering practice.", "num_citations": "16\n", "authors": ["1610"]}
{"title": "Integrating a program design calculus and a subset of UML\n", "abstract": " The predicative programming design calculus is integrated with an object-oriented method that uses a subset of the Unified Modelling Language. The integration is carried out so as to make the calculus and refinement techniques more applicable to the development of large-scale object-oriented software. The two methods are integrated using a meta-method for formal method integration based on heterogeneous notations. We demonstrate how the methods being integrated complement each other and outline the use of the integrated method in a case study.", "num_citations": "16\n", "authors": ["1610"]}
{"title": "High-integrity agile processes for the development of safety critical software\n", "abstract": " Typically, safety critical software systems are developed using plan-driven development processes. Agile processes have evolved to help reduce costs of software development and seek to minimise documentation overheads. For safety critical systems that must undergo certification, documentation is essential. The question this paper addresses is: can a process based on agile principles be used to deliver a safety critical software product, but also the evidence needed to satisfy assurance objectives? The paper makes three contributions. Firstly, it presents an analysis of agile processes and their applicability in this domain. It reviews positive indicators for their use, outlines challenges associated with their deployment and proposes strategies for addressing these challenges. Secondly, it makes a number of recommendations for adapting an agile process to the domain. Finally, the paper reports on an experiment to\u00a0\u2026", "num_citations": "15\n", "authors": ["1610"]}
{"title": "Analysing system failure behaviours with PRISM\n", "abstract": " The verification of safety-critical systems using formal techniques is not something new. Traditionally, safety-critical systems are verified using hazard analysis techniques, e.g., fault tree analysis. As safety-critical systems have become larger and more complex, several analysis techniques with compositional capabilities were developed. However, these techniques were not able to analyse stochastic systems. In this paper, we present a model-based compositional safety analysis technique (i.e., failure propagation analysis) and explore the feasibility of integrating this safety analysis technique with techniques of probabilistic model checking, more precisely the PRISM model checker. By doing so, we make it possible to rigorously verify a model while system failure behaviours are quantitatively analysed.", "num_citations": "15\n", "authors": ["1610"]}
{"title": "Challenges when using model driven architecture in the development of safety critical software\n", "abstract": " The model driven architecture (MDA) is an approach to software engineering in which models are systematically developed and transformed into code. This paper discusses some of the issues which would need to be overcome when attempting to certify a safety critical design or software developed with the MDA approach, partially based on our experience with an avionics software case study. We particularly focus on the need to certify MDA artefacts and produce a compelling system safety case", "num_citations": "15\n", "authors": ["1610"]}
{"title": "Metamodelling for grammarware researchers\n", "abstract": " A metamodel is variously defined as a model of a model, a definition of a language, a description of abstract syntax, and a description of a domain. It is all of these things and more. Metamodels can be confusing, and explaining why they are constructed, what you can do with them, and how they are built can be challenging, especially when trying to bridge the gap between the modelware and grammarware communities. In this example-driven mini-tutorial, we introduce the key concepts and ideas behind metamodelling and explain why metamodels are useful, and particularly how they differ from grammar-based approaches to language development. We give some tips on how grammarware researchers can explain what they do to modelware researchers, and vice versa, in the spirit of interdisciplinarity and improving collaboration.", "num_citations": "14\n", "authors": ["1610"]}
{"title": "An integrated framework for system/software requirements development aligning with business motivations\n", "abstract": " The ultimate aim of (business) software is to help implement the business value. How to align the software requirements with business objectives is therefore one of the focuses in both the business and technology realms. In this paper, we take a holistic view of the business planning and system/software requirements development in order to achieve the effectiveness of business alignment. We propose a framework that integrates the development of motivation and requirements models at the organization, business, product, and system/software levels. Furthermore, we base our modeling constructs on the OMG standardized Business Motivation Model (BMM) and Systems Modeling Language (SysML), with the extension and linkage between them, so that can be embraced by industrial applications easily.", "num_citations": "14\n", "authors": ["1610"]}
{"title": "MADES: Embedded systems engineering approach in the avionics domain\n", "abstract": " This article introduces the MADES Project [1]. MADES is developing new model-driven technologies to improve current practices in the development of embedded systems for the avionics and surveillance embedded systems industries, in particular taking advantage of MARTE [3], the OMG UML profile dedicated to Modelling and Analysis of Real time and Embedded Systems. The project is applying a holistic approach in building new tools and technologies that support design, validation, simulation, and code generation, while providing better support for component reuse. The tools and technologies developed within MADES are driven by requirements from industrial users in the Avionics and Defence domains and will undergo extensive validation through use in the development of new applications for avionics and radar surveillance.", "num_citations": "14\n", "authors": ["1610"]}
{"title": "Playing the game: cheating, loopholes, and virtual identity\n", "abstract": " A broad range of interactive and distributed systems are essentially virtual worlds; these include examples such as multiplayer games, and even operating systems. They enable the formation and maintenance of virtual societies, which must be healthy in order to be prosperous and useful. We describe properties, inspired by writings on law and psychology, that we use to define the notion of fairness, which is an essential characteristic of a healthy society. By using multiplayer gaming as a running example, we discuss how a fair virtual society will interact with its real-world counterparts, and outline how one might choose to detect and deal with transgressors who violate rules designed to enable fair interaction and prohibit cheating. This is a conceptual paper, and raises a number of issues and problems that must be considered when designing virtual worlds. Our aim is to develop guidelines for the design of fair\u00a0\u2026", "num_citations": "14\n", "authors": ["1610"]}
{"title": "Toward model-driven sustainability evaluation\n", "abstract": " Exploring the vision of a model-based framework that may enable broader engagement with and informed decision making about sustainability issues.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Towards optimisation of model queries: A parallel execution approach\n", "abstract": " The growing size of software models poses significant scalability challenges. Amongst these challenges is the execution time of queries and transformations. In many cases, model management programs are (or can be) expressed as chains and combinations of core fundamental operations. Most of these operations are pure functions, making them amenable to parallelisation, lazy evaluation and short-circuiting. In this paper we show how all three of these optimisations can be combined in the context of Epsilon: an OCL-inspired family of model management languages. We compare our solutions with both interpreted and compiled OCL as well as hand-written Java code. Our experiments show a significant improvement in the performance of queries, especially on large models.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Stress-testing remote model querying APIs for relational and graph-based stores\n", "abstract": " Recent research in scalable model-driven engineering now allows very large models to be stored and queried. Due to their size, rather than transferring such models over the network in their entirety, it is typically more efficient to access them remotely using networked services (e.g. model repositories, model indexes). Little attention has been paid so far to the nature of these services, and whether they remain responsive with an increasing number of concurrent clients. This paper extends a previous empirical study on the impact of certain key decisions on the scalability of concurrent model queries on two domains, using an Eclipse Connected Data Objects model repository, four configurations of the Hawk model index and a Neo4j-based configuration of the NeoEMF model store. The study evaluates the impact of the network protocol, the API design, the caching layer, the query language and the type of\u00a0\u2026", "num_citations": "12\n", "authors": ["1610"]}
{"title": "A systematic approach for designing mutation operators for MDE languages\n", "abstract": " Testing is an essential activity in software development, used to increase confidence in the quality of software. One testing approach that is used to evaluate the quality of testing inputs for a particular program is mutation analysis. The most important step in mutation analysis is the process of defining mutation operators that mimic typical errors of the users of a language. There is a wide variety of mutation operators that have been designed for a number of languages including C, Java, and SQL. However, the design of mutation operators is rarely systematic, which may result in passing over crucial operators for specific features of languages. This paper describes a way to apply mutation analysis in the context of Model Driven Engineering (MDE). In particular, the paper proposes a systematic approach for designing mutation operators for MDE languages. The systematic approach is demonstrated for the Atlas Transformation Language (ATL) and the result is a list of mutation operators that includes previously designed ones for ATL from the literature.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "A framework to benchmark NoSQL data stores for large-scale model persistence\n", "abstract": " We present a framework and methodology to benchmark NoSQL stores for large scale model persistence. NoSQL technologies potentially improve performance of some applications and provide schema-less data-structures, so are particularly suited to persisting large and heterogeneous models. Recent studies consider only a narrow set of NoSQL stores for large scale modelling. Benchmarking many technologies requires substantial effort due to the disparate interface each store provides. Our experiments compare a broad range of NoSQL stores in terms of processor time and disc space used. The framework and methodology is evaluated through a case study that involves persisting large reverse-engineered models of open source projects. The results give tool engineers and practitioners a basis for selecting a store to persist large models.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Manifesto-model engineering for complex systems\n", "abstract": " Complex systems are hard to define. Nevertheless they are more and more frequently encountered. Examples include a worldwide airline traffic management system, a global telecommunication or energy infrastructure or even the whole legacy portfolio accumulated for more than thirty years in a large insurance company. There are currently few engineering methods and tools to deal with them in practice. The purpose of this Dagstuhl Perspectives Workshop on Model Engineering for Complex Systems was to study the applicability of Model Driven Engineering (MDE) to the development and management of complex systems. MDE is a software engineering field based on few simple and sound principles. Its power stems from the assumption of considering everything - engineering artefacts, manipulations of artefacts, etc - as a model. Our intuition was that MDE may provide the right level of abstraction to move the study of complex systems from an informal goal to more concrete grounds. In order to provide first evidence in support of this intuition, the workshop studied different visions and different approaches to the development and management of different kinds of complex systems. This note presents the summary of the discussions.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Introducing goal structuring notation to explain decisions in clinical practice\n", "abstract": " Clinical reasoning is a key contributor to the quality of healthcare. Clinical decisions at the policy level are made within a stochastic domain; decisions for individuals are usually more qualitative. In both cases, poor reasoning could result in an undesirable outcome. Clinical decisions are most typically communicated in a document through free text. Text has significant limitations (particularly ambiguity and poor structuring) whether used for analysis, or to explain the decisionmaking process. In safety engineering, similar problems are faced in conveying safety arguments to support certification. As a result, approaches have been developed to conveying arguments in ways which improve communication and which are more amenable to analysis. Goal Structuring Notation (GSN) [12] -a graphical argumentation notation for safety -was developed for those reasons. It has evolved to be one of the most widely used\u00a0\u2026", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Search-based model driven engineering\n", "abstract": " Model driven engineering (MDE) is a software development practice that treats models as first-class artefacts in the development lifecycle. MDE models conform to a metamodel\u2013another model that describes the model\u2019s concepts and semantics. One of the challenges presented when managing MDE models is the need to migrate models when their metamodel evolves to a new version.Model transformations are processes which move models from abstract representations of the system, to more concrete, platform-specific, representations and eventually to code. Like all programming artefacts, transformations need to be tested, which requires a set of models to which the transformation is applied. Creating many models by hand is tedious, and so automation is desirable. Automated generation, however, needs to ensure that the set of generated models will sufficiently test the transformation. This report presents progress into utilising metaheuristic search techniques to addressing the two challenges mentioned above. This report then outlines the structure of my thesis, and describes how I will spend the remaining 15 months of my PhD.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Exceptions in concurrent Eiffel\n", "abstract": " We describe the problem of asynchronous exceptions in Eiffel\u2019s Simple Concurrent Object-Oriented Programming (SCOOP). We discuss a range of possible solutions to further enable dependable computing in concurrent Eiffel. We propose a mechanism to handle aynchronous exceptions via a limited developer choice, including the notion of a failed or dead object, and necessarily introduce a small number of new exceptions. We additionally describe a number of mechanisms that were discarded as unsuitable.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Architecture description languages for high-integrity real-time systems\n", "abstract": " Safety-critical systems, such as those in the avionics, automotive, power, space, and medical industries, are predominantly driven by real-time embedded software and are often referred to as high-integrity real-time systems (HIRTS). In these systems, safety is of paramount importance. Safety is broadly defined as freedom from accidents and loss. When no safe alternative to normal service exists, a system must be dependable to be safe, that is, it must have reliable ways to deliver a certain quality of service. Our collaborations with industrial partners have focused on HIRTS modeling techniques. Initially, we explored the potential benefits that the most successful software architecture and modeling approaches could bring to the safety-critical domain. We subsequently designed the architecture information modeling language. AIM lets us exploit the available technologies from the same platform and thus provide\u00a0\u2026", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Model Driven Architecture-Foundations and Applications\n", "abstract": " The fourth edition of the European Conference on Model-Driven Architecture\u2013Foundations and Applications (ECMDA-FA 2008) was dedicated to furthering the state of knowledge and fostering the industrialization of the model-driven architecture (MDA) methodology. MDA is an initiative proposed by the Object Management Group (OMG) for platform-generic software development. It promotes the use of models in the specification, design, analysis, synthesis, deployment, and evolution of complex software systems. ECMDA-FA 2008 focused on engaging key European and international researchers and practitioners in a dialogue which will result in a stronger, more efficient industry, producing more reliable software on the basis of state-of-the-art research results. ECMDA-FA is a forum for exchanging information, discussing the latest results and arguing about future developments of MDA. It is a pleasure to be able to\u00a0\u2026", "num_citations": "12\n", "authors": ["1610"]}
{"title": "A proposal for a lightweight rigorous UML-based development method for reliable systems\n", "abstract": " A lightweight UML-based software development method for building reliable software systems is proposed. It attempts to combine the coding emphasis of Extreme Programming with the utility of modelling, while offering a counterpoint to Extreme Modelling. The method is built atop of a subset of UML, making use of contracts for documentation and for run-time (and potentially static) checking. Rules are given to establish consistency of views of a system, and a proposal for a tool pro- totype that implements the diagrams and which helps to establish their consistency is outlined. The key elements of a process, which emphasizes rapid production of code and test drivers, are also outlined.", "num_citations": "12\n", "authors": ["1610"]}
{"title": "Developer-centric knowledge mining from large open-source software repositories (CROSSMINER)\n", "abstract": " Deciding if an OSS project meets the required standards for adoption is hard, and keeping up-to-date with a rapidly evolving project is even harder. Making decisions about quality and adoption involves analysing code, documentation, online discussions, and issue trackers. There is too much information to process manually and it is common that uninformed decisions have to be made with detrimental effects. CROSSMINER aims to remedy this by automatically extracting the required knowledge and injecting it into the developers\u2019 Integrated Development Environments (IDE), at the time they need it to make design decisions. This allows them to reduce their effort in knowledge acquisition and to increase the quality of their code. CROSSMINER uniquely combines advanced software project analyses with online IDE monitoring. Developers will be monitored to infer which information is timely, based on\u00a0\u2026", "num_citations": "11\n", "authors": ["1610"]}
{"title": "The epsilon pattern language\n", "abstract": " We present the Epsilon Pattern Language (EPL), a textual language that supports expressing and detecting patterns on models conforming to arbitrary metamodels and captured using diverse modelling technologies. EPL provides out-of-the-box integration with existing languages that target a wide range of related model management activities (such as model validation, model-to-model and model-to-text transformation), thus enabling code reuse and seamless runtime interoperability across complex Model-Driven Engineering workflows. We discuss the syntax and semantics of EPL, its supporting development tools, and demonstrate how instances of patterns detected using EPL can be consumed and further processed by other model management programs.", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Exploring enterprise information systems\n", "abstract": " The concept of an Enterprise Information System (EIS) has arisen from the need to deal with the increasingly volatile requirements of modern large-scale organisations. An EIS is a platform capable of supporting and integrating a wide range of activities across an organisation. In principle, the concept is useful and applicable to any large and SMEs, international or national business organisation. However, the range of applications for EIS is growing and they are now being used to support e-government, health care, and non-profit/non-governmental organisations. This chapter reviews research and development efforts related to EIS, and as a result attempts to precisely define the boundaries for the concept of EIS, ie, identifying what is and what is not an EIS. Based on this domain analysis, a proposal for using goal-oriented modelling techniques for building EIS is constructed; the proposal is made more concrete\u00a0\u2026", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Behavioural interoperability to support model-driven systems integration\n", "abstract": " Software system integration is a process in which the target system is synthesised from discrete components (subsystems) whilst ensuring they function together as a system and are able to deliver required functionality. System integration is particularly important in projects in which new technologies must integrate with legacy systems. In such scenarios, this process can be broadly divided in two stages: interoperability checking and composition. Model-based approaches are promising since they allow us to carry out some of this process earlier (thus identifying problems earlier in the development lifecycle when they are easier to rectify). In this paper we describe a generic modelbased platform for system integration, applicable to different modelling languages, that supports both interoperability checking (at different levels of abstraction) and composition; our presentation focuses on the platform's support for\u00a0\u2026", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Automatic generation of integrated formal models corresponding to UML system models\n", "abstract": " This paper presents a complex model transformation that takes two related UML models as input (class diagrams and state machines) and outputs an integrated formal model. The transformation is achieved using the Epsilon model management framework and has involved the definition of new CSP and B metamodels. The target model is a CSPB specification (a fusion of CSP and B) that can be used to analyse the source UML. Through a comparative study we conclude that the code written using Epsilon is more concise than the equivalent model-to-text transformation achieved using the iUML toolset.", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Novel features in languages of the epsilon model management platform\n", "abstract": " We present a set of novel features that we have recently incorporated to model management languages of the Epsilon platform. We provide a detailed discussion on the usefulness of each feature and present motivating scenarios that highlight the benefits they deliver to programmatic model management.", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Comparing extended Z with a heterogeneous notation for reasoning about time and space\n", "abstract": " We contrast using a notation extension with using a combination of notations. Specifically, we compare the use of an extended dialect of Z [10] with a combination of Z and predicative programming notation [6] for algorithm refinement and for reasoning about time and space constraints on systems. We discuss the difficulty of using extended notations versus using heterogeneous notations, and consider when we might prefer to extend or combine notations. We conclude that there exist situations where a heterogeneous notation can be more appropriate to use than an extended notation.", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Heterogeneous notations for pure formal method integration\n", "abstract": " We outline an extendible approach for combining formal methods \u2013 such as Z, Morgan's refinement calculus, and predicative programming \u2013 based on composing specifications written in similar formal languages. We discuss how algorithm refinement can be extended to such a setting, and outline some examples of using integrated formal methods. We also provide justifications for why using combinations of similar methods might be helpful.", "num_citations": "11\n", "authors": ["1610"]}
{"title": "Bridging proprietary modelling and open-source model management tools: the case of PTC integrity modeller and epsilon\n", "abstract": " While the majority of research on Model-Based Software Engineering revolves around open-source modelling frameworks such as the Eclipse Modelling Framework, the use of commercial and closed-source modelling tools such as RSA, Rhapsody, MagicDraw and Enterprise Architect appears to be the norm in industry at present. This technical gap can prohibit industrial users from reaping the benefits of state-of-the-art research-based tools in their practice. In this paper, we discuss an attempt to bridge a proprietary UML modelling tool (PTC Integrity Modeller), which is used for model-based development of safety-critical systems at Rolls-Royce, with an open-source family of languages for automated model management (Epsilon). We present the architecture of our solution, the challenges we encountered in developing it, and a performance comparison against the tool\u2019s built-in scripting interface. In addition, we\u00a0\u2026", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Partial loading of XMI models\n", "abstract": " XML Metadata Interchange (XMI) is an OMG-standardised model exchange format, which is natively supported by the Eclipse Modeling Framework (EMF) and the majority of the modelling and model management languages and tools. Whilst XMI is widely supported, the XMI parser provided by EMF is inefficient in some cases where models are readonly (such as input models for model query, model-to-model transformation, etc) as it always requires loading the entire model into memory. In this paper we present a novel algorithm, and a prototype implementation (SmartSAX), which is capable of partially loading models persisted in XMI. SmartSAX offers improved performance, in terms of loading time and memory footprint, over the default EMF XMI parser. We describe the algorithm in detail, and present benchmarking results that demonstrate the substantial improvements of the prototype implementation over the\u00a0\u2026", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Model transformation specification for automated formal verification\n", "abstract": " The development of model transformations is commonly an ad-hoc activity in MDE. Transformations are engineering artefacts, and can be developed in a disciplined way, like other software artefacts. A model transformation development process can produce transformations expressed in many different styles; transformation patterns can be used to underpin such different properties to be constructed. This paper introduces a systematic approach to development of model transformation specifications that are amenable to automated formal verification of its properties. The paper introduces a process for planning transformation and a language for capturing structural and behavioural characteristics of a model transformation, that supports templates which, when instantiated, automatically produce equivalent formal specification with analysis capabilities. The approach is illustrated with a small example, UML Class to\u00a0\u2026", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Functional hazard assessment in product-lines\u2013a model-based approach\n", "abstract": " A product-line can offer the reuse of complete lifecycle assets, comprising planning, development and assessment artefacts. In safety-critical systems engineering, safety assessment artefacts are indispensable assets which are expensive to generate. For safety-critical product-lines, it would be costeffective to encapsulate these assessment artefacts as reusable assets, ie to provide the capability of reusing a product-line function or component in addition to its safety assessment artefacts. In this paper, we focus on Functional Hazard Assessment of a product-line\u2019s functions. We propose a product-line functional hazard model which is integrated with the product-line context and domain models. We also show how this proposed product-line functional hazard model fits within the product-line processes.", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Towards using OCL for instance-level queries in domain specific languages\n", "abstract": " The Object Constraint Language (OCL) provides a set of powerful facilities for navigating and querying models in the MOF metamodelling architecture. Currently, OCL queries can be expressed only in the context of MOF metamodels and UML models. This adds an additional burden to the development and use of Domain Specific Languages, which can also benefit from an instance-level querying mechanism. In an effort to address this issue, we report on ongoing work on defining a rigorous approach for aligning the OCL querying and navigation facilities, with arbitrary Domain Specific Languages to support instance-level queries. We present a case-study that demonstrates the usefulness and practicality of this approach.", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Knowledge modelling using the UML profile\n", "abstract": " This paper discusses platform independent conceptual modeling of a knowledge intensive application, focusing on the use of knowledge-based systems (KBS) in the context of model-driven engineering. An extension to the Unified Modeling Language (UML) for knowledge modeling is presented based on the profiling extension mechanism of UML. The UML profile discussed in this paper has been successfully captured in a Meta-Object-Facility (MOF) based UML tool \u2014 the executable Modeling Framework (XMF). The example is that of modeling a knowledge-based system for the Ulcer Clinical Practical Guidelines (CPG) Recommendations. It demonstrates the use of the profile, with the prototype system implemented in the Java Expert System Shell (JESS).", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Aligning ocl with domain-specific languages to support instance-level model queries\n", "abstract": " The Object Constraint Language (OCL) provides a set of powerful facilities for navigating and querying models in the MOF metamodelling architecture. Currently, OCL queries can be expressed only in the context of MOF metamodels and UML models. This adds an additional burden to the development and use of Domain Specific Languages, which can also benefit from an instance-level querying mechanism. In an effort to address this issue, we report on ongoing work on defining a rigorous approach for aligning the OCL querying and navigation facilities with arbitrary Domain Specific Languages to support instance-level queries. We present a case-study that demonstrates the usefulness and practicality of this approach.", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Integrating BON and Object-Z.\n", "abstract": " A significant limitation with object-oriented formal specification languages, such as Object-Z, is that they lack development and management processes, which can be used to guide the production of reliable, robust object-oriented systems. An integration of an object-oriented methodology, BON, and Object-Z is presented in order to add an industrially validated development process to Object-Z.", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Specification-driven development of an executable metamodel in Eiffel\n", "abstract": " Metamodels precisely define the constructs and underlying well-formedness rules for modelling languages. They are vital for tool vendors, who aim to provide support so that concrete models can be checked formally and automatically against a metamodel for conformance. This paper describes how an executable metamodel\u2013which supports fully automated conformance checking\u2013was developed using a model-driven extension of test-driven development. The advantages and disadvantages of this approach to building metamodels are discussed.", "num_citations": "10\n", "authors": ["1610"]}
{"title": "The logic of software design\n", "abstract": " The authors provide an overview of how logic can be used throughout the software development cycle, and discuss what methods can be introduced in the computer science curriculum to support software development. To see how logic is useful throughout the cycle, they present the WRSM reference model, and illustrate it with simple motivating examples. Reasoning is performed in Logic E, and PVS is used to illustrate automated proofs.", "num_citations": "10\n", "authors": ["1610"]}
{"title": "Re-Engineering the database layer of legacy applications for scalable cloud deployment\n", "abstract": " As the quantity of data stored in legacy enterprise systems increases, the re-engineering of the database layer in such systems becomes more important. Data is often the most valuable artefact in a system and unlike software it may not be replaceable. In collaboration with an industrial partner, Science Warehouse, a number of research problems in this area will be addressed. This extended abstract summarises the motivation for the project, its research questions, and the plan for addressing them.", "num_citations": "9\n", "authors": ["1610"]}
{"title": "Document\u2010centric XML workflows with fragment digital signatures\n", "abstract": " The use of digital document management and processing is increasing. Traditional workflows of paper forms are being replaced by electronic workflows of digital documents. These workflows often require multiple signatures to be added to the documents for authorization and/or integrity. We describe examples of digital workflows that illustrate problems with digital signatures: i.e. the use of digital signatures across entire documents results in signatures that can be unnecessarily invalidated by subsequent modification of the document. We propose the use of fragment signatures, which reduce unnecessary invalidation of signatures and enable greater concurrency in workflows. Our approach is document\u2010centric and does not use a centralized database. We report on an implementation that allows fragment signatures over document fragments as well as the attachment (or embedding) of other documents. This\u00a0\u2026", "num_citations": "9\n", "authors": ["1610"]}
{"title": "Domain analysis on an electronic health records system\n", "abstract": " Electronic Health Records (EHR) have been proposed as a means for managing the technical and organisational complexity that arises in modern healthcare. Different EHR systems are being developed around the world, and within individual countries, different services, such as electronic prescriptions, are being deployed that exploit EHR. We report on a domain analysis of England's developing EHR, as is being implemented in the NHS's National Programme for IT. The analysis, supported by the Feature-Oriented Domain Analysis (FODA) process, ultimately aims to identify commonality and variability across services that use EHR. We summarise the analysis, and describe challenges that we encountered when using FODA to support the analysis.", "num_citations": "9\n", "authors": ["1610"]}
{"title": "Cameo: an alternative model of concurrency for Eiffel\n", "abstract": " We present a new concurrency model for the Eiffel programming language. The model is motivated by describing a number of semantic problems with the leading concurrency model for Eiffel, namely SCOOP. Our alternative model aims to preserve the existing behaviour of sequential programs and libraries wherever possible. Comparison with the SCOOP model is made. The concurrency aspects of the alternative model are presented in CSP along with a model of exceptions. The results show that while the new model provides increased parallelism, this comes with the price of increased overhead due to lock management.", "num_citations": "9\n", "authors": ["1610"]}
{"title": "Bridging the Epsilon Wizard Language and the Eclipse Graphical Modeling Framework\n", "abstract": " The Eclipse Graphical Modeling Framework (GMF) provides tooling that enables developers to implement high-quality diagrammatical editors for modelling languages built atop the Eclipse Modeling Framework (EMF). Epsilon is an Eclipse GMT component that aims at providing infrastructure for developing tool support for task-specific model management languages. The Epsilon Wizard Language is a language built atop Epsilon, which targets the task of in-place model transformations. In this paper, we present the results of our effort to provide a bridge between GMF and EWL that enables users to define and execute in-place transformations (wizards) expressed in EWL in the context of GMF-based editors. The rest of the paper is organized as follows. In Sections 2 and 3 we briefly discuss Epsilon and EWL. In Section 4 we present our implementation and in Section 5 we conclude and provide directions to future work on the subject.", "num_citations": "9\n", "authors": ["1610"]}
{"title": "The design of a tool-supported graphical notation for timed CSP\n", "abstract": " A graphical notation for representing Timed CSP (TCSP) specifications is presented. The notation, which integrates features from a number of existing specification languages, including Statecharts, is aimed at providing the means for more easily constructing and managing large TCSP specifications, with the intention of forming the basis for tools and a methodology for applying TCSP in the large. The graphical notation extends TCSP by allowing specifications to be both processes and arbitrary predicates, thus increasing the expressiveness and applicability of the notation. An extendible tool framework, designed for the graphical notation and to be integrated with other tools, is outlined. We discuss the features of this framework, especially how it aims to support reasoning about TCSP specifications.", "num_citations": "9\n", "authors": ["1610"]}
{"title": "On-the-fly Translation and Execution of OCL-like Queries on Simulink Models\n", "abstract": " MATLAB/Simulink is a tool for dynamic system modelling widely used across industries such as aerospace and automotive. Model management languages such as OCL, ATL and the languages of the Epsilon platform enable the validation, model-to-model, model-to-text transformation of models but tend to focus on the Eclipse Modelling Framework (EMF), a de facto standard for domain specific modelling. As Simulink models are built on an entirely different technical stack, the current solution to manipulate them using such languages requires their transformation into an EMF-compatible representation. This approach is expensive as (a) the cost of the transformation can be crippling for large models, (b) it requires the synchronisation of the native Simulink model and its EMF counterpart, and (c) the EMF-representation may be an incomplete copy of the model potentially hampering model management operations. In\u00a0\u2026", "num_citations": "8\n", "authors": ["1610"]}
{"title": "Parallel Model Validation with Epsilon\n", "abstract": " Traditional model management programs, such as transformations, often perform poorly when dealing with very large models. Although many such programs are inherently parallelisable, the execution engines of popular model management languages were not designed for concurrency. We propose a scalable data and rule-parallel solution for an established and feature-rich model validation language (EVL). We highlight the challenges encountered with retro-fitting concurrency support and our solutions to these challenges. We evaluate the correctness of our implementation through rigorous automated tests. Our results show up\u00a0to linear performance improvements with more threads and larger models, with significantly faster execution compared to interpreted OCL.", "num_citations": "8\n", "authors": ["1610"]}
{"title": "System of systems acquisition trade-offs\n", "abstract": " During System of Systems acquisition, organisations aim to satisfy their goals through the procurement of systems, people, training and processes. The most successful organisations undertake these acquisitions as efficiently as possible. For large organisations, a set of goals may be satisfied \u2013 to varying degrees \u2013 by any one of a large number of potential resource combinations, and so it is necessary to consider the trade-offs exhibited by each combination to find an effective System of Systems architecture.In this paper, we present an approach, supported by tools, that combines techniques from the fields of goal-modelling and multi-objective optimisation to effectively explore these high-level organisational trade-offs. The decision maker can state the organisational problems and provide high-level descriptions of the existing and acquirable systems using a custom domain specific language. The tool then explores\u00a0\u2026", "num_citations": "8\n", "authors": ["1610"]}
{"title": "Lies, Damned Lies and UML2Java\n", "abstract": " We review far too many research papers for journals and conferences.(Admittedly, we probably write too many papers as well, but that's another story.) We regularly encounter misunderstandings, misconceptions, misrepresentations and plain old-fashioned errors related to Model-Driven Engineering (MDE): what it is, how it works, what it really means, what's wrong with it, and why it's yet another overhyped, oversold, overheated idea. Some of these misunderstandings are annoyingly common for us to want to put them down on the digital page and try to address them here. Perhaps this will help improve research papers, or it will make reviewing easier; perhaps it will lead to debate and argument; perhaps this list will be consigned to an e-bin somewhere.", "num_citations": "8\n", "authors": ["1610"]}
{"title": "Migrating activity diagrams with Epsilon Flock\n", "abstract": " The Transformation Tools Contest 2010 workshop invites solutions to a model migration case in which UML activity diagrams are to be migrated from UML 1.4 to UML 2.2. This paper presents a solution to this case, which uses Epsilon Flock, a model transformation language tailored for model migration.", "num_citations": "8\n", "authors": ["1610"]}
{"title": "Automated safety analysis for domain-specific languages\n", "abstract": " Critical systems must be shown to be acceptably safe and secure to deploy and use in their environment. But the size, scale, heterogeneity, and distributed nature of these increasingly complex systems makes them difficult to verify and analyse. Additionally, domain experts use a variety of languages to model and build their systems. We present an automated safety analysis technique, Fault Propagation and Transformation Analysis, and explain how it can be used for automatically calculating the failure behaviour of an entire system from the failure behaviours of its components. We outline an implementation of the technique in the Epsilon model management platform, thus allowing it to be used in combination with state-of-the-art model management languages and tools, and making it applicable to a variety of different domainspecific modelling languages.", "num_citations": "8\n", "authors": ["1610"]}
{"title": "Xround: Bidirectional transformations and unifications via a reversible template language\n", "abstract": " Efficient tool support for transformations is a key requirement for the industrialisation of MDA. While there is substantial and growing support for unidirectional transformations (e.g., from PIM-to-PSM), for bidirectional transformations there is little. This paper presents tool support for bidirectional transformations, in the form of a language, called XRound, for specifying reversible templates. The language supports round-trip transformations between UML models and predicate logic. Its supporting tool also implements model unification, so that new information encoded in logic can be seamlessly integrated with information encoded in the model.", "num_citations": "8\n", "authors": ["1610"]}
{"title": "Towards agile re-engineering of dependable grid applications\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "8\n", "authors": ["1610"]}
{"title": "From Z to Bon/Eiffel\n", "abstract": " The article shows how to make a transition from the Z formal notation to the Business Object Notation (BON). It is demonstrated that BON has the expressive power of Z, with the additional advantages of object-orientation and a supporting seamless development method. The transition is illustrated for some widely used Z constructs. The translation lays the groundwork for a semi-automated tool for extracting classes from Z specifications.", "num_citations": "8\n", "authors": ["1610"]}
{"title": "The changing face of model-driven engineering\n", "abstract": " Model-Driven Engineering has been studied and applied for many years, and it has evolved to a state where it has been used successfully in a variety of substantial projects. It is now at a state of maturity where there are potentially significant challenges to future adoption. In this chapter, we outline the state of practice in Model-Driven Engineering and point to two important future research directions: support for more flexible approaches to modelling and support for legacy models and modelling technologies.", "num_citations": "7\n", "authors": ["1610"]}
{"title": "A domain specific transformation language to bridge concrete and abstract syntax\n", "abstract": " Existing language workbenches, such as Xtext, support bridging the gap between the concrete syntax (CS) and abstract syntax (AS) of textual languages. However, the specification artefacts \u2013 i.e. grammars \u2013 are not sufficiently expressive to completely model the required CS-to-AS mapping, when it requires complex name resolution or multi-way mappings. This paper proposes a new declarative domain specific transformation language (DSTL) which provides support for complex CS-to-AS mappings, including features for name resolution and CS disambiguation. We justify the value of and need for a DSTL, analyse the challenges for using it to support mappings for complex languages such as Object Constraint Language, and demonstrate how it addresses these challenges. We present a comparison between the new DSTL and the state-of-the-art Gra2Mol, including performance data showing a\u00a0\u2026", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Big health data: Institutional and technological challenges\n", "abstract": " Much of the enthusiasm about Big Data focuses on the potential for exploiting the large, high quality datasets that are now available about the weather, sub-atomic particles, voting behaviour and many other topics. Current challenges focus on exploiting the datasets\u2013on the management of data, on new methods for analysis and visualisation. But there is another class of Big Data, typified by the routine data that are generated within organisations, including public services. Datasets are typically inaccurate and incomplete, and yet contain the best available information about the numbers of people who are in the criminal justice system, are doing well at school or are at risk of developing a particular disease.This paper focuses on the second class of Big Data, and in particular on secondary uses of health care datasets in the NHS in England. For the purposes of discussion, the primary use of health care information is for the diagnosis, treatment and care that we receive from doctors, nurses and other clinicians. Every other use is a secondary use, and includes planning services, managing budgets, accounting for resources used and research. There is a long history of these secondary uses in all health care systems, and citizens appear to be relaxed about the use of aggregated\u2013and non-identifiable\u2013data by staff working within a system. But expectations have been raised about new uses of health care data by third parties (ie neither patients nor health care staff). Manyika and", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Failures of a business process in enterprise systems\n", "abstract": " A business process model typically describes a desired flow of events in an ideal environment. However, the reality tends to be more complicated than what is designed in the model. During the execution of business process instances, a lot of exceptions may occur. These exceptions are deviations from the correct, specified sequence of events. Thus it is important to know the behaviours of process instances in the presence of exceptions. The classical approach of incorporating exception analysis in process models has been trying to anticipate beforehand all possible exceptional conditions that might arise and argue the process model with those additional conditions in order to determine the exception handling actions. This approach, however, might be problematic because the identification of all possible exceptions relies on the experience and intuition of the participants.To have a clear understand of\u00a0\u2026", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Integrated model management with Epsilon\n", "abstract": " This paper provides a summary of the contents of the ECMFA 2011 tutorial titled \u201dIntegrated Model Management with Epsilon\u201d. The aim of the tutorial is to provide an overview of the principles, practices and standards related to MDE and present the Epsilon model management platform, which provides an extensible architecture and set of consistent and interoperable task-specific model management languages and tools for automating a wide range of MDE operations.", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Generating formal model transformation specification using a template-based approach\n", "abstract": " Model transformation is a key activity in Model-Driven Engineering (MDE). Transformations map between models, in different languages and/or at different levels of abstraction. Model transformation introduces challenges for specification, verification and validation. Normally, MDE development requires planning which includes metamodel and transformation design and a customized testing. This paper describes ongoing work on a unified approach to specifying and verification of model transformations using a template-based mapping to a formal specification language. A small example shows how diagrammatic models mapped to Alloy so that the Alloy Analyzer can check transformation properties.", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Lazy exploration and checking of CSP models with CSPsim\n", "abstract": " We have recently constructed a model, and carried out an analysis, of a concurrent extension to an object-oriented language at a level of abstraction above threads. The model was constructed in CSP. We subsequently found that existing CSP tools were unsuitable for reasoning about and analysing this model, so it became necessary to create a new tool to handle CSP models: CSPsim. We describe this tool, its capabilities and algorithms, and compare it with the related tools, FDR2 and ProBE. We illustrate CSPsim's usage with examples from the model. The tool's on-the-fly construction of successor states is important for exhaustive and non-exhaustive state exploration. Thus we found CSPsim to be particularly useful for parallel compositions of components with infinite states that reduce to finite-state systems.", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Implementing the interactive television applications case study using epsilon\n", "abstract": " In this paper we illustrate a technical solution to the Interactive Television Applications case study presented in [1] using languages and tools from the Epsilon GMT component based on the infrastructure provided by the Eclipse Modeling Framework (EMF).", "num_citations": "7\n", "authors": ["1610"]}
{"title": "Measuring the scattering coefficient of turbid media from two-photon microscopy\n", "abstract": " In this paper, we propose a new and simple method based on two-photon excitation fluorescence (TPEF) microscopy to measure the scattering coefficient \u00b5_s of thick turbid media. We show, from Monte Carlo simulations, that \u00b5_s can be derived from the axial profile of the ratio of the TPEF signals epi-collected by the confocal and the non-descanned ports of a scanning microscope, independently of the anisotropy factor g and of the absorption coefficient \u00b5_a of the medium. The method is validated experimentally on tissue-mimicking optical phantoms, and is shown to have potential for imaging the scattering coefficient of heterogeneous media.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Revealing complexity through domain-specific modelling and analysis\n", "abstract": " Complex systems exhibit emergent behaviour. The explanations for this explicit emergent behaviour are often difficult to identify, and usually require understanding of significant parts of system structure and component behaviour to interpret. We present ongoing work on a set of techniques, based on Model-Driven Engineering principles and practices, for helping to reveal explanations for system complexity. We outline the techniques abstractly, and then illustrate parts of them with three examples from the health care, system security and Through-Life Capability Management domains.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Model Engineering for Complex Systems\n", "abstract": " Complex systems are hard to define [1]. Nevertheless they are more and more frequently encountered. Examples include a worldwide airline traffic management system, a global telecommunication or energy infrastructure or even the whole legacy portfolio accumulated for more than thirty years in a large insurance company. There are currently few engineering methods and tools to deal with them in practice. The purpose of this Dagstuhl Perspectives Workshop on Model Engineering for Complex Systems was to study the applicability of Model Driven Engineering (MDE) to the development and management of complex systems. MDE is a software engineering field based on few simple and sound principles. Its power stems from the assumption of considering everything\u2013engineering artefacts, manipulations of artefacts, etc\u2013as a model [3].", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Origins of the Grid architectural style\n", "abstract": " The grid represents an emerging class of highly complex distributed systems that aims to realize the full potential of the Web services computational and architectural models. Blueprints and recipes for building grids do not as of yet exist. We present a grid architectural style, and describe how it has been designed, and its relationships with other key elements of distributed systems", "num_citations": "6\n", "authors": ["1610"]}
{"title": "A critique of SCOOP\n", "abstract": " The Simple Concurrent Object-Oriented Programming (SCOOP) is the leading proposed mechanism for introducing concurrency to Eiffel. We summarise our position on the status of SCOOP, and on the open issues and research questions that should be addressed.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "E-tester: a contract-aware and agent-based unit testing framework for eiffel\n", "abstract": " We describe a contract-aware unit testing framework, E-Tester, for the Eiffel programming language. The framework differs from JUnit in its first-class support for lightweight formal methods, through test support for contracts and assertions. As well, it supports a form of negative test, called violation cases, which aim at validating contracts. It also differs based on its use of agents for expressing tests and test cases. We compare E-Tester with JUnit and suggest several advantages it offers, with the additional aim of making recommendations for improving JUnit\u2019s support for testing software with contracts. We also explain how it can be applied within a test-driven process for building reliable systems.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Formalising Eiffel references and expanded types in PVS\n", "abstract": " Ongoing work is described in which a theory of Eiffel reference and expanded (composite) types is formalised. The theory is expressed in the PVS specification language, thus enabling the use of the PVS theorem prover and model checker to semi-automatically prove properties about Eiffel structures and programs. The theory is being used as the basis for automated support for the Eiffel Refinement Calculus.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Combining agile practices with UML and EJB: A case study in agile development\n", "abstract": " An agile methodology, with similarities to the Rational Unified Process, and which integrates selected XP practices, UML modelling and Enterprise Java Beans is described. A case study in the domain of web-based systems is outlined, which applies and assesses the utility of the methodology.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Theorem Proving Support for View Consistency Checking.\n", "abstract": " Cet article pr\u00e9sente une approche formelle et automatis\u00e9e pour la v\u00e9rification de la coh\u00e9rence des contraintes entre deux vues d\u2019un syst\u00e8me orient\u00e9e objets. Les vues, d\u00e9crites dans le langage de mod\u00e9lisation BON, capture l\u2019architecture statique du syst\u00e8me gr\u00e2ce \u00e0 des diagrammes de classes annot\u00e9s par des contrats, la vue dynamique est r\u00e9alis\u00e9e par des diagrammes de collaboration. Les contraintes sont sp\u00e9cifi\u00e9es comme une extension du m\u00e9ta-mod\u00e8le de BON et sont impl\u00e9ment\u00e9es en PVS. Elles assurent que les s\u00e9quences de messages qui apparaissent dans la vue dynamique sont l\u00e9gales compte-tenu des pr\u00e9-post conditions de la vue statique. Un exemple d\u2019utilisation du prouveur PVS pour d\u00e9montrer la coh\u00e9rence des vues est d\u00e9crit.", "num_citations": "6\n", "authors": ["1610"]}
{"title": "Towards Platform Independent Database Modelling in Enterprise Systems\n", "abstract": " Enterprise software systems are prevalent in many organisations, typically they are data-intensive and manage customer, sales, or other important data. When an enterprise system needs to be modernised or migrated (e.g. to the cloud) it is necessary to understand the structure of this data and how it is used. We have developed a tool-supported approach to model database structure, query patterns, and growth patterns. Compared to existing work, our tool offers increased system support and extensibility which is vital for use in industry. Standardisation and platform independence is ensured by producing models conforming to the Knowledge Discovery Metamodel and Software Metrics Metamodel.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Traceability in model-driven safety critical software engineering\n", "abstract": " Evidence-Based Software Engineering (EBSE) focuses on understanding and delivering software engineering practices, tools and techniques that qualitatively and quantitatively provide value. The principles of EBSE underpin safety critical software engineering practices: when we build a safety critical software system, we must, in parallel, deliver evidence that the steps we have taken and the artefacts that we build will lead to an acceptably safe system. In safety critical software engineering, traceability plays a vital role. This talk will explore some of the different applications and uses of traceability in this context, and will suggest ways in which Model-Driven Engineering can provide solutions (eg, through standardised approaches for describing safety arguments and evidence), as well as new challenges.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Content personalization for inclusive education through model-driven engineering\n", "abstract": " Content personalization of e-learning resources has the opportunity to encourage self-directed learning and collaborative activities between students with varying cultures and backgrounds. In the case of students with disabilities, it also has the potential to provide equality of access to learning resources that can be presented in formats that are compatible with a student\u2019s needs and preferences. In this paper, a framework is presented for doing this type of content personalization for students with disabilities using Model-Driven Engineering tools and techniques.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Exploring the boundaries of enterprise information systems\n", "abstract": " Around the globe companies are steadily becoming more connected. Therefore, there is an increasing demand for IT systems that can support large interconnected organisations. One of the main requirements of such systems is the ability to support business processes as well as organisational connections. There is a tension between how IT systems that support large interconnected organisations are currently built and organisations\u2019 functionalities. In addition, there is a need for such systems to have the flexibility to address new business requirements and opportunities. These tensions are addressed in the field of Enterprise Information Systems (EIS). The focus of this paper is on exploring the boundaries of the concept of Enterprise Information Systems through a survey of the literature on EIS. The aim is to delineate what might legitimately be described as an EIS and where this technology might be applied.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Towards a Metamodel for Dependability Cases\n", "abstract": " \u220e(Design) decisions collections of factors\u220e-ve &+ ve contributions to achieving a goal\u220e Identification of \u2018sensitivity points\u2019", "num_citations": "5\n", "authors": ["1610"]}
{"title": "An agile and extensible code generation framework\n", "abstract": " Code generation automatically produces executable code by software. Model-driven code generation is currently the most flexible and scalable generative technique, but there are many complaints about the complexity it introduces into the development process, and the design decisions imposed on the code. Here, an agile code-oriented model-driven generative methodology is outlined that reduces complexity and allows the engineer to define the exact form of the produced code and embrace change in the requirements in an automated manner. A flexible tool, ECGF, supports this methodology, and a case study in rapid generation of large-scale HTML documents is outlined.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "An Information Model for High-Integrity Real Time Systems\n", "abstract": " We propose an information model that captures information suitable for architectural modelling in high integrity real time systems. We also suggest an overall context for architectural modelling and place the information model within this context. Furthermore, we use a simple three-phased approach to architectural modelling. With such approach, models are both tractable but also rich enough to be able to provide for various kinds of formal analyses. This work has been carried out by the DARP HIRTS (Defence and Aerospace Research Partnership for High Integrity Real Time Systems), part of the HISE (High Integrity Systems Engineering) research group at the University of York, and in collaboration with BAE SYSTEMS, Rolls-Royce plc and QinetiQ ltd.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "A test-based agile approach to checking the consistency of class and collaboration diagrams\n", "abstract": " The problem of checking the consistency of different views of a system is presented, and a test-based approach\u2013which is being implemented in the context of an object-oriented CASE tool\u2013is described using the Eiffel language. The approach is novel in that it supports design-by-contract mechanisms, including preconditions, postconditions, and class invariants, that may be embedded within views. The agile development process in which the approach is intended to be used is outlined.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "A Tool-Supported Integration of BON and JML\n", "abstract": " We describe a tool-supported integration of an object-oriented formal method, BON, with an object-oriented formal modelling language, JML. The integration is both artifactual\u2013carried out so as to exploit JML\u2019s existing and planned tool support\u2013and effectual, in order to provide a graphical syntax and process support for JML. The integration is characterised using the meta-method of [13, 14] which provides a general approach for combining software development methods and modelling languages. A CASE tool is described that supports the integrated techniques.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "An object-oriented refinement calculus\n", "abstract": " Design-by-contract has been used in the BON/Eiffel setting as an industrial-strength technique for building reliable, reusable, and maintainable software systems. We show that it provides a basis for refining object-oriented specifications to programs on an industrial scale. We present a collection of algorithm refinement rules, in particular, new rules for introducing feature calls (which are the basis of object-oriented computing) that can be used to refine a specification in BON to an immediately executable and correct program in Eiffel. We show how refinement of large systems can be decomposed into an arbitrary number of small steps. And we describe how automated support for such a process can be developed based on existing tools.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Bunches for object-oriented, concurrent, and real-time specification\n", "abstract": " We show how a collection of object-oriented concepts can be directly expressed in predicative programming [6]. We demonstrate how these features can be used in cooperation with the existing real-time and concurrency features of predicative programming in several examples, thus providing a simple integration of object-orientation, real-time, and concurrency.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "An Introduction to BON\n", "abstract": " As designers and programmers of software, we need notations that we can use to write down our ideas. When we write programs, we use a programming language--like Eiffel--to describe how we want the machine to behave. A programming language is a useful notation for writing down algorithms, and for efficiently implementing systems. However, when we are trying to solve a problem (one that will eventually be implemented as a computer program) a programming language isn't likely to be the most appropriate notation. When we are problem solving, we probably won't be concerned with the technical details that we must worry about when we are programming. When we are problem solving, and when we are designing our systems, we want to be able to write down abstractions, using a notation that is well-suited to expressing abstractions. When we are thinking, we don't want to be forced to think in terms of programming language idioms--things like registers, while loops, pointers, and the like. We usually want to think in terms of abstractions--high-level concepts like classes, relationships, components, and so on. And there are better notations for describing these abstractions than programming languages.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Case studies in using a meta-method for formal method integration\n", "abstract": " We summarize the results of several experiments in applying a meta-method for formal method integration [18, 19]. We provide a small example of using an instance of integrated formal methods, and discuss properties and difficulties associated with applying the meta-method to combining and using several formal and semiformal methods.", "num_citations": "5\n", "authors": ["1610"]}
{"title": "Systematic evaluation of (safety) assurance cases\n", "abstract": " An Assurance Case (AC) documents an argument that supports a claim made about a system. An effective Assurance Case provides adequate belief to stakeholders that the system under consideration adequately embodies specific critical properties, for example safety and security. Comprehensive evaluation of an AC is a necessary step in building this belief. This involves measuring confidence in the assurance case argument, but also includes an overall quality assessment of the AC. This paper describes essential components of a (safety) AC evaluation process using previously defined evaluation criteria. These criteria were classified as applying to either structure or content of the (safety) AC. Two example (safety) ACs are used to demonstrate the approach, and for brevity, we illustrate the examples using purely Goal Structuring Notation (GSN) and in a second example, a GSN-like notation.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Criteria to systematically evaluate (safety) assurance cases\n", "abstract": " An assurance case (AC) captures explicit reasoning associated with assuring critical properties, such as safety. A vital attribute of an AC is that it facilitates the identification of fallacies in the validity of any claim. There is considerable published research related to confidence in ACs, which primarily relate to a measure of soundness of reasoning. Evaluation of an AC is more general than measuring confidence and considers multiple aspects of the quality of an AC. Evaluation criteria thus play a significant role in making the evaluation process more systematic. This paper contributes to the identification of effective evaluation criteria for ACs, the rationale for their use, and initial tests of the criteria on existing ACs. We classify these criteria as to whether they apply to the structure of the AC, or to the content of the AC. This paper focuses on safety as the critical property to be assured, but only a very small number of the\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Domain-specific languages for the design, deployment and manipulation of heterogeneous databases\n", "abstract": " The need for levels of availability and scalability beyond those supported by relational databases has led to the emergence of a new generation of purpose-specific databases grouped under the term NoSQL. In general, NoSQL databases are designed with horizontal scalability as a primary concern and deliver increased availability and fault tolerance at a cost of temporary inconsistency and reduced durability of data. To balance the requirements for data consistency and availability, organisations increasingly migrate towards hybrid data persistence architectures comprising both relational and NoSQL databases. The consensus is that this trend will only become stronger in the future; critical data will continue to be stored in ACID (largely relational) databases while non-critical data will be progressively migrated to high-availability NoSQL databases. Designing and deploying a hybrid data persistence architecture\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Towards automatic generation of UML profile graphical editors for papyrus\n", "abstract": " We present an approach for defining the abstract and concrete syntax of UML profiles and their equivalent Papyrus graphical editors using annotated Ecore metamodels, driven by automated model-to-model and model-to-text transformations. We compare our approach against manual UML profile specification and implementation using Archimate, a non-trivial enterprise modelling language, and we demonstrate the substantial productivity and maintainability benefits it delivers.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Restmule: Enabling resilient clients for remote APIs\n", "abstract": " Mining data from remote repositories, such as GitHub and StackExchange, involves the execution of requests that can easily reach the limitations imposed by the respective APIs to shield their services from overload and abuse. Therefore, data mining clients are left alone to deal with such protective service policies which usually involves an extensive amount of manual implementation effort. In this work we present RestMule, a framework for handling various service policies, such as limited number of requests within a period of time and multi-page responses, by generating resilient clients that are able to handle request rate limits, network failures, response caching, and paging in a graceful and transparent manner. As a result, RestMule clients generated from OpenAPI specifications (ie standardized REST API descriptors), are suitable for intensive data-fetching scenarios. We evaluate our framework by reproducing\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Model-based tool support for Tactical Data Links: an experience report from the defence domain\n", "abstract": " The Tactical Data Link (TDL) allows the exchange of information between cooperating platforms as part of an integrated command and control () system. Information exchange is facilitated by adherence to a complex, message-based protocol defined by document-centric standards. In this paper, we report on a recent body of work investigating migration from a document-centric to a model-centric approach within the context of the TDL domain, motivated by a desire to achieve a positive return on investment. The model-centric approach makes use of the Epsilon technology stack and provides a significant improvement to both the level of abstraction and rigour of the network design. It is checkable by a machine and, by virtue of an MDA-like approach to the separation of domains and model transformation between domains, is open to integration with other models to support more complex workflows, such\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Exploring the Use of Metaheuristic Search to Infer Models of Dynamic System Behaviour.\n", "abstract": " As software systems become more pervasive and increase in both size and complexity, the requirement for systems to be able to selfadapt to changing environments becomes more important. This paper describes a model-based approach for adapting to dynamic runtime environments using metaheuristic optimisation techniques. The metaheuristics exploit metamodels that capture the important components in the adaptation process. Firstly, a model of the environment\u2019s behaviour is extracted using a combination of inference and search. The model of the environment is then used in the discovery of a model of optimal system behaviour\u2013ie how the system should best behave in response to the environment. The system is then updated based on this model. This paper focuses on investigating the extraction of a behaviour model of the environment and describes how our previous work can be utilised for the adaptation stage. We contextualise the approach using an example and analyse different ways of applying the metaheuristic algorithms for discovering an optimal model of the case study\u2019s environment.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "1st international workshop on combining modelling and search-based software engineering (CMSBSE 2013)\n", "abstract": " Modelling plays a vital and pervasive role in software engineering: it provides means to manage complexity via abstraction, and enables the creation of larger, more complex systems. Search-based software engineering (SBSE) offers a productive and proven approach to software engineering through automated discovery of near-optimal solutions to problems, and has proven itself to be effective on a wide variety of software-and systems engineering problems. CMSBSE 2013 was a forum allowing researchers from both communities to meet, discuss synergies and differences, and present topics related to the intersection of search and modelling. Particular goals of CMSBSE were to highlight that SBSE and modelling have substantial conceptual and technical synergy, and to identify and present opportunities in which they can be combined, whilst also aiming to grow the community working in this area.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "The UK Large-Scale Complex IT Systems (LSCITS) Initiative\n", "abstract": " This paper summarizes the current activities and the future plans of the UK National Research & Training Initiative in the Science & Engineering of Large\u2010Scale Complex IT Systems (LSCITS). The LSCITS Initiative is funded by over\u00a3 10m of UK public funds, runs from 2007\u20102014, and involves research teams at six top British universities, including a training programme that aims to graduate more than 50 doctoral researchers. We start with a discussion of the Initiative\u2019s motivating concern: the observation that in most advanced economies, large\u2010scale socio\u2010technical systems are increasing in complexity, and in socio\u2010economic criticality, while our ability to engineer and manage such systems is probably not increasing at the same pace. From this comes the concern that in advanced economies we may already be reliant on large\u2010scale complex IT systems that support critical social and economic functions, and yet\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Evaluating goal-oriented analysis in the domain of enterprise information systems\n", "abstract": " The development of Enterprise Information Systems (EIS) raises specific challenges related to the scale and complexity of the business processes that must be supported. Techniques for managing the challenges of scale and complexity are often based on modelling, and are targeted at different parts of the EIS development process. This paper presents the results of an evaluation of a number of goal-oriented analysis approaches in the domain of EIS, based on an example EIS for health care. The paper concludes that existing approaches lack process guidance and, in particular, guidance on the evaluation of the results of goal analysis. We present an analysis of the problem of evaluation, and propose a scenario-based approach to evaluate the results of goal analysis.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Towards a model-based refinement process for contractual state machines\n", "abstract": " We present a rigorous model-based approach to the stepwise design of contractual state machines, which are a simplified form of state charts extended with declarative specifications. The approach is based on application of a set of refinement patterns, that can be validated against a formal semantics, and that are implemented using update-in-place model transformations. We describe the integrated tool support we are implementing for this model-based approach, and illustrate the approach with small examples.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Theory and practice of model transformations\n", "abstract": " Models have become essential for supporting the development, analysis and evolution of large-scale and complex IT systems. Models allow different views, perspectives and elements of a system to be captured rigorously and precisely, thus allowing automated tools to manipulate and manage the models. In a full-fledged model-driven engineering (MDE) process, the transformations developed and expressed between models are also key. Model transformations allow the definition and implementation of the operations on models, and also provide a chain that enables the automated development of a system from its corresponding models. Model transformations are already an integral part of any model-driven approach, and there are a number of available model transformation languages, tools, and supporting environments; some of these approaches are now approaching maturity. Nevertheless, much work\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Practical distributed processing\n", "abstract": " Distributed processing has a strong theoretical foundation, but many day-to-day practitioners make limited use of the advantages this theory can give them. The result includes unreliable systems with obscure and intermittent failures that can cost time, money and in extreme cases, lives. Reliable construction of distributed and concurrent systems must incorporate theory in practice. This book provides a concise presentation of the theory closely linked to the practical realisation of these concepts. This easy-to-follow textbook focuses on practical issues of building working distributed systems and gives an overview of the basic theory, principles and techniques, whilst illustrating how these fit together, via the process of building interesting, non-trivial systems. Topics and features:\u2022 Provides all the elements needed for a complete development of a distributed system, from theory to practice\u2022 Offers an integrated approach to the field of distributed processing, and presents a coherent view of the field as a practical subject\u2022 Links theoretical models of concurrency with practical realisation of systems\u2022 Contains many examples from C, Java Ada and Eiffel, as well as case studies\u2022 Considers important aspects of the engineering process, including models that can be used to assess and analyse parts of distributed systems, implementation techniques, as well as protocols and security concerns\u2022 Many pedagogical tools: chapter summaries, exercises (with sketch solutions and hints), comprehensive glossary, Internet support for students and instructors, accessible at http://www. scm. tees. ac. uk/pj brooke/dpb/.\u2022 Ideal for use by lecturers as a coherent one-term\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Model Driven Architecture-Foundations and Applications: Third European Conference, ECMDA-FA 2007, Haifa, Israel, June 11-15, 2007, Proceedings\n", "abstract": " Model-driven architecture, and model-driven approaches in general, holds the promise of moving software development towards a higher level of abstraction. Given the challenges in the software industry of delivering more complex fu-tionality with less e? ort, it is not really a question whether model-driven-velopment will succeed, but rather a question of when it will break through. However, before this can happen, there are many challenging problems to c-quer, both theoretical and pragmatic. This requires close collaboration between academic research and industrial application. ThegoaloftheEuropeanConferenceonModel-DrivenArchitecture\u2014Fo-dations and Applications (ECMDA-FA) is to bring together industry and academia to tackle the problems in model-driven development. This volume-cludes nine foundation papers and seven application papers. ECMDA-FA 2007 alsohostedsixworkshopsonboththeoreticalandpracticalaspectsofMDA. F-thermore, the keynote speakers, Stuart Kent from Microsoft and Andy Schur \u0308 r from TU Darmstadt, proved that both industry and academia are interested in MDA and its applications. This third ECMDA-FA conference is the result of the work of the authors who submitted a total of 60 papers, the Program Committee members who produced careful and thoughtful reviews under signi? cant time pressures, the people organizing the workshops, and of course the Steering Committee. Several hundreds of people worked hard to make this conference a success. We have the honor of speaking for all these people in this preface and we would like to thank each of them for their valuable contribution. The ECMDA\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Game Development using Design-by-Contract.\n", "abstract": " There are some application domains to which it appears intrinsically challenging to introduce the services offered by formal engineering methods. This paper is an evidence-based presentation that lightweight formal methods are effective in building realistic networked multiplayer games. The evidence is produced via a pilot study that uses Design-by-Contract, under realistic game development conditions, and encompasses both qualitative and empirical results.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "An alternative model of concurrency for Eiffel\n", "abstract": " The Simple Concurrent Object-Oriented Programming (SCOOP) is the leading proposed mechanism for introducing concurrency to Eiffel. We outline a number of concerns, related to the semantics of SCOOP, and present an alternative concurrency model for Eiffel that alleviates many of these problems. Our alternative model aims to preserve the existing behaviour of sequential programs and libraries whereever possible. Comparison with the SCOOP model is made, and ongoing work on evaluating the alternative model is discussed. A sketch of the model in CSP is given.", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Security in Pervasive Computing: Third International Conference, SPC 2006, York, UK, April 18-21, 2006, Proceedings\n", "abstract": " This volume contains the papers presented at the Third International Conference on Security in Pervasive Computing (SPC 2006), held April 19\u201321, 2006 in York, UK. The conference focused on methods, tools, principles, and practices for assessing and achievingsecurityinapervasiveenvironment. Newsecurityconceptswerediscussed, in domains and applications such as handheld devices, mobile phones, smartcards, RFID chips, and smart labels, as well as new, emerging technological spaces. The conf-ence also presented work on fundamental themes such as risk identi? cation and mi-gation, security policies for pervasiveenvironments, privacymeasures (especially cr-tographic protocols), and mobility and location-aware services. Submissions included work on biometrics, ambient intelligence, Web services, security requirements, and many other topics. We received 56 submissions, and accepted 16 full papers for presentation. Each submission was reviewed by the international Programme Committee. We are grateful to the Programme Committee members, and the additional reviewers, for their timely completion of the reviewing process, and for the quality and detail of their reviews and discussion. Our thanks go to all members of the ProgrammeCommittee for their efforts; the-ditional reviewers; the authors, for submitting their papers; the keynote speaker, Frank Stajano; the invited speaker, Howard Chivers; and the Department of Computer S-ence, University of York, for supporting the event. April 2006 John A. Clark (Program Chair) Richard F. Paige Fiona AC Polack Phillip J. Brooke Organization SPC 2006 was organized by the\u00a0\u2026", "num_citations": "4\n", "authors": ["1610"]}
{"title": "Reusable textual styles for domain-specific modeling languages\n", "abstract": " Domain-specific languages enable concise and precise formalization of domain concepts and promote direct employment by domain experts. Therefore, syntactic constructs are introduced to empower users to associate concepts and relationships with visual textual symbols. Model-based language engineering facilitates the description of concepts and relationships in an abstract manner. However, concrete representations are commonly attached to abstract domain representations, such as annotations in metamodels, or directly encoded into language grammar and thus introduce redundancy between metamodel elements and grammar elements. In this work we propose an approach that enables autonomous development and maintenance of domain concepts and textual language notations in a distinctive and metamodel-agnostic manner by employing style models containing grammar rule templates and injection-based property selection. We provide an implementation and showcase the proposed notationspecification language in a comparison with state of the art practices during the creation of notations for an executable domain-specific modeling language based on the Eclipse Modeling Framework and Xtext.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Towards a modular and flexible human-usable textual syntax for EMF models.\n", "abstract": " This paper extends previous work on capturing models conforming to object-oriented metamodels using fuzzily-parsed XML, with mechanisms that facilitate file-level modularity and reuse. In particular we introduce facilities for importing and including content residing in external model files as well as a metamodel-independent templating mechanism that can facilitate encapsulation and reuse of complex model element structures.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Technical Obsolescence Management Strategies for Safety-Related Software for Airborne Systems\n", "abstract": " Complex software systems deployed in safety-critical and business-critical application domains (e.g., avionics, defence, healthcare) are meant to provide service for decades. Although many of these systems withstand technological evolution and infrequently undergo substantial changes, they will likely face software obsolescence problems during their lifetime. Resolving these obsolescence problems is an expensive, time-consuming and labour intensive process. This project investigates technical obsolescence problems in safety-related software for airborne systems, examines the applicability of obsolescence management strategies and explores methods to automate the resolution of software obsolescence.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Cloud computing workload and capacity management using domain specific modelling\n", "abstract": " Cloud computing is a technology through which software, platforms and infrastructure can be provided as services. Managing resources which enable this technology is a crucial task to maximise performance and benefits all related parties. Demand for resources starts with application requests initiated by the users. These trigger the creation of virtual machines, which in turn trigger the allocation of physical resources. This paper proposes a solution for cloud computing workload management and capacity planning by utilising domain specific modelling, model transformation, and time series analysis techniques with estimation algorithms. Each application\u2019s workload is different depending on its behaviour, software design and the technologies it builds atop. As such, each application needs to provide a custom workload domain specific language (WL-DSL) through which clients can express their anticipated workloads. Models conforming to different WL-DSLs can be transformed to a model conforming to a Virtual Machine domain specific language (VM-DSL) to assist the SaaS or PaaS service provider to manage their virtual resources in the cloud. The IaaS provider can also benefit from numbers of VM-DSL from their customer to manage their physical resources in the actual data centre by transforming multiple incoming VM-DSL models into a model that conforms to a Physical Machine Domain Specific Language (PM-DSL).", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Evaluating Student Work in Modelling Courses.\n", "abstract": " In any curriculum or course that teaches or emphasises the use of modelling, a critical concern is evaluating the modelling artefacts that students produce, leading to the production of feedback. Students need to be able to use this feedback to improve their understanding and to become better, more mature modellers. In this position paper, we discuss the challenges and importance of evaluating modelling (and related) artefacts and providing precise and reproducible feedback. We also discuss some possible principles and criteria for supporting this critical part of how we teach modelling.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Resource requirement analysis for web applications running in a virtualised environment\n", "abstract": " Analysis of resource usage and precise correlation with the workload that triggered it is essential in order to conduct capacity planning in computing environments. Virtualisation enables resource optimisation and is widely used in grid, cluster and cloud computing. We present an automated approach for resource usage analysis in a virtualised environment that can support capacity planning for web applications. The approach uses Domain Specific Modelling Languages (DSMLs) and model management techniques, which support tool interoperation and provide precise ways for describing resource and request logs and requirements, and automatically generate different outputs that feed into the capacity planning process. The approach is demonstrated using a proof-of-concept example involving a media streaming web application, and the results of the analysis are presented and discussed.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Strategy-guided requirements development and validation\n", "abstract": " The ultimate aim of business/mission software is to help implement the business value or mission imperatives. For critical business/mission applications, high-level strategies need to play a crucial role in the development and validation of software requirement, so that the requirements and the produced software can closely align with the business/mission objectives and effectively contribute to the business/mission success. In this paper, we propose a strategy-guided method for the development and validation of requirements. We firstly articulate the dimensions of strategy and concept model for connecting strategies and requirements. We then present the approaches for the requirements development and validation, based on the relationship between the elements of strategies and requirements. This strategy-guided method addresses the paradigms for both the market-oriented and customer-specific software\u00a0\u2026", "num_citations": "3\n", "authors": ["1610"]}
{"title": "An approach for model querying-by-example applied to multi-paradigm models\n", "abstract": " Scenarios for industry-scale multi-paradigm modelling involve analysis, transformation, or fine-grained manipulation of models. These models are often treatedwholly or in part as trees (eg XML or XMI documents, or source code). However, existing facilities for accessing and manipulating models as trees is limited. We present anovel approach to model querying-by-example, treating models as trees. The approachabstracts away from platform-specific concerns (eg XML), and exploits tree-basedpatterns in expressing queries; the results of queries are also trees, thus providing meansto compose (conjoin) queries without requiring intermediate manipulations.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "The state of the art in language workbenches-conclusions from the language workbench challenge\n", "abstract": " @inproceedings{ErdwegSVBBCGHKLKMPPSSSVVVWW13, author = {Sebastian Erdweg and Tijs van der Storm and Markus V\u00f6lter and Meinte Boersma and Remi Bosman and William R. Cook and Albert Gerritsen and Angelo Hulshout and Steven Kelly and Alex Loh and Gabri\u00ebl DP Konat and Pedro J. Molina and Martin Palatnik and Ri}, title = {The State of the Art in Language Workbenches - Conclusions from the Language Workbench Challenge}, booktitle = {Software Language Engineering - 6th International Conference, SLE 2013, Indianapolis, IN, USA, October 26-28, 2013. Proceedings}, publisher = {Springer}, year = {2013}, editor = {Martin Erwig and Richard F. Paige and Eric Van Wyk}, volume = {8225}, series = {Lecture Notes in Computer Science}, pages = {197-217}, isbn = {978-3-319-02653-4}, topic = {model-driven software development,domain-specific languages,Programming languages}, group = {SE\u2026", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Software language engineering\n", "abstract": " We are pleased to present the proceedings of the 6th International Conference of Software Language Engineering (SLE 2013). The conference was held in Indianapolis, USA, during October 26\u201328, 2013. It was co-located with the 12th International Conference on Generative Programming and Component Engineering (GPCE 2013), the 4th Conference on Systems, Programming, Languages and Applications: Software for Humanity (SPLASH 2013, which includes OOPSLA), the Dynamic Languages Symposium, the 5th International Workshop on Feature-Oriented Software Development, and three SLE workshops: the Industry Track of Software Language Engineering, the Systems Biology and Language Engineering, and the Parsing@ SLE Workshop. The SLE conference series is devoted to a wide range of topics related to artificial languages in software engineering. SLE is an international research forum that\u00a0\u2026", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Modeling workloads, slas and their violations in cloud computing\n", "abstract": " Cloud computing is an evolution of data centres with a concept of utility computing. In utility computing, the service provider provides resources and infrastructure accessible to the customers and charges them in a pay-per-use base. Although this concept has been around for some time, it has become widely employed lately under the term \u201cCloud Computing\u201d. One of the challenges in the field of Cloud Computing is resource management, which includes capacity management with regard to SLAs (Service Level Agreements). This paper analyses the roadmap for achieving a solution to the problem of breaching server workload agreed in SLAs between service providers and customers by utilising domain specific modelling and model analysis techniques.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Requirements for a model comparison language\n", "abstract": " Model comparison is an essential prerequisite for a number of model management tasks in Model-Driven Engineering, including model differencing, merging and transformation testing. Previous work highlighted some of the shortcomings of existing approaches to model comparison, and proposed a new language that addressed some of the key limitations. In this paper we present additional requirements that we have identified as a result of applying this particular language, the Epsilon Comparison Language, as well as possible solutions to the requirements. We aim to stimulate discussion of requirements and solutions for model comparison, both at a conceptual level and in terms of tool support for the particular model comparison language in question.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Largescale complex systems engineering\n", "abstract": " On the afternoon of 6th May 2010, the US equity markets underwent an extraordinary upheaval. In about 10 minutes, the Dow Jones Industrial Average dropped by over 600 points representing the disappearance of around one trillion dollars of market value. In the course of this sudden downturn, the share-prices of several blue-chip multinational companies went crazy\u2013shares in companies that had been a few tens of dollars plummeted to $0.01 in some instances, and rocketed to values over $100,000.00 in others.As suddenly as this market downturn occurred, it reversed; over the next few minutes most of the loss was recovered. Share prices returned to levels within a few percentage points of the values they had held before the crash. This \u2018Flash Crash\u2019sparked a major enquiry into its causes by the CFTC (Commodity Futures Trading Commission) and the SEC (Securities Exchange Commission).", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Jscoop: A high-level concurrency framework for java\n", "abstract": " SCOOP is a minimal extension to the sequential object-oriented programming model for concurrency. The extension consists of one keyword (separate) that avoids explicit thread declarations, synchronized blocks, explicit waits, and eliminates data races and atomicity violations by construction through a set of compiler rules. It attempts to guarantee fairness via use of a global scheduler. We present a new implementation of SCOOP for Java, called JSCOOP. JSCOOP introduces a new set of annotations modeled after SCOOP keywords, as well as several core library classes which provide the support necessary to implement the SCOOP semantics. A prototype Eclipse plug-in allows for the creation of JSCOOP projects. The plug-in does syntax checking and detects consistency problems at compile time. The use of JSCOOP is demonstrated by an example.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "High-level circuit design\n", "abstract": " We present two new ways to implement ordinary programs with logic gates. One, like imperative programs, has an associated memory to store state; the other, like functional programs, passes the state from one component to the next. Application-specific circuit design can be done more effectively by using a standard programming language to describe the function that a circuit is intended to perform, rather than by describing a circuit that is intended to perform that function. The resulting circuits are produced automatically; they behave according to the programs, and have the same structure as the programs. For timing, we use local delays, rather than a global clock or local handshaking. We give a formal semantics for both programs and circuits in order to prove our circuits correct. By simulation, we also demonstrate that the circuits perform favorably compared to others.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Producing reliable software via the single model principle\n", "abstract": " We contrast software modelling languages and developments that are founded on use of a single model with those founded on use of multiple models. The advantages and disadvantages of each approach are discussed. We propose that to best support seamless and reversible development of reliable software, languages and developments that follow the single model principle are superior for late requirements engineering through to implementation. We define the principle precisely, provide examples of languages that support it, contrast it with multiple model development, and discuss when the principle is insufficient: when dealing with inconsistent descriptions, and for capturing and manipulating early requirements.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Precise and formal metamodeling with the business object notation and pvs\n", "abstract": " A modeling language consists of both a notation and a metamodel, the latter of which captures the syntactic wellformedness constraints that all valid models must obey. We present two versions of a metamodel for an industrialstrength object-oriented modeling language, BON. The first version of the metamodel, written in BON itself, is intended to give a precise and understandable description of the syntactic well-formedness constraints. The second version, written in the PVS specification language, is intended to give a formal description of the constraints, in a form that is amenable to automated checking and analysis. We demonstrate how the PVS version can be used for conformance checking, ie, showing that BON models satisfy or fail to satisfy the metamodel. A process is defined for using the metamodel in carrying out conformance testing of models. We also contrast the BON metamodel with the metamodel of the Unified Modelling Language (UML), both in terms of the precise metamodel presented in the UML Semantics Reference, and a formalization of the metamodel presented in the Alloy specification language. We discuss lessons learned in constructing metamodels, particularly in terms of using the PVS specification language for metamodeling.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Specification and refinement using a heterogeneous notation for concurrency and communication\n", "abstract": " It is shown how to combine the Z formal specification notation with a predicative notation so as to be able to specify and reason about concurrency and communication. The integration is carried out so as to alleviate some of the limitations noted with previous integration approaches, such as the inability to use Z proof rules and tools with the integrated notation. In the process, it is demonstrated that it is not necessary to combine Z with a very different behavioural formalism in order to reason about concurrency.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Formal methods in the classroom: The logic of real-time software design\n", "abstract": " In recent years, much progress has been made towards the development of mathematical methods (\"formal methods\") through which it is possible, in principle, to specify and design software to conform to specifications. In this paper, we provide an overview of how formal methods-and particularly real-time formal methods-can be used throughout the software development cycle, and what methods and tools can be introduced in the computer science curriculum to support software development.", "num_citations": "3\n", "authors": ["1610"]}
{"title": "Higraph-based Predicate and Heterogeneous Specification\n", "abstract": " We describe a higraph-based notation for visualizing and writing predicate speci cations, and for depicting formal derivations of programs from speci cations. We show how to present various system views using the notation, and consider how to deal with abstraction, which is vital in coping with large speci cations. We then describe how the notation can be extended to heterogeneous speci cations Paig95].", "num_citations": "3\n", "authors": ["1610"]}
{"title": "An architecture for the development of distributed analytics based on polystore events\n", "abstract": " To balance the requirements for data consistency and availability, organisations increasingly migrate towards hybrid data persistence architectures (called polystores throughout this paper) comprising both relational and NoSQL databases. The EC-funded H2020 TYPHON project offers facilities for designing and deploying such polystores, otherwise a complex, technically challenging and error-prone task. In addition, it is nowadays increasingly important for organisations to be able to extract business intelligence by monitoring data stored in polystores. In this paper, we propose a novel approach that facilitates the extraction of analytics in a distributed manner by monitoring polystore queries as these arrive for execution. Beyond the analytics architecture, we presented a pre-execution authorisation mechanism. We also report on preliminary scalability evaluation experiments which demonstrate the linear\u00a0\u2026", "num_citations": "2\n", "authors": ["1610"]}
{"title": "ModelFlow: towards reactive model management workflows\n", "abstract": " In this paper we propose a domain specific language that enables the description and execution of model management workflows. Our language declares tasks and resources involved in a multi-step model management process and resolves the execution behaviour and order based on dependencies among these components. We describe the abstract and a concrete syntax of the language along with its execution semantics. Then, we demonstrate how the language interpreter can orchestrate and execute a selection model management tasks through a case study of a workflow that generates a graphical editor from a metamodel.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Stress-testing centralised model stores\n", "abstract": " One of the current challenges in model-driven engineering is enabling effective collaborative modelling. Two common approaches are either storing the models in a central repository, or keeping them under a traditional file-based version control system and build a centralized index for model-wide queries. Either way, special attention must be paid to the nature of these repositories and indexes as networked services: they should remain responsive even with an increasing number of concurrent clients. This paper presents an empirical study on the impact of certain key decisions on the scalability of concurrent model queries, using an Eclipse Connected Data Objects model repository and a Hawk model index. The study evaluates the impact of the network protocol, the API design and the internal caching mechanisms and analyzes the reasons for their varying performance.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Special issue on Model Based Engineering for Embedded Systems Design\n", "abstract": " Editorial: Special issue on Model Based Engineering for Embedded Systems Design: Journal of Systems Architecture: the EUROMICRO Journal: Vol 58, No 5 ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Journal of Systems Architecture: the EUROMICRO Journal Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsJournal of Systems Architecture: the EUROMICRO JournalVol. , No. Editorial: Special issue on Model Based Engineering for Embedded Systems Design article Editorial: Special issue on Model Based Engineering for Embedded Systems Design Share on Authors: Daniela Cancila profile image Daniela Cancila Atego Inc., France \u2026", "num_citations": "2\n", "authors": ["1610"]}
{"title": "KAOS-\u03b2: A Goal-oriented Process Model for EIS.\n", "abstract": " There is increasing demand for approaches to develop more effective enterprise information systems (EIS). A possible solution is to focus on eliciting and elaborating goals prior to capturing EIS requirements. Focusing on EIS goals could help the developer team and other stakeholders (particularly decision makers) achieve a shared and structured understanding of the goals of the EIS and the overall enterprise. We present an investigation of the use of the KAOS approach to goal modelling in the domain of EIS. As a result, we propose a tailoring of KAOS for this domain; the tailoring has been developed through empirical studies. Our tailoring, called KAOS-\u03b2, is described, and an empirical evaluation is presented, investigating its applicability for defining and structuring the goals of groups of EIS.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Formal Analysis in Model Management: Exploiting the Power of CZT.\n", "abstract": " The AUtoZ tools (jamesrobertwilliams. co. uk/autoz. php) provide formalisation in the style of commercially-acceptable model management [3]. AU-toZ is an automated framework based on Am\u00e1lio\u2019s GeFoRME, the generative framework for rigorous model-driven engineering [1]. GeFoRME is designed to give semantically-adaptable support to the construction of formal models from diagrams.Formal methods tools often produce messages aimed at expert users of the tool and relate to line numbers of the formal specification; mapping these messages back to components in UML diagrams is not trivial. To address this, we are creating an AUtoZ instance that targets the Community Z Tools (CZT) project (czt. sourceforge. net). The ZML sub-project of CZT [2] supports XML markup for Z. CZT tools annotate the ZML file, for instance with issues raised by formal analysis. Exploiting the fact that, in model engineering, a\u00a0\u2026", "num_citations": "2\n", "authors": ["1610"]}
{"title": "XRound: A reversible template language and its application in model-based security analysis\n", "abstract": " Successful analysis of the models used in Model-Driven Development requires the ability to synthesise the results of analysis and automatically integrate these results with the models themselves. This paper presents a reversible template language called XRound which supports round-trip transformations between models and the logic used to encode system properties. A template processor that supports the language is described, and the use of the template language is illustrated by its application in an analysis workbench, designed to support analysis of security properties of UML and MOF-based models. As a result of using reversible templates, it is possible to seamlessly and automatically integrate the results of a security analysis with a model.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "The view glue\n", "abstract": " In this paper we focus on domain-specific Architecture Description Languages (ADLs), particularly for safety critical systems. We argue that existing standards for architectural modelling are insufficient for achieving the necessary levels of control of the development process for such systems. We outline the requirements for safety critical ADLs, the challenges faced in their construction, and present an example - AIM - developed in collaboration with the safety industry. Explaining the key principles of AIM, we show how to address multiple and cross-cutting concerns through active system views and, how to ensure consistency across such views. The AIM philosophy is supported by a brief exploration of a real-life jet engine case study.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "The Meta-Object Facility (MOF)\n", "abstract": " \u2022 Co-funded by the European Commission, the MODELWARE project involves 19 partners from 8 European countries. MODELWARE aims to improve software productivity by capitalizing on techniques known as Model-Driven Development (MDD).\u2022 To achieve the goal of large-scale adoption of these MDD techniques, MODELWARE promotes the idea of a collaborative development of courseware dedicated to this domain.\u2022 The MDD courseware provided here with the status of open source software is produced under the EPL 1.0 license.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Unified Modeling Language for Knowledge Modelling\n", "abstract": " Knowledge modelling techniques are widely adopted for designing knowledge-based systems (KBS) and these systems are important for knowledge management. This paper argues the need and importance of adopting Unified Modeling Language (UML) for knowledge modelling through the profile extension mechanism. KBS are developed using knowledge engineering (KE) techniques that are often similar to software engineering (SE), and both domains emphasise the use of conceptual models in designing software systems. Most of these knowledge models heavily rely on modelling notations used in software engineering; in this the UML is widely adopted. UML can be formally tailored for knowledge modelling by creating a UML profile for knowledge modelling", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Designing a domain-specific contract language: A metamodelling approach\n", "abstract": " Domain-specific languages are of increasing importance in software engineering. Little attention has been paid to the systematic production of domain-specific contract languages (DSCLs). In this paper, we present a metamodel-based approach for designing DSCLs. An extensible metamodel for software contracts is presented, and a process for building DSCLs is sketched. Finally, an example of building a DSCL is demonstrated, using the metamodel and process.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Conceptual Modelling of Knowledge-Based Systems Using UML\n", "abstract": " Conceptual modelling is an important aspect in designing systems. However, the use of conceptual models in knowledge-based system (KBS) is limited as there is no particular consensus on which modelling language should be used and most of these systems are developed in a\u2019 problem to code\u2019 manner. This paper focuses on the use of a Unified Modeling Language (UML) Profile for conceptual knowledge modelling. The profile is created using the profile extension approach of UML and is based on the XMF (executable Modelling Framework). An example of modelling a KBS based on the Ottawa Ankle Rule demonstrates the use of the profile.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Designing Knowledge-Based Systems Using UML Profile (Metamodel Based Extension)\n", "abstract": " Knowledge engineers have favoured a diagrammatic approach for developing knowledge-based systems by adopting those used in software engineering. However, these modelling techniques tend to be used in an ad hoc way and are highly dependent on the modelling experience of the engineers involved. This paper focuses on the use of the Unified Modeling Language (UML) Profiles for knowledge modelling. It identifies the short-comings of current approaches in adopting UML and proposes an extension to UML through the profile mechanism (metamodel extension) based on the eXecutable Modelling Framework (XMF). An abstract syntax model of the UML profile for knowledge modelling is also presented.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Agile development of a metamodel in eiffel\n", "abstract": " A metamodel defines the well-formedness rules for a modelling language such as UML. We outline how an executable metamodel was designed and implemented using an agile method based on test-driven development that aimed at achieving high reliability. The test-driven approach was augmented with design-by-contract techniques to increase the likelihood of obtaining a correct, robust implementation.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Extending the message flow debugger for MQSI.\n", "abstract": " Integration and management of applications play key roles in today\u2019s computing. MQSeries is an asynchronous, assured application-to-application communication protocol designed to support the integration of business processes. MQSeries Integrator (MQSI) is a component of MQSeries providing support for application integration and communication. The key technology in MQSI is the notion of a message flow. A message flow is a sequence of operations on a message, performed by a series of message processing nodes. A message flow developer creates a message flow by including processing nodes and connectors between them. Errors in the development of large and complex message flows are unavoidable, hence the need for a message flow debugger. A prototype debugger for message flows was developed at IBM Research Lab in Haifa. In this paper, techniques are presented that extend the prototype debugger to deal with multithreaded and nested message flows. In addition, we discuss how the performance of the debugger can be improved to meet production standards.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Using an Object-Oriented Predicative Style to Solve the Invoicing Problem\n", "abstract": " We apply the predicative programming formal method of [2] in specifying and designing a solution to the invoicing case study. The method is used in an object-oriented style: first-class citizens of the descriptions are classes and objects. We discuss some of the advantages to using the predicative method in its object-oriented style, as well as its limitations in this problem domain.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Heterogeneous Notations for Formal Method Integration\n", "abstract": " We describe an approach for de ning and making use of compositions of partial speci cations written in di erent formal languages. The technique provides a rst step towards integrating formal methods that use the notations. We discuss the integration process and consider how re nement can occur in such a setting. We present several examples of formal heterogeneous speci cations, and two examples of integrated formal method usage based on such an idea.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Heterogeneous specifications and their application to software development\n", "abstract": " We describe a course of research examining formal and semiformal heterogeneous specifications, ie, compositions of partial specifications written in different textual and visual notations. We describe why we believe this to be an interesting topic for further inquiry, and suggest why such specifications might prove beneficial for use in software development.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Correctness and Performance Analysis of Imperative and Functional Circuits\n", "abstract": " With computer circuit designs reaching new pinnacles in complexity, it is becoming increasingly apparent that there is a need to abstract some or all of the circuit design process to a higher level. This would have the effect of removing many of the trivial details of circuit construction from the designer\u2019s consideration. A specification for a circuit could thus be written in a programming language, and through semantics-preserving transformations, circuits could be compiled from their high-level descriptions. We consider different techniques that perform this so-called silicon compilation, examining methods that produce both clocked and asynchronous circuits. Two new simple approaches, that generate the so-called imperative and functional circuits, are presented, along with a proof of their correctness. Techniques for estimating the size and performance of the circuits these methods produce are considered as well, as are quantitative comparisons with circuits synthesized by compilation strategies that have been presented in the literature.", "num_citations": "2\n", "authors": ["1610"]}
{"title": "Distributed model validation with Epsilon\n", "abstract": " Scalable performance is a major challenge with current model management tools. As the size and complexity of models and model management programs increases and the cost of computing falls, one solution for improving performance of model management programs is to perform computations on multiple computers. In this paper, we demonstrate a low-overhead data-parallel approach for distributed model validation in the context of an OCL-like language. Our approach minimises communication costs by exploiting the deterministic structure of programs and can take advantage of multiple cores on each (heterogeneous) machine with highly configurable computational granularity. Our performance evaluation shows that the implementation is extremely low overhead, achieving a speed up of 24.5 with 26 computers over the sequential case, and 122 when utilising all six cores on each computer.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "On-the-fly Translation and Execution of OCL-like Queries on Simulink Models\n", "abstract": " MATLAB/Simulink is a tool for dynamic system modelling. Model management languages such as OCL, ATL and the languages of the Epsilon platform tend to focus on the Eclipse Modelling Framework (EMF), a de facto standard for domain specific modelling. As Simulink models are built on an entirely different technical stack, the current solution to manipulate them using such languages requires their transformation into an EMF-compatible representation. This approach is expensive as the cost of the transformation can be crippling for large models, it requires the synchronisation of the native Simulink model and its EMF counterpart, and the EMF-representation may be an incomplete copy of the model. In this paper we propose an alternative approach that uses the MATLAB API to bridge Simulink models with existing model management languages that relies on the \u201con-the-fly\u201d translation of model management language constructs into MATLAB commands. Our approach eliminates the cost of the transformation and of the co-evolution of the EMF-compatible representation while enabling full access to the Simulink model details. We evaluate the performance of both approaches using a set of model validation constraints executed on a sample of the largest Simulink models available on GitHub. Our evaluation suggests that the translation approach can reduce the model validation time up to 80%.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Dependent input sampling strategies: using metaheuristics for generating parameterised random sampling regimes\n", "abstract": " Understanding extreme execution times is of great importance in gaining assurance in real-time embedded systems. The standard benchmark for dynamic testing---uniform randomised testing---is inadequate for reaching extreme execution times in these systems. Metaheuristics have been shown to be an effective means of directly searching for inputs with such behaviours but the increasing complexity of modern systems is now posing challenges to the effectiveness of this approach. The research reported in this paper investigates the use of metaheuristic search to discover biased random sampling regimes. Rather than search for test inputs, we search for distributions of test inputs that are then sampled. The search proceeds to discover and exploit relationships between test input variables, leading to sampling regimes where the distribution of a sampled parameter depends on the values of previously sampled\u00a0\u2026", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Search-based temporal testing in an embedded multicore platform\n", "abstract": " Multicore processors have now become the norm. However, for many embedded real-time systems their use introduces challenges in verification as their shared components are potential channels for interference. Of particular interest is the determination for each task of its worst case (longest) execution time (WCET). In this paper, we investigate the effectiveness of a variety of metaheuristic search algorithms for dynamically finding extreme execution times of tasks executing on a multicore processor. Over finite search spaces, these are shown to perform considerably better than randomly generated test inputs and the work reveals significant performance differences between the various algorithms.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Parallel execution of first-order operations.\n", "abstract": " The growing size of software models poses significant scalability challenges. Amongst these scalability issues is the execution time of queries and transformations. Although the processing pipeline for models may involve numerous stages such as validation, transformation and code generation, many of these complex processes are (or can be) expressed by a combination of simpler and more fundamental operations. In many cases, these underlying operations are pure functions, making them amenable to parallelisation. We present parallel execution algorithms for a range of iteration-based operations in the context of the OCL-inspired Epsilon Object Language. Our experiments show a significant improvement in the performance of queries on large models.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "SECT-AIR: Software Engineering Costs and Timescales\u2013Aerospace Initiative for Reduction\n", "abstract": " Software is critical to the majority of functionality in avionics and aerospace systems. The amount of safety-related software in avionics is growing rapidly (doubling in size around every four years), and the costs of software programmes in industry are increasingly unaffordable \u2013 safety-related code can cost upwards of USD $150 per line. At the same time, demands from avionics customers for increased scope and new functionality is increasing, and quality is non-negotiable: it is fixed by standards and safety requirements. The SECT-AIR project is addressing these cost and demand issues by focusing on automation in software engineering, with particular emphasis on model-based development. In this paper we provide an overview of the motivation behind the project, which started in 2016, and some of the key tasks it will carry out to help improve productivity, increase customer scope and maintain quality.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Language engineering: Challenges, opportunities and potential disasters for interactive systems\n", "abstract": " Language engineering underpins model-driven engineering and the application of domain-specific languages. In this talk, I will introduce language engineering and its principles and practices, using model-driven engineering as an exemplar. I will suggest how the engineering of interactive systems offers opportunities, challenges and the potential for chaos for language engineering.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "The value of user-visible internet cryptography\n", "abstract": " Cryptographic mechanisms are used in a wide range of applications, including email clients, web browsers, document and asset management systems, where typical users are not cryptography experts. A number of empirical studies have demonstrated that explicit, user-visible cryptographic mechanisms are not widely used by non-expert users, and as a result arguments have been made that cryptographic mechanisms need to be better hidden or embedded in end-user processes and tools. Other mechanisms, such as HTTPS, have cryptography built-in and only become visible to the user when a dialogue appears due to a (potential) problem. This paper surveys deployed and potential technologies in use, examines the social and legal context of broad classes of users, and from there, assesses the value and issues for those users.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Guest editorial to the special issue on model transformation\n", "abstract": " Models are widespread in systems engineering, and provide a mechanism for managing and controlling complexity when developing large-scale complex IT systems. Models help engineers capture essential information at a suitable level of abstraction, and reason about that information in precise ways. Models are at the heart of model-driven approaches to systems engineering. A key operation in model-driven engineering is model transformation, which is the practice of defining and implementing operations on models. Model transformations refine and/or evolve a model into a different artefact: a new model (eg, expressed in a different language), an abstraction of the original model, text (eg, source code), or some other representation needed for a specific domain context.Model transformation approaches are becoming mainstream in model-driven engineering: there are now numerous model transformation languages and tools that allow the specification, implementation, orchestration and execution of transformations, applied to different languages and on different platforms. The research field is extremely active, with substantial research efforts in understanding the advantages and disadvantages of different approaches to model transformation, foundational principles, semantics of transformation languages, and model transformation properties like modularity and composability. There is also substantial interest in treatment of model transformations as reusable assets\u2014", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Approaches to modelling security scenarios with domain-specific languages\n", "abstract": " Many security scenarios involve both network and cryptographic protocols and the interactions of different human participants in a real-world environment. Modelling these scenarios is complex, in part due to the imprecision and under-specification of the tasks and properties involved. We present work-in-progress on a domain-specific modelling approach for such scenarios; the approach is intended to support coarse-grained state exploration, and incorporates a classification of elements complementary to computer protocols, such as the creation, personalisation, modification and transport of identity tokens. We propose the construction of a domain-specific language for capturing these elements, which will in turn support domain-specific analyses related to the reliability and modifiability of said scenarios.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Value-Based Software Traceability Workshop (VALSOT 2011)\n", "abstract": " Traceability defines and maintains relationships among the artifacts involved in the software-engineering life cycle. This mechanism is widely used for purposes as project visibility and accountability, and it provides an essential support for developing high-quality software systems. Traceability has traditionally been strongly influenced by software process drivers; however, during the last few years, the software process is starting to take into account new drivers.One such driver is the software product\u2019s value. The global value of a product can be understood as the perceived benefits in relation to its cost. Both business and technical areas of an organization consider the value concept as a priority, for analyzing software costs and benefits. For these purposes, a tight interaction between these two sides is fundamental.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Model-based failure analysis of business process\n", "abstract": " The success of most organisations are based on how well the organisation can engineer and execute their business processes in order to better manage the extra value that these processes can provide. However, business processes may fail to deliver the functions which are designed. In order to help the understanding of how and why a business process may fail, we considered the techniques in system safety engineering and integrated them with existing techniques of business process modelling and analysis. We proposed a framework of business process failure analysis. The kernel of the framework is that we extended the workflow net of a business process by modelling failures as coloured tokens and so that the failure behaviours of the business process can be simulated. In addition, we developed a tool based on the codes of an open source project to support the analysis. The applications of proposed technique have demonstrated that it is a powerful and easy-to-use technique for the management of business processes in large complex enterprise systems.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Hello World with Epsilon\n", "abstract": " Epsilon is an extensible platform of integrated and taskspecific languages for model management. With solutions to the 2011 TTC Hello World case, this paper demonstrates some of the key features of the Epsilon Object Language (an extension and reworking of OCL), which is at the core of Epsilon. In addition, the paper introduces several of the task-specific languages provided by Epsilon including the Epsilon Generation Language (for model-to-text transformation), the Epsilon Validation Language (for model validation) and Epsilon Flock (for model migration).", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Model\u2010driven software development. By Thomas Stahl and Markus Volter. Published by John Wiley & Sons, New York, 2006. ISBN: 0470025700, 444 pages. Price\u00a3 33.99. Soft Cover\n", "abstract": " Model-driven software development (MDSD) is a class of approaches to building software systems that rely on the use of so-called models, ie descriptions of interesting characteristics of systems. MDSD has become increasingly popular and widespread with the ascendance of the Unified Modelling Language (UML) as the de facto standard modelling language. There are a variety of different approaches to MDSD, including the Object Management Group\u2019s Model-Driven Architecture (MDA), which supports a particular kind of model (those written in languages that conform to the OMG\u2019s MOF standard), a particular approach to using models (via transformation), and a specific reliance on standards (such as MOF, UML, and XMI).This book gives a thorough and general overview of MDSD, including an introduction to MDA, and covering the full process, from modelling through to implementation of models. It aims to\u00a0\u2026", "num_citations": "1\n", "authors": ["1610"]}
{"title": "08331 Abstracts Collection--Perspectives Workshop: Model Engineering of Complex Systems (MECS)\n", "abstract": " From 10.08. to 13.08. 2008, the Dagstuhl Seminar 08331``Perspectives Workshop: Model Engineering of Complex Systems (MECS)''was held in the International Conference and Research Center (IBFI), Schloss Dagstuhl. During the seminar, several participants presented their current research, and ongoing work and open problems were discussed. Abstracts of the presentations given during the seminar as well as abstracts of seminar results and ideas are put together in this paper. The first section describes the seminar topics and goals in general. Links to extended abstracts or full papers are provided, if available.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "ECMDA Traceability Workshop Proceedings 2007\n", "abstract": " This report contains the proceedings of the Third ECMDA Traceability Workshop, arrangedin Haifa, Israel 2007 together with ECMDA 2007 conference. The papers within targetvarious aspects of traceability in model-driven development.\u00a0  Oppdragsgiver: ECMDA Traceability Workshop", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Knowledge modelling using uml profile for knowledge-based systems development\n", "abstract": " Knowledge modelling techniques are widely adopted for designing knowledge-based systems (KBS) used for managing knowledge. This chapter discusses conceptual modelling of KBS in the context of model-driven engineering using standardised conceptual modeling language. An extension to the Unified Modeling Language (UML) for knowledge modelling is presented based on the profiling extension mechanism of UML. The UML profile discussed in this chapter has been successfully captured in a Meta-Object-Facility (MOF) based UML tool\u2013the eXecutable Modelling Framework (XMF) Mosaic. The Ulcer Clinical Practical Guidelines (CPG) Recommendations case study demonstrates the use of the profile, with the prototype system implemented in the Java Expert System Shell (JESS).", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Adding an Action Semantics to MOF 2.0\n", "abstract": " We show how to extend MOF 2.0 to include an action semantics to support behavioural modelling. We illustrate why such an extension is useful, particularly for model transformation and consistency checking.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Checking the Consistency of Views using PVS\n", "abstract": " A method, based on BON [17], for building reliable object-oriented software systems was proposed in [14]. It combined use of modelling and Extreme Programming [1](XP) practices, emphasizing the use of a limited set of views of a software system, with consistency rules and automatic generation tools defined between the views. This paper builds upon this framework and formally specifies the consistency constraints between the two BON views: the static view provided by class diagrams, and the dynamic view provided by collaboration diagrams. The constraints are specified as an extension of the BON metamodel from [12], and are implemented in PVS. They ensure that the sequence of messages appearing in the dynamic view are permitted, given the contracts appearing in the static view. A sketch of how the constraints might be implemented in a BON CASE tool is also provided.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "The Single Model Principle\n", "abstract": " Modelling languages such as UML are increasingly used to describe software systems at different levels of abstraction. There are two very different ways of using such languages. One approach is based on the manifestation of a single model, with construction of different views from this model, and with automatic or semi-automatic consistency checking among these views. This follows what we term the single model principle. The second approach (of which the use of unrestricted UML is an example) is based on the independent construction of multiple models of the same system, but with no guarantee of the consistency of the various models. We propose that to best support seamless, reversible software development of reliable software, it is preferable to follow the single model principle for a specific subset of development tasks. We describe the single model principle and its supporting infrastructure. We show how the BON/Eiffel description language, which supports both high-level abstract specifications as well as code implementations, can be enhanced to satisfy the essential tenets of the single model principle, both for static and dynamic descriptions. We describe how a UML profile (including the use of Java) might be expanded to provide weak support for the principle. We also consider situations and tasks when following the principle is insufficient, particularly when capturing early (goal-oriented) requirements.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "The Timed Predicative Calculus as a Framework for Comparative Semantics\n", "abstract": " Predicates are used in a variety of formal specification languages, though a predicate does not always mean the same thing in each approach. For example, the predicate false in Z means the same thing as true in the predicative calculus of Hehner. In this paper, we compare the specification languages Z, Morgan\u2019s Refinement Calculus, and Parnas\u2019s Limited Domain relations, using the timed predicative calculus (TP) of Hehner as an underlying framework. In particular, we show that TP is more expressive than the other languages. We also show that refinement in TP is strictly weaker than the refinement relations associated with the other languages. As a result, refinement laws from the other languages can be reused in TP. We conject that the simplicity of TP makes it a good candidate as a specification language and program development method for the refinement of procedural specifications, as well as real-time object oriented specifications.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "From Z to BON/Ei el\n", "abstract": " It is shown how to make a transition from the formal specification notation Z [10] to the Business Object Notation (BON)[11], so as to be able to relate the former notation with object-oriented specifications and implementations. The transition is applied in a case study that shows how to move from Z to BON, and finally through to executable Eiffel programs. The translation lays the groundwork for a semi-automated tool that spans the semantic gap from abstract Z specifications to concrete Eiffel implementations.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Using Heterogeneous Notations to Integrate a Formal and Object-Oriented Method\n", "abstract": " We combine a formal speci cation technique with an object-oriented method using a meta-method for formal method integration based on heterogeneous notations 18, 19]. We discuss the integrated method, and then apply it to an example.", "num_citations": "1\n", "authors": ["1610"]}
{"title": "Heterogeneous Specifications and their Application to Software Development A Research Proposal\n", "abstract": " We describe a course of research examining formal and semiformal heterogeneous speci cations, ie, compositions of partial speci cations written in di erent textual and visual notations. We describe why we believe this to be an interesting topic for further inquiry, and suggest why such speci cations might prove bene cial for use in software development.", "num_citations": "1\n", "authors": ["1610"]}