{"title": "To unify or not to unify: a case study on unified builds (in WebKit)\n", "abstract": " Unified builds are a simple but effective technique to reduce the build time of large software projects. Unified builds generate large compiler tasks by bundling multiple source files into one, resulting in a significant reduction in build time through removal of redundant work incurred by shared headers. However, unified builds have a negative effect on incremental builds because each compiler task gets larger. An ad-hoc unification strategy causes an excessive slowdown in incremental builds. A rough report from WebKit says the worst slowdown is 20%(6s\u2192 7s), but our investigation shows it is as high as 479%(19s\u2192 110s).", "num_citations": "2\n", "authors": ["1127"]}
{"title": "Native Build System for Unity Builds with Sophisticated Bundle Strategies\n", "abstract": " Build systems are essential tools for developing large software projects. Traditionally, build systems have been designed for high incremental-build performance. However, the longer build times of recent large C++ projects have imposed a requirement on build systems: i.e., unity builds. Unity builds are a build technique for speeding up sequential compilation of many source files by bundling multiple source files into one. Unity builds lead to a significant reduction in build time through removal of redundant parsing of shared header files. However, unity builds have a negative effect on incremental builds because each compiler task gets larger. Our previous study reported existing unity builds overlook many better bundle configurations that improve unity-build performance without increasing the incremental-build time. Motivated by the problem, we present a novel build system for better performance in unity builds\u00a0\u2026", "num_citations": "1\n", "authors": ["1127"]}
{"title": "Detecting and analyzing year 2038 problem bugs in user-level applications\n", "abstract": " The year 2038 problem is a well-known year problem that might cause severe damage to many existing software systems. However, no current tool can detect the bugs since it requires the understandings of the problem unique encoding semantics. In this paper, we analyze real-world applications and raise the alarm over the fact that the Year 2038 problem is a real threat. We target all of the C based projects uploaded on GitHub in the years 2012 to 2018 (32,921 in total), between the dates July 1 to July 10. Our analysis shows that 7.35% of the compiled projects have bugs. Some of the bugs trigger undefined behavior and are dangerous enough to crash the software systems. Our bug fixing patches sent to six projects have been confirmed and approved, including large-scale, real-world projects such as the Amazon Web Service support tools and the Linux Test Project.", "num_citations": "1\n", "authors": ["1127"]}
{"title": "Short-liveness of error propagation in kernel can improve operating systems availability\n", "abstract": " The reliability of operating systems is crucial to achieving high availability of computer systems. Unfortunately, Linux, a widely used operating system, is far from bug-free. Some recent studies point out error propagation is very short in the kernel and thus most data in the kernel are not corrupt even when a failure occurs. This paper explores the possibility of exploiting the property of \"short-liveness\" of error propagation in the kernel to improve the operating system availability. Our novel design of the memory management scheme allows us to recover the kernel by removing inconsistent data structures corrupted during error propagations.", "num_citations": "1\n", "authors": ["1127"]}