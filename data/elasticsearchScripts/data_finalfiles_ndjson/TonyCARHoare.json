{"title": "Communicating sequential processes\n", "abstract": " Among the primitive concepts of computer programming, and of the high level lan guages in which programs are expressed, the action of assignment is familiar and well understood. In fact, any change of the internal state of a machine executing a program can be modeled as an assignment of a new value to some variable part of that machine. However, the operations of input and output, which affect the exter nal environment of a machine, are not nearly so well understood. They are often added to a programming language only as an afterthought. Among the structuring methods for computer programs, three basic constructs have received widespread recognition and use: A repetitive construct (eg the while loop), an alternative construct (eg the conditional if.. then.. else), and normal se quential program composition (often denoted by a semicolon). Less agreement has been reached about the design of other\u00a0\u2026", "num_citations": "14482\n", "authors": ["1572"]}
{"title": "An axiomatic basis for computer programming\n", "abstract": " In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.", "num_citations": "8587\n", "authors": ["1572"]}
{"title": "Communicating sequential processes\n", "abstract": " This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.", "num_citations": "8423\n", "authors": ["1572"]}
{"title": "Monitors: An operating system structuring concept\n", "abstract": " This paper develops Brinch Hansen\u2019s concept of a monitor as a method of structuring an operating system. It introduces a form of synchronization, describes a possible method of implementation in terms of semaphores and gives a suitable proof rule. Illustrative examples include a single resource scheduler, a bounded buffer, an alarm clock, a buffer pool, a disk head optimizer, and a version of the problem of readers and writers.", "num_citations": "2645\n", "authors": ["1572"]}
{"title": "Structured programming\n", "abstract": " In recent years there has been an increasing interest in the art of computer programming, the conceptual tools available for the design of programs, and the prevention of programming oversights and error. The initial outstanding contribution to our understanding of this subject was made by E. W. Dijkstra, whose Notes on Structured Programming form the first and major section of this book. They clearly expound the reflections of a brilliant programmer on the methods which he has hitherto unconsciously applied; there can be no programmer of the present day who could not increase his skills by a study and conscious application of these principles. In the second monograph I have tried to describe how similar principles can be applied in the design of data structures. I have suggested that in analysing a problem and groping towards a solution, a programmer should take advantage of abstract concepts such as sets\u00a0\u2026", "num_citations": "2436\n", "authors": ["1572"]}
{"title": "Proof of correctness of data representations\n", "abstract": " A powerful method of simplifying the proofs of program correctness is suggested; and some new light is shed on the problem of functions with side-effects.", "num_citations": "1704\n", "authors": ["1572"]}
{"title": "Quicksort\n", "abstract": " A description is given of a new method of sorting in the random-access store of a computer. The method compares very favourably with other known methods in speed, in economy of storage, and in ease of programming. Certain refinements of the method, which may be useful in the optimization of inner loops, are described in the second part of the paper.", "num_citations": "1604\n", "authors": ["1572"]}
{"title": "Unifying theories of programming\n", "abstract": " A theory of programming explores the principles that underlie the successful practice of software engineering. As in all branches of engineering, the practice comes first, both in importance and in historical order. The rapidly spreading benefits of computer application in modern society are largely due to the efforts and intuitive genius of teams of programmers, who have gained their skills and understanding the hard way, by long practice and experience. But now there is another complementary way for practising software engineers. A study of the relevant scientific theory can enhance their skills, broaden their range, deepen their understanding and strengthen their confidence in the accuracy and reliability of their designs and products. Understanding of a common theory enables experience gained in one language or application to be generalised rapidly to new applications and to new developments in technology or fashion; and it is the theory that maintains the intellectual interest of professional activity throughout a lifetime of achievement. But best of all, development of a comprehensive and comprehensible theory encapsulates the best of the state of the art in the subject, and makes it more readily available to the next generation of entrants to the profession.The key to further progress is education; that is the goal of this book. It aims to attract and inform a class of student who are committed to practical engineering ideals, and who wish to devote their efforts to study of the relevant scientific foundation. They will probably have exposure already to one or more programming languages, and expect to meet more in their professional careers. An\u00a0\u2026", "num_citations": "1329\n", "authors": ["1572"]}
{"title": "A calculus of durations\n", "abstract": " The purpose of the calculus of durations is to reason about designs and requirements for time-critical systems, without explicit mention of absolute time. Its distinctive feature is reasoning about integrals of the durations of different states within any given interval. The first section introduces the running example, of leakage in a gas burner. The second section defines and axiomatises the proposed calculus as an extension of interval temporal logic. The third section applies it to the problem described in the introduction. The fourth section briefly surveys alternative calculi.", "num_citations": "1185\n", "authors": ["1572"]}
{"title": "An axiomatic definition of the programming language PASCAL\n", "abstract": " The axiomatic definition method proposed in reference [5] is extended and applied to define the meaning of the programming language PASCAL [1]. The whole language is covered with the exception of real arithmetic and go to statements.", "num_citations": "657\n", "authors": ["1572"]}
{"title": "Algorithm 65: find\n", "abstract": " ec) mment This procedure places a set of values of QnIn (x) in the array Q [] for values of n from 0 to nmax for a particular value of m and a value of x which is real if ri is 0 and is purely imaginary, ix, ortherwise. R [] will contain the set of ratios of successive values of Q. These ratios may be especially valuable when the Q,~\"~(x) of the smallest size is so small as to underflow the machine representation (eg 10-6~ if 10-~ 1 were the smallest representable", "num_citations": "561\n", "authors": ["1572"]}
{"title": "Towards a theory of parallel programming\n", "abstract": " The objectives in the construction of a theory of parallel programming as a basis for a high-level programming language feature are:                                     1.                                         Security from error. In many of the applications of parallel programming the cost of programming error is very high, often inhibiting the use of computers in environments for which they would otherwise be highly suitable. Parallel programs are particularly prone to time-dependent errors, which either cannot be detected by program testing nor by run-time checks. It is therefore very important that a high-level language designed for this purpose should provide complete security against time-dependent errors by means of a compile-time check.                                                                        2.                                         Efficiency. The spread of real-time computer applications is severely limited by computing costs; and in particular by the cost of main\u00a0\u2026", "num_citations": "544\n", "authors": ["1572"]}
{"title": "Algorithm 64: quicksort\n", "abstract": " Director of Research, Palo Alto Unified School District, Palo Alto, California procedure Invrs (t) size:(n); value n; real array t~ integer n; comment Inverts a positive definite symmetric matrix t, of order n, by a simplified variant of the square root method. Replaces the n (n-4-1)/2 diagonal and superdiagonal elements of t with elements of t-~, leaving subdiagonal elements unchanged. Advantages: only n temporary storage registers are required, no identity matrix is used, no square roots are computed, only n divisions are performed, and, as n becomes large, the number of multiplications approaches n3/2; begin integer i, j, s; real array v [l: n--1]; real y, pivot; for s:= 0 step 1 until n-1 do begin pivot:= 1.0/t [1, 1]; begin pivot:= 1.0/t [1, 1]; comment If t [1, 1]~ 0, t is not positive definite; for i:= 2 step 1 until n do vii-l]:= t [1, i]; for i:= 1 step 1 until n--1 do begin t [i, n]:= y:=--v [i] X pivot; for j:= i step 1 until n--1 do t [i, jl:= t [i-4-1, j-4-11-4-vii\u00a0\u2026", "num_citations": "474\n", "authors": ["1572"]}
{"title": "The verifying compiler: A grand challenge for computing research\n", "abstract": " I propose a set of criteria which distinguish a grand challenge in science or engineering from the many other kinds of short-term or long-term research problems that engage the interest of scientists and engineers. As an example drawn from Computer Science, I revive an old challenge: the construction and application of a verifying compiler that guarantees correctness of a program before running it.", "num_citations": "462\n", "authors": ["1572"]}
{"title": "The emperor's old clothes\n", "abstract": " Professor Hoare was selected by the General Technical Achievement Award Committee for his fundamental contributions to the definition and design of programming languages. His work is characterized by an unusual combination of insight, originality, elegance, and impact. He is best known for his work on axiomatic definitions of programming languages through the use of techniques popularly referred to as axiomatic semantics. He developed ingenious algorithms such as Quicksort and was responsible for inventing and promulgating advanced data structuring techniques in scientific programming languages. He has also made important contributions to operating systems through the study of monitors. His most recent work is on communicating sequential processes. CAR I-Ioare Prior to his appointment to the University of Oxford in 1977, Professor Hoare was Professor of Computer Science at The Queen's\u00a0\u2026", "num_citations": "437\n", "authors": ["1572"]}
{"title": "Procedures and parameters: An axiomatic approach\n", "abstract": " It has been suggested, Hoare (1969), that an axiomatic approach to formal language definition might simultaneously contribute to the clarity and reliability of programs expressed in the and execution on an electronic and to the efficiency of their translation computer. This paper gives an example of the application of the axiomatic method to the definition of procedure and parameter passing features of a high-level programming language. It reveals that ease of demonstrating program correctness and high efficiency of implementation may be achieved simultaneously, provided that the programmer is willing to observe a certain familiar and natural discipline in his use of parameters.", "num_citations": "432\n", "authors": ["1572"]}
{"title": "Specification-oriented semantics for communicating processes\n", "abstract": " A process P satisfies a specification S if every observation we can make of the behaviour of P is allowed by S. We use this idea of process correctness as a starting point for developing a specific form of denotational semantics for processes, called here specification \u2014 oriented semantics. This approach serves as a uniform framework for generating and relating a series of increasingly sophisticated denotational models for Communicating Processes.               These models differ in the underlying structure of their observations which influences both the number of representable language operators and the induced notion of process correctness. Safety properties are treated by all models; the more sophisticated models also permit proofs of certain liveness properties. An important feature of the models is a special hiding operator which abstracts from internal process activity. This allows large processes to be\u00a0\u2026", "num_citations": "395\n", "authors": ["1572"]}
{"title": "Chapter II: Notes on data structuring\n", "abstract": " In the development of our understanding of complex phenomena, the most powerful tool available to the human intellect: is abstraction. Abstraction arises from a recognition of similarities between certain objects, situations, or processes in the real world, and the decision to concentrate on these similarities, and to ignore for the time being the differences. As soon as we have discovered which similarities are relevant to the prediction and control of future events, we will tend to regard the similarities as fundamental and the differences as trivial. We may then be said to have developed an abstract concept to cover the set of objects or situations in question. At this stage, we will usually introduce a word or picture to symbolise the abstract concept; and any particular spoken or written occurrence of the word or picture may be used to represent a particular or general instance of the corresponding situation.The primary use for representations is to convey information about important aspects of the real world to others, and to record this information in written form, partly as an aid to memory and partly to pass it on to future generations. However, in primitive societies the representations were sometimes believed to be useful in their own right, because it was supposed that manipulation of representations might in itself cause corresponding changes in the real world; and thus we hear of such practices as sticking pins into wax models of enemies in order to cause pain to the corresponding part of the real person. This type of activity is characteristic of magic and witchcraft. The modern scientist on the other hand, believes that the manipulation of representations\u00a0\u2026", "num_citations": "387\n", "authors": ["1572"]}
{"title": "Hints on programming language design\n", "abstract": " The paper presents the view that a programming language is a tool which should assist the programmer in the most difficult aspects of his art, namely program design, documentation, and debugging. It discusses the objective criteria for evaluating a language design, and illustrates them by application to language features of both high level languages and machine code programming. It concludes with an annotated reading list, recommended for all intending language designers.Descriptors:", "num_citations": "382\n", "authors": ["1572"]}
{"title": "Proof of a program: FIND\n", "abstract": " A proof is given of the correctness of the algorithm \u201cFind.\u201d First, an informal description is given of the purpose of the program and the method used. A systematic technique is described for constructing the program proof during the process of coding it, in such a way as to prevent the intrusion of logical errors. The proof of termination is treated as a separate exercise. Finally, some conclusions relating to general programming methodology are drawn.", "num_citations": "329\n", "authors": ["1572"]}
{"title": "Chapter III: Hierarchical program structures\n", "abstract": " In this monograph we shall explore certain ways of program structuring and point out their relationship to concept modelling. We shall make use of the programming language SIMULA 67 with particular emphasis on structuring mechanisms. SIMULA 67 is based on ALGOL 60 and contains a slightly restricted and modified version of ALGOL 60 as a subset. Additional language features are motivated and explained informally when introduced. The student should have a good knowledge of ALGOL 60 and preferably be acquainted with list processing techniques.For a full exposition of the SIMULA language we refer to the\" Simula 67 Common Base Language\"[2]. Some of the linguistic mechanisms introduced in the monograph are currently outside the\" Common Base\"*. The monograph is an extension and reworking of a series of lectures given by Dahl at the NATO Summer School on Programming, Marktoberdorf 1970. Some of the added material is based on programming examples that have occurred elsewhere [3, 4, 5].", "num_citations": "291\n", "authors": ["1572"]}
{"title": "Playing by the rules: rewriting as a practical optimisation technique in GHC\n", "abstract": " We describe a facility for improving optimization of Haskell programs using rewrite rules. Library authors can use rules to express domain-specific optimizations that the compiler cannot discover for itself. The compiler can also generate rules internally to propagate information obtained from automated analyses. The rewrite mechanism is fully implemented in the released Glasgow Haskell Compiler.", "num_citations": "274\n", "authors": ["1572"]}
{"title": "A contribution to the development of ALGOL\n", "abstract": " A programming language similar in many respects to ALGOL 60, but incorporating a large number of improvements based on six years' experience with that language, is described in detail. Part I consists of an introduction to the new language and a summary of the changes made to ALGOL 60, together with a discussion of the motives behind the revisions. Part II is a rigorous definition of the proposed language. Part III describes a set of proposed standard procedures to be used with the language, including facilities for input/output.", "num_citations": "272\n", "authors": ["1572"]}
{"title": "Data refinement refined resume\n", "abstract": " We consider the original work of Hoare and Jones on data refinement in the light of Dijkstra and Smyth's treatment of nondeterminism and of Milner and Park's definition of the simulation of Communicating Systems. Two proof methods are suggested which we hope are simpler and more general than those in current use. They are proved to be individually sufficient for the correctness of refinement and together necessary for it. The proof methods can be employed to derive the weakest specification of an implementation from its abstract specification.", "num_citations": "269\n", "authors": ["1572"]}
{"title": "Recursive data structures\n", "abstract": " The power and convenience of a programming language may be enhanced for certain applications by permitting treelike data structures to be defined by recursion. This paper suggests a pleasing notation by which such structures can be declared and processed; it gives the axioms which specify their properties, and suggests an efficient implementation method. It shows how a recursive data structure may be used to represent another data type, for example, a set. It then discusses two ways in which significant gains in efficiency can be made by selective updating of structures, and gives the relevant proof rules and hints for implementation. The examples show that a certain range of applications in symbol manipulation can be efficiently programmed without introducing the low-level concept of a reference into a high-level programming language.", "num_citations": "238\n", "authors": ["1572"]}
{"title": "A model for communicating sequential process\n", "abstract": " The primary objective of this paper Is to give a simple mathematical model for communicating sequential processes. The model is Illustrated in a wide range of familiar programming exercises, including an operating system and a simulation study. As the exposition unfolds J the examples begin to look 1ike programs, and the notations begin to look like a programming language. Thus the design of a language seems to emerge naturally from its formal definition J in an intel1ectual1y pleasing fashion. The model is not intended to deal with certain problems of nondeterminism. These have been avoided by observance of certain restrictions detailed in the appendix. No attention has been paid to problems of efficient implementation; for this J even further restrictions should be imposed. The long term objective of this study is to provide a basis for the proof of correctness of programs expressed as communicating sequential processes. However, in this paper the formalities have been kept to a minimum and no proofs are given.", "num_citations": "221\n", "authors": ["1572"]}
{"title": "Consistent and complementary formal theories of the semantics of programming languages\n", "abstract": " This paper presents a comparative study of different methods for formal description of programming languages. These methods have been applied to a simple but realistically usable programming language; the more abstract definitions have been proved to be consistent relative to the more concrete ones.", "num_citations": "191\n", "authors": ["1572"]}
{"title": "Ambiguities and insecurities in Pascal\n", "abstract": " Ambiguities and insecurities in the programming language Pascal are discussed.", "num_citations": "174\n", "authors": ["1572"]}
{"title": "Program proving: Jumps and functions\n", "abstract": " Proof methods adequate for a wide range of computer programs have been expounded in [1] and [2]. This paper develops a method suitable for programs containing functions, and a certain kind Of jump. The method is illustrated by the proof of a useful and efficient program for table lookup by logarithmic search.", "num_citations": "167\n", "authors": ["1572"]}
{"title": "The weakest prespecification, Part I\n", "abstract": " For, aside from the fact that the concepts occurring in this calculus possess an objective importance a nd are in these times almost indispensable in any scientific discussion, the calculus of relations has an intrinsic charm and beauty which makes it a source of intellectual delight to all who become acquainted with it. ALFRED TARSKI [10]", "num_citations": "165\n", "authors": ["1572"]}
{"title": "Provably correct systems\n", "abstract": " The goal of the Provably Correct Systems project (ProCoS) is to develop a mathematical basis for development of embedded, real-time, computer systems. This survey paper introduces the specification languages and verification techniques for four levels of development: Requirements definition and control design; Transformation to a systems architecture with program designs and their transformation to programs; Compilation of real-time programs to conventional processors, and Compilation of programs to hardware.", "num_citations": "154\n", "authors": ["1572"]}
{"title": "How did software get so reliable without proof?\n", "abstract": " By surveying current software engineering practice, this paper reveals that the techniques employed to achieve reliability are little different from those which have proved effective in all other branches of modern engineering: rigorous management of procedures for design inspection and review; quality assurance based on a wide range of targeted tests; continuous evolution by removal of errors from products already in widespread use; and defensive programming, among other forms of deliberate over-engineering. Formal methods and proof play a small direct role in large scale programming; but they do provide a conceptual framework and basic understanding to promote the best of current practice, and point directions for future improvement.", "num_citations": "147\n", "authors": ["1572"]}
{"title": "Prespecification in data refinement\n", "abstract": " In data refinement, a concrete data type replaces an abstract data type used in the design of an algorithm or system (Gries and Prins, 1985; Hoare, 1972; Jones, 1980). We present two methods for calculating the weakest specification of each operation on a concrete data type from the specification of the corresponding abstract operation, together with a single simulation relation (Milner, 1980; Park, 1981), which specifies the correspondence between the two types. The methods are proved sound and (jointly) complete for a nondeterministic procedural programming language slightly more powerful than Dijkstra's (1976). Operations (in general, nondeterministic) are represented by relations, and significant use is made of prespecification and postspecification (Hoare and He, Jifeng, 1987).", "num_citations": "144\n", "authors": ["1572"]}
{"title": "Programs are predicates\n", "abstract": " In 1969, Hoare introduced the notion of an axiomatic definition of a programming language [1]. In his technique, axioms which expressed the meaning of a language construct (in terms of the weakest precondition necessary for a given postcondition to hold) were given for each of the constructs in the language. Much of the work on proving programs correct can be traced back to this notion of a program as a predicate transformer. In this more recent paper, Hoare has shifted his viewpoint. Instead of viewing a program as a predicate transformer, he now treats it as a predicate relating the input of a program to its output. In making this shift, Hoare is developing an alternative approach to proving program correctness; correctness is shown by proving that the predicate representing the program necessarily implies the formal specification. In order to illustrate and demonstrate this idea, Hoare designs a language for\u00a0\u2026", "num_citations": "138\n", "authors": ["1572"]}
{"title": "Concurrent Kleene algebra and its foundations\n", "abstract": " A Concurrent Kleene Algebra offers two composition operators, related by a weak version of an exchange law: when applied in a trace model of program semantics, one of them stands for sequential execution and the other for concurrent execution of program components. After introducing this motivating concrete application, we investigate its abstract background in terms of a primitive independence relation between the traces. On this basis, we develop a series of richer algebras the richest validates a proof calculus for programs similar to that of a Jones style rely/guarantee calculus. On the basis of this abstract algebra, we finally reconstruct the original trace model, using the notion of atoms from lattice theory.", "num_citations": "135\n", "authors": ["1572"]}
{"title": "Normal form approach to compiler design\n", "abstract": " This paper demonstrates how reduction to normal form can help in the design of a correct compiler for Dijkstra's guarded command language. The compilation strategy is to transform a source program, by a series of algebraic manipulations, into a normal form that describes the behaviour of a stored-program computer. Each transformation eliminates high-level language constructs in favour of lower-level constructs. The correctness of the compiler follows from the correctness of each of the algebraic transformations.", "num_citations": "133\n", "authors": ["1572"]}
{"title": "A semantics for imprecise exceptions\n", "abstract": " Some modern superscalar microprocessors provide only imprecise exceptions. That is, they do not guarantee to report the same exception that would be encountered by a straightforward sequential execution of the program. In exchange, they offer increased performance or decreased chip area (which amount to much the same thing). This performance/precision tradeoff has not so far been much explored at the programming language level. In this paper we propose a design for imprecise exceptions in the lazy functional programming language Haskell. We discuss several designs, and conclude that imprecision is essential if the language is still to enjoy its current rich algebra of transformations. We sketch a precise semantics for the language extended with exceptions. The paper shows how to extend Haskell with exceptions without crippling the language or its compilers. We do not yet have enough experience of\u00a0\u2026", "num_citations": "129\n", "authors": ["1572"]}
{"title": "The weakest prespecification\n", "abstract": " In Dijkstra's calculus of weakest preconditions [2], a program is generally specified by a predicate R describing the desired properties of the values of the program's variables when the program successfully terminates. If Q is a program, the weakest precondition", "num_citations": "121\n", "authors": ["1572"]}
{"title": "Semantics of nondeterminism, concurrency, and communication\n", "abstract": " One of the more important and active areas in the theory of programming languages is that of concurrent programs, specifically their design, definition, analysis, and verification. Due to recent developments in the technology of microprocessors, there is a trend toward languages supporting distributed activities involving communication rather than concurrent activities on some shared resources, mainly memory. Thus, it becomes very important to supply adequate tools for the definition and analysis of such programs and programming languages.", "num_citations": "121\n", "authors": ["1572"]}
{"title": "A calculus of total correctness for communicating processes\n", "abstract": " A process communicates with its environment and with other processes by syncronized output and input on named channels. The current state of a process is defined by the sequences of messages which have passed along each of the channels, and by the sets of messages that may next be passed on each channel. A process satisfies an assertion if the assertion is at all times true of all possible states of the process. We present a calculus for proving that a process satisfies the assertion describing its intended behaviour. The following constructs are axiomatised: output; input; simple recursion; disjoint parallelism; channel renaming, connection and hiding; process chaining; nondeterminism; conditional; alternation; and mutual recursion. The calculus is illustrated by proof of a number of simple buffering protocols.", "num_citations": "120\n", "authors": ["1572"]}
{"title": "An overview of some formal methods for program design\n", "abstract": " T the actions of a computer executing that program. As in other branches of engineering, the progress of its implemen-tation as well as its eventual quality can be promoted by additional design documents, formalized before starting to write the final code. These preliminary documents may be expressed in a variety of notations suitable for different purposes at different stages of a project, from capture of requirements through design and implementation, to delivery and long-term maintenance. These notations are derived from mathematics, and include algebra, logic, functions, and procedures. The connection between the notations is provided by mathematical calculation and proof. This article introduces and illustrates a selection of formal methods by means of a single recurring example, the design of a program to compute the greatest common divisor of two positive numbers. It is hoped that some of the conclusions\u00a0\u2026", "num_citations": "112\n", "authors": ["1572"]}
{"title": "Operating Systems Techniques\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "98\n", "authors": ["1572"]}
{"title": "Record handling\n", "abstract": " Problems involving structured data arise in many areas of computer application, for example, in simulation studies, information retrieval, graph theory, compiler writing, symbol manipulation, and business oriented data processing. In each of these areas,, specialised languages have been developed to define and manipulate data structures of a form suited to that particular application. This paper presents a generalised approach to data structures, which is suitable for incorporation in a general purpose programming language such as ALGOL. 60, and which may extend its application to many of the areas cited above.", "num_citations": "98\n", "authors": ["1572"]}
{"title": "Some properties of predicate transformers\n", "abstract": " This paper defines some\" weakest precondltmn'\" predicate transformers, Investigates their\" healthiness\" properties, and apphes them to Dljkstra's language of guarded commands It shows that Dljkstra's w~ function is not the weakest healthy one, but it~ s clearly the best one for practical programming, because it proves the absence of bhnd alleys from a nondetermmlsac program", "num_citations": "96\n", "authors": ["1572"]}
{"title": "Concurrent kleene algebra\n", "abstract": " A concurrent Kleene algebra offers, next to choice and iteration, operators for sequential and concurrent composition, related by an inequational form of the exchange law. We show applicability of the algebra to a partially-ordered trace model of program execution semantics and demonstrate its usefulness by validating familiar proof rules for sequential programs (Hoare triples) and for concurrent ones (Jones\u2019s rely/guarantee calculus). This involves an algebraic notion of invariants; for these the exchange inequation strengthens to an equational distributivity law. Most of our reasoning has been checked by computer.", "num_citations": "94\n", "authors": ["1572"]}
{"title": "Verified software: Theories, tools, experiments vision of a grand challenge project\n", "abstract": " The ideal of correct software has long been the goal of research in Computer Science. We now have a good theoretical understanding of how to describe what programs do, how they do it, and why they work.This understanding has already been applied to the design, development and manual verification of simple programs of moderate size that are used in critical applications.Automatic verification could greatly extend the benefits of this technology.               This paper argues that the time is ripe to embark on an international Grand Challenge project to construct a program verifier that would use logical proof to give an automatic check of the correctness of programs submitted to it.Prototypes for the program verifier will be based on a sound and complete theory of programming; they will be supported by a range of program construction and analysis tools; and the entire toolset will be evaluated and evolve by\u00a0\u2026", "num_citations": "91\n", "authors": ["1572"]}
{"title": "Parallel programming: an axiomatic approach\n", "abstract": " This paper develops some ideas expounded in [1]. It distinguishes a number of ways of using parallelism, including disjoint processes, competition, cooperation, communication and \"colluding\". In each case an axiomatic proof rule is given. Some light is thrown on traps or ON conditions. Warning: the program structuring methods described here are not suitable for the construction of operating systems.", "num_citations": "87\n", "authors": ["1572"]}
{"title": "Refinement algebra proves correctness of compiling specifications\n", "abstract": " A compiler is specified by a description of how each construct of the source language is translated into a sequence of object code instructions. The meaning of the object code can be defined by an interpreter written in the source language itself.", "num_citations": "86\n", "authors": ["1572"]}
{"title": "A theory of synchrony and asynchrony\n", "abstract": " Loosely-coupled (asynchronous) data flow networks are often constrasted to tightlycoupled (synchronous) systems. We present CSP [10] as a unified theory for both types of system, and deduce algebraic laws relating them. The theory may be useful in design and implementation of systems from parts which take advantage of both paradigms.", "num_citations": "80\n", "authors": ["1572"]}
{"title": "An axiomatic definition of the programming language PASCAL\n", "abstract": " The purpose of a formal language definition is to act as a\" contract\" between the implementor and user of the language. It is not intended to be read straight through, but rather to be used by both parties as a work of reference; it will also be used as the basis of more readable descriptions of the language. Thus the objective of a formal description is to make it easy to identify the chapter and subsection relevant to any query, and to consult it in isolation, without having to follow cross-references to other sections and chapters. The axiomatic definition of PASCAL seems to achieve this objective to a remarkable degree.", "num_citations": "79\n", "authors": ["1572"]}
{"title": "An axiomatic basis for computer programming\n", "abstract": " In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantages, both theoretical and practical, may follow from a pursuance of these topics.", "num_citations": "78\n", "authors": ["1572"]}
{"title": "Mathematical logic and programming languages\n", "abstract": " CAR Hoare & JC Shepherdson, Mathematical Logic and Programming Languages - PhilPapers Sign in | Create an account PhilPapers PhilPeople PhilArchive PhilEvents PhilJobs PhilPapers home Syntax Advanced Search Syntax Advanced Search Syntax Advanced Search Mathematical Logic and Programming Languages CAR Hoare & JC Shepherdson (1985) Abstract This article has no associated abstract. (fix it) Keywords Logic, Symbolic and mathematical Programming languages Categories Areas of Mathematics in Philosophy of Mathematics (categorize this paper) Buy this book $25.35 used (53% off) Amazon page ISBN(s) 0135614651 Request removal from index Revision history Download options PhilArchive copy Upload a copy of this paper Check publisher's policy Papers currently archived: 59,399 External links \u2026", "num_citations": "76\n", "authors": ["1572"]}
{"title": "Proof of a recursive program: Quicksort\n", "abstract": " This paper gives the proof of a useful and non-trivial program, Quicksort (Hoare, 1961). First the general algorithm is described informally; next a rigorous but informal proof of correctness of the coded program is given; finally some formal methods are introduced. Conclusions are drawn on the possibility of enlisting mechanical aid in the proof process.", "num_citations": "76\n", "authors": ["1572"]}
{"title": "The mathematics of programming\n", "abstract": " The Mathematics of Programming - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks General item icon General item The Mathematics of Programming Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1986). The Mathematics of Programming. Oxford University Press. \u2026", "num_citations": "75\n", "authors": ["1572"]}
{"title": "Assertions: A personal perspective\n", "abstract": " Assertions are Boolean formulas placed in program text at places where their evaluation will always be true. If the assertions are strong enough, they express everything that the programmers on either side of an interface need to know about the program on the other side, even before the code is written. Indeed, assertions can serve as the basis of a formal proof of the correctness of a complete program.", "num_citations": "73\n", "authors": ["1572"]}
{"title": "Specification-oriented semantics for communicating processes\n", "abstract": " We are aiming at a classification of semantical models for Communicating Processes that will enable us to recommend certain models which are just detailed enough for particular applications. But before such an aim can be fully realised, more sophisticated models of processes should be studied.             For example, we have not considered the notion of state so far. This would allow to add assignment and explicit value passing between processes, thus combining sequential programs with Communicating Processes.             It is also important to ensure that the operators satisfy the usual algebraic laws, for example parallel composition should be associative. And the relationship between specification-oriented denotational semantics used here and the operational semantics used in [12,13,16] should be studied. This requires an explicit concept of divergence. In particular, it is interesting to investigate how\u00a0\u2026", "num_citations": "73\n", "authors": ["1572"]}
{"title": "A note on the for statement\n", "abstract": " This note discusses methods of defining the for statement in high level languages and suggests a proof rule intended to reflect the proper role of a for statement in computer programming. It concludes with a suggestion for possible generalisation.", "num_citations": "71\n", "authors": ["1572"]}
{"title": "A tree semantics of an orchestration language\n", "abstract": " This paper presents a formal semantics of a language, called Orc, which is described in a companion paper[3] in this volume. There are many styles of presentation of programming language semantics. The more operational styles give more concrete guidance to the implementer on how a program should be executed. The more abstract styles are more helpful in proving the correctness of particular programs. The style adopted in this paper is neutral between implementer and programmer. Its main achievement is to permit simple proofs of familiar algebraic identities that hold between programs with different syntactic forms.", "num_citations": "65\n", "authors": ["1572"]}
{"title": "A trace model for pointers and objects\n", "abstract": " Object-oriented programs [Dahl, Goldberg, Meyer] are notoriously prone to the following kinds of error, which could lead to increasingly severe problems in the presence of tasking                                         1.                                             Following a null pointer                                                                                2.                                             Deletion of an accessible object                                                                                3.                                             Failure to delete an inaccessible object                                                                                4.                                             Interference due to equality of pointers                                                                                5.                                             Inhibition of optimisation due to fear of (4)                                                                                              Type disciplines and object classes are a great help in avoiding these errors. Stronger protection may be obtainable with the help of assertions, particularly invariants, which\u00a0\u2026", "num_citations": "65\n", "authors": ["1572"]}
{"title": "Programming: sorcery or science?\n", "abstract": " Professional programming practice should be based on underlying mathematical theories and follow the traditions of better-established engineering disciplines. Success will come through improved education.", "num_citations": "62\n", "authors": ["1572"]}
{"title": "Data reliability\n", "abstract": " This paper surveys the problems of achieving data reliability, and finds them more severe than those of program reliability. It then outlines some of the conceptual and methodological tools which are available for the solution of these problems, including the concept of type, direct product, union, sequence, recursion and mapping. It touches on the topdown design of data and programs, and argues that references or pointers are to be avoided. It concludes with an annotated bibliography for further reading.", "num_citations": "62\n", "authors": ["1572"]}
{"title": "Grand challenges for computing research\n", "abstract": " What are the major research challenges that face the world of computing today? Are there any of them that match the grandeur of well-known challenges in other branches of science? This article is a report on an exercise by the Computing Research Community in the UK to answer these questions, and includes a summary of the outcomes of a BCS-sponsored conference held in Newcastle-upon-Tyne from 29 to 31 March this year.", "num_citations": "60\n", "authors": ["1572"]}
{"title": "Sequential calculus\n", "abstract": " This paper presents an algebraic calculus like the relational calculus for reasoning about sequential phenomena. It provides a common foundation for several proposed models of concurrent or reactive systems. It is clearly differentiated from the relational calculus by absence of a general converse operation. This permits the treatment of temporal logic within the sequential calculus.", "num_citations": "60\n", "authors": ["1572"]}
{"title": "The verifying compiler: A grand challenge for computer research\n", "abstract": " I propose a set of criteria which distinguish a grand challenge in science or engineering from the many other kinds of short-term or long-term research problems that engage the interest of scientists and engineers. As an example drawn from Computer Science, I revive an old challenge: the construction and application of a verifying compiler that guarantees correctness of a program before running it.", "num_citations": "56\n", "authors": ["1572"]}
{"title": "Quasiparallel programming\n", "abstract": " This paper describes SIMONE, an extension of PASCAL,1 which provides the quasiparallel programming facility of SIMULA 67, but without classes or references. The language is intended to be suitable for the design, testing and simulation of operating system algorithms. It is illustrated by simple examples, suitable as project material in a course on operating systems. A simple, restricted, but efficient implementation is described. It is suggested that the language might be suitable for more general simulation purposes, and an example of a general job shop simulation is given.", "num_citations": "53\n", "authors": ["1572"]}
{"title": "Viewpoint retrospective: An axiomatic basis for computer programming\n", "abstract": " C.A.R. Hoare revisits his past Communications article on the axiomatic approach to programming and uses it as a touchstone for the future.", "num_citations": "52\n", "authors": ["1572"]}
{"title": "New graduate nurses as knowledge brokers in general practice in N ew Z ealand: a constructivist grounded theory\n", "abstract": " Practice nursing in New Zealand is not well described in the literature. One survey illustrated that most of the New Zealand practice nurses sampled did not know of the country's two premier evidence\u2010based health websites. A recent review compared general practice in the UK, New Zealand and Australia and found that whereas there had been significant developments in empowering the practice nurse workforce to run nurse\u2010led clinics in the UK, New Zealand and Australia lagged behind. The aim of this reported constructivist grounded theory study was to investigate practice nurses\u2019 use of information. Conducted in Auckland, New Zealand, data were collected through ethnographic techniques in one general practice between September 2009 and January 2010 to enhance theoretical sensitivity to the area of information use. Subsequently, six experienced practice nurses (one twice after moving jobs) and five\u00a0\u2026", "num_citations": "51\n", "authors": ["1572"]}
{"title": "Differential static analysis: opportunities, applications, and challenges\n", "abstract": " It is widely believed that program analysis can be more closely targeted to the needs of programmers if the program is accompanied by further redundant documentation. This may include regression test suites, API protocol usage, and code contracts. To this should be added the largest and most redundant text of all: the previous version of the same program. It is the differences between successive versions of a legacy program already in use which occupy most of a programmer's time. Although differential analysis in the form of equivalence checking has been quite successful for hardware designs, it has not received as much attention in the static program analysis community.", "num_citations": "51\n", "authors": ["1572"]}
{"title": "A THEORY OF ASY'iCHRONOUS PROCESSES\n", "abstract": " A theory of asynchronous processes (nondeterministic data florv netrvorks) is presented. It consists of a mathematical model and a process algebra. The intention is to provide a better theoretical underpinning to the Jackson System Development metirod. The model is so constructed as to be compatible rvith the failures modei of Hoare's Communicating Sequential Processes. The process algebra describes the laws that govern a collection of CSP-like operators, convenient for constructing asynchronous process networks from their components. The operators are defined in terms of the model and so their algebraic properties can be verified. As in CSP, the laws are suffi. ciently complete to transform every netrvork r^ r qpnrrpnria. l form This is imnort; r. nt fnr a dpsion rncfhod LU 4 JEqUE] LLI@ lVLfrlt rllfr IJ lutl, va like JSD, rvhefe the resulting programs must be implemented on a traditional sequential computer.", "num_citations": "50\n", "authors": ["1572"]}
{"title": "Programming is an engineering profession\n", "abstract": " Programming is an Engineering Profession - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Programming is an Engineering Profession Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1983). Programming is an Engineering \u2026", "num_citations": "50\n", "authors": ["1572"]}
{"title": "Partial correctness of communicating sequential processes\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "49\n", "authors": ["1572"]}
{"title": "Algebra and models\n", "abstract": " Science makes progress by constructing mathematical models, deducing their observable consequences, and testing them by experiment. Successful theoretical models are later taken as the basis for engineering methods and codes of practice for design of reliable and useful products. Models can play a similar central role in the progress and practical application of Computing Science.               A model of a computational paradigm starts with choice of a carrier set of potential direct or indirect observations that can be made of a computational process. A particular process is modelled as the subset of observations to which it can give rise. Process composition is modelled by relating observations of a composite process to those of its components. Indirect observations play an essential role in such compositions. Algebraic properties of the composition operators are derived with the aid of the simple theory of\u00a0\u2026", "num_citations": "48\n", "authors": ["1572"]}
{"title": "Grand Challenges for Computing Research\n", "abstract": " The primary purpose of the formulation and promulgation of a grand challenge is to contribute to the advancement of some branch of science or engineering. A grand challenge represents a commitment by a significant section of the research community to work together towards a common goal, agreed to be valuable and achievable by a team effort within a predicted timescale. The challenge is formulated by the researchers themselves as a focus for the research that they wish to pursue in any case, and which they believe can be pursued more effectively by advance planning and co-ordination. Unlike other common kinds of research initiative, a grand challenge should not be triggered by hope of short-term economic, commercial, medical, military, or social benefits; and its initiation should not wait for political promotion or for prior allocation of special funding. The goals of the challenge should be the purely\u00a0\u2026", "num_citations": "46\n", "authors": ["1572"]}
{"title": "Unified theories of programming\n", "abstract": " Professional practice in a mature engineering discipline is based on relevant scientific theories, usually expressed in the language of mathematics. A mathematical theory of programming aims to provide a similar basis for specification, design and implementation of computer programs. The theory can be presented in a variety of styles, including                                         1. Denotational, relating a program to a specification of its observable properties and behaviour.                                                           2. Algebraic, providing equations and inequations for comparison, transformation and optimisation of designs and programs.                                                           3. Operational, describing individual steps of a possible mechanical implementation.                                     This paper presents simple theories of sequential non-deterministic programming in each of these three styles; by deriving each presentation from its\u00a0\u2026", "num_citations": "46\n", "authors": ["1572"]}
{"title": "VDM'90: VDM and Z: Formal Methods in Software Development: Third International Symposium of VDM Europe, Kiel, FRG, April 17-21, 1990 Proceedings\n", "abstract": " The present volume is the third in a series of VDM Symposia Proceedings. VDM, the Vienna Development Method, is a formal method for software engineering, Z refers to Zermelo, a mathematician whose name is associated with set theory. Many computing science, programming and software engineering proceedings are published regularly. The ones by VDM Europe have the distinguished mark that they are concerned with bringing real theory to apply to real programming. In Europe, there is very much interest in methodology, semantics and techniques, that is, in understanding how we build and what it is that we are building. The papers of these proceedings basically fall into four major groups: Applications, Methodology, Formalisations, and Foundations. The Methodology group has been further subdivided into five areas: Specification Methodology, Design Methodology, Modularity, Object Orientedness, and\u00a0\u2026", "num_citations": "46\n", "authors": ["1572"]}
{"title": "REMARKS ON\" PROGRAM PROVING: JUMPS AND FUNCTIONS BY M. CLINT AND CAR HOARE\".\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "45\n", "authors": ["1572"]}
{"title": "Notes on an approach to category theory for computer scientists\n", "abstract": " These notes have been designed for the benefit of theoretical computer scientists who are not sure whether they want to study category theory, and who are too busy to devote the long period of continuous study required to master the subject from standard texts. The notes are therefore structured into three independent chapters, of which the earlier ones are the simplest and most clearly relevant to computer science. Each chapter introduces a number of essential categorical concepts, illustrates them by examples intended to be familiar to computer scientists, and presents theorems describing their most important properties. Each chapter may therefore be studied at widely separated intervals of time; further, the material of each chapter is organised so that there is no need to finish one chapter (or even one section) before starting the next. Finally, the reader who decides to abandon the study of category\u00a0\u2026", "num_citations": "44\n", "authors": ["1572"]}
{"title": "Notes on communicating sequential systems\n", "abstract": " These notes present a coherent and comprehensive introduction to the theory and applications of Communicating Sequential Processes. Most of the illustrative examples have appeared earlier in PRG-22. The theory described in PRG-16 has been taken as the basis of a number of algebraic laws, which can be used for proofs of equivalence and can justify correctness-preserving transformations. A complete method for specifying processes and proving their correctness has been taken over from PRG-20 and PRG-23. Many of the concepts have been implemented in LISPKIT, as described in PRG-32.", "num_citations": "44\n", "authors": ["1572"]}
{"title": "Hardware and software: The closing gap\n", "abstract": " The study of computing science is split at an early stage between the branches dealing separately with hardware and software; and there is a corresponding split in later professional specialisation. This paper explores the essential unity and overlap of the two branches. The basic concepts are those of occam, taken as a simple example of a high-level programming language; its notations may be translated by the laws of programming to the machine code of a conventional machine. Almost identical transformations can produce the networks of gates and flip-flops which constitute a hardware design. These insights are being exploited in hybrid systems, implemented partly in hardware and partly in software. A TRAM-standard printed circuit board called HARP has been constructed for such applications. It links a transputer by shared memory with a commercial Field Programmable Gate Array. Prospects for\u00a0\u2026", "num_citations": "43\n", "authors": ["1572"]}
{"title": "Proof of a structured program:\u2018The sieve of Eratosthenes\u2019\n", "abstract": " This paper illustrates a method of constructing a program together with its proof. By structuring the program at two levels of abstraction, the proof of the more abstract algorithm may be completely separated from the proof of the concrete representation. In this way, the overall complexity of the proof is kept within more reasonable bounds.", "num_citations": "43\n", "authors": ["1572"]}
{"title": "A structured paging system\n", "abstract": " The principles and practices of structured programming have been expounded and illustrated by relatively small examples (Dahl, Dijkstra, Hoare, 1972). Systematic methods for the construction of parallel algorithms have also been suggested (Dijkstra, 1968, a, b). This paper attempts to extend structured programming methods to a program intended to operate in a parallel environment, namely a paging system for the implementation of virtual store. The design decisions are motivated by considerations of cost of effectiveness.         The purpose of a paging system is taken to be the sharing of main and backing store of a computer among a number of users making unpredictable demands upon them; and to do so in such a way that each user will not be concerned whether his information is stored at any given time on main or backing store. For the sake of definiteness, the backing store is taken here to be a\u00a0\u2026", "num_citations": "40\n", "authors": ["1572"]}
{"title": "Algebraic specification and proof of a distributed recovery algorithm\n", "abstract": " An algebraic specification is given of an algorithm for recovery from catastrophe by a deterministic process. A second version of the algorithm also includes check-points. The algorithms are formulated in the notations of Communicating Sequential Processes (Hoare 1985) and the proofs of correctness are conducted wholly by application of algebraic laws (together with the unique fixed point theorem).", "num_citations": "38\n", "authors": ["1572"]}
{"title": "A more complete model of communicating processes\n", "abstract": " A previous paper by Hoare gives axioms and proof rules for communicating processes that provide a calculus of total correctness. This paper gives explicit definitions of communicating processes as predicates. The former axioms and proof rules become theorems, proved using the explicit definitions. The defining predicates are more powerful than the proof rules for reasoning about processes, but less often useful for their construction. An implementation of the processes using partial recursive functions is given.", "num_citations": "38\n", "authors": ["1572"]}
{"title": "Algebra of Logic Programming.\n", "abstract": " A declarative programming language has two kinds of semantics. The more abstract helps in reasoning about specifications and correctness, while an operational semantics determines the manner of program execution. A correct program should reconcile its abstract meaning with its concrete interpretation.To help in this, we present a kind of algebraic semantics for logic programming. It lists only those laws that are equally valid for predicate calculus and for the standard depth-first strategy of Prolog. An alternative strategy is breadth-first search, which shares many of the same laws. Both strategies are shown to be special cases of the most general strategy, that for tree searching. The three strategies are defined in the lazy functional language Haskell, so that each law can be proved by standard algebraic reasoning. The laws are an enrichment of the familiar categorical concept of a monad, and the links between such monads are explored.", "num_citations": "36\n", "authors": ["1572"]}
{"title": "Mathematics of programming\n", "abstract": " I hold the opinion that the construction of computer programs is a mathematical activity like the solution of differential equations, that programs can be derived from their specifications through mathematical insight, calculation, and proof, using algebraic laws as simple and elegant as those of elementary arthmetic. Such methods of program construction promise benefits in specifications, systems software, safety-critical programs, silicon design, and standards.", "num_citations": "36\n", "authors": ["1572"]}
{"title": "From algebra to operational semantics\n", "abstract": " There is a general agreement among theoretical computing scientists that a programming language, or its underlying computational paradigm, may be clarified by a mathematical investigation of its formal semantics. There are at least three approaches to the definition of the required semantics, each with its own distinctive advantages.(1) Specification-oriented[11, 13, 17]. This relates a program to the testable requirements which it is intended to meet. It is useful for reasoning about correctness even before the program is written.(2) Algebraic [l]. This is presented as a set of algebraic equations, like the axioms of group theory. They are useful for the derivation of designs and for the optimization of programs [2]. They also help in comparing and classifying the variety of possible languages [9].(3) Operational[12, 14]. This reduces the computation of a program to a series of individual steps, suitable for execution by a\u00a0\u2026", "num_citations": "35\n", "authors": ["1572"]}
{"title": "Developments in Concurrency and Communication\n", "abstract": " Copyright\u00a9 1990 by Addison-Wesley Publishing Company, Inc.", "num_citations": "35\n", "authors": ["1572"]}
{"title": "Programs are predicates\n", "abstract": " A computer program is identified with the strongest predicate describing every relevant observation that can be made of the behaviour of a computer executing that program. A programming language is a subset of logical and mathematical notations, which is so restricted that products described in the language can be automatically implemented on a computer. The notations enjoy a number of elegant algebraic properties, which can be used for optimizing program efficiency. A specification is a predicate describing all permitted observations of a program, and it may be expressed with greatest clarity by taking advantage of the whole language of logic and mathematics. A program P meets its specification S iff =P=>S. The proof of this implication may use all the classical methods of mathematics and logic. These points are illustrated by design of a small language that includes assignments, conditionals, non\u00a0\u2026", "num_citations": "35\n", "authors": ["1572"]}
{"title": "Incomputability\n", "abstract": " Russell's logical paradox, formulated in terms of English adjectives, is cons] dered as a convenient starting point for this discussion of incomputablhty. It is shown to be impossible, under a wide variety of circumstances, to program a function which will determine whether another function written in the same programming language wdl terminate. The theory of types is introduced in an attempt to evade the paradox Finally, it is shown that any language containing conditionals and recursive function definitions, which is powerful enough to program its own interpreter, cannot be used to program its own terminates function.", "num_citations": "35\n", "authors": ["1572"]}
{"title": "The dawn of software engineering: From turing to Dijkstra\n", "abstract": " Did Alan Turing play a major role in the advent of the all-purpose computer? Did Turing Award winners, like Edsger W. Dijkstra, depend on his famous accomplishments? In his well-researched book The Dawn of Software Engineering: from Turing to Dijkstra, Edgar G. Daylight deromanticizes Turing's & logic's role in the history of computing. Dijkstra's pioneering work in compilers lies at the heart of modern-day computers. The book vividly describes how & why Dijkstra's ideas stood out among those of his contemporaries. This book includes interviews with Turing Award winners Tony Hoare, Niklaus Wirth, Peter Naur, and Barbara Liskov. The Dawn of Software Engineering is a rich and fascinating account of the time when software engineering was a compelling intellectual discipline at the center of computer science. John C. Reynolds, CMU wonderfully novel, very readable, and most engaging Grady Booch, IBM\u00a0\u2026", "num_citations": "33\n", "authors": ["1572"]}
{"title": "A ProCoS II Project Final Report: ESPRIT Basic Research project 707\n", "abstract": " An overview of the research and associated activities of the Europeancollaborative ESPRIT Basic Research ProCoS II project (no. 7071) on``Provably Correct Systems''which ran from 1992 to 1995 is presented. This was a follow-on project to ProCoS (no. 3104) and ran inparallel with the ProCoS Working Group (no. 8694), all previouslyannounced in the Bulletin of the EATCS. Acomprehensive bibliography of publications with selected projectdocuments is included for those wishing to study the results of theproject in greater depth.", "num_citations": "32\n", "authors": ["1572"]}
{"title": "A theory of nondeterminism\n", "abstract": " A construction is described which takes an arbitrary set of machines, an arbitray set of tests, and an arbitrary relation on machines and tests defining which machines pass which tests. It produces a domain of specifications, which is a retract of the lattice of sets of tests (with the subset ordering), and a domain of nondeterministic machines (ndms), which is a retract of the lattice of sets of machines (with the superset ordering). These two domains are isomorphic. Simple conditions ensure that they are \u03c9-algebraic.             Functions on such domains may be defined equivalently either as transformations of ndms (an operational definition) or as transformations of specifications (an axiomatic definition). Conditions for the \"realism\" of such functions are formulated.", "num_citations": "32\n", "authors": ["1572"]}
{"title": "University of Oxford\n", "abstract": " Studies of law-making often treat the executive as a single actor. However, bill drafts are\u2013more often than not\u2013developed and drafted by particular executive ministries, departments, or agencies before being debated in cabinet and sent on for legislative review with the executive\u2019s imprimatur. This paper presents and analyses data on contemporary Russian law-making, disaggregating Government legislative initiatives by their original drafting actor. The paper draws on a new dataset of Russian law-making, which, for the first time, combines systematic data on all bills before and after legislative introduction. Statistical and processtracing techniques are used to evaluate competing hypotheses about the differential ability of discrete Russian executive actors to realise their law-making goals.", "num_citations": "31\n", "authors": ["1572"]}
{"title": "Unifying theories of programming\n", "abstract": " Unifying theories of programming - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Unifying theories of programming Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style He, J., & Hoare, CAR (1998). Unifying theories of programming. Copy \u2026", "num_citations": "30\n", "authors": ["1572"]}
{"title": "Data refinement in a categorical setting\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "30\n", "authors": ["1572"]}
{"title": "The varieties of programming language\n", "abstract": " The next section compares the merits of two methods of studying the mathematics of programming languages. The denotational method, due to Strachey, requires the construction of a mathematical meaning for each major component of each program expressed in each language. The various operators which combine the components are defined as functions, on the meanings of their operands. The algebraic approach avoids giving any meaning to the operators and operands; instead it formulates general equations describing the algebraic properties of the operators individually and in relation to each other. In some cases, this is sufficient to characterise the meaning of each operator, at least up to some form of equivalence or isomorphism. The algebraic approach seems to offer considerable advantages in the classification of the varieties of programming language, because it permits individual features and\u00a0\u2026", "num_citations": "28\n", "authors": ["1572"]}
{"title": "Specifications \u201aPrograms and Implementations\n", "abstract": " Specifications\u201a Programs and Implementations - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Report icon Report Specifications\u201a Programs and Implementations Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1982). Specifications\u201a Programs and Implementations\u2026", "num_citations": "28\n", "authors": ["1572"]}
{"title": "Drumlinised glaciofluvial and glaciolacustrine sediments on the Sm\u00e5land peneplain, South Sweden\u2013new information on the growth and decay history of the Fennoscandian Ice Sheets\u00a0\u2026\n", "abstract": " Dug trenches in sediment-cored drumlins on the Sm\u00e5land peneplain, southern Sweden, occurring intermixed with rock-cored drumlins, revealed sedimentary successions and facies suggesting that the core sediments were primarily deposited proglacially, both in glaciolacustrine settings as delta-front and more distal deeper-water sediments, and as glaciofluvial braidplain sediments. From the relationship between the drumlin sorted-sediment cores and their surficial drape by a till carapace, it is concluded that erosion was the main drumlin-forming process here, reshaping the original sediment morphology into streamlined landforms, after which a more or less thick traction till was deposited over the eroded and/or deformed ice\u2013bed interface. Drumlin formation probably took place during the last deglaciation over the area. The drumlin-core sediments in 14 excavated trenches were dated by Optically Stimulated\u00a0\u2026", "num_citations": "24\n", "authors": ["1572"]}
{"title": "Why ever CSP?\n", "abstract": " The original theoretical model of Communicating Sequential Processes owed its inspiration to the achievements of Milner, Scott and Dijkstra. It was developed at around the time of the publication of Milner's Calculus of Communicating Systems. Why ever did CSP diverge from CCS?The ESPRIT basic research action 'CONCUR' brought together the proponents of three of the original calculi of concurrency: ACP, CCS and CSP. It was hoped that we would develop a unified calculus, and concur upon its adoption. Why ever did we fail?I would like to share with you the way in which I thought about these questions twenty five years ago. Since then, many excellent comparative studies have been conducted. As a result, we can now see how such theories can best be unified, without assimilation of their distinctive features or compromise of their distinctive merits.", "num_citations": "24\n", "authors": ["1572"]}
{"title": "Programs as executable predicates\n", "abstract": " Programs as Executable Predicates - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Programs as Executable Predicates Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & Roscoe, AW (1984). Programs as Executable \u2026", "num_citations": "24\n", "authors": ["1572"]}
{"title": "The role of formal techniques: past, current and future or how did software get so reliable without proof?\n", "abstract": " Twenty years ago it was reasonable to products would be severely limited by predict that the size and ambition of software the unreliability of their component programs. Crude estimates suggest that professionally written programs delivered to the customer can contain between one and ten independently correctable errors per thousand lines of code; and any software error in principle can have spectacular effect (or worse, a subtly misleading effect) on the behaviour of the entire system. Dire warnings have been issued of the dangers of safety-critical software controlling health equipment, aircraft, weapons and industrial processes, including nuclear power stations. The arguments were sufficiently persuasive to trigger a significant research effort devoted to the problem of program correctness. A proportion of this research was based on the ideal of certainty achieved by mathematical proof.Fortunately, the problem of\u00a0\u2026", "num_citations": "23\n", "authors": ["1572"]}
{"title": "Mathematical models for computing science\n", "abstract": " A scienti c theory is a predicate, usually expressed in the notations of mathematics, which describes all possible observations that can be made directly or indirectly of any system from a given reproducible class. An example is Einstein's famous equation e= mc2 where e is the energy of the system m is its mass and c is the speed of light.Considerable familiarity with physics is needed to correlate the variables e and m with the physical reality which they refer to. The same physical system may be described at many di erent levels of abstraction and granularity, for example as a collection of interacting quarks, or elementary particles, or atoms, or molecules, or crystal structures. Science has discovered independent theories for reasoning at each of these levels of abstraction. But even more impressive is the demonstration that each theory is soundly based on the more detailed theory below it. This is the strongest argument for the soundness not only for each separate theory, but also for the entire intellectual structure of modern physics. Mathematical theories expressed as predicates play an equally decisive role in engineering. A signi cant engineering project begins with a speci cation describing as directly as possible the observable properties and behaviour of the desired product. The design documents, formulated at various stages of the project, are indirect descriptions of the same behaviour. They are expressed in some restricted notation, at a level of abstraction appropriate to guide the physical implementation. This implementation is correct if its detailed description logically implies its speci cation; for then any observation of the product will be\u00a0\u2026", "num_citations": "22\n", "authors": ["1572"]}
{"title": "The quality of software\n", "abstract": " The aim of every item of software must be most clearly defined; and recommendations on the circumstances of its successful use must be fully explained. Vagueness in this matter is intolerable; and of course, every feature of the program delivered must be oriented towards the declared purpose.", "num_citations": "22\n", "authors": ["1572"]}
{"title": "Unification of theories: A challenge for computing science\n", "abstract": " Unification of theories is the long-standing goal of the natural sciences; and modern physics offers a spectacular paradigm of its achievement. The structure of modern mathematics has also been determined by its great unifying theories \u2014 topology, algebra and the like. The same ideals and goals are shared by researchers and students of theoretical computing science.", "num_citations": "21\n", "authors": ["1572"]}
{"title": "Partial correctness of communicating processes and protocols\n", "abstract": " Partial Correctness of Communicating Processes and Protocols - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Report icon Report Partial Correctness of Communicating Processes and Protocols Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & Chaochen, Z. (\u2026", "num_citations": "21\n", "authors": ["1572"]}
{"title": "Refinement algebra proves correctness of compilation\n", "abstract": " A compiler is specified by a description of how each construct of the source language is translated into a sequence of object code instructions. The meaning of the object code can be defined by an interpreter written in the source language itself. A proof that the compiler is correct must show that interpretation of the object code is at least as good (for any relevant purpose) as the corresponding source program. The proof is conducted using standard techniques of data refinement. All the-calculations are based on algebraic laws governing the source language. The theorems are expressed in a form close to a logic program, which may be used as a compiler prototype, or as a check on the results of a particular compilation. It is suggested that this formal framework provides appropriate interfaces for compiler implementors, and hardware designers, as well as users of the language.", "num_citations": "20\n", "authors": ["1572"]}
{"title": "Mechanized Reasoning and Hardware Design\n", "abstract": " CAR Hoare & MJC Gordon, Mechanized Reasoning and Hardware Design - PhilPapers Sign in | Create an account PhilPapers PhilPeople PhilArchive PhilEvents PhilJobs PhilPapers home Syntax Advanced Search Syntax Advanced Search Syntax Advanced Search Mechanized Reasoning and Hardware Design CAR Hoare & MJC Gordon (1992) Abstract This article has no associated abstract. (fix it) Keywords Logic design Microprocessors Categories No categories specified (categorize this paper) Buy this book Find it on Amazon.com ISBN(s) 0135724058 Options Edit this record Mark as duplicate Export citation Find it on Scholar Request removal from index Revision history Download options PhilArchive copy Upload a copy of this paper Check publisher's policy Papers currently archived: 59,493 External links This entry has no external links. Add one. Setup an account with your affiliations in order to access \u2026", "num_citations": "20\n", "authors": ["1572"]}
{"title": "Developments in concurrent Kleene algebra\n", "abstract": " This report summarises the background and recent progress in the research of its co-authors. It is aimed at the construction of links between algebraic presentations of the principles of programming and the exploitation of concurrency in modern programming practice. The signature and laws of a Concurrent Kleene Algebra (CKA) largely overlap with those of a Regular Algebra, with the addition of concurrent composition and a few simple laws for it. They are re-interpreted here in application to computer programs. The inclusion relation for regular expressions is re-interpreted as a refinement ordering, which supports a stepwise contractual approach to software system design and to program debugging.The laws are supported by a hierarchy of models, applicable and adaptable to a range of different purposes and to a range of different programming languages. The algebra is presented in three tiers. The bottom tier\u00a0\u2026", "num_citations": "19\n", "authors": ["1572"]}
{"title": "Foundations of concurrent Kleene algebra\n", "abstract": " A Concurrent Kleene Algebra offers two composition operators, one that stands for sequential execution and the other for concurrent execution [10]. In this paper we investigate the abstract background of this law in terms of independence relations on which a concrete trace model of the algebra is based. Moreover, we show the interdependence of the basic properties of such relations and two further laws that are essential in the application of the algebra to a Jones style rely/guarantee calculus. Finally we reconstruct the trace model in a more abstract setting based on the notion of atoms from lattice theory.", "num_citations": "19\n", "authors": ["1572"]}
{"title": "Towards the verifying compiler\n", "abstract": " A verifying compiler is one that proves automatically that a program is correct before allowing it to be run. Correctness of a program is defined by placing assertions at strategic points in the program text, particularly at the interfaces between its components. From recent enquiries among software developers at Microsoft, I have discovered that assertions are widely used in program development practice. Their main role is as test oracles, to detect programming errors as close as possible to their place of occurrence. Further progress in reliable software engineering is supported by programmer productivity tools that exploit assertions of various kinds in various ways at all stages in program development. The construction and exploitation of a fully verifying compiler remains as a long-term challenge for twenty-first century Computing Science. The results of this research will be of intermediate benefit long before\u00a0\u2026", "num_citations": "19\n", "authors": ["1572"]}
{"title": "Theories of programming: Top-down and bottom-up and meeting in the middle\n", "abstract": " The goal of scientific research is to develop an understanding of the complexity of the world which surrounds us. There is certainly enough complexity out there to justify a wide range of specialist branches of science; and within each branch to require a wide range of investigatory styles and techniques.", "num_citations": "19\n", "authors": ["1572"]}
{"title": "The logic of engineering design\n", "abstract": " A scientific theory takes the form of an equation or a set of equations and inequations, usually expressed in the language of mathematics. We will use the general logical term predicate to stand for such mathematical descriptions. The purpose of the predicate is to de scribe and therefore predict all possible observations that can be made directly or indirectly of any system from a given reproducible class. The values obtained by physical measurement are denoted by free variables occurring in the formulae. An example is Einstein\u2019s famous equation e= mc2 where e is the energy of the system, m is its mass and c is the speed of light.", "num_citations": "19\n", "authors": ["1572"]}
{"title": "Prentice-Hall International Series in Computer Science\n", "abstract": " Although they are widely cited as one of those techniques that can result in high-integrity systems [31], and are being mandated more and more in certain applications (see Part 6), formal methods remain one of the most controversial areas of current software engineering practice [119].", "num_citations": "19\n", "authors": ["1572"]}
{"title": "The transputer and occam: A personal story\n", "abstract": " The paper tells the story of the development over twenty\u2010five years of my ideas about communicating sequential processes. One of its most subtle and most useful facilities is the guarded choice, which appears as the ALT command in occam. Its subtleties are clarified and its usefulness increased by an understanding of the relevant simple algebraic laws, based on mathematical research conducted at Oxford. The abstractions provided by mathematics are the secret of the versatility of occam, which can be reliably and efficiently implemented by multiprogramming or by multiprocessing or by hardware, or by any combination of these. In conclusion, it is conjectured that the occam programming paradigm will remain the most efficient and most reliable for the general\u2010purpose shared\u2010store multiprocessors of the future.", "num_citations": "18\n", "authors": ["1572"]}
{"title": "The Ideal of Program Correctness: Third Computer Journal Lecture\n", "abstract": " The ideal of verified software has long been the goal of research in Computer Science. This article argues that the time is ripe to embark on a Grand Challenge project to construct a program verifier, based on a sound and complete theory of programming, and evaluated by experimental application to a large and representative sample of useful computer software.", "num_citations": "17\n", "authors": ["1572"]}
{"title": "Control Flow and Data Flow: Concepts of Distributed Programming: International Summer School\n", "abstract": " In a time of multiprocessor machines, message switching networks and process control programming tasks, the foundations of programming distributed systems are among the central challenges for computing sci enti sts. The foundati ons of di stributed programming compri se all the fasci nating questions of computing science: the development of adequate com putational, conceptual and semantic model s for distributed systems, specification methods, verification techniques, transformation rules, the development of suitable representations by programming languages, evaluation and execution of programs describing distributed systems. Being the 7th in a series of ASI Summer Schools at Marktoberdorf, these lectures concentrated on distributed systems. Already during the previous Summer School s at Marktoberdorf aspects of di stributed systems were important periodical topics. The rising interest in distributed\u00a0\u2026", "num_citations": "17\n", "authors": ["1572"]}
{"title": "Case expressions\n", "abstract": " It is widely held that the switch mechanism of ALGOL60 is one of its less successful features, being both inelegant and inefficient in implementation. At the same time, there is general agreement that the conditional expression and the conditional statement are among the~ ost attractive features of the language, contributing greatly to the perspicuity of programs written~ n ALGOL as compared, for example, with FORTRAN. The aim of the\" case\" expressions and statements described in this note is to reproduce the effect of the ALGOL and the FORTRAN\" computed go to\" by means of a notation which shares some of perspicuity and elegance of the ALGOL conditional.The present proposal invites comparison with a previous proposal made by FoG. Duncan and A. van Wijngaarden (Cleoning up ALGOL60, AB16o5o5). It appears to have several advantages bcsides its perspicuity: I. It avoids the necessity of laboriously\u00a0\u2026", "num_citations": "17\n", "authors": ["1572"]}
{"title": "Report on the Elliott ALGOL Translator.\n", "abstract": " The Elliott ALGOL programming and operating system has been designed to suit the ne\u1ec3ds of an Elliott 503 computer installation which aliocates at least part of its time to running programs on a service basis. The main problem in operating a computing service js to maintain a high average number of programs processed in a given period, and in particular to reduce to a minimum thc timc spent in changing over from one program to the next.", "num_citations": "17\n", "authors": ["1572"]}
{"title": "The structure of an operating system\n", "abstract": " This paper describes the use of the class and inner concepts of SIMULA 67 to express the multi-level structure of an operating system. A comparison is drawn between compile-time checking and run-time protection.", "num_citations": "16\n", "authors": ["1572"]}
{"title": "The laws of programming unify process calculi\n", "abstract": " We survey the well-known algebraic laws of sequential programming, and propose some less familiar laws for concurrent programming. On the basis of these laws, we derive the rules of a number of classical programming and process calculi, for example, those due to Hoare, Milner, and Kahn. The algebraic laws are simpler than each of the calculi derived from it, and they are stronger than all the calculi put together. Conversely, most of the laws are derivable from one or more of the calculi. This suggests that the laws are useful as a presentation of program semantics, and correspond to a widely held common understanding of the meaning of programs. For further evidence, Appendix A describes a realistic and generic model of program behaviour, which has been proved to satisfy the laws.", "num_citations": "15\n", "authors": ["1572"]}
{"title": "Pre-adjunctions in order enriched categories\n", "abstract": " Category theory offers a unified mathematical framework for the study of specifications and programs in a variety of styles, such as procedural, functional and concurrent. One way that these different languages may be treated uniformly is by generalising the definitions of some standard categorical concepts. In this paper we reproduce in the generalised theory analogues of some standard theorems on isomorphism, and outline their applications to programming languages.", "num_citations": "15\n", "authors": ["1572"]}
{"title": "A Contribution to the Development of ALGOL\n", "abstract": " A programming language similar in many respects to Algol 60, but incorporating a large number of improvements based on six years\u2019 experience with that language, is described in detail. Part I consists of an introduction to the new language and a summary of the changes made to ALGOL 60, together with a discussion of the motives behind the revisions. Part II is a rigorous definition of the proposed language. Part III describes a set of proposed standard procedures to be used with the language, including facilities for input/output.", "num_citations": "15\n", "authors": ["1572"]}
{"title": "Optimization of Store Size for Garbage Collection.\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "15\n", "authors": ["1572"]}
{"title": "Partial correctness of communicating sequential processes\n", "abstract": " Partial Correctness of Communicating Sequential Processes - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Partial Correctness of Communicating Sequential Processes Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Chaochen, Z., & Hoare, CAR (\u2026", "num_citations": "14\n", "authors": ["1572"]}
{"title": "Maths adds safety to computer programs\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "14\n", "authors": ["1572"]}
{"title": "Process algebra: A unifying approach\n", "abstract": " Process algebra studies systems that act and react continuously with their environment. It models them by transition graphs, whose nodes represent their states, and whose edges are labelled with the names of events by which they interact with their environment. A trace of the behaviour of a process is recorded as a sequence of observable events in which the process engages. Refinement is defined as the inclusion of all traces of a more refined process in those of the process that it refines. A simulation is a relation that compares states as well as events; by definition, two processes that start in states related by a simulation, and which then engage in the same event, will end in states also related by the same simulation. A bisimulation is defined as a symmetric simulation, and similarity is defined as the weakest of all simulations. In classical automata theory, the transition graphs are deterministic: from a\u00a0\u2026", "num_citations": "14\n", "authors": ["1572"]}
{"title": "Assertions\n", "abstract": " An assertion is a Boolean formula written in the text of a program, which the programmer asserts will always be true when that part of the program is executed. It species an internal interface between that part of the program that comes before it and all that follows it. In the software industry today, assertions are conditionally compiled in test runs of a program, and help in the detection and diagnosis of errors. Alan Turing first proposed assertions as a means of checking a large routine. They were rediscovered independently by Naur as generalised snapshots, and by Floyd, who used them to assign meanings to programs. Floyd suggested that if the internal assertions were strong enough, they would constitute a formal proof of the correctness of a complete program. In this lecture, I will summarise the subsequent development of the idea, and describe some of its practical impact.", "num_citations": "14\n", "authors": ["1572"]}
{"title": "Partial correctness of C-mos switching circuits: an exercise in applied logic\n", "abstract": " The possibility of extending some of the logical methods that have been recommended for the design of software to the design of hardware, in particular, of synchronous switching circuits implemented in CMOS, is explored. The objective is to design networks that are known by construction. Things that can go wrong with circuits designed in this way are examined. The application of the techniques is discussed.<>", "num_citations": "14\n", "authors": ["1572"]}
{"title": "The ideal of verified software\n", "abstract": " The ideal of verified software has long been the goal of research in Computer Science. This paper argues that the time is ripe to embark on a Grand Challenge project to construct a program verifier, based on a sound and complete theory of programming, and evaluated by experimental application to a large and representative sample of useful computer software.", "num_citations": "13\n", "authors": ["1572"]}
{"title": "A model for synchronous switching circuits and its theory of correctness\n", "abstract": " Following Bryant [2], an algorithm is given for translating a switching circuit design into a program that simulates its dynamic behavior. A theory of assertions based on Dijkstra [5] and UNITY [4] is then developed to formalize specifications of hardware circuit designs and to establish their correctness. Both combinational and sequential circuits are taken into account both in N-mos and C-mos; the latter turns out to be much simpler.", "num_citations": "13\n", "authors": ["1572"]}
{"title": "Data refinement refined\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "13\n", "authors": ["1572"]}
{"title": "Software engineering: A keynote address\n", "abstract": " This paper argues that our recent progress in the development of a sound programming methodology should not lead us to ignore the more difficult aspects of engineering; and that in future we should pay more attention to the quality of our designs, and not just the accuracy of their implementation.", "num_citations": "13\n", "authors": ["1572"]}
{"title": "The 1980 acm turing award lecture\n", "abstract": " Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission.Delivered at ACM\u201980, Nashvile, Tennessee, October 27, 1980 Originally published in Communication of the ACM February 1981 Volume 24 Number 2\u00a9 1981 ACM 0001-0782/81/0200-0075 $00.75. Reprinted from: CAR Hoare. February 1981. The emperor\u2019s old clothes: The ACM Turing award lecture. Communication ACM 24, 2, 75\u201383. https://www. cs. fsu. edu/engelen/courses/COP4610/hoare. pdf. DOI: https://doi. org/10.1145/358549.358561.", "num_citations": "12\n", "authors": ["1572"]}
{"title": "Unifying models of data flow\n", "abstract": " We propose a model of computation, based on data flow, that unifies several disparate programming phenomena, including local and shared variables, synchronised and buffered communication, reliable and unreliable channels, dynamic and static allocation, explicit and garbage-collected disposal, fine-grained and coarse-grained concurrency, and weakly and strongly consistent memory.", "num_citations": "12\n", "authors": ["1572"]}
{"title": "CSP is a retract of CCS\n", "abstract": " Theories of concurrency can be distinguished by the set of processes that they model, and by their choice of pre-ordering relation used to compare processes and to prove their correctness. For example, theories based on CCS are often pre-ordered by simulation (or more commonly bisimulation), of which the main varieties are strong or weak or barbed. Theories based on CSP choose as their pre-order a refinement relation, defined as inclusion over sets of observations. The main varieties of observation are just traces, or failures and/or divergences. The processes of the CSP model are restricted to those that satisfy certain naturally arising \u2018healthiness conditions\u2019. This paper gives a unifying treatment of simulation and refinement, and illustrates it by the familiar varieties of CCS and CSP that are mentioned above.             We consider the variations two at a time. A link between two theories is a function L\u00a0\u2026", "num_citations": "12\n", "authors": ["1572"]}
{"title": "Algebraic derivation of an operational semantics.\n", "abstract": " Professional practice in a mature engineering discipline is based on relevant scientific theories, usually expressed in the language of mathematics. A mathematical semantics for a programming notation aims to provide a scientific basis for specification, design and implementation of computer programs expressed in that notation. The long-term goal is to improve the cost, quality, and duration of software engineering projects. Such a goal is akin to those of applied mathematics, but the most relevant concepts are discrete rather than continuous, and are taken from branches of logic and pure mathematics. The study of program semantics may be rationally structured into three main branches, differentiated by their style of presentation. The denotational style relates each program to a description of its observable properties and behaviour when executed. This style is most directly applicable to capture of requirements, and the establishment of correctness of specifications and designs, even before the program has been written. The process languages CSP [12] and occam [16] have been given a semantics in this style by Bill Roscoe and his colleagues at Oxford [4, 7, 8]. The algebraic style characterises a programming language by a somewhat complete collection of equations which are postulated to hold between programs. These can be used directly to reason about specifications, to transform designs, and to optimise programs for efficient execution. The process language ACP [2] has been defined primarily in algebraic style by Jan Bergstra and his colleagues in Amsterdam. The operational style [19] gives meaning to a program by showing how its\u00a0\u2026", "num_citations": "12\n", "authors": ["1572"]}
{"title": "Professionalism\n", "abstract": " Professionalism - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Professionalism Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1981). Professionalism. BCS\u201a Computer Bulletin, 2(29), 2\u20134. Copy APA Style MLA Style Hoare, CAR \u2026", "num_citations": "12\n", "authors": ["1572"]}
{"title": "The engineering of software: a startling contradiction\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "12\n", "authors": ["1572"]}
{"title": "Language hierarchies and interfaces: international summer school\n", "abstract": " Language Hierarchies and Interfaces: International Summer School \u2014 Eindhoven University of Technology research portal Skip to main navigation Skip to search Skip to main content Eindhoven University of Technology research portal Logo Help & FAQ English Nederlands Home Researchers Research output Organisational units Activities Projects Prizes Press / Media Facilities / Equipment Datasets Courses Research areas Student theses Search by expertise, name or affiliation Language Hierarchies and Interfaces: International Summer School FL Bauer (Editor), EW Dijkstra (Editor), A. Ershov (Editor), M. Griffiths (Editor), CAR Hoare (Editor), William A. Wulf (Editor), K. Samelson (Editor) Addenda op de Lotgevallen Research output: Book/Report \u203a Book \u203a Academic Overview Original language English Place of Publication Berlin Publisher Springer Number of pages 432 ISBN (Electronic) 9783540379720 ISBN (\u2026", "num_citations": "12\n", "authors": ["1572"]}
{"title": "Software design: a parable\n", "abstract": " Software Design: A Parable - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Software Design: A Parable Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1974). Software Design: A Parable. Software World, 5(9\u201310), 53\u201356. Copy \u2026", "num_citations": "12\n", "authors": ["1572"]}
{"title": "Unifying semantics for concurrent programming\n", "abstract": " Four well-known methods for presenting semantics of a programming language are: denotational, deductive, operational, and algebraic. This essay presents algebraic laws for the structural features of a class of imperative programming languages which provide both sequential and concurrent composition; and it illustrates the way in which the laws are consistent with the other three semantic presentations of the same language. The exposition combines simplicity with generality by postponing consideration of the possibly more complex basic commands of particular programming languages. The proofs are given only as hints, but they are easily reconstructed, even with the aid of a machine.", "num_citations": "11\n", "authors": ["1572"]}
{"title": "A theory of programming: Denotational, algebraic and operational semantics\n", "abstract": " Professional practice in a mature engineering discipline is based on relevant scientific theories, usually expressed in the language of mathematics. A mathematical theory of programming aims to provide a similar basis for specification, design and implementation of computer programs. The theory can be presented in a variety of styles, including", "num_citations": "11\n", "authors": ["1572"]}
{"title": "A theory for the derivation of combinational C-MOS circuit designs\n", "abstract": " This paper shows how propositional logic may be used to reason about synchronous combinational switching circuits implemented in C-mos. It develops a simple formalism and theory for describing and predicting their behaviour. On this it builds a calculus of design which is driven by proof obligations. The design philosophy for software introduced in [1] is thereby extended to a certain kind of hardware design. No prior knowledge of hardware is assumed of the reader; but useful background, motivation, examples and pictures may be found in [2]. Many of the problems described in that paper have been solved in this one.", "num_citations": "11\n", "authors": ["1572"]}
{"title": "Let's make models\n", "abstract": " Science makes progress by constructing mathematical models, deducing their consequences, and testing them by experiment. Such models are the basis for engineering methods and codes of practice for design of reliable and useful products. Models can play a similar central role in the progress and practical application of Computing Science.A model of a computational paradigm starts with choice of a carrier set of potential direct or indirect observations that can be made of a computational process. A particular process is modelled as the subset of observations to which it can give rise. Process composition is modelled by relating observations of a composite process to those of its components. Algebraic properties of such compositions are derived simply with the aid of set theory.", "num_citations": "11\n", "authors": ["1572"]}
{"title": "Categorical semantics for programming languages\n", "abstract": " The cartesian closed monoid [6] provides an algebraic semantics for an untyped lambda calculus; this language includes a surjective pairing (cons), partial functions, non-strict parameter passing and recursion. The cartesian closed category [7](with natural number objects) provides an Mgebric semantics for the typed lambda calculus, which includes cartesian products, discriminated unions, total functions and iteration. Topos theory [7] extends the range of definable functions and types.This paper applies categorica~ method to the definition of a range of conventioned programming languages, which include conditionals, non-determinism, non-termination, strictness, recursion, higher order procedures and even communications. A good example is Dijkstra's language with predicate transformer semantics [1]. To achieve this greater generality, we use a simple kind of 2-category theory, ie, a category whose homsets\u00a0\u2026", "num_citations": "11\n", "authors": ["1572"]}
{"title": "Algebraic specifications and proofs for communicating sequential processes\n", "abstract": " A restricted notation is suggested for the description of communicating sequential processes. The notation is defined by algebraic equations, which permit proof of further equations describing relevant properties of the operators. Equations are also used to specify and define the behaviour of particular processes, and to prove that they meet their specifications.               The examples cover a range of simple one-way communications devices between a single sender and a single receiver. A simple theory is used at first; this is extended when its inadequacies become too obvious.", "num_citations": "11\n", "authors": ["1572"]}
{"title": "Semantics of nondeterminism, concurrency and communication\n", "abstract": " One of the more important and active areas in the theory of programming languages is that of concurrent programs, specifically their design, definition, analysis and verification. Due to recent developments in the technology of microprocessors, there is a trend towards languages supporting distributed activities involving communication rather than concurrent activities on some shared resources, mainly memory, Thus, it becomes very important to supply adequate tools for the definition and analysis of such programs and programming languages, One recent attempt to define such a language was done by Hoare [I], where the language of CSP (communicating sequential processes) was presented formally. This is a language for the expression of nondeterministic, concurrent and communicating programs (see appendix for a short informal description). The main features which distinguish CSP are: a. Processes are\u00a0\u2026", "num_citations": "11\n", "authors": ["1572"]}
{"title": "The consistency of the calculus of total correctness for communicating processes\n", "abstract": " The Consistency of the Calculus of Total Correctness for Communicating Processes - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Report icon Report The Consistency of the Calculus of Total Correctness for Communicating Processes Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 \u2026", "num_citations": "10\n", "authors": ["1572"]}
{"title": "Does Chagas' disease exist in Asia?(Further contribution to this problem.).\n", "abstract": " This paper is a critique of that abstracted above [Weinman and Wiratmadja, abstr. 264]. Hoare points out that the\" two... different morphological types\" of\" mature trypanosomes\" developing in blood-agar cultures at 25 C and in tissue cultures at 35 C doubtless represented, respectively, metacyclic forms and bloodstream forms bloodstream forms Subject Category: Miscellaneous", "num_citations": "10\n", "authors": ["1572"]}
{"title": "Data Structures in Two\u2212 level Store\n", "abstract": " Data Structures in Two\u2212level Store - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Data Structures in Two\u2212level Store Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1969). Data Structures in Two\u2212level Store. Copy APA \u2026", "num_citations": "10\n", "authors": ["1572"]}
{"title": "The Elliott ALGOL input/output system\n", "abstract": " A description of the method of specifying input and output in ALGOL programs run on the National-Elliott 803 and the Elliott 503 digital computers.", "num_citations": "10\n", "authors": ["1572"]}
{"title": "Preface to special issue on software verification\n", "abstract": " The origins of software verification go back to the pioneers of Computing Science, von Neumann and Turing. The idea has been rediscovered several times since then, for example by McCarthy, Naur and Floyd. The ideals of verification have inspired half a century of productive computing research at the foundations of the subject. There are now flourishing research schools in computational logic, computer-aided proof, programming theory, formal semantics, specification and programming languages, programming methodology and software engineering. By the end of the last century, enormous progress had been made in verification theory and in tools to assist in its application. The technology of proof was extended to include constraint solving and model checking, which were routinely exploited in the electronics industry to increase confidence in the absence of errors in circuit designs before commitment to\u00a0\u2026", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Graphical models of separation logic\n", "abstract": " Labelled graphs are used to model control and data flow among events occurring in the execution of a (possibly concurrent) program. Data flow is a unifying concept that covers both access to memory and communication along channels; it covers many variations including weakly consistent memory, re-ordered execution, and communication channels that are multiplexed, buffered, or otherwise unreliable. Nevertheless, the laws of Hoare and Jones correctness reasoning remain valid when interpreted in this general model. The key is use of the same language and logic for the specification of programs as for description of the behavior of programs. We make no attempt to lift the level of abstraction above that of the atomic events involved in program execution.", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Fine-grain concurrency\n", "abstract": " I have been interested in concurrent programming since about 1963, when its associated problems contributed to the failure of the largest software project that I have managed. When I moved to an academic career in 1968, I hoped that I could find a solution to the problems by my research. Quite quickly I decided to concentrate on coarse-grained concurrency, which does not allow concurrent processes to share main memory. The only interaction between processes is confined to explicit input and output commands. This simplification led eventually to the exploration of the theory of Communicating Sequential Processes.             Since joining Microsoft Research in 1999, I have plucked up courage at last to look at fine-grain concurrency, involving threads which interleave their access to main memory at the fine granularity of single instruction execution. By combining the merits of a number of different theories\u00a0\u2026", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Equating bisimulation with refinement\n", "abstract": " Two-thirds simulation is equivalent to failures refinement if two redundant transition rules are added to the operational semantics of CCS. This paper also shows how to define a process calculus in which the concepts of simulation and mutual refinement coincide with testing equivalence: thus the combined benefits of all three approaches are available uniformly to all applications.", "num_citations": "9\n", "authors": ["1572"]}
{"title": "A trace model for pointers and objects\n", "abstract": " Object-oriented programs [5, 6, 10] are notoriously prone to the following kinds of error, which could lead to increasingly severe problems in the presence of tasking:                                             1.                                                 Following a null pointer;                                                                                        2.                                                 Deletion of an accessible object;                                                                                        3.                                                 Failure to delete an inaccessible object;                                                                                        4.                                                 Interference due to equality of pointers; and                                                                                        5.                                                 Inhibition of optimisation due to fear of (4).                                                                Type disciplines and object classes are a great help in avoiding these errors. Stronger protection may be obtainable with the help of assertions, particularly invariants\u00a0\u2026", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Unifying theories: a personal statement\n", "abstract": " The progress of science involves a constant interplay between diversification and unification. Diversification extends the boundaries of science to cover new and wider ranges of phenomena; successful unification reveals that a range of experimentally validated theories are no more than particular cases of some more general principle. The cycle continues when the general principle suggests further specializations for experimental investigation.", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Provably correct systems--FTRTFT'94 tutorial\n", "abstract": " ProCoS aims to improve dependability, reduce timescales and cut development costs of construction for embedded systems, particularly in real-time and safety-critical applications. It uses and develops the results of basic research into fundamental properties of interactive systems. It aims to provide a scientific basis for future standards of practice in the development of embedded systems, ensuring correctness of all stages in the development, from elicitation and analysis of requirements through design and implementation of programs down to compilation and execution on verified hardware.", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Fast Fourier transform free from tears\n", "abstract": " Many descriptions of Fast Fourier Transform exist in the literature. Several of these appeal to matrix concepts, such as Kronecker multiplication. This paper shows the essential simplicity of the algorithm and the reasoning behind it. However it deals only with the case when the number of points is an exact power of 2.", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Set manipulation\n", "abstract": " We next need a method of denoting sets as constants within a program. A convenient notation for doing this is to write\" se t (,,,.....)\", where the blanks between the commas are filled by constants denoting the elements of the set. Note that if two of the constants denote the same element, this is an error, to be detected at compile time. Also,\" set ()\" denotes the empty set.A run-time analogue of the set-constant is provided by a standard function\" unit set\", which takes a single parameter, and delivers as its result a set whose only member is the value of the parameter. This standard function could be taken as the implicit transfer function when a value which is not a set is assigned to a set variable, or subjected to set arithmetic. On the other hand, transfer from a set to an element should not be provided automatically by a translator for a high-level language.", "num_citations": "9\n", "authors": ["1572"]}
{"title": "Exploring an interface model for CKA\n", "abstract": " Concurrent Kleene Algebras (CKAs) serve to describe general concurrent systems in a unified way at an abstract algebraic level. Recently, a graph-based model for CKA has been defined in which the incoming and outgoing edges of a graph define its input/output interface. The present paper provides a simplification and a significant extension of the original model to cover notions of states, predicates and assertions in the vein of algebraic treatments using modal semirings. Moreover, it uses the extension to set up a variant of the temporal logic  for the interface model.", "num_citations": "8\n", "authors": ["1572"]}
{"title": "Algebra unifies operational calculi\n", "abstract": " We survey the well-known algebraic laws of sequential programming, and propose some less familiar laws for concurrent programming. On the basis of these laws, we derive a general calculus of program execution. The basic judgment of the theory is a quintuple, and we deduce its rules by algebraic reasoning. The general calculus can be specialised to obtain more familiar operational calculi, such as the structural operational semantics of Plotkin, process calculus semantics of Milner, reduction semantics with evaluation contexts of Felleisen and Hieb, and the natural semantics of Kahn. The algebra unifies these calculi, as it is simpler than each calculus derived from it, and stronger than all of them put together.", "num_citations": "8\n", "authors": ["1572"]}
{"title": "Unifying theories for parallel programming\n", "abstract": " The progress of science involves a constant interplay between diversification and unification. Diversification extends the boundaries of science to cover new and wider ranges of phenomena; successful unification reveals that a range of experimentally validated theories are no more than particular cases of some more general principle. The cycle continues when the general principle reveals further directions for experimental investigation. This paper suggests that the time has come to attempt a unifying classification of theories of parallel programming. Ideally, this should provide a common basis for reasoning about specifications and the correctness of designs, for optimising programs by algebraic transformation, and for implementing them in a range of technologies on a variety of machine architectures, to satisfy the needs of a wide range of applications.", "num_citations": "8\n", "authors": ["1572"]}
{"title": "A Theory of Conjunction and Concurrency.\n", "abstract": " This paper explores some general conditions under which the specification of a concurrent system can be expressed as the conjunction of specifications for its component processes. It proves a lattice-theoretic fixed point theorem about increasing functions, and gives examples of its application in several areas of computing science. Some consequences are drawn for the design of concurrent algorithms, high-level programming languages, and of finegrained concurrent com-puter architectures", "num_citations": "8\n", "authors": ["1572"]}
{"title": "Synchronisation of Parallel Processes\n", "abstract": " Synchronisation of Parallel Processes - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book Synchronisation of Parallel Processes Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1980). Synchronisation of Parallel Processes (FK Hanna, Ed.; pp. 108\u2013111\u2026", "num_citations": "8\n", "authors": ["1572"]}
{"title": "Prospects for a better programming language\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "8\n", "authors": ["1572"]}
{"title": "Minority report\n", "abstract": " Newcastle University e-prints Page 1 Newcastle University e-prints Date deposited: 12th August 2011 Version of file: Author final Peer Review Status:Peer reviewed Citation for item: Dijkstra EW, Duncan FG, Garwick JV, Hoare CAR, Randell B, Seegmueller G, Turski WM, Woodger M. Minority Report. ALGOL Bulletin 1970, 31, 7. Further information on publisher website: http://dl.ifip.org/ Publisher\u2019s copyright statement: The definitive version of this report was published by the International Federation for Information Processing, 1970. Always use the definitive version when citing. Use Policy: The full-text may be used and/or reproduced and given to third parties in any format or medium, without prior permission or charge, for personal research or study, educational, or not for profit purposes provided that: \u2022 A full bibliographic reference is made to the original source \u2022 A link is made to the metadata record in Newcastle E-\u2026", "num_citations": "8\n", "authors": ["1572"]}
{"title": "Further thoughts on record handling AB21. 3.6\n", "abstract": " The concepts of record handling are comparatively novel and unfamiliar in the field of general purpose programming languages, and it is desirable that they should be discussed~ refined, and extended before they reach their fullest usefulness. This paper is intended to initiate and contribute to such discussion, rather than to present final solutions to the problems involved.", "num_citations": "8\n", "authors": ["1572"]}
{"title": "A discrete geometric model of concurrent program execution\n", "abstract": " A trace of the execution of a concurrent object-oriented program can be displayed in two-dimensions as a diagram of a non-metric finite geometry. The actions of a programs are represented by points, its objects and threads by vertical lines, its transactions by horizontal lines, its communications and resource sharing by sloping arrows, and its partial traces by rectangular figures.               We prove informally that the geometry satisfies the laws of Concurrent Kleene Algebra (CKA); these describe and justify the interleaved implementation of multithreaded programs on computer systems with a lesser number of concurrent processors. More familiar forms of semantics (e.g., verification-oriented and operational) can be derived from CKA.               Programs are represented as sets of all their possible traces of execution, and non-determinism is introduced as union of these sets. The geometry is extended to multiple\u00a0\u2026", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Equating bisimulation with refinement\n", "abstract": " Two-thirds simulation is equivalent to failure refinement if two redundant transition rules are added to the operational semantics of CCS. This paper also shows how to define a process calculus in which the concepts of simulation and mutual refinement coincide with testing equivalence: thus the combined benefits of all three approaches are available uniformly to all applications.", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Assertions in modern software engineering practice\n", "abstract": " I recently conducted an e-mail survey among the Development Managers\u2019 Discussion Group in Microsoft at Redmond, asking for reports on interesting ways that assertions are now being used in Microsoft programming practice. In this talk, I will summarise the results of the survey, and speculate on ways in which assertions can contribute further advantage in speeding the development and maintenance of mass-market software, and the improvement of its quality. Although my examples draw on my experience in Microsoft, I expect that my experience generalises to other software Companies, and I am sure that many readers and developers of Open Source software are equally familiar with the benefits of assertions.Assertions have long been the topic of my academic research into the theory of programming; they are now a wide-spread feature of Microsoft coding and testing practice. In a modern release of Windows\u00a0\u2026", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Linking theories in probabilistic programming\n", "abstract": " This paper presents a theory of probabilistic programming based on relational calculus through a series of stages; each stage concentrates on a different and smaller class of program, defined by the healthiness conditions of increasing strength. At each stage we show that the notations of the probabilistic language conserve the healthiness conditions of their operands, and that every theory conserves the definition of recursion.", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Laws of programming\n", "abstract": " A complete set of algebraic laws is given for Dijkstra\u2019s nondeterministic sequential programming language. Iteration and recursion are explained in terms of Scott\u2019s domain theory as fixed points of continuous functionals. A calculus analogous to weakest preconditions is suggested as an aid to deriving programs from their specifications.", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Notes on communicating systems\n", "abstract": " Notes on Communicating Systems - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book Notes on Communicating Systems Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1985). Notes on Communicating Systems (M. Broy, Ed.; pp. 123\u2013204). Copy APA \u2026", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Towards a theory of communicating sequential processes\n", "abstract": " This paper extends the methods of a previous paper [] to describe nondetermi n ist ic processes. These are model \u0142 ed as sets of determ lnistic processes, The problem of concealment of internal commun i cation is solved, Some add i tional operators are defined, and the ir use ill ustrated in the des lgn of some s imple modules of an operat I ng system.", "num_citations": "7\n", "authors": ["1572"]}
{"title": "Laws of programming: The algebraic unification of theories of concurrency\n", "abstract": " I began my academic research career in 1968, when I moved from industrial employment as a programmer to the Chair of Computing at the Queen\u2019s University in Belfast. My chosen research goal was to discover an axiomatic basis for computer programming. Originally I wanted to express the axioms as algebraic equations, like those which provide the basis of arithmetic or group theory. But I did not know how. After many intellectual vicissitudes, I have now discovered the simple secret. I would be proud of this discovery, if I were not equally ashamed at taking so long to discover it.", "num_citations": "6\n", "authors": ["1572"]}
{"title": "A safety proof of a lazy concurrent list-based set implementation\n", "abstract": " We prove the safety of a practical concurrent list-based implementation due to Heller et al. It exposes an interface of an integer set with methods contains, add, and remove. The implementation uses a combination of fine-grain locking, optimistic and lazy synchronisation. Our proofs are hand-crafted. They use rely-guarantee reasoning and thereby illustrate its power and applicability, as well as some of its limitations. For each method, we identify the linearisation point, and establish its validity. Hence we show that the methods are safe, linearisable and implement a high-level specification. This report is a companion document to our PPoPP 2006 paper entitled \u201cProving correctness of highly-concurrent linearisable objects\u201d.", "num_citations": "6\n", "authors": ["1572"]}
{"title": "The IFIP working conference on verified software: Theories, tools, experiments\n", "abstract": " The VSTTE Working Conference yielded a good consensus on the shape of the Grand Challenge and the nature of the theories, tools, and experiments needed to achieve success in the envisioned fifteen-year time-frame. A number of relevant and interesting challenges have been identified, on varying scales and different degrees of difficulty. The more straightforward ones could be tackled immediately by existing tools, and might serve as useful pilot projects before the main work of the Challenge starts. Examples include a lightweight file system, embedded system controllers, and medical devices. The Grand Challenge activity will be centered around a digital repository containing a suite of tools, reference specifications and semantics, and challenge codes with specifications and annotations. Another focus will be the design of a formal tool bus to mediate the coarse-grained interaction between a variety of\u00a0\u2026", "num_citations": "6\n", "authors": ["1572"]}
{"title": "Fixed points of increasing functions\n", "abstract": " If d and e are increasing functions in a partial order, then the fixed points on their functional composition (d \u2218 e) are just the points that are fixed for both d and e. The same is true of a form of parallel composition (fx V gx), using the least upper bound V in the partial order. This fact may be useful in cases when fixed points are computed by iteration, with arbitrary mixture of sequential and parallel composition.", "num_citations": "6\n", "authors": ["1572"]}
{"title": "A theory for the derivation of C-mos circuit designs\n", "abstract": " This paper shows how propositional logic may be used to reason about synchronous sequential switching circuits implemented in C-mos. It develops a simple formalism and theory for describing and predicting their behaviour. On this it builds a calculus of design which is driven by proof obligations. The design philosophy for software introduced in [1] is thereby extended to a certain kind of hardware design.             No prior knowledge of hardware is assumed of the reader; but useful background, motivation, examples and pictures may be found in [2]. Many of the problems described in that paper have been solved in this one.", "num_citations": "6\n", "authors": ["1572"]}
{"title": "Algebraic specification and proof of properties of communicating sequential processes\n", "abstract": " A buffer i5 a\" e: o: amr1e of a ripe, 1. E'., a, HOCE'SS with a single input (narnel a\" the left and a singie output cha\" nel un the right. fI pair of pipes P aCid Ll can bEl assemblad Illtu a; Jif~ ql\" lonqpr pipe (p,\u00bb. U} b'l ccr'n~ cti I'q t~{1 rlq~ It channtll of P to: r\" S left channel of Ll. so thrJt all lliee'rJqli~ o'Jt. put by P artl slmult\" n8nti,, 11'lntJuL by Lj and vice IJ8r~\". Jt\"> l? se internal mes!';~ ges are cc\" r: e< l! ec. so that (I,)::>; l) is also a pipp. 111 which all a. tarnal 1nput g [le~ t: JP and ail e. ternai output co~ s from Ll.The a1gebr.) jc; properties of pipes in gp. nera1 and buffprs in prJrt! cular ara in\\! 8stigated in/;;, 4. f]. ror a d8~ igner of communications serIJic {ls, the mO: Jt importarJt properties are ttlat tJuffers can\\! aiid1y be composed In serle~ hy ttle chain1ng operetor\u00bb", "num_citations": "6\n", "authors": ["1572"]}
{"title": "Structure of an Operating System\n", "abstract": " This paper suggests that the structure of an operating system can be clearly expressed as a hierarchy of communicating sequential processes. The suggestion is illustrated by the development of an absurdly simple multiprogrammed batch processing system. It is hoped that the structuring methods and notations may be more widely useful.", "num_citations": "6\n", "authors": ["1572"]}
{"title": "The engineering of software: A startling contradiction\n", "abstract": " If words could cure the ills of our profession of programming, what a healthy and highly respected profession it would now be! We have had \u201cmodular programming\u201d; the craze for \u201cstructured programming\u201d has hardly yet reached the height of its commercial profitablity; and already we have a newcomer to the charts\u2014the theme we have all so long been waiting for\u2014yes, it\u2019s \u201cSOFTWARE ENGINEERING\u201d. The experienced programmer will greet the gladsome tidings with a stifled yawn, and turn to more urgent and important tasks. But perhaps there is something he could learn from these catch phrases on their passage from popularity to oblivion. Certainly, the latest combination of the new but already tarnished word \u201csoftware\u201d with the old and respected profession of engineering is such a startling contradiction that it should give us pause. Let us compare the ideals of the professional engineer with those\u00a0\u2026", "num_citations": "6\n", "authors": ["1572"]}
{"title": "Structured programming in introductory programming courses\n", "abstract": " Structured Programming in Introductory Programming Courses - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Structured Programming in Introductory Programming Courses Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1976). \u2026", "num_citations": "6\n", "authors": ["1572"]}
{"title": "Operating systems: Their purpose, objectives, functions, and scope\n", "abstract": " This paper proposes a definition of the purpose and'_objectives of an Operating System,. which is intended to clearly distinguish the responsibility of its designers from that of the designers of hardware, programming languages, utility routines, library procedures, and'other software. The definition is then applied to delimit the proper functions of various Operating Systems, working to meet various requirements in various \u201cdifferent circumstances.", "num_citations": "6\n", "authors": ["1572"]}
{"title": "A note on indirect addressing\n", "abstract": " Indirect addressing is a technique which permits a section of program (usually a procedure) to operate on simple variables held in any locations of the computer store, specified usually before the section of program is entered. It involves the storage of the actual address of the variable in the local workspace of the procedure; and this address is used unmodified whenever access to the variable is required. The technique of indirect addressing is the standard parameter mechanism in FORTRAN, and has been used for certain cases of the ALGOL name parameter specified as real, integer or Boolean. The technique has even been enshrined in the machine code of some computers.The purpose of this note is to point out certain undesirable consequences of the use of indirect addressing, especially when advanced hardware and software techniques for storage control are incorporated in the system. In all cases the use\u00a0\u2026", "num_citations": "6\n", "authors": ["1572"]}
{"title": "The Elliott ALGOL programming system\n", "abstract": " The Elliott ALGOL Programming System - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book The Elliott ALGOL Programming System Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1964). The Elliott ALGOL Programming System (P. Wegner, Ed.; pp. \u2026", "num_citations": "6\n", "authors": ["1572"]}
{"title": "Generic models of the laws of programming\n", "abstract": " The laws of programming are a collection of judgments about the equality and ordering of computer programs. A model of the laws is a mathematical description of the execution of programs, where the model has been proved to satisfy the laws. A generic model is one that has parameters that can be adjusted to the properties of a range of different programming languages and their differing implementations and differing applications. In this way, a generic model serves as the basis of a unifying theory of programming.", "num_citations": "5\n", "authors": ["1572"]}
{"title": "Compensable transactions\n", "abstract": " The concept of a compensable transaction has been embodied in modern business workflow languages like BPEL. This article uses the concept of a box-structured Petri net to formalise the definition of a compensable transaction. The standard definitions of structured program connectives are extended to construct longer-running transactions out of shorter fine-grain ones. Floyd-type assertions on the arcs of the net specify the intended properties of the transaction and of its component programs. The correctness of the whole transaction can therefore be proved by local reasoning.", "num_citations": "5\n", "authors": ["1572"]}
{"title": "Towards the verifying compiler\n", "abstract": " A verifying compiler is one that proves mechanically that a program is correct before allowing it to be run. Correctness of a program is defined by placing assertions at strategic points in the program text, particularly at the interfaces between its components. From recent enquiries among software developers at Microsoft, I have discovered that assertions are already used widely in program development practice. Their main r\u00f4le is as test oracles, to detect programming errors as close as possible to their place of occurrence. Further progress in reliable software engineering is currently supported by programmer productivity tools. I conjecture that these will be developed to exploit assertions of various kinds in various ways at all stages in program development. Eventually assertions will be used more widely for their original purpose of establishing important aspects of the correctness of large programs. However\u00a0\u2026", "num_citations": "5\n", "authors": ["1572"]}
{"title": "A calculus for the derivation of C-MOS switching circuits\n", "abstract": " This paper presents a method for correct design of C-mos switching circuits by simple calculation checked by occasional proof. It meets many of the criteria. proposed in an earlier less successful paper [Hoare and Gordon]. Indeed, it provides a model which might be emulated in the search for new design methods in other branches of engineering, for example, software. However, no claim is made for its practical utility in hardware design.", "num_citations": "5\n", "authors": ["1572"]}
{"title": "A Theory of Non\u2212 determinism\n", "abstract": " A Theory of Non\u2212determinism - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book A Theory of Non\u2212determinism Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & Kennaway, JR (1980). A Theory of Non\u2212determinism (pp. 338\u2013350). Copy APA Style \u2026", "num_citations": "5\n", "authors": ["1572"]}
{"title": "Hints on the Design of a Programming Language for Real\u2212 time Command and Control\n", "abstract": " Hints on the Design of a Programming Language for Real\u2212time Command and Control - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book Hints on the Design of a Programming Language for Real\u2212time Command and Control Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 \u2026", "num_citations": "5\n", "authors": ["1572"]}
{"title": "Structured programming\n", "abstract": " As you\u2019ve probably guessed by now, structured design is not just about giving programs structure. The idea of structure with respect to this design paradigm is to view a program as one big, fluid procedure. The procedure is the forefront of the program. Every real-world problem is first changed into a procedure that logically progresses to the desired result. The big procedure is then broken down into small pieces, but each piece is still just another procedure that solves a portion of the big procedure problem.When this approach is used to solve a problem, all real-world problems are first converted into computer problems. In other words, a programmer must think like the computers of a few years ago that could only perform one step in a set of instructions at a time. Such a computer sees everything as step-by-step instructions, so that\u2019s what must be created\u2014a collection of step-by-step instructions.", "num_citations": "5\n", "authors": ["1572"]}
{"title": "Subscript optimisation and checking\n", "abstract": "", "num_citations": "5\n", "authors": ["1572"]}
{"title": "Cleaning up the for statement\n", "abstract": " It is obviously possible to do without the for statement, and to construct loops from goto statements. The purpose of having for statements is:", "num_citations": "5\n", "authors": ["1572"]}
{"title": "A ProCoS\u2212 WG Working Group Final Report: ESPRIT Working Group 8694\n", "abstract": " An overview of the activities of the European collaborative ESP\u00cdRIT ProCoS-WG Working Group (no. 8694) on \u201cProvably Correct Systems\u201d which ran from 1993 to 1997 is presented. This was a follow-on to the ESPRIT BRA ProCoS I project (no. 3104, 1989\u20131991) and ProCoS II project (no. 7071, 1992\u20131995), overlapping with the latter. A selected bibliography of publications, especially those involving the original project sites and collaboration between member sites, is included.", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Verification of fine-grain concurrent programs\n", "abstract": " Intel has announced that in future each standard computer chip will contain many processors operating concurrently on the same shared memory; their use of memory is interleaved at the fine granularity of individual memory accesses. The speed of the individual processors will never be significantly faster than they are today. Continued increase in performance will therefore depend on the skill of programmers in exploiting the concurrency of this multi-core architecture. In addition, programmers will have to avoid increased risks of race conditions, non-determinism, deadlocks and livelocks. To reduce these risks, we propose a theory of correctness for fine-grain concurrent programs. The approach is just an amalgamation of a number of well-known and well-researched ideas, including flowcharts, Floyd assertions, Petri nets, process algebra, separation logic, critical regions and rely/guarantee reasoning. These\u00a0\u2026", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Science and Engineering: A collusion of cultures\n", "abstract": " The cultures of science and engineering are diametrically opposed along a number of dimensions: long-term/short-term, idealism/compromise, formality/ intuition, certainty/risk management, perfection/ adequacy, originality/familiarity, generality/specificity, unification/diversity, separation/amalgamation of concerns. You would expect two such radically different cultures to collide. Yet all the technological advances of the modern era result not from their collision but from their collusion-in its original sense of a fruitful interplay of ideas from both cultures. The author illustrates these points by the example of research into program verification and research into dependability of systems. The first of these aims at development and exploitation of a grand unified theory of programming, and therefore shares more the culture of science. The second is based on practical experience of projects in a range of important computer\u00a0\u2026", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Legacy\n", "abstract": " An increasing proportion of the effort of skilled programmers is devoted to servicing the legacy of software. The techniques and tools currently in use to tackle the problem take good advantage of the results of past research into programming theory. I suggest that new generations of tools will be based on concepts and principles developed by basic research of the present and by future research directed at currently outstanding challenges. These points are illustrated by examples drawn from my personal experience. They show that academic research and education can contribute to industrial development and production in an atmosphere of mutual respect for their different allegiances and timescales, and in recognition of convergence of their long-term goals.", "num_citations": "4\n", "authors": ["1572"]}
{"title": "A hard act to follow\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Software: Barrier or frontier\n", "abstract": " In recent times, the capabilities of computers and of communication systems have im-proved by many orders of magnitude. Every year the frontiers are being pushed forward at an increasing rate by the amazing skill of researchers, inventors, designers and production engineers; and yet further advances are con\ufb01dently predicted for the years to come. But everyone knows that an exponential rate of progress cannot be maintained forever. Frontiers can be advanced only until they meet absolute barriers imposed by physics\u2014the speed of light and the imprecision of quantum mechanics. It may be ten or it may be \ufb01fty years hence\u2014that I do not wish to argue about. IThe purpose of my tall: is to share with you a more immediate fear. I am afraid that the full potential for advance of the frontiers of communication technology is already inhibited by the problems of complexity of computer programs and software; that these\u00a0\u2026", "num_citations": "4\n", "authors": ["1572"]}
{"title": "The ProCoS approach to the design of real-time systems: Linking different formalisms\n", "abstract": " ... The automatic computer, by virtue of its fantastic speed, was the rst (mechanism) to provide an environment with enough\\room\" for highly hierarchical artifacts. And in this respect the challenge of the programming task seems indeed without precedent (in science and engineering)...'The past 20 years have seen much progress in developing suitable theories to assist programming within the levels of the hierarchy. In particular, speci cation and design languages with well-developed techniques for reasoning about properties of the described quantities. The universal use of problem oriented programming languages, module libraries, and the increasing use of formal speci cations in industrial practise testi es to the success of the research e ort during those years. However, the rapid development of electronics has in the mean time given us highly complex microprocessors and the potential to produce specialized circuits comparable in complexity to programs, all with a very low production cost. The hierarchy of programmed artifacts has expanded and what could once be regarded as a lowest level, eg the computer, is now yet another specialized component for which a design must be speci ed. This broader scope means that it is hard to imagine one convenient speci cation language which can describe essential facets of every level of a complex system, as eg, the computing systems embedded in a modern car, a factory or even a photo copier. The challenge is therefore to deal with several speci cation languages within a single development. Here the years have helped, because they have given us a better understanding of the underlying\u00a0\u2026", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Algebraic specification and proof of properties of a mail service\n", "abstract": " Algebraic specification and proof of properties of a mail service | The IFIP TC2/WG 2.1 Working Conference on Program specification and transformation ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsThe IFIP TC2/WG 2.1 Working Conference on Program specification and transformationAlgebraic specification and proof of properties of a mail service Article Algebraic specification and proof of properties of a mail service Share on Authors: CAR Hoare View Profile , Jifeng He View Profile Authors Info & Affiliations Publication: The IFIP TC2/WG 2.1 Working Conference on Program specification and transformationJune 1987 \u2026", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Computer programming as an engineering discipline\n", "abstract": " Unlike engineering, computer programming has no well-established methods of attack. Even when it has, these methods are disregarded too often. How can an engineer's approach be made to computer programming?", "num_citations": "4\n", "authors": ["1572"]}
{"title": "High Level Programming Languages \u201athe Way Behind\n", "abstract": " High Level Programming Languages\u201a the Way Behind - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item High Level Programming Languages\u201a the Way Behind Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1973). High Level \u2026", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Report on the Elliott ALGOL translator\n", "abstract": " The Elliott ALGOL programming and operating system has been designed to suit the ne\u1ec3ds of an Elliott 503 computer installation which aliocates at least part of its time to running programs on a service basis. The main problem in operating a computing service js to maintain a high average number of programs processed in a given period, and in particular to reduce to a minimum thc timc spent in changing over from one program to the next.", "num_citations": "4\n", "authors": ["1572"]}
{"title": "Logic, algebra, and geometry at the foundation of computer science\n", "abstract": " This paper shows by examples how the Theory of Programming can be taught to first-year CS undergraduates. The only prerequisite is their High School acquaintance with algebra, geometry, and propositional calculus. The main purpose of teaching the subject is to support practical programming assignments and projects throughout the degree course. The aims would be to increase the student\u2019s enjoyment of programming, reduce the workload, and increase the prospect of success.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Algebra, Logic, Geometry: at the Foundations of CS\n", "abstract": " \u2022 Both sequential composition and concurrent composition are associative and have [] as unit \u2018proof\u2019: consider the diagrams\u2022 Both distribute (leftward and rightward) through disjunction This allows the implementation to make the choice of which disjunct to execute either at compile time or only just before execution the disjunction...... or at any time between.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Implementation Languages for Real\u2212 Time Systems\u2014II. Language Design\u2014General Comments\n", "abstract": " Implementation Languages for Real\u2212Time Systems \u2014 II. Language Design \u2014 General Comments - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Stats Export BibTeX EndNote RefWorks Report icon Report Implementation Languages for Real\u2212Time Systems \u2014 II. Language Design \u2014 General Comments Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. \u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Recovery blocks\n", "abstract": " We give a semantics for Brian Randell\u2019s recovery blocks, and show how they can be proved correct. The formalisation is expressed wholly in propositional logic.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Engineering Methods and Tools for Software Safety and Security\n", "abstract": " As a consequence of the wide distribution of software and software infrastructure, information security and safety depend on the quality and excellent understanding of its functioning. Only if this functionality is guaranteed as safe, customer and information are protected against adversarial attacks and malfunction. A vast proportion of information exchange is dominated by computer systems. Due to the fact that technical systems are more or less interfaced with software systems, most information exchange is closely related to software and computer systems. Information safety and security of software systems depend on the quality and excellent understanding of its functioning. The last few years have shown a renewed interest in formally specifying and verifying software and its role in engineering methods. Within the last decade, interactive program verifiers have been applied to control software and other critical applications. Software model checking has made strides into industrial applications and a number of research tools for bug detection have been built using automatic program-verification technology. Such solutions are high-level programming methods which provide strategies to ensure information security in complex software systems by automatically verified correctness. Based on the specific needs in applications of software technology, models and formal methods must serve the needs and the quality of advanced software engineering methods. This book provides an in-depth presentation of state-of-the-art topics on how to meet such challenges covering both theoretical foundations and industrial practice.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Software System Reliability and Security\n", "abstract": " \" Information security covers the protection of information against unauthorized disclosure, transfer, modification, and destruction, whether accidentally or intentionally. Quality of life in general and of individual citizens, and the effectiveness of the economy critically depends on our ability to build software in a transparent and efficient way. Furthermore, we must be able to enhance the software development process systematically in order to ensure software's safety and security. This, in turn, requires very high software reliability, ie, an extremely high confidence in the ability of the software to perform flawlessly. Foundations of software technology provide models that enable us to capture application domains and their requirements, but also to understand the structure and working of software systems and software architectures. Based on these foundations tools allow to prove and ensure the correctness of software's functioning. New developments must pay due diligence to the importance of security-related aspects, and align current methods and techniques to information security, integrity, and system reliability. The articles in this book describe the state-of-the-art ideas on how to meet these challenges in software engineering.\"", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Linking theories of concurrency\n", "abstract": " We construct a Galois connection between the theories that underlie CCS [7] and CSP [4]. It projects the complete transition system for CCS onto exactly the subset that satisfies the healthiness conditions of CSP. The construction applies to several varieties of both calculi: CCS with strong, weak or barbed simulation, and CSP with trace refinement or failures refinement, or failures/divergence. We suggest the challenge of linking other theories of concurrency by Galois connection.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Assertions: a personal perspective.\n", "abstract": " An assertion is a Boolean formula written in the text of a program, at a place where its evaluation will always be true\u2014or at least, that is the intention of the programmer. In the absence of jumps, it specifies the internal interface between the part of the program that comes before it and the part that comes after. The interface between a procedure declaration and its call is defined by assertions known as preconditions and post-conditions. If the assertions are strong enough, they express everything that the programmers on either side of the interface need to know about the program on the other side, even before the code is written. Indeed, such strong assertions can serve as the basis of a formal proof of the correctness of a complete program.In this paper, I will describe how my early experience in industry triggered my interest in assertions and their role in program proofs; and how my subsequent research at university\u00a0\u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Laws of Programming: a tutorial paper\n", "abstract": " Here are some of the familiar laws of arithmetic,\\lJhich apply to multiplication of real numbers.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Is There a Mathematical Basis for Computer Programming?\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Suggested Papers for the Top Ten Algorithms\n", "abstract": " PAPERS - Suggested Papers for the Top Ten Algorithms Suggested Papers for the Top Ten Algorithms http://people.sc.fsu.edu/~jburkardt/classes/tta_2015/papers.html John Backus, The history of Fortran I, II and III, ACM SIGPLAN Notices, Volume 13, Number 8, pages 165-180, August 1978. David Bailey, Integer Relation Detection, Computing in Science and Engineering, Volume 2, Number 1, January/February 2000, pages 24-28. Rick Beatson, Leslie Greengard, A short course on fast multipole methods. Isabel Beichl, Francis Sullivan, The Metropolis Algorithm, Computing in Science and Engineering, Volume 2, Number 1, January/February 2000, pages 65-69. Burton Bloom, Space-time Tradeoffs in Hash Coding with Allowable Errors, Communications of the ACM, Volume 13, Number 7, July 1970, pages 422-426. John Board, Klaus Schulten, The Fast Multipole Algorithm, Computing in Science and Engineering, \u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Matrix reduction\u2014an efficient method\n", "abstract": " The paper describes an efficient method for reduction of the binary matrices which arise in some school time-tabling problems. It is a development of that described by John Lions. It has been generalized and adapted to fit into the complete timetabling process; to use a more compact data representation and more efficient processing techniques; to take fuller advantage of possible available previous knowledge about the matrix. And it is designed as a structured program, which can readily be coded by the reader in the high level or low level programming language of his choice. Practical tests of the method have shown it to be a good basis for a realistic timetabling algorithm.", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Computer Science Department\n", "abstract": " Summary This paper develops Brinch-Hansen's concept of a monitor [l, 2, 31 as a method of structuring an operating system. It introduces a form of synchronization, describes a possible method of implementation in terms of semaphores, and gives a suitable proof rule. Illustrative examples inc1ude. a single resource scheduler, a bounded buffer, an alarm clock, a buffer pool, a disc head optimizer, and a version of the problem of readers and writers [4]. e", "num_citations": "3\n", "authors": ["1572"]}
{"title": "A Survey of Store Management Techniques: Part 2\n", "abstract": " A Survey of Store Management Techniques: Part 2 - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item A Survey of Store Management Techniques: Part 2 Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & McKeag, RM (1972). A \u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Critique of ALGOL 68\n", "abstract": " Critique of ALGOL 68 - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Critique of ALGOL 68 Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1968). Critique of ALGOL 68. ALGOL Bulletin, 29, 27\u201329. Copy APA Style MLA Style \u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Limitations on languages\n", "abstract": " Limitations on Languages - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Limitations on Languages Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1968). Limitations on Languages. Computer Weekly. Copy APA Style MLA Style \u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "The Axiomatic Method\n", "abstract": " The Axiomatic Method - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Report icon Report The Axiomatic Method Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1968). The Axiomatic Method. National Computing Centre. Copy APA Style MLA Style Hoare, CAR \u2026", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Single pass compilation. PL/I\n", "abstract": " defini tely h) \u00e7e reconnended to use a\" one-and-a-half-pass system\", which i nvolves a pre limi nary scan of the source programme in order to collect all the informati on on i dentifi ers that is requi red, and \u00ed n which the ma in part of the conpil at i on is per formcd i 1 ase concl scan of the source programme. The one-and-a-half-pass system has be en used by Dijkstra in his pi on e ering implementati on of ALGOL 60 for the X. l.. The s ollu ti on a ci opted by El J. i ott on the 803 and 503 was to make min or rest tri cti ons to Uh e All gol 1 anguage whic lh na dle it p oss\u2013si b1 e to be su 1 e that practically everything is dcc la red", "num_citations": "3\n", "authors": ["1572"]}
{"title": "Implementation Languages for Real\u2212 Time Systems\u2014I. Standardisation\u2014its Implementation and Acceptance\n", "abstract": " Implementation Languages for Real\u2212Time Systems \u2014 I. Standardisation \u2014 its Implementation and Acceptance - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Stats Export BibTeX EndNote RefWorks Report icon Report Implementation Languages for Real\u2212Time Systems \u2014 I. Standardisation \u2014 its Implementation and Acceptance Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Natural transformations and data refinement\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Hoare on programming\n", "abstract": " Hoare on Programming - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Hoare on Programming Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (2015). Hoare on Programming. Computer World UK. Copy APA Style MLA Style Hoare, CAR \u201c\u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Tomorrow's men: the role of the university\n", "abstract": " I should certainly be interested in such an article, which should be l 500-2000 words long. If possible, I should like to receive a draft before the end of January, together with a photograph of yourself and a short biographical note to accompany the article when published.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Testing and proving, hand-in-hand\n", "abstract": " The motivating ideal of my lifetime\u2019s scientific research has been that of program correctness, achieved with the aid of mathematical proof. As suggested by Turing, Floyd, and others, the proofs would be based on the decoration of a program with assertions, that would be proved true if ever they were evaluated at the point where they were written in the code. During my long academic career, I regarded program testing as the main rival technology, and feared that improvement in the practice of testing would delay development and application of the superior technology of proof.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Communicating sequential processes\n", "abstract": " This volume, like the symposium CSP25 which gave rise to it, commemorates the semi-jubilee of Communicating Sequential Processes. Tony Hoare\u2019s paper \u201cCommunicating Sequential Processes\u201d 1 is today widely regarded as one of the most influential papers in computer science. To commemorate it, an event was organized under the auspices of BCS-FACS (the British Computer Society\u2019s Formal Aspects of Computing Science specialist group). CSP25 was one of a series of such events organized to highlight the use of formal methods, emphasize their relevance to modern computing and promote their wider application. BCS-FACS is proud that Tony Hoare presented his original ideas on CSP at one of its first meetings, in 1978. The two-day event, 7\u20138 July 2004, was hosted by London South Bank University\u2019s Institute for Computing Research, Faculty of Business, Computing and Information Management. The\u00a0\u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Roger Michael Needham CBE FREng. 9 February 1935\u20131 March 2003: Elected FRS 1985\n", "abstract": " Roger Needham was born in Sheffield on 9 February 1935. He was the only son of Leonard William Needham and Phyllis Mary Needham (n\u00e9e Baker). Leonard and Phyllis had met in the first year chemical laboratory at Birmingham University and had duly graduated in that subject. At the time of Roger's birth, Leonard was a lecturer in the Mining Department at Birmingham, having become in effect a chemical engineer. When Roger was two years old the family moved to Sheffield, where Leonard took up an appointment with a company that made mineral separation plants, in which particles of coal were separated from lighter particles of incombustible material by flotation in a dense medium of suspended barytes.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Assertions in programming: From scientific theory to engineering practice\n", "abstract": " I first became interested in assertions when I took up my post as Professor of Computer Science at the Queen's University Belfast in 1968, I welcomed them first as a means of applying objective scientific judgement to the design and evaluation of computer programming languages. My subsequent academic research career was inspired by an ideal that assertions would contribute to the avoidance of programming error by means of mathematical proofAt the present day, assertions are widely used in program development practice, as I have found from a recent survey among software development managers in Microsoft. The main role of assertions is as test oracles, to detect programming errors as close as possible to their place of occurrence. In this talk I will describe a number of other ways in which assertions ar\u0119 found useful, and may become even more useful in future. All of then (fall far short of the hard, ideals\u00a0\u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Unifying theories of concurrency\n", "abstract": " A theory of concurrency provides a basis for reasoning about the behaviour of distributed interactive systems. Its goal is to give a conceptual framework for specifying systems, designing them, and implementing them correctly. Correctness is a relationship between two formulae expressed in the notations provided by the theory. Differing definitions have been adopted in a wide range of theories, for example, CCS, ACP, CSP, LOTOS and the pi-calculus; and each of these has many variations. Familiar examples of a correctness relation are: structural equivalence, reaction, algebraic reduction, bisimulation, refinement, and observational equivalence or inclusion; each of these has many variations. Each variation justly claims distinct advantages, for example, simple proof methods, mechanical model checking, guidance for practical implementation, support of operational intuition, high level of abstraction, or a clear\u00a0\u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Mathematical models for computing science\n", "abstract": " Mathematical models for computing science | Proceedings of the NATO Advanced Study Institute on Deductive program design ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsProceedings of the NATO Advanced Study Institute on Deductive program designMathematical models for computing science ARTICLE Mathematical models for computing science Share on Author: CAR Hoare profile image CAR Hoare View Profile Authors Info & Affiliations Publication: Proceedings of the NATO Advanced Study Institute on Deductive program designSeptember 1996 Pages 115\u2013164 0citation 0 Downloads Metrics Total Citations0 \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "An algebra of games of choice\n", "abstract": " The simplest game of choice is one whose outcome is determined by a single pair of moves: the player makes the first move by selecting a set p of possible outcomes; and the second move is made by the adversary, who selects the actual outcome from p. The rules of the game are therefore given by a family of sets of outcomes, and the player's choice is restricted to members of this family.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Formal Logic via Functional Programming\n", "abstract": " We investigate how formal logic can be introduced to students who are familiar with functional programming in a way that takes advantage of their familiarity with higher order functions, free data-types, homomorphisms, and induction principles. In our experience, students often struggle with formal logic because they are unclear about the distinction between theorems and metatheorems, the distinction between syntactic constructors and semantic operators (and hence the meaning of models and valuations), and the induction and recursion principles over proofs. Using a functional programming notation as a metalanguage clears up these ambiguities because of the imposed type discipline: theorems and metatheorems have distinctive types, so are easily distinguished; when operators are overloaded (for example, when they are used both in syntax and semantics) their di erent types can be written out; and the recursion and induction principles over proofs become straightforward because the data-type for proofs is explicitly described. As an added bene t, proofs| which are tree-structured| need not be arbitrarily linearized just so that natural number recursion and induction can be performed on them.We present a Gofer Jones91] functional program script that de nes datatypes for representing well-formed formulas, proofs, and sequents in the propositional logic. We then discuss the implementation of theorem and inference schemas and illustrate the latter by de ning a function ded that provides a constructive proof of the Deduction Theorem. We display a type for representing a boolean model of our logic and de ne the notion of a valuation for\u00a0\u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "A theory of engineering design\n", "abstract": " Boolean algebra is the mathematical theory which forms the basis of Computing Science and Information Engineering. It is applicable at all levels, from the collection and analysis of requirements for computer applications, through the specification and development of reliable computer programs, to the gates and wires that implement in hardware, the logic of the executing mechanism. Based on my experience in the study of computing, I suggest that Boolean algebra has an even wider role as the basis for a general methodology of engineering. For this paper, my examples are drawn from simple theories of electronic hardware design.< >", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Description of CONCUR\n", "abstract": " 2. SUMMARY\u00bb Formal verification of software programs, protocols and chip designs, is becoming increasingly important, as systems become more complex, production more expensive, and testing is widely recognized as being insuf\ufb01cient to guard against malfunction. Veri\ufb01cation of concurrent or distributed systems has up till now been undertaken only on a vcrv smail scale. in a haphazard wav. and with a multitude of techniques and formal", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Formal methods in computer system design\n", "abstract": " This note expounds a philosophy of engineering design which is stimulated, guided and checked by mathematical calculations and proofs. Its application to software engineering promises the same benifits as those derived from the use of mathematics in all other branches of modern science.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Design and Proof of a Mail Service\n", "abstract": " Design and Proof of a Mail Service - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book Design and Proof of a Mail Service Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & Jifeng, H. (1987). Design and Proof of a Mail Service (O. Friesen & F. Golshani, \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Specification of a Simplified Network Service in CSP\n", "abstract": " Specification of a Simplified Network Service in CSP - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Specification of a Simplified Network Service in CSP Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & Morgan, C. (1985). \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Control flow and data flow: Concepts of distributed programming\n", "abstract": " This book provides a description of approaches to the representation, specification, design and verification of distributed systems as well as very large scale integrated (VLSI) systems and parallel hardware architecture.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Case studies in specification: four games\n", "abstract": " Case studies in specification Four games - OpenGrey fra | eng OpenGrey Open System for Information on Grey literature in Europe Home Search Subjects Partners Export Help Search XML To cite or link to this reference: http://hdl.handle.net/10068/626501 Title : Case studies in specification Four games Author : Teruel, A. ; Corporate author : Oxford Univ. (UK). Programming Research Group ; Publication year : 1982 Language : English ; Pagination/Size : 63 p. ; SIGLE classification : 09H - Computer software, programming ; Keyword(s) : Case studies in specification [ system specification] ; Document type : R - Report ; Report number : PRG--30 ; Other identifier : GB ; GB_ 1984:2689 ; handle : http://hdl.handle.net/10068/626501 Provenance : SIGLE ; Get a copy : BLDSC - British Library Document Supply Centre Availability : LD:8671.22(PRG--30) Country : United Kingdom ; CNRS INIST Creative Commons Help Search \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "The high cost of programming languages\n", "abstract": " The High Cost of Programming Languages - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article The High Cost of Programming Languages Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1976). The High Cost of Programming \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Cooperation in education\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Matrix Reduction\u2014an Efficient Method (School Timetables)\n", "abstract": " Matrix Reduction\u2014an Efficient Method (School Timetables) - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article Matrix Reduction\u2014an Efficient Method (School Timetables) Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR, & Johnston, \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Program Correctness Proofs\n", "abstract": " Program Correctness Proofs - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book Program Correctness Proofs Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1975). Program Correctness Proofs (B. Shaw, Ed.; pp. 7\u201345). Copy APA Style MLA Style \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "A general conservation law for queueing disciplines\n", "abstract": " * wiito = ,:i!I: qa$o~ Page 1 IWORM 4TION PROCJZSSI[NG LETTERS 2 (1972) 82-85. NORTH-HOLLAND FUBLISHIhG COWAN-Y A GENERAL CONSERVATION LAW FOR QUEUbNG DISCIPLINES CAR HOARE &P@rMnt of COmplrJer Science, The Queen\u2019s University o j Belfast, Beljbst, Northern keland Received 15 June 1973 theory of scheduling resource allocation operating systems Number the total set of customers between 1 and N. Let functions W#) and Rl(t) be defined for 0 Q t GT as folluw s: W@) = I, 1-f customer i is waiting at time t; Ri(t) = 1, if customer i is being served at time t; - 0, otherwise. = 0, otherwise. The following defmiGons are introduced. Their explanations should be checked. is the total waiting time for customer 4\u2019. is the rota1 servke time for customer i. is the total future service time for customer i at moment X. is the total past waitbg time for customer i up to moment x. * wiito = ,:i!I: qa$o~ is the \u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Initialisation of variables\n", "abstract": " One of the most irritating of programming errors is the failure to assign a value to a variable before using it. This error is one which is difficult to trace to its source, particularly if it gives rise to different results on different runs of the same program, and hardware faults are suspected. For users of a high-level programming language, a special problem arises, since the results of the run are in principle unpredictable within the terms of the programming language itself, and can only be explained in terms of octal dumps, etc.For this reason, many implementation of a high-level programming language will set all variables to a standard value, say zero, before entering a users program. In FORTRAN, which has only static allocation of storage, this involves only a negligible penalty in increased run time, since it is a once-for-all process. For ALGOL, which permits allocation of store at run time, the clearing of store adds a small\u00a0\u2026", "num_citations": "2\n", "authors": ["1572"]}
{"title": "File processing\n", "abstract": " ii or, to my mind, is it a sufficient answer to say that the copy rule can still be used, but must be stated as having this exception. One of the most annoyin}: things in any language (whether computer language or human language) is a rule with exceptions. One of the most delightful things about Algol 60 is that it has so few exceptions. Let us~ et rid of the few that exist rather than introduce ne;; ones.1 [ed [cal Research Council, statistical Research Uni t, 115 Gowec Street, London WoCo lo", "num_citations": "2\n", "authors": ["1572"]}
{"title": "A Programming Language for Processor Construction\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "2\n", "authors": ["1572"]}
{"title": "Tracelets and specifications\n", "abstract": " In the accompanying paper [1] the authors study a model of concurrent programs in terms of events and a dependence relation, ie, a set of arrows, between them. There also two simplifying interface models are presented; they abstract in different ways from the intricate network of internal points and arrows of program components. This report supplements [1] by presenting full proofs for the properties of the interface models, in particular, that both models exhibit homomorphic behaviour wrt sequential and concurrent composition.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Parallel programming\n", "abstract": " Some thesis volumes scanned as part of the digitisation scheme funded by Dr Leonard Polonsky are currently unavailable due to sensitive material or uncleared third-party copyright content. We are attempting to contact authors whose theses are affected.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Parallel Processing: Theoretical Foundations\n", "abstract": " My first and most painful encounter with the problems ofparallel processing occurred in I965, when I was in charge ofan operating system project for a small computer manufacturer. Complete failure of that project has led me since that time to devote my main practical and theoretical research to the topic of parallelism. The results of widespread research are nov available for practical application, at a time when economics, technology, commercial availability and even ultimate physical linits dictate that the next advance in highspeed computation must involve parallel processing.My task is to explain the basic concepts of parallel processing and how they apply equally to hardware and to software, to microscopic as well as macroscopic parallelism. The necessary abstraction has been achieved by some rather deep mathematical research, but I hope to show that the results are as simple and memorable and usable as\u00a0\u2026", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Net models for concurrent object behaviour\n", "abstract": " The behaviour of an object allocated and used by a computer program consists of a set of events involving the object which occur in and around a computer during execution of the program. Object behaviour can be modelled by an occurrence net (a Petri net without places), in which each event is a transition (drawn as a box), and the arrows between the transitions represent dependency between the events. The total behaviour of the program is just the sum of the behaviours of the objects which it allocates. A program (perhaps expressed as a Petri net with places) is mathematically defined as just the set of all its possible behaviours, in all its possible environments of execution. An object class is similarly defined as the set of all the possible behaviours of all its possible objects, as used in any possible program.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Message of thanks: on the receipt of the 2011 ACM SIGPLAN distinguished achievement award\n", "abstract": " Even to one who has lived long enough to receive many awards, the recognition of distinguished achievement from the scientific community in one\u2019s own research field is surprisingly welcome. I particularly treasure the SIGPLAN citation for my award, which singles out exactly the modest achievements of which I am most proud. I have known nearly all the previous winners of this award, and they number among my professional colleagues, rivals, and friends. I have derived inspiration from them all, and I am pleased to be regarded in their company.The award prompts me to reflect again on the origins and progress of my professional career: how did I select the topics for my research? What methods did I consider appropriate for an academic researcher to pursue such research? What is the current level of maturity of research on these topics? What does the future hold for it? Why do I regard my renewed interest in\u00a0\u2026", "num_citations": "1\n", "authors": ["1572"]}
{"title": "The Michael Jackson Design Technique: A study of the theory with applications\n", "abstract": " This paper reproduces a report written by Hoare in 1977, in which he explains the fundamental ideas of Jackson\u2019s programming method, JSP. The notions that Hoare uses for this purpose\u2013program traces, selective traces, and combination of selective programs\u2013appeared in the following years in the conceptual foundation of his process algebra, CSP. Hoare shows that the key step in the JSP method, in which multiple stream structures are merged to form a single program structure, can be viewed in two phases. First, each stream\u2013represented as a regular expression\u2013is transformed by applying simple algebraic equalities into an equivalent structure, matching the structures obtained from the other streams. Second, these structures are merged. The paper also includes a wider discussion about the scope and nature of JSP. A new introduction provides some context, and presents in full the examples that Hoare alludes to in his report.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Assersions\n", "abstract": " CiNii \u8ad6\u6587 - Assersions CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003 \u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 Assersions HOARE CAR \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 HOARE CAR \u53ce\u9332\u520a\u884c\u7269 Models, Algebras and Logic of Engineering Software Models, Algebras and Logic of Engineering Software, 2003 IOS Press \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u30d7\u30ed\u30b0\u30e9\u30e0\u7c21\u6613\u691c\u8a3c\u30c4\u30fc\u30ebESC/Java2 \u4e2d\u5cf6 \u9707 , Shin Nakajima , \u56fd\u7acb\u60c5\u5831 \u5b66\u7814\u7a76\u6240 , National Institute of Informatics \u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2 24(2), 2-7, 2007-04-24 \u53c2\u8003 \u6587\u732e12\u4ef6 \u88ab\u5f15\u7528\u6587\u732e3\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10019649669 \u8cc7\u6599\u7a2e\u5225 \u56f3\u66f8 \u306e\u4e00\u90e8 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u66f8\u304d\u51fa\u3057 Mendeley\u306b\u2026", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Assert Early \u201aAssert Often\n", "abstract": " That is why the PREfix assertion macro requires a second gSAAAA eee, a string jrf which te pregerrrrrer can explai\u0146quite AM informally the reason why the first parameter will always be true. CBBBS The more obscure the reason, the greater the value of the explanation. Unexplained assertions can be seen from records in the RAID programrdefectrdatabase to generate grief when they fire in later releases of the same program.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Unifying theories of healthiness condition\n", "abstract": " A theory of programming starts with a complete Boolean algebra of specifications, and defines healthiness conditions which exclude infeasibility of implementation. These are expressed as algebraic laws useful for transformation and optimisation of designs. Programming notations and languages must be restricted to those preserving all the healthiness conditions. We have explored a wide range of programming paradigms, including nondeterministic, sequential, parallel, logical and probabilistic. In all cases, we have found a single healthiness condition, formalised by constructions due to Karoubi and to Kleisli. The uniformity maintains for all paradigms a single notion of correctness throughout the chain that leads from specification through designs to programs that are proved to meet the original specification.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Legacy code\n", "abstract": " An increasing proportion of the effort of skilled programmers is devoted to servicing the legacy of software already in use. The techniques and tools currently in use to tackle the problem take good advantage of the results of past research into programming theory. I suggest that new generations of tools will be based on concepts andprinciples developed by basic research of the present, and by future research directed at currently outstanding challenges. These points are illustrated by examples drawn@ om my personal experience. They show that academic research and education can contribute to industrial development and production, in an atmosphere of mutual respect for their different allegiances and timescales, and in recognition of convergence of their long-term goals.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "of the Programming Language\n", "abstract": " The FORTRAN project was begun in the summer of 1954. Its purpose was to reduce by a large factor the task of preparing scientific problems for IBM's next large computer, the 704. If it were possible for the 704 to code problems for itself and produce as good programs as human coders (but without the errors), it was clear that large benefits could be achieved. For it was known that about two-thirds of the cost of solving most scientific and engineering problems on large computers was that of problem preparation. Furthermore, more than 90 per cent of the elapsed time for a problem was usually devoted to planning, writing, and debugging the program. In many cases the development of a general plan for solving a problem was a small job in comparison to the task of devising and coding machine procedures to carry out the plan. The goal of the FORTRAN project was to enable the programmer to specify a numerical procedure using a concise language like that of mathematics and obtain automatically from this specification an efficient 704 program to carry out the procedure. It was expected that such a system would reduce the coding and debugging tasks to less than one-fifth of the job it had been.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Will proof replace simulation?\n", "abstract": " Within industry, the almost universally accepted method of validating a design against its requirement involves extrapolation from simulation of a (comparatively) small number of test cases to the behaviour of the complete circuit. That such an extrapolation is in general unjustifiable is widely accepted, but despite theorem provers\u2019 ability to provide a mo^e robust link between specification and circuit design, very few industrial engineers are using theorem provers on a daily basis. This paper aims to consider some of the factors that may be preventing the wider application of proof methods. Specifically, RSRE has concentrated on two areas of research: the development of a largely automatic but functionally limited proof system, and more recently on a more general prover based on the concepts of a hardware description language. It is hoped to illustrate that these provers, being designed specifically for hardware\u00a0\u2026", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Programming: Sorcery or Science?\n", "abstract": " Reprinted from IEEE Software, April 1984, pagei 5-1 6. Copyright &1984 by The Institute of Electrical and Electronic! Engineers, Inc. All rights reserved. explain how or why he did what he did, yet he worked effectively, by himself or in a small team, and could usually complete the tasks he under-took within a predictable timescale, at a fixed cost and with results that were satisfactory to his clients. The programmer of today shares many attributes with the craftsman of yesterday. He learns his craft by a short but highly paid apprenticeship in an existing programming team engaged in some ongoing project, and he develops his skills by ex-perience rather than by reading books or journals. He knows little of the logical and mathematical founda-tions of his profession. He does not like to explain or document his ac-tivities. Yet he works effectively, by himself or in small teams, and he sometimes manages to complete the tasks he undertakes at the predicted time, within the predicted costs, and to the satisfaction of his client. wrath of his deity\u2014the high priest himself had no inner understanding of the ways of his god. The best the client could hope for was to go right back to the beginning and start the spell again. If this did not work, he went back to the high priest to get a new spell.And that brings up another feature of the priesthood. When something went wrong, as it quite often did, somehow it was always caused by the client's ignorance or stupidity or im-purity or wickedness. It was never the fault of the high priest or his god. When the harvest failed, it was the high priest who sacrificed the king, never the other way around.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "ESPRIT BRA 3104 ProCoS project: Provably Correct Systems\n", "abstract": " A compiler is speci ed by a description of how each construct of the source language is translated into a sequence of object code instructions. The meaning of the object code can be de ned by an interpreter written in the source language itself. A proof that the compiler is correct must show that interpretation of the object code is at least good (for any relevant purpose) as the corresponding source program. The proof is conducted using standard techniques of data re nement. All the calculations are based on algebraic laws governing the source language. The theorems are expressed in a form close to a logic program, which may used as a compiler prototype, or a check on the results of a particular compilation. A subset of the occam programming language and the transputer instruction set are used to illustrate the approach. An advantage of the method is that it is possible to add new programming constructs without a ecting existing development work.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Future developments in the CAD environment\n", "abstract": " This paper presents the views of ICL, a major UK computer manufacturer, on future developments in the CAD environment. A particular emphasis is placed on the role of mainframes, particularly when used in networks linked to workstations. ICL believes that the next 5\u201310 years will see a transformation in the design office, in a similar fashion to that which has occured through the computerization of the accounting office.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "1983 Technology Forecast\n", "abstract": " 1983 Technology Forecast - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Journal article icon Journal article 1983 Technology Forecast Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Hoare, CAR (1983). 1983 Technology Forecast. Electronic Design. Copy APA Style MLA \u2026", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Computer Science: An Inaugural Lecture Delivered Before the Queen's University of Belfast on 10 February 1971\n", "abstract": " IN University circles it is a pleasant and informative custom when introducing members of staff to mention the academic department to which they belong. The same custom is extended to our wives, who, like the wives of peers, assume their husbands' titles. But one drawback in this mode of introduction is that it frequently leads to further conversation on academic topics. In my case, this is often introduced by an open admis-sion that my new acquaintance has never been able to understand com-puters. I wonder whether others have found an acceptable response to this conversational gambit. There is the temptation to joke:", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Critique of MR93\n", "abstract": " I believe that the essential problem in the design of selfextending languages is in the design of the nucleus of built-in features, which the implementor will be expected to represent within the machine code of his computer. It is essential that this nucleus should have the properties: i. Extreme simplicity and small size: it should contain the minimum of features, and each feature should be structurally simple. Any structurally complex features should be left to be inserted by the self-exlension mechanism. In fact, the inclusion of elaborate features in the nucleus is an immediate ad~: ission of failure in design of the self-extension mechanism. Some of the defects in the MR 93 self-extension mechanism are listed in Appendix I.. Extreme efficiency of implementation: one of the main practical limitations of the utility of the self-extension mechanism will be the resulting inefficiency (in space and time) of the extended language\u00a0\u2026", "num_citations": "1\n", "authors": ["1572"]}
{"title": "Text processing\n", "abstract": " In the early days after the publication of AIC, OL 60, it was widely thought that the undeveloped concept of the string would provide a key to excitin6 possibilities of language extension. Several detailed proposals were worked out, but failed to live up to their early promise.", "num_citations": "1\n", "authors": ["1572"]}
{"title": "How some fundamental problems are treated in the design of the TRAC language\n", "abstract": " TRAC is a macrogenerator language operating on character strings with versatile interactive capabilities at run time. Unlike many symbol processing or programming languages, it operates at the literal string level instead of at the name level. It uses an explicit functional notation, and has the ability to interpolate any action or value-producing function at any point in any procedural statement. TRAC treats procedural statements the same as general character strings, with the result that any procedure can act on itself as well as on other procedures, thus giving completely general self-referencing capabilities. The representation of the varieties of\" nothing\" has been a source of great confusion in many languages, and the manner of treatment of this problem in TRAC is discussed. A brief mention is given of the manner of use of TRAC at other installations, where advantage is taken of its uniform syntax and modular construction to extend its capabilities in other directions of local interest. This is done through the definition of new functions which are uniform in syntax and philosophy with the rest of the language.", "num_citations": "1\n", "authors": ["1572"]}