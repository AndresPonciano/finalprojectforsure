{"title": "Pex\u2013white box test generation for. net\n", "abstract": " Pex automatically produces a small test suite with high code coverage for a .NET program. To this end, Pex performs a systematic program analysis (using dynamic symbolic execution, similar to path-bounded model-checking) to determine test inputs for Parameterized Unit Tests. Pex learns the program behavior by monitoring execution traces. Pex uses a constraint solver to produce new test inputs which exercise different program behavior. The result is an automatically generated small test suite which often achieves high code coverage. In one case study, we applied Pex to a core component of the .NET runtime which had already been extensively tested over several years. Pex found errors, including a serious issue.", "num_citations": "1162\n", "authors": ["269"]}
{"title": "Parameterized unit tests\n", "abstract": " Parameterized unit tests extend the current industry practice of using closed unit tests defined as parameterless methods. Parameterized unit tests separate two concerns: 1) They specify the external behavior of the involved methods for all test arguments. 2) Test cases can be re-obtained as traditional closed unit tests by instantiating the parameterized unit tests. Symbolic execution and constraint solving can be used to automatically choose a minimal set of inputs that exercise a parameterized unit test with respect to possible code paths of the implementation. In addition, parameterized unit tests can be used as symbolic summaries which allows symbolic execution to scale for arbitrary abstraction levels. We have developed a prototype tool which computes test cases from parameterized unit tests. We report on its first use testing parts of the .NET base class library.", "num_citations": "296\n", "authors": ["269"]}
{"title": "DySy\n", "abstract": " Dynamically discovering likely program invariants from concrete test executions has emerged as a highly promising software engineering technique. Dynamic invariant inference has the advantage of succinctly summarizing both \"expected\" program inputs and the subset of program behaviors that is normal under those inputs. In this paper, we introduce a technique that can drastically increase the relevance of inferred invariants, or reduce the size of the test suite required to obtain good invariants. Instead of falsifying invariants produced by pre-set patterns, we determine likely program invariants by combining the concrete execution of actual test cases with a simultaneous symbolic execution of the same tests. The symbolic execution produces abstract conditions over program variables that the concrete tests satisfy during their execution. In this way, we obtain the benefits of dynamic inference tools like Daikon: the\u00a0\u2026", "num_citations": "279\n", "authors": ["269"]}
{"title": "Model-based testing of object-oriented reactive systems with Spec Explorer\n", "abstract": " Testing is one of the costliest aspects of commercial software development. Model-based testing is a promising approach addressing these deficits. At Microsoft, model-based testing technology developed by the Foundations of Software Engineering group in Microsoft Research has been used since 2003. The second generation of this tool set, Spec Explorer, deployed in 2004, is now used on a daily basis by Microsoft product groups for testing operating system components, .NET framework components and other areas. This chapter provides a comprehensive survey of the concepts of the tool and their foundations.", "num_citations": "241\n", "authors": ["269"]}
{"title": "Approximating finite domains in symbolic state exploration\n", "abstract": " A finite domain approximation for symbolic terms of a symbolic state is derived, given some finite domains for basic terms of the symbolic state. A method is executed recursively for symbolic sub-terms of a symbolic term, providing a domain over-approximation that can then be provided to a solver for determining a more accurate domain. The method can be applied to a wide array of system terms, including, for example, object states, arrays, and runtime types.", "num_citations": "225\n", "authors": ["269"]}
{"title": "Path feasibility analysis for string-manipulating programs\n", "abstract": " We discuss the problem of path feasibility for programs manipulating strings using a collection of standard string library functions. We prove results on the complexity of this problem, including its undecidability in the general case and decidability of some special cases. In the context of test-case generation, we are interested in an efficient finite model finding method for string constraints. To this end we develop a two-tier finite model finding procedure. First, an integer abstraction of string constraints are passed to an SMT (Satisfiability Modulo Theories) solver. The abstraction is either unsatisfiable, or the solver produces a model that fixes lengths of enough strings to reduce the entire problem to be finite domain. The resulting fixed-length string constraints are then solved in a second phase. We implemented the procedure in a symbolic execution framework, report on the encouraging results and discuss\u00a0\u2026", "num_citations": "215\n", "authors": ["269"]}
{"title": "Rex: Symbolic regular expression explorer\n", "abstract": " Constraints in form regular expressions over strings are ubiquitous. They occur often in programming languages like Perl and C#, in SQL in form of LIKE expressions, and in web applications. Providing support for regular expression constraints in program analysis and testing has several useful applications. We introduce a method and a tool called Rex, for symbolically expressing and analyzing regular expression constraints. Rex is implemented using the SMT solver Z3, and we provide experimental evaluation of Rex.", "num_citations": "176\n", "authors": ["269"]}
{"title": "Flopsy-search-based floating point constraint solving for symbolic execution\n", "abstract": " Recently there has been an upsurge of interest in both, Search\u2013Based Software Testing (SBST), and Dynamic Symbolic Execution (DSE). Each of these two approaches has complementary strengths and weaknesses, making it a natural choice to explore the degree to which the strengths of one can be exploited to offset the weakness of the other. This paper introduces an augmented version of DSE that uses a SBST\u2013based approach to handling floating point computations, which are known to be problematic for vanilla DSE. The approach has been implemented as a plug in for the Microsoft Pex DSE testing tool. The paper presents results from both, standard evaluation benchmarks, and two open source programs.", "num_citations": "110\n", "authors": ["269"]}
{"title": "Unit tests reloaded: Parameterized unit testing with symbolic execution\n", "abstract": " Unit tests are becoming popular. Are there ways to automate the generation of good unit tests? Parameterized unit tests are unit tests that depend on inputs. PUTs describe behavior more concisely than traditional unit tests. We use symbolic execution techniques and constraint solving to find inputs for PUTs that achieve high code coverage, to turn existing unit tests into PUTs, and to generate entirely new PUTs that describe an existing implementation's behavior. Traditional testing benefits from these techniques because test inputs - including the behavior of entire classes - can often be generated automatically from compact PUTs", "num_citations": "110\n", "authors": ["269"]}
{"title": "Unit test generalization\n", "abstract": " A computer system provides a test program and one or more unit tests, such as a traditional unit test and or a parameterized unit test. The system also includes a constraint solver, a theorem prover, an implementation under test, a symbolic executor, a generalizor, and generated test cases. The generalizor receives a traditional unit tests as input, and modifies the traditional unit test into a parameterized unit test. The modification includes replacing plural concrete values in the traditional unit test with symbols, and exporting the symbols into a signature of the parameterized unit test. A symbolic executor identifies constraints while symbolically executing the created parameterized unit test of the implementation under test. A constraint solver and or theorem prover generates a set of test cases by solving for values that satisfy the series of constraints. The test program executes the automatically generated test cases.", "num_citations": "103\n", "authors": ["269"]}
{"title": "Model-based testing of object-oriented reactive systems with Spec Explorer\n", "abstract": " Testing is one of the costliest aspects of commercial software development. Not only laborious and expensive, it also often lacks systematic engineering methodology, clear semantics and adequate tool support.Model-based testing is one of the most promising approaches for addressing these deficits. At Microsoft, model-based testing technology developed by the Foundations of Software Engineering group in Microsoft Research has been used internally since", "num_citations": "101\n", "authors": ["269"]}
{"title": "Optimal strategies for testing nondeterministic systems\n", "abstract": " This paper deals with testing of nondeterministic software systems. We assume that a model of the nondeterministic system is given by a directed graph with two kind of vertices: states and choice points. Choice points represent the nondeterministic behaviour of the implementation under test (IUT). Edges represent transitions. They have costs and probabilities. Test case generation in this setting amounts to generation of a game strategy. The two players are the testing tool (TT) and the IUT. The game explores the graph. The TT leads the IUT by selecting an edge at the state vertices. At the choice points the control goes to the IUT. A game strategy decides which edge should be taken by the TT in each state. This paper presents three novel algorithms 1) to determine an optimal strategy for the bounded reachability game, where optimality means maximizing the probability to reach any of the given final states from a\u00a0\u2026", "num_citations": "91\n", "authors": ["269"]}
{"title": "Towards a tool environment for model-based testing with AsmL\n", "abstract": " We present work on a tool environment for model-based testing with the Abstract State Machine Language (AsmL). Our environment supports semi-automatic parameter generation, call sequence generation and conformance testing. We outline the usage of the environment by an example, discuss its underlying technologies, and report on some applications conducted in the Microsoft environment.", "num_citations": "86\n", "authors": ["269"]}
{"title": "Online testing with model programs\n", "abstract": " Online testing is a technique in which test derivation from a model program and test execution are combined into a single algorithm. We describe a practical online testing algorithm that is implemented in the model-based testing tool developed at Microsoft Research called Spec Explorer. Spec Explorer is being used daily by several Microsoft product groups. Model programs in Spec Explorer are written in the high level specification languages AsmL or Spec\\#. We view model programs as implicit definitions of interface automata. The conformance relation between a model and an implementation under test is formalized in terms of refinement between interface automata. Testing then amounts to a game between the test tool and the implementation under test.", "num_citations": "83\n", "authors": ["269"]}
{"title": "Mock-object generation with behavior\n", "abstract": " Unit testing is a popular way to guide software development and testing. Each unit test should target a single feature, but in practice it is difficult to test features in isolation. Mock objects are a well-known technique to substitute parts of a program which are irrelevant for a particular unit test. Today mock objects are usually written manually supported by tools that generate method stubs or distill behavior from existing programs. We have developed a prototype tool based on symbolic execution of .NET code that generates mock objects including their behavior by analyzing all uses of the mock object in a given unit test. It is not required that an actual implementation of the mocked behavior exists. We are working towards an integration of our tool into Visual Studio Team System", "num_citations": "68\n", "authors": ["269"]}
{"title": "Parameterized unit tests with behavioral purity axioms\n", "abstract": " Separation of parameterized unit tests (PUTs) from specific test cases supports many benefits including automated test case generation. Symbolic execution assigns symbolic input variables to parameters of a parameterized unit test. Path constraints of an implementation under test (IUT) are identified during symbolic execution. A constraint solver automatically generates test cases by determining the test inputs that satisfy one of more paths, each described by constraints, through the IUT. PUTs are used to populate behavioral summaries. Behavioral summaries are used later in future symbolic executions to emulate summarized methods. Behavioral summaries comprise behavioral purity axioms. Behavioral purity axioms require that an intensional heap before execution of a PUT be equal to the intensional heap after execution. An intensional heap is provided to represent state changes performed by summarized\u00a0\u2026", "num_citations": "63\n", "authors": ["269"]}
{"title": "Diagnosing problems in distributed systems\n", "abstract": " Diagnosing problems in distributed systems. In one aspect, a model of a distributed system defines trace statements are generated by various nodes of the system and placed in log files. The log files are sent to an automatic validator that attempts to reconcile the trace statements against the model. Results of the attempt are indicated. In another aspect, trace statements are received by a multiplexer that creates an ordering via sequence numbers. The ordering is forwarded to an automatic validator to determine whether the trace statements indicate correct behavior.", "num_citations": "62\n", "authors": ["269"]}
{"title": "Discovering likely method specifications\n", "abstract": " Software specifications are of great use for more rigorous software development. They are useful for formal verification and automated testing, and they improve program understanding. In practice, specifications often do not exist and developers write software in an ad-hoc fashion. We describe a new way to automatically infer specifications from code. Our approach infers a likely specification for any method such that the method\u2019s behavior, i.e., its effect on the state and possible result values, is summarized and expressed in terms of some other methods. We use symbolic execution to analyze and relate the behaviors of the considered methods. In our experiences, the resulting likely specifications are compact and human-understandable. They can be examined by the user, used as input to program verification systems, or as input for test generation tools for validation. We implemented the technique for\u00a0\u2026", "num_citations": "61\n", "authors": ["269"]}
{"title": "Qex: Symbolic SQL query explorer\n", "abstract": " We describe a technique and a tool called Qex for generating input tables and parameter values for a given parameterized SQL query. The evaluation semantics of an SQL query is translated into a specific background theory for a satisfiability modulo theories (SMT) solver as a set of equational axioms. Symbolic evaluation of a goal formula together with the background theory yields a model from which concrete tables and values are extracted. We use the SMT solver Z3 in the concrete implementation of Qex and provide an evaluation of its performance.", "num_citations": "60\n", "authors": ["269"]}
{"title": "XRT\u2013Exploring Runtime for. NET Architecture and Applications\n", "abstract": " XRT\u2013 Exploring Runtime \u2013 is an exploration framework for programs represented in Microsoft's common intermediate language (CIL). Processing .NET managed assemblies, it provides means for analyzing, rewriting, and executing the rewritten program. Whereas XRT's representation of state allows for arbitrary exploration strategies, it is particularly optimized for transactional exploration, where a transaction may consist of many instruction steps. XRT supports extensions, and one such extension is a module for symbolic exploration which captures the complete domain of safe CIL. Current applications of XRT are in the area of testing, namely parameterized unit testing and state-space exploration for model-based testing. This paper gives an overview of the architecture of XRT and outlines the applications.", "num_citations": "59\n", "authors": ["269"]}
{"title": "Symbolic execution of object oriented programs with axiomatic summaries\n", "abstract": " Symbolic execution identifies possible execution paths of a computer program or method, each having certain constraints over the input values. The symbolic execution also records updates of memory locations, eg updates of the fields of symbolic objects in the heap of an object oriented program, involving a description of the previous heap, the updated symbolic object, a field identification, and a newly assigned symbolic value. The symbolic execution can also record calls to summarized methods, involving a description of previous calls, an identification of the summarized methods, and its symbolic arguments. The behavior of summarized methods can be expressed by axioms. Axioms describe the relationship between summarized methods under certain conditions. Axioms can be generated from parameterized unit tests. A parameterized unit test is a method with parameters which executes a sequence of calls to\u00a0\u2026", "num_citations": "52\n", "authors": ["269"]}
{"title": "Parameterized unit testing with Pex\n", "abstract": " This hands-on tutorial will teach the principles of Parameterized Unit Testing [5,4] with Pex [2], an automatic test input generator for .NET which performs a systematic program analysis, similar to path bounded model-checking.               A parameterized unit test is simply a method that takes parameters, calls the code under test, and states assertions.", "num_citations": "52\n", "authors": ["269"]}
{"title": "Achieving both model and code coverage with automated gray-box testing\n", "abstract": " We have devised a novel technique to automatically generate test cases for a software system, combining black-box model-based testing with white-box parameterized unit testing. The former provides general guidance for the structure of the tests in the form of test sequences, as well as the oracle to check for conformance of an application under test with respect to a behavioral model. The latter finds a set of concrete parameter values that maximize code coverage using symbolic analysis. By applying these techniques together, we can produce test definitions (expressed as code to be run in a test management framework) that exercise all selected paths in the model, while also covering code branches specific to the implementation. These results cannot be obtained from any of the individual approaches alone, as the model cannot predict what values are significant to a particular implementation, while\u00a0\u2026", "num_citations": "50\n", "authors": ["269"]}
{"title": "Testing concurrent object-oriented systems with Spec Explorer\n", "abstract": " We describe a practical model-based testing tool developed at Microsoft Research called Spec Explorer. Spec Explorer enables modeling and automatic testing of concurrent object-oriented systems. These systems take inputs as well as provide outputs in form of spontaneous reactions, where inputs and outputs can be arbitrary data types, including objects. Spec Explorer is being used daily by several Microsoft product groups. The here presented techniques are used to test operating system components and Web service infrastructure.", "num_citations": "50\n", "authors": ["269"]}
{"title": "Symbolic query exploration\n", "abstract": " We study the problem of generating a database and parameters for a given parameterized SQL query satisfying a given test condition. We introduce a formal background theory that includes arithmetic, tuples, and sets, and translate the generation problem into a satisfiability or model generation problem modulo the background theory. We use the satisfiability modulo theories (SMT) solver Z3 in the concrete implementation. We describe an application of model generation in the context of the database unit testing framework of Visual Studio.", "num_citations": "49\n", "authors": ["269"]}
{"title": "Mock object generation by symbolic execution\n", "abstract": " A system for testing programs using a digital processor and programs in computer memory. A mock behavior generator identifies an interface indicated for mock behavior. The interface is identified as an input parameter of a parameterized unit test. The mock behavior generator creates a symbolic object with stubs to receive calls and mock behavior that returns symbolic values upon receiving a call to the stub. A symbolic executor, symbolically executes the parameterized unit test to obtain path constraints for an implementation under test, and at least one path constraint includes the symbol returned in response to the call to the stub. A constraint solver provides solutions for the paths including concrete values assigned to returned symbols. The mock behavior generator creates mock objects that return the concrete values when the implementation under test is executed.", "num_citations": "49\n", "authors": ["269"]}
{"title": "Testable use cases in the abstract state machine language\n", "abstract": " Use cases are a method for describing interactions between humans and/or systems. However, despite their popularity there is no agreed formal syntax and semantics of use cases. The Abstract State Machine Language (ASML) is an executable specification language developed at Microsoft Research. We define an encoding of use cases in ASML and demonstrate the advantages by describing techniques to generate test cases and test oracles from the encoding.", "num_citations": "49\n", "authors": ["269"]}
{"title": "Specification generation from implementations\n", "abstract": " A computerized method receives an implementation comprising a modifier method and an observer method of a class implementing an abstract data type. The method symbolically executes the modifier method to obtain constrained states, and applies the observer method in constrained states to obtain specialized axioms. The method then creates a specification from the obtained specialized axioms based on generalizing, merging and simplifying the specialized axioms.", "num_citations": "41\n", "authors": ["269"]}
{"title": "Validating use-cases with the AsmL test tool\n", "abstract": " The Abstract State Machine Language supports use-case oriented modeling in a faithful way. In this paper, we discuss how the AsmL test tool, a new component of the AsmL tool environment, is used to generate finite state machines from use-case models which can be used for validation purposes or for testing.", "num_citations": "38\n", "authors": ["269"]}
{"title": "Partial updates: exploration\n", "abstract": " The partial update problem for parallel abstract state machines has manifested itself in the cases of counters, sets and maps. We propose a solution of the problem that lends itself to an efficient implementation and covers the three cases mentioned above. There are other cases of the problem that require a more general framework.", "num_citations": "36\n", "authors": ["269"]}
{"title": "Conformance testing of multi-threaded and distributed software systems\n", "abstract": " Techniques and tools for testing multi-threaded or distributed software systems are described. For example, a multi-threaded system is instrumented and executed to produce logs of events that are performed by each of its agents. The agent logs contain a totally ordered series of events per agent, as well as information about accesses to resources shared between the agents. With this information, a partial ordering of the events performed by all the agents is described for the execution. The agent logs are then multiplexed into one or more serialized event orderings, which can then be compared to a specification of the system in a conformance testing engine.", "num_citations": "35\n", "authors": ["269"]}
{"title": "Efficient checking of state-dependent constraints\n", "abstract": " Constraints are defined in view of a program implementation. Constraints check program state or variables to maintain data consistency. A constraint component determines a constraint's scope and variables upon which a constraint depends. Program flow is altered so constraints are checked whenever a variable upon which a constraint depends is updated. Optionally, program flow is altered dynamically to re-establish constraints whenever a variable upon which a constraint depends is updated. Re-establishing constraints provides efficiency, since a program flow is altered for a minimum cost based on a present evolving minimum set of active constraint-variable relationships.", "num_citations": "35\n", "authors": ["269"]}
{"title": "Moles: tool-assisted environment isolation with closures\n", "abstract": " Isolating test cases from environment dependencies is often desirable, as it increases test reliability and reduces test execution time. However, code that calls non-virtual methods or consumes sealed classes is often impossible to test in isolation. Moles is a new lightweight framework which addresses this problem. For any .NET method, Moles allows test-code to provide alternative implementations, given as .NET delegates, for which C# provides very concise syntax while capturing local variables in a closure object. Using code instrumentation, the Moles framework will redirect calls to provided delegates instead of the original methods. The Moles framework is designed to work together with the dynamic symbolic execution tool Pex to enable automated test generation. In a case study, testing code programmed against the Microsoft SharePoint Foundation API, we achieved full code coverage while running\u00a0\u2026", "num_citations": "34\n", "authors": ["269"]}
{"title": "Instrumenting scenarios in a model-driven development environment\n", "abstract": " SpecExplorer is an integrated environment for model-driven development of .NET software. In this paper we discuss how scenarios can be described in SpecExplorer's modeling language, Spec#, and how the SpecExplorer tool can be used to validate those scenarios by various means.", "num_citations": "34\n", "authors": ["269"]}
{"title": "Model-based testing with AsmL .NET\n", "abstract": " We present work on a tool environment for model-based testing with the Abstract State Machine Language (AsmL). Our environment supports semi-automatic parameter generation, call sequence generation and conformance testing. We outline the usage of the environment by an example, discuss its underlying technologies, and report on some applications conducted in the Microsoft environment.", "num_citations": "32\n", "authors": ["269"]}
{"title": "Graphical user interface for exploring source code execution behavior\n", "abstract": " Described herein are interactive graphical user interfaces that visualize execution behavior of source code together with theoretical execution behavior of the source code together with the source code itself. Structure of the source code is analyzed to determine theoretical execution behavior of the source code. Thereafter, symbolic execution of the source code is undertaken to output an execution trace. The execution trace is shown together with the theoretical execution behavior of the source code.", "num_citations": "31\n", "authors": ["269"]}
{"title": "DyGen: Automatic generation of high-coverage tests via mining gigabytes of dynamic traces\n", "abstract": " Unit tests of object-oriented code exercise particular sequences of method calls. A key problem when automatically generating unit tests that achieve high structural code coverage is the selection of relevant method-call sequences, since the number of potentially relevant sequences explodes with the number of methods. To address this issue, we propose a novel approach, called DyGen, that generates tests via mining dynamic traces recorded during program executions. Typical program executions tend to exercise only happy paths that do not include error-handling code, and thus recorded traces often do not achieve high structural coverage. To increase coverage, DyGen transforms traces into parameterized unit tests (PUTs) and uses dynamic symbolic execution to generate new unit tests for the PUTs that can achieve high structural code coverage. In this paper, we show an application of DyGen by\u00a0\u2026", "num_citations": "30\n", "authors": ["269"]}
{"title": "Runtime verification\n", "abstract": " Runtime Verification - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Runtime Verification Barringer, Howard ; Falcone, Ylies ; Finkbeiner, Bernd ; Havelund, Klaus ; Lee, Insup ; Pace, Gordon ; Ro\u0219u, Grigore ; Sokolsky, Oleg ; Tillmann, Nikolai Abstract Publication: Lecture Notes in Computer Science Pub Date: 2010 DOI: 10.1007/978-3-642-16612-9 Bibcode: 2010LNCS......B Keywords: Computer Science; Software Engineering; Algorithm Analysis and Problem Complexity; Logics and Meanings of Programs; Programming Techniques; Programming Languages; Compilers; Interpreters; Mathematical Logic and Formal Languages full text sources Publisher | \u00a9 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo About @.\u2026", "num_citations": "30\n", "authors": ["269"]}
{"title": "Action machines: a framework for encoding and composing partial behaviors\n", "abstract": " We describe action machines, a framework for encoding and composing partial behavioral descriptions. Action machines encode behavior as a variation of labeled transition systems where the labels are observable activities of the described artifact and the states capture full data models. Labels may also have structure, and both labels and states may be partial with a symbolic representation of the unknown parts. Action machines may stem from software models or programs, and can be composed in a variety of ways to synthesize new behaviors. The composition operators described here include synchronized and interleaving parallel composition, sequential composition, and alternating simulation. We use action machines in analysis processes such as model checking and model-based testing. The current main application is in the area of model-based conformance testing, where our approach addresses\u00a0\u2026", "num_citations": "30\n", "authors": ["269"]}
{"title": "Symbolic runtime checking of quantified contracts\n", "abstract": " An extension of symbolic execution for programs involving contracts with quantifiers over large and potentially unbounded domains is described. Symbolic execution is used to generate, from a program, concrete test cases that exhibit mismatches between the program code and its contracts with quantifiers. Quantifiers are instantiated using symbolic values encountered during a set of exhibited runs. In this setting, quantifier instantiation is limited to values supplied to or produced by a symbolic execution. Quantifier instantiation is controlled by performing a matching algorithm that uses run-time values of input and program variables in order to guide and limit the set of quantifier instantiations. With a sufficient set of instances, test cases are derived that directly witness limitations of the auxiliary assertions.", "num_citations": "29\n", "authors": ["269"]}
{"title": "Parameterized unit tests with unit meister\n", "abstract": " Parameterized unit tests extend the current industry practice of using closed unit tests defined as parameterless methods. Traditional closed unit tests are re-obtained by instantiating the parameterized unit tests. We have developed the prototype tool Unit Meister, which uses symbolic execution and constraint solving to automatically compute a minimal set of inputs that exercise a parameterized unit test given certain coverage criteria. In addition, the parameterized unit tests can be used as symbolic summaries during symbolic execution, which allows our approach to scale for arbitrary abstraction levels. Unit Meister has a command-line interface, and is also integrated into Visual Studio 2005 Team System.", "num_citations": "29\n", "authors": ["269"]}
{"title": "Exposing native device APIs to web apps\n", "abstract": " A recent survey among developers revealed that half plan to use HTML5 for mobile apps in the future. An earlier survey showed that access to native device APIs is the biggest shortcoming of HTML5 compared to native apps. Several different approaches exist to overcome this limitation, among them cross-compilation and packaging the HTML5 as a native app. In this paper we propose a novel approach by using a device-local service that runs on the smartphone and that acts as a gateway to the native layer for HTML5-based apps running inside the standard browser. WebSockets are used for bi-directional communication between the web apps and the device-local service. The service approach is a generalization of the packaging solution. In this paper we describe our approach and compare it with other popular ways to grant web apps access to the native API layer of the operating system.", "num_citations": "28\n", "authors": ["269"]}
{"title": "Parameterized test driven development\n", "abstract": " In one embodiment a computer system automatically generates unit tests. The computer system accesses a parameterized unit test that provides a base outline from which one or more unit tests are automatically generated, generates input parameter values for a unit of software code, automatically generates a unit test configured to assess the functionality of the unit of software code, and receives test results from a software testing program and provides feedback to a user. In other embodiments, a computer system automatically maintains a unit test database. The computer system receives a unit test at a unit test database, assigns a test identity to the received unit test, determines that the test identity assigned to the received unit test is unique when compared to other unit tests, determines that the received unit test has different functionality coverage characteristics, and adds the received unit test to the unit test\u00a0\u2026", "num_citations": "27\n", "authors": ["269"]}
{"title": "Extending test sequences to accepting states\n", "abstract": " State spaces are traversed to produce test cases, or test coverage. Test coverage is a test suite of sequences. Accepting states are defined. Expected costs are assigned to the test graph states. Strategies are created providing transitions to states with lower expected costs. Linear programs and other approximations are discussed for providing expected costs. Strategies are more likely to provide access to an accepting state, based on expected costs. Strategies are used to append transitions to test segments such that the new test segment ends in an accepting state.", "num_citations": "27\n", "authors": ["269"]}
{"title": "Scenario-oriented Modeling in AsmL and its Instrumentation for Testing\n", "abstract": " We present an approach for modeling use cases and scenarios in the Abstract State Machine Language and discuss how to use such models for validation and verification purposes.", "num_citations": "27\n", "authors": ["269"]}
{"title": "Generating test cases for software with complex preconditions\n", "abstract": " Techniques and tools for generating test cases for methods or programs with input preconditions are described. For example, after finding feasible control flow paths for a tested method along with each path's associated input conditions, a new program is created which tests these conditions along with the precondition. By analyzing this new program's control flow graph, a class of test cases is found while avoiding inefficiencies created by doing complete searches of paths through the combined control flow graph of the precondition and the method. Additional efficiencies are introduced by partitioning a control flow graph for the precondition into branched and straight sections.", "num_citations": "26\n", "authors": ["269"]}
{"title": "Non-deterministic testing\n", "abstract": " A computerized method creates test coverage for non-deterministic programs. The method receives a graph of edges and states representing a program under test, and creates a continuous cycle of edges that reaches each edge in the graph at least once. In one example, the method splits the continuous cycle into discrete sequences that end at edges reaching non-deterministic nodes in the graph, and verifies that the executing program conforms to the behavior represented by the discrete sequences. In another example, a method creates probabilistic strategies for reaching one or more vertices in a non-deterministic graph. The strategies provide a graph path with a high probability of reaching a desired vertex.", "num_citations": "25\n", "authors": ["269"]}
{"title": "On-the-fly testing of reactive systems\n", "abstract": " On-the-fly testing is a technique in which test derivation from a model program and test execution are combined into a single algorithm. It can also be called online testing using a model program, to distinguish it from offline test generation as a separate process. We describe a practical on-the-fly testing algorithm that is implemented in the model-based testing tool developed at Microsoft Research called Spec Explorer. Spec Explorer is being used daily by several Microsoft product groups. Model programs in Spec Explorer are written in a high level specification language AsmL or Spec#. We view model programs as implicit definitions of interface automata. The conformance relation between a model and an implementation under test is formalized in terms of refinement between interface automata, and testing amounts to a game between the test tool and the implementation under test.", "num_citations": "25\n", "authors": ["269"]}
{"title": "Tracing just-in-time compilation with pointers to local variables\n", "abstract": " In one embodiment, a trace optimizing engine may create an optimized trace of an operation segment of a software program. A memory may store a trace of an operation segment and an inherited stack frame from the operation segment. An optimizing trace compiler may resolve a local pointer of the operation segment to a memory object and insert a guard in the trace that invalidates the trace if the local pointer does not resolve to the memory object. A just in time compiler may receive in the trace a stack pointer to the inherited stack frame, move the stack pointer to create a storage space, and store an intermediate value for a local variable in a temporary variable in the storage space.", "num_citations": "24\n", "authors": ["269"]}
{"title": "Partial updates\n", "abstract": " A datastructure instance, e.g. a set or file or record, may be modified independently by different parts of a computer system. The modifications may be nested. Such hierarchies of modifications need to be efficiently checked for consistency and integrated. This is the problem of partial updates in a nutshell. In our first paper on the subject, we developed an algebraic framework which allowed us to solve the partial update problem for some useful datastructures including counters, sets and maps. These solutions are used for the efficient implementation of concurrent data modifications in the specification language AsmL. The two main contributions of this paper are (i)\u00a0a more general algebraic framework for partial updates and (ii)\u00a0a solution of the partial update problem for sequences and labeled ordered trees.", "num_citations": "24\n", "authors": ["269"]}
{"title": "GROPG: A graphical on-phone debugger\n", "abstract": " Debugging mobile phone applications is hard, as current debugging techniques either require multiple computing devices or do not support graphical debugging. To address this problem we present GROPG, the first graphical on-phone debugger. We implement GROPG for Android and perform a preliminary evaluation on third-party applications. Our experiments suggest that GROPG can lower the overall debugging time of a comparable text-based on-phone debugger by up to 2/3.", "num_citations": "22\n", "authors": ["269"]}
{"title": "Access driven filtering\n", "abstract": " A test domain configuration module generates graphical user interfaces for identifying information about desired tests such as data types and domain configurations, and collects information used by other modules to generate tests. The identified information may include, for example, an abstract syntax, a static semantic, max counts on instances of data types, or costs of field accesses or data types for max path costs or max expression costs. A test input generator, generates test input for the identified and configured data types. In one case, the generated test inputs are generated as tree data structures. A predicate determines whether a generated test input follows semantic conditions. A test input evaluator counts instances of data types in, sums paths through, or sums total costs of, the generated test inputs. A test acceptance module saves test inputs acceptable to the predicate and the test input evaluator.", "num_citations": "22\n", "authors": ["269"]}
{"title": "Action machines-towards a framework for model composition, exploration and conformance testing based on symbolic computation\n", "abstract": " We report on a framework for model composition, exploration, and conformance testing based on symbolic execution. The foundations of this framework are given by so-called action machines, a variation of labeled transition systems which communicate over synchronously stepped actions and constraints attached to them. The implementation is based on XRT, an exploration engine for .NET CIL code which supports symbolic computation. The main application is in the area of model-based conformance testing, where our approach addresses practical problems users at Microsoft have in applying model-based testing technology.", "num_citations": "22\n", "authors": ["269"]}
{"title": "Bounded program failure analysis and correction\n", "abstract": " In one embodiment, a computer system determines that a previously run test scenario configured to test a software program has failed to produce an expected result due to one or more semantic errors, generates error trace code configured to monitor the called component, processes the test scenario using the error trace code, and analyzes error trace information to determine the point at which the semantic error occurs in the called component. In an alternative embodiment, a computer system detects a semantic error in a software component of a software program, constructs an error condition that may include source code representing a minimum condition under which the error occurs, generates an object invariant based on the error condition that represents an opposite condition to that represented by the error condition, and automatically generates source code change recommendations using the object\u00a0\u2026", "num_citations": "20\n", "authors": ["269"]}
{"title": "Interactive domain configuration\n", "abstract": " Described herein are methods and systems for interactively configuring and producing a data domain for various data structure elements of a computer program. A domain configuration manager is described which interactively receives domain configuration information corresponding to a data structure element, reads a reflection of the program and produces a data domain according to domain configuration information. The domain configuration manager is capable of producing a data domain for a data structure element according to such domain configuration information such as an explicit expression, inheritance or domain generation technique. The reflection of the computer program exposes the methods and functions of the program to be used in the explicit expression regardless of the visibility rules. Also, predicates and conditions can be used with domain generation techniques to further narrowly configure\u00a0\u2026", "num_citations": "19\n", "authors": ["269"]}
{"title": "Whitebox trace fuzzing\n", "abstract": " Disclosed is a process to generate and execute relevant, non-redundant test cases starting with an execution trace. An execution trace may be collected. A sequence of actions and the data involved in the actions may then be extracted from the execution trace and persisted separately from one another. Code for a non-deterministic program (\u201cNDP\u201d) may be generated, comprising the sequence of actions but without determining the data. A systematic program analysis of the NDP may be made, exploring possible execution paths and beginning from the path exercised by the persisted data. A new test case may be generated which fixes particular test inputs for the NDP.", "num_citations": "17\n", "authors": ["269"]}
{"title": "Symbolic program model compositions\n", "abstract": " A model composition environment can allow for description of fill or partial symbolic system behavior, as well as the combination of models of specific features into compound models. Compositional operators can include intersection, concatenation, substitution, alternating refinement, as well as a set of regular expression-like operators. Models called \u201caction machines\u201d can represent object-oriented, reactive programs, and an action machine may be composed with another action machine using a compositional operator. This can allow for testing of particular scenarios or behaviors.", "num_citations": "17\n", "authors": ["269"]}
{"title": "Addressing JavaScript JIT engines performance quirks: A crowdsourced adaptive compiler\n", "abstract": " JavaScript has long outpaced its original target applications, being used not only for coding complex web clients, but also web servers, game development and even desktop applications. The most appealing advantage of moving applications to JavaScript is its capability to run the same code in a large number of different devices. It is not surprising that many compilers target JavaScript as an intermediate language. However, writing optimizations and analyses passes for a compiler that emits JavaScript is challenging: a long time spent in optimizing the code in a certain way can be excellent for some browsers, but a futile effort for others. For example, we show that applying JavaScript code optimizations in a tablet with Windows 8 and Internet Explorer 11 increased performance by, on average, 5 times, while running in a desktop with Windows 7 and Firefox decreased performance by 20%. Such a scenario\u00a0\u2026", "num_citations": "14\n", "authors": ["269"]}
{"title": "TouchDevelop: programming on the go\n", "abstract": " In TouchDevelop, sprites are 2D bitmaps that are drawn directly to the screen. Sprites are commonly used to display information such as health bars, number of lives, or text such as scores. Some games, especially older games, are composed entirely of sprites. TouchDevelop allows creation and use of several types of sprite, such as ellipse, rectangle, text and picture. More details about a sprite\u2019s capabilities can be obtained from http://msdn. microsoft. com/en-us/library/bb203919. aspx", "num_citations": "14\n", "authors": ["269"]}
{"title": "An experiment in developing small mobile phone applications comparing on-phone to off-phone development\n", "abstract": " TouchDevelop represents a radically new mobile application development model, as TouchDevelop enables mobile application development on a mobile device. I.e., with TouchDevelop, the task of programming say a Windows Phone is shifted from the desktop computer to the mobile phone itself. We describe a first experiment on independent, non-expert subjects to compare programmer productivity using TouchDevelop vs. using a more traditional approach to mobile application development.", "num_citations": "14\n", "authors": ["269"]}
{"title": "State exploration using multiple state groupings\n", "abstract": " Exploration algorithms are relevant to the industrial practice of generating test cases from an abstract state machine whose runs define the predicted behavior of the software system under test. Here, a new exploration algorithm allows multiple state groupings to simultaneously guide the search for states that are interesting or relevant for testing. In some cases, the algorithm allows exploration to be optimized from exponential to linear complexity. An extended example is included that illustrates the use of the algorithm.", "num_citations": "14\n", "authors": ["269"]}
{"title": "Symbolic query exploration\n", "abstract": " A symbolic query exploration (QEX) module automatically produces output information that can be used to evaluate a database. The QEX module operates by converting an input query into a formula for processing by a satisfiability module theories (SMT) solver module. The SMT solver module generates a model that satisfies the formula. The model yields table information that is used to populate the database and, optionally, parameter information that is used to instantiate the query. A query evaluation module then submits the instantiated query to the populated database and evaluates whether an evaluation result produced thereby agrees with pre-specified condition information. The QEX module can preprocess the formula using either (or both) an eager expansion approach (in which the formula is expanded in an upfront manner) or a lazy expansion approach (in which axioms are identified for later possible\u00a0\u2026", "num_citations": "13\n", "authors": ["269"]}
{"title": "Generating finite state machines for software systems with asynchronous callbacks\n", "abstract": " Techniques and tools for generating finite state machines (\u201cFSMs\u201d) for a software system with asynchronous callbacks are described. For example, method invocations in a model of the software system are partitioned into observable and controlled method invocations. The controlled method invocations are those which can be run from a test harness while the observed method invocations are those which are observed asynchronously as they are invoked in the system. An FSM is created with observation and control nodes such that observable transitions are found from observation nodes and controlled transitions are found from control nodes. If a state of the model contains both controlled and observable invocations, a timeout transition is added to the FSM to give an implementation time to come up with an observed method invocation before continuing to controlled invocations.", "num_citations": "13\n", "authors": ["269"]}
{"title": "White-box testing of behavioral web service contracts with pex\n", "abstract": " A web service exposes a public API that can be accessed by potentially hostile clients over the internet. Pex, a white-box test generation tool for .NET, can automatically create test inputs that cover comer cases of a web service implemented in .NET, simulating a malicous attacker.", "num_citations": "13\n", "authors": ["269"]}
{"title": "Parameterized test patterns for effective testing with Pex\n", "abstract": " A unit test is a method without parameters that represents a test case which typically executes a method of a class-under-test with fixed arguments and verifies that it returns the expected result. A parameterized unit test (PUT) is the straightforward generalization of a unit test by allowing parameters. PUTs make statements about the code\u2019s behavior for an entire set of possible input values, instead of just a single exemplary input value.This paper contains common patterns for parameterized unit tests (PUTs)[8]. The patterns are written with automatic test input generation tools in mind, such as Pex [7], which can determine all (or at least many) relevant test inputs that trigger the possible cases of the PUT and the code-under-test.", "num_citations": "12\n", "authors": ["269"]}
{"title": "Using dynamic symbolic execution to improve deductive verification\n", "abstract": " One of the most challenging problems in deductive program verification is to find inductive program invariants typically expressed using quantifiers. With strong-enough invariants, existing provers can often prove that a program satisfies its specification. However, provers by themselves do not find such invariants. We propose to automatically generate executable test cases from failed proof attempts using dynamic symbolic execution by exploring program code as well as contracts with quantifiers. A developer can analyze the test cases with a traditional debugger to determine the cause of the error; the developer may then correct the program or the contracts and repeat the process.", "num_citations": "11\n", "authors": ["269"]}
{"title": "Partial updates exploration II\n", "abstract": " During one step of a powerful programming, specification or query language, the same mathematical object, like a set or map or sequence, may be modified - in parallel - by different parts of the program. Such partial updates need to be efficiently checked for consistency and integrated. This is the problem of partial updates in a nutshell. In our first paper on the subject we proposed a general solution of the partial-update problem for abstract state machines (ASMs) where the problem is exacerbated by the use of nested submachines; in particular we solved the problem in the cases of counters, sets and maps. Here we propose a more general framework that allows us to solve the problem for sequences and labeled ordered trees. The partial update problem for sequences is related to the problem of collaborative editing.", "num_citations": "11\n", "authors": ["269"]}
{"title": "Test case generation from AsmL specifications\n", "abstract": " Model-based testing has recently been receiving more and more attention in Microsoft\u2019s product groups. Typically, the models are required to be finite state machines (FSMs) because there is well-known algorithmic support for test case generation for FSMs. The direct FSM based modeling approach has its limitations though. Most noticeably, the FSM model for a particular testing problem may not be the most natural one to describe the implementation under test. This motivated us to study the problem of algorithmic generation of an FSM from a given AsmL spec1. We have developed a pragmatic test case generation tool where the FSM generation algorithm is used and has been extended in several ways.", "num_citations": "10\n", "authors": ["269"]}
{"title": "Contextually intelligent code editing\n", "abstract": " This document describes techniques for contextually intelligent code editing. In at least some embodiments, the techniques are network-based and can use client-server interactions to develop programming code. For example, input to a local programming environment of a client can be transmitted to a server. A functionality at the server can inspect the input and determine programming options (eg, programming terms and/or phrases) that are contextually valid in the local programming environment. A list of the programming options can then be transmitted to the client and presented via a user interface. In some embodiments, a selection of one of the programming options can cause the programming option to be populated to the local programming environment, eg, as part of a user interface associated with the local programming environment. In at least some embodiments, the list of programming options can be\u00a0\u2026", "num_citations": "9\n", "authors": ["269"]}
{"title": "State as a first-class citizen of an imperative language\n", "abstract": " A state component saves a present state of a program or model. This state component can be invoked by the program or model itself, thereby making state a first-class citizen. As the state of the program evolves from the saved state, the saved state remains for reflection and recall, for example, for testing, verification, transaction processing, etc. Using a state reference token, the saved state of the program or model can be accessed by the program or model. For example, the program or model by utilizing a state component, can return itself to the saved state. After returning to the saved state, a second execution path can be introduced without requiring re-execution of the actions leading to the saved state. In another example, the state space of an executing model is saved in order to generate inputs required to exercise a program or model.", "num_citations": "9\n", "authors": ["269"]}
{"title": "Automated testing of environment-dependent programs-a case study of modeling the file system for Pex\n", "abstract": " Programs that interact with the file system are a classical challenge for automated software testing. A common approach to handling this problem is to insert an abstraction layer between the application and the file system. However, even with a well-defined abstraction layer, the burden on the software developer or tester is still high: they have to understand the subtleties of the file system to craft a meaningful set of test cases. The file system is accessed through a complex API, which often causes developers to overlook obscure yet possible corner cases. In this paper, we present a parameterized model of the file system that can be used in conjunction with Pex, an automated test generation tool, to test code that depends on the file system.", "num_citations": "9\n", "authors": ["269"]}
{"title": "Symbolic finite automata\n", "abstract": " Described are symbolic finite automata for symbolically expressing and analyzing regular expression constraints, such as for use in program analysis and testing. A regular expression or pattern is transformed into a symbolic finite automaton having transitions that are labeled by formulas that denote sets of characters (rather than individual characters). Also described is composing two or more symbolic finite automata into a resulting symbolic finite automaton that is fully satisfiable. A constraint solver may be used to ensure satisfiability.", "num_citations": "8\n", "authors": ["269"]}
{"title": "Model-based testing with specexplorer\n", "abstract": " Encode a system's intended behavior (its specification) in machine-executable form (as a\" model program\"). The model program typically does much less than the implementation; it does just enough to capture the relevant states of the system and show the constraints that a correct implementation must follow. The goal is to specify from a chosen viewpoint what the system must do, what it may do and what it must not do.", "num_citations": "8\n", "authors": ["269"]}
{"title": "Automatic parallelization of programming languages: past, present and future\n", "abstract": " Automatic parallelization of modern object-oriented languages, like Java, C#, Python or JavaScript, is considered to be a grand challenge. But what is the challenge exactly? Let us simplify the discussion by focusing on loop parallelization only. As usual loop parallelization requires answering two questions:(1) is it worthwhile to parallelize a loop?(2) is it safe to parallelize a loop?", "num_citations": "7\n", "authors": ["269"]}
{"title": "Halleux. Pex-white box test generation for. NET\n", "abstract": " Pex automatically produces a small test suite with high code coverage for a .NET program. To this end, Pex performs a systematic program analysis (using dynamic symbolic execution, similar to pathbounded model-checking) to determine test inputs for Parameterized Unit Tests. Pex learns the program behavior by monitoring execution traces. Pex uses a constraint solver to produce new test inputs which exercise different program behavior. The result is an automatically generated small test suite which often achieves high code coverage. In one case study, we applied Pex to a core component of the .NET runtime which had already been extensively tested over several years. Pex found errors, including a serious issue. 1", "num_citations": "6\n", "authors": ["269"]}
{"title": "Code Digging with Pex Code Understanding and Automatic Testing At Your Fingertips\n", "abstract": " Pex is a new tool that helps in understanding the behavior of .NET code, debugging issues, and in creating a test suite that covers all corner cases\u2013fully automatically. Through a context menu in the code editor, the user can invoke Pex to analyze an entire class or a single method. For any method, Pex computes and displays interesting input-output pairs. Pex systematically hunts for bugs\u2013exceptions or assertion failures. As Pex discovers boundary conditions in code, Pex generates new tests that target these conditions. The result is a small test suite with high code coverage. Pex enables Parameterized Unit Testing, an extension of traditional unit testing that reduces test maintenance costs. Pex has been used in Microsoft to test core .NET components. Pex is developed at Microsoft Research and is integrated into Microsoft Visual Studio.", "num_citations": "5\n", "authors": ["269"]}
{"title": "Code hunt: context-driven interactive gaming for learning programming and software engineering\n", "abstract": " Code Hunt is a web-based serious gaming platform for players to solve coding duels, a type of puzzle based on programming and software engineering. In Code Hunt, a player iteratively modifies code to match the functional behavior of a secret code segment. The functional behavior is defined based on unit test cases shown as input-output pairs. To guide players to modify the code segment, Code Hunt provides feedback based on test generation through the Pex engine. In Code Hunt, the way of writing code is very different from the way in traditional software development since there are no known requirements (either informally/formally documented or existing in developers\u2019 mind); the game aspect in Code Hunt is essentially re-engineering from sample expected behaviors observed from generated test cases. Various types of context exist in Code Hunt including the duel and the test cases, as well as the player\u2019s history and any hints that are given. In this position paper, we discuss how such context assists the players to solve coding duels while offering the players learning and fun experiences.", "num_citations": "4\n", "authors": ["269"]}
{"title": "Double inspection for run-time loop parallelization\n", "abstract": " The Inspector/Executor is well-known for parallelizing loops with irregular access patterns that cannot be analyzed statically. The downsides of existing inspectors are that it is hard to amortize their high run-time overheads by actually executing the loop in parallel, that they can only be applied to loops with dependencies that do not change during their execution and that they are often specifically designed for array codes and are in general not applicable in object oriented just-in-time compilation.             In this paper we present an inspector that inspects a loop twice to detect if it is fully parallelizable. It works for arbitrary memory access patterns, is conservative as it notices if changing data dependencies would cause errors in a potential parallel execution, and most importantly, as it is designed for current multicore architectures it is fast \u2013 despite of its double inspection effort: it pays off at its first use.             On\u00a0\u2026", "num_citations": "4\n", "authors": ["269"]}
{"title": "Retrofitting unit tests for parameterized unit testing\n", "abstract": " Maintenance of software applications requires unit tests with high fault-detection capability. In practice, developers face two major challenges when manually writing unit tests with high fault-detection capability. First, developers may not be able to write test data that test all important behaviors of methods under test. Second, developers may unintentionally write redundant unit tests that exercise the same behavior of methods under test. To address these issues, developers can write Parameterized Unit Tests (PUTs), instead of unit tests without parameters, referred to as Conventional Unit Tests (CUTs). A major benefit of PUTs compared to CUTs is that developers do not need to provide test data in PUTs, since test data can be generated automatically using a test-generation tool. However, writing PUTs is more challenging than writing CUTs. For example, PUTs typically encode algebraic specifications, which are more abstract and general than sample-point behaviors encoded by CUTs. On the other hand, existing applications often include CUTs, which can be used to write PUTs with low effort. To exploit the benefits of PUTs in practice, we propose a novel approach to retrofit existing CUTs into PUTs. We conducted an empirical study on three real-world applications to show the benefits of retrofitting CUTs into PUTs. In our empirical study, we show that our approach retrofits 407 CUTs (4.6 KLOC) to 224 PUTs (4.0 KLOC). Along with achieving higher branch coverage (a maximum increase of 52% for one class under test and 10% for one application) than existing CUTs, our approach helps detect 19 new defects not detected by existing CUTs. Some\u00a0\u2026", "num_citations": "4\n", "authors": ["269"]}
{"title": "Microsoft Pex Tutorial\n", "abstract": " This hands-on tutorial will teach the principles of Parameterized Unit Testing in Visual Studio with Pex, an automatic test input generator (http://research. microsoft. com/pex). A parameterized unit test (PUT) is simply a method that takes parameters, calls the code under test, and states assertions. Given a PUT written in a .NET language, Pex automatically produces a small test suite with high code and assertion coverage. Moreover, when a generated test fails, Pex can often suggest a bug fix. To do so, Pex performs a systematic program analysis, similar to path bounded model-checking. Pex learns the program behavior by monitoring execution traces, and uses a constraint solver to produce new test cases with different behavior. At Microsoft, this technique proved highly effective in testing even an extremely well-tested component.From a specification, the developer (1) writes parameterized unit tests in C# to reflect\u00a0\u2026", "num_citations": "4\n", "authors": ["269"]}
{"title": "Automatic rendering of interactive user interface elements\n", "abstract": " This patent relates to automatic UI rendering techniques by which specified data items can be automatically posted on a UI and rendered as interactive UI elements and/or UI sub-elements without explicit instructions for how the specified data items are to be rendered. A developer can therefore specify in a simple expression (eg, a script) that the data item is to be posted and rendered, without having to specify how the UI elements and/or UI sub-elements are to be rendered.", "num_citations": "3\n", "authors": ["269"]}
{"title": "Teaching programming on a mobile device\n", "abstract": " From paper to computers, the way we have been writing down thoughts and performing symbolic computations has been constantly evolving. Teaching methods closely follow this trend, leveraging existing technology to make teaching more effective and preparing students for their later careers with available technologies. At present, we are in the middle of another technology shift: instead of using PCs and laptops, mobile devices are becoming more prevalent for most everyday computing tasks. We propose that computer programming, and thus the teaching of programming, can and should be done directly on the mobile devices themselves, without the need for a separate PC to write code. Programming on mobile devices engages students in new ways, allowing them to access and manipulate programmatically their most personal digital data such as pictures, videos, and music in an easy and intuitive way.", "num_citations": "3\n", "authors": ["269"]}
{"title": "TouchStudio-Programming Cloud-Connected Mobile Devices via Touchscreen\n", "abstract": " The world is experiencing a technology shift. In 2011, more touchscreenbased mobile devices like smartphones and tablets will be sold than desktops, laptops, and netbooks combined. In fact, in many cases incredibly powerful and easy-to-use smart phones are going to be the first and, in less developed countries, possibly the only computing devices which virtually all people will own, and carry with them at all times. Furthermore, mobile devices do not only have touchscreens, but they are also equipped with a multitude of sensors, such as location information and acceleration, and they are always connected to the cloud. TouchStudio is a novel application creation environment for anyone to script their smartphones anywhere\u2013you do not need a separate PC. TouchStudio allows you to develop mobile device applications that can access your data, your media, your sensors and allows using cloud services including\u00a0\u2026", "num_citations": "3\n", "authors": ["269"]}
{"title": "Satisfiability Modulo Bit-precise Theories for Program Exploration\n", "abstract": " The Satisfiability Modulo Theories solver Z3 [10] is used in several program analysis and verification tools at Microsoft Research. Some of these tools require bit-precise reasoning for accurately modeling machine arithmetic instructions. But this alone is rarely sufficient, and an integration with other theories is required. The Pex tool [20] performs program exploration of .NET programs by generating and solving path conditions corresponding to paths that get explored during concrete execution. The path conditions reflect directly the executed instructions, including ones involving machine arithmetic supported by the CLR. The path conditions include also operations on heaps and structures. Pex relies on Z3\u2019s ability to produce models for satisfiable path conditions, the models must reflect the combination of the involved theories: bit-vectors, arrays, and tuples. This paper describes the features of Z3 that are used by Pex.", "num_citations": "3\n", "authors": ["269"]}
{"title": "Parameterized unit testing with Pex: tutorial\n", "abstract": " This hands-on tutorial teaches the principles of Parameterized Unit Testing in Visual Studio with Pex, an automatic test input generator.             A parameterized unit test (PUT) is simply a method that takes parameters, calls the code under test, and states assertions. Given a PUT written in a .NET language, Pex automatically produces a small test suite with high code and assertion coverage.Moreover, when a generated test fails, Pex can often suggest a bug fix. To do so, Pex performs a systematic program analysis, similar to path bounded model-checking. Pex learns the program behavior by monitoring execution traces, and uses a constraint solver to produce new test cases with different behavior. At Microsoft, this technique proved highly effective in testing even an extremely well-tested component.", "num_citations": "3\n", "authors": ["269"]}
{"title": "Using asml for runtime verification\n", "abstract": " We use AsmL, an executable specification language created by the Foundations of Software Engineering group [1], to describe the behavior of .NET components and perform runtime verification. AsmL is based on the theory of ASMs; AsmL is an industrial-strength specification language that is a full member of the Microsoft .NET Framework.", "num_citations": "3\n", "authors": ["269"]}
{"title": "It\u2019s Alive\n", "abstract": " It\u2019s Alive! Page 1 It\u2019s Alive! Continuous Feedback in UI Programming Sebastian Burckhardt Manuel Fahndrich Peli de Halleux Sean McDirmid Michal Moskal Nikolai Tillmann Microsoft Research Jun Kato The University of Tokyo Page 2 Live Programming : Archer Analogy [Hancock, 2003] \u2022 Archer: aim, shoot, inspect, repeat \u2022 Hose: aim & watch Page 3 \u2022 Archer: aim, shoot, inspect, repeat \u2022 edit, compile, test, repeat \u2022 Hose: aim & watch \u2022 edit & watch Live Programming : Archer Analogy [Hancock, 2003] Page 4 Quick Demo: What is Live Programming? What is TouchDevelop? Page 5 Question: How to do live programming? \u2022 Target: Event-driven apps with graphical user interfaces (GUI\u2019s) \u2022 User input events (tap button, edit text, ..) \u2022 I/O events (eg asynchronous web requests) \u2022 We can think of code editing as an event (replace old program with a new one) \u2022 What should we do in this situation? Page 6 on code changes, ? \u2026", "num_citations": "3\n", "authors": ["269"]}
{"title": "Generating type-safe wrappers for dynamic detouring\n", "abstract": " An isolation system is described for converting original product code into corresponding modified code. The isolation system operates by identifying a subset of original methods to be converted. For each such original method, the isolation system generates a modified part having at least one property with a type-safe delegate type which matches a signature of the original method. Test code, which tests the product code, can then associate a delegate instance to the thus-defined property of the original method. This prompts an execution system to dynamically execute detour code associated with the delegate instance, rather than an instrumentation of the original method, thus avoiding dependency on potentially non-deterministic functionality which would be otherwise invoked by an instrumentation of the original method.", "num_citations": "2\n", "authors": ["269"]}
{"title": "Parameterized Unit Testing with Microsoft PeX\n", "abstract": " This hands-on tutorial teaches the principles of Parameterized Unit Testing in Visual Studio with Pex, an automatic test input generator (http://research. microsoft. com/pex). A parameterized unit test (PUT) is simply a method that takes parameters, calls the code under test, and states assertions. Given a PUT written in a .NET language, Pex automatically produces a small test suite with high code and assertion coverage. Moreover, when a generated test fails, Pex can often suggest a bug fix. To do so, Pex performs a systematic program analysis, similar to path bounded model-checking. Pex learns the program behavior by monitoring execution traces, and uses a constraint solver to produce new test cases with different behavior. At Microsoft, this technique proved highly effective in testing even an extremely well-tested component.From a specification, the developer (1) writes parameterized unit tests in C# to reflect the specification, and (2) develops code that implements the specification. The tutorial will outline key aspects to make this methodology successful in practice, including how to write mock objects, as well as the theoretical foundations on which Pex is built.", "num_citations": "2\n", "authors": ["269"]}
{"title": "Issue analysis for residual structural coverage in dynamic symbolic execution\n", "abstract": " The process of achieving high structural coverage of the program under test can be automated using Dynamic Symbolic Execution (DSE), which generates test inputs to iteratively explore paths of the program under test. When applied on real-world applications, DSE faces various challenges in generating test inputs to achieve high structural coverage. Among issues related to these challenges, our preliminary study identified two main types of issues:(1) object-creation issues (OCI), where DSE fails to generate method-call sequences to produce desirable object states;(2) external-method-call issues (EMCI), where symbolic values are passed as arguments to third-party library methods that are not instrumented by DSE. Automatically solving these two main types of issues is challenging, since the exploration space of generating method-call sequences for desirable object states is usually too huge, and instrumenting all third-party libraries can cause explosion of the exploration space. However, when provided with informative information of issues, users can effectively assist DSE to achieve high structural coverage. In this paper, we propose a general approach, called Covana, to identify issues faced by DSE via analyzing runtime information, and filter out irrelevant issues using residual structural coverage. We provide two techniques to instantiate our general approach to identify OCIs and EMCIs. To show the effectiveness of Covana, we conduct evaluations on two open source projects. Our results show that Covana effectively identifies 155 OCIs, and 43 EMCIs. Moreover, Covana effectively reduces 296 irrelevant issues out of 451 OCIs and\u00a0\u2026", "num_citations": "2\n", "authors": ["269"]}
{"title": "Experience with constructing code hunt contests\n", "abstract": " Puzzles are the basic building block of Code Hunt contests. Creating puzzles and choosing suitable puzzles from the puzzle bank turns out to be a complex operation requiring skill and experience. Constructing a varied and interesting mix of puzzles is based on several factors. The major factor is the difficulty of the puzzle, so that the contest can build up from easier puzzles to more difficult ones. For a successful and fun contest aimed at the expected abilities of the contestants, other factors include the language features needed to solve the puzzle, clues to provide when the puzzle is presented to the player, and test cases to seed into the Code Hunt engine. We describe our experience with contest construction over a period of year and provide guidelines for choosing and making adjustments to the puzzles so that a Code Hunt contest will provide a satisfying trouble-free experience for the contestants.", "num_citations": "1\n", "authors": ["269"]}
{"title": "Sound performance investigation of composite materials for the soundbox of a membrane musical instrument\n", "abstract": " The materials used in the manufacture of musical instruments with wooden sound box is obtained from trees in general. This fact creates difficulties due to problems with limited environmental resources. In addition, such materials vary widely in quality as they are biomaterial, and so it is necessary for musical instrument makers to invest a great deal of effort in quality control and in the wood drying process. To resolve these issues, we have begun the development of synthetic structure using glass fiber and carbon fiber composites with polyester resin for Turkish folk violin (Kemane) traditionally made from gourd was used in the construction. Three instruments were manufactured exactly the same using the traditional measures; two kinds of composite materials and the gourd. Computer modeling was created for composite and sound analysis was performed according to sound recordings of instruments. The analyzes were compared with the traditional gourd Kemane.", "num_citations": "1\n", "authors": ["269"]}
{"title": "Specifications in the development process: An ASML demonstration\n", "abstract": " AsmL is a specification system for software modeling, test generation, test validation, and implementation verification. It comprises a formal specification language, a set of libraries, and a test tool. It is integrated into the .NET Framework and Microsoft development tools. It has multiple source notations that can be used in a literate programming style either in an XML format or embedded within Microsoft Word. Specifications written in the system are executable, a novel feature which allows for semi-automatic test-case generation. In addition, the system can dynamically monitor an implementation to ensure that it conforms to its specification.", "num_citations": "1\n", "authors": ["269"]}