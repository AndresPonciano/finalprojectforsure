{"title": "Towards semantic robot description languages\n", "abstract": " There is a semantic gap between simple but high-level action instructions like \u201cPick up the cup with the right hand\u201d and low-level robot descriptions that model, for example, the structure and kinematics of a robot's manipulator. Currently, programmers bridge this gap by mapping abstract instructions to parametrized algorithms and rigid body parts of a robot within their control programs. By linking descriptions of robot components, i.e. sensors, actuators and control programs, via capabilities to actions in an ontology we equip robots with knowledge about themselves that allows them to infer the required components for performing a given action. Thereby a robot that is instructed by an end-user, a programmer, or even another robot to perform a certain action, can assess itself whether it is able and how to perform the requested action. This self-knowledge for robots could considerably change the way of robot control\u00a0\u2026", "num_citations": "135\n", "authors": ["2152"]}
{"title": "Challenges in Program Comprehension\n", "abstract": " Program comprehension as a subtask of software maintenance and evolution consumes about half of the time spent by the developers who have to explore a systems\u2019 source code to find and understand the subset of the code which is relevant to their current task. The problems encountered during the comprehension process influence the time spent on program comprehension to a great extent. Although many empirical studies have been conducted in the field of program comprehension, only little is known about the challenges developers face when trying to understand a software system. This paper reports on an observational study of 28 professional developers, investigating their behaviour with respect to the occurring problems.", "num_citations": "15\n", "authors": ["2152"]}
{"title": "Semiautomatic security requirements engineering and evolution using decision documentation, heuristics, and user monitoring\n", "abstract": " Security issues can have a significant negative impact on the business or reputation of an organization. In most cases they are not identified in requirements and are not continuously monitored during software evolution. Therefore, the inability of a system to conform to regulations or its endangerment by new vulnerabilities is not recognized. In consequence, decisions related to security might not be taken at all or become obsolete quickly. But to evaluate efficiently whether an issue is already addressed appropriately, software engineers need explicit decision documentation. Often, such documentation is not performed due to high overhead. To cope with this problem, we propose to document decisions made to address security requirements. To lower the manual effort, information from heuristic analysis and end user monitoring is incorporated. The heuristic assessment method is used to identify security issues in\u00a0\u2026", "num_citations": "10\n", "authors": ["2152"]}
{"title": "Automated extraction of failure reproduction steps from user interaction traces\n", "abstract": " Bug reports submitted by users and crash reports collected by crash reporting tools often lack information about reproduction steps, i.e. the steps necessary to reproduce a failure. Hence, developers have difficulties to reproduce field failures and might not be able to fix all reported bugs. We present an approach to automatically extract failure reproduction steps from user interaction traces. We capture interactions between a user and a WIMP GUI using a capture/replay tool. Then, we extract the minimal, failure-inducing subsequence of captured interaction traces. We use three algorithms to perform this extraction: Delta Debugging, Sequential Pattern Mining, and a combination of both. Delta Debugging automatically replays subsequences of an interaction trace to identify the minimal, failure-inducing subsequence. Sequential Pattern Mining identifies the common subsequence in interaction traces inducing the same\u00a0\u2026", "num_citations": "9\n", "authors": ["2152"]}
{"title": "Two User Perspectives in Program Comprehension: End Users and Developer Users\n", "abstract": " Recent empirical studies identified an interest of software developers in high-level usage information, i.e. Why and how end users employ a software application. Furthermore, recent empirical work found that developers of interactive applications put themselves in the role of users by interacting with the user interface during program comprehension. This paper presents an exploratory case study investigating these two user perspectives in detail. The study focuses on information needs regarding software usage and developers in the role of users during program comprehension. 21 developers from six software companies were observed during program comprehension tasks and interviewed. The resulting observation protocols and interview minutes were analyzed using coding. We found that developers are interested in information about use cases and user behavior, user goals and user needs, failure\u00a0\u2026", "num_citations": "9\n", "authors": ["2152"]}
{"title": "Towards Identification of Software Improvements and Specification Updates by Comparing Monitored and Specified End-User Behavior\n", "abstract": " Support of end-user needs is an important success factor for a software application. In order to optimize the support of end-user needs, developers have to be aware of them and their evolution over time. But a communication gap between developers and users leads to ignorance of developers about how users use their application. Also, developer assumptions about user behavior are rarely tested and corrected if they are wrong. Consequently, many software applications have a mediocre support of user needs and user problems as well as changes in user needs are detected rather late. In this paper, we present a research agenda addressing this problem by comparing use case descriptions to monitored user actions. More specifically, we propose to monitor user actions using instrumentation, detect the current use case of a user using machine learning, and compare use case steps to monitored user actions. By\u00a0\u2026", "num_citations": "7\n", "authors": ["2152"]}
{"title": "Reproducing software failures by exploiting the action history of undo features\n", "abstract": " Bug reports seldom contain information about the steps to reproduce a failure. Therefore, failure reproduction is a time consuming, difficult, and sometimes impossible task for software developers. Users are either unaware of the importance of steps to reproduce, are unable to describe them, or do not have time to report them. Similarly, automated crash reporting tools usually do not capture this information. In order to tackle this problem, we propose to exploit the action history of undo features, ie the history of user actions captured by many applications in order to allow users to undo previous actions. As it is captured anyway, our approach does not introduce additional monitoring overhead. We propose to extract the action history upon occurrence of a failure and present it to developers during bug fixing. Our hypothesis is that information about user actions contained in the action history of undo features enables\u00a0\u2026", "num_citations": "2\n", "authors": ["2152"]}
{"title": "How to Improve Decision Documentation in Software Evolution?\n", "abstract": " This problem statement describes the lack of effective methodologies and tool support for documenting decision knowledge during software evolution. After a brief description and definition of decisions in software evolution, we outline the current mismatch between the need for decision documentation and the effort required for documentation.", "num_citations": "2\n", "authors": ["2152"]}