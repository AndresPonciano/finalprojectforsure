{"title": "Complementary use case scenario representations based on domain vocabularies\n", "abstract": " Use cases are commonly used as notation for capturing functional requirements through scenarios. The problem is that there is no universal notation for use case contents which is capable of accommodating all the needs of software project participants. Business analysts and stakeholders need understandability and informality, while for architects and designers, precision and unambiguity are the most crucial features. In this paper we propose a metamodel and concrete syntax for three complementary representations of use case scenarios. These representations present the same information, but put emphasis on different aspects of it thus accommodating for different readers. This metamodel utilises the idea of separation of requirements as such from their representations as well as the idea of clear distinction between description of the system\u2019s behaviour and of the problem domain.", "num_citations": "48\n", "authors": ["2196"]}
{"title": "Case-based reuse with partial requirements specifications\n", "abstract": " A case-based approach allows reuse without the usual and significant effort for making software explicitly reusable. We even support such reuse for only partially developed requirements, since it allows reuse already without the need to develop a \u201ccomplete\u201d specification first. The solution information (models and code) of (one of) the most similar problems can then be taken for reuse and adapted to the newly specified requirements. And even the specification of these new requirements can be facilitated, since the retrieved software case contains related requirements, which may be reused as well.", "num_citations": "30\n", "authors": ["2196"]}
{"title": "Accommodating informality with necessary precision in use case scenarios\n", "abstract": " Paper contains a proposition of notation for use case scenarios that accommodates the needs of different roles in software development projects. Some roles require simple and informal English sentences with references to the domain vocabulary. Other roles need a relation and mapping to user interface elements or messages flowing inside the developed system. These contradictory requirements lead to a conclusion that the use case notation should be a composition of several notations with precisely defined rules for their transformation. There are proposed four such notations based on structured text, interaction diagrams and activity diagrams. There is also presented a mapping between specific elements of these notations and a mapping to elements of the static domain and design models.", "num_citations": "29\n", "authors": ["2196"]}
{"title": "Teaching software modeling in computing curricula\n", "abstract": " Modeling is a key skill in software development. The ability to develop, manipulate and understand models for software is therefore an important learning objective in many CS/SE courses. In this working group, we investigated how and when (software) modeling is taught to help us better understand the key issues in teaching (software) modeling. Several shortcomings were found in common curricula, both in their understanding of the term\\modeling\" and in how they address its teaching. This WG report summarizes the findings and formulates recommendations on the inclusion of software modeling courses in future CS/SE curricula.", "num_citations": "28\n", "authors": ["2196"]}
{"title": "Comprehensive system for systematic case-driven software reuse\n", "abstract": " Reuse of software artifacts (blueprints and code) is normally associated with organising a systematic reuse framework most often constructed for a specific problem domain. In this paper we present a system (language, tool, reuse process) where software reuse is based on building and retrieving of so-called software cases (large compound artifacts) that can be reused between domains. The system is opportunistic in that software cases result from usual (non-reuse oriented) activities where also semantic information is added. This information is used to support regular development but may serve later to retrieve software cases. Having this common semantic basis, we can organise a systematic cross-domain reuse process where application logic of one system can be reused for systems within different domains.", "num_citations": "25\n", "authors": ["2196"]}
{"title": "Facilitating transition from requirements to code with the ReDSeeDS tool\n", "abstract": " This paper presents a tool suite that automates transition from precise use case and domain models to code. The suite is built around the Requirements Specification Language (RSL) that is based on a precise constrained language grammar. RSL specifications can be used to generate complete MVC/MVP code structure together with method bodies of the Controller layer.", "num_citations": "20\n", "authors": ["2196"]}
{"title": "Translation of Use Case Scenarios to Java Code\n", "abstract": " EN Use cases are usually treated as second class citizens in the software development chain based on models. Their textual descriptions (scenarios) are treated as informal input to more formal design models that can then be (semi-) automatically transformed down to code. In this paper we will show that use case scenarios can gain precise metamodel-based notation and semantics enabling automatic processing. What is more, we will show transformation algorithms that can transform use case scenarios directly to dynamic code in Java. The presented transformation can generate the full structure of the system following the MVP architectural pattern, including complete method contents for the application logic (Presenter) and presentation (View) layers. It also provides a code skeleton for the domain logic (Model) layer. The use case notation and the transformation were implemented within a sophisticated tool suite. Based on this, the paper discusses the evaluation efforts based on a case study.", "num_citations": "19\n", "authors": ["2196"]}
{"title": "Scenario construction tool based on extended UML metamodel\n", "abstract": " Scenario based notations are becoming more and more popular as means for user requirements elicitation. They can be used in more formal specifications as part of detailed use case templates or in agile processes to capture informal user stories. Despite their significance in software engineering, scenarios seem not to be properly supported by appropriate tools. This paper describes a scenario construction tool that offers clear separation of the actual story from notions used therein. The tool is constructed as an extension to visual notation of UML\u2019s use cases. It is based on an extended UML metamodel in the area of activities and classifiers. This formal basis makes the tool capable of supplying the existing UML tools with an additional layer of requirements models based on scenarios and notions. This layer makes it possible to transform requirements directly into design-level models. The tool offers such\u00a0\u2026", "num_citations": "19\n", "authors": ["2196"]}
{"title": "Use cases in model-driven software engineering\n", "abstract": " Use cases have achieved wide use as specification tools for systems observable behavior, but there still remains a large gap between specifying behavior and determining the software components to build or procure. WUsCaM 05 \u2013 \u201cWorkshop on Use Cases in Model-Driven Software Engineering\u201d \u2013 brought together use case and MDSE experts from industry and academia to identify and characterize problem areas and promising approaches.", "num_citations": "18\n", "authors": ["2196"]}
{"title": "From Requirements to Java in a Snap\n", "abstract": " Back in 1988, Gerald M. Weinberg, in his seminal book \u201cUnderstanding the Professional Programmer\u201d[180] has formulated the following statement:\u201c\u2026 programming computers is by far the hardest intellectual task that human beings have ever tried to do. Ever.\u201d We can discuss this statement and argue with it but we have to admit that software development is an extremely complex task, and this is so for various reasons. Probably the most concise summary of these reasons was given by Fred Brooks in his famous essay \u201cNo Silver Bullet\u201d[26]. He has pointed out that software is composed of two types of complexity: essential and accidental. The essential aspect is inherent for the problem at hand and cannot be reduced. This complexity has to \u201cbe there\u201d in software so that it would be able to solve the actual problem. The accidental aspect is associated with the computer technology and includes things like programming\u00a0\u2026", "num_citations": "17\n", "authors": ["2196"]}
{"title": "Requirements-level language and tools for capturing software system essence\n", "abstract": " Creation of an unambiguous requirements specification with precise domain    vocabulary is crucial for capturing the essence of any software system,    either when developing a new system or when recovering knowledge from a    legacy one. Software specifications usually maintain noun notions and include    them in central vocabularies. Verb or adjective phrases are easily forgotten    and their definitions buried inside imprecise paragraphs of text. This paper    proposes a model-based language for comprehensive treatment of domain    knowledge, expressed through constrained natural language phrases that are    grouped by nouns and include verbs, adjectives and prepositions. In this    language, vocabularies can be formulated to describe behavioural    characteristics of a given problem domain. What is important, these    characteristics can be linked from within other specifications similarly to a    wiki. The application logic can be formulated through sequences of imperative    subject-predicate sentences containing only links to the phrases in the    vocabulary. The paper presents an advanced tooling framework to capture    application logic specifications making them available for automated    transformations down to code. The tools were validated through a controlled    experiment.", "num_citations": "17\n", "authors": ["2196"]}
{"title": "From Use Cases and Their Relationships to Code\n", "abstract": " Use cases are used in many methodologies to drive the software engineering process. Though, their transition to code was usually a mostly manual process. In the context of MDD, use cases gain attention as first-class artifacts with representation notations allowing for automatic transformations to analysis and design models. The paper concentrates on an important problem of constructing transformations that cater for use case relationships. It presents a notation that unifies the ambiguous \u201cinclude\u201d and \u201cextend\u201d, and allows for representing them within textual use case scenarios. This notation, equipped with runtime semantics, is used to construct a direct transformation into working code. The code is placed within method bodies of the Controller/Presenter and View layers within the MVC/MVP framework. Based on this transformation, an agile use-case-driven development process is possible.", "num_citations": "15\n", "authors": ["2196"]}
{"title": "Application Logic Patterns\u2013Reusable Elements of User-System Interaction\n", "abstract": " Patterns of various kind are commonly used to reduce costs and improve quality in software development. This paper introduces the concept of patterns at the level of detailed descriptions of the user-system dialogue. Application Logic Patterns define generalised sequences of interactions performed by the system and its users in the context of an abstract problem domain. The patterns are organised into a library. They are precisely described by a language which is defined through a strict meta-model. It extends the notation and semantics of the UML activities and use cases. Each of the patterns describing the visible system dynamics is linked to an abstract domain model central to all the patterns. The patterns can be easily instantiated by substituting abstract domain notions with the notions specific to a given domain. This ease of use and reduction in effort is validated in a controlled experiment using an\u00a0\u2026", "num_citations": "13\n", "authors": ["2196"]}
{"title": "Reusing terminology for requirements specifications from WordNet\n", "abstract": " In order to make requirements comprehensible to humans and as unambiguous as possible, a glossary and/or domain model is needed for defining the terminology used. Unless these are available from related projects, however,they are hard to create. Therefore, we propose to reuse terminology and its definition for requirements specifications from the semantic lexicon WordNet. For making this useful, however, we had to deal with the issue of disambiguation of the general terminology there for a given domain of a requirements specification.", "num_citations": "13\n", "authors": ["2196"]}
{"title": "Teaching software modeling in a simulated project environment\n", "abstract": " Teaching software engineering in the academia always faces the problem of inability to show problems of real life development projects. The courses seem to be unable to properly show the need of using software modeling as important means of coping with complexity and handling communication within the project. The paper presents format of a course that tries to overcome this. It focuses on application of modeling tools in a realistic software engineering environment. The objective is to teach best practices of software design and implementation with the use of UML. The students can practice design and communication techniques based around CASE tools in teams of 12 to 14 people. The paper summarizes 5 years of experience in teaching modeling with CASE tools. Authors present a concept of how to simulate the roles of architects, designers and programmers as close to reality as possible. The\u00a0\u2026", "num_citations": "13\n", "authors": ["2196"]}
{"title": "Runtime semantics of use case stories\n", "abstract": " Direct end-user participation in software system construction necessitates bringing general-purpose programming activities to the level understandable by \u201claymen\u201d. This paper introduces a new software development approach where stories written in commonly understood structured natural language gain runtime semantics. Stories are precisely linked to domain concepts and actions, thus forming the application logic of the system. These constructs are written at a high level of abstraction, very close to detailed software requirements specifications. In fact, they are structured into familiar use case models that include special \u201cinvocation\u201d relationships between use cases. At the same time, the paper proposes precise translational semantics for such defined stories. For each story element, equivalent Java code is derived. This semantics has been implemented within a tool containing a story editor and a code\u00a0\u2026", "num_citations": "10\n", "authors": ["2196"]}
{"title": "Mapping MOF-based requirements representations to ontologies for software reuse\n", "abstract": " In this paper, we combine MOF-based software representations and description logic-based mechanisms for facilitating software reuse. All software representations (requirements specifications, design models, code) arising from one project are combined in a software case and stored in a repository for later retrieval. For reuse purposes, we use requirements as search indexes. We map metamodel-based requirements specifications to an ontology and use a Description Logic reasoner for classification. This makes implicit taxonomical relations explicit. The inferred taxonomical hierarchy is then used to compute the taxonomical similarity between the current (initial) requirements and those in the repository. Doing so, we retrieve software cases with a high reuse potential. This approach has already been validated in an industrial context. 1", "num_citations": "10\n", "authors": ["2196"]}
{"title": "Automating acceptance testing with tool support\n", "abstract": " During acceptance testing different areas of delivered software system are reviewed. Usually these are functionality, business domain logic, non-functional characteristics, user interface. Although they are related to the same particular functional area, they are verified separately. This paper presents the concept and the Requirements Driven Software Testing (ReDSeT) tool, which allows for automatic integrated test generation based on different types of requirements. Tests are expressed in newly introduced Test Specification Language (TSL). The basis for functional test generation are detailed use case models. Furthermore, by combining different types of requirements, relations between tests are created. The constructed tool acknowledges validity of the presented concept.", "num_citations": "9\n", "authors": ["2196"]}
{"title": "Finite element approximation of biharmonic mathematical model for MHD flow using/spl Psi/-an approach\n", "abstract": " A generalized mathematical model describing the dynamics of magnetic field influence on a conducting liquid in a square cavity is presented. A method involving a biharmonic mathematical model with stream function /spl Psi/, and the magnetic potential A was used. The Galerkin method was applied to solve a system of two variational identities. A numerical finite element algorithm based on the second order elements was developed. In the algorithm the Newton-Raphson method is used to solve the resulting nonlinear system. Numerical experiments with different Reynolds (R/sub e/, R/sub m/) and Hartmann (H/sub /spl alpha//) numbers were presented in graphical form.", "num_citations": "9\n", "authors": ["2196"]}
{"title": "Numerical analysis of peristaltic MHD flows\n", "abstract": " The paper presents a generalized mathematical model describing the dynamics of magnetic field influence on a peristaltic flow of a conducting liquid in a two dimensional channel. A method using the stream function (/spl Psi/), vorticity (/spl xi/) and magnetic potential (A) is used. The Galerkin method is applied to obtain a system of three variational identities. A numerical finite element algorithm based on the second order elements is developed. The algorithm uses the Newton-Raphson method to solve the resulting nonlinear system. A simulator based on the formulated algorithm is constructed using object-oriented technology.", "num_citations": "9\n", "authors": ["2196"]}
{"title": "Numerical simulation of 2D MHD flows-/spl Psi/-/spl xi/-A method\n", "abstract": " Described in this paper is the flow of a viscous, non-compressible liquid with a property of electric current conduction, inside a channel with a rapidly expanded section, in an external magnetic field (B/spl I.oarr//sub 0/). A description is made using two vector potentials (A/spl I.oarr/, /spl Psi//spl I.oarr/), and the vorticity vector (/spl xi//spl I.oarr/), which form a system of three simultaneous, quasilinear equations of the elliptic type. An approximation is applied by constructing an iterative, finite difference algorithm for obtaining discrete value distribution of the above fields.", "num_citations": "9\n", "authors": ["2196"]}
{"title": "Requirements-Level Programming for Rapid Software Evolution\n", "abstract": " Rapid development of evolving software systems is highly associated with the ability to react quickly to changing user requirements. This paper presents a coherent set of technologies for simplifying the path from evolving requirements to code. The most important novel element on this path is a language defined at the level of requirements (understandable for non-IT experts) that is equipped with operational semantics. This means that it is possible to translate specifications written in this language, automatically into executable code. The language also allows for easy detection of changes in requirements. This detection can be propagated down to the code structure and appropriate code parts (these that are not automatically generated) indicated for rework. It will be demonstrated that the presented approach is effective and suitable for a wide range of problem domains as opposed to domain-specific approaches\u00a0\u2026", "num_citations": "8\n", "authors": ["2196"]}
{"title": "Software development with reusable requirements-based cases\n", "abstract": " 4 ing models to form a coherent path from requirements to code are given. Certain mechanisms for comparing and retrieving Software Cases are also specified. This includes a query language suitable for formulating queries that allow for matching requirements models thus allowing for reusing solutions to problems specified through requirements.", "num_citations": "7\n", "authors": ["2196"]}
{"title": "Writing coherent user stories with tool support\n", "abstract": " Writing good user stories for software systems seems to be a hard task. Story writers often tend to mix real stories (sequences of events) with descriptions of the domain (notion definitions). This often leads to inconsistencies and confusion in communication between the users and the developers. This paper proposes a tool that could support writing coherent user stories. The tool clearly separates the domain notion definitions from the actual stories. This leads to a consistent requirements model that is more readable by the users and also easier to implement by the developers.", "num_citations": "7\n", "authors": ["2196"]}
{"title": "A New Approach to Visualise Accessibility Problems of Mobile Apps in Source Code.\n", "abstract": " A wide range of software development is moving to the direction and domain of mobile applications. Single developer or small teams create apps for smartphones. Too often, they have not the capacity or know-how to check for usability problems and do not care for accessibility. We propose a novel workflow to bring usability issues into the development process: A quick accessibility evaluation (QAC) with 15 predefined metrics allow to collect issues. These issues are further condensed into formalised (UsabML) and the issues are tagged with the location in the source code. A dashboard view (RepoVis) showing the source code from a repository allows to spot and interactively inspect code and related issues simultaneously.", "num_citations": "6\n", "authors": ["2196"]}
{"title": "Model-driven acceptance test automation based on use cases\n", "abstract": " Acceptance testing is highly dependent on the formulation of requirements, as    the final system is tested against user requirements. It is thus highly    desirable to be able to automate transition from requirements to acceptance    tests. In this paper we present a model-driven approach to this issue, where    detailed use case models are transformed into test cases. Importantly, our    approach facilitates synchronising functional test cases with other types of    tests (non-functional, domain logic, user interface) and introducing test    data. This leads to a unified approach where requirements models of various    kind drive the acceptance testing process. This process is parallel to the    development process which also involves automatic transformations from    requirements models to software development artefacts (models and code). To    show validity of the approach we present a case study which uses a new tool    called ReDSeT, that transforms requirements formulated in the Requirements    Specification Language (RSL) into tests in a newly proposed Test    Specification Language (TSL).", "num_citations": "6\n", "authors": ["2196"]}
{"title": "From user stories to code in one day?\n", "abstract": " User stories in software engineering serve the purpose of discovering requirements and are used as units of system development. When applying stories in a project, two elements seem to be crucial: the ability to write coherent sequences of events and the ability to transform these sequences into code quickly and resourcefully. In this paper, these qualities are reflected in a notation that can be described as \u201cstories with notions\u201d. This notation separates the story\u2019s sequence of events from the description of terms used in this sequence. Such a formal separation does not limit and rather enhances invention, at the same time rising the level of consistence, and facilitating translation into models of code. This translation maps domain notions into static code constructs (classes, interfaces) and also maps stories into dynamic sequences of messages. With such a mapping, programming becomes equivalent to\u00a0\u2026", "num_citations": "6\n", "authors": ["2196"]}
{"title": "Recovery and Migration of Application Logic from Legacy Systems\n", "abstract": " It is more than obvious that the functioning of most companies and organizations is heavily dependent on software assets which automate or support most of their business processes. Many of such software applications have been in production for years being constantly evolved in order to adapt them to business changes resulting both from changing market needs as well as emerging new technologies providing new business opportunities. Service Oriented Architecture (SOA) and cloud computing are seen as the most dominant software engineering paradigms nowadays. They have dramatically changed the way software systems are designed, delivered and used, what also implies changes in the way business services are provided [1]. For many organizations the transition of their legacy applications to", "num_citations": "5\n", "authors": ["2196"]}
{"title": "Profile suite for model transformations on the computation independent level\n", "abstract": " Transformations of models on the Computation Independent level of the MDA framework seem to have little focus in the current research. This is despite their great significance for ensuring traceability of business requirements into system design and implementation. Hence, this paper proposes a suite of profiles that define appropriate models and transformations between them. There is briefly described a set of well-formedness rules for the models, and a set of mappings and rules that allow for model transformations. These mappings and rules are presented in the context of UML 2.0 Profiles.", "num_citations": "5\n", "authors": ["2196"]}
{"title": "Generating database access code from domain models\n", "abstract": " Automatic processing of requirements (e.g. to generate code) remains a challenge in contemporary software development. Requirements are still treated as secondary artifacts by software developers, as they are written in natural languages which causes ambiguity. In this paper, we present an approach to generate working code from requirements through applying precisely formulated domain models. As the source, we use the Requirements Specification Language (RSL) which is a precise constrained language, based on a central domain model composed of domain notions. These notions are linked from use case scenarios and create a form of a `wiki'. Notions are graphically visualized in RSL, and resemble UML classes with attributes. Notions can be used in phrases that can represent various operations used within use case scenarios. In our approach we introduce model transformation algorithms that allow\u00a0\u2026", "num_citations": "4\n", "authors": ["2196"]}
{"title": "Mechanisms for requirements based model reuse\n", "abstract": " The paper presents a sketch of a methodology for model-reuse-oriented software development. It describes a methodological core, reuse enabling interface and reuse methodological plug-in. These elements form a methodological basis for the construction of an automatic software case modeling, mapping and retrieval tool.", "num_citations": "4\n", "authors": ["2196"]}
{"title": "Developer Modelling using Software Quality Metrics and Machine Learning.\n", "abstract": " Software development has become an essential activity for organizations that increasingly rely on these to manage their business. However, poor software quality reduces customer satisfaction, while high-quality software can reduce repairs and rework by more than 50 percent. Software development is now seen as a collaborative and technology-dependent activity performed by a group of people. For all these reasons, choosing correctly software development members teams can be decisive. Considering this motivation, classifying participants in different profiles can be useful during project management team\u2019s formation and tasks distribution. This paper presents a developer modeling approach based on software quality metrics. Quality metrics are dynamically collected. Those metrics compose the developer model. A machine learning-based method is presented. Results show that it is possible to use quality metrics to model developers.", "num_citations": "3\n", "authors": ["2196"]}
{"title": "Domain-Driven Reuse of Software Design Models\n", "abstract": " This chapter presents an approach to software development where model driven development and software reuse facilities are combined in a natural way. The basis for all of this is a semiformal requirements language RSL. The requirements in RSL consist of use cases refined by scenarios in a simple controlled natural language and the domain vocabulary containing the domain concepts. The chapter shows how model transformations building a platform independent model (PIM) can be applied directly to the requirements specified in RSL by domain experts. Further development of the software case (PSM, code) is also supported by transformations, which in addition ensure a rich traceability within the software case. The reuse support relies on a similarity based comparison of requirements for software cases. If a similar part is found in an existing software case, a traceability link based slice of the solution can be\u00a0\u2026", "num_citations": "3\n", "authors": ["2196"]}
{"title": "Applying use case logic patterns in practice: lessons learnt\n", "abstract": " Use cases are popular means to specify functional requirements in terms of application logic. A typical way to represent this logic is through scenarios expressed using textual or graphical notations. Use case scenarios can be generalised to offer abstract use cases \u2013 use case logic patterns. Such patterns capture recurring logic of user-system interactions independent of the particular problem domain. They are composed of abstract use case models and use case scenarios formulated in constrained natural language. Scenarios refer uniformly to an abstract domain model. Use case patterns can be easily instantiated through substituting the abstract domain with a concrete one. In this paper we present a study on application of use case patterns in a real industry project. At first, the project attempted at specifying reoccurring functionality using an ad-hoc approach. This resulted in poor quality specifications as\u00a0\u2026", "num_citations": "2\n", "authors": ["2196"]}
{"title": "Enterprise Information Systems: 19th International Conference, ICEIS 2017, Porto, Portugal, April 26-29, 2017, Revised Selected Papers\n", "abstract": " This book constitutes extended and revised papers from the 19th International Conference on Enterprise Information Systems, ICEIS 2017, held in Porto, Portugal, in April 2017. The 28 papers presented in this volume were carefully reviewed and selected for inclusion in this book from a total of 318 submissions. They were organized in topical sections named: databases and information systems integration; artificial intelligence and decision support systems; information systems analysis and specification; software agents and internet computing; human-computer interaction; and enterprise architecture.", "num_citations": "2\n", "authors": ["2196"]}
{"title": "Acceptance test generation based on detailed use case models\n", "abstract": " Tests performed in order to verify compliance of a software system with customer expectations cover different areas. Some of them verify the functionality, other\u2013the business domain logic, the non-functional characteristics or the user interface. Usually they are done separately, but on the same functional areas. This paper presents the concept for the Requirements Driven Software Testing (ReDSeT) tool, which allows for automatic integrated test generation based on different types of requirements. Tests are expressed in newly introduced Test Specification Language (TSL). The basis for functional test generation are detailed use case models. Furthermore, by combining different types of requirements, relations between tests are created. The constructed tool acknowledges validity of the presented concept.", "num_citations": "2\n", "authors": ["2196"]}
{"title": "Global reuse strategy based on use cases\n", "abstract": " The paper introduces two concepts based on use cases: business patterns and automation patterns. It describes a connection between the business and automation patterns with classes. Finally, it presents an idea of a multi-level library that allows global reuse of software development models and code.", "num_citations": "2\n", "authors": ["2196"]}
{"title": "BalticLSC: Low-Code Software Development Platform for Large Scale Computations\n", "abstract": " In modern times, innovation often requires performing complex computations in a short amount of time. However, for many small organisations and freelance innovators, large-scale computations remain beyond reach because of the small accessibility of computation resources and the lack of knowledge required to use them efficiently. The BalticLSC Platform is a software development and computing environment created to address this issue. This paper presents the associated software development process. The platform users can perform advanced computations using ready applications or develop new applications quickly from available components. This can be done using a visual notation called the Computation Application Language (CAL). CAL programs are developed in a dedicated online editor, through selecting and connecting reusable computation modules. If a required module is missing, it can be quickly created by encapsulating code inside a standardised container. The platform's ultimate goal is to relieve the developers from the need to understand the complexity of the distributed parallel computation environment. The platform was implemented in the form of an online software development portal. Validation of the platform consisted in the development of applications and modules by students not experienced in programming. The results of this validation acknowledge the required platform's characteristics.", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Towards a unified requirements model for distributed high performance computing\n", "abstract": " High Performance Computing (HPC) consists in development and execution of sophisticated computation applications, developed by highly skilled IT personnel. Several past studies report significant problems with applying HPC in industry practice. This is caused by lack of necessary IT skills in developing highly parallelised and distributed computation software. This calls for new methods to reduce software development effort when constructing new computation applications. In this paper we propose a generic requirements model consisting of a conceptual domain specification, unified domain vocabulary and use-case-based functional requirements. Vocabulary definition provides detailed clarifications of HPC fundamental component elements and their role in the system. Further we address security issues by providing transparency principles for HPC. We also propose a research agenda that leads to the\u00a0\u2026", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Introducing requirements-driven modelling\n", "abstract": " Requirements play a pivotal role in software development because they express the needs of the customer. A quality software system can emerge only when the real needs of the client are discovered. However, this is not enough. A typical software development project faces the problem of translating the user needs into a working system. These problems are dealt with by hundreds of books on various aspects of software design and pertaining to the plethora of software development technologies we can choose from. Related activities produce important artefacts that are treated as primary in software development: design models and code. Software design and coding directly contributes to the final system, and thus their results are treated as first-class citizens in the world of software development.", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Developing Software with Domain-Driven Model Reuse\n", "abstract": " This chapter presents an approach to software development where model-driven development and software reuse facilities are combined in a natural way. It shows how model transformations building a Platform Independent Model (PIM) can be applied directly to the requirements specified in RSL by domain experts. Further development of the software case (PSM, code) is also supported by transformations, which in addition ensure a rich traceability within the software case. Alternatively, the PSM model and code can also be generated directly from requirements in RSL, thus providing fast development of the final code of at least a system prototype in many situations. The reuse support relies on a similarity-based comparison of requirements for software cases. If a similar part is found in an existing software case, a traceability link-based slice of the solution can be merged into the new case. The implementation of\u00a0\u2026", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Using structured grammar domain models to capture software system essence\n", "abstract": " Creation of a precise domain vocabulary is crucial for capturing the essence of any software system, either when recovering knowledge from a legacy system or when formulating requirements for a new one. Software specifications usually maintain noun notions and include them in central vocabularies. Verb or adjective phrases are easily forgotten and their definitions buried inside imprecise paragraphs of text. This paper proposes a model-based language for comprehensive treatment of domain knowledge, expressed through constrained natural language phrases that are grouped by nouns and include verbs, adjectives and prepositions. In this language, vocabularies can be formulated to describe behavioural, declarative and conditional characteristics of a given problem domain. What is important, these characteristics can be used (linked) from within other specifications similarly to a wiki. In particular, the\u00a0\u2026", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Using structured grammar domain models to capture software system essence\n", "abstract": " Creation of a precise domain vocabulary is crucial for capturing the essence of any software system, either when recovering knowledge from a legacy system or when formulating requirements for a new one. Software specifications usually maintain noun notions and include them in central vocabularies. Verb or adjective phrases are easily forgotten and their definitions buried inside imprecise paragraphs of text. This paper proposes a model-based language for comprehensive treatment of domain knowledge, expressed through constrained natural language phrases that are grouped by nouns and include verbs, adjectives and prepositions. In this language, vocabularies can be formulated to describe behavioural, declarative and conditional characteristics of a given problem domain. What is important, these characteristics can be used (linked) from within other specifications similarly to a wiki. In particular, the application logic can be formulated through sequences of imperative Subject-Predicate sentences containing only links to the phrases in the vocabulary. The paper presents initial tooling framework to capture application logic specifications and make them available for further automated transformations.", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Current issues in teaching software modeling: Educators symposium at MODELS 2008\n", "abstract": " Software modeling is an increasingly popular method among software development teams to overcome the problems associated with complexity of contemporary software systems. It can be argued that teaching modeling to software engineers is as important as teaching maths and physics to general engineers. This lead many academic and industrial centers to introducing modeling courses to their curricula. Unfortunately, it seems that education does not yet support the modeling paradigm well enough, thus limiting its acceptance as a mature method of developing software systems. This symposium sought for innovations on teaching modeling that would show its benefits in attractive and pedagogically effective ways. Three areas that need improvement were identified: placing modeling in the software engineering curriculum, teaching model semantics, and tool support for teaching modeling. Several\u00a0\u2026", "num_citations": "1\n", "authors": ["2196"]}
{"title": "KOMPLEKSOWY SYSTEM PO OW EGO WYKORZYSTA IA MODELI OPROGRAMOWA IA\n", "abstract": " Wzrastaj\u0105ca z\u0142o ono\u015b\u0107 system\u00f3w oprogramowania, spowodowana z\u0142o ono\u015bci\u0105 wymaga\u0144 i zmienno\u015bci\u0105 technologii, powoduje problemy zwi\u0105zane z ponownym wykorzystaniem zgromadzonych konkretnych rozwi\u0105za\u0144. Niniejszy rozdzia\u0142 przedstawia metod\u0119 ponownego wykorzystania tzw.\u201eprzypadk\u00f3w oprogramowania\u201d opart\u0105 na og\u00f3lnej metodzie CBR. W przedstawionej metodzie, re-u yciu podlegaj\u0105 specyfikacje wymaga\u0144 powi\u0105zane w spos\u00f3b jednoznaczny z modelami projektowymi i kodem. Wyszukiwanie przypadk\u00f3w oprogramowania nast\u0119puje poprzez por\u00f3wnanie specyfikacji wymaga\u0144 zapisanych przy pomocy j\u0119zyka modelowania RSL o dobrze okre\u015blonej sk\u0142adni i semantyce. Modele projektowe oraz kod w ramach przypadk\u00f3w oprogramowania pochodz\u0105 bezpo\u015brednio z modelu wymaga\u0144. Przej\u015bcie mi\u0119dzy wymaganiami a projektem nast\u0119puje zgodnie z regu\u0142ami transformacji, kt\u00f3re umo liwiaj\u0105\u00a0\u2026", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Model management based on a visual transformation language\n", "abstract": " Modeling becomes the most prominent method of dealing with software complexity. Models for software systems can be created on different levels of abstraction and in different phases of the software development process. In order to manage these various models effectively we need to apply methods for keeping them coherent and traceable. The current paper proposes a method for defining and executing transformations between models written in the currently most popular modeling language (UML). We propose a general purpose transformation language that allows for specifying transformation mappings between different models. This language has a visual (MOF-based) notation and allows for defining transformation templates and rules. With this language, the software developers are capable of determining traceability links between individual model elements. Moreover, the transformations can be executed\u00a0\u2026", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Intelligent Content Management System\n", "abstract": " The primary objective of the ICONS Project Presentation report is to provide a baseline platform for all ICONS project stakeholders representing the consensus of the ICONS consortium members with respect to the ICONS research and development strategy. Much effort has gone into interactions among members of the ICONS research and development community aiming at reconciliation of diverse views and specialisations in the relevant research realms. We assume that the ensuing research results may require refinements and modifications of the underlying ICONS assumptions and we plan to reflect them in the ensuing versions of the report. Hence, this report is to \u201clive: status document reflecting the current views of the ICONS consortium.The initial effort has gone into the Knowledge Management System (KMS) feature requirements analysis in order to establish compatibility of requirements voiced by the knowledge management community and the prevailing opinions and conclusions of the on-going research work in the IT field. Our motivation has been to verify the ICONS project goals and objectives and possibly to re-orient some of the principal research and development objectives.", "num_citations": "1\n", "authors": ["2196"]}
{"title": "Analysis of magnetohydrodynamic pressure in conducting fluids\n", "abstract": " The process of magnetic field influence on the movement of a viscous, conducting liquid was described by using a Maxwell-Navier-Stokes system of equations. By introducing vector potentials /spl Psi/, /spl zeta/, A and elements of dimensional analysis, a nonlinear Poisson equation was produced for a function describing pressure distribution in a flat channel. For a Poiseuille flow there was formulated a Neuman boundary condition in a generalised form as an integral identity. To solve the above problem, a finite element approximation method was used. Appropriate numerical experiments were conducted. The calculation results were presented as a family of constant pressure lines and as lines of pressure value on the channel boundaries. All the experiments were performed for different values of criterion numbers: Reynolds (R/sub e/), Reynolds magnetic (R/sub m/) and Hartman (H/sub a/).", "num_citations": "1\n", "authors": ["2196"]}