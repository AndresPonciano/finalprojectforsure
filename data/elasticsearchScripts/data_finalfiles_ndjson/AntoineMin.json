{"title": "The octagon abstract domain\n", "abstract": " This article presents the octagon abstract domain, a relational numerical abstract domain for static analysis by abstract interpretation. It allows representing conjunctions of constraints of the form \u00b1 X \u00b1 Y \u2264 c where X and Y range among program variables and c is a constant in \u2124, \u211a, or \u211d automatically inferred. Abstract elements are represented using modified Difference Bound Matrices and we use a normalization algorithm loosely based on the shortest-path closure to compute canonical representations and construct best-precision abstract transfer functions. We achieve a quadratic memory cost per abstract element and a cubic worst-case time cost per abstract operation, with respect to the number of program variables.               In terms of cost and precision, our domain is in between the well-known fast but imprecise interval domain and the costly polyhedron domain. We show that it is precise enough to\u00a0\u2026", "num_citations": "1113\n", "authors": ["1744"]}
{"title": "Apron: A Library of Numerical Abstract Domains for Static Analysis\n", "abstract": " This article describes Apron, a freely available library dedicated to the static analysis of the numerical variables of programs by abstract interpretation. Its goal is threefold: provide analysis implementers with ready-to-use numerical abstractions under a unified API, encourage the research in numerical abstract domains by providing a platform for integration and comparison, and provide teaching and demonstration tools to disseminate knowledge on abstract interpretation.", "num_citations": "473\n", "authors": ["1744"]}
{"title": "A new numerical abstract domain based on difference-bound matrices\n", "abstract": " This paper presents a new numerical abstract domain for static analysis by abstract interpretation. This domain allows us to represent invariants of the form (x \u2212 y = c) and (\u00b1x = c) , where x and y are variables values and c is an integer or real constant.               Abstract elements are represented by Difference-Bound Matrices, widely used by model-checkers, but we had to design new operators to meet the needs of abstract interpretation. The result is a complete lattice of infinite height featuring widening, narrowing and common transfer functions. We focus on giving an efficient O(n                         2)re presentation and graph-based O(n                         3)algorit hms\u2014where n is the number of variables\u2014and claim that this domain always performs more precisely than the well-known interval domain.               To illustrate the precision/cost tradeoff of this domain, we have implemented simple abstract interpreters for\u00a0\u2026", "num_citations": "254\n", "authors": ["1744"]}
{"title": "Weakly relational numerical abstract domains\n", "abstract": " The goal of this thesis is to design techniques related to the automatic analysis of computer programs. One major application is the creation of tools to discover bugs before they actually happen, an important goal in a time when critical yet complex tasks are performed by computers. We will work in the Abstract Interpretation framework, a theory of sound approximation of program semantics. We will focus, in particular, on numerical abstract domains that specialize in the automatic discovery of properties of the numerical variables of programs. In this thesis, we introduce new numerical abstract domains: the zone abstract domain (that can discover invariants of the form XY\u2264 c), the zone congruence domain (X\u2261 Y+ c [b]), and the octagon domain (\u00b1X\u00b1Y\u2264 c), among others. These domains rely on the classical notions of potential graphs, difference bound matrices, and algorithms for the shortest path closure computation. They are in-between, in terms of cost and precision, between non-relational domains (such as the interval domain), that are very imprecise, and classical relational domains (such as the polyhedron domain), that are very costly. We will call them\" weakly relational.\" We also introduce some methods to apply relational domains to the analysis of floating-point numbers, which was previously only possible using imprecise, non-relational domains. Finally, we introduce so-called\" linearization\" and\" symbolic constant propagation\" generic methods to enhance the precision of any numerical domain, for a low increase in cost. The analysis framework presented in this thesis has been integrated within Astr\u00e9e, an analyzer for critical embedded\u00a0\u2026", "num_citations": "215\n", "authors": ["1744"]}
{"title": "Relational abstract domains for the detection of floating-point run-time errors\n", "abstract": " We present a new idea to adapt relational abstract domains to the analysis of IEEE 754-compliant floating-point numbers in order to statically detect, through Abstract Interpretation-based static analyses, potential floating-point run-time exceptions such as overflows or invalid operations. In order to take the non-linearity of rounding into account, expressions are modeled as linear forms with interval coefficients. We show how to extend already existing numerical abstract domains, such as the octagon abstract domain, to efficiently abstract transfer functions based on interval linear forms. We discuss specific fixpoint stabilization techniques and give some experimental results.", "num_citations": "205\n", "authors": ["1744"]}
{"title": "Field-sensitive value analysis of embedded C programs with union types and pointer arithmetics\n", "abstract": " We propose a memory abstraction able to lift existing numerical static analyses to C programs containing union types, pointer casts, and arbitrary pointer arithmetics. Our framework is that of a combined points-to and data-value analysis. We abstract the contents of compound variables in a field-sensitive way, whether these fields contain numeric or pointer values, and use stock numerical abstract domains to find an overapproximation of all possible memory states---with the ability to discover relationships between variables. A main novelty of our approach is the dynamic mapping scheme we use to associate a flat collection of abstract cells of scalar type to the set of accessed memory locations, while taking care of byte-level aliases---ie, C variables with incompatible types allocated in overlapping memory locations. We do not rely on static type information which can be misleading in C programs as it does not\u00a0\u2026", "num_citations": "152\n", "authors": ["1744"]}
{"title": "Symbolic methods to enhance the precision of numerical abstract domains\n", "abstract": " We present lightweight and generic symbolic methods to improve the precision of numerical static analyses based on Abstract Interpretation. The main idea is to simplify numerical expressions before they are fed to abstract transfer functions. An important novelty is that these simplifications are performed on-the-fly, using information gathered dynamically by the analyzer.             A first method, called \u201clinearization,\u201d allows abstracting arbitrary expressions into affine forms with interval coefficients while simplifying them. A second method, called \u201csymbolic constant propagation,\u201d enhances the simplification feature of the linearization by propagating assigned expressions in a symbolic way. Combined together, these methods increase the relationality level of numerical abstract domains and make them more robust against program transformations. We show how they can be integrated within the classical interval\u00a0\u2026", "num_citations": "127\n", "authors": ["1744"]}
{"title": "A few graph-based relational numerical abstract domains\n", "abstract": " This article presents the systematic design of a class of relational numerical abstract domains from non-relational ones. Constructed domains represent sets of invariants of the form (v                                       j                - v                                       i                                     \u2208 C), where vj and vi are two variables, and C lives in an abstraction of  ,  , or  . We will call this family of domains weakly relational domains. The underlying concept allowing this construction is an extension of potential graphs and shortest-path closure algorithms in exotic-like algebras. Example constructions are given in order to retrieve well-known domains as well as new ones. Such domains can then be used in the Abstract Interpretation framework in order to design various static analyses. A major benefit of this construction is its modularity, allowing to quickly implement new abstract domains from existing ones.", "num_citations": "74\n", "authors": ["1744"]}
{"title": "Relational thread-modular static value analysis by abstract interpretation\n", "abstract": " We study thread-modular static analysis by abstract interpretation to infer the values of variables in concurrent programs. We show how to go beyond the state of the art and increase an analysis precision by adding the ability to infer some relational and history-sensitive properties of thread interferences. The fundamental basis of this work is the formalization by abstract interpretation of a rely-guarantee concrete semantics which is thread-modular, constructive, and complete for safety properties. We then show that previous analyses based on non-relational interferences can be retrieved as coarse computable abstractions of this semantics; additionally, we present novel abstraction examples exploiting our ability to reason more precisely about interferences, including domains to infer relational lock invariants and the monotonicity of counters. Our method and domains have been implemented in the Astr\u00e9eA\u00a0\u2026", "num_citations": "67\n", "authors": ["1744"]}
{"title": "Static analysis of run-time errors in embedded critical parallel C programs\n", "abstract": " We present a static analysis by Abstract Interpretation to check for run-time errors in parallel C programs. Following our work on Astr\u00e9e, we focus on embedded critical programs without recursion nor dynamic memory allocation, but extend the analysis to a static set of threads. Our method iterates a slightly modified non-parallel analysis over each thread in turn, until thread interferences stabilize. We prove the soundness of the method with respect to a sequential consistent semantics and a reasonable weakly consistent memory semantics. We then show how to take into account mutual exclusion and thread priorities through partitioning over the scheduler state. We present preliminary experimental results analyzing a real program with our prototype, Th\u00e9s\u00e9e, and demonstrate the scalability of our approach.", "num_citations": "67\n", "authors": ["1744"]}
{"title": "A constraint solver based on abstract domains\n", "abstract": " In this article, we apply techniques from Abstract Interpretation (a general theory of semantic abstractions) to Constraint Programming (which aims at solving hard combinatorial problems with a generic framework based on first-order logics). We highlight some links and differences between these fields: both compute fixpoints by iteration but employ different extrapolation and refinement strategies; moreover, consistencies in Constraint Programming can be mapped to non-relational abstract domains. We then use these correspondences to build an abstract constraint solver that leverages abstract interpretation techniques (such as relational domains) to go beyond classic solvers. We present encouraging experimental results obtained with our prototype implementation.", "num_citations": "54\n", "authors": ["1744"]}
{"title": "A decision tree abstract domain for proving conditional termination\n", "abstract": " We present a new parameterized abstract domain able to refine existing numerical abstract domains with finite disjunctions. The elements of the abstract domain are decision trees where the decision nodes are labeled with linear constraints, and the leaf nodes belong to a numerical abstract domain.             The abstract domain is parametric in the choice between the expressivity and the cost of the linear constraints for the decision nodes (e.g., polyhedral or octagonal constraints), and the choice of the abstract domain for the leaf nodes. We describe an instance of this domain based on piecewise-defined ranking functions for the automatic inference of sufficient preconditions for program termination.             We have implemented a static analyzer for proving conditional termination of programs written in (a subset of) C and, using experimental evidence, we show that it performs well on a wide variety of\u00a0\u2026", "num_citations": "53\n", "authors": ["1744"]}
{"title": "Static analysis of run-time errors in embedded real-time parallel C programs\n", "abstract": " We present a static analysis by Abstract Interpretation to check for run-time errors in parallel and multi-threaded C programs. Following our work on Astr\\'ee, we focus on embedded critical programs without recursion nor dynamic memory allocation, but extend the analysis to a static set of threads communicating implicitly through a shared memory and explicitly using a finite set of mutual exclusion locks, and scheduled according to a real-time scheduling policy and fixed priorities. Our method is thread-modular. It is based on a slightly modified non-parallel analysis that, when analyzing a thread, applies and enriches an abstract set of thread interferences. An iterator then re-analyzes each thread in turn until interferences stabilize. We prove the soundness of our method with respect to the sequential consistency semantics, but also with respect to a reasonable weakly consistent memory semantics. We also show how to take into account mutual exclusion and thread priorities through a partitioning over an abstraction of the scheduler state. We present preliminary experimental results analyzing an industrial program with our prototype, Th\\'es\\'ee, and demonstrate the scalability of our approach.", "num_citations": "46\n", "authors": ["1744"]}
{"title": "Tutorial on static inference of numeric invariants by abstract interpretation\n", "abstract": " Born in the late 70s, Abstract Interpretation has proven an effective method to construct static analyzers. It has led to successful program analysis tools routinely used in avionic, automotive, and space industries to help ensuring the correctness of missioncritical software.This tutorial presents Abstract Interpretation and its use to create static analyzers that infer numeric invariants on programs. We first present the theoretical bases of Abstract Interpretation: how to assign a well-defined formal semantics to programs, construct computable approximations to derive effective analyzers, and ensure soundness, ie, any property derived by the analyzer is true of all actual executions\u2014although some properties may be missed due to approximations, a necessary compromise to keep the analysis automatic, sound, and terminating when inferring uncomputable properties. We describe the classic numeric abstractions readily available to an analysis designer: intervals, polyhedra, congruences, octagons, etc., as well as domain combiners: the reduced product and various disjunctive completions. This tutorial focuses not only on the semantic aspect, but also on the algorithmic one, providing a description of the data-structures and algorithms necessary to effectively implement all our abstractions. We will encounter many trade-offs between cost on the one hand, and precision and expressiveness on the other hand. Invariant inference is formalized on an idealized, toy-language, manipulating perfect numbers, but the principles and algorithms we present are effectively used in analyzers for real industrial programs, although this is out of the scope of this tutorial\u00a0\u2026", "num_citations": "44\n", "authors": ["1744"]}
{"title": "An abstract domain to infer ordinal-valued ranking functions\n", "abstract": " The traditional method for proving program termination consists in inferring a ranking function. In many cases (i.e. programs with unbounded non-determinism), a single ranking function over natural numbers is not sufficient. Hence, we propose a new abstract domain to automatically infer ranking functions over ordinals.               We extend an existing domain for piecewise-defined natural-valued ranking functions to polynomials in \u03c9, where the polynomial coefficients are natural-valued functions of the program variables. The abstract domain is parametric in the choice of the maximum degree of the polynomial, and the types of functions used as polynomial coefficients.               We have implemented a prototype static analyzer for a while-language by instantiating our domain using affine functions as polynomial coefficients. We successfully analyzed small but intricate examples that are out of the reach of\u00a0\u2026", "num_citations": "37\n", "authors": ["1744"]}
{"title": "Abstract domains for bit-level machine integer and floating-point operations\n", "abstract": " We present a few lightweight numeric abstract domains to analyze C programs that exploit the binary representation of numbers in computers, for instance to perform \"compute-through-overflow\" on machine integers, or to directly manipulate the exponent and mantissa of floating-point numbers. On integers, we propose an extension of intervals with a modular component, as well as a bitfield domain. On floating-point numbers, we propose a predicate domain to match, infer, and propagate selected expression patterns. These domains are simple, efficient, and extensible. We have included them into the Astr\u00e9e and Astr\u00e9eA static analyzers to supplement existing domains. Experimental results show that they can improve the analysis precision at a reasonable cost.", "num_citations": "28\n", "authors": ["1744"]}
{"title": "Towards an industrial use of sound static analysis for the verification of concurrent embedded avionics software\n", "abstract": " Formal methods, and in particular sound static analyses, have been recognized by Certification Authorities as reliable methods to certify embedded avionics software. For sequential C software, industrial static analyzers, such as Astree, already exist and are deployed. This is not the case for concurrent C software. This article discusses the requirements for sound static analysis of concurrent embedded software at Airbus and presents AstreeA, an extension of Astree with the potential to address these requirements: it is scalable and reports soundly all run-time errors with few false positives. We illustrate this potential on a variety of case studies targeting different avionics software components, including large ARINC 653 and POSIX threads applications, and a small part of an operating system. While the experiments on some case studies were conducted in an academic setting, others were conducted in an industrial\u00a0\u2026", "num_citations": "25\n", "authors": ["1744"]}
{"title": "Static value analysis of Python programs by abstract interpretation\n", "abstract": " We propose a static analysis by abstract interpretation for a significant subset of Python to infer variable values, run-time errors, and uncaught exceptions. Python is a high-level language with dynamic typing, a class-based object system, complex control structures such as generators, and a large library of builtin objects. This makes static reasoning on Python programs challenging. The control flow is highly dependent on the type of values, which we thus infer accurately.               As Python lacks a formal specification, we first present a concrete collecting semantics of reachable program states. We then propose a non-relational flow-sensitive type and value analysis based on simple abstract domains for each type, and handle non-local control such as exceptions through continuations. We show how to infer relational numeric invariants by leveraging the type information we gather. Finally, we propose a\u00a0\u2026", "num_citations": "23\n", "authors": ["1744"]}
{"title": "Inferring sufficient conditions with backward polyhedral under-approximations\n", "abstract": " In this article, we discuss the automatic inference of sufficient pre-conditions by abstract interpretation and sketch the construction of an under-approximating backward analysis. We focus on numeric domains and propose transfer functions, including a lower widening, for polyhedra, without resorting to disjunctive completion nor complementation, while soundly handling non-determinism. Applications include the derivation of sufficient conditions for a program to never step outside an envelope of safe states, or dually to force it to eventually fail. Our construction is preliminary and essentially untried, but we hope to convince that this avenue of research is worth considering.", "num_citations": "22\n", "authors": ["1744"]}
{"title": "Domaines num\u00e9riques abstraits faiblement relationnels\n", "abstract": " theses.fr \u2013 Antoine Min\u00e9 , Domaines num\u00e9riques abstraits faiblement relationnels Connexion Retour \u00e0 l'accueil Toutes les th\u00e8ses Th\u00e8ses en pr\u00e9paration Personnes Organismes D\u00e9sactiver l'autocompl\u00e9tion Recherche avanc\u00e9e Uniquement les th\u00e8ses soutenues Uniquement les th\u00e8ses soutenues accessibles en ligne SIGNALER une erreur EXPORTER les infos format RIS format BibTeX format XML th\u00e8se pr\u00e9c\u00e9dente th\u00e8se suivante Domaines num\u00e9riques abstraits faiblement relationnels par Antoine Min\u00e9 Th\u00e8se de doctorat en Informatique Sous la direction de Patrick Cousot. Soutenue en 2004 \u00e0 Palaiseau, Ecole polytechnique . Description en fran\u00e7ais Description en anglais mots cl\u00e9s mots cl\u00e9s Domaines num\u00e9riques abstraits Interpr\u00e9tation abstraite Domaines relationnels Logiciels -- V\u00e9rification Arithm\u00e9tique en virgule flottante Syst\u00e8mes embarqu\u00e9s (informatique) Pas de r\u00e9sum\u00e9 disponible. Titre traduit Weakly \u2026", "num_citations": "21\n", "authors": ["1744"]}
{"title": "Modular static analysis of string manipulations in C programs\n", "abstract": " We present a modular analysis able to tackle out-of-bounds accesses in C strings. This analyzer is modular in the sense that it infers and tabulates (for reuse) input/output relations, automatically partitioned according to the shape of the input state. We show how the inter-procedural iterator discovers and generalizes contracts in order to improve their reusability for further analysis. This analyzer was implemented and was able to successfully analyze and infer relational contracts for functions such as strcpy, strcat.", "num_citations": "18\n", "authors": ["1744"]}
{"title": "Precise thread-modular abstract interpretation of concurrent programs using relational interference abstractions\n", "abstract": " We present a static analysis by abstract interpretation of numeric properties in multi-threaded programs. The analysis is sound (assuming a sequentially consistent memory), parameterized by a choice of abstract domains and, in order to scale up, it is modular, in that it iterates over each thread individually (possibly several times) instead of iterating over their product. We build on previous work that formalized rely-guarantee verification methods as a concrete, fixpoint-based semantics, and then apply classic numeric abstractions to abstract independently thread states and thread interference. This results in a flexible algorithm allowing a wide range of precision versus cost trade-offs, and able to infer even flow-sensitive and relational thread interference. We implemented our method in an analyzer prototype for a simple language and experimented it on several classic mutual exclusion algorithms for two or\u00a0\u2026", "num_citations": "18\n", "authors": ["1744"]}
{"title": "Proving guarantee and recurrence temporal properties by abstract interpretation\n", "abstract": " We present new static analysis methods for proving liveness properties of programs. In particular, with reference to the hierarchy of temporal properties proposed by Manna and Pnueli, we focus on guarantee (i.e., \u201csomething good occurs at least once\u201d) and recurrence (i.e., \u201csomething good occurs infinitely often\u201d) temporal properties.             We generalize the abstract interpretation framework for termination presented by Cousot and Cousot. Specifically, static analyses of guarantee and recurrence temporal properties are systematically derived by abstraction of the program operational trace semantics.             These methods automatically infer sufficient preconditions for the temporal properties by reusing existing numerical abstract domains based on piecewise-defined ranking functions. We augment these abstract domains with new abstract operators, including a dual widening.             To illustrate the\u00a0\u2026", "num_citations": "18\n", "authors": ["1744"]}
{"title": "Backward under-approximations in numeric abstract domains to automatically infer sufficient program conditions\n", "abstract": " In this article, we discuss the automatic inference of sufficient preconditions by abstract interpretation and sketch the construction of an under-approximating backward analysis. We focus on numeric properties of variables and revisit three classic numeric abstract domains: intervals, octagons, and polyhedra, with new under-approximating backward transfer functions, including the support for non-deterministic expressions, as well as lower widenings to handle loops. We show that effective under-approximation is possible natively in these domains without necessarily resorting to disjunctive completion nor domain complementation. Applications include the derivation of sufficient conditions for a program to never step outside an envelope of safe states, or dually to force it to eventually fail. We built a proof-of-concept prototype implementation and tried it on simple examples. Our construction and our implementation are\u00a0\u2026", "num_citations": "14\n", "authors": ["1744"]}
{"title": "Combinations of Reusable Abstract Domains for a Multilingual Static Analyzer\u22c6\n", "abstract": " We discuss the design of Mopsa, an ongoing effort to design a novel semantic static analyzer by abstract interpretation. Mopsa strives to achieve a high degree of modularity and extensibility by considering value abstractions for numeric, pointer, objects, arrays, etc. as well as syntax-driven iterators and control-flow abstractions uniformly as domain modules, which offer a unified signature and loose coupling, so that they can be combined and reused at will. Moreover, domains can dynamically rewrite expressions, which simplifies the design of relational abstractions, encourages a design based on layered semantics, and enables domain reuse across different analyses and different languages. We present preliminary applications of Mopsa analyzing simple programs in subsets of the C and Python programming languages, checking them for run-time errors and uncaught exceptions.", "num_citations": "13\n", "authors": ["1744"]}
{"title": "Design of a modular platform for static analysis\n", "abstract": " We present the design and implementation of Mopsa, a platform that simplifies the construction of semantic static analyzers by abstract interpretation. Mopsa computes sound program invariants and reports run-time errors, undefined behaviors, and uncaught exceptions. Mopsa differs from existing platforms by its highly modular and extensible design: semantic abstractions of numeric values, pointers, objects, control, as well as syntax-driven iterators, are defined in small, reusable domains with loose coupling, that can be combined and reused to a greater extent than in previous work. Moreover, Mopsa aims at supporting several languages (currently, subsets of both C and Python) while sharing abstraction components as much as possible. Mopsa is a work in progress, and not yet capable of analyzing full programs; nevertheless, we report early experimental results on verification benchmarks.", "num_citations": "13\n", "authors": ["1744"]}
{"title": "Static analysis by abstract interpretation of sequential and multi-thread programs\n", "abstract": " In the realm of embedded critical systems, it is crucial to guarantee the correctness of programs before they are deployed. Static analyzers can help by detecting at compile-time potentially erroneous program behaviors: they perform sound over-approximations to achieve an efficient analysis while not missing any potential behavior. We discuss the systematic design of such analyzers using abstract interpretation, a general theory of semantic approximation. After recalling the classic construction of static analyzers for sequential programs by abstraction of the concrete trace semantics, we introduce abstractions to derive thread-modular analyzers for multithreaded programs, borrowing ideas from rely/guarantee proof methods. Finally, we present two static analyzer tools, Astr\u00e9e and Astr\u00e9eA, that are used to check for run-time errors in large sequential and multithreaded embedded industrial avionic C applications.", "num_citations": "12\n", "authors": ["1744"]}
{"title": "Static analysis by abstract interpretation of functional properties of device drivers in TinyOS\n", "abstract": " In this paper, we present a static analysis by Abstract Interpretation of device drivers developed in the TinyOS operating system, which is considered as the de facto system in wireless sensor networks. We focus on verifying user-defined functional properties describing safety rules that programs should obey in order to interact correctly with the hardware. Our analysis is sound by construction and can prove that all possible execution paths follow the correct interaction patterns specified by the functional property. The soundness of the analysis is justified with respect to a preemptive execution model where interrupts can occur during execution depending on the configuration of specific hardware registers. The proposed solution performs a modular analysis that analyzes every interrupt independently and aggregates their results to over-approximate the effect of preemption. By doing so, we avoid reanalyzing interrupts\u00a0\u2026", "num_citations": "11\n", "authors": ["1744"]}
{"title": "Static type analysis by abstract interpretation of Python programs\n", "abstract": " Python is an increasingly popular dynamic programming language, particularly used in the scientific community and well-known for its powerful and permissive high-level syntax. Our work aims at detecting statically and automatically type errors. As these type errors are exceptions that can be caught later on, we precisely track all exceptions (raised or caught). We designed a static analysis by abstract interpretation able to infer the possible types of variables, taking into account the full control-flow. It handles both typing paradigms used in Python, nominal and structural, supports Python\u2019s object model, introspection operators allowing dynamic type testing, dynamic attribute addition, as well as exception handling. We present a flow-and context-sensitive analysis with special domains to support containers (such as lists) and infer type equalities (allowing it to express parametric polymorphism). The analysis is soundly derived by abstract interpretation from a concrete semantics of Python developed by Fromherz et al. Our analysis is designed in a modular way as a set of domains abstracting a concrete collecting semantics. It has been implemented into the MOPSA analysis framework, and leverages external type annotations from the Typeshed project to support the vast standard library. We show that it scales to benchmarks a few thousand lines long, and preliminary results show it is able to analyze a small real-life command-line utility called PathPicker. Compared to previous work, it is sound, while it keeps similar efficiency and precision.", "num_citations": "9\n", "authors": ["1744"]}
{"title": "Relational thread-modular abstract interpretation under relaxed memory models\n", "abstract": " We address the verification problem of numeric properties in many-threaded concurrent programs under weakly consistent memory models, especially TSO. We build on previous work that proposed an abstract interpretation method to analyse these programs with relational domains. This method was not sufficient to analyse more than two threads in a decent time. Our contribution here is to rely on a rely-guarantee framework with automatic inference of thread interferences to design an analysis with a thread-modular approach and describe relational abstractions of both thread states and interferences. We show how to adapt the usual computing procedure of interferences to the additional issues raised by weakly consistent memories. We demonstrate the precision and the performance of our method on a few examples, operating a prototype analyser that verifies safety properties like mutual exclusion. We\u00a0\u2026", "num_citations": "9\n", "authors": ["1744"]}
{"title": "Static analysis of embedded real-time concurrent software with dynamic priorities\n", "abstract": " In previous work, we developed a sound static analysis by abstract interpretation to check the absence of run-time errors in concurrent programs, focusing on embedded C programs composed of a fixed set of threads in a shared memory. The method is thread-modular: it considers each thread independently, analyzing them with respect to an abstraction of the effect of the other threads, so-called interference, which are also inferred automatically as part of analyzing the threads. The analysis thus proceeds in a series of rounds that reanalyze all threads, gathering an increasing set of interference, until stabilization. We proved that this method is sound and covers all possible thread interleavings. This analysis was integrated into the Astr\u00e9e industrial-scale static analyzer, deployed in avionics and automotive industries.In this article, we consider the more specific case of programs running under a priority-based real\u00a0\u2026", "num_citations": "9\n", "authors": ["1744"]}
{"title": "Perlin textures in real time using OpenGL\n", "abstract": " Perlin's procedural solid textures provide for high quality rendering of surface appearance like surface aspect such as marble, wood or rock. This method does not suffer many of the flaws that are associated with classical image mapped textures methods, such as distortion, memory size, bad continuity through objects. Being based on a per-pixel calculation, they were however limited up to now to non-real-time quality rendering as is ray-tracing. In this paper, we propose a way to implement Perlin texture using a real-time graphics library like OpenGL.", "num_citations": "8\n", "authors": ["1744"]}
{"title": "From array domains to abstract interpretation under store-buffer-based memory models\n", "abstract": " We address the problem of verifying concurrent programs under store-buffer-based weakly consistent memory models, such as TSO or PSO. Using the abstract interpretation framework, we adapt existing domains for arrays to model store buffers and obtain a sound abstraction of program states (including the case of programs with infinite state space) parameterised by a numerical domain. Whereas the usual method for this kind of programs implements a program transformation to come back to an analysis under a sequentially consistent model, the novelty of our work consists in applying abstract interpretation directly on the source program, setting a clean foundation for special dedicated domains keeping information difficult to express with program transformations. We demonstrate the precision of this method on a few examples, targetting the TSO model and incidentally being also sound for PSO due to\u00a0\u2026", "num_citations": "7\n", "authors": ["1744"]}
{"title": "Inference of ranking functions for proving temporal properties by abstract interpretation\n", "abstract": " We present new static analysis methods for proving liveness properties of programs. In particular, with reference to the hierarchy of temporal properties proposed by Manna and Pnueli, we focus on guarantee (i.e., \u201csomething good occurs at least once\u201d) and recurrence (i.e., \u201csomething good occurs infinitely often\u201d) temporal properties.We generalize the abstract interpretation framework for termination presented by Cousot and Cousot. Specifically, static analyses of guarantee and recurrence temporal properties are systematically derived by abstraction of the program operational trace semantics.These methods automatically infer sufficient preconditions for the temporal properties by reusing existing numerical abstract domains based on piecewise-defined ranking functions. We augment these abstract domains with new abstract operators, including a dual widening.To illustrate the potential of the proposed methods\u00a0\u2026", "num_citations": "6\n", "authors": ["1744"]}
{"title": "Repr\u00e9sentation d\u2019ensembles de contraintes de somme ou de diff\u00e9rence de deux variables et applicationa l\u2019analyse automatique de programmes\n", "abstract": " Nous pr\u00e9sentons, dans ce rapport, une nouvelle m\u00e9thode d\u2019analyse statique de programmes. Cette analyse calcule de maniere automatique des invariants sur les variables num\u00e9riques d\u2019un programme,a l\u2019instar des m\u00e9thodes classiques d\u2019analyse d\u2019intervalles ou d\u2019in\u00e9galit\u00e9s lin\u00e9aires. Plus pr\u00e9cis\u00e9ment, les invariants que nous trouvons sont de la forme\u00b1x\u00b1y\u2264 c (que nous appellerons contrainte de somme ou de diff\u00e9rence de deux variables), oux et y sont des valeurs de variables et c est une constante num\u00e9rique. Nous utilisons des difference bound matrices pour repr\u00e9senter les ensembles de contraintes de somme ou de diff\u00e9rence de deux variables. Leur complexit\u00e9 en espace est, au pire, en O (n2), n \u00e9tant le nombre de variables dans le programme, et les algorithmes qui les manipulent ont une complexit\u00e9, au pire, en O (n3). La s\u00fbret\u00e9 de cette analyse est prouv\u00e9e dans le cadre formel de l\u2019interpr\u00e9tation abstraite en utilisant des correspondances de Galois entre treillis complets.Bien que les difference bound matrices soient tres utilis\u00e9es pour le model-checking d\u2019automates temporis\u00e9s, il nous a fallu introduire de nombreux op\u00e9rateurs (\u00e9largissement, affectation, garde,...) pour les rendre utilisables dans le cadre de l\u2019interpr\u00e9tation abstraite. De plus, comme les difference bound matrices n\u2019ont \u00e9t\u00e9 utilis\u00e9es, jusqu\u2019a pr\u00e9sent, que pour repr\u00e9senter les contraintes de la forme x\u2212 y\u2264 c, nous avons d\u00fb les \u00e9tendre pour pouvoir repr\u00e9senter les contraintes de sommes aussi bien que les contraintes de diff\u00e9rence de deux variables.", "num_citations": "6\n", "authors": ["1744"]}
{"title": "A Review of Formal Methods applied to Machine Learning\n", "abstract": " We review state-of-the-art formal methods applied to the emerging field of the verification of machine learning systems. Formal methods can provide rigorous correctness guarantees on hardware and software systems. Thanks to the availability of mature tools, their use is well established in the industry, and in particular to check safety-critical applications as they undergo a stringent certification process. As machine learning is becoming more popular, machine-learned components are now considered for inclusion in critical systems. This raises the question of their safety and their verification. Yet, established formal methods are limited to classic, i.e. non machine-learned software. Applying formal methods to verify systems that include machine learning has only been considered recently and poses novel challenges in soundness, precision, and scalability. We first recall established formal methods and their current use in an exemplar safety-critical field, avionic software, with a focus on abstract interpretation based techniques as they provide a high level of scalability. This provides a golden standard and sets high expectations for machine learning verification. We then provide a comprehensive and detailed review of the formal methods developed so far for machine learning, highlighting their strengths and limitations. The large majority of them verify trained neural networks and employ either SMT, optimization, or abstract interpretation techniques. We also discuss methods for support vector machines and decision tree ensembles, as well as methods targeting training and data preparation, which are critical but often neglected aspects of machine\u00a0\u2026", "num_citations": "4\n", "authors": ["1744"]}
{"title": "A library modeling language for the static analysis of C programs\n", "abstract": " We present a specification language aiming at soundly modeling unavailable functions in a static analyzer for C by abstract interpretation. It takes inspiration from Behavioral Interface Specification Languages popular in deductive verification, notably Frama-C\u2019s ACSL, as we annotate function prototypes with pre and post-conditions expressed concisely in a first-order logic, but with key differences. Firstly, the specification aims at replacing a function implementation in a safety analysis, not verifying its functional correctness. Secondly, we do not rely on theorem provers; instead, specifications are interpreted at function calls by our abstract interpreter.                 We implemented the language into Mopsa, a static analyzer designed to easily reuse abstract domains across widely different languages (such as C and Python). We show how its design helped us support a logic-based language with minimal effort\u00a0\u2026", "num_citations": "4\n", "authors": ["1744"]}
{"title": "Value and allocation sensitivity in static Python analyses\n", "abstract": " Sound static analyses for large subsets of static programming languages such as C are now widespread. For example the Astr\u00e9e static analyzer soundly overapproximates the behavior of C programs that do not contain any dynamic code loading, longjmp statements nor recursive functions. The sound and precise analysis of widely used dynamic programming languages like JavaScript and Python remains a challenge. This paper examines the variation of static analyses of Python\u2013in precision, time and memory usage\u2013by adapting three parameters: the value sensitivity, the allocation sensitivity and the activation of an abstract garbage collector. It is not clear yet which level of sensitivity constitutes a sweet spot in terms of precision versus efficiency to achieve a meaningful Python analysis. We thus perform an experimental evaluation using a prototype static analyzer on benchmarks a few thousand lines long. Key\u00a0\u2026", "num_citations": "4\n", "authors": ["1744"]}
{"title": "Analysis of Software Patches Using Numerical Abstract Interpretation\n", "abstract": " We present a static analysis for software patches. Given two syntactically close versions of a program, our analysis can infer a semantic difference, and prove that both programs compute the same outputs when run on the same inputs. Our method is based on abstract interpretation, and parametric in the choice of an abstract domain. We focus on numeric properties only. Our method is able to deal with unbounded executions of infinite-state programs, reading from infinite input streams. Yet, it is limited to comparing terminating executions, ignoring non terminating ones.                 We first present a novel concrete collecting semantics, expressing the behaviors of both programs at the same time. Then, we propose an abstraction of infinite input streams able to prove that programs that read from the same stream compute equal output values. We then show how to leverage classic numeric abstract domains\u00a0\u2026", "num_citations": "3\n", "authors": ["1744"]}
{"title": "An abstract domain for trees with numeric relations\n", "abstract": " We present an abstract domain able to infer invariants on programs manipulating trees. Trees considered in the article are defined over a finite alphabet and can contain unbounded numeric values at their leaves. Our domain can infer the possible shapes of the tree values of each variable and find numeric relations between: the values at the leaves as well as the size and depth of the tree values of different variables. The abstract domain is described as a product of (1) a symbolic domain based on a tree automata representation and (2) a numerical domain lifted, for the occasion, to describe numerical maps with potentially infinite and heterogeneous definition set. In addition to abstract set operations and widening we define concrete and abstract transformers on these environments. We present possible applications, such as the ability to describe memory zones, or track symbolic equalities between\u00a0\u2026", "num_citations": "3\n", "authors": ["1744"]}
{"title": "Analysis of program differences with numerical abstract interpretation\n", "abstract": " We present work in progress on the static analysis of software patches. Given two syntactically close versions of a program, our analysis can infer a semantic difference, and prove that both programs compute the same outputs when run on the same inputs. Our method is based on abstract interpretation, and parametric in the choice of an abstract domain. At the moment, we focus on numeric properties only, on a toy language. Our method is able to deal with infinite-state programs and unbounded executions, but it is limited to comparing terminating executions, ignoring non terminating ones.  We first present a novel concrete collecting semantics, expressing the behaviors of both programs at the same time. We then show how to leverage classic numeric abstract domains, such as polyhedra or octagons, to build an effective static analysis. We also introduce a novel numeric domain to bound differences between the values of the variables in the two programs, which has linear cost, and the right amount of relationality to express useful properties of software patches. We implemented a prototype and experimented on a few small examples from the literature.  In future work, we will consider extensions to non purely numeric programs, towards the analysis of realistic patches.", "num_citations": "2\n", "authors": ["1744"]}
{"title": "Inferring functional properties of matrix manipulating programs by abstract interpretation\n", "abstract": " We present a new static analysis by abstract interpretation to prove automatically the functional correctness of algorithms implementing matrix operations, such as matrix addition, multiplication, general matrix multiplication, inversion, or more generally Basic Linear Algebra Subprograms. In order to do so, we introduce a family of abstract domains parameterized by a set of matrix predicates as well as a numerical domain. We show that our analysis is robust enough to prove the functional correctness of several versions of the same matrix operations, resulting from loop reordering, loop tiling, inverting the iteration order, line swapping, and expression decomposition. We extend our method to enable modular analysis on code fragments manipulating matrices by reference, and show that it results in a significant analysis speedup.", "num_citations": "2\n", "authors": ["1744"]}
{"title": "To Infinity... and Beyond!\n", "abstract": " The traditional method for proving program termination consists in inferring a ranking function. In many cases (i.e. programs with unbounded non-determinism), a single ranking function over natural numbers is not sufficient. Hence, we propose a new abstract domain to automatically infer ranking functions over ordinals. We extend an existing domain for piecewise-defined natural-valued ranking functions to polynomials in \u03c9, where the polynomial coefficients are natural-valued functions of the program variables. The abstract domain is parametric in the choice of the state partitioning inducing the piecewise-definition and the type of functions used as polynomial coefficients. To our knowledge this is the first abstract domain able to reason about ordinals. Handling ordinals leads to a powerful approach for proving termination of imperative programs, which in particular allows us to take a first step in the direction of proving termination under fairness constraints and proving liveness properties of (sequential and) concurrent programs.", "num_citations": "2\n", "authors": ["1744"]}
{"title": "Static Analysis: 19th International Symposium, SAS 2012, Deauville, France, September 11-13, 2012. Proceedings\n", "abstract": " This book constitutes the thoroughly refereed proceedings of the 19th International Symposium on Static Analysis, SAS 2012, held in Deauville, France, in September 2012. The 25 revised full papers presented together with 4 invited talks were selected from 62 submissions. The papers address all aspects of static analysis, including abstract domains, abstract interpretation, abstract testing, bug detection, data flow analysis, model checking, new applications, program transformation, program verification, security analysis, theoretical frameworks, and type checking.", "num_citations": "2\n", "authors": ["1744"]}
{"title": "Static Analysis of Endian Portability by Abstract Interpretation\n", "abstract": " We present a static analysis of endian portability for C programs. Our analysis can infer that a given program, or two syntactically close versions thereof, compute the same outputs when run with the same inputs on platforms with different byte-orders, a.k.a. endiannesses. We target low-level C programs that abuse C pointers and unions, hence rely on implementation-specific behaviors undefined in the C standard.               Our method is based on abstract interpretation, and parametric in the choice of a numerical abstract domain. We first present a novel concrete collecting semantics, relating the behaviors of two versions of a program, running on platforms with different endiannesses. We propose a joint memory abstraction, able to infer equivalence relations between little- and big-endian memories. We introduce a novel symbolic predicate domain to infer relations between individual bytes of the variables in\u00a0\u2026", "num_citations": "1\n", "authors": ["1744"]}
{"title": "A Multilanguage Static Analysis of Python Programs with Native C Extensions\n", "abstract": " Modern programs are increasingly multilanguage, to benefit from each programming language\u2019s advantages and to reuse libraries. For example, developers may want to combine high-level Python code with low-level, performance-oriented C code. In fact, one in five of the 200 most downloaded Python libraries available on GitHub contains C code. Static analyzers tend to focus on a single language and may use stubs to model the behavior of foreign function calls. However, stubs are costly to implement and undermine the soundness of analyzers. In this work, we design a static analyzer by abstract interpretation that can handle Python programs calling C extensions. It analyses directly and fully automatically both the Python and the C source codes. It reports runtime errors that may happen in Python, in C, and at the interface. We implemented our analysis in a modular fashion: it reuses off-the-shelf C and\u00a0\u2026", "num_citations": "1\n", "authors": ["1744"]}
{"title": "Static Type Analysis by Abstract Interpretation of Python Programs (Artifact)\n", "abstract": " Python is an increasingly popular dynamic programming language, particularly used in the scientific community and well-known for its powerful and permissive high-level syntax. Our work aims at detecting statically and automatically type errors. As these type errors are exceptions that can be caught later on, we precisely track all exceptions (raised or caught). We designed a static analysis by abstract interpretation able to infer the possible types of variables, taking into account the full control-flow. It handles both typing paradigms used in Python, nominal and structural, supports Python\u2019s object model, introspection operators allowing dynamic type testing, dynamic attribute addition, as well as exception handling. We present a flow-and context-sensitive analysis with special domains to support containers (such as lists) and infer type equalities (allowing it to express parametric polymorphism). The analysis is soundly derived by abstract interpretation from a concrete semantics of Python developed by Fromherz et al. Our analysis is designed in a modular way as a set of domains abstracting a concrete collecting semantics. It has been implemented into the MOPSA analysis framework, and leverages external type annotations from the Typeshed project to support the vast standard library. We show that it scales to benchmarks a few thousand lines long, and preliminary results show it is able to analyze a small real-life command-line utility called PathPicker. Compared to previous work, it is sound, while it keeps similar efficiency and precision.", "num_citations": "1\n", "authors": ["1744"]}
{"title": "Combination of Boxes and Polyhedra Abstractions for Constraint Solving\n", "abstract": " This paper investigates the use of abstract domains from Abstract Interpretation (AI) in the field of Constraint Programming (CP). CP solvers are generally very efficient on a specific constraint language, but can hardly be extended to tackle more general languages, both in terms of variable representation (discrete or continuous) and constraint type (global, arithmetic, etc.). For instance, linear constraints are usually solved with linear programming techniques, but non-linear ones have to be either linearized, reformulated or sent to an external solver. We approach this problem by adapting to CP a popular domain construction used to combine the power of several analyses in AI: the reduced product. We apply this product on two well-known abstract domains, Boxes and Polyhedra, that we lift to constraint solving. Finally we define general metrics for the quality of the solver results, and present a benchmark accordingly\u00a0\u2026", "num_citations": "1\n", "authors": ["1744"]}
{"title": "Quantitative static analysis of communication protocols using abstract Markov chains\n", "abstract": " In this paper we present a static analysis of probabilistic programs to quantify their performance properties by taking into account both the stochastic aspects of the language and those related to the execution environment. More particularly, we are interested in the analysis of communication protocols in lossy networks and we aim at inferring statically parametric bounds of some important metrics such as the expectation of the throughput or the energy consumption. Our analysis is formalized within the theory of abstract interpretation and soundly takes all possible executions into account. We model the concrete executions as a set of Markov chains and we introduce a novel notion of abstract Markov chains that provides a finite and symbolic representation to over-approximate the (possibly unbounded) set of concrete behaviors. We show that our proposed formalism is expressive enough to handle both\u00a0\u2026", "num_citations": "1\n", "authors": ["1744"]}
{"title": "Static analysis by abstract interpretation of the functional correctness of matrix manipulating programs\n", "abstract": " We present new abstract domains to prove automatically the functional correctness of algorithms implementing matrix operations, such as matrix addition, multiplication, GEMM (general matrix multiplication), or more generally BLAS (Basic Linear Algebra Subprograms). In order to do so, we introduce a family of abstract domains parameterized by a set of matrix predicates and by a numeric domain. We show that our analysis is robust enough to prove the functional correctness of several versions of matrix addition and multiplication codes resulting from loop reordering, loop tiling, inverting the iteration order, line swapping, and expression decomposition. Finally, we extend our method to enable modular analysis on code fragments manipulating matrices by reference, and show that it results in a significant analysis speedup.", "num_citations": "1\n", "authors": ["1744"]}
{"title": "Proceedings of the 19th International Static Analysis Symposium (SAS 2012)\n", "abstract": " Ecole Normale Sup\u00e9rieure - Proceedings of the 19th International Static Analysis Symposium (SAS 2012) Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support Ecole normale sup\u00e9rieure de Paris HAL - hal.archives-ouvertes.fr Accueil D\u00e9p\u00f4t Consultation Par type de publication Par ann\u00e9e de publication Par domaine Par laboratoire Recherche En savoir plus sur l'Acc\u00e8s Ouvert et le d\u00e9p\u00f4t dans HAL Le d\u00e9p\u00f4t dans HAL en trois \u00e9tapes Ai-je le droit de d\u00e9poser en archives ouvertes ? Les \u00e9diteurs pr\u00e9dateurs Trouver des ressources en Acc\u00e8s Ouvert Les r\u00e9seaux sociaux acad\u00e9miques hal-00748287, version 1 Direction d'ouvrage, Proceedings, Dossier Proceedings of the 19th International Static Analysis \u2026", "num_citations": "1\n", "authors": ["1744"]}
{"title": "A Few Graph-Based Relational Numerical Abstract Domains\n", "abstract": " This article presents the systematic design of a class of relational numerical abstract domains from non-relational ones. Constructed domains represent sets of invariants of the form (vj - vi in C), where vj and vi are two variables, and C lives in an abstraction of P(Z), P(Q), or P(R). We will call this family of domains weakly relational domains. The underlying concept allowing this construction is an extension of potential graphs and shortest-path closure algorithms in exotic-like algebras. Example constructions are given in order to retrieve well-known domains as well as new ones. Such domains can then be used in the Abstract Interpretation framework in order to design various static analyses. Amajor benfit of this construction is its modularity, allowing to quickly implement new abstract domains from existing ones.", "num_citations": "1\n", "authors": ["1744"]}