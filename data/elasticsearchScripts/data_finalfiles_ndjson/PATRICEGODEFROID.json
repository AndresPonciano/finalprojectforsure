{"title": "Automated whitebox fuzz testing.\n", "abstract": " Automated Whitebox Fuzz Testing Page 1 Monday, December 9, 2019 Thomas Schuster, Automated Whitebox Fuzz Testing Automated Whitebox Fuzz Testing Patrice Godefroid, Michael Y. Levin and David Molnar Page 2 Monday, December 9, 2019 Thomas Schuster, Automated Whitebox Fuzz Testing 2 Paper \u25cf January 2012 \u25cf Microsoft \u2013 Patrice Godefroid \u2013 Michael Y. Levin \u2013 David Molnar \u25cf 69 citations Page 3 Monday, December 9, 2019 Thomas Schuster, Automated Whitebox Fuzz Testing 3 Overview \u25cf Background \u25cf Whitebox Fuzzing Algorithm \u25cf SAGE \u25cf Results \u25cf Taxonomy Page 4 Monday, December 9, 2019 Thomas Schuster, Automated Whitebox Fuzz Testing 4 Symbolic execution \u25cf For a part of a program \u2013 Find input that reaches this part \u25cf Interpret Programs \u2013 Use symbolic values instead of real input \u2013 Conditional jumps are constrained by the symbolic values \u2013 Solve using a SAT solver 5 , 9, \u2026", "num_citations": "1494\n", "authors": ["256"]}
{"title": "Partial-order methods for the verification of concurrent systems: an approach to the state-explosion problem\n", "abstract": " State-space exploration techniques are increasingly being used for debugging and proving correct nite-state concurrent reactive systems. The reason for this success is mainly the simplicity of these techniques. Indeed, they are easy to understand, easy to implement and, last but not least, easy to use: they are fully automatic. Moreover, the range of properties that they can verify has been substantially broadened thanks to the development of model-checking methods for various temporal logics.The main limit of state-space exploration veri cation techniques is the often excessive size of the state space due, among other causes, to the modeling of concurrency by interleaving. However, exploring all interleavings of concurrent events is not a priori necessary for veri cation: interleavings corresponding to the same concurrent execution contain related information. One can thus hope to be able to verify properties of a concurrent system without exploring all interleavings of its concurrent executions. This thesis presents a collection of methods, called partial-order methods, that make this possible.", "num_citations": "1449\n", "authors": ["256"]}
{"title": "Model checking for programming languages using VeriSoft\n", "abstract": " Verification by state-space exploration, also often referred to as\" model checking\", is an effective method for analyzing the correctness of concurrent reactive systems (eg, communication protocols). Unfortunately, existing model-checking techniques are restricted to the verification of properties of models, ie, abstractions, of concurrent systems. In this paper, we discuss how model checking can be extended to deal directly with\" actual\" descriptions of concurrent systems, eg, implementations of communication protocols written in programming languages such as C or C++. We then introduce a new search technique that is suitable for exploring the state spaces of such systems. This algorithm has been implemented in VeriSoft, a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary C code. As an example of application, we describe how VeriSoft\u00a0\u2026", "num_citations": "1000\n", "authors": ["256"]}
{"title": "Dynamic partial-order reduction for model checking software\n", "abstract": " We present a new approach to partial-order reduction for model checking software. This approach is based on initially exploring an arbitrary interleaving of the various concurrent processes/threads, and dynamically tracking interactions between these to identify backtracking points where alternative paths in the state space need to be explored. We present examples of multi-threaded programs where our new dynamic partial-order reduction technique significantly reduces the search space, even though traditional partial-order algorithms are helpless.", "num_citations": "797\n", "authors": ["256"]}
{"title": "Compositional dynamic test generation\n", "abstract": " Dynamic test generation is a form of dynamic program analysis that attempts to compute test inputs to drive a program along a specific program path. Directed Automated Random Testing, or DART for short, blends dynamic test generation with model checking techniques with the goal of systematically executing all feasible program paths of a program while detecting various types of errors using run-time checking tools (like Purify, for instance). Unfortunately, systematically executing all feasible program paths does not scale to large, realistic programs. This paper addresses this major limitation and proposes to perform dynamic test generation compositionally, by adapting known techniques for interprocedural static analysis. Specifically, we introduce a new algorithm, dubbed SMART for Systematic Modular Automated Random Testing, that extends DART by testing functions in isolation, encoding test results as\u00a0\u2026", "num_citations": "635\n", "authors": ["256"]}
{"title": "SAGE: whitebox fuzzing for security testing\n", "abstract": " SAGE has had a remarkable impact at Microsoft.", "num_citations": "634\n", "authors": ["256"]}
{"title": "Grammar-based whitebox fuzzing\n", "abstract": " Whitebox fuzzing is a form of automatic dynamic test generation, based on symbolic execution and constraint solving, designed for security testing of large applications. Unfortunately, the current effectiveness of whitebox fuzzing is limited when testing applications with highly-structured inputs, such as compilers and interpreters. These applications process their inputs in stages, such as lexing, parsing and evaluation. Due to the enormous number of control paths in early processing stages, whitebox fuzzing rarely reaches parts of the application beyond those first stages.", "num_citations": "549\n", "authors": ["256"]}
{"title": "Using partial orders to improve automatic verification methods\n", "abstract": " In this paper, we present a verification method for concurrent finite-state systems that attempts to avoid the part of the combinatorial explosion due to the modeling of concurrency by interleavings. The behavior of a system is described in terms of partial orders (more precisely in terms of Mazurkiewicz's traces) rather than in terms of interleavings. We introduce the notion of \u201ctrace automation\u201d which generates only one linearization per partial order. Then we show how to use trace automata to prove program correctness.", "num_citations": "505\n", "authors": ["256"]}
{"title": "Symbolic verification of communication protocols with infinite state spaces using QDDs\n", "abstract": " We study the verification of properties of communication protocols modeled by a finite set of finite-state machines that communicate by exchanging messages via unbounded FIFO queues. It is well-known that most interesting verification problems, such as deadlock detection, are undecidable for this class of systems. However, in practice, these verification problems may very well turn out to be decidable for a subclass containing most \u201creal\u201d protocols.               Motivated by this optimistic (and, we claim, realistic) observation, we present an algorithm that may construct a finite and exact representation of the state space of a communication protocol, even if this state space is infinite. Our algorithm performs a loop-first search in the state space of the protocol being analyzed. A loop-first search is a search technique that attempts to explore first the results of successive executions of loops in the protocol description\u00a0\u2026", "num_citations": "244\n", "authors": ["256"]}
{"title": "Active property checking\n", "abstract": " An exemplary method includes providing software for testing; during execution of the software, performing a symbolic execution of the software to produce path constraints; injecting issue constraints into the software where each issue constraint comprises a coded formula; solving the constraints using a constraint solver; based at least in part on the solving, generating input for testing the software; and testing the software using the generated input to check for violations of the injected issue constraints. Such a method can actively check properties of the software. Checking can be performed on a path for a given input using a constraint solver where, if the check fails for the given input, the constraint solver can also generate an alternative input for further testing of the software. Various exemplary methods, devices, systems, etc., are disclosed.", "num_citations": "243\n", "authors": ["256"]}
{"title": "Presence awareness in collaborative systems\n", "abstract": " Presence awareness initiatives are implemented in a collaborative system that enables a user to set presence awareness policies, and that provides a reasonably high assurance that the system will correctly implement those policies. Specifically, the collaborative presence awareness system is such as to enable users to specify complex presence awareness policies. The presence awareness system is also such as to have been verified by employing systematic state-space exploration tools to establish a high level of assurance that the presence awareness system has the capability to implement correctly, substantially all possible presence awareness policies. Further, in accordance with another aspect of the invention, the presence awareness policy specifications are modular relative to the rest of the presence awareness system, and can be modified without having to modify computational modules or user\u00a0\u2026", "num_citations": "230\n", "authors": ["256"]}
{"title": "Abstraction-based model checking using modal transition systems\n", "abstract": " We present a framework for automatic program abstraction that can be used for model checking any formula of the modal mu-calculus. Unlike traditional conservative abstractions which can only prove universal properties, our framework can both prove and disprove any formula including arbitrarily nested path quantifiers. We discuss algorithms for automatically generating an abstract Modal Transition System (MTS) by adapting existing predicate and cartesian abstraction techniques. We show that model checking arbitrary formulas using abstract MTSs can be done at the same computational cost as model checking universal formulas using conservative abstractions.", "num_citations": "215\n", "authors": ["256"]}
{"title": "Refining dependencies improves partial-order verification methods\n", "abstract": " Partial-order verification methods exploit \u201cindependency\u201d between transitions of a concurrent program to avoid parts of the state space explosion due to the modeling of concurrency by interleaving. In this paper, we study the influence of refining dependencies between transitions of the program on the effectiveness of these methods. We show that carefully tracking dependencies can yield substantial improvements for their performances. For instance, we were able to decrease the memory requirements needed for the verification of a real-size protocol with such a method from a factor of 5 to a factor of 25 by only refining dependencies.", "num_citations": "215\n", "authors": ["256"]}
{"title": "Software model checking: The VeriSoft approach\n", "abstract": " Verification by state-space exploration, also often referred to as model checking, is an effective method for analyzing the correctness of concurrent reactive systems (for instance, communication protocols). Unfortunately, traditional model checking is restricted to the verification of properties of models, i.e., abstractions, of concurrent systems.               We discuss in this paper how model checking can be extended to analyze arbitrary software, such as implementations of communication protocols written in programming languages like C or C++. We then introduce a search technique that is suitable for exploring the state spaces of such systems. This algorithm has been implemented in VeriSoft, a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary code.               During the past five years, VeriSoft has been applied successfully for analyzing\u00a0\u2026", "num_citations": "207\n", "authors": ["256"]}
{"title": "Billions and billions of constraints: Whitebox fuzz testing in production\n", "abstract": " We report experiences with constraint-based whitebox fuzz testing in production across hundreds of large Windows applications and over 500 machine years of computation from 2007 to 2013. Whitebox fuzzing leverages symbolic execution on binary traces and constraint solving to construct new inputs to a program. These inputs execute previously uncovered paths or trigger security vulnerabilities. Whitebox fuzzing has found one-third of all file fuzzing bugs during the development of Windows 7, saving millions of dollars in potential security vulnerabilities. The technique is in use today across multiple products at Microsoft. We describe key challenges with running whitebox fuzzing in production. We give principles for addressing these challenges and describe two new systems built from these principles: SAGAN, which collects data from every fuzzing run for further analysis, and JobCenter, which controls\u00a0\u2026", "num_citations": "192\n", "authors": ["256"]}
{"title": "Checking beliefs in dynamic networks\n", "abstract": " Network Verification is a form of model checking in which a model of the network is checked for properties stated using a specification language. Existing network verification tools lack a general specification language and hardcode the network model. Hence they cannot, for example, model policies at a high level of abstraction. Neither can they model dynamic networks; even a simple packet format change requires changes to internals. Standard verification tools (eg, model checkers) have expressive specification and modeling languages but do not scale to large header spaces. We introduce Network Optimized Datalog (NoD) as a tool for network verification in which both the specification language and modeling languages are Datalog. NoD can also scale to large to large header spaces because of a new filter-project operator and a symbolic header representation.", "num_citations": "175\n", "authors": ["256"]}
{"title": "Automatic partial loop summarization in dynamic test generation\n", "abstract": " Whitebox fuzzing extends dynamic test generation based on symbolic execution and constraint solving from unit testing to whole-application security testing. Unfortunately, input-dependent loops may cause an explosion in the number of constraints to be solved and in the number of execution paths to be explored. In practice, whitebox fuzzers arbitrarily bound the number of constraints and paths due to input-dependent loops, at the risk of missing code and bugs.", "num_citations": "138\n", "authors": ["256"]}
{"title": "SAGE: Whitebox Fuzzing for Security Testing: SAGE has had a remarkable impact at Microsoft.\n", "abstract": " Most ACM Queue readers might think of \"program verification research\" as mostly theoretical with little impact on the world at large. Think again. If you are reading these lines on a PC running some form of Windows (like 93-plus percent of PC users--that is, more than a billion people), then you have been affected by this line of work--without knowing it, which is precisely the way we want it to be.", "num_citations": "117\n", "authors": ["256"]}
{"title": "Using partial-order methods in the formal validation of industrial concurrent programs\n", "abstract": " Formal validation is a powerful technique for automatically checking that a collection of communicating processes is free from concurrency-related errors. Although validation tools invariably find subtle errors that were missed during thorough simulation and testing, the brute-force search they perform can result in excessive memory usage and extremely long running times. Recently, a number of researchers have been investigating techniques known as partial-order methods that can significantly reduce the computational resources needed for formal validation by avoiding redundant exploration of execution scenarios. This paper investigates the behavior of partial-order methods in an industrial setting. We describe the design of a partial-order algorithm or a formal validation tool that has been used on several projects that are developing software for the Lucent Technologies 5ESS/sup (R/) telephone switching\u00a0\u2026", "num_citations": "117\n", "authors": ["256"]}
{"title": "On the expressiveness of 3-valued models\n", "abstract": " Three-valued models and logics have been recently advocated as being more suitable to reason about automatically-generated abstractions of reactive systems than traditional \u201c2-valued\u201d models such as standard Kripke structures or Labeled Transition Systems. Indeed, abstractions specified in 3-valued models are able to distinguish properties that are true, false and unknown of the concrete system, and hence their analysis can yield correctness proofs and counter-examples that can be both guaranteed to be sound. In this paper, we study several 3-valued modeling formalisms proposed in the literature and show that they have the same expressiveness, in the sense that any model specified in any of these formalisms can be translated into a model specified in any other. We also show that the complexity of the model checking and generalized model checking problems does not change from one\u00a0\u2026", "num_citations": "105\n", "authors": ["256"]}
{"title": "Random testing for security: blackbox vs. whitebox fuzzing\n", "abstract": " Fuzz testing is an effective technique for finding security vulnerabilities in software. Fuzz testing is a form of blackbox random testing which randomly mutates well-formed inputs and tests the program on the resulting data. In some cases, grammars are used to randomly generate the well-formed inputs. This also allows the tester to encode application-specific knowledge (such as corner cases of particular interest) as part of the grammar, and to specify test heuristics by assigning probabilistic weights to production rules. Although fuzz testing can be remarkably effective, the limitations of blackbox random testing are well-known. For instance, the then branch of the conditional statement\" if (x== 10) then\" has only one in 2 32 chances of being exercised if x is a randomly chosen 32-bit input value. This intuitively explains why random testing usually provides low code coverage.", "num_citations": "100\n", "authors": ["256"]}
{"title": "VeriSoft: A tool for the automatic analysis of concurrent reactive software\n", "abstract": " VeriSoft is a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary code written in full-fledged programming languages such as C or C++. It can automatically detect coordination problems between concurrent processes. Specifically, VeriSoft searches the state space of the system for deadlocks, livelocks, divergences, and violations of user-specified assertions. An interactive graphical simulator/debugger is also available for following the execution of all the processes of the concurrent system.", "num_citations": "97\n", "authors": ["256"]}
{"title": "Automatic abstraction using generalized model checking\n", "abstract": " Generalized model checking is a framework for reasoning about partial state spaces of concurrent reactive systems. The state space of a system is only \u201cpartial\u201d (partially known) when a full state-space exploration is not computationally tractable, or when abstraction techniques are used to simplify the system\u2019s representation. In the context of automatic abstraction, generalized model checking means checking whether there exists a concretization of an abstraction that satisfies a temporal logic formula. In this paper, we show how generalized model checking can extend existing automatic abstraction techniques (such as predicate abstraction) for model checking concurrent/reactive programs and yield the three following improvements: (1) any temporal logic formula can be checked (not just universal properties as with traditional conservative abstractions), (2) correctness proofs and counter-examples are\u00a0\u2026", "num_citations": "92\n", "authors": ["256"]}
{"title": "Active property checking\n", "abstract": " Runtime property checking (as implemented in tools like Purify or Valgrind) checks whether a program execution satisfies a property. Active property checking extends runtime checking by checking whether the property is satisfied by all program executions that follow the same program path. This check is performed on a symbolic execution of the given program path using a constraint solver. If the check fails, the constraint solver generates an alternative program input triggering a new program execution that follows the same program path but exhibits a property violation. Combined with systematic dynamic test generation, which attempts to exercise all feasible paths in a program, active property checking defines a new form of dynamic software model checking (program verification). In this paper, we formalize and study active property checking. We show how static and dynamic type checking can be extended with\u00a0\u2026", "num_citations": "89\n", "authors": ["256"]}
{"title": "Precise pointer reasoning for dynamic test generation\n", "abstract": " Dynamic test generation consists of executing a program while gathering symbolic constraints on inputs from predicates encountered in branch statements, and of using a constraint solver to infer new program inputs from previous constraints in order to steer next executions towards new program paths. Variants of this technique have recently been adopted in several bug detection tools, including our whitebox fuzzer SAGE, which has found dozens of new expensive security-related bugs in many Windows applications and is now routinely used in various Microsoft groups.", "num_citations": "81\n", "authors": ["256"]}
{"title": "Three-valued abstractions of games: Uncertainty, but with precision\n", "abstract": " We present a framework for abstracting two-player turn-based games that preserves any formula of the alternating /spl mu/-calculus (AMC). Unlike traditional conservative abstractions which can only prove the existence of winning strategies for only one of the players, our framework is based on 3-valued games, and it can be used to prove and disprove formulas of AMC including arbitrarily nested strategy quantifiers. Our main contributions are as follows. We define abstract 3-valued games and an alternating refinement relation on these that preserves winning strategies for both players. We provide a logical characterization of the alternating refinement relation. We show that our abstractions are as precise as can be via completeness results. We present AMC formulas that solve 3-valued games with /spl omega/-regular objectives, and we show that such games are determined in a 3-valued sense. We also discuss\u00a0\u2026", "num_citations": "79\n", "authors": ["256"]}
{"title": "Automated synthesis of symbolic instruction encodings from I/O samples\n", "abstract": " Symbolic execution is a key component of precise binary program analysis tools. We discuss how to automatically boot-strap the construction of a symbolic execution engine for a processor instruction set such as x86, x64 or ARM. We show how to automatically synthesize symbolic representations of individual processor instructions from input/output examples and express them as bit-vector constraints. We present and compare various synthesis algorithms and instruction sampling strategies. We introduce a new synthesis algorithm based on smart sampling which we show is one to two orders of magnitude faster than previous synthesis algorithms in our context. With this new algorithm, we can automatically synthesize bit-vector circuits for over 500 x86 instructions (8/16/32-bits, outputs, EFLAGS) using only 6 synthesis templates and in less than two hours using the Z3 SMT solver on a regular machine. During this\u00a0\u2026", "num_citations": "76\n", "authors": ["256"]}
{"title": "Automatically closing open reactive programs\n", "abstract": " We study in this paper the problem of analyzing implementations of open systems --- systems in which only some of the components are present. We present an algorithm for automatically closing an open concurrent reactive system with its most general environment, i.e., the environment that can provide any input at any time to the system. The result is a nondeterministic closed (i.e., self-executable) system which can exhibit all the possible reactive behaviors of the original open system. These behaviors can then be analyzed using VeriSoft, an existing tool for systematically exploring the state spaces of closed systems composed of multiple (possibly nondeterministic) processes executing arbitrary code. We have implemented the techniques introduced in this paper in a prototype tool for automatically closing open programs written in the C programming language. We discuss preliminary experimental results\u00a0\u2026", "num_citations": "75\n", "authors": ["256"]}
{"title": "Higher-order test generation\n", "abstract": " Symbolic reasoning about large programs is bound to be imprecise. How to deal with this imprecision is a fundamental problem in program analysis. Imprecision forces approximation. Traditional static program verification builds\" may\" over-approximations of the program behaviors to check universal\" for-all-paths\" properties, while automatic test generation requires\" must\" under-approximations to check existential\" for-some-path\" properties.", "num_citations": "64\n", "authors": ["256"]}
{"title": "Symbolic protocol verification with queue BDDs\n", "abstract": " Symbolic verification based on Binary Decision Diagrams (BDDs) has proven to be a powerful technique for ensuring the correctness of digital hardware. In contrast, BDDs have not caught on as widely for software verification, partly because the data types used in software are more complicated than those used in hardware. In this work, we propose an extension of BDDs for dealing with dynamic data structures. Specifically, we focus on queues, since they are commonly used in modeling communication protocols. We introduce Queue BDDs (QBDDs), which include all the power of BDDs while also providing an efficient representation of queue contents. Experimental results show that QBDDs are well-suited for the verification of communication protocols.", "num_citations": "63\n", "authors": ["256"]}
{"title": "An E cient Reactive Planner for Synthesizing Reactive Plans\n", "abstract": " We present a nonlinear forward-search method suitable for planning the reactions of an agent operating in a highly unpredictable environment. We show that this method is more e cient than existing linear methods. We then introduce the notion of safety and liveness rules. This makes possible a sharper exploitation of the information retrieved when exploring the future of the agent.", "num_citations": "62\n", "authors": ["256"]}
{"title": "Micro execution\n", "abstract": " Micro execution is the ability to execute any code fragment without a user-provided test driver or input data. The user simply identifies a function or code location in an exe or dll. A runtime Virtual Machine (VM) customized for testing purposes then starts executing the code at that location, catches all memory operations before they occur, allocates memory on-the-fly in order to perform those read/write memory operations, and provides input values according to a customizable memory policy, which defines what read memory accesses should be treated as inputs.", "num_citations": "59\n", "authors": ["256"]}
{"title": "Root causing flaky tests in a large-scale industrial setting\n", "abstract": " In today\u2019s agile world, developers often rely on continuous integration pipelines to help build and validate their changes by executing tests in an efficient manner. One of the significant factors that hinder developers\u2019 productivity is flaky tests\u2014tests that may pass and fail with the same version of code. Since flaky test failures are not deterministically reproducible, developers often have to spend hours only to discover that the occasional failures have nothing to do with their changes. However, ignoring failures of flaky tests can be dangerous, since those failures may represent real faults in the production code. Furthermore, identifying the root cause of flakiness is tedious and cumbersome, since they are often a consequence of unexpected and non-deterministic behavior due to various factors, such as concurrency and external dependencies.", "num_citations": "55\n", "authors": ["256"]}
{"title": "Restler: Stateful rest api fuzzing\n", "abstract": " This paper introduces RESTler, the first stateful REST API fuzzer. RESTler analyzes the API specification of a cloud service and generates sequences of requests that automatically test the service through its API. RESTler generates test sequences by (1) inferring producer-consumer dependencies among request types declared in the specification (e.g., inferring that \"a request B should be executed after request A\" because B takes as an input a resource-id x produced by A) and by (2) analyzing dynamic feedback from responses observed during prior test executions in order to generate new tests (e.g., learning that \"a request C after a request sequence A;B is refused by the service\" and therefore avoiding this combination in the future). We present experimental results showing that these two techniques are necessary to thoroughly exercise a service under test while pruning the large search space of possible\u00a0\u2026", "num_citations": "52\n", "authors": ["256"]}
{"title": "Model checking without a model: An analysis of the heart-beat monitor of a telephone switch using verisoft\n", "abstract": " VeriSoft is a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary code written in full-fledged programming languages such as C or C++. The state space of a concurrent system is a directed graph that represents the combined behavior of all concurrent components in the system. By exploring its state space, VeriSoft can automatically detect coordination problems between the processes of a concurrent system. We report in this paper our analysis with VeriSoft of the\" Heart-Beat Monitor\"(HBM), a telephone switching application developed at Lucent Technologies. The HBM of a telephone switch determines the status of different elements connected to the switch by measuring propagation delays of messages transmitted via these elements. This information plays an important role in the routing of data in the switch, and can significantly impact switch\u00a0\u2026", "num_citations": "50\n", "authors": ["256"]}
{"title": "Model checking vs. generalized model checking: Semantic minimizations for temporal logics\n", "abstract": " Three-valued models, in which properties of a system are either true, false or unknown, have recently been advocated as a better representation for reactive program abstractions generated by automatic techniques such as predicate abstraction. Indeed, for the same cost, model checking three-valued abstractions can be used to both prove and disprove any temporal-logic property, whereas traditional conservative abstractions can only prove universal properties. Also, verification results can be more precise with generalized model checking, which checks whether there exists a concretization of an abstraction satisfying a temporal-logic formula. Since generalized model checking includes satisfiability as a special case (when everything in the model is unknown), it is in general more expensive than traditional model checking. In this paper, we study how to reduce generalized model checking to model checking by a\u00a0\u2026", "num_citations": "45\n", "authors": ["256"]}
{"title": "Statically validating must summaries for incremental compositional dynamic test generation\n", "abstract": " Compositional dynamic test generation can achieve significant scalability by memoizing symbolic execution sub-paths as test summaries. In this paper, we formulate the problem of statically validating symbolic test summaries against code changes. Summaries that can be proved still valid using a static analysis of a new program version do not need to be retested or recomputed dynamically. In the presence of small code changes, incrementality can considerably speed up regression testing since static checking is much cheaper than dynamic checking and testing. We provide several checks ranging from simple syntactic ones to ones that use a theorem prover. We present preliminary experimental results comparing these approaches on three large Windows applications.", "num_citations": "40\n", "authors": ["256"]}
{"title": "On the costs and benefits of using partial-order methods for the verification of concurrent systems\n", "abstract": " Verification by state-space exploration is one of the most successful strategies for analyzing the correctness of finite-state concurTent reactive systems. Partial-order methods are algorithms for dynamically pruning the state space of such systems without incurring the risk of any incompleteness in the verification results. This paper presents results of experiments performed with these algorithms on real protocol examples, and discusses the practical significance of partial-order methods.", "num_citations": "39\n", "authors": ["256"]}
{"title": "Proving memory safety of floating-point computations by combining static and dynamic program analysis\n", "abstract": " Whitebox fuzzing is a novel form of security testing based on dynamic symbolic execution and constraint solving. Over the last couple of years, whitebox fuzzers have found many new security vulnerabilities (buffer overflows) in Windows and Linux applications, including codecs, image viewers and media players. Those types of applications tend to use floating-point instructions available on modern processors, yet existing whitebox fuzzers and SMT constraint solvers do not handle floating-point arithmetic. Are there new security vulnerabilities lurking in floating-point code?", "num_citations": "38\n", "authors": ["256"]}
{"title": "LinkedIn password leak: salt their hide.\n", "abstract": " 6.5 million unsalted SHA1 hashed LinkedIn passwords have appeared in the criminal underground. There are two words in that sentence that should cause LinkedIn no end of concern:\" unsalted\" and\" SHA1.\"", "num_citations": "37\n", "authors": ["256"]}
{"title": "Test generation using symbolic execution\n", "abstract": " This paper presents a short introduction to automatic code-driven test generation using symbolic execution. It discusses some key technical challenges, solutions and milestones, but is not an exhaustive survey of this research area.", "num_citations": "36\n", "authors": ["256"]}
{"title": "Fuzzing: Hack, art, and science\n", "abstract": " Reviewing software testing techniques for finding security vulnerabilities.", "num_citations": "34\n", "authors": ["256"]}
{"title": "Software partitioning for effective automated unit testing\n", "abstract": " A key problem for effective unit testing is the dificulty of partitioning large software systems into appropriate units that can be tested in isolation. We present an approach that identifies control and data inter-dependencies between software components using static program analysis, and divides the source code into units where highly-intertwined components are grouped together. Those units can then be tested in isolation using automated test generation techniques and tools, such as dynamic software model checkers. We discuss preliminary experimental results showing that automatic software partitioning can significantly increase test coverage without generating too many false alarms caused by unrealistic inputs being injected at interfaces between units.", "num_citations": "34\n", "authors": ["256"]}
{"title": "Model checking in practice: An analysis of the ACCESS. bus\u2122 protocol using SPIN\n", "abstract": " This paper presents a case study of the use of model checking for analyzing an industrial protocol, the ACCESS.bus\u2122 protocol. Our analysis of this protocol was carried out using SPIN, an automated verification system which includes an implementation of model-checking algorithms. A model of the protocol was developed, and properties expressed by linear-time temporal-logic formulas were checked on this model. This analysis revealed subtle flaws in the design of the protocol. Developers who worked on implementations of ACCESS.bus\u2122 were unaware of these flaws at a very late stage of their development process. We also present suggestions for solving the detected problems.", "num_citations": "34\n", "authors": ["256"]}
{"title": "Automatic context-sensitive sanitization\n", "abstract": " An automatic context-sensitive sanitization technique detects errors due to the mismatch of a sanitizer sequence with a browser parsing context. A pre-deployment analyzer automatically detects violating paths that contain a sanitizer sequence that is inconsistent with a browsing context associated with outputting an untrusted input. The pre-deployment analyzer determines a correct sanitizer sequence which is stored in a sanitization cache. During the runtime execution of the web application, a path detector tracks execution of the web application in relation to the violating paths. The correct sanitizer sequence can be applied when the runtime execution follows a violating path.", "num_citations": "33\n", "authors": ["256"]}
{"title": "Software model checking: Searching for computations in the abstract or the concrete\n", "abstract": " We review and discuss the current approaches to software model checking, including the complementary views of validation versus falsification and those of static versus dynamic analysis. For falsification, also known as bug finding, we advocate the need for blended approaches that combine the strengths of both static and dynamic analysis. We outline possible directions of research in this area.", "num_citations": "32\n", "authors": ["256"]}
{"title": "Exploiting symmetry when model-checking software\n", "abstract": " We study how to exploit symmetry induced by identical processes or data structures when systematically exploring the state spaces of concurrent software applications such as implementations of communication protocols. Existing model-checking symmetry reduction methods are based on equivalence classes of states, and assume that every system state can easily be encoded by a unique string of bits. When dealing with processes described by software programs written in full-fledged programming languages such as C, C++ or Java, this assumption is not valid anymore. Indeed, the state of each process is determined by the values of all the memory locations that can be accessed by the process and influence its behavior (including activation records associated to procedure calls). This amount of information is typically far too large and complex to be efficiently computed at each step of a state-space\u00a0\u2026", "num_citations": "32\n", "authors": ["256"]}
{"title": "Method for automatically closing open reactive systems\n", "abstract": " A unique process, ie, method, is employed to automatically close an open reactive system. This is realized by employing a unique analysis technique to automatically close the open system by eliminating its interface to its environment. This allows the open system being analyzed to be comprised of either a single sequential process or a set of concurrent processes. The effect of closing the system is to make it executable and amenable to analysis. This is because the resulting closed system simulates the behavior of the original open system in its most general environment. Specifically, this is realized by employing a unique method that transforms an open system into a closed nondeterministic system such that all data values in the open system and its environment that may depend on the behavior of the environment are eliminated in the resulting closed system, and all control-flow choices in the open system and\u00a0\u2026", "num_citations": "30\n", "authors": ["256"]}
{"title": "Incremental compositional dynamic test generation\n", "abstract": " Concepts and technologies are described herein for incremental compositional dynamic test generation. The concepts and technologies described herein are used to increase the code coverage and security vulnerability identification abilities of testing applications and devices, without significantly increasing, and in some cases decreasing, computational and time costs associated with the testing. Test summaries that describe how code is tested by a test engine are generated and stored during testing of code. These test summaries can be evaluated when additional iterations or versions of the code are tested. If functions corresponding to the test summaries are unchanged from, or logically equivalent to, a version of the function previously tested, the test summary may be used when testing the new version of the code.", "num_citations": "27\n", "authors": ["256"]}
{"title": "Proving memory safety of the ANI Windows image parser using compositional exhaustive testing\n", "abstract": " We report in this paper how we proved memory safety of a complex Windows image parser written in low-level C in only three months of work and using only three core techniques, namely (1) symbolic execution at the x86 binary level, (2) exhaustive program path enumeration and testing, and (3) user-guided program decomposition and summarization. We also used a new tool, named MicroX, for executing code fragments in isolation using a custom virtual machine designed for testing purposes. As a result of this work, we are able to prove, for the first time, that a Windows image parser is memory safe, i.e., free of any buffer-overflow security vulnerabilities, modulo the soundness of our tools and several additional assumptions regarding bounding input-dependent loops, fixing a few buffer-overflow bugs, and excluding some code parts that are not memory safe by design. In the process, we also discovered\u00a0\u2026", "num_citations": "26\n", "authors": ["256"]}
{"title": "The soundness of bugs is what matters (position statement)\n", "abstract": " In this short note, I argue that most program analysis and verification research seems confused about the ultimate goal of software defect detection. The Goal is to Find Bugs. The main practical usefulness of software defect detection is the ability to find bugs, not to report that\" no bugs have been found\". Unfortunately, the latter is sometimes confused for a correctness proof. In practice, there is no such thing as a complete correctness proof, since even a sound analysis implemented flawlessly in a bug-free tool is bound to check only a specific set of properties. So, Why May-Analysis? Yet, most defect detection tools are surprisingly based on program verification ideas and make use of conservative abstractions. By design, such tools detect bugs that may happen. The price to pay for this questionable design decision is enormous: such tools are doomed to report (many) false alarms, ie, unsound bugs. Despite progress\u00a0\u2026", "num_citations": "26\n", "authors": ["256"]}
{"title": "Simulation of a process of a concurrent system\n", "abstract": " The simulation of sequences of the visible operations of a process in a concurrent system is performed by synthesizing the finite-state machine for the process from a projected tree. The synthesis procedure includes a parameter that can be adjusted to obtain machines that represent the desired behavior with varying degrees of approximation. An\" on-the-fly\" version of the invention provides intermediate results while the state space of the system continues to be explored. The finite-state machines may be abstracted to reduce the magnitude of visible operations to be considered to a more manageable level.", "num_citations": "26\n", "authors": ["256"]}
{"title": "Protocol verification using symbolic representations of queues\n", "abstract": " A finite symbolic representation of the states of an unbounded FIFO queue. Because the representation is protocol verification tools of the type which explore the state space of a protocol may be used to verify protocols which involve unbounded FIFO queues and consequently have an infinite state space. In a preferred embodiment, the finite symbolic representation is used together with a finite state automaton whose states are the global states of the protocol. A symbolic representation of the queue states is associated with each of the global states. State space exploration continues until all new queue states reached are already contained in the states of the finite symbolic representation. Increased processing speed is achieved by employing meta-transitions in the finite state automaton and exploring the meta-transitions from a global state before exploring the ordinary transitions.", "num_citations": "26\n", "authors": ["256"]}
{"title": "Systematic software testing using VeriSoft\u2014An analysis of the 4ESS\u2122 heart\u2010beat monitor\n", "abstract": " VeriSoft is a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary code written in full\u2010fledged programming languages, such as C or C++. Using VeriSoft, we analyzed the 4ESS\u2122 switch Heart\u2010Beat Monitor (HBM), a telephone switching application developed at Lucent Technologies. The 4ESS HBM plays an important role in routing data in the switch and can significantly affect switch performance. Since VeriSoft automatically generates, executes, and evaluates thousands of tests per minute and has complete control over nondeterminism, our analysis revealed HBM behavior that is virtually impossible to detect or test in a traditional lab testing environment. Specifically, we discovered flaws in the existing documentation for this application and unexpected behaviors in the software itself. These results are being used as the basis for an improved\u00a0\u2026", "num_citations": "24\n", "authors": ["256"]}
{"title": "LTL generalized model checking revisited\n", "abstract": " Given a 3-valued abstraction of a program (possibly generated using static program analysis and predicate abstraction) and a temporal logic formula, generalized model checking (GMC) checks whether there exists a concretization of that abstraction that satisfies the formula. In this paper, we revisit generalized model checking for linear time (LTL) properties. First, we show that LTL GMC is 2EXPTIME-complete in the size of the formula and polynomial in the model, where the degree of the polynomial depends on the formula, instead of EXPTIME-complete and quadratic as previously believed. The standard definition of GMC depends on a definition of concretization which is tailored for branching-time model checking. We then study a simpler linear completeness preorder for relating program abstractions. We show that LTL GMC with this weaker preorder is only EXPSPACE-complete in the size of the formula\u00a0\u2026", "num_citations": "23\n", "authors": ["256"]}
{"title": "Reasoning about abstract open systems with generalized module checking\n", "abstract": " We present a framework for reasoning about abstract open systems. Open systems, also called \u201creactive systems\u201d or \u201cmodules\u201d, are systems that interact with their environment and whose behaviors depend on these interactions. Embedded software is a typical example of open system. Module checking [KV96] is a verification technique for checking whether an open system satisfies a temporal property no matter what its environment does. Module checking makes it possible to check adversarial properties of the \u201cgame\u201d played by the open system with its environment (such as \u201cis there a winning strategy for a malicious agent trying to intrude a secure system?\u201d). We study how module checking can be extended to reason about 3-valued abstractions of open systems in such a way that both proofs and counter-examples obtained by verifying arbitrary properties on such abstractions are guaranteed to be sound\u00a0\u2026", "num_citations": "23\n", "authors": ["256"]}
{"title": "Memory safety of floating-point computations\n", "abstract": " Concepts and technologies are described herein for determining memory safety of floating-point computations. The concepts and technologies described herein analyze code to determine if any floating-point computations exist in the code, and if so, if the floating-point computations are memory safe. The analysis can include identifying floating-point instructions and conditional statements in the code. The code can be symbolically executed, and behavior of the floating-point instructions and the conditional statements can be monitored to determine if a floating point calculation is ever involved in computation of any memory address during the execution of the code.", "num_citations": "20\n", "authors": ["256"]}
{"title": "Automatic synthesis of specifications from the dynamic observation of reactive programs\n", "abstract": " VeriSoft [God97] is a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary C (or C++) code. VeriSoft can automatically detect coordination problems between the concurrent processes of a system. In this paper, we present a method to synthesize a finite-state machine that simulates all the sequences of visible operations of a given process that were observed during a state-space exploration performed by VeriSoft. The examination of this machine makes it possible to discover the dynamic behavior of the process in its environment and to understand how it contributes to the global behavior of the system.", "num_citations": "20\n", "authors": ["256"]}
{"title": "IC-Cut: A compositional search strategy for dynamic test generation\n", "abstract": " We present IC-Cut, short for \u201cInterface-Complexity-based Cut\u201d, a new compositional search strategy for systematically testing large programs. IC-Cut dynamically detects function interfaces that are simple enough to be cost-effective for summarization. IC-Cut then hierarchically decomposes the program into units defined by such functions and their sub-functions in the call graph. These units are tested independently, their test results are recorded as low-complexity function summaries, and the summaries are reused when testing higher-level functions in the call graph, thus limiting overall path explosion. When the decomposed units are tested exhaustively, they constitute verified components of the program. IC-Cut is run dynamically and on-the-fly during the search, typically refining cuts as the search advances.                 We have implemented this algorithm as a new search strategy in the whitebox fuzzer\u00a0\u2026", "num_citations": "19\n", "authors": ["256"]}
{"title": "Network verification in the light of program verification\n", "abstract": " The fastest tools for network reachability queries use adhoc algorithms to compute all packets from a source S that can reach a destination D. This paper examines whether network reachability can be solved efficiently using existing verification tools. While most verification tools only compute reachability (\u201cCan S reach D?\u201d), we efficiently generalize them to compute all reachable packets. Using new and old benchmarks, we compare model checkers, SAT solvers and various Datalog implementations. The only existing verification method that worked competitively on all benchmarks in seconds was Datalog with a new composite Filter-Project operator and a Difference of Cubes representation. While Datalog is slightly slower than the Hassel C tool, it is far more flexible. We also present new results that more precisely characterize the computational complexity of network verification. This paper also provides a gentle introduction to program verification for the networking community.", "num_citations": "16\n", "authors": ["256"]}
{"title": "Software Model Checking Improving Security of a Billion Computers.\n", "abstract": " Software Model Checking Improving Security of a Billion Computers Page 1 Page 1 June 2009 SPIN\u20192009 Software Model Checking Improving Security of a Billion Computers Patrice Godefroid Microsoft Research Page 2 Page 2 June 2009 SPIN\u20192009 Acknowledgments \u2022 Joint work with Michael Levin (CSE) and others: \u2013 Chris Marsh, Lei Fang, Stuart de Jong (CSE) \u2013 interns Dennis Jeffries (06), David Molnar (07), Adam Kiezun (07), Bassem Elkarablieh (08), \u2026 \u2022 Thanks to the entire SAGE team and users ! \u2013 MSR: Ella Bounimova,\u2026 \u2013 Z3: Nikolaj Bjorner, Leonardo de Moura,\u2026 \u2013 WEX (Windows): Nick Bartmon, Eric Douglas,\u2026 \u2013 Office: Tom Gallagher, Octavian Timofte,\u2026 \u2013 SAGE users all across Microsoft! Page 3 Page 3 June 2009 SPIN\u20192009 References \u2022 see http://research.microsoft.com/users/pg \u2013 DART: Directed Automated Random Testing, with N. Klarlund and K. Sen, PLDI\u20192005 \u2013 Compositional Dynamic , \u2019\u2013 \u2019\u2026", "num_citations": "14\n", "authors": ["256"]}
{"title": "Automated systematic testing for constraint-based interactive services\n", "abstract": " Constraint-based languages can express in a concise way the complex logic of a new generation of interactive services for applications such as banking or stock trading, that must support multiple types of interfaces for accessing the same data. These include automatic speech-recognition interfaces where inputs may be provided in any order by users of the service. We study in this paper how to systematically test event-driven applications developed using such languages. We show how such applications can be tested automatically, without the need for any manually-written test cases, and efficiently, by taking advantage of their capability of taking unordered sets of events as inputs.", "num_citations": "13\n", "authors": ["256"]}
{"title": "Analysis of boolean programs\n", "abstract": " Boolean programs are a popular abstract domain for static-analysis-based software model checking. Yet little is known about the complexity of model checking for this model of computation. This paper aims to fill this void by providing a comprehensive study of the worst-case complexity of several basic analyses of Boolean programs, including reachability analysis, cycle detection, LTL, CTL, and CTL* model checking. We present algorithms for these problems and show that our algorithms are all optimal by providing matching lower bounds. We also identify particular classes of Boolean programs which are easier to analyse, and compare our results to prior work on pushdown model checking.", "num_citations": "12\n", "authors": ["256"]}
{"title": "Pythia: grammar-based fuzzing of REST APIs with coverage-guided feedback and learning-based mutations\n", "abstract": " This paper introduces Pythia, the first fuzzer that augments grammar-based fuzzing with coverage-guided feedback and a learning-based mutation strategy for stateful REST API fuzzing. Pythia uses a statistical model to learn common usage patterns of a target REST API from structurally valid seed inputs. It then generates learning-based mutations by injecting a small amount of noise deviating from common usage patterns while still maintaining syntactic validity. Pythia's mutation strategy helps generate grammatically valid test cases and coverage-guided feedback helps prioritize the test cases that are more likely to find bugs. We present experimental evaluation on three production-scale, open-source cloud services showing that Pythia outperforms prior approaches both in code coverage and new bugs found. Using Pythia, we found 29 new bugs which we are in the process of reporting to the respective service owners.", "num_citations": "11\n", "authors": ["256"]}
{"title": "Automated software test generation: some challenges, solutions, and recent advances\n", "abstract": " The automation of software testing promises to delegate to machines what is otherwise the most labor-intensive and expensive part of software development. The past decade has seen a resurgence in research interest for this problem, bringing about significant progress. In this article, we provide an overview of automated test generation for software, and then discuss recent developments that have had significant impact on real-life software.", "num_citations": "11\n", "authors": ["256"]}
{"title": "Checking security properties of cloud service rest apis\n", "abstract": " Most modern cloud and web services are programmatically accessed through REST APIs. This paper discusses how an attacker might compromise a service by exploiting vulnerabilities in its REST API. We introduce four security rules that capture desirable properties of REST APIs and services. We then show how a stateful REST API fuzzer can be extended with active property checkers that automatically test and detect violations of these rules. We discuss how to implement such checkers in a modular and efficient way. Using these checkers, we found new bugs in several deployed production Azure and Office365 cloud services, and we discuss their security implications. All these bugs have been fixed.", "num_citations": "10\n", "authors": ["256"]}
{"title": "Dna pairing: Using differential network analysis to find reachability bugs\n", "abstract": " Existing tools for network reachability such as HSA, Anteater, Veriflow and NetPlumber focus on queries for a single path and single snapshot in time\u2013eg,\u201cwhich packets from a source to a destination pass through a middlebox?\u201d Motivated by reachability problems in a large public cloud, we identify a need for reachability differences across multiple paths and across snapshots in time\u2013eg,\u201ccan packets be dropped on some load balanced paths but not others?\u201d or \u201care packets being dropped which were being let through a day ago?\u201d. We show that Datalog allows us to formulate such differential queries in space and time, and provides other useful features of a higher-level programming language such as definitions, recursion, and stratified negation. By adding a difference of cubes symbolic table representation, and an optimized filter-project operation to Datalog, we were able to complete large network benchmarks in\u00a0\u2026", "num_citations": "10\n", "authors": ["256"]}
{"title": "From program to logic: An introduction\n", "abstract": " We review, compare and discuss several approaches for representing programs by logic formulas, such as symbolic model checking, bounded model checking, verification-condition generation, and symbolic-execution-based test generation.", "num_citations": "10\n", "authors": ["256"]}
{"title": "From blackbox fuzzing to whitebox fuzzing towards verification\n", "abstract": " From Blackbox Fuzzing to Whitebox Fuzzing towards Verification Page 1 Page 1 July 2010 ISSTA\u20192010 From Blackbox Fuzzing to Whitebox Fuzzing towards Verification Patrice Godefroid Microsoft Research 2000 2005 2010 2015 Blackbox Fuzzing Whitebox Fuzzing Verification Page 2 Page 2 July 2010 ISSTA\u20192010 Acknowledgments \u2022 Joint work with: \u2013 MSR: Ella Bounimova, David Molnar,\u2026 \u2013 CSE: Michael Levin, Chris Marsh, Lei Fang, Stuart de Jong,\u2026 \u2013 Interns Dennis Jeffries (06), David Molnar (07), Adam Kiezun (07), Bassem Elkarablieh (08), Cindy Rubio-Gonzalez (08,09), Johannes Kinder (09),\u2026 \u2022 Thanks to the entire SAGE team and users ! \u2013 Z3: Nikolaj Bjorner, Leonardo de Moura,\u2026 \u2013 Windows: Nick Bartmon, Eric Douglas,\u2026 \u2013 Office: Tom Gallagher, Eric Jarvi, Octavian Timofte,\u2026 \u2013 SAGE users all across Microsoft! Page 3 Page 3 July 2010 ISSTA\u20192010 References \u2022 See http://research.microsoft.com//pg \u2019\u2026", "num_citations": "10\n", "authors": ["256"]}
{"title": "The Ulg partial-order package for SPIN\n", "abstract": " This document presents an overview of the Partial-Order Package for SPIN developed at the University of Li ege (ULg) in 1992 {1994. The current version of the ULg Partial-Order Package (Version 3.0) is available free of charge for educational and research purposes by anonymous ftp from ftp. monte ore. ulg. ac. be in the/pub/popackage directory.", "num_citations": "10\n", "authors": ["256"]}
{"title": "Micro-execution for software testing\n", "abstract": " Micro-execution is the ability to run any code segment in isolation. Implementations for micro-execution of code segments are described. A test engine determines an effective address of a memory operation of an instruction of an executable program. The test engine determines, prior to performing the memory operation and based on a memory policy, that the effective address is to be replaced with a replacement address. Based on determining that the effective address is to be replaced, the test engine allocates the replacement address and executes the instruction based on the allocated replacement address.", "num_citations": "9\n", "authors": ["256"]}
{"title": "Automated whitebox fuzz testing\n", "abstract": " Automated Whitebox Fuzz Testing Page 1 Automated Whitebox Fuzz Testing Patrice Godefroid (Microsoft Research)\u200f Michael Y. Levin (Microsoft Center for Software Excellence)\u200f David Molnar (UC-Berkeley & MSR) Page 2 Fuzz Testing \u2022 Send \u201crandom\u201d data to application \u2013 B. Miller et al.; inspired by line noise \u2022 Fuzzing well-formed \u201cseed\u201d \u2022 Heavily used in security testing \u2013 eg July 2006 \u201cMonth of Browser Bugs\u201d Page 3 Whitebox Fuzzing \u2022 Combine fuzz testing with dynamic test generation \u2013 Run the code with its input \u2013 Collect constraints on inputs with symbolic execution \u2013 Generate new constraints \u2013 Solve constraints with constraint solver \u2013 Synthesize new inputs \u2013 Leverages Directed Automated Random Testing (DART)\u200f ( [Godefroid-Klarlund-Sen PLDI 2005,\u2026])\u200f Page 4 Dynamic Test Generation void top(char input[4]) { int cnt = 0; if (input[0] == \u2018b\u2019) cnt++; if (input[1] == \u2018a\u2019) cnt++; if (input[2] == \u2018d\u2019) cnt++; if (input[3] == \u2018!\u2026", "num_citations": "9\n", "authors": ["256"]}
{"title": "Protocol checking for concurrent systems\n", "abstract": " A verification of the protocol between the various communicating elements of a concurrent system may be performed directly using the actual code that implements the element when it is actually operating. This is achieved by combining stateless search techniques with partial order methods, namely, persistent set and sleep set methods. In particular, the code of each element of a system is exercised by a scheduler in such a way that global states of the system are visited according to a stateless search, which is a search that does not use an explicit representation of the global states. A global state is a state in which the next operation to be executed by every element of the system is a visible operation. The set of visible operations includes at least those operations related to communication between the elements. The global states are visited using an intelligent state space exploration technique so that only a\u00a0\u2026", "num_citations": "9\n", "authors": ["256"]}
{"title": "Rest-ler: automatic intelligent rest api fuzzing\n", "abstract": " Cloud services have recently exploded with the advent of powerful cloud-computing platforms such as Amazon Web Services and Microsoft Azure. Today, most cloud services are accessed through REST APIs, and Swagger is arguably the most popular interface-description language for REST APIs. A Swagger specification describes how to access a cloud service through its REST API (e.g., what requests the service can handle and what responses may be expected). This paper introduces REST-ler, the first automatic intelligent REST API security-testing tool. REST-ler analyzes a Swagger specification and generates tests that exercise the corresponding cloud service through its REST API. Each test is defined as a sequence of requests and responses. REST-ler generates tests intelligently by (1) inferring dependencies among request types declared in the Swagger specification (e.g., inferring that \"a request B should not be executed before a request A\" because B takes as an input argument a resource-id x returned by A) and by (2) analyzing dynamic feedback from responses observed during prior test executions in order to generate new tests (e.g., learning that \"a request C after a request sequence A;B is refused by the service\" and therefore avoiding this combination in the future). We show that these two techniques are necessary to thoroughly exercise a service under test while pruning the large search space of possible request sequences. We also discuss the application of REST-ler to test GitLab, a large popular open-source self-hosted Git service, and the new bugs that were found.", "num_citations": "8\n", "authors": ["256"]}
{"title": "Differential regression testing for REST APIs\n", "abstract": " Cloud services are programmatically accessed through REST APIs. Since REST APIs are constantly evolving, an important problem is how to prevent breaking changes of APIs, while supporting several different versions. To find such breaking changes in an automated way, we introduce differential regression testing for REST APIs. Our approach is based on two observations. First, breaking changes in REST APIs involve two software components, namely the client and the service. As such, there are also two types of regressions: regressions in the API specification, ie, in the contract between the client and the service, and regressions in the service itself, ie, previously working requests are\" broken\" in later versions of the service. Finding both kinds of regressions involves testing along two dimensions: when the service changes and when the specification changes. Second, to detect such bugs automatically, we\u00a0\u2026", "num_citations": "7\n", "authors": ["256"]}
{"title": "Fuzzing in the cloud (position statement)\n", "abstract": " In this short note, we argue that fuzzing in the cloud will revolutionize security testing. It\u2019s more than elasticity. Fuzz testing is the process of repeatedly feeding modified inputs to a program in order to uncover security bugs (such as buffer overflows). Because fuzzing is typically easy to parallelize by running multiple instances of the program under test, it benefits from the elastic nature of cloud computing: if an organization wants to perform 100,000 test iterations, it only needs machines for the required time. This elasticity means that smaller teams or smaller companies can experiment with fuzz testing without a large capital cost.Despite these benefits of elasticity, in the long run an organization that needs software security will find itself continuously testing. New releases of software need new security testing, whether by the authors of the software or by adversaries trying to find security holes. Over time, this repeated testing chips away at the \u201crent vs. own\u201d argument for cloud infrastructure. An organization that does fuzz testing for each build of a piece of software will pass the break-even point for buying its own dedicated machines in a matter of months, even when the costs for cooling, administration, etc. are taken into account. Elasticity is not the \u201ckiller argument\u201d for cloud fuzzing. It\u2019s about shared infrastructure. Instead, the major win for cloud fuzzing comes from a shared security infrastructure for the entire picture of people, processes, and tools required to build secure software. Each application must be \u201cenrolled\u201d in a fuzz testing infrastructure, which includes defining how new inputs are passed to the program (test harnesses/drivers), how to detect\u00a0\u2026", "num_citations": "6\n", "authors": ["256"]}
{"title": "Veriweb: Automatically testing dynamic web sites\n", "abstract": " VeriWeb:Automatically Testing Dynamic Web Sites Page 1 Juliana Freire 1 WWW2002 VeriWeb:Automatically Testing Dynamic Web Sites Juliana Freire http://www-db.bell-labs.com/~juliana Bell Labs Joint work with Michael Benedikt and Patrice Godefroid Page 2 Juliana Freire 2 WWW2002 Web pages became very complex \u25c6 Almost 90 different actions (85 links and 3 forms); \u25c6 96 gif images; \u25c6 113 lines of JavaScript code; \u25c6 ~570 lines of HTML Page 3 Juliana Freire 3 WWW2002 5 navigation steps, 650kb transferred Web navigation became very complex Go to travelocity.com Enter login info Choose 9 best itineraries Enter itinerary Flight list Page 4 Juliana Freire 4 WWW2002 Microsoft JET Database Engine error '80004005' Could not find file 'e:\\\u2026..\\cgi-bin\\db\\unimagem.mdb'. /cgi-bin/\u2026./main.asp, line 695 Many things can go wrong \u25c6 Interactions between HTML pages \u25c6 Applications that run in Web pages (, -\u2026", "num_citations": "6\n", "authors": ["256"]}
{"title": "Intelligent REST API data fuzzing\n", "abstract": " The cloud runs on REST APIs. In this paper, we study how to intelligently generate data payloads embedded in REST API requests in order to find data-processing bugs in cloud services. We discuss how to leverage REST API specifications, which, by definition, contain data schemas for API request bodies. We then propose and evaluate a range of data fuzzing techniques, including structural schema fuzzing rules, various rule combinations, search heuristics, extracting data values from examples included in REST API specifications, and learning data values on-the-fly from previous service responses. After evaluating these techniques, we identify the top-performing combination and use this algorithm to fuzz several Microsoft Azure cloud services. During our experiments, we found 100s of \u201cInternal Server Error\u201d service crashes, which we triaged into 17 unique bugs and reported to Azure developers. All these bugs\u00a0\u2026", "num_citations": "5\n", "authors": ["256"]}
{"title": "A general framework for dynamic stub injection\n", "abstract": " Stub testing is a standard technique to simulate the behavior of dependencies of an application under test such as the file system. Even though existing frameworks automate the actual stub injection, testers typically have to implement manually where and when to inject stubs, in addition to the stub behavior. This paper presents a novel framework that reduces this effort. The framework provides a domain specific language to describe stub injection strategies and stub behaviors via declarative rules, as well as a tool that automatically injects stubs dynamically into binary code according to these rules. Both the domain specific language and the injection are language independent, which enables the reuse of stubs and injection strategies across applications. We implemented this framework for both unmanaged (assembly) and managed (.NET) code and used it to perform fault injection for twelve large applications\u00a0\u2026", "num_citations": "5\n", "authors": ["256"]}
{"title": "VeriWeb: A platform for automating web site testing\n", "abstract": " VeriWeb: A Platform for Automating Web Site Testing \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output VeriWeb: A Platform for Automating Web Site Testing M. Benedikt, Juliana Freire, P. Godefroid Urban Initiative Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter (peer-reviewed) Overview Original language English (US) Title of host publication Proceedings of the World Wide Web Conference (WWW) \u2013 Web Engineering track State Published - 2002 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Benedikt, M., Freire, J., & Godefroid, P. (2002). VeriWeb: A Platform for Automating Web Site Testing. In Proceedings of the World Wide Web Conference (WWW) \u2013 Web Engineering track VeriWeb : A Platform for Automating Web Site Testing. / Benedikt, M. ; Freire, Juliana; , P\u2026", "num_citations": "5\n", "authors": ["256"]}
{"title": "Using partial orders to improve automatic verification methods. Computer-Aided Verification \u201890, New Brunswick, NJ (proceedings of a workshop). AMS-ACM DIMACS Series in\u00a0\u2026\n", "abstract": " In this paper, we present a verification method for concurrent finite-state systems that attempts to avoid the part of the combinatorial explosion due to the modeling of concurrency by interleavings. The be-havior of a system is described in terms of partial orders (more precisely in terms of Mazurkiewicz's traces) rather than in terms of interleavings. We introduce the notion of \u201ctrace automaton\u201d which generates only one linearization per partial order. Then we show how to use trace automata to prove program correctness.", "num_citations": "5\n", "authors": ["256"]}
{"title": "Between Testing and Verification: Dynamic Software Model Checking.\n", "abstract": " Dynamic software model checking consists of adapting model checking into a form of systematic testing that is applicable to industrial-size software. Over the last two decades, dozens of tools following this paradigm have been developed for checking concurrent and data-driven software. Compared to traditional software testing, dynamic software model checking provides better coverage, but is more computationally expensive. Compared to more general forms of program verification like interactive theorem proving, this approach provides more limited verification guarantees, but is cheaper due to its higher level of automation. Dynamic software model checking thus offers an attractive practical trade-off between testing and formal verification. This paper presents a brief introduction to dynamic software model checking.", "num_citations": "3\n", "authors": ["256"]}
{"title": "May/Must Abstraction-Based Software Model Checking for Sound Verification and Falsification.\n", "abstract": " Three-valued models, in which properties of a system are either true, false or unknown, have recently been advocated as a better representation for reactive program abstractions generated by automatic techniques such as predicate abstraction. Indeed, for the same cost, model checking three-valued abstractions, also called may/must abstractions, can be used to both prove and disprove any temporallogic property, whereas traditional conservative abstractions can only prove universal properties. Also, verification results can be more precise with generalized model checking, which checks whether there exists a concretization of an abstraction satisfying a temporal-logic formula. Generalized model checking generalizes both model checking (when the model is complete) and satisfiability (when everything in the model is unknown), probably the two most studied problems related to temporal logic and verification.This paper presents an introduction to the main ideas behind this framework, namely models for three-valued abstractions, completeness preorders to measure the level of completeness of such models, three-valued temporal logics and generalized model checking. It also discusses algorithms and complexity bounds for three-valued model checking and generalized model-checking for various temporal logics. Finally, it discusses applications to program verification via automatic abstraction.", "num_citations": "3\n", "authors": ["256"]}
{"title": "Model Checking Software\n", "abstract": " This volume contains the proceedings of the 12th International SPIN Workshop on Model Checking of Software, held in San Francisco, USA, on August 22\u201324, 2005. SPIN 2005 is a forum for practitioners and researchers interested in model-checking based techniques for the validation and analysis of communication protocols and software systems. The workshop focuses on topics including theoretical and algorithmic foundations and tools for software model checking, model derivation from code and code derivation from models, techniques for dealing with large and infinite state spaces, and applications. The workshop aims to foster interactions and exchanges of ideas with all related areas in software engineering. It has traditionally drawn contributions from both academia and industry.The SPIN workshop series started 10 years ago, in 1995. Since then, SPIN workshops have been held on an annual basis at\u00a0\u2026", "num_citations": "3\n", "authors": ["256"]}
{"title": "Automatic intelligent cloud service testing tool\n", "abstract": " In a method for automatically testing a service via a programming interface of the service includes, a set of operation descriptions describing a set of operations supported by the service is obtained. The set of operation descriptions includes respective descriptions of requests associated with respective operations in the set of operations and responses expected in response to the requests. Based on the set of operation descriptions, dependencies among the requests associated with the respective operations are determined, and a set of test request sequences that satisfy the determined dependencies is generated. Test request sequences in the set of test request sequences are executed to test the service via the programming interface of the service.", "num_citations": "2\n", "authors": ["256"]}
{"title": "Generalized model checking\n", "abstract": " Three-valued models, in which properties of a system are either true, false or unknown, have recently been advocated as a better representation for reactive program abstractions generated by automatic techniques such as predicate abstraction. Indeed, for the same cost, model checking three-valued abstractions (also called may/must abstractions) can be used to both prove and disprove any temporal-logic property, whereas traditional conservative abstractions can only prove universal properties. Also, verification results can be more precise with generalized model checking, which checks whether there exists a concretization of an abstraction satisfying a temporal-logic formula. Generalized model checking generalizes both model checking (when the model is complete) and satisfiability (when everything in the model is unknown), probably the two most studied problems related to temporal logic and verification. In\u00a0\u2026", "num_citations": "2\n", "authors": ["256"]}
{"title": "Addendum to dynamic partial-order reduction for model checking software\n", "abstract": " The postcondition PC for Explore (S) becomes:\u2200 p\u2200 w:(\u2200 wi\u2208[w]: w1 i\u2208 Sleep (last (S)))\u21d2 PC (Sw,| S|, p) where\u2200 wi\u2208[w] denotes the set of sequences wi of transitions equivalent to w (ie, transition sequences that are part of the same Mazurkiewicz\u2019s trace\u2013see [10] for details), and where w1 i denotes the first transition of wi. In the presence of sleep sets, we use the following definition (similar notions are used in [9], for instance in Theorem 5.2):", "num_citations": "2\n", "authors": ["256"]}
{"title": "Transferring formal methods technology to industry\n", "abstract": " Computer vision in general, and object proposals in particular, are nowadays strongly influenced by the databases on which researchers evaluate the performance of their algorithms. This paper studies the transition from the Pascal Visual Object Challenge dataset, which has been the benchmark of reference for the last years, to the updated, bigger, and more challenging Microsoft Common Objects in Context. We first review and deeply analyze the new challenges, and opportunities, that this database presents. We then survey the current state of the art in object proposals and evaluate it focusing on how it generalizes to the new dataset. In sight of these results, we propose various lines of research to take advantage of the new benchmark and improve the techniques. We explore one of these lines, which leads to an improvement over the state of the art of+ 5.2%.", "num_citations": "2\n", "authors": ["256"]}
{"title": "Automatically closing open reactive programs\n", "abstract": " We study in this paper the problem of analyzing implementations of open systems---systems in which only some of the components are present. We present an algorithm for automatically closing an open concurrent reactive system with its most general environment, ie, the environment that can provide any input at any time to the system. The result is a nondeterministic closed (ie, self-executable) system which can exhibit all the possible reactive behaviors of the original open system. These behaviors can then be analyzed using VeriSoft, an existing tool for systematically exploring the state spaces of closed systems composed of multiple (possibly nondeterministic) processes executing arbitrary code. We have implemented the techniques introduced in this paper in a prototype tool for automatically closing open programs written in the C programming language. We discuss preliminary experimental results obtained with a large telephone-switching software application developed at Lucent Tec...", "num_citations": "2\n", "authors": ["256"]}
{"title": "Testing kernel mode computer code by executing the computer code in user mode\n", "abstract": " Described herein are technologies related to testing computer code for bugs, wherein the computer code is to run in kernel mode of an operating system. The computer code is executed in kernel mode of a first operating system, and content of memory that is mapped to kernel mode address space of the first operating system is transferred to user mode memory that is mapped to user mode address space of a second operating system. The computer code is executed in user mode and tested while being executed in user mode.", "num_citations": "1\n", "authors": ["256"]}
{"title": "An abort-aware model of transactional programming\n", "abstract": " There has been a lot of recent research on transaction-based concurrent programming, aimed at offering an easier concurrent programming paradigm that enables programmers to better exploit the parallelism of modern multi-processor machines, such as multi-core microprocessors. We introduce Transactional State Machines (TSMs) as an abstract finite-data model of transactional shared-memory concurrent programs. TSMs are a variant of concurrent boolean programs (or concurrent extended recursive state machines) augmented with additional constructs for specifying potentially nested transactions. Namely, some procedures (or code segments) can be marked as transactions and are meant to be executed \u201catomically\u201d, and there are also explicit commit and abort operations for transactions. The TSM model is non-blocking and allows interleaved executions where multiple processes can\u00a0\u2026", "num_citations": "1\n", "authors": ["256"]}
{"title": "Tests from Proofs.\n", "abstract": " Tests from Proofs Page 1 Page 1 June 2011 TAP\u201f2011 Tests from Proofs Patrice Godefroid Microsoft Research Page 2 Page 2 June 2011 TAP\u201f2011 Part 1: Tests from Satisfiability Proofs (Whitebox Fuzzing for Security Testing) Page 3 Page 3 June 2011 TAP\u201f2011 Security is Critical (to Microsoft) \u2022 Software security bugs can be very expensive: \u2013 Cost of each Microsoft Security Bulletin: $Millions \u2013 Cost due to worms (Slammer, CodeRed, Blaster, etc.): $Billions \u2022 Many security exploits are initiated via files or packets \u2013 Ex: MS Windows includes parsers for hundreds of file formats \u2022 Security testing: \u201chunting for million-dollar bugs\u201d \u2013 Write A/V (always exploitable), Read A/V (sometimes exploitable), NULL-pointer dereference, division-by-zero (harder to exploit but still DOS attacks), etc. Page 4 Page 4 June 2011 TAP\u201f2011 Hunting for Security Bugs \u2022 Main techniques used by \u201cblack hats\u201d: \u2013 Code inspection (of binaries: \u2026", "num_citations": "1\n", "authors": ["256"]}
{"title": "Software model checking via static and dynamic program analysis\n", "abstract": " Software Model Checking via Static and Dynamic Program Analysis Page 1 Page 1 June 2006 MOVEP 2006 Software Model Checking via Static and Dynamic Program Analysis Patrice Godefroid Bell Laboratories, Lucent Technologies Page 2 Page 2 June 2006 MOVEP 2006 Overview of Software Model Checking \u2022 Part I: The Dynamic Approach (Systematic Testing) \u2013 VeriSoft \u2022 Part II: The Static Approach (Automatic Abstraction) \u2013 SLAM and predicate abstraction, 3-valued model checking, generalized model checking \u2022 Part III: Combining the Static and Dynamic Approaches \u2013 DART, Compositional Dynamic Test Generation (SMART) \u2022 Disclaimer: emphasis on what influenced the speaker, not an exhaustive survey \u2022 Main references: see the bibliography of the abstract Page 3 Page 3 June 2006 MOVEP 2006 \u201cModel Checking\u201d \u2022 Model Checking (MC) = systematic state-space exploration = exhaustive testing \u2022 \u201c\u201d = \u201ca -\u2026", "num_citations": "1\n", "authors": ["256"]}
{"title": "Invited Talk: \" Model checking\" software with VeriSoft\n", "abstract": " VeriSoft is a tool for systematically testing concurrent reactive software systems. It explores the state space (dynamic behavior) of a system by driving and observing the execution of its components using a run-time scheduler, and by reinitializing their execution. This systematic state-space exploration is performed using model-checking algorithms and makes heavy use of so-called\" partial-order reduction\" techniques. By default, VeriSoft searches state spaces for violations of user-specified assertions and coordination problems (deadlocks, crashes, etc.) between concurrent components. With its first prototype developed in 1996 (published at POPL'97), VeriSoft is the first software model checker for general-purpose programming languages like C and C++. Since made publicly available in 1999, VeriSoft has been licensed to hundreds of users in industry and academia. Inside Lucent Technologies, it was applied\u00a0\u2026", "num_citations": "1\n", "authors": ["256"]}
{"title": "Symbolic protocol verification with Queue BDDs\n", "abstract": " Symbolic veri cation based on Binary Decision Diagrams (BDDs) has proven to be a powerful technique for ensuring the correctness of digital hardware. In contrast, BDDs have not caught on as widely for software veri cation, partly because the data types used in software are more complicated than those used in hardware. In this work, we propose an extension of BDDs for dealing with dynamic data structures. Speci cally, we focus on queues, since they are commonly used in modeling communication protocols. We introduce Queue BDDs (QBDDs), which include all the power of BDDs while also providing an e cient representation of queue contents. Experimental results show that QBDDs are well-suited for the veri cation of communication protocols.", "num_citations": "1\n", "authors": ["256"]}