{"title": "Using high-rising cities to visualize performance in real-time\n", "abstract": " For developers concerned with a performance drop or improvement in their software, a profiler allows a developer to quickly search and identify bottlenecks and leaks that consume much execution time. Non real-time profilers analyze the history of already executed stack traces, while a real-time profiler outputs the results concurrently with the execution of software, so users can know the results instantaneously. However, a real-time profiler risks providing overly large and complex outputs, which is difficult for developers to quickly analyze. In this paper, we visualize the performance data from a real-time profiler. We visualize program execution as a three-dimensional (3D) city, representing the structure of the program as artifacts in a city (i.e., classes and packages expressed as buildings and districts) and their program executions expressed as the fluctuating height of artifacts. Through two case studies and using a\u00a0\u2026", "num_citations": "18\n", "authors": ["749"]}
{"title": "Code clone graph metrics for detecting diffused code clones\n", "abstract": " Code clones (duplicated source code in a software system) are one of the major factors in decreasing maintainability. Many code clone detection methods have been proposed to find code clones automatically from large-scale software. However, it is still hard to find harmful code clones to improve maintainability because there are many code clones that should remain. Thus, to help find harmful code clones, we propose a code clone visualization method and a metrics application on the visualized information. Our method enables the location of harmful code clones diffused in a software system. We apply our method to three open source software programs and visualize their code clone information.", "num_citations": "17\n", "authors": ["749"]}
{"title": "A topological analysis of communication channels for knowledge sharing in contemporary GitHub projects\n", "abstract": " With over 28 million developers, success of the GitHub collaborative platform is highlighted through an abundance of communication channels among contemporary software projects. Knowledge is broken into two forms and its sharing (through communication channels) can be described as externalization or combination by the SECI model. Such platforms have revolutionized the way developers work, introducing new channels to share knowledge in the form of pull requests, issues and wikis. It is unclear how these channels capture and share knowledge. In this research, our goal is to analyze these communication channels in GitHub. First, using the SECI model, we are able to map how knowledge is shared through the communication channels. Then in a large-scale topology analysis of seven library package projects (i.e., involving over 70 thousand projects), we extracted insights of the different communication\u00a0\u2026", "num_citations": "11\n", "authors": ["749"]}
{"title": "Extracting insights from the topology of the javascript package ecosystem\n", "abstract": " Software ecosystems have had a tremendous impact on computing and society, capturing the attention of businesses, researchers, and policy makers alike. Massive ecosystems like the JavaScript node package manager (npm) is evidence of how packages are readily available for use by software projects. Due to its high-dimension and complex properties, software ecosystem analysis has been limited. In this paper, we leverage topological methods in visualize the high-dimensional datasets from a software ecosystem. Topological Data Analysis (TDA) is an emerging technique to analyze high-dimensional datasets, which enables us to study the shape of data. We generate the npm software ecosystem topology to uncover insights and extract patterns of existing libraries by studying its localities. Our real world example reveals many interesting insights and patterns that describes the shape of a software ecosystem.", "num_citations": "11\n", "authors": ["749"]}
{"title": "Code-based Vulnerability Detection in Node. js Applications: How far are we?\n", "abstract": " With one of the largest available collection of reusable packages, the JavaScript runtime environment Node. js is one of the most popular programming application. With recent work showing evidence that known vulnerabilities are prevalent in both open source and industrial software, we propose and implement a viable code-based vulnerability detection tool for Node. js applications. Our case study lists the challenges encountered while implementing our Node. js vulnerable code detector.", "num_citations": "9\n", "authors": ["749"]}
{"title": "Analysis of bug fixing processes using program slicing metrics\n", "abstract": " This paper is a report of a feasibility study into an alternative assessment of software processes at the micro-level. Using the novel approach of applying program slicing metrics to identify bug characteristics, the research studied relationships between bug characteristics and their bug fixing processes. The results suggested that specific characteristics such as cyclomatic complexity may relate to how long it takes to fix a bug. Results serve as a proof of concept and a starting point for this proposed assessment methodology. Future refinement of the metrics and much larger sample data is needed. This research is an initial step in the development of assessment tools to assist with Software Process Improvement.", "num_citations": "8\n", "authors": ["749"]}
{"title": "Human capital in software engineering: A systematic mapping of reconceptualized human aspect studies\n", "abstract": " The human capital invested into software development plays a vital role in the success of any software project. By human capital, we do not mean the individuals themselves, but involves the range of knowledge and skills (i.e., human aspects) invested to create value during development. However, there is still no consensus on how these broad terms of human aspects relate to the health of a project. In this study, we reconceptualize human aspects of software engineering (SE) into a framework (i.e., SE human capital). The study presents a systematic mapping to survey and classify existing human aspect studies into four dimensions of the framework: capacity, deployment, development, and know-how (based on the Global Human Capital Index). From premium SE publishing venues (five journal articles and four conferences), we extract 2,698 hits of papers published between 2013 to 2017. Using a search criteria, we then narrow our results to 340 papers. Finally, we use inclusion and exclusion criteria to manually select 78 papers (49 quantitative and 29 qualitative studies). Using research questions, we uncover related topics, theories and data origins. The key outcome of this paper is a set of indicators for SE human capital. This work is towards the creation of a SE Human Capital Index (SE-HCI) to capture and rank human aspects, with the potential to assess progress within projects, and point to opportunities for cross-project learning and exchange across software projects.", "num_citations": "5\n", "authors": ["749"]}
{"title": "Software team member configurations: A study of team effectiveness in moodle\n", "abstract": " Many open source projects organize teams to collaboratively manage their software development activities (i.e. issue resolution processes). Therefore good configurations of software development teams can be an important factor, as effective allocation and completion of tasks may result in a more effective activity (i.e. changing configurations after an issue is reopened). To validate this assumption, we present an exploratory study on software team member configuration when resolving issues. We mine the JIRA issue tracking system to assess whether different team member configurations are quicker to resolve issues after being reopened. In a case study of Moodle, our results confirm that the combinations of team members in different roles correlate with reopened issues and the changing of team members is found to resolve those reopened issues. Moreover, the study shows that the issue type is an important\u00a0\u2026", "num_citations": "3\n", "authors": ["749"]}
{"title": "Visualizing the Usage of Pythonic Idioms over Time: A Case Study of the with open Idiom\n", "abstract": " Veterans within the Python community claim that the usage of Pythonic idiomatic writing style is usually preferred. Because of its conciseness and ease of understanding, the idiomatic code tends to be more efficient and less error-prone code. With the growth of Python developers outside the Python community, it is not certain to what extent how Python idiomatic code is used in real software projects, especially if there are consequences. In this paper, our aim is to understand when and how developers start to use idioms in their software projects. Specifically, we propose a technique to visualize and understand the usage of the with open Pythonic idiom, one of the popular idioms. Two visualizations are proposed: (1) a visualization of evolution of non-idiomatic and idiomatic style of writing in four Python software projects over time and (2) a visualization to show the amount of appearing and disappearing idioms by\u00a0\u2026", "num_citations": "3\n", "authors": ["749"]}
{"title": "Understanding shared links and their intentions to meet information needs in modern code review\n", "abstract": " Code reviews serve as a quality assurance activity for software teams. Especially for Modern Code Review, sharing a link during a review discussion serves as an effective awareness mechanism where \u201cCode reviews are good FYIs [for your information].\u201d. Although prior work has explored link sharing and the information needs of a code review, the extent to which links are used to properly conduct a review is unknown. In this study, we performed a mixed-method approach to investigate the practice of link sharing and their intentions. First, through a quantitative study of the OpenStack and Qt projects, we identify 19,268 reviews that have 39,686 links to explore the extent to which the links are shared, and analyze a correlation between link sharing and review time. Then in a qualitative study, we manually analyze 1,378 links to understand the role and usefulness of link sharing. Results indicate that internal\u00a0\u2026", "num_citations": "2\n", "authors": ["749"]}
{"title": "Can we benchmark Code Review studies? A systematic mapping study of methodology, dataset, and metric\n", "abstract": " Context:Code Review (CR) is the cornerstone for software quality assurance and a crucial practice for software development. As CR research matures, it can be difficult to keep track of the best practices and state-of-the-art in methodology, dataset, and metric.Objective:This paper investigates the potential of benchmarking by collecting methodology, dataset, and metric of CR studies.Methods:A systematic mapping study was conducted. A total of 112 studies from 19,847 papers published in high-impact venues between the years 2011 and 2019 were selected and analyzed.Results:First, we find that empirical evaluation is the most common methodology (65% of papers), with solution and experience being the least common methodology. Second, we highlight 50% of papers that use the quantitative method or mixed-method have the potential for replicability. Third, we identify 457 metrics that are grouped into sixteen\u00a0\u2026", "num_citations": "2\n", "authors": ["749"]}
{"title": "Newcomer candidate: Characterizing contributions of a novice developer to github\n", "abstract": " To attract, onboard, and retain any newcomer in Open Source Software (OSS) projects is vital to their livelihood. Recent studies conclude that OSS projects risk failure due to abandonment and poor participation of newcomers. Evidence suggests more new users are joining GitHub, however, the extent to which they contribute to OSS projects is unknown. In this study, we coin the term \u2018newcomer candidate\u2019 to describe new users to the GitHub platform. Our objective is to track and characterize their initial contributions. As a preliminary survey, we collected 208 newcomer candidate contributions in GitHub. Using this dataset, we then plan to track their contributions to reveal insights. We will use a mixed-methods approach, i.e., quantitative and qualitative, to identify whether or not newcomer candidates practice social coding, the kinds of their contributions, projects they target, and the proportion that they eventually\u00a0\u2026", "num_citations": "2\n", "authors": ["749"]}
{"title": "Same File, Different Changes: The Potential of Meta-Maintenance on GitHub\n", "abstract": " Online collaboration platforms such as GitHub have provided software developers with the ability to easily reuse and share code between repositories. With clone-and-own and forking becoming prevalent, maintaining these shared files is important, especially for keeping the most up-to-date version of reused code. Different to related work, we propose the concept of meta-maintenance\u2014i.e., tracking how the same files evolve in different repositories with the aim to provide useful maintenance opportunities to those files. We conduct an exploratory study by analyzing repositories from seven different programming languages to explore the potential of meta-maintenance. Our results indicate that a majority of active repositories on GitHub contains at least one file which is also present in another repository, and that a significant minority of these files are maintained differently in the different repositories which contain them\u00a0\u2026", "num_citations": "1\n", "authors": ["749"]}
{"title": "GitHub Discussions: An Exploratory Study of Early Adoption\n", "abstract": " Discussions is a new feature of GitHub for asking questions or discussing topics outside of specific Issues or Pull Requests. Before being available to all projects in December 2020, it had been tested on selected open source software projects. To understand how developers use this novel feature, how they perceive it, and how it impacts the development processes, we conducted a mixed-methods study based on early adopters of GitHub discussions from January until July 2020. We found that: (1) errors, unexpected behavior, and code reviews are prevalent discussion categories; (2) there is a positive relationship between project member involvement and discussion frequency; (3) developers consider GitHub Discussions useful but face the problem of topic duplication between Discussions and Issues; (4) Discussions play a crucial role in advancing the development of projects; and (5) positive sentiment in Discussions is more frequent than in Stack Overflow posts. Our findings are a first step towards data-informed guidance for using GitHub Discussions, opening up avenues for future work on this novel communication channel.", "num_citations": "1\n", "authors": ["749"]}
{"title": "Teddy: Automatic Recommendation of Pythonic Idiom Usage For Pull-Based Software Projects\n", "abstract": " Pythonic code is idiomatic code that follows guiding principles and practices within the Python community. Offering performance and readability benefits, Pythonic code is claimed to be widely adopted by experienced Python developers, but can be a learning curve to novice programmers. To aid with Pythonic learning, we create an automated tool, called Teddy, that can help checking the Pythonic idiom usage. The tool offers a prevention mode with Just-In-Time analysis to recommend the use of Pythonic idiom during code review and a detection mode with historical analysis to run a thorough scan of idiomatic and non-idiomatic code. In this paper, we first describe our tool and an evaluation of its performance. Furthermore, we present a case study that demonstrates how to use Teddy in a real-life scenario on an Open Source project. An evaluation shows that Teddy has high precision for detecting Pythonic idiom\u00a0\u2026", "num_citations": "1\n", "authors": ["749"]}
{"title": "Kode_Stylers: Author Identification through Naturalness of Code: An Ensemble Approach.\n", "abstract": " Authorship identification plays an important role in detecting undesirable deception of others\u2019 content misuse or exposing the owners of some anonymous hurtful content. The Authorship Identification of SOurce COde (AI-SOCO) competition was held to investigate this task. Our team, namely Kode_Stylers, participated in the competition and used the naturalness of code as the key to our solution. In this working note, we (i) present methods to obtain features such as tokenization, N-gram TF-IDF, warning messages, and coding styles,(ii) implement our framework using Random Forest and Transformer to classify authors through our features, and (iii) apply an ensemble approach to increase the performance of our solutions. The results suggest that the authorship can be identified through the features extracted from source code and selected classifiers with up to an accuracy of 0.82, while the ensemble model outperforms any single model.", "num_citations": "1\n", "authors": ["749"]}
{"title": "How Do Contributors Impact Code Naturalness? An Exploratory Study of 50 Python Projects\n", "abstract": " Recent studies have shown how software is comparable to natural languages, meaning that source code is highly repetitive and predictable. Other studies have shown the naturalness as indicators for code quality (i.e., buggy code). With the rise of social coding and the popularity of open source projects, the software is now being built with contributions that come from contributors from diverse backgrounds. From this social contribution perspective, we explore how contributors impact code naturalness. In detail, our exploratory study investigators whether the developers' history of programming language experience affects the code naturalness. Calculating the code naturalness of 678 contributors from 50 open-source python projects, we analyze how two aspects of contributor activities impact the code naturalness: (a) the number of contributors in a software project, (b) diversity of programming language\u00a0\u2026", "num_citations": "1\n", "authors": ["749"]}
{"title": "The Health and Wealth of OSS Projects: Evidence from Community Activities and Product Evolution\n", "abstract": " Background: Understanding the condition of OSS projects is important to analyze features and predict the future of projects. In the field of demography and economics, health and wealth are considered to understand the condition of a country. Aim: In this paper, we apply this framework to OSS projects to understand the communities and the evolution of OSS projects from the perspectives of health and wealth. Method: We define two measures of Workforce (WF) and Gross Product Pull Requests (GPPR). We analyze OSS projects in GitHub and investigate three typical cases. Results: We find that wealthy projects attract and rely on the casual workforce. Less wealthy projects may require additional efforts from their more experienced contributors. Conclusions: This paper presents an approach to assess the relationship between health and wealth of OSS projects. An interactive demo of our analysis is available at goo.gl/Ig6NTR.", "num_citations": "1\n", "authors": ["749"]}