{"title": "From the cathedral to the bazaar: An empirical study of the lifecycle of volunteer community projects\n", "abstract": " Some free software and open source projects have been extremely successful in the past. The success of a project is often related to the number of developers it can attract: a larger community of developers (the \u2018bazaar\u2019) identifies and corrects more software defects and adds more features via a peer-review process. In this paper two free software projects (Wine and Arla) are empirically explored in order to characterize their software lifecycle, development processes and communities. Both the projects show a phase where the number of active developers and the actual work performed on the system is constant, or does not grow: we argued that this phase corresponds to the one termed \u2018cathedral\u2019 in the literature. One of the two projects (Wine) shows also a second phase: a sudden growing amount of developers corresponds to a similar growing output produced: we termed this as the \u2018bazaar\u2019 phase, and\u00a0\u2026", "num_citations": "102\n", "authors": ["127"]}
{"title": "Models for the evolution of OS projects\n", "abstract": " Software evolution and maintenance is largely based on data gathered through years of experience: understanding and improving software is often a matter of how much data is available. Open source software offers the opportunity to analyze closely all the phases in the evolution of a project. What's more, data regarding its evolution is generally available for inspections. Based on simply code analyses, lots of questions about its efficiencies can't be resolved. It would be necessary to study the process from the inside, understanding who or what drove what improvement and so on. Still a quantitative analysis gives several insights about how much code is created and evolved by developers. This study takes a sample of 12 open source projects and gives some statistics to analyze their evolution. The purpose is here to compare what is commonly know in software evolution in traditional environments, and what\u00a0\u2026", "num_citations": "84\n", "authors": ["127"]}
{"title": "Agent\u2010based simulation of open source evolution\n", "abstract": " We present an agent\u2010based simulation model developed to study how size, complexity and effort relate to each other in the development of open source software (OSS). In the model, many developer agents generate, extend, and re\u2010factor code modules independently and in parallel. This accords with empirical observations of OSS development. To our knowledge, this is the first model of OSS evolution that includes the complexity of software modules as a limiting factor in productivity, the fitness of the software to its requirements, and the motivation of developers. Validation of the model was done by comparing the simulated results against four measures of software evolution (system size, proportion of highly complex modules, level of complexity control work, and distribution of changes) for four large OSS systems. The simulated results resembled the observed data, except for system size: three of the OSS\u00a0\u2026", "num_citations": "67\n", "authors": ["127"]}
{"title": "Structural evolution of an open source system: A case study\n", "abstract": " Software evolution empirical studies are made possible only when data is available and easily collectable. Open source software provides a good opportunity for observing software products in various phases of their evolution, growth and maturity. One of the aspects that have not been analyzed yet through empirical studies is the relation that exists between code components growth and the evolving code structure. In this paper, we look at the growth of code elements by measuring the total number of files per release and also by visualizing the folder structure as a tree. Both, the number of files and the shape of the folder tree structure offer proxies to study the evolving complexity of the system. In this study, a number of hypotheses about the evolutionary patterns in the size of files and folders, in the folder tree structure, reflecting common assumptions on software engineering and open source are tested against\u00a0\u2026", "num_citations": "65\n", "authors": ["127"]}
{"title": "An empirical study of the evolution of an agile-developed software system\n", "abstract": " We have analyzed evolution patterns over two and a half years for a system developed using extreme programming. We find that the system shows a smooth pattern of growth overall, that (McCabe) code complexity is low, and that the relative amount of complexity control work (e.g. refactoring) is higher than in other systems we have studied. To interpret these results, we have drawn on qualitative data including the results of an observational study, records of progress and productivity, and comments on our findings from team members.", "num_citations": "57\n", "authors": ["127"]}
{"title": "Studying the evolution of open source systems at different levels of granularity: Two case studies\n", "abstract": " This work presents a study of several evolutionary attributes of two open source software systems: the distributed file system Arla and the stable branch of the Web browser Mozilla. The attributes (size, activity rate and complexity) are visualized over releases using measures at various levels of granularity: folders, files and procedures. A number of hypotheses about the evolutionary behaviour of the systems are considered and, in general, supported by the data from the 2 systems.", "num_citations": "47\n", "authors": ["127"]}
{"title": "The evolution of source folder structure in actively evolved open source systems\n", "abstract": " Predicting when and how a software system evolves is one of the most fascinating challenges of software engineering. No matter what approach one is using to study such evolution, empirical studies, including observations of systems used in the real world, and of their processes, are needed in order to define correlations, find recurring patterns, and eventually predict how systems are likely to evolve. In the empirical study presented in this paper, we take 25 software systems released as open source, and observe their evolution. Our focus is not only on how much systems grow in size, but rather on how code structure is adapted and gets modified over time and releases. The goal here is to recognize recurring patterns and practices used in evolving long-lived real world software systems. In our study we find three dominant patterns of code structure evolution of open source systems: horizontal expansion, vertical\u00a0\u2026", "num_citations": "40\n", "authors": ["127"]}
{"title": "Identifying exogenous drivers and evolutionary stages in FLOSS projects\n", "abstract": " The success of a Free/Libre/Open Source Software (FLOSS) project has been evaluated in the past through the number of commits made to its configuration management system, number of developers and number of users. Most studies, based on a popular FLOSS repository (SourceForge), have concluded that the vast majority of projects are failures.This study\u2019s empirical results confirm and expand conclusions from an earlier and more limited work. Not only do projects from different repositories display different process and product characteristics, but a more general pattern can be observed. Projects may be considered as early inceptors in highly visible repositories, or as established projects within desktop-wide projects, or finally as structured parts of FLOSS distributions. These three possibilities are formalized into a framework of transitions between repositories.The framework developed here provides a wider\u00a0\u2026", "num_citations": "38\n", "authors": ["127"]}
{"title": "A study of open source software evolution data using qualitative simulation\n", "abstract": " Simulation modelling of growth trends and other empirical data from software systems can reveal the main drivers of software evolution and help improve understanding and management of the software evolution phenomenon. This article reports on the application of qualitative abstraction techniques to data from 25 open source software (OSS) systems. After justifying the use of qualitative simulation techniques for the software process domain, the article presents an analysis of the support from OSS\u2010derived data to previously developed qualitative simulation models, which were inspired by observations from the domain of proprietary systems. The analysis involved comparison of model output and qualitatively abstracted growth trends. The analysis also involved the comparison of the transitions in trends of functional size and complexity to those predicted by the models in a sub\u2010set of 21 systems for which\u00a0\u2026", "num_citations": "36\n", "authors": ["127"]}
{"title": "Coordination and productivity issues in free software: The role of brooks' law\n", "abstract": " Proponents of the free software paradigm have argued that some of the most established software engineering principles do not fully apply when considered in an open, distributed approach found in free software development. The objective of this research is to empirically examine the Brooks' law in a free software context. The principle is separated out into its two primary premises: the first is based on a developer's ability to become productive when joining a new team; the second premise relates to the quality of coordination as the team grows. Three large projects are studied for this purpose: KDE, Plone and Evince. Based on empirical evidence, the paper provides two main contributions: based on the first premise of Brooks' law, it claims that coordination costs increase only in a very specific phase for free software projects. After that, these costs become quasi-constant. Secondly, it shows that a ramp up period\u00a0\u2026", "num_citations": "34\n", "authors": ["127"]}
{"title": "A large study on the effect of code obfuscation on the quality of java code\n", "abstract": " Context:\u00a0Obfuscation is a common technique used to protect software against malicious reverse engineering. Obfuscators manipulate the source code to make it harder to analyze and more difficult to understand for the attacker. Although different obfuscation algorithms and implementations are available, they have never been directly compared in a large scale study.                                        Aim:\u00a0This paper aims at evaluating and quantifying the effect of several different obfuscation implementations (both open source and commercial), to help developers and project managers to decide which algorithms to use.                                        Method:\u00a0In this study we applied 44 obfuscations to 18 subject applications covering a total of 4 millions lines of code. The effectiveness of these source code obfuscations has been measured using 10 code metrics, considering modularity, size and complexity of code\u00a0\u2026", "num_citations": "33\n", "authors": ["127"]}
{"title": "Effort estimation of FLOSS projects: a study of the Linux kernel\n", "abstract": " Empirical research on Free/Libre/Open Source Software (FLOSS) has shown that developers tend to cluster around two main roles: \u201ccore\u201d contributors differ from \u201cperipheral\u201d developers in terms of a larger number of responsibilities and a higher productivity pattern. A further, cross-cutting characterization of developers could be achieved by associating developers with \u201ctime slots\u201d, and different patterns of activity and effort could be associated to such slots. Such analysis, if replicated, could be used not only to compare different FLOSS communities, and to evaluate their stability and maturity, but also to determine within projects, how the effort is distributed in a given period, and to estimate future needs with respect to key points in the software life-cycle (e.g., major releases). This study analyses the activity patterns within the Linux kernel project, at first focusing on the overall distribution of effort and activity\u00a0\u2026", "num_citations": "28\n", "authors": ["127"]}
{"title": "Matching demand and offer in on-line provision: A longitudinal study of monster. com\n", "abstract": " When considering the jobs market, changes or recurring trends for skilled employees expressed by employers' needs have a tremendous impact on the evolution of website content. On-line jobs sites adverts, academic institutions and professional development \u201cstandard bodies\u201d all share those needs as their common driver for contents evolution. This paper aims, on one hand, to discuss and to analyse how current needs and requirements (\u201cdemand\u201d) of IT skills in the UK job market drive the contents of different types of websites, in turn analysing whether this demand changes and how. On the other hand, it is studied what the UK higher education institutions have to offer to fulfill this demand. The results found analysing the evolution of the largest on-line job centre (www.monster.com), and the websites of selected UK academic institutions, demonstrate that often what is requested by UK industries is not clearly\u00a0\u2026", "num_citations": "28\n", "authors": ["127"]}
{"title": "Exploring the relationship between cumulative change and complexity in an open source system\n", "abstract": " This paper explores the relationship between cumulative change and complexity in an evolving open source system. The study involves measurements at the function and file level. In order to measure cumulative change, the approach used a metric termed release-touches, which counts the number of releases for which a given file has been modified. Based on the value of this metric, we ranked the files and used the ranking in order to identity two groups, the more stable and the less stable parts of the source code. Complexity was measured using two derivatives of the McCabe index. Histograms and distributions were visually and statistically analyzed. The results empirically suggest that at the file level there are correlations between high cumulative change, large size and high complexity. This paper provides an approach for identifying which functions need to be refactored first if one wishes to reduce the\u00a0\u2026", "num_citations": "27\n", "authors": ["127"]}
{"title": "Evolutionary success of open source software: An investigation into exogenous drivers\n", "abstract": " The \u201csuccess\u201d of a Free/Libre/Open Source Software (FLOSS) project has often been evaluated through the number of commits made to its configuration management system, number of developers and number of users. Based on Source- Forge, most studies have concluded that the vast majority of projects are failures. This paper argues that the relative success of a FLOSS project can depend also on the chosen forge and distribution. Given a random sample of 50 projects contained within a popular FLOSS forge (Debian, which is the basis of the successful Debian distribution), we compare these with a similar sample from SourceForge, using product and process metrics, such as size achieved and number of developers involved. The results show firstly that, depending on the forge of FLOSS projects, researchers can draw different conclusions regarding what constitutes a successful FLOSS project. Secondly, the projects included in the Debian distribution benefit, on average, from more evolutionary activity and more developers than the comparable projects on SourceForge. Finally, the Debian projects start to benefit from more activity and more developers from the point at which they join this distribution.", "num_citations": "23\n", "authors": ["127"]}
{"title": "Structural complexity and decay in floss systems: An inter-repository study\n", "abstract": " Past software engineering literature has firmly established that software architectures and the associated code decay over time. Architectural decay is, potentially, a major issue in free/libre/open source software (FLOSS) projects, since developers sporadically joining FLOSS projects do not always have a clear understanding of the underlying architecture, and may break the overall conceptual structure by several small changes to the code base. This paper investigates whether the structure of a FLOSS system and its decay can also be influenced by the repository in which it is retained: specifically, two FLOSS repositories are studied to understand whether the complexity of the software structure in the sampled projects is comparable, or one repository hosts more complex systems than the other. It is also studied whether the effort to counteract this complexity is dependent on the repository, and the governance it\u00a0\u2026", "num_citations": "20\n", "authors": ["127"]}
{"title": "Coupling patterns in the effective reuse of open source software\n", "abstract": " Albeit practical reuse approaches have been established in commercial environments, the open source software (OSS) communities have not yet taken full advantage of the reuse mechanism. Many OSS projects, sharing the same application domain and topic, duplicate effort and code, without fully leveraging the vast amounts of available code. In order to fill these gaps, this study focuses on source code folders of OSS projects: the objective is to investigate their potential as shareable and small-grained reusable software components in other OSS projects.", "num_citations": "20\n", "authors": ["127"]}
{"title": "Understanding the interplay between the logical and structural coupling of software classes\n", "abstract": " During the lifetime of object-Oriented (OO) software systems, new classes are added to increase functionality, also increasing the inter-dependencies between classes. Logical coupling depicts the change dependencies between classes, while structural coupling measures source code dependencies induced via the system architecture. The relationship or dependency between logical and structural coupling have been debated in the past, but no large study has confirmed yet their interplay.In this study, we have analysed 79 open-source software projects of different sizes to investigate the interplay between the two types of coupling. First, we quantified the overlapping or intersection of structural and logical class dependencies. Second, we statistically computed the correlation between the strengths of logical and structural dependencies. Third, we propose a simple technique to determine the stability of OO software\u00a0\u2026", "num_citations": "17\n", "authors": ["127"]}
{"title": "Software reuse in open source a case study\n", "abstract": " A promising way to support software reuse is based on Component-Based Software Development (CBSD). Open Source Software (OSS) products are increasingly available that can be freely used in product development. However, OSS communities still face several challenges before taking full advantage of the \u201creuse mechanism\u201d: many OSS projects duplicate effort, for instance when many projects implement a similar system in the same application domain and in the same topic. One successful counter-example is the FFmpeg multimedia project; several of its components are widely and consistently reused in other OSS projects. Documented is the evolutionary history of the various libraries of components within the FFmpeg project, which presently are reused in more than 140 OSS projects. Most use them as black-box components; although a number of OSS projects keep a localized copy in their repositories\u00a0\u2026", "num_citations": "16\n", "authors": ["127"]}
{"title": "User generated (web) content: trash or treasure\n", "abstract": " It has been claimed that the advent of user-generated content has reshaped the way people approached all sorts of content realization projects, being multimedia (YouTube, DeviantArt, etc.), knowledge (Wikipedia, blogs), to software in general, when based on a more general Open Source model.", "num_citations": "16\n", "authors": ["127"]}
{"title": "Identifying and improving reusability based on coupling patterns\n", "abstract": " Open Source Software (OSS) communities have not yet taken full advantage of reuse mechanisms. Typically many OSS projects which share the same application domain and topic, duplicate effort and code, without fully leveraging the vast amounts of available code.               This study proposes the empirical evaluation of source code folders of OSS projects in order to determine their actual internal reuse and their potential as shareable, fine-grained and externally reusable software components by future projects.               This paper empirically analyzes four OSS systems, identifies which components (in the form of folders) are currently being reused internally and studies their coupling characteristics. Stable components (i.e., those which act as service providers rather than service consumers) are shown to be more likely to be reusable. As a means of supporting replication of these successful instances of\u00a0\u2026", "num_citations": "15\n", "authors": ["127"]}
{"title": "Reassessing Brooks\u2019 law for the free software community\n", "abstract": " Proponents of Free Software have argued that some of the most established software engineering principles do not fully apply when considered in an open, distributed approach. Among these principles, \u201cBrooks\u2019 Law\u201d has been questioned in the Free Software context: large teams of developers, contrary to the law, will not need an increasingly growing number of communication channels. As advocates claim, this is due to the internal characteristics of the Free Software process: the high modularity of the code helps developers to work on comparted sections, without the need to coordinate with all other contriutors.               This paper examines Brooks\u2019 Law in a Free Software context, and it studies the interaction of contributors to a large Free Software project, KDE. The network of interactions is analyzed and a summary term, the \u201ccompaction\u201d, is dynamically evaluated to test how the coordination mechanism\u00a0\u2026", "num_citations": "14\n", "authors": ["127"]}
{"title": "Users and developers: an agent-based simulation of open source software evolution\n", "abstract": " We present an agent-based simulation model of open source software (OSS). To our knowledge, this is the first model of OSS evolution that includes four significant factors: productivity limited by the complexity of software modules, the software\u2019s fitness for purpose, the motivation of developers, and the role of users in defining requirements. The model was evaluated by comparing the simulated results against four measures of software evolution (system size, proportion of highly complex modules, level of complexity control work, and distribution of changes) for four large OSS systems. The simulated results resembled all the observed data, including alternating periods of growth and stagnation. The fidelity of the model suggests that the factors included here have significant effects on the evolution of OSS systems.", "num_citations": "13\n", "authors": ["127"]}
{"title": "An empirical study on the interplay between semantic coupling and co-change of software classes\n", "abstract": " Software systems continuously evolve to accommodate new features and interoperability relationships between artifacts point to increasingly relevant software change impacts. During maintenance, developers must ensure that related entities are updated to be consistent with these changes. Studies in the static change impact analysis domain have identified that a combination of source code and lexical information outperforms using each one when adopted independently. However, the extraction of lexical information and the measure of how loosely or closely related two software artifacts are, considering the semantic information embedded in their comments and identifiers has been carried out using somewhat complex information retrieval (IR) techniques. The interplay between software semantic and change relationship strengths has also not been extensively studied. This work aims to fill both gaps by\u00a0\u2026", "num_citations": "12\n", "authors": ["127"]}
{"title": "Software engineering in practice: Design and architectures of floss systems\n", "abstract": " Free/Libre/Open Source Software (FLOSS) practitioners and developers are typically also users of their own systems: as a result, traditional software engineering (SE) processes (e.g., the requirements and design phases), take less time to articulate and negotiate among FLOSS developers. Design and requirements are kept more as informal knowledge, rather than formally described and assessed. This paper attempts to recover the SE concepts of software design and architectures from three FLOSS case studies, sharing the same application domain (i.e., Instant Messaging). Its first objective is to determine whether a common architecture emerges from the three systems, which can be used as shared knowledge for future applications. The second objective is to determine whether these architectures evolve or decay during the evolution of these systems. The results of this study are encouraging: albeit no\u00a0\u2026", "num_citations": "12\n", "authors": ["127"]}
{"title": "A model to predict anti-regressive effort in open source software\n", "abstract": " Accumulated changes on a software system are not uniformly distributed: some elements are changed more often than others. For optimal impact, the limited time and effort for complexity control, called anti-regressive work, should be applied to the elements of the system which are frequently changed and are complex. Based on this, we propose a maintenance guidance model (MGM) which is tested against real-world data. MGM takes into account several dimensions of complexity: size, structural complexity and coupling. Results show that maintainers of the eight open source systems studied tend, in general, to prioritize their anti-regressive work in line with the predictions given by our MGM, even though, divergences also exist. MGM offers a history-based alternative to existing approaches to the identification of elements for anti-regressive work, most of which use static code characteristics only.", "num_citations": "12\n", "authors": ["127"]}
{"title": "Code defactoring: Evaluating the effectiveness of java obfuscations\n", "abstract": " Obfuscation is a very common protection against reverse engineering attacks: it modifies a program structure to make it harder for the adversary to analyse and understand it. Conceptually, obfuscation is the opposite of refactoring: the code should be more complex to understand, bloated, and with excessive characteristics from the design point of view. This paper aims at evaluating the code complexity introduced by different obfuscation algorithms by using software engineering metrics. Using structural metrics, this paper illustrates how the various types of obfuscation algorithms perform in terms of OO attributes that should be kept low in refactoring. Results show that the majority of the selected algorithms produce no changes in the structural attributes or the average complexity, but they produce more ``dead'' code. We argue that this could not represent the optimal way to protect the code: when protecting against\u00a0\u2026", "num_citations": "11\n", "authors": ["127"]}
{"title": "Quality factors and coding standards\u2013a comparison between open source forges\n", "abstract": " Enforcing adherence to standards in software development in order to produce high quality software artefacts has long been recognised as best practice in traditional software engineering. In a distributed heterogeneous development environment such those found within the Open Source paradigm, coding standards are informally shared and adhered to by communities of loosely coupled developers. Following these standards could potentially lead to higher quality software.This paper reports on the empirical analysis of two major forges where OSS projects are hosted. The first one, the KDE forge, provides a set of guidelines and coding standards in the form of a coding style that developers may conform to when producing the code source artefacts. The second studied forge, SourceForge, imposes no formal coding standards on developers. A sample of projects from these two forges has been analysed to detect\u00a0\u2026", "num_citations": "11\n", "authors": ["127"]}
{"title": "Bridging the gap between agile and free software approaches: The impact of sprinting\n", "abstract": " Agile sprints are short events where a small team collocates in order to work on particular aspects of the overall project for a short period of time. Sprinting is a process that has been observed also in Free Software projects: these two paradigms, sharing common principles and values have shown several commonalities of practice. This article evaluates the impact of sprinting on a Free Software project through the analysis of code repository logs: sprints from two Free Software projects (Plone and KDE PIM) are assessed and two hypotheses are formulated: do sprints increase productivity? Are Free Software projects more productive after sprints compared with before? The primary contribution of this article is to show how sprinting creates a large increase in productivity both during the event, and immediately after the event itself: this argues for more in-depth studies focussing on the nature of sprinting.", "num_citations": "10\n", "authors": ["127"]}
{"title": "Detecting agility of open source projects through developer engagement\n", "abstract": " The principles behind the agile development methods and common practise within the Open Source community are vastly different. In recent years there has been a rise of interest in these, in order to detect and inform on areas of compatible shared practises. This paper argues that it is possible to quantify the level of agility displayed by Open Source projects. An indicator of agility, the Mean Developer Engagement (MDE) metric is introduced and tested through the analysis of public project data. Projects sampled from two repositories (KDE and SourceForge) are studied and a hypothesis is formulated: projects from the two samples display a similar level of MDE.               This paper provides two main contributions: first, the MDE metric is shown to vary significantly between the KDE and SourceForge projects. Second, by combining MDE with a project\u2019s lifespan, it is also shown that SourceForge projects have\u00a0\u2026", "num_citations": "10\n", "authors": ["127"]}
{"title": "Semantic coupling between classes: Corpora or identifiers?\n", "abstract": " Context: Conceptual coupling is a measure of how loosely or closely related two software artifacts are, by considering the semantic information embedded in the comments and identifiers. This type of coupling is typically evaluated using the semantic information from source code into a words corpus. The extraction of words corpora can be lengthy, especially when systems are large and many classes are involved.Goal: This study investigates whether using only the class identifiers (eg, the class names) can be used to evaluate the conceptual coupling between classes, as opposed to the words corpora of the entire classes.Method: In this study, we analyze two Java systems and extract the conceptual coupling between pairs of classes, using (i) a corpus-based approach; and (ii) two identifier-based tools.Results: Our results show that measuring the semantic similarity between classes using (only) their identifiers is\u00a0\u2026", "num_citations": "9\n", "authors": ["127"]}
{"title": "Undergraduate research opportunities in OSS\n", "abstract": " Using Open Source Software (OSS) in undergraduate teaching in universities is now commonplace. Students use OSS applications and systems in their courses on programming, operating systems, DBMS, web development to name but a few. Studying OSS projects from both a product and a process view also forms part of the software engineering curriculum at various universities. Many students have taken part in OSS projects as well as developers.               At the University of Lincoln, under the Undergraduate Research Opportunities Scheme (UROS), undergraduate student researchers have the chance to work over the summer embedded within an existing research centre on a UROS project. Here two such projects within the Centre for Research in Open Source Software (CROSS) are described: Collaborative Development for the XO Laptop (CODEX) and Software Modularity in Open Source Software\u00a0\u2026", "num_citations": "8\n", "authors": ["127"]}
{"title": "Architectural studies of games engines\u2014The quake series\n", "abstract": " The move of commercial companies to \"open-source\" their products presents challenges for both the proposing company and the wider open source (OS) communities. The former has to align their source code to the OS practices, while the latter has to cope with large amounts of closely-developed code. This paper aims to present relevant data and results from the analysis performed on the Quake family of OSS game engines, including findings and an initial interpretation of the data. This forms the basis for the architectural understanding necessary to design and develop improvements and new features to the studied game engines. The presented approach constitutes a useful resource for games developers who wish to contribute to the further evolution of these games engines; and it provides insights into how the Quake engine architecture has evolved in practice since it was released as an open source project.", "num_citations": "7\n", "authors": ["127"]}
{"title": "Change rate and complexity in software evolution\n", "abstract": " This paper deals with the problem of identifying which parts of the source code will benefit most from refactoring, that is, complexity reduction, and how this work should be prioritised for maximum impact on the evolvability of a system. Our approach ranks the files based on the value of a metric called release-touches, which simply counts the number of releases at which a given file has been changed. The metric enables us to split the code into two parts: the more stable and the less stable. The paper presents empirical data derived from the distributed file system Arla, an evolving Open Source System, with 62 public releases since 1998. The results indicate that the source files which are subject to the higher change rate include a large portion of highly complex functions. It is argued that refactoring of this less stable, more complex functions, is likely to have an impact on evolvability.", "num_citations": "7\n", "authors": ["127"]}
{"title": "Detecting Java software similarities by using different clustering techniques\n", "abstract": " BackgroundResearch on empirical software engineering has increasingly been conducted by analysing and measuring vast amounts of software systems. Hundreds, thousands and even millions of systems have been (and are) considered by researchers, and often within the same study, in order to test theories, demonstrate approaches or run prediction models. A much less investigated aspect is whether the collected metrics might be context-specific, or whether systems should be better analysed in clusters.ObjectiveThe objectives of this study are (i) to define a set of clustering techniques that might be used to group similar software systems, and (ii) to evaluate whether a suite of well-known object-oriented metrics is context-specific, and its values differ along the defined clusters.MethodWe group software systems based on three different clustering techniques, and we collect the values of the metrics suite in each\u00a0\u2026", "num_citations": "6\n", "authors": ["127"]}
{"title": "Managing hidden dependencies in oo software: a study based on open source projects\n", "abstract": " Dependency-based software change impact analysis is the domain concerned with estimating the sets of artifacts impacted by a change to a related artifact. Research has shown that analysing the various class dependency types independently will never completely reveal the impact sets. Therefore, dependency types are combined to improve the precision of estimated when compared to impact sets. Software classes can be linked in different ways; for instance semantically, if their meaning is somewhat related or, structurally, if one class depends on the services of other classes. 'Hidden' dependencies arise when two classes, linked structurally, do not share the same semantic namespace or when semantically dependent classes do not share a structural link. With the goal of revealing hidden dependencies during change impact analysis, we empirically investigated the relationship between structural and semantic\u00a0\u2026", "num_citations": "6\n", "authors": ["127"]}
{"title": "Improving comprehension and cooperation through code structure\n", "abstract": " Defining a relationship between a software system's architecture and the process' efforts is one of the most fascinating questions of software engineering. Apparently, when a system's architecture is complex, the process to improve and evolve it will be more difficult. We try to tackle this question from a different point of view: given an open source system, in all the phases of its evolution, we focus on both the aspects of software developers, and the obtained software product. More we observe one of the possible architectures of this system, based on the tree structure derived from source components. First conclusions show that some patterns of tree evolution are recognizable: some branches may appear more promising than other, and are extensively evolved, while other remains in the same status for all the life cycle. More, when the tree structure reaches some status, the process of joining as a core developer\u00a0\u2026", "num_citations": "6\n", "authors": ["127"]}
{"title": "An empirical analysis of source code metrics and smart contract resource consumption\n", "abstract": " A smart contract (SC) is a programme stored in the Ethereum blockchain by a contract\u2010creation transaction. SC developers deploy an instance of the SC and attempt to execute it in exchange for a fee, paid in Ethereum coins (Ether). If the computation needed for their execution turns out to be larger than the effort proposed by the developer (i.e., the gasLimit), their client instantiation will not be completed successfully. In this paper, we examine SCs from 11 Ethereum blockchain\u2010oriented software projects hosted on GitHub.com, and we evaluate the resources needed for their deployment (i.e., the gasUsed). For each of these contracts, we also extract a suite of object\u2010oriented metrics, to evaluate their structural characteristics. Our results show a statistically significant correlation between some of the object\u2010oriented (OO) metrics and the resources consumed on the Ethereum blockchain network when deploying SCs\u00a0\u2026", "num_citations": "5\n", "authors": ["127"]}
{"title": "The relevance of application domains in empirical findings\n", "abstract": " The term 'software ecosystem' refers to a collection of software systems that are related in some way. Researchers have been using different levels of aggregation to define an ecosystem: grouping them by a common named project (e.g., the Apache ecosystem); or considering all the projects contained in online repositories (e.g., the GoogleCode ecosystem). In this paper we propose a definition of ecosystem based on application domains: software systems are in the same ecosystem if they share the same application domain, as described by a similar technological scope, context or objective. As an example, all projects implementing networking capabilities to trade Bitcoin and other virtual currencies can be considered as part of the same \"cryp-tocurrency\" ecosystem. Utilising a sample of 100 Java software systems, we derive their application domains using the Latent Dirichlet Allocation (LDA) approach. We then evaluate a suite of object-oriented metrics per ecosystem, and test a null hypothesis: 'the OO metrics of all ecosystems come from the same population'. Our results show that the null hypothesis is rejected for most of the metrics chosen: the ecosystems that we extracted, based on application domains, show different structural properties. From the point of view of the interested stakeholders, this could mean that the health of a software system depends on domain-dependent factors, that could be common to the projects in the same domain-based ecosystem.", "num_citations": "5\n", "authors": ["127"]}
{"title": "A social-centred gamification approach to improve household water use efficiency\n", "abstract": " The research community is showing a growing interest in gamification and there are works showing the usefulness of gamification in different problem domains. Recently, a special interest has been given to the gamification design on systems addressing natural resource consumption issues such as to encourage efficient household water consumption. Despite the potential benefits, the gamification design method for such system is not conclusive. In this paper, we proposed a social-centred gamification approach to improve household water use efficiency. The approach firstly identified the water use related social network activities based upon existing popular social network activities. The approach then gamified each identified activity in terms of traditional instruments for improving water use efficiency and gamification rewards. The approach also used a set of indicators to explicitly detect and monitor both online\u00a0\u2026", "num_citations": "5\n", "authors": ["127"]}
{"title": "Towards an automation of the traceability of bugs from development logs: a study based on open source software\n", "abstract": " Context: Information and tracking of defects can be severely incomplete in almost every Open Source project, resulting in a reduced traceability of defects into the development logs (ie, version control commit logs). In particular, defect data often appears not in sync when considering what developers logged as their actions. Synchronizing or completing the missing data of the bug repositories, with the logs detailing the actions of developers, would benefit various branches of empirical software engineering research: prediction of software faults, software reliability, traceability, software quality, effort and cost estimation, bug prediction and bug fixing.Objective: To design a framework that automates the process of synchronizing and filling the gaps of the development logs and bug issue data for open source software projects.Method: We instantiate the framework with a sample of OSS projects from GitHub, and by\u00a0\u2026", "num_citations": "5\n", "authors": ["127"]}
{"title": "Engaging without Over-powering: a Case Study of a FLOSS project\n", "abstract": " The role of Open Source Software (OSS) in the e-learning business has become more and more fundamental in the last 10 years, as long as corporate and government organizations have developed their educational and training programs based on OSS out-of-the-box tools. This paper qualitatively documents the decision of the largest UK e-learning provider, the Open University, to adopt the Moodle e-learning system, and how it has been successfully deployed in its site after a multi-million investment. A further quantitative study also provides evidence of how a commercial stakeholder has been engaged with, and produced outputs for, the Moodle community. Lessons learned from this experience by the stakeholders include the crucial factors of contributing to the OSS community, and adapting to an evolving technology. It also becomes evident how commercial partners helped this OSS system to achieve\u00a0\u2026", "num_citations": "5\n", "authors": ["127"]}
{"title": "From\" community\" to\" commercial\" FLOSS: the case of Moodle\n", "abstract": " This paper documents the evolution of Moodle, an advanced Content Management System, and its transition from a purely volunteer-based project to one driven by commercial interests and stakeholders. The study of its evolution provides evidence of the sustainability of its process: increasing amounts of provided effort by developers correspond to similarly increasing produced outputs to the Moodle system. It is also evident how this OSS system, apart from achieving the transition to a successful multisite, collaborative and community-based OSS project, depends more on its community than its commercial partners.", "num_citations": "5\n", "authors": ["127"]}
{"title": "How outsourcing affects the quality of mission critical software\n", "abstract": " Often organisations employ third party contractors to carry out modifications and upgrades to an existing software product. This is usually done because of a lack of resource within the organisation: the software support staff could be busy on other projects, they could have a lack of expertise in the area of the work, or the job could just be too big to be done internally. Whatever the reason, bringing in an external contractor can have huge implications on the evolution of the software. As part of an evolution case study of a software product in use by the UK Royal Air Force (RAF), where third party contractor modifications were done on a regular basis, the implications of this third party work is being examined. The quality of the delivered software from both the in-house team and the contractor has been measured with particular attention to the software complexity. Preliminary results show that the software product\u00a0\u2026", "num_citations": "5\n", "authors": ["127"]}
{"title": "Reducing procrastination while improving performance: A Wiki-powered Experiment with Students\n", "abstract": " Students in higher education are traditionally requested to produce various pieces of written work during the courses they undertake. When students' work is submitted online as a whole, both the ethically questionable act of procrastinating and late submissions affect performance. The objective of this paper is to assess the performance of students from a control group, with that of students from an experimental group. The control group produced work as a unique deliverable to be submitted at the end of the course. On the other hand, the experimental group worked on each part for a week, and their work was managed by a wiki environment and monitored by a specifically developed software. Positive effects were noticed in the experimental group, as both students' time management skills and performance increased. Replications of this experiment can and should be performed, in order to compare results in\u00a0\u2026", "num_citations": "3\n", "authors": ["127"]}
{"title": "Patterns of creation and usage of Wikipedia content\n", "abstract": " Wikipedia is the largest online service storing user-generated content. Its pages are open to anyone for addition, deletion and modifications, and the effort of contributors is recorded and can be tracked in time. Although potentially the Wikipedia web content could exhibit unbounded growth, it is still not clear whether the effort of developers and the output generated are actually following patterns of continuous growth. It is also not clear how the users access such content, and if recurring patterns of usage are detectable showing how the Wikipedia content typically is viewed by interested readers. Using the category of Wikipedia as macro-agglomerates, this study reveals that Wikipedia categories face a decreasing growth trend over time, after an initial, exponential phase of development. On the other hand the study demonstrates that the number of views to the pages within the categories follow a linear, unbounded\u00a0\u2026", "num_citations": "3\n", "authors": ["127"]}
{"title": "The effect of multiple developers on structural attributes: A Study based on java software\n", "abstract": " ContextLong-term software projects employ different software developers who collaborate on shared artifacts. The accumulation of changes pushed by different developers leave traces on the underlying code, that have an effect on its future maintainability, and even reuse.ObjectiveThis study focuses on the how the changes by different developers might have an impact on the code: we investigate whether the work of multiple developers, and their experience, have a visible effect on the structural metrics of the underlying code.MethodWe consider nine object-oriented (OO) attributes and we measure them in a GitHub sample containing the top 200 \u2018forked\u2019 projects. For each of their classes, we evaluated the number of distinct developers contributing to its source code, and their experience in the project.ResultsWe show that the presence of multiple developers working on the same class has a visible effect on the\u00a0\u2026", "num_citations": "2\n", "authors": ["127"]}
{"title": "A specialised social network software architecture for efficient household water use management\n", "abstract": " Specialised, or vertical, social networks (SSN) are emerging as a useful tool to address practical issues such as household water use management. Despite the perceived benefits, the design of such systems is still not fully aware of the social interactions or the incentives that could be used to change user\u2019s behaviours when engaging with the network and peers. In this work, we propose and demonstrate the software architecture of a social network aimed at the efficient management of water in households, defining and connecting specialised system components. Three aspects are relevant in this work: first, the architecture explicitly defines components that support social interactions, in the context of existing water management instruments. Second, the architecture defines components addressing openness, which enable easy communication with external resources. Third, as part of a gamification\u00a0\u2026", "num_citations": "2\n", "authors": ["127"]}
{"title": "The impact of developer team sizes on the structural attributes of software\n", "abstract": " It is established that the internal quality of software is a key determinant of the total cost of ownership of that software. The objective of this research is to determine the impact that the development team\u2019s size has on the internal structural attributes of a codebase and, in doing so, we consider the impact that the team\u2019s size may have on the internal quality of the software that they produce. In this paper we leverage the wealth of data available in the open-source domain by mining detailed data from 1000 projects in GoogleCode and, coupled with one of the most established of object-oriented metric suites, we isolate and identify the effect that the development team size has on internal structural attributes of the software produced. We will find that some measures of functional decomposition are enhanced when we compare projects authored by fewer developers against those authored by a larger number of\u00a0\u2026", "num_citations": "2\n", "authors": ["127"]}
{"title": "Similarities, challenges and opportunities of wikipedia content and open source projects\n", "abstract": " Several years of research and evidence have demonstrated that open source software portals often contain a large amount of software projects that simply do not evolve, developed by relatively small communities, struggling to attract a sustained number of contributors. These portals have started to increasingly act as a storage for abandoned projects, and researchers and practitioners should try and point out how to take advantage of such content. Similarly, other online content portals (like Wikipedia) could be harvested for valuable content. In this paper we argue that, even with differences in the requested expertise, many projects reliant on content and contributions by users undergo a similar evolution, and follow similar patterns: when a project fails to attract contributors, it appears to be not evolving, or abandoned. Far from a negative finding, even those projects could provide valuable content that should be\u00a0\u2026", "num_citations": "2\n", "authors": ["127"]}
{"title": "Open standards and e-learning: the role of open source software\n", "abstract": " The role of Open Source Software (OSS) in the e-learning business has become more and more fundamental in the last 10 years, as long as corporate and government organizations have developed their educational and training programs based on OSS out-of-the-box tools. This paper qualitatively documents the decision of the largest UK e-learning provider, the Open University, to adopt the Moodle e-learning system, and how it has been successfully deployed in its site after a multi-million investment. A further quantitative study also provides evidence of the success of this OSS project, based on increasing amounts of both provided effort into, and produced outputs by the Moodle community. Lessons learned from this experience by the stakeholders include the crucial factors of contributing to the OSS community, and adapting to an evolving technology. It also becomes evident how commercial partners helped this OSS system to achieve the transition from an \u201caverage\u201d OSS system to a successful multi-site, collaborative and community-based OSS project.", "num_citations": "2\n", "authors": ["127"]}
{"title": "Domain Drivers in the Modularization of FLOSS Systems\n", "abstract": " The classification of software systems into types has been achieved in the past by observing both their specifications and behavioral patterns: the SPE classification, for instance, and its further supplements and refinements, has identified the S-type (i.e., fully specified), the P-type (i.e., specified but dependent on the context) and the E-type (i.e., addressing evolving problems) among the software systems.               In order to detect types, and establish similarities, among Free/Libre/Open Source Software (FLOSS) systems, this paper considers three modular characteristics (functions, files and folders) and their evolution: how they are evolving with size, if they are constant across systems, and whether recurring evolutionary patterns are observed. Using these various-grained characteristics, a set of models for the evolution of modularization are extracted from evolving systems, and then used to extract\u00a0\u2026", "num_citations": "2\n", "authors": ["127"]}
{"title": "Structural Analysis of Open Source Systems\n", "abstract": " The long-term evolution software systems that are actively used in real-world domains and environments2 is an interesting topic of empirical study. Such study can lead to insights and useful lessons both for researchers and practitioners. While systems not actively used, or prototypes, can be the subject of analysis, the conclusions derived from their study are limited in their applicability to real-world applications and domains. The empirical studies of real-world software processes and products are necessarily circumscribed to the kind of artefacts that an investigator may be able to obtain and measure: Proprietary systems are in general difficult to be studied, since the public disclosure of data reflecting those systems is forbidden in the vast majority of the cases. In the work reported in this chapter, we have used metrics derived from a number of Open Source Software (OSS) systems in order to study the characteristics of their longterm evolution, and, in particular, how their folder structure evolves. The naming of the files that contain the code generally follows a folder structure and we have found this an interesting attribute of study, which reveals some aspects of the evolving structure of", "num_citations": "2\n", "authors": ["127"]}
{"title": "Understanding open source and agile evolution through qualitative reasoning\n", "abstract": " The phenomenon of software evolution has been described in the literature [eg, Lehman 1974; Lehman and Belady 1985] and several models of different nature [eg, Aoyama 2002; Capiluppi 2003; Lehman et al 2002; Rajlich and Bennett 2000; FEAST] have been proposed to understand and explain the empirical observations. Some of these models purport to be universally applicable to all software development processes. However, the models in the literature were built mainly observing software developed in what has been the traditional centrally-managed Waterfall development process or one its variants. Since these theories were developed, software development methods have themselves evolved and now much software is developed and evolved by using agile methods (such as XP [Beck 1999]) and in open-source environments. It remains a question to be investigated what are the characteristics of software evolution under these new paradigms and whether the existing models form an accurate description of the evolution of software under these new regimes or whether new models will be required. In previous work [eg, Ramil & Smith 2002; Smith & Ramil 2002, 2003; Smith et al 2004, 2005] the authors have illustrated how qualitative reasoning methods, such a qualitative simulation, provide a useful way to examine the general behaviour of models of software evolution. This extended abstract describes our plans for further research into the topic.", "num_citations": "2\n", "authors": ["127"]}
{"title": "Folder Structure Evolution in Open Source Software\n", "abstract": " Predicting when and how a software system will evolve is one of the most fascinating challenges of software engineering. No matter what approach one is using to study such evolution, empirical studies, including observations of systems used in the real world, and of their software processes, are needed in order to identify correlations, find recurring patterns, and eventually predict how systems are likely to evolve. In the empirical study presented in this paper, we take 25 software systems released as Open Source, and observe their evolution. Our focus is not only on how much systems grow in size, but rather on how code structure is adapted and gets modified as the system is evolved. The main goal of this study is to recognize recurring patterns and practices used in evolving long-lived real world software systems.In our study we find three dominant patterns of code structure evolution of Open Source systems: horizontal expansion, vertical expansion, vertical shrinking. By detailed study of exemplars of these three patterns one can identify under which conditions a particular pattern is more likely to prevail than the others.", "num_citations": "2\n", "authors": ["127"]}
{"title": "National boundaries and semantics of artefacts in open source development\n", "abstract": " Global software development has long being recognised as a paradigm shift in modern software development. As an immediate effect, co-location of workers in the same building or office is not seen as necessary any longer. Coordination in distributed socio-technical systems is mostly achieved by means of the artifacts that are produced by the developers part of a project's team. Geographic distance profoundly affects the ability to collaborate. With communication becoming less frequent, the challenge is for it to become more effective. This is especially complex when different nationalities, languages and cultures are part of the same development effort. Open source software is an example of a distributed, multi-lingual development effort. As such, the main resulting artefacts are discussions, and source code. Diverse backgrounds can produce a different semantic corpus if the authors come from the same ethnic and\u00a0\u2026", "num_citations": "1\n", "authors": ["127"]}
{"title": "Notice of Retraction: It jobs in UK: Current trends\n", "abstract": " Part of the role of universities is, today as from their earlier times, to prepare students for a productive role in the society. In this context, the role of curriculum development is to ensure that students are able-if so they wish-to acquire skills that are in demand in the work market. This is of uttermost importance in areas as IT where weak choices by students and/or universities might have repercussions in the employability at the end of the academic studies. This paper aims to discusses and a discuss and analyse what are the requirements of the job market, now, today, for IT workers in UK and to provide a meaningful starting point to support curricula development in UK.", "num_citations": "1\n", "authors": ["127"]}
{"title": "De la catedral al bazar\n", "abstract": " Estudios previos han proporcionado pruebas emp\u00edricas de los procesos de desarrollo empleados en proyectos de software libre que tienen \u00e9xito: por ejemplo, la definici\u00f3n de diferentes tipos de desarrolladores para los proyectos Apache y Mozilla, que justificaba diferentes niveles de esfuerzo [27], y conclu\u00eda que el primer tipo, los desarrolladores principales (core developers), son los que contribuyen al \u00e9xito de un proyecto. Tambi\u00e9n, el an\u00e1lisis de redes sociales ha mostrado cu\u00e1les son los costes de comunicaci\u00f3n y coordinaci\u00f3n en proyectos de software libre de \u00e9xito [21].", "num_citations": "1\n", "authors": ["127"]}
{"title": "Software libre: investigaci\u00f3n y desarrollo: investigaci\u00f3n y desarrollo\n", "abstract": " En los \u00faltimos a\u00f1os hemos podido observar c\u00f3mo el Software Libre ha pasado de ser un simple modelo de desarrollo de software (con todas sus implicaciones t\u00e9cnicas y \u00e9ticas) a ser un elemento clave en las estrategias de desarrollo de empresas, instituciones, regiones e incluso pa\u00edses enteros. Ejemplos como el de gobierno de Brasil apoyando la implantaci\u00f3n de software libre en el pa\u00eds o la Junta de Andaluc\u00eda liberando todos sus desarrollos han servido para que cada vez m\u00e1s instituciones y foros estudien las implicaciones del modelo a largo plazo.", "num_citations": "1\n", "authors": ["127"]}