{"title": "Learning to Mine Aligned Code and Natural Language Pairs from Stack Overflow\n", "abstract": " For tasks like code synthesis from natural language, code retrieval, and code summarization, data-driven models have shown great promise. However, creating these models require parallel data between natural language (NL) and code with fine-grained alignments. StackOverflow (SO) is a promising source to create such a data set: the questions are diverse and most of them have corresponding answers with high-quality code snippets. However, existing heuristic methods (e.g. pairing the title of a post with the code in the accepted answer) are limited both in their coverage and the correctness of the NL-code pairs obtained. In this paper, we propose a novel method to mine high-quality aligned data from SO using two sets of features: hand-crafted features considering the structure of the extracted snippets, and correspondence features obtained by training a probabilistic model to capture the correlation between\u00a0\u2026", "num_citations": "89\n", "authors": ["198"]}
{"title": "Adding Sparkle to Social Coding: An Empirical Study of Repository Badges in the npm Ecosystem\n", "abstract": " In fast-paced, reuse-heavy, and distributed software development, the transparency provided by social coding platforms like GitHub is essential to decision making. Developers infer the quality of projects using visible cues, known as signals, collected from personal profile and repository pages. We report on a large-scale, mixed-methods empirical study of npm packages that explores the emerging phenomenon of repository badges, with which maintainers signal underlying qualities about their projects to contributors and users. We investigate which qualities maintainers intend to signal and how well badges correlate with those qualities. After surveying developers, mining 294,941 repositories, and applying statistical modeling and time-series analyses, we find that non-trivial badges, which display the build status, test coverage, and up-to-dateness of dependencies, are mostly reliable signals, correlating with more\u00a0\u2026", "num_citations": "82\n", "authors": ["198"]}
{"title": "You can't control the unfamiliar: A study on the relations between aggregation techniques for software metrics\n", "abstract": " A popular approach to assessing software maintainability and predicting its evolution involves collecting and analyzing software metrics. However, metrics are usually defined on a micro-level (method, class, package), and should therefore be aggregated in order to provide insights in the evolution at the macro-level (system). In addition to traditional aggregation techniques such as the mean, median, or sum, recently econometric aggregation techniques, such as the Gini, Theil, Kolm, Atkinson, and Hoover inequality indices have been proposed and applied to software metrics. In this paper we present the results of an extensive correlation study of the most widely-used traditional and econometric aggregation techniques, applied to lifting SLOC values from class to package level in the 106 systems comprising the Qualitas Corpus. Moreover, we investigate the nature of this relation, and study its evolution on a subset\u00a0\u2026", "num_citations": "68\n", "authors": ["198"]}
{"title": "Developer Initiation and Social Interactions in OSS: A Case Study of the Apache Software Foundation\n", "abstract": " Maintaining a productive and collaborative team of developers is essential to Open Source Software (OSS) success, and hinges upon the trust inherent among the team. Whether a project participant is initiated as a committer is a function of both his technical contributions and also his social interactions with other project participants. One\u2019s online social footprint is arguably easier to ascertain and gather than one\u2019s technical contributions e.g., gathering patch submission information requires mining multiple sources with different formats, and then merging the aliases from these sources. In contrast to prior work, where patch submission was found to be an essential ingredient to achieving committer status, here we investigate the extent to which the likelihood of achieving that status can be modeled solely as a social network phenomenon. For 6 different Apache Software Foundation OSS projects we compile\u00a0\u2026", "num_citations": "55\n", "authors": ["198"]}
{"title": "Human aspects, gamification, and social media in collaborative software engineering\n", "abstract": " Software engineering is inherently a collaborative venture. In open-source software (OSS) development, such collaborations almost always span geographies and cultures. Because of the decentralised and self-directed nature of OSS as well as the social diversity inherent to OSS communities, the success of an OSS project depends to a large extent on the social aspects of distributed collaboration and achieving coordination over distance. The goal of this dissertation research is to raise our understanding of how human aspects (eg, gender or cultural diversity), gamification and social media (eg, participation in social environments such as Stack Overflow or GitHub) impact distributed collaboration in OSS.", "num_citations": "34\n", "authors": ["198"]}
{"title": "Detecting and Characterizing Bots that Commit Code\n", "abstract": " Background: Some developer activity traditionally performed manually, such as making code commits, opening, managing, or closing issues is increasingly subject to automation in many OSS projects. Specifically, such activity is often performed by tools that react to events or run at specific times. We refer to such automation tools as bots and, in many software mining scenarios related to developer productivity or code quality, it is desirable to identify bots in order to separate their actions from actions of individuals. Aim: Find an automated way of identifying bots and code committed by these bots, and to characterize the types of bots based on their activity patterns. Method and Result: We propose BIMAN, a systematic approach to detect bots using author names, commit messages, files modified by the commit, and projects associated with the commits. For our test data, the value for AUC-ROC was 0.9. We also\u00a0\u2026", "num_citations": "25\n", "authors": ["198"]}
{"title": "Why do People Give Up FLOSSing? A Study of Contributor Disengagement in Open Source\n", "abstract": " Established contributors are the backbone of many free/libre open source software (FLOSS) projects. Previous research has shown that it is critically important for projects to retain contributors and it has also revealed the motivations behind why contributors choose to participate in FLOSS in the first place. However, there has been limited research done on the reasons why established contributors disengage, and factors (on an individual and project level) that predict their disengagement. In this paper, we conduct a mixed-methods empirical study, combining surveys and survival modeling, to identify the reasons and predictive factors behind established contributor disengagement. We find that different groups of established contributors tend to disengage for different reasons; however, overall contributors most commonly cite some kind of transition (e.g., switching jobs or leaving academia). We also find that\u00a0\u2026", "num_citations": "24\n", "authors": ["198"]}
{"title": "One Size Does Not Fit All: An Empirical Study of Containerized Continuous Deployment Workflows\n", "abstract": " Continuous deployment (CD) is a software development practice aimed at automating delivery and deployment of a software product, following any changes to its code. If properly implemented, CD together with other automation in the development process can bring numerous benefits, including higher control and flexibility over release schedules, lower risks, fewer defects, and easier on-boarding of new developers. Here we focus on the (r) evolution in CD workflows caused by containerization, the virtualization technology that enables packaging an application together with all its dependencies and execution environment in a light-weight, self-contained unit, of which Docker has become the de-facto industry standard. There are many available choices for containerized CD workflows, some more appropriate than others for a given project. Owing to cross-listing of GitHub projects on Docker Hub, in this paper we\u00a0\u2026", "num_citations": "24\n", "authors": ["198"]}
{"title": "\"Automatically Assessing Code Understandability\" Reanalyzed: Combined Metrics Matter\n", "abstract": " Previous research shows that developers spend most of their time understanding code. Despite the importance of code understandability for maintenance-related activities, an objective measure of it remains an elusive goal. Recently, Scalabrino et al. reported on an experiment with 46 Java developers designed to evaluate metrics for code understandability. The authors collected and analyzed data on more than a hundred features describing the code snippets, the developers' experience, and the developers' performance on a quiz designed to assess understanding. They concluded that none of the metrics considered can individually capture understandability. Expecting that understandability is better captured by a combination of multiple features, we present a reanalysis of the data from the Scalabrino et al. study, in which we use different statistical modeling techniques. Our models suggest that some computed\u00a0\u2026", "num_citations": "24\n", "authors": ["198"]}
{"title": "Within-Ecosystem Issue Linking: A Large-Scale Study of Rails\n", "abstract": " Social coding facilitates the sharing of ideas within and between projects in an open source ecosystem. Bug fixing and triaging, in particular, are aided by linking issues in one project to potentially related issues within it or in other projects in the ecosystem. Identifying and linking to related issues is in general challenging, and more so across projects. Previous studies, on a limited number of projects have shown that linking to issues within a project associates with faster issue resolution times than cross-project linking. In this paper, we present a mixed methods study of the relationship between the practice of issue linking and issue resolution in the Rails ecosystem of open source projects. Using a qualitative study of issue linking we identify a discrete set of linking outcomes together with their coarse-grained effects on issue resolution. Using quantitative study of patterns in developer linking within and across projects\u00a0\u2026", "num_citations": "21\n", "authors": ["198"]}
{"title": "A large-scale, in-depth analysis of developers\u2019 personalities in the Apache ecosystem\n", "abstract": " ContextLarge-scale distributed projects are typically the results of collective efforts performed by multiple developers with heterogeneous personalities.ObjectiveWe aim to find evidence that personalities can explain developers\u2019 behavior in large scale-distributed projects. For example, the propensity to trust others \u2014 a critical factor for the success of global software engineering \u2014 has been found to influence positively the result of code reviews in distributed projects.MethodIn this paper, we perform a quantitative analysis of ecosystem-level data from the code commits and email messages contributed by the developers working on the Apache Software Foundation (ASF) projects, as representative of large scale-distributed projects.ResultsWe find that there are three common types of personality profiles among Apache developers, characterized in particular by their level of Agreeableness and Neuroticism. We also\u00a0\u2026", "num_citations": "20\n", "authors": ["198"]}
{"title": "Tool Choice Matters: JavaScript Quality Assurance Tools and Usage Outcomes in GitHub Projects\n", "abstract": " Quality assurance automation is essential in modern software development. In practice, this automation is supported by a multitude of tools that fit different needs and require developers to make decisions about which tool to choose in a given context. Data and analytics of the pros and cons can inform these decisions. Yet, in most cases, there is a dearth of empirical evidence on the effectiveness of existing practices and tool choices. We propose a general methodology to model the time-dependent effect of automation tool choice on four outcomes of interest: prevalence of issues, code churn, number of pull requests, and number of contributors, all with a multitude of controls. On a large data set of npm JavaScript projects, we extract the adoption events for popular tools in three task classes: linters, dependency managers, and coverage reporters. Using mixed methods approaches, we study the reasons for the\u00a0\u2026", "num_citations": "19\n", "authors": ["198"]}
{"title": "Incorporating External Knowledge through Pre-training for Natural Language to Code Generation\n", "abstract": " Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at https://github.com/neulab/external-knowledge-codegen.", "num_citations": "18\n", "authors": ["198"]}
{"title": "What the fork: a study of inefficient and efficient forking practices in social coding\n", "abstract": " Forking and pull requests have been widely used in open-source communities as a uniform development and contribution mechanism, giving developers the flexibility to modify their own fork without affecting others before attempting to contribute back. However, not all projects use forks efficiently; many experience lost and duplicate contributions and fragmented communities. In this paper, we explore how open-source projects on GitHub differ with regard to forking inefficiencies. First, we observed that different communities experience these inefficiencies to widely different degrees and interviewed practitioners to understand why. Then, using multiple regression modeling, we analyzed which context factors correlate with fewer inefficiencies. We found that better modularity and centralized management are associated with more contributions and a higher fraction of accepted pull requests, suggesting specific best\u00a0\u2026", "num_citations": "18\n", "authors": ["198"]}
{"title": "Stress and Burnout in Open Source: Toward Finding, Understanding, and Mitigating Unhealthy Interactions\n", "abstract": " Developers from open-source communities have reported high stress levels from frequent demands for features and bug fixes and from the sometimes aggressive tone of these demands. Toxic conversations may demotivate and burn out developers, creating challenges for sustaining open source. We outline a path toward finding, understanding, and possibly mitigating such unhealthy interactions. We take a first step toward finding them, by developing and demonstrating a measurement instrument (an SVM classifier tailored for software engineering) to detect toxic discussions in GitHub issues. We used our classifier to analyze trends over time and in different GitHub communities, finding that toxicity varies by community and that toxicity decreased between 2012 and 2018.", "num_citations": "15\n", "authors": ["198"]}
{"title": "How Has Forking Changed in the Last 20 Years? A Study of Hard Forks on GitHub\n", "abstract": " The notion of forking has changed with the rise of distributed version control systems and social coding environments, like GitHub. Traditionally forking refers to splitting off an independent development branch (which we call hard forks); research on hard forks, conducted mostly in pre-GitHub days showed that hard forks were often seen critical as they may fragment a community. Today, in social coding environments, open-source developers are encouraged to fork a project in order to contribute to the community (which we call social forks), which may have also influenced perceptions and practices around hard forks. To revisit hard forks, we identify, study, and classify 15,306 hard forks on GitHub and interview 18 owners of hard forks or forked repositories. We find that, among others, hard forks often evolve out of social forks rather than being planned deliberately and that perception about hard forks have indeed\u00a0\u2026", "num_citations": "14\n", "authors": ["198"]}
{"title": "On Developers' Personality in Large-scale Distributed Projects: The Case of the Apache Ecosystem\n", "abstract": " Large-scale distributed projects are typically the results of collective efforts performed by multiple developers, each one having a different personality. The study of developers' personalities has the potential of explaining their' behavior in various contexts. For example, the propensity to trust others, a critical factor to the success of global software engineering - has been found to influence positively the result of code reviews in distributed projects. In this paper, we perform a quantitative analysis of developers' personality in open source software projects, intended as an extreme form of distributed projects in which no single organization controls the project. We mine ecosystem-level data from the code commits and email messages contributed by the developers working on the Apache Software Foundation (ASF) projects, as representative of large scale-distributed projects. We find that developers become over time\u00a0\u2026", "num_citations": "14\n", "authors": ["198"]}
{"title": "Software developers are humans, too!\n", "abstract": " Open-source communities can be seen as knowledge-sharing ecosystems: participants learn from the community and from one another, and share their knowledge through contributions to the source code repositories or by offering support to users. With the emergence and growing popularity of social media sites targeting software developers (eg, StackOverflow, GitHub), the paths through which knowledge flows within open-source software knowledge-sharing ecosystems are also beginning to change. My dissertation research seeks to raise our understanding of these changes.", "num_citations": "13\n", "authors": ["198"]}
{"title": "The Signals that Potential Contributors Look for When Choosing Open-source Projects\n", "abstract": " While open-source software has become ubiquitous, its sustainability is in question: without a constant supply of contributor effort, open-source projects are at risk. While prior work has extensively studied the motivations of open-source contributors in general, relatively little is known about how people choose which project to contribute to, beyond personal interest. This question is especially relevant in transparent social coding environments like GitHub, where visible cues on personal profile and repository pages, known as signals, are known to impact impression formation and decision making. In this paper, we report on a mixed-methods empirical study of the signals that influence the contributors' decision to join a GitHub project. We first interviewed 15 GitHub contributors about their project evaluation processes and identified the important signals they used, including the structure of the README and the\u00a0\u2026", "num_citations": "11\n", "authors": ["198"]}
{"title": "An exploratory study of bot commits\n", "abstract": " Background: Bots help automate many of the tasks performed by software developers and are widely used to commit code in various social coding platforms. At present, it is not clear what types of activities these bots perform and understanding it may help design better bots, and find application areas which might benefit from bot adoption. Aim: We aim to categorize the Bot Commits by the type of change (files added, deleted, or modified), find the more commonly changed file types, and identify the groups of file types that tend to get updated together. Method: 12,326,137 commits made by 461 popular bots (that made at least 1000 commits) were examined to identify the frequency and the type of files added/deleted/modified by the commits, and association rule mining was used to identify the types of files modified together. Result: Majority of the bot commits modify an existing file, a few of them add new files, while\u00a0\u2026", "num_citations": "10\n", "authors": ["198"]}
{"title": "A splitting line model for directional relations\n", "abstract": " Directional relations are fundamental to spatial data queries, analysis and reasoning. Consequently there has been a significant amount of effort to determine directional relations between two regions. However, many existing methods do not perform well when the regions are neighboring or intertwined. In this paper we introduce a new model for directional relations which is based on a splitting line separating the two regions in question. We identify essential quality criteria for directional relation models and translate them into measurable properties of a given splitting line. We present an efficient algorithm that computes an optimal splitting line for two regions and perform extensive experiments. Our results show that the splitting line model captures directional relations very well and that it clearly outperforms existing approaches on pairs of neighboring or intertwined regions.", "num_citations": "10\n", "authors": ["198"]}
{"title": "A conceptual replication of continuous integration pain points in the context of Travis CI\n", "abstract": " Continuous integration (CI) is an established software quality assurance practice, and the focus of much prior research with a diverse range of methods and populations. In this paper, we first conduct a literature review of 37 papers on CI pain points. We then conduct a conceptual replication study on results from these papers using a triangulation design consisting of a survey with 132 responses, 12 interviews, and two logistic regressions predicting Travis CI abandonment and switching on a dataset of 6,239 GitHub projects. We report and discuss which past results we were able to replicate, those for which we found conflicting evidence, those for which we did not find evidence, and the implications of these findings.", "num_citations": "9\n", "authors": ["198"]}
{"title": "I\u2019m Leaving You, Travis: A Continuous Integration Breakup Story\n", "abstract": " Continuous Integration (CI) services, which can automatically build, test, and deploy software projects, are an invaluable asset in distributed teams, increasing productivity and helping to maintain code quality. Prior work has shown that CI pipelines can be sophisticated, and choosing and configuring a CI system involves tradeoffs. As CI technology matures, new CI tool offerings arise to meet the distinct wants and needs of software teams, as they negotiate a path through these tradeoffs, depending on their context. In this paper, we begin to uncover these nuances, and tell the story of open-source projects falling out of love with Travis, the earliest and most popular cloud-based CI system. Using logistic regression, we quantify the effects that open-source community factors and project technical factors have on the rate of Travis abandonment. We find that increased build complexity reduces the chances of\u00a0\u2026", "num_citations": "9\n", "authors": ["198"]}
{"title": "In-IDE Code Generation from Natural Language: Promise and Challenges\n", "abstract": " A great part of software development involves conceptualizing or communicating the underlying procedures and logic that needs to be expressed in programs. One major difficulty of programming is turning concept into code, especially when dealing with the APIs of unfamiliar libraries. Recently, there has been a proliferation of machine learning methods for code generation and retrieval from natural language queries, but these have primarily been evaluated purely based on retrieval accuracy or overlap of generated code with developer-written code, and the actual effect of these methods on the developer workflow is surprisingly unattested. We perform the first comprehensive investigation of the promise and challenges of using such technology inside the IDE, asking \"at the current state of technology does it improve developer productivity or accuracy, how does it affect the developer experience, and what are the remaining gaps and challenges?\" We first develop a plugin for the IDE that implements a hybrid of code generation and code retrieval functionality, and orchestrate virtual environments to enable collection of many user events. We ask developers with various backgrounds to complete 14 Python programming tasks ranging from basic file manipulation to machine learning or data visualization, with or without the help of the plugin. While qualitative surveys of developer experience are largely positive, quantitative results with regards to increased productivity, code quality, or program correctness are inconclusive. Analysis identifies several pain points that could improve the effectiveness of future machine learning based code generation\u00a0\u2026", "num_citations": "8\n", "authors": ["198"]}
{"title": "MARBLE: Mining for Boilerplate Code to Identify API Usability Problems\n", "abstract": " Designing usable APIs is critical to developers' productivity and software quality, but is quite difficult. One of the challenges is that anticipating API usability barriers and real-world usage is difficult, due to a lack of automated approaches to mine usability data at scale. In this paper, we focus on one particular grievance that developers repeatedly express in online discussions about APIs: \"boilerplate code.\" We investigate what properties make code count as boilerplate, the reasons for boilerplate, and how programmers can reduce the need for it. We then present MARBLE, a novel approach to automatically mine boilerplate code candidates from API client code repositories. MARBLE adapts existing techniques, including an API usage mining algorithm, an AST comparison algorithm, and a graph partitioning algorithm. We evaluate MARBLE with 13 Java APIs, and show that our approach successfully identifies both\u00a0\u2026", "num_citations": "7\n", "authors": ["198"]}
{"title": "Social aspects of collaboration in online software communities\n", "abstract": " Social aspects of collaboration in online software communities (2014) | www.narcis.nl KNAW KNAW Narcis Back to search results Eindhoven University of Technology Publication Social aspects of collaboration in online software communities (2014) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Social aspects of collaboration in online software communities Author Vasilescu, BN Thesis advisor van den Brand, Mark GJ; Serebrenik, Alexander Publisher Model Driven Software Engineering W&I; Sectie Softwaretechnologie Date issued 2014 Access Open Access Language English Type Doctoral Thesis Publisher Technische Universiteit Eindhoven Publication https://research.tue.nl/nl/publications/social-aspects-of-co... ISBN 978-90-386-3685-6 Persistent Identifiers NBN urn:nbn:nl:ui:25-09396b4d-d71a-4344-9203-1f2d53a4e478 /: .\u2026", "num_citations": "6\n", "authors": ["198"]}
{"title": "Need for Tweet: How Open Source Developers Talk About Their GitHub Work on Twitter\n", "abstract": " Social media, especially Twitter, has always been a part of the professional lives of software developers, with prior work reporting on a diversity of usage scenarios, including sharing information, staying current, and promoting one's work. However, previous studies of Twitter use by software developers typically lack information about activities of the study subjects (and their outcomes) on other platforms. To enable such future research, in this paper we propose a computational approach to cross-link users across Twitter and GitHub, revealing (at least) 70,427 users active on both. As a preliminary analysis of this dataset, we report on a case study of 786 tweets by open-source developers about GitHub work, combining automatic characterization of tweet authors in terms of their relationship to the GitHub items linked in their tweets with qualitative analysis of the tweet contents. We find that different developer roles\u00a0\u2026", "num_citations": "5\n", "authors": ["198"]}
{"title": "Heard It through the Gitvine: An Empirical Study of Tool Diffusion across the npm Ecosystem\n", "abstract": " Automation tools like continuous integration services, code coverage reporters, style checkers, dependency managers, etc. are all known to provide significant improvements in developer productivity and software quality. Some of these tools are widespread, others are not. How do these automation\" best practices\" spread? And how might we facilitate the diffusion process for those that have seen slower adoption? In this paper, we rely on a recent innovation in transparency on code hosting platforms like GitHub---the use of repository badges---to track how automation tools spread in open-source ecosystems through different social and technical mechanisms over time. Using a large longitudinal data set, multivariate network science techniques, and survival analysis, we study which socio-technical factors can best explain the observed diffusion process of a number of popular automation tools. Our results show that\u00a0\u2026", "num_citations": "3\n", "authors": ["198"]}
{"title": "Poster: Learning to Mine Parallel Natural Language/Source Code Corpora from Stack Overflow\n", "abstract": " For tasks like code synthesis from natural language, code retrieval, and code summarization, data-driven models have shown great promise. However, creating these models requires parallel data between natural language (NL) and code with fine-grained alignments. Stack Overflow (SO) is a promising source to create such a data set but existing heuristic methods are limited both in their coverage and the correctness of the NL-code pairs obtained. In this paper, we propose a method to mine high-quality aligned data from SO by training a classifier using two sets of features: hand-crafted features considering the structure of the extracted snippets, and correspondence features obtained by training a neural network model to capture the correlation between NL and code. Experiments using Python and Java as test beds show that the proposed method greatly expands coverage and accuracy over existing mining\u00a0\u2026", "num_citations": "3\n", "authors": ["198"]}
{"title": "Seeing the Forest for the Trees with New Econometric Aggregation Techniques.\n", "abstract": " Maintaining a software system is like renovating a house: it usually takes longer and costs more than planned. Like a house owner preparing a condition report identifying potential problems before renovation, a software owner should assess maintainability of software before renovating or extending it. To measure software maintainability one often applies software metrics, associating software artifacts with numerical values. Unfortunately, advanced software metrics are commonly measured at a level of small artifacts, eg methods and classes, and fail to provide an adequate picture of the system maintainability. Continuing the analogy, the state-of-theart in software metrics corresponds to a condition report detailing the state of every brick and obscuring the general assessment in the multitude of details. Metrics visualization techniques provide a general overview of the measurements but have difficulties with presenting evolution of these measurements in time.To see the forest of a software system for the trees of individual measurements, aggregation techniques are used. Current aggregation techniques are, however, usually unreliable or involve human judgment. For instance, the mean is known to become unreliable in the presence of highly skewed distributions, which are typical for software metrics. Another approach, distribution fitting, consists of manually selecting a known family of distributions and fitting its parameters to approximate the observed", "num_citations": "1\n", "authors": ["198"]}