{"title": "An automata-theoretic approach to automatic program verification\n", "abstract": " [en] We describe an automata-theoretic approach to the automatic verification of concurrent finite-state programs bymodel checking. The basic idea underlying this approach is that for any temporal formula we can construct an automaton that accepts precisely the computations that satisfy the formula. The model-checking algorithm that results from this approach is much simpler and cleaner than tableau-based algorithms. We use this approach to extend model checking to probabilistic concurrent finite-state programs.", "num_citations": "2195\n", "authors": ["1585"]}
{"title": "Simple on-the-fly automatic verification of linear temporal logic\n", "abstract": " We present a tableau-based algorithm for obtaining an automaton from a temporal logic formula. The algorithm is geared towards being used in model checking in an \u201con-the-fly\u201d fashion, that is the automaton can be constructed simultaneously with, and guided by, the generation of the model. In particular, it is possible to detect that a property does not hold by only constructing part of the model and of the automaton. The algorithm can also be used to check the validity of a temporal logic assertion. Although the general problem is PSPACE-complete, experiments show that our algorithm performs quite well on the temporal formulas typically encountered in verification. While basing linear-time temporal logic model-checking upon a transformation to automata is not new, the details of how to do this efficiently, and in \u201con-the-fly\u201d fashion have never been given.", "num_citations": "1143\n", "authors": ["1585"]}
{"title": "Reasoning about infinite computations\n", "abstract": " We investigate extensions of temporal logic by connectives defined by finite automata on infinite words. We consider three different logics, corresponding to three different types of acceptance conditions (finite, looping, and repeating) for the automata. It turns out, however that these logics all have the same expressive power and that their decision problems are all PSPACE-complete. We also investigate connectives defined by alternating automata and show that they do not increase the expressive power of the logic or the complexity of the decision problem.", "num_citations": "1085\n", "authors": ["1585"]}
{"title": "Temporal logic can be more expressive\n", "abstract": " It is first proved that there are properties of sequences that are not expressible in temporal logic, even though they are easily expressible using, for instance, regular expressions. Then, it is shown how temporal logic can be extended to express any property definable by a right-linear grammar and hence a regular expression. Finally, a complete axiomatization and a decision procedure for the extended temporal logic are given and the complexity of the extended logic is examined.", "num_citations": "1040\n", "authors": ["1585"]}
{"title": "Synthesis of communicating processes from temporal logic specifications\n", "abstract": " In this paper, Propositional Temporal Logic (PTL) is applied to the specification and synthesis of the synchronization part of communicating processes. To specify a process, a PTL formula that describes its sequence of communications is given. The synthesis is done by constructing a model of the given specifications using a tableau-like satisfiability algorithm for PTL. This model can then be interpreted as a program.", "num_citations": "772\n", "authors": ["1585"]}
{"title": "Automata-theoretic techniques for modal logics of programs\n", "abstract": " We present a new technique for obtaining decision procedures for modal logics of programs. The technique centers around a new class of finite automata on infinite trees for which the emptiness problem can be solved in polynomial time. The decision procedures then consist of constructing an automaton Af for a given formula f such that Af accepts some tree if and only if f is satisfiable. We illustrate our technique by giving exponential decision procedures for several variants of deterministic propositional dynamic logic.", "num_citations": "690\n", "authors": ["1585"]}
{"title": "Realizable and unrealizable specifications of reactive systems\n", "abstract": " A specification is useless if it cannot be realized by any concrete implementation. There are obvious reasons why it might be unrealizable: it might require the computation of a nonrecursive function, or it might be logically inconsistent. A more subtle danger is specifying the behavior of part of the universe outside the implementor's control. This source of unreaiizability is most likely to infect specifications of concurrent systems or reactive systems [HP85]. It is this source of unrealizability that concerns us.Formally, a specification is a set of sequences of states, which represents the set of allowed behaviors of a system. We do not distinguish between specifications and programs; a Pascal program and a temporal logic specification are both specifications, although one is at a lower level than the other.(Some may wonder which is the lowerlevel one.) A specification S1 is said to implement a specification S2 iff (if and only if\u00a0\u2026", "num_citations": "397\n", "authors": ["1585"]}
{"title": "Expressing interesting properties of programs in propositional temporal logic\n", "abstract": " We show that the class of properties of programs expressible in propositional temporal logic can be substantially extended if we assume the programs to bedata-independent. Basically, a program is data-independent if its behavior does not depend on the specific data it operates upon. Our results significantly extend the applicability of program verification and synthesis methods based on propositional temporal logic.", "num_citations": "395\n", "authors": ["1585"]}
{"title": "The tableau method for temporal logic: An overview\n", "abstract": " An overview of the tableau decision method for propositional temporal logic is presented. The method is described in detail for linear time temporal logic. It is then discussed how it can be applied to other variants of temporal logic like branching time temporal logic and extensions of linear time temporal logic. Finally, applications of temporal logics to computer science are reviewed.", "num_citations": "371\n", "authors": ["1585"]}
{"title": "Verifying properties of large sets of processes with network invariants\n", "abstract": " If a system is built from a large number of identical finite-state processes, it seems intuitively obvious that, with the help of\" a little induction\", the verification of such a system can be reduced to a finite-state problem. The difficulty is to find the right form of\" a little induction\". There have been several attempts to address this problem in the context of model-checking [CGBS6],[CGS7],[GSS7]. In very general terms (see Section 6 for more details), the approach is to find ways of proving that if a process satisfies a fornmla, then the n-fold parallel composition of this process with itself still satisfies the same (or a related) formula. This approach makes some interesting verifications possible. However, it has its limits and usually requires the implementation of special purpose tools. In this paper, we propose an alternative approach. It is an attempt to make the\" little induction\" explicit and simple. If one wants to prove that some\u00a0\u2026", "num_citations": "304\n", "authors": ["1585"]}
{"title": "Symbolic verification with periodic sets\n", "abstract": " Symbolic approaches attack the state explosion problem by introducing implicit representations that allow the simultaneous manipulation of large sets of states. The most commonly used representation in this context is the Binary Decision Diagram (BDD). This paper takes the point of view that other structures than BDD's can be useful for representing sets of values, and that combining implicit and explicit representations can be fruitful. It introduces a representation of complex periodic sets of integer values, shows how this representation can be manipulated, and describes its application to the state-space exploration of protocols. Preliminary experimental results indicate that the method can dramatically reduce the resources required for state-space exploration.", "num_citations": "224\n", "authors": ["1585"]}
{"title": "Reliable hashing without collision detection\n", "abstract": " Thanks to a variety of new techniques, state-space exploration is becoming an increasingly effective method for the verification of concurrent programs. One of these techniques, hashing without collision detection, was proposed by Holzmann as a way to vastly reduce the amount of memory needed to store the explored state space. Unfortunately, this reduction in memory use comes at the price of a high probability of ignoring part of the state space and hence of missing existing errors. In this paper, we carefully analyze this method and show that, by using a modified strategy, it is possible to reduce the risk of error to a negligible amount while maintaining the memory use advantage of Holzmann's technique. Our proposed strategy has been implemented and we describe experiments that confirm the excellent expected results.", "num_citations": "217\n", "authors": ["1585"]}
{"title": "On the relation of programs and computations to models of temporal logic\n", "abstract": " In recent years there has been a proliferation of program verification methods that use temporal logic. These methods differ by the version of temporal logic they are based upon and by the way they use this logic. In this paper we attempt to give a simple, unified and coherent view of the field. For this, we first characterize the models and model generators of different versions of temporal logic using automata theory. From this characterization, we build a classification of verification and synthesis methods that use temporal logic.", "num_citations": "166\n", "authors": ["1585"]}
{"title": "Constructing Automata from Temporal Logic Formulas: A Tutorial\u22c6\n", "abstract": " This paper presents a tutorial introduction to the construction of finite-automata on infinite words from linear-time temporal logic formulas. After defining the source and target formalisms, it describes a first construction whose correctness is quite direct to establish, but whose behavior is always equal to the worst-case upper bound. It then turns to the techniques that can be used to improve this algorithm in order to obtain the quite effective algorithms that are now in use.", "num_citations": "147\n", "authors": ["1585"]}
{"title": "Temporal deductive databases\n", "abstract": " We survey a number of approaches to the problem of nite representation of in nite temporal extensions. Two of them, Datalog1S and Templog, are syntactical extensions of Datalog; the third is based on repetition and arithmetic constraints. We provide precise characterizations of the expressiveness and the computational complexity of these languages. We also describe query evaluation methods.", "num_citations": "144\n", "authors": ["1585"]}
{"title": "Iterating transducers in the large\n", "abstract": " Checking infinite-state systems is frequently done by encoding infinite sets of states as regular languages. Computing such a regular representation of, say, the reachable set of states of a system requires acceleration techniques that can finitely compute the effect of an unbounded number of transitions. Among the acceleration techniques that have been proposed, one finds both specific and generic techniques. Specific techniques exploit the particular type of system being analyzed, e.g. a system manipulating queues or integers, whereas generic techniques only assume that the transition relation is represented by a finite-state transducer, which has to be iterated. In this paper, we investigate the possibility of using generic techniques in cases where only specific techniques have been exploited so far. Finding that existing generic techniques are often not applicable in cases easily handled by specific\u00a0\u2026", "num_citations": "137\n", "authors": ["1585"]}
{"title": "Handling infinite temporal data\n", "abstract": " In this paper, we present a powerful framework for describing, storing, and reasoning about infinite temporal information. This framework is an extension of classical relational databases. It represents infinite temporal information by generalized tuples defined by linear repeating points and constraints on these points. We prove that relations formed from generalized tuples are closed under the operations of relational algebra. A characterization of the expressiveness of generalized relations is given in terms of predicates definable in Presburger arithmetic. Finally, we provide some complexity results.", "num_citations": "135\n", "authors": ["1585"]}
{"title": "An automata-theoretic approach to Presburger arithmetic constraints\n", "abstract": " This paper introduces a finite-automata based representation of Presburger arithmetic definable sets of integer vectors. The representation consists of concurrent automata operating on the binary encodings of the elements of the represented sets. This representation has several advantages. First, being automata-based it is operational in nature and hence leads directly to algorithms, for instance all usual operations on sets of integer vectors translate naturally to operations on automata. Second, the use of concurrent automata makes it compact. Third, it is insensitive to the representation size of integers. Our representation can be used whenever arithmetic constraints are needed. To illustrate its possibilities we show that it can handle integer programming optimally, and that it leads to a new original algorithm for the satisfiability of arithmetic inequalities.", "num_citations": "133\n", "authors": ["1585"]}
{"title": "On the construction of automata from linear arithmetic constraints\n", "abstract": " This paper presents an overview of algorithms for constructing automata from linear arithmetic constraints. It identifies one case in which the special structure of the automata that are constructed allows a linear-time determinization procedure to be used. Furthermore, it shows through theoretical analysis and experiments that the special structure of the constructed automata does, in quite a general way, render the usual upper bounds on automata operations vastly overpessimistic.", "num_citations": "128\n", "authors": ["1585"]}
{"title": "Yet another process logic\n", "abstract": " We present a process logic that differs from the one introduced by Harel, Kozen and Parikh in several ways. First, we use the extended temporal logic of Wolper for statements about paths. Second, we allow a \u201crepeat\u201d operator in the programs. This allows us to specify programs with infinite computations. However, we limit the interaction between programs and path statements by adopting semantics similar to the ones used by Nishimura. Also, we require atomic programs to be interpreted as binary relations. We argue that this gives us a more appropriate logic. We have obtained an elementary decision procedure for our logic. The time complexity of the decision procedure is four exponentials in the general case and two exponentials if the logic is restricted to finite paths.", "num_citations": "108\n", "authors": ["1585"]}
{"title": "A temporal logic for reasoning about partially ordered computations\n", "abstract": " Current Temporal Logics are all oriented towards the description of totally ordered sequences. This limits their usefulness for reasoning about systems whose computations cannot easily be mapped into totally ordered sequences. Here, we propose a temporal logic geared towards describing partially ordered sets and apply it to dynamic distributed systems. Even though the logic we define does not have the finite model property, we establish that it has a one exponential decision procedure and a complete axiomatization.", "num_citations": "107\n", "authors": ["1585"]}
{"title": "On the representation of infinite temporal data and queries\n", "abstract": " Time is unbounded by nature. A temporal predicate (one that varies with time) will thus often have an infinite extension. To store such a predicate in a database, one can either artificially restrict its extension to a finite set or, more desirably, use a formalism that allows the finite representation of at least some infinite temporal extensions. Several such formalisms have been proposed in the past few years.The formalism that extends traditional relational databases most directly is the generalized databases described in [KSW90]. There, database tuples are extended with an arbitrary number of additional columns carrying linear repeating points. These represent periodic sets of time points possibly constrained by linear inequalities. The query language propmed in [KSW90] is a multi-sorted first-order logic in which predicates have specific temporal parameters in addition to the usual data parameters. Queries are\u00a0\u2026", "num_citations": "98\n", "authors": ["1585"]}
{"title": "Introduction \u00e0 la calculabilit\u00e9\n", "abstract": " [fr] Dans le monde de l'informatique en perp\u00e9tuelle \u00e9volution, une connaissance \u00e9l\u00e9mentaire de la th\u00e9orie de la calculabilit\u00e9 reste plus que jamais indispensable \u00e0 l'informaticien, qui se pose sans cesse la question des limites de l'informatique. La th\u00e9orie de la calculabilit\u00e9 apporte des r\u00e9ponses. Elle d\u00e9montre notamment que certains probl\u00e8mes informatiques ne peuvent pas \u00eatre r\u00e9solus par des programmes.Cet ouvrage pr\u00e9sente les \u00e9l\u00e9ments essentiels de cette science qui consiste \u00e0 \u00e9tudier ce qu'il est possible ou non de r\u00e9soudre gr\u00e2ce \u00e0 l'outil informatique, quelle que soit la machine utilis\u00e9e. Il aborde en premier lieu les langages formels, les automates et les grammaires puis introduit la notion de calculabilit\u00e9 par le biais des machines de Turing et des fonctions r\u00e9cursives. En dernier lieu, sont \u00e9tudi\u00e9es les notions de complexit\u00e9, et plus particuli\u00e8rement les probl\u00e8mes NP-complets.", "num_citations": "94\n", "authors": ["1585"]}
{"title": "On the expressiveness of real and integer arithmetic automata\n", "abstract": " If read digit by digit, a n-dimensional vector of integers represented in base r can be viewed as a word over the alphabet r                                n               . It has been known for some time that, under this encoding, the sets of integer vectors recognizable by finite automata are exactly those definable in Presburger arithmetic if independence with respect to the base is required, and those definable in a slight extension of Presburger arithmetic if only a specific base is considered.             Using the same encoding idea, but moving to infinite words, finite automata on infinite words can recognize sets of real vectors. This leads to the question of which sets of real vectors are recognizable by finite automata, which is the topic of this paper. We show that the recognizable sets of real vectors are those definable in the theory of reals and integers with addition and order, extended with a special base-dependent predicate that\u00a0\u2026", "num_citations": "92\n", "authors": ["1585"]}
{"title": "Constraint-generating dependencies\n", "abstract": " Traditionally, dependency theory has been developed for uninterpreted data. Specifically, the only assumption that is made about the data domains is that data values can be compared for equality. However, data is often interpreted and there can be advantages in considering data as such, for instance, obtaining more compact representations as is done in constraint databases. This paper considers dependency theory in the context of interpreted data. Specifically, it studies constraint-generating dependencies. These are a generalization of equality-generating dependencies where equality requirements are replaced by constraints on an interpreted domain. The main technical results in the paper are a general decision procedure for the implication and consistency problems for constraint-generating dependencies and complexity results for specific classes of such dependencies over given domains. The decision\u00a0\u2026", "num_citations": "88\n", "authors": ["1585"]}
{"title": "An effective decision procedure for linear arithmetic over the integers and reals\n", "abstract": " This article considers finite-automata-based algorithms for handling linear arithmetic with both real and integer variables. Previous work has shown that this theory can be dealt with by using finite automata on infinite words, but this involves some difficult and delicate to implement algorithms. The contribution of this article is to show, using topological arguments, that only a restricted class of automata on infinite words are necessary for handling real and integer linear arithmetic. This allows the use of substantially simpler algorithms, which have been successfully implemented.", "num_citations": "83\n", "authors": ["1585"]}
{"title": "Handling infinite temporal data\n", "abstract": " In this paper, we present a powerful framework for describing, storing, and reasoning about infinite temporal information. This framework is an extension of classical relational databases. It represents infinite temporal information by generalized tuples defined by linear repeating points and constraints on these points. We characterize the expressiveness of these generalized relations in terms of predicates definable in Presburger arithmetic. Next, we prove that relations formed from generalized tuples are closed under the operations of relational algebra and provide complexity results for the evaluation of first-order queries.", "num_citations": "77\n", "authors": ["1585"]}
{"title": "Adding liveness properties to coupled finite-state machines\n", "abstract": " Informal specifications of protocols are often imprecise and incomplete and are usually not sufficient to ensure the correctness of even very simple protocols. Consequently, formal specification methods, such as finite-state models, are increasingly being used. The selection/resolution (S/R) model is a finite-state model with a powerful communication mechanism that makes it easy to describe complex protocols as a collection of simple finite-state machines. A software environment, called SPANNER, has been developed to specify and analyze protocols specified with the S/R model. SPANNER provides the facility to compute the joint behavior of a number of finite-state machines and to check if the \u201cproduct\u201d machine has inaccessible states, states corresponding to deadlocks, and loops corresponding to livelocks. So far, however, SPANNER has had no facility to systematically deal with liveness conditions. For\u00a0\u2026", "num_citations": "70\n", "authors": ["1585"]}
{"title": "An algorithmic approach for checking closure properties of temporal logic specifications and \u03c9-regular languages\n", "abstract": " In concurrency theory, there are several examples where the interleaved model of concurrency can distinguish between execution sequences which are not significantly different. One such example is sequences that differ from each other by stuttering, i.e., the number of times a state can adjacently repeat. Another example is executions that differ only by the ordering of independently executed events. Considering these sequences as different is semantically rather meaningless. Nevertheless, specification languages that are based on interleaving semantics, such as linear temporal logic (LTL), can distinguish between them. This situation has led to several attempts to define languages that cannot distinguish between such equivalent sequences. In this paper, we take a different approach to this problem: we develop algorithms for deciding if a property cannot distinguish between equivalent sequences, i.e., is closed\u00a0\u2026", "num_citations": "62\n", "authors": ["1585"]}
{"title": "Representing arithmetic constraints with finite automata: An overview\n", "abstract": " Linear numerical constraints and their first-order theory, whether defined over the reals or the integers, are basic tools that appear in many areas of Computer Science. This paper overviews a set of techniques based on finite automata that lead to decision procedures and other useful algorithms, as well as to a normal form, for the first-order linear theory of the integers, of the reals, and of the integers and reals combined. This approach has led to an implemented tool, which has the so far unique capability of handling the linear first-order theory of the integers and reals combined.", "num_citations": "59\n", "authors": ["1585"]}
{"title": "On the use of weak automata for deciding linear arithmetic with integer and real variables\n", "abstract": " This paper considers finite-automata based algorithms for handling linear arithmetic with both real and integer variables. Previous work has shown that this theory can be dealt with by using finite automata on in finite words, but this involves some difficult and delicate to implement algorithms. The contribution of this paper is to show, using topological arguments, that only a restricted class of automata on in finite words are necessary for handling real and integer linear arithmetic. This allows the use of substantially simpler algorithms and opens the path to the implementation of a usable system for handling this combined theory.", "num_citations": "58\n", "authors": ["1585"]}
{"title": "Omega-regular model checking\n", "abstract": " \u201cRegular model checking\u201d is the name of a family of techniques for analyzing infinite-state systems in which states are represented by words or trees, sets of states by finite automata on these objects, and transitions by finite automata operating on pairs of state encodings, i.e. finite-state transducers. In this context, the central problem is then to compute the iterative closure of a finite-state transducer. This paper addresses the use of regular model-checking like techniques for systems whose states are represented by infinite (omega) words. Its main motivation is to show the feasibility and usefulness of this approach through a combination of the necessary theoretical developments, implementation, and experimentation. The iteration technique that is used is adapted from recent work of the authors on the iteration of finite-word transducers. It proceeds by comparing successive elements of a sequence of\u00a0\u2026", "num_citations": "54\n", "authors": ["1585"]}
{"title": "Partial-order methods for model checking: From linear time to branching time\n", "abstract": " Partial-order methods make it possible to check properties of a concurrent system by state-space exploration without considering all interleavings of independent concurrent events. They have been applied to linear-time model checking, but so far only limited results are known about their applicability to branching-time model checking. In this paper, we introduce a general technique for lifting partial-order methods from linear-time to branching-time logics. This technique is shown to be applicable both to reductions that are applied to the structure representing the program before running the model checking procedure, as well as to reductions that can be obtained when model checking is done in an automata-theoretic framework. The latter are extended to branching-time logics by using the model-checking framework based on alternating automata introduced by O. Bernholtz et al. (1994).", "num_citations": "52\n", "authors": ["1585"]}
{"title": "Specification and synthesis of communicating processes using an extended temporal logic: (preliminary version)\n", "abstract": " We apply an Extended Propositional Temporal Logic (EPTL) to the specification and synthesis of the synchronization part of communicating processes. To specify a process, we give an EPTL formula that describes its sequence of communications. The synthesis is done by constructing a model of the given specifications using a tableau-like satisfiability algorithm for the extended temporal logic. This model can then be interpreted as a program.", "num_citations": "52\n", "authors": ["1585"]}
{"title": "Handling liveness properties in (\u03c9-) regular model checking\n", "abstract": " Since the topic emerged several years ago, work on regular model checking has mostly been devoted to the verification of state reachability and safety properties. Though it was known that liveness properties could also be checked within this framework, little has been done about working out the corresponding details, and experimentally evaluating the approach. This paper addresses these issues in the context of regular model checking based on the encoding of states by finite or infinite words. It works out the exact constructions to be used in both cases, and solves the problem resulting from the fact that infinite computations of unbounded configurations might never contain the same configuration twice, thus making cycle detection problematic. Several experiments showing the applicability of the approach were successfully conducted.", "num_citations": "45\n", "authors": ["1585"]}
{"title": "An automata-based symbolic approach for verifying programs on relaxed memory models\n", "abstract": " This paper addresses the problem of verifying programs for the relaxed memory models implemented in modern processors. Specifically, it considers the TSO (Total Store Order) relaxation, which corresponds to the use of store buffers. The proposed approach proceeds by using finite automata to symbolically represent the possible contents of the store buffers. Store, load and commit operations then correspond to operations on these finite automata.               The advantage of this approach is that it operates on (potentially infinite) sets of buffer contents, rather than on individual buffer configurations. This provides a way to tame the explosion of the number of possible buffer configurations, while preserving the full generality of the analysis. It is thus possible to check even designs that exploit the relaxed memory model in unusual ways. An experimental implementation has been used to validate the feasibility\u00a0\u2026", "num_citations": "42\n", "authors": ["1585"]}
{"title": "A verification-based approach to memory fence insertion in relaxed memory systems\n", "abstract": " This paper addresses the problem of verifying and correcting programs when they are moved from a sequential consistency execution environment to a relaxed memory context. Specifically, it considers the TSO (Total Store Order) relaxation, which corresponds to the use of store buffers, and its extension x86-TSO, which in addition allows synchronization and lock operations.               The proposed approach uses a previously developed verification tool that uses finite automata to symbolically represent the possible contents of the store buffers. Its starting point is a program that is correct for the usual sequential consistency memory model, but that might be incorrect under x86-TSO. This program is then analyzed for this relaxed memory model and when errors are found (with respect to safety properties), memory fences are inserted in order to avoid these errors. The approach proceeds iteratively and\u00a0\u2026", "num_citations": "41\n", "authors": ["1585"]}
{"title": "Reasoning about fair concurrent programs\n", "abstract": " We investigate the use of branching time temporal logic to reason about fair programs. Our approach is novel in viewing fairness conditions as an intrinsic part of the computations rather than as a part of the formulas specifying the computations. Our first result is that the branching time logic of fair programs is the same as the branching time logic of probabilistic programs and as the logic of fusion-and suffix-closed programs defined by Abrahamson. Next we give decision procedures for the temporal logic of fair programs using a new type of automata on infinite trees. Matching upper and lower bounds for two different versions of branching time temporal logic are established", "num_citations": "41\n", "authors": ["1585"]}
{"title": "A verification-based approach to memory fence insertion in PSO memory systems\n", "abstract": " This paper addresses the problem of verifying and correcting programs when they are moved from a sequential consistency execution environment to a relaxed memory context. Specifically, it considers the PSO (Partial Store Order) memory model, which corresponds to the use of a store buffer for each shared variable and each process. We also will consider, as an intermediate step, the TSO (Total Store Order) memory model, which corresponds to the use of one store buffer per process.               The proposed approach extends a previously developed verification tool that uses finite automata to symbolically represent the possible contents of the store buffers. Its starting point is a program that is correct for the usual Sequential Consistency (SC) memory model, but that might be incorrect under PSO with respect to safety properties. This program is then first analyzed and corrected for the TSO memory model\u00a0\u2026", "num_citations": "33\n", "authors": ["1585"]}
{"title": "The meaning of \u201cformal\u201d: from weak to strong formal methods\n", "abstract": " This short note reflects on what makes formal methods \u201cformal\u201d. It concludes that there are weak and strong ways of being formal, the latter being linked to the formality of the method being exploitable, and exploited, in software tools.", "num_citations": "31\n", "authors": ["1585"]}
{"title": "An algorithmic approach for checking closure properties of \u03c9-regular languages\n", "abstract": " In concurrency theory, there are several examples where the interleaved model of concurrency can distinguish between execution sequences which are not significantly different. One such example is sequences that differ from each other by stuttering, i.e., the number of times a state can adjacently repeat. Another example is executions that differ only by the ordering of independently executed events. Considering these sequences as different is semantically rather meaningless. Nevertheless, specification languages that are based on interleaving semantics, such as linear temporal logic (LTL), can distinguish between them. This situation has led to several attempts to define languages that cannot distinguish between such equivalent sequences. In this paper, we take a different approach to this problem: we develop algorithms for deciding if a property cannot distinguish between equivalent sequences, i. e., is\u00a0\u2026", "num_citations": "30\n", "authors": ["1585"]}
{"title": "Relative liveness and behavior abstraction\n", "abstract": " This paper is motivated by the fact that verifying liveness properties under a fairness condition is often problematic, especially when abstraction is used. It shows that using a more abstract notion than truth under fairness, specifically the concept of relative liveness property can lead to interesting possibilities. Technically, it is first established that deciding relative liveness is a PSPACE-complete problem and it is shown that relative liveness properties ca aiways be satisfied by some fair implementation. Thereafter, the interaction between behavior abstraction and relative Iiveness properties is studied and it is proved that relative liveness properties can be verified on behavior abstractions, if the abstracting homomorphism is simple in the sense of Ochsenschlager.", "num_citations": "29\n", "authors": ["1585"]}
{"title": "Temporal logic\n", "abstract": " Temporal Logic - Gribomont Pascal Open Repository and Bibliography Home Other OA projects at the University Help? University of Li\u00e8ge | Library Network | Login | You are here: ORBi Detailled reference Reference : Temporal Logic Document type : Parts of books : Contribution to collective works Discipline(s) : Engineering, computing & technology : Computer science To cite this reference: http://hdl.handle.net/2268/184448 Title : Temporal Logic Language : English Author, co-author : Gribomont, Pascal mailto [Universit\u00e9 de Li\u00e8ge > D\u00e9p. d'\u00e9lectric., \u00e9lectron. et informat. (Inst.Montefiore) > Informatique et intelligence artificielle >] Wolper, Pierre mailto [Universit\u00e9 de Li\u00e8ge > D\u00e9p. d'\u00e9lectric., \u00e9lectron. et informat. (Inst.Montefiore) > Informatique (parall\u00e9lisme et banques de donn\u00e9es) >] Publication date : 1989 Main document title : From Modal Logic to Deductive Databases Publisher : John Wiley and Sons Peer reviewed : \u2026", "num_citations": "14\n", "authors": ["1585"]}
{"title": "An introduction to model checking\n", "abstract": " Verifying a program is proving, in a formal mathematical way, that the program satis es a specication written in a logical language. Though veri cation has often been claimed to be a promising approach for ensuring the correctness of software, almost 30 years of research, starting with the work of Floyd Flo67] and Hoare Hoa69], have failed to deliver a widely usable technology. There are at least two reasons for this.First, one should remember that veri cation is comparing two descriptions of what the program should do: the program itself and a logical speci cation, which is in principle shorter and more abstract. For a complex system, the logical speci cation can nevertheless be very large and di cult to obtain. Its correctness is thus often nonobvious, which renders hypothetical the certainty that veri cation appears to o er. Second, the veri cation process requires very long proofs. These can require far more time than writing the program itself, and are very prone to error. Indeed, they are too speci c and boring to be checked reliably by humans, and theorem-proving technology requires too much expertise and is not yet su ciently powerful to be widely usable.", "num_citations": "13\n", "authors": ["1585"]}
{"title": "Reasoning about cryptographic protocols\n", "abstract": " We present a modelization of the probabilistic knowledge of the participants in cryptographic protocols. This modelization can be used to establish the security of the protocols. It is based on the assumption that the underlying cryptographic system is perfect and is an extension of the", "num_citations": "12\n", "authors": ["1585"]}
{"title": "A tutorial on partial-order methods for the verification of concurrent systems\n", "abstract": " CiNii \u8ad6\u6587 - A Tutorial on Partial-Order Methods for the Verification of Concurrent Systems CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74 \u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u306e\u30b5\u30fc\u30d3\u30b9\u306b\u95a2\u3059\u308b\u30a2\u30f3\u30b1\u30fc\u30c8\u3092\u5b9f\u65bd\u4e2d\u3067\u3059\uff0811/11(\u6c34)-12/23(\u6c34)\uff09 CiNii Research\u30d7\u30ec\u7248\u306e\u516c\u958b\u306b\u3064\u3044\u3066 A Tutorial on Partial-Order Methods for the Verification of Concurrent Systems WOLPER P. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 WOLPER P. \u53ce\u9332\u520a\u884c\u7269 Computer Aided Verification '93 Tutorial Computer Aided Verification '93 Tutorial, 1993 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u534a\u9806\u5e8f\u6cd5\u306b\u3088\u308b\u4e26\u884c\u30b7\u30b9\u30c6\u30e0\u306e\u52b9\u7387\u7684\u306a\u691c\u8a3c\u306b\u3064\u3044\u3066 \u5e73\u77f3 \u90a6\u5f66 \u96fb\u5b50\u60c5\u5831\u901a\u4fe1\u5b66\u4f1a \u6280\u8853\u7814\u7a76\u5831\u544a. CST, \u30b3\u30f3\u30ab\u30ec\u30f3\u30c8\u5de5\u5b66 96(204), 1-7, 1996-07-26 \u53c2\u8003\u6587\u732e11\u4ef6 \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u2026", "num_citations": "11\n", "authors": ["1585"]}
{"title": "From modal logic to deductive databases: introducing a logic based approach to artificial intelligence\n", "abstract": " Advances the study of artificial intelligence concepts and applications using logic as a guideline. Examines such topics as natural and formal languages; modal logic; temporal logic and specification of concurrent programs; theory of relational and deductive databases; intensional logic and Montague's Semantics; representation of incomplete information in databases and much more.", "num_citations": "11\n", "authors": ["1585"]}
{"title": "Computing convex hulls by automata iteration\n", "abstract": " This paper considers the problem of computing the real convex hull of a finite set of n-dimensional integer vectors. The starting point is a finite-automaton representation of the initial set of vectors. The proposed method consists in computing a sequence of automata representing approximations of the convex hull and using extrapolation techniques to compute the limit of this sequence. The convex hull can then be directly computed from this limit in the form of an automaton-based representation of the corresponding set of real vectors. The technique is quite general and has been implemented. Also, our result fits in a wider scheme whose objective is to improve the techniques for converting automata-based representation of constraints to formulas.", "num_citations": "9\n", "authors": ["1585"]}
{"title": "Automata theoretic techniques for modal logics of programs\n", "abstract": " We describe an automata-theoretic approach to automatic verification of concurrent finite-state programs by model checking. The basic idea underlying this approach is that for any temporal formula we can construct an automaton that accepts precisely the compu-tations that satisfy the formula. The model-checking algorithm that results from this approach is much simpler and cleaner than tableau-based algorithms. We use this approach to extend model-checking to probabilistic concurrent finite-state programs.", "num_citations": "8\n", "authors": ["1585"]}
{"title": "On (omega-) regular model checking\n", "abstract": " Checking infinite-state systems is frequently done by encoding infinite sets of states as regular languages. Computing such a regular representation of, say, the set of reachable states of a system requires acceleration techniques that can finitely compute the effect of an unbounded number of transitions. Among the acceleration techniques that have been proposed, one finds both specific and generic techniques. Specific techniques exploit the particular type of system being analyzed, for example, a system manipulating queues or integers, whereas generic techniques only assume that the transition relation is represented by a finite-state transducer, which has to be iterated. In this article, we investigate the possibility of using generic techniques in cases where only specific techniques have been exploited so far. Finding that existing generic techniques are often not applicable in cases easily handled by specific\u00a0\u2026", "num_citations": "7\n", "authors": ["1585"]}
{"title": "Reasoning about fair concurrent programs\n", "abstract": " We investigate the use of branching time temporal logic to reason about fair programs. Our approach is novel in viewing fairness conditions as an intrinsic part of the computations rather than as a part of the formulas specifying the computations. Our first result is that the branching time logic of fair programs is the same as the branching time logic of probabilistic programs and as the logic of fusion-and suffix-closed prograns defined by Abrahamson. Next we give decision procedures for the temporal logic of fair programs using a new type of auto-nata on infinite trees. Matching upper and lower bounds for two different versions of branching time temporal logic are established", "num_citations": "7\n", "authors": ["1585"]}
{"title": "The meaning of \u201cformal\u201d\n", "abstract": " When is a method formal? It is somewhat surprising that this simple question is rarely asked when discussing formal methods research. After all, we know when a method is formal, don't we? Nevertheless, let us try to define formality. First, notice that the\" formal\" in\" formal methods\" usually refers to the language in which one writes specifications. So a formal method is one based on a formal specification language. When we talk of formal languages, we usually mean languages whose sentences are defined in a mathematically precise way. I would go slightly further and require that the sentences be recognizable algorithmically.So, is a formal method one that is based on a specification language with algorithmically recognizable sentences? Essentially all existing formal methods do satisfy this definition. However I believe it is much too weak. Indeed, while it is clearly useful to have a language with a checkable\u00a0\u2026", "num_citations": "5\n", "authors": ["1585"]}
{"title": "Reliable probabilistic verification using hash compaction\n", "abstract": " This paper describes and analyzes a probabilistic technique to reduce the memory requirement of the table of reached states maintained in veri cation by explicit state enumeration. The memory savings of the new scheme come at the price of a certain probability that the search becomes incomplete. However, this probability can be made negligibly small by using typically 40 bits of memory per state. From this point of view, this new scheme improves substantially on Holzmann's bitstate hashing, which has a high probability of producing an incomplete search even when using close to 1000 bits per state. The proposed scheme has been implemented in the contexts of the SPIN and Mur'veri cation systems. Experiments on sample protocols nicely match the predictions of the analysis. For large protocols, memory savings of two orders of magnitude are obtained. We also show how to e ciently combine the new scheme with state space caching, and we analyze bitstate hashing in order to compare it with the new scheme.", "num_citations": "5\n", "authors": ["1585"]}
{"title": "Where could SPIN go next? A unifying approach to exploring infinite state spaces\n", "abstract": " Where could SPIN go next? A unifying approach to exploring in nite state spaces Page 1 Where could SPIN go next? A unifying approach to exploring in nite state spaces Pierre Wolper University of Li ege 1 in order to verify in nite state systems ? Reachability, Reachability, Reachability, and repeated reachability. Why ? It is necessary : if you cannot determine what states are reachable, there is not much you can do. It is su cient : most veri cation problems are reducible to reachability or repeated reachability. 2 Reducing veri cation to reachability Linear-time model checking Verify that all the computations of a program P satisfy a temporal logic speci cation f Solution VW86]. Build the automaton for :f: A:f Check whether there is a reachable accepting state in the product PA:f (safety properties), or Check whether there is a repeatedly reachable accepting state in the product PA:f (general properties). 3 Reducing veri \u2026", "num_citations": "4\n", "authors": ["1585"]}
{"title": "Where is the algorithmic support?\n", "abstract": " Where's the algorithmic support? This is quite a natural question to ask in computer science research, but one that has not always been adequately addressed in concurrency theory research. This position statement argues that it should always be present in our minds when pursuing such research. Of course, much work in concurrency theory has led to algorithms, and one clearly needs to understand the structures one is talking about before finding algorithms to manipulate them. But, the latter point should not be taken as a blank check for eluding indefinitely the algorithmic support question. After all, a model starts to have real value when it can be used for analytical or synthetic computations.The algorithmic support of concurrency theories need be neither immediate nor direct. A semantics can eventually lead to a reliable compiler. Temporal logic was studied for several years before algorithmic synthesis and\u00a0\u2026", "num_citations": "4\n", "authors": ["1585"]}
{"title": "On the use of automata for deciding linear arithmetic\n", "abstract": " This talk presents a survey of automata-based techniques for representing and manipulating linear arithmetic constraints. After introducing the basic concepts used in this approach, both representing integer constraints by finite-word automata and real constraints by infinite-word automata is discussed. Various results about the construction of automata from constraints and about the specific properties of automata representing arithmetic constraints are then presented. Finally, it is shown how this approach leads to simple and natural decision procedures that are in some ways related to tableaux.", "num_citations": "3\n", "authors": ["1585"]}
{"title": "Linear repeating points\n", "abstract": " Temporal databases have been a research subject for many years, though one might wonder why so much attention has been devoted to this topic; indeed, time can easily be introduced as additional attributes in the relational model. Of course, specific operations need to be performed with temporal attributes, such as dealing with date formats, but such operations are not really problematic, and have long been available in commercial systems. Nevertheless, the feeling remains that time is special. Clearly, introducing time in a database requires some thought: Is one going to deal with valid time, transaction time, or both; is the basic unit a point or an interval; is time continuous or discrete; if discrete, what is the basic granularity? Nevertheless, once these questions have been answered, a direct representation by additional attributes appears at first to be adequate. With respect to querying, however, the need to\u00a0\u2026", "num_citations": "3\n", "authors": ["1585"]}
{"title": "A Framework to Handle Linear Temporal Properties in (\\omega-) Regular Model Checking\n", "abstract": " Since the topic emerged several years ago, work on regular model checking has mostly been devoted to the verification of state reachability and safety properties. Though it was known that linear temporal properties could also be checked within this framework, little has been done about working out the corresponding details. This paper addresses this issue in the context of regular model checking based on the encoding of states by finite or infinite words. It works out the exact constructions to be used in both cases, and proposes a partial solution to the problem resulting from the fact that infinite computations of unbounded configurations might never contain the same configuration twice, thus making cycle detection problematic.", "num_citations": "2\n", "authors": ["1585"]}
{"title": "Representing periodic temporal information with automata\n", "abstract": " [en] Motivated by issues in temporal databases and in the verification of infinite-state systems, this talk considers the", "num_citations": "2\n", "authors": ["1585"]}
{"title": "On the Relation of Programs and Computations to Models of Temporal Logic [chap. 3]\n", "abstract": " On the Relation of Programs and Computations to Models of Temporal Logic [chap. 3] - Wolper Pierre Open Repository and Bibliography Home Other OA projects at the University Help? University of Li\u00e8ge | Library Network | Login | You are here: ORBi Detailled reference Reference : On the Relation of Programs and Computations to Models of Temporal Logic [chap. 3] Document type : Parts of books : Contribution to collective works Discipline(s) : Engineering, computing & technology : Computer science To cite this reference: http://hdl.handle.net/2268/163845 Title : On the Relation of Programs and Computations to Models of Temporal Logic [chap. 3] Language : English Author, co-author : Wolper, Pierre mailto [Universit\u00e9 de Li\u00e8ge - ULi\u00e8ge > D\u00e9p. d'\u00e9lectric., \u00e9lectron. et informat. (Inst.Montefiore) > Informatique (parall\u00e9lisme et banques de donn\u00e9es) >] Publication date : 1995 Main document title : Time and Logic, a \u2026", "num_citations": "2\n", "authors": ["1585"]}
{"title": "TEMPORA: a temporal database transaction system\n", "abstract": " TEMPORA is an ESPRIT project which aims to integrate rule-based systems database technology and temporal reasoning to produce effective software for information systems. As part of this project, a temporal database transaction system, is being developed. This is based on earlier work on executable temporal logic systems. This report describes the syntax and semantics of the temporal language which is being used in the prototype implementation of TEMPORA, together with an informal description of the execution mechanism employed.< >", "num_citations": "2\n", "authors": ["1585"]}
{"title": "Automata theoretic techniques for modal logics of programs:(Extended abstract)\n", "abstract": " We present a new technique for obtaining decision procedures for modal logics of programs. The technique centers around a new class of finite automata on infinite trees for which the emptiness problem can be solved in polynomial time. The decision procedures then consist of constructing an automaton Af for a given formula f, such that Af accepts some tree if and only if f is satisfiable. We illustrate our technique by giving an exponential decision procedure for deterministic propositional dynamic logic and a variant of the &mgr-calculus of Kozen.", "num_citations": "2\n", "authors": ["1585"]}
{"title": "Computing convex hulls by automata iteration\n", "abstract": " This paper considers the problem of computing the real convex hull of a finite set of n-dimensional integer vectors. The starting point is a finite-automaton representation of the initial set of vectors. The proposed method consists in computing a sequence of automata representing approximations of the convex hull and using extrapolation techniques to compute the limit of this sequence. The convex hull can then be directly computed from this limit in the form of an automaton-based representation of the corresponding set of real vectors. The technique is quite general and has been implemented.", "num_citations": "1\n", "authors": ["1585"]}
{"title": "Introduction to the Theory of Computation\n", "abstract": " Introduction to the Theory of Computation Page 1 Introduction to the Theory of Computation Pierre Wolper Email: Pierre.Wolper@ulg.ac.be URL: http: //www.montefiore.ulg.ac.be/~pw/ http: //www.montefiore.ulg.ac.be/ ~pw/cours/calc.html References Pierre Wolper, Introduction `a la calculabilit\u00e9 - 3i`eme \u00e9dition, Dunod, 2006. Michael Sipser, Introduction to the Theory of Computation, Second Edition, Course Technology, 2005 1 Page 2 Chapter 1 Introduction 2 Page 3 1.1 Motivation \u2022 To understand the limits of computer science. \u2022 To distinguish problems that are solvable by algorithms from those that are not. \u2022 To obtain results that are independent of the technology used to build computers. 3 Page 4 1.2 Problems and Languages \u2022 Which problems can be solved by a program executed by a computer? We need to be more precise about: \u2013 the concept of problem, \u2013 the concept of program executed by a computer. 4 \u2026", "num_citations": "1\n", "authors": ["1585"]}
{"title": "Checking Properties within Fairness and Behavior Abstractions\n", "abstract": " This paper is motivated by the fact that verifying liveness properties under a fairness condition is often problematic, especially when abstraction is used. It shows that using a more abstract notion than truth under fairness, specifically the concept of a property being satisfied within fairness can lead to interesting possibilities. Technically, it is first established that deciding satisfaction within fairness is a PSPACE-complete problem and it is shown that properties satisfied within fairness can always be satisfied by some fair implementation. Thereafter, the interaction between behavior abstraction and satisfaction within fairness is studied and it is proved that satisfaction of properties within fairness can be verified on behavior abstractions, if the abstraction homomorphism is weakly continuation-closed.", "num_citations": "1\n", "authors": ["1585"]}
{"title": "Algorithms for synthesizing reactive systems: A perspective\n", "abstract": " Algorithms for Synthesizing Reactive Systems: A Perspective Page 1 Algorithms for Synthesizing Reactive Systems: A Perspective Pierre Wolper Universit e de Li ege 1 Page 2 How it all Started Temporal logic was proposed in 1977 by Amir Pnueli as a language for specifying and verifying concurrent and reactive systems. Initially, rst-order temporal logic was the focus. Later, interest in propositional temporal logic started to grow for several reasons: { It is already an interesting and expressive formalism, { It is decidable, { Its decision procedure, though of exponential complexity, is fairly simple and can be implemented. It was then seen that this decision procedure could be adapted to synthesize programs from propositional temporal logic speci cations. 2 Page 3 (Linear-Time) Temporal logic: A Brief Overview Formulas built from a set of propositions P, Boolean connectives :, ^, _, and the temporal operators , 2, 3, and U. \u2026", "num_citations": "1\n", "authors": ["1585"]}
{"title": "Protocol Specification, Testing and Verification, XIII: Proceedings of the IFIP TC6/WG6. 1. Thirteenth International Symposium on Protocol Specification, Testing and\u00a0\u2026\n", "abstract": " Protocol Specification, Testing and Verification (PSTV) brings together contributions from researchers and practitioners interested in the application of formal methods to the design, description, analysis, implementation and testing of complex and safety-critical systems such as distributed systems or communication protocols and services. The 20 selected papers included in this publication provide a comprehensive account of the current state-of-the-art in this field. They consider, in particular, protocol engineering, improvement of formal methods, verification and synthesis methods, conformance testing and application to real case studies. Two invited papers complete the volume and address the industrial applicability of the techniques. Researchers, computer scientists and post-graduate students concerned with data communications and computer networks should find the book offers a valuable insight into this rapidly developing arena.", "num_citations": "1\n", "authors": ["1585"]}
{"title": "Temporal databases: Beyond finite extensions (position paper)\n", "abstract": " [en] We argue that temporal databases should not be restricted to relations with finite extensions. many temporal events are periodic and have no natural bounds. Moreover, such events have a more compact representation when allowed to be unbounded. We present two formalisms for representing and querying possibly infinite periodic data and discuss some of their properties, including expressiveness and query evaluation complexity. Finally, we turn to implementation issues and argue that significant extensions to existing database systems are necessary in order to implement the frameworks we describe.", "num_citations": "1\n", "authors": ["1585"]}
{"title": "An automata-theoretic approach to automatic program verification (preliminary report)\n", "abstract": " We describe an automata-theoretic approach to automatic verification of concurrent finite-state pro grams by model checking. The basic idea underlying this approach is that for any temporal formula we can construct an automaton that accepts precisely the computations that satisfy the formula. The model-checking algorithm that results from this approach is much simpler and cleaner than tableau-based algorithms. We use this approach to extend model checking to probabilistic concurrent finite-state programs.", "num_citations": "1\n", "authors": ["1585"]}