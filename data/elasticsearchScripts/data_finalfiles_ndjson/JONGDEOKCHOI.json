{"title": "Escape analysis for Java\n", "abstract": " This paper presents a simple and efficient data flow algorithm for escape analysis of objects in Java programs to determine (i) if an object can be allocated on the stack; (ii) if an object is accessed only by a single thread during its lifetime, so that synchronization operations on that object can be removed. We introduce a new program abstraction for escape analysis, the connection graph, that is used to establish reachability relationships between objects and object references. We show that the connection graph can be summarized for each method such that the same summary information may be used effectively in different calling contexts. We present an interprocedural algorithm that uses the above property to efficiently compute the connection graph and identify the non-escaping objects for methods and threads. The experimental results, from a prototype implementation of our framework in the IBM High\u00a0\u2026", "num_citations": "654\n", "authors": ["268"]}
{"title": "Hybrid dynamic data race detection\n", "abstract": " We present a new method for dynamically detecting potential data races in multithreaded programs. Our method improves on the state of the art in accuracy, in usability, and in overhead. We improve accuracy by combining two previously known race detection techniques--lockset-based detection and happens-before-based detection--to obtain fewer false positives than lockset-based detection alone. We enhance usability by reporting more information about detected races than any previous dynamic detector. We reduce overhead compared to previous detectors--particularly for large applications such as Web application servers--by not relying on happens-before detection alone, by introducing a new optimization to discard redundant information, and by using a\" two phase\" approach to identify error-prone program points and then focus instrumentation on those points. We justify our claims by presenting the results\u00a0\u2026", "num_citations": "514\n", "authors": ["268"]}
{"title": "Method and system for recording and replaying the execution of distributed java programs\n", "abstract": " A method for recording and replaying execution of distributed programs on a computer system in a distributed environment, includes identifying an execution order of critical events of a program, generating groups of critical events of the program, wherein for each group, critical events belonging to the group belong to a common execution thread, and generating for each execution thread a logical thread schedule that identifies a sequence of the groups so as to allow deterministically replaying a non-deterministic arrival of stream socket connection requests, a non-deterministic number of bytes received during message reads, and a non-deterministic binding of stream sockets to local ports.", "num_citations": "330\n", "authors": ["268"]}
{"title": "Deterministic replay of Java multithreaded applications\n", "abstract": " Threads and concurrency constructs in Java introduce nondeterminism to a program\u2019s execution, which makes it hard to understand and analyze the execution behavior. Nondeterminism in execution behavior also makes it impossible to use execution replay for debugging, performance monitoring, or visualization. This paper discusses a record/replay tool for Java, DejaVu, that provides deterministic replay of a program\u2019s execution. In particular, this paper describes the idea of the logical thread schedule, which makes DejaVu efficient and independent of the underlying thread scheduler. The paper also discusses how to handle the various Java synchronization operations for record and replay. DejaVu has been implemented by modifying the Sun Microsystems\u2019 Java Virtual Machine.", "num_citations": "329\n", "authors": ["268"]}
{"title": "Automatic construction of sparse data flow evaluation graphs\n", "abstract": " In this paper, we present an algorithm that constructs sparse evaluation graphs for forward or backward monotone data flow problems. The sparse graph combines information as early as possible, yet directly connects nodes that generate and use information. This allows problems from the large, general class of monotone data flow problems to err joy the advantages of solutions based on Static Single Assignment(SSA) form.", "num_citations": "285\n", "authors": ["268"]}
{"title": "Deterministic replay of multithreaded applications\n", "abstract": " A multithreaded program includes sequences of events wherein each sequence is associated with one of a plurality of execution threads. In a record mode, the software tool of the present invention records a run-time representation of the program by distinguishing critical events from non-critical events of the program and identifying the execution order of such critical events. Groups of critical events are generated wherein, for each group G i, critical events belonging to the group G i belong to a common execution thread, critical events belonging to the group G i are consecutive, and only non-critical events occur between any two consecutive critical events in the group G i. In addition, the groups are ordered and no two adjacent groups include critical events that belong to a common execution thread. For each execution thread, a logical thread schedule is generated that identifies a sequence of said groups\u00a0\u2026", "num_citations": "173\n", "authors": ["268"]}
{"title": "Static slicing in the presence of goto statements\n", "abstract": " A static program slice is an extract of a program which can help our understanding of the behavior of the program; it has been proposed for use in debugging, optimization, parallelization, and integration of programs. This article considers two types of static slices: executable and nonexecutable. Efficient and well-founded methods have been developed to construct executable slices for programs without goto statements; it would be tempting to assume these methods would apply as well in programs with arbitrary goto statements. We show why previous methods do not work in this more general setting, and describe our solutions that correctly and efficiently compute executable slices for programs even with arbitrary goto statements. Our conclusion is that goto statements can be  accommodated in generating executable static slices.", "num_citations": "145\n", "authors": ["268"]}
{"title": "Accurate, efficient, and adaptive calling context profiling\n", "abstract": " Calling context profiles are used in many inter-procedural code optimizations and in overall program understanding. Unfortunately, the collection of profile information is highly intrusive due to the high frequency of method calls in most applications. Previously proposed calling-context profiling mechanisms consequently suffer from either low accuracy, high overhead, or both. We have developed a new approach for building the calling context tree at runtime, called adaptive bursting. By selectively inhibiting redundant profiling, this approach dramatically reduces overhead while preserving profile accuracy. We first demonstrate the drawbacks of previously proposed calling context profiling mechanisms. We show that a low-overhead solution using sampled stack-walking alone is less than 50% accurate, based on degree of overlap with a complete calling-context tree. We also show that a static bursting approach\u00a0\u2026", "num_citations": "143\n", "authors": ["268"]}
{"title": "Stack allocation and synchronization optimizations for Java using escape analysis\n", "abstract": " This article presents an escape analysis framework for Java to determine (1) if an object is not reachable after its method of creation returns, allowing the object to be allocated on the stack, and (2) if an object is reachable only from a single thread during its lifetime, allowing unnecessary synchronization operations on that object to be removed. We introduce a new program abstraction for escape analysis, the connection graph, that is used to establish reachability relationships between objects and object references. We show that the connection graph can be succinctly summarized for each method such that the same summary information may be used in different calling contexts without introducing imprecision into the analysis. We present an interprocedural algorithm that uses the above property to efficiently compute the connection graph and identify the nonescaping objects for methods and threads. The\u00a0\u2026", "num_citations": "142\n", "authors": ["268"]}
{"title": "Race frontier: Reproducing data races in parallel-program debugging\n", "abstract": " A data race is a typical case of unintended nondeterminism, which occurs when two or more processes concurrently access the same memory location, with at least one of the accesses being awrite access. This paper presents a mechanism to debug data races in the execution of parallel programs. Arace FRONTIER is a set of execution events, one event for each process, whose execution histories, including data races preceding them, can be reproduced. Data races can be debugged by first identifying a RACE FRONTIER and then reproducing all the events, including data-race events? up to the RACE FRONTIER. Reproducing and debugging data races up to a RACE FRONTIER will eventually result in an execution instance without any data races. This paper describes how to identify a RACE FRONTIER and how to reproduce the execution history of data races u~ p to the RACE FRONTIER.", "num_citations": "123\n", "authors": ["268"]}
{"title": "An efficient cache-based access anomaly detection scheme\n", "abstract": " One important issue in parallel program debugging is the efficient detection of access anomalies caused by uncoordinated accesses to shared variables. On-the-fly detection of access anomalies has two advantages over static analysis or post-mortem trace analysis. First, it reports only actual anomalies during execution. Second, it produces shorter traces for post-mortem analysis purposes if an anomaly is detected, since generating further trace information after the detection of an anomaly is of dubious value. Existing methods for on-the-fly access anomaly detection suffer from performance penalties since the execution of the program being debugged has to be interrupted on every access to shared variables. In this paper, we propose an efficient cachebased access anomaly detection scheme that piggybacks on the overhead already paid by the underlying cache coherence protocol.", "num_citations": "117\n", "authors": ["268"]}
{"title": "Method for optimizing creation and destruction of objects in computer programs\n", "abstract": " Information is computed about the reachability relationships among objects and pointers to enable transformation of a computer program for optimizing the creation and destruction of objects, while strictly performing the semantics of the original program. An interprocedural analysis is used to determine whether an object that is allocated on the heap during the execution of a procedure is not reachable from any global variable, parameter, or the return value of the procedure after it returns. If so, that object can be allocated on the stack frame of the procedure in which it is otherwise heap-allocated. This simplifies the memory allocation and deallocation operations, as allocation on the stack can be done more efficiently than allocation on the heap, and objects allocated on the stack frame of a procedure are automatically deallocated when the procedure returns, without incurring the overhead of garbage collection. This\u00a0\u2026", "num_citations": "114\n", "authors": ["268"]}
{"title": "Deterministic replay of distributed java applications\n", "abstract": " Execution behavior of a Java application can be nondeterministic due to concurrent threads of execution, thread scheduling, and variable network delays. This nondeterminism in Java makes the understanding and debugging of multi-threaded distributed Java applications a difficult and a laborious process. It is well accepted that providing deterministic replay of application execution is a key step towards programmer productivity and program under-standing. Towards this goal, we developed a replay framework based on logical thread schedules and logical intervals. An application of this framework was previously published in the context of a system called Deja Vu that provides deterministic replay of multi-threaded Java programs on a single Java Virtual Machine (JVM). In contrast, this paper focuses on distributed Deja Vu that provides deterministic replay of distributed Java applications running on multiple JVMs\u00a0\u2026", "num_citations": "103\n", "authors": ["268"]}
{"title": "Slicing class hierarchies in C++\n", "abstract": " This paper describes an algorithm for slicing class hierarchies in C++ programs. Given a C++ class hierarchy (a collection of C++ classes and inheritance relations among them) and a program P that uses the hierarchy, the algorithm eliminates from the hierarchy those data members, member functions, classes, and inheritance relations that are unnecessary for ensuring that the semantics of P is maintained. Class slicing is especially useful when the program P is generated from a larger program P'by a statement slicing algorithm. Such an algorithm eliminates statements that are irrelevant to a set of slicing criteria---program points of particular interest. There has been considerable previous work on statement slicing, and it will not be the concern of this paper. However, the combination of statement slicing and class slicing for C++ has two principal applications: First, class slicing can enhance statement slicing's utility\u00a0\u2026", "num_citations": "96\n", "authors": ["268"]}
{"title": "Method and apparatus for deterministic replay of java multithreaded programs on multiprocessors\n", "abstract": " A method (and apparatus) of determinstically replaying an observable run-time behavior of distributed multi-threaded programs on multiprocessors in a shared-memory multiprocessor environment, wherein a run-time behavior of the programs includes sequences of events, each sequence being associated with one of a plurality of execution threads, includes identifying an execution order of critical events of the program, wherein the program includes critical events and non-critical events, generating groups of critical events of the program, generating, for each given execution thread, a logical thread schedule that identifies a sequence of the groups associated with the given execution thread, and storing the logical thread schedule for subsequent reuse.", "num_citations": "91\n", "authors": ["268"]}
{"title": "Method for optimizing locks in computer programs\n", "abstract": " A method and several variants for using information about the scope of access of objects acted upon by mutual exclusion, or mutex, locks to transform a computer program by eliminating locking operations from the program or simplifying the locking operations, while strictly performing the semantics of the original program. In particular, if it can be determined by a compiler that the object locked can only be accessed by a single thread it is not necessary to perform the \u201cacquire\u201d or \u201crelease\u201d part of the locking operation, and only its side effects must be performed. Likewise, if it can be determined that the side effects of a locking operation acting on a variable which is locked in multiple threads are not needed, then only the locking operation, and not the side effects, needs to be performed. This simplifies the locking operation, and leads to faster programs which use fewer computer processor resources to execute; and\u00a0\u2026", "num_citations": "90\n", "authors": ["268"]}
{"title": "An OpenCL framework for heterogeneous multicores with local memory\n", "abstract": " In this paper, we present the design and implementation of an Open Computing Language (OpenCL) framework that targets heterogeneous accelerator multicore architectures with local memory. The architecture consists of a general-purpose processor core and multiple accelerator cores that typically do not have any cache. Each accelerator core, instead, has a small internal local memory. Our OpenCL runtime is based on software-managed caches and coherence protocols that guarantee OpenCL memory consistency to overcome the limited size of the local memory. To boost performance, the runtime relies on three source-code transformation techniques, work-item coalescing, web-based variable expansion and preload-poststore buffering, performed by our OpenCL C source-to-source translator. Work-item coalescing is a procedure to serialize multiple SPMD-like tasks that execute concurrently in the presence\u00a0\u2026", "num_citations": "87\n", "authors": ["268"]}
{"title": "Finding and removing performance bottlenecks in large systems\n", "abstract": " Software systems obey the 80/20 rule: aggressively optimizing a vital few execution paths yields large speedups. However, finding the vital few paths can be difficult, especially for large systems like web applications. This paper describes a novel approach to finding bottlenecks in such systems, given (possibly very large) profiles of system executions. In the approach, for each kind of profile (for example, call-tree profiles), a tool developer implements a simple profile interface that exposes a small set of primitives for selecting summaries of profile measurements and querying how summaries overlap. Next, an analyst uses a search tool, which is written to the profile interface and thus independent of the kind of profile, to find bottlenecks. Our search tool (Bottlenecks) manages the bookkeeping of the search for bottlenecks and provides heuristics that automatically suggest likely bottlenecks. In one case study\u00a0\u2026", "num_citations": "87\n", "authors": ["268"]}
{"title": "Global communication analysis and optimization\n", "abstract": " Reducing communication cost is crucial to achieving good performance on scalable parallel machines. This paper presents a new compiler algorithm for global analysis and optimization of communication in data-parallel programs. Our algorithm is distinct from existing approaches in that rather than handling loop-nests and array references one by one, it considers all communication in a procedure and their interactions under different placements before making a final decision on the placement of any communication. It exploits the flexibility resulting from this advanced analysis to eliminate redundancy, reduce the number of messages, and reduce contention for cache and communication buffers, all in a unified framework. In contrast, single loop-nest analysis often retains redundant communication, and more aggressive dataflow analysis on array sections can generate too many messages or cache and buffer\u00a0\u2026", "num_citations": "87\n", "authors": ["268"]}
{"title": "A perturbation-free replay platform for cross-optimized multithreaded applications\n", "abstract": " Development of multithreaded applications is particularly tricky because of their non-deterministic execution behaviors. Tools that support the debugging and performance timing of such applications are needed. Key to the construction of such tools is the ability to repeat the nondeterministic execution behavior of a multithreaded application. A clean separation between the application and the system that runs it facilitates supporting that ability. This paper presents a platform for constructing such tools in a context in which any separation between the application and the underlying system (and between both and the platform's own instrumentation code) has been obscured. DejaVu supports deterministic replay of nondeterministic executions of multithreaded Java programs on the Jalapeno virtual machine (running on a uniprocessor). Jalapeno is written in Java and its optimizing compiler regularly integrates\u00a0\u2026", "num_citations": "80\n", "authors": ["268"]}
{"title": "Dynamic instrumentation for a mixed mode virtual machine\n", "abstract": " The present invention provides a method, apparatus, and computer instructions for dynamic intermediate code transformation in a mixed mode compiler. In an exemplary embodiment, an object code compiler of a virtual-machine, such as the just-in-time (JIT) compiler (415) of a Java virtual machine (JVM), takes loaded classes and compiles these into object code (416). A JIT-enabled dynamic instrumentation (JEDI) interface (420) provides information to an application (eg, a tool with a GUI), and passes requests for transformation to the JIT (415) and class-loader (410). If loaded, JEDI controls the JIT compiler (415) to compile and transform the class into object code. Thus, dynamically transformed object code is produced without transformation or re-loading of the loaded classes.", "num_citations": "66\n", "authors": ["268"]}
{"title": "Branch target prediction for multi-target branches by identifying a repeated pattern\n", "abstract": " An information processing system for branch target prediction is disclosed. The information processing system includes a memory for storing entries, wherein each entry includes a plurality of target addresses representing a history of target addresses for a multi-target branch and logic for reading the memory and identifying a repeated pattern in a plurality of target addresses for a multi-target branch. The information processing system further includes logic for predicting a next target address for the multi-target branch based on the repeated pattern that was identified.", "num_citations": "62\n", "authors": ["268"]}
{"title": "On the efficient engineering of ambitious program analysis\n", "abstract": " Recent advances in languages, software design methodologies, and architecture have prompted the development of improved compile-time methods for analyzing the effects of procedure calls, pointer references, and array accesses. Such sophistication, however, generally implies that compilers and programming environments will experience a corresponding increase in the volume of analysis information, which may be difficult to use efficiently. In this paper, we consider the practical accommodation of such information. Our results show how to engineer a compiler such that its optimization phase takes time proportional to the benefit, rather than the size, of such information.< >", "num_citations": "50\n", "authors": ["268"]}
{"title": "System and method for solving monotone information propagation problems\n", "abstract": " A method and system is provided for constructing sparse evaluation graphs for forward or backward monotone data flow problems. The sparse graph combines information as early as possible, yet directly connects nodes that generate and use information. This allows problems from the large, general class of monotone data flow problems to enjoy the advantages of solutions based on Static Single Assignment (SSA) form.", "num_citations": "41\n", "authors": ["268"]}
{"title": "Mechanism for data cache replacement based on region policies\n", "abstract": " A system and method for cache replacement includes: augmenting each cache block in a cache region with a region hint indicating a temporal priority of the cache block; receiving an indication that a cache miss has occurred; and selecting for eviction the cache block comprising the region hint indicating a low temporal priority.", "num_citations": "40\n", "authors": ["268"]}
{"title": "System for target branch prediction using correlation of local target histories including update inhibition for inefficient entries\n", "abstract": " An information processing system includes a branch target buffer (BTB) comprising the last next address for the instruction and for receiving an indirect instruction address and providing a BTB predicted target; and next branch target table (NBTT) for storing potential branch targets based on a history of the branch and for providing an NBTT when the a BTB predicted target is not successful. In another embodiment a system comprising a plurality of branch prediction resources dynamically predicts the best resource appropriate for a branch. The method includes predicting a target branch for an indirect instruction address using a resource chosen among the plurality of branch prediction resources; and selectively inhibiting updates of the branch prediction resources whose prediction accuracy does not meet a threshold.", "num_citations": "37\n", "authors": ["268"]}
{"title": "Conditional memory ordering\n", "abstract": " Conventional relaxed memory ordering techniques follow a proactive model: at a synchronization point, a processor makes its own updates to memory available to other processors by executing a memory barrier instruction, ensuring that recent writes have been ordered with respect to other processors in the system. We show that this model leads to superfluous memory barriers in programs with acquire-release style synchronization, and present a combined hardware/software synchronization mechanism called conditional memory ordering (CMO) that reduces memory ordering overhead. CMO is demonstrated on a lock algorithm that identifies those dynamic lock/unlock operations for which memory ordering is unnecessary, and speculatively omits the associated memory ordering instructions. When ordering is required, this algorithm relies on a hardware mechanism for initiating a memory ordering operation on\u00a0\u2026", "num_citations": "37\n", "authors": ["268"]}
{"title": "Balancing runtime and replay costs in a trace-and-replay system\n", "abstract": " Replaying the execution of a parallel program from a runtime trace is a standard approach to performance analysis and debugging of a program with nondeterministic behavior. We propose two improvements to a previous trace-and-replay system. The first is a refinement of a previous trace-reduction strategy called in-cremental tracing, which generates a coarse trace at the expense of longer replay time. We propose a compiletime heuristic to choose the level of runtime tracing, to improve the balance between runtime-trace size and replay time. The second improvement is an extension of the replay strategy. During replay, the coarse trace that was generated at runtime is expanded incrementally aa it is required by the replay.", "num_citations": "32\n", "authors": ["268"]}
{"title": "Perfdiff: a framework for performance difference analysis in a virtual machine environment\n", "abstract": " Although applications running on virtual machines, such as Java, can achieve platform independence, performance evaluation and analysis becomes difficult due to extra intermediate layers and the dynamic nature of virtual execution environment.", "num_citations": "26\n", "authors": ["268"]}
{"title": "DejaVu: deterministic Java replay debugger for Jalape\u00f1o Java virtual machine.\n", "abstract": " ABSTRACT e'fhg ik jl nm\" orfpgPqD gPr9 mt s m\" o mu mgv whfh\" mPe'fhggi 0mgik jl izy {q'| $ fhi fh} 3e'fh e'gi| d wWe'fWe'\" m {fhi fh} fi izy {q'| $ fhi fp} y|| 0}@ d q'} 3e (mgi {fhi mgi {{gfpi wWe'fWe'\" m {m\" ogm9 mPv y v whfp 0mPe'fhg m {fW wWe9 mgi {w mPjlggq'fhg vzq'g0} y} 0 qyy| $ fhi fp} 3e'fh m\" ogm 9e'fhwhfWe 0whv fhit d Bq'} 3e (mgi {y fhi mgi {gfpi q'| $ fhi fh} 3e'fh m\" ogm mPv whfh\" m5e'fpggi {q'| $ fhi fh} 3e'fh\" mPwpwW $ q'wpm\" zfhi 0dze'fpggi nm\" orfhggq gPr izy {q'| $ fhi fh} 3e'fh e'fhg & fh}{0| $ gz ffhwhwH vzq'0ief m {y j q9 r mgwpmPvl gh s m\" o 9fhqye'd mgw& nmPe e'fhwhfh 0} e'hq'\" mgv fpwhfWe q'g5orf {{jq 0whv} i fhi fh} yg wpmPe'fhi izy {q'| $ fhi fp} 3e'fh mPfpwhdzq'D jmPfhe'wpwW q'q'g {d 0fhi ke'u}'mP| $ e'fhg m\" ozfhgPqh e'nm5eh wh {e'gk e'ggj mgfhwhd mPwpmgvl gh fh} mx s 0whggvl {m5e r sz kmPe'} yggi 0mPq'ire'Bq\" vzq'g5ozf {0} e'ggwpwhg\" ffhi 0mPe'd\" Td {q'| $ fhi fp} 3e'fh\" mPwhwh wpm0 z} s m5ogm $ v q'gg gq (mg| $} 0 0| $ gPe'e'fhggi} yd vlggqye'} q (mgw {y j e'fhgginmgwhfWe'fh} yd mP} t} y eye'fhi jzq'\" mg rvlg fhie'} 0 mP| $ fpizy fhi i vzq'g gq (mP|} 3e (mPe'& mPi {e'fhi\" m {whgT mPi {m t vzq'gPorf {} 9 mPi fhie'd fWe'fho mgi {\" mP} 3 e'gD d fhie'1. INTRODUCTION q'}{fW m5q'q'gg| 0whfh 0ief mgv whfh\" mPe'fhg} fhi q (mgw q'} yvl e'} 0 m5q'mgwhwW whggi Bqyy| $ gPq'e'\" m {mPi {nm\" o\" mPe'0mgwpmgj fpwhfWe q'}| d} 3eT q'0} yvlg i {e'g\" 0} 3e'} r ggr ffWe'whfh 0fWe e'fh| $ whfh| $ fWe'} 0 ird gPr& 0whfp ire'} mPi {q'0} 3e'}| jl fh| $ vlg} y} yfhj f e'g Be\" & q'ggvl qye'fh 0ggi fhq'f e'g} y Bq'o q'gg gq (mg| $| $ fhi {fW wWe\" q (mPw@ r\" m5e'd gPr s m\" ogm~ fWe m5eyeyq (mg e'fho y", "num_citations": "25\n", "authors": ["268"]}
{"title": "Preferred write-mostly data cache replacement policies\n", "abstract": " A computer-implemented method of cache replacement includes steps of: determining whether each cache block in a cache memory is a read or a write block; augmenting metadata associated with each cache block with an indicator of the type of access; receiving an access request resulting in a cache miss, the cache miss indicating that a cache block will need to be replaced; examining the indicator in the metadata of each cache block for determining a probability that said cache block will be replaced; and selecting for replacement the cache block with the highest probability of replacement.", "num_citations": "24\n", "authors": ["268"]}
{"title": "Method and apparatus for slicing class hierarchies\n", "abstract": " Given a class hierarchy (a collection of classes and inheritance relations among them) and a program P that uses the hierarchy, a slice of the class hierarchy is computed with respect to the program by eliminating from the hierarchy those data members, member functions, classes, and inheritance relations that are unnecessary for ensuring that the semantics of P is maintained.", "num_citations": "23\n", "authors": ["268"]}
{"title": "Parallel program debugging with flowback analysis\n", "abstract": " This thesis describes the design and implementation of an integrated debugging system for parallel programs running on shared memory multi-processors. The goal of the debugging system is to present to the programmer a graphical view of the dynamic program dependences while keeping the execution-time overhead low.", "num_citations": "19\n", "authors": ["268"]}
{"title": "Computer implemented method and system for accurate, efficient and adaptive calling context profiling\n", "abstract": " Computer implemented method, system and computer usable program code for profiling the execution of an application that is both space-and time-efficient and highly accurate. A computer implemented method for profiling the execution of an application includes sampling execution characteristics of the application at a plurality of sampling points to provide samples, and deriving a calling context of the samples. The application is continuously executed between sampling points while additional profiling data is gathered.", "num_citations": "13\n", "authors": ["268"]}
{"title": "Checkpointed tag prefetcher\n", "abstract": " A dual-mode prefetch mechanism for implementing checkpoint tag prefetching includes: a data array for storing data fetched from cache memory; a set of cache tags for identifying the data stored in the data array; a set of checkpoint tags for storing data identification; a cache controller including prefetch logic, the prefetch logic including a checkpoint prefetch controller and a checkpoint prefetch operator.", "num_citations": "12\n", "authors": ["268"]}
{"title": "Reader-initiated shared memory synchronization\n", "abstract": " A method of optimizing memory synchronization through software in a multi-threaded computer system using a read-initiated memory synchronization process is described. One or more embodiments of the invention may operate in a computer system capable of executing at least one computational activity needing exclusive access shared memory. In the method of one or more embodiments, a multi-field lock may be associated with shared memory to reserved it for exclusive use by a first processor, and where the multi-field lock is already reserved by a second processor, synchronizing the shared memory by the second processor, updating the multi-field lock reservation information; and performing instruction synchronization for the first processor.", "num_citations": "12\n", "authors": ["268"]}
{"title": "Fine-grained I/O access control based on Xen virtualization for 3G/4G mobile devices\n", "abstract": " Although Xen's isolated driver domain (IDD) model enables strong system isolation by limiting the impact of driver faults to the driver domain itself, it results in severe security problems when malware in a guest domain tries to abuse mobile device's limited system resources by sending an extreme number of I/O requests to the IDD. In order to solve this problem, this paper presents a fine-grained I/O access control mechanism in an IDD. Requests from guest domains are managed by an accounting module in terms of CPU usage, with the calculation of estimated CPU consumption using regression equations. The requests are scheduled by an I/O access control enforcer according to security policies. As a result, our mechanism provides precise control on the CPU usage of a guest domain due to I/O device access, and prevents compromised guest domains from CPU overuse, performance degradation, and battery\u00a0\u2026", "num_citations": "11\n", "authors": ["268"]}
{"title": "Method and system for optimal binding selection for service oriented architectures\n", "abstract": " A method for selecting a best performing binding for a server and a client in a service-oriented architecture includes: discovering configuration information about the service and the operating environment of the server and the client; selecting the best performing binding between the client and the server based on the discovered information; enabling the selected binding in a binding proxy for communication between the client and the server.", "num_citations": "11\n", "authors": ["268"]}
{"title": "Dynamic linking on a shared-memory multiprocessor\n", "abstract": " This paper presents a technique for back-patching instructions in an SMP environment. This technique is used by the Jalapeno virtual machine to support dynamic class loading in Java. There is a small runtime overhead the first time a back-patch site is executed. Thereafter, it executes at the same speed as equivalent sites not requiring back-patching.", "num_citations": "11\n", "authors": ["268"]}
{"title": "Computer-implemented method, system, and program product for deployment time optimization of a distributed application\n", "abstract": " A computer-implemented method, system, and program product for optimizing a distributed (software) application are provided. Specifically, a configuration of a target computing environment, in which the distributed application is deployed, is discovered upon deployment of the distributed application. Thereafter, based on a set of rules and the discovered configuration, one or more optimization techniques are applied to optimize the distributed application. In a typical embodiment, the set of rules can be embedded in the distributed application, or they can be accessed from an external source such as a repository. Regardless, the optimization techniques applied can include at least one of the following:(1) identification and replacement of an underperforming component of the distributed application with a new component;(2) generation of interface layers (to allow selection of optimal bindings) between distributed\u00a0\u2026", "num_citations": "9\n", "authors": ["268"]}
{"title": "Target branch prediction using a plurality of tables\n", "abstract": " A system for predicting multiple targets for a single branch includes: a branch target buffer that includes a previous next address for an instruction and that receives an indirect instruction address to provide a first branch target prediction; a first branch table for capturing local past target information of an indirect branch in an encoded form; a second branch table which is a correlation table for storing potential branch targets based on a local branch history and which provides a second branch target prediction when the first branch target prediction is not successful; an exclusion predictor for inhibiting updates of inefficient entries; and a multiplexer to select the predicted target as output.", "num_citations": "8\n", "authors": ["268"]}
{"title": "Improving the performance of web services using deployment-time binding selection\n", "abstract": " In this paper, we present a novel deployment-time binding selection framework for Web services to improve the performance. Using the information about target environments, we determine the best binding based on the availability and the accessibility of a service, and the performance characteristics of the bindings in a target environment. We have implemented the proposed mechanism as part of Eclipse-based development tools. We present an extensive performance evaluation of our methodology using benchmarks that we have created following public Web service interfaces, and emulating several e-business applications including a large scale legacy transaction processing system that runs on a mainframe.", "num_citations": "8\n", "authors": ["268"]}
{"title": "Branch target prediction for multi-target branches by identifying a repeated pattern\n", "abstract": " An information processing system for branch target prediction includes: a first memory for storing entries for multi-target branch, wherein each entry includes a plurality of target addresses representing a history of target addresses for each single branch in the multi-target branch, and wherein said first memory stores an entry for the branch only if the branch is a multi-target branch; hardware logic for reading the memory and identifying a repeated pattern in each of the plurality of target addresses for the multi-target branch; logic for predicting a next target address for the multi-target branch based on the repeated pattern that was identified, using a pattern matching algorithm; and a second memory for storing information regarding whether a branch is a multi-target branch; wherein the logic for reading and the logic for predicting are executed only if the branch is the multi-target branch.", "num_citations": "5\n", "authors": ["268"]}
{"title": "Ise01-4: Deployment time performance optimization of internet services\n", "abstract": " This paper introduces a novel deployment time optimization (DTO) technology for Internet services. Using the configuration information collected from the target operation environment, the proposed optimization technology attempts to deploy only necessary and most performant components for a service in the target environment. To facilitate DTO, we have developed a framework called blue pencil, which consists of the following modules: configuration discovery module, optimization rule repository, deployment optimization module, proxy generation module, and code transformation module. We present how these modules enable DTO and show the performance benefit of DTP in a client-server binding selection scenario.", "num_citations": "5\n", "authors": ["268"]}
{"title": "Record/Replay in the Presence of Benign Data Races\n", "abstract": " In this article we present our experience with the integration of record/replay in the Jalape no virtual machine. The goal of record/replay is to be able to faithfully replay an application. Previous work in Jalape no focused on the replay of Java applications on uni-processors. Here we describe additional work done to obtain replay with low intrusion on multi-processor systems by doing'ordering based'record/replay. During ordering based record/replay we only record the order of the synchronization operations performed. A prerequisite of this technique is that there are no data races present in the application that is to be replayed. However, we found that Jalape no contains many benign data races. A major contribution of this article is that we show how one can circumvent these data races and still perform a meaningful replay of the application.", "num_citations": "5\n", "authors": ["268"]}
{"title": "Computer-implemented method, system, and program product for optimizing a distributed application\n", "abstract": " A computer-implemented method, system, and program product for optimizing a distributed (software) application are provided. Specifically, a configuration of a target computing environment, in which the distributed application is deployed, is discovered upon deployment of the distributed application. Thereafter, based on a set of rules and the discovered configuration, one or more optimization techniques are applied to optimize the distributed application. In a typical embodiment, the set of rules can be embedded in the distributed application, or they can be accessed from an external source such as a repository. Regardless, the optimization techniques applied can include at least one of the following:(1) identification and replacement of an underperforming component of the distributed application with a new component;(2) generation of interface layers (to allow selection of optimal bindings) between distributed\u00a0\u2026", "num_citations": "4\n", "authors": ["268"]}
{"title": "Thread-sensitive points-to analysis for multithreaded Java programs\n", "abstract": " Every running thread has its own thread context that consists of values of the fields of the target thread object. To consider the thread context in understanding the behaviors of concurrently running threads, we propose a thread-sensitive interprocedural analysis for multithreaded Java applications. Our thread-sensitive analysis exploits thread-context information, instead of the conventional calling-context information, for computing dataflow facts holding at a statement. The thread-sensitive analysis is highly effective in distinguishing dataflow facts for different threads, producing more precise dataflow information than non-thread-sensitive analysis. The analysis is also generally much more efficient than conventional (calling) context-sensitive analysis. It uses the target thread objects at a thread start site to distinguish different thread contexts. We give a thread-sensitive points-to analysis as an instance of\u00a0\u2026", "num_citations": "4\n", "authors": ["268"]}
{"title": "Deployment-time binding selection to improve the performance of distributed applications\n", "abstract": " We investigate a novel technology to improve the performance of a distributed application by configuring its components in an optimal way using the information about the operation environment discovered during the deployment of the application. To enable such capabilities we have developed a general architecture for deployment time optimization, called Blue Pencil. In this paper, we present how Blue Pencil can improve the performance of distributed applications by selecting the most appropriate binding between a client and a server using only static information such as the service interface definition, the location of the service, and information about the application server. Based on the performance study using real world Web services and internal benchmarks, we report that:(1) modern SOAP implementations are highly efficient and can perform even better than RMI under certain workloads and operation\u00a0\u2026", "num_citations": "2\n", "authors": ["268"]}
{"title": "What is in a slice\n", "abstract": " First, I am going to talk about what MC-CDMA is, comparing its transmitter structure with those of DS-CDMA and OFDM. Then, we will see where MC-CDMA will t. MCCDMA has several nasty problems inherited from OFDM. One of them is the non-constant power envelope of the transmitted signal. We will see what the problem is for OFDM through a simple example. We established the relationships between the codes and peakto-mean envelope power ratio in MC-CDMA as well as OFDM. Based on these, we propose to use orthogonal Gold codes rather than Walsh codes and the numerical results will be presented.", "num_citations": "2\n", "authors": ["268"]}
{"title": "Programming in the large for the internet of things (invited talk)\n", "abstract": " The term Internet of Things (IoT) has generated a lot of buzz in the information technology and consumer electronics industries. In the IoT setting, a large number of physically dispersed devices-such as sensors, actuators and processing units-coordinate to bring useful capabilities to the user. A significant portion of these devices may have rather small computation and storage footprints, but at the same time, they can leverage support from potential enormous computation and storage resources via the cloud. Also, a large set of small footprint devices can serve not just a single logical app or service, but also many independent logical apps or services. This requires a careful separation of computational activities and their associated data within a device, for privacy and security purposes. Application development for the Internet of Things gives a whole new meaning to the term\" programming in the large\", and some of this is likely to be new to the practitioner. This talk will discuss what the IoT environment means to the practical programmer, and what apps and app ecosystems for IoT might look like. The talk will also discuss the issues and open challenges in software engineering brought on by this new environment, pointing towards new opportunities for researchers in our community.", "num_citations": "1\n", "authors": ["268"]}
{"title": "Security optimization techniques for web applications\n", "abstract": " A method for determining whether to provide a requested service includes steps of receiving a current request for at least one secure service; searching a cache for a stored decision on whether to provide the at least one secure service, wherein the stored decision was made responsive to a prior request that is equivalent to the current request; using the stored decision when the stored decision is found; and performing a security check to determine whether a requested secure service can be granted, if the stored decision is not found. According to other embodiments, the method can be implemented as a computer readable medium including program instructions for performing the method or as an information processing system comprising a processor and memory for performing the method.", "num_citations": "1\n", "authors": ["268"]}
{"title": "Whole-stack analysis and optimization of commercial workloads on Server systems\n", "abstract": " The evolution of the Web as an enabling tool for e-business introduces a challenge to understanding the execution behavior of large-scale middleware systems, such as J2EE\u00a0[2], and their commercial workloads. This paper presents a brief description of the whole-stack analysis and optimization system \u2013 being developed at IBM Research \u2013 for commercial workloads on Websphere Application Server (WAS)\u00a0[5] \u2013 IBM\u2019s implementation of J2EE \u2013 running on IBM\u2019s pSeries\u00a0[4] and zSeries\u00a0[3] server systems.", "num_citations": "1\n", "authors": ["268"]}
{"title": "Memory Management Replay For DejaVu\n", "abstract": " Multithreading makes it hard to use cyclic debugging techniques, due to the non-determinism related to the concurrent behaviour of such applications. A well known solution consists of recording an execution and debugging it during replay. In order to produce a faithful replay, the recorded information needs to contain enough information to cover all non-deterministic choices. Java has an extra source of non-determinism related to the garbage collector of the JVM. This paper discusses the problems that arise herefrom and describes the solutions we developed in order to implement a fully operational memory management replay module, based on the scheduling replay of DejaVu.", "num_citations": "1\n", "authors": ["268"]}
{"title": "A Debugging Platform for Java Server Applications\n", "abstract": " Development of multithreaded server applications is particularly tricky because of their nondeterministic execution behavior, availability requirements, and extended running times. New tools are needed to help programmers understand server behavior.DejaVu supports deterministic replay of nondeterministic, multithreaded Java programs running on the Jalapeno virtual machine on uniprocessors. Jalapeno is written in Java, and its optimizing compiler combines application, virtual machine, and DejaVu instrumentation code into unified machine-code sequences. Such integration boosts performance, but it also compounds the difficulty of replaying nondeterministic behavior accurately and with minimal interference from the instrumentation. DejaVu ensures deterministic replay through symmetric instrumentation\u2014side-effect-preserving instrumentation in both record and replay modes\u2014and remote reflection, which exposes the state of an application without perturbing it.", "num_citations": "1\n", "authors": ["268"]}