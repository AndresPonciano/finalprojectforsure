{"title": "Control-flow integrity principles, implementations, and applications\n", "abstract": " Current software attacks often build on exploits that subvert machine-code execution. The enforcement of a basic safety property, control-flow integrity (CFI), can prevent such attacks from arbitrarily controlling program behavior. CFI enforcement is simple and its guarantees can be established formally, even with respect to powerful adversaries. Moreover, CFI enforcement is practical: It is compatible with existing software and can be done efficiently using software rewriting in commodity systems. Finally, CFI provides a useful foundation for enforcing further security policies, as we demonstrate with efficient software implementations of a protected shadow call stack and of access control for memory regions.", "num_citations": "2114\n", "authors": ["350"]}
{"title": "Edit automata: Enforcement mechanisms for run-time security policies\n", "abstract": " We analyze the space of security policies that can be enforced by monitoring and modifying programs at run time. Our program monitors, called edit automata, are abstract machines that examine the sequence of application program actions and transform the sequence when it deviates from a specified policy. Edit automata have a rich set of transformational powers: they may terminate an application, thereby truncating the program action stream; they may suppress undesired or dangerous actions without necessarily terminating the program; and they may also insert additional actions into the event stream.               After providing a formal definition of edit automata, we develop a rigorous framework for reasoning about them and their cousins: truncation automata (which can only terminate applications), suppression automata (which can terminate applications and suppress individual actions), and insertion\u00a0\u2026", "num_citations": "416\n", "authors": ["350"]}
{"title": "Composing security policies with polymer\n", "abstract": " We introduce a language and system that supports definition and composition of complex run-time security policies for Java applications. Our policies are comprised of two sorts of methods. The first is query methods that are called whenever an untrusted application tries to execute a security-sensitive action. A query method returns a suggestion indicating how the security-sensitive action should be handled. The second sort of methods are those that perform state updates as the policy's suggestions are followed. The structure of our policies facilitates composition, as policies can query other policies for suggestions. In order to give programmers control over policy composition, we have designed the system so that policies, suggestions, and application events are all first-class objects that a higher-order policy may manipulate. We show how to use these programming features by developing a library of policy\u00a0\u2026", "num_citations": "233\n", "authors": ["350"]}
{"title": "Run-time enforcement of nonsafety policies\n", "abstract": " A common mechanism for ensuring that software behaves securely is to monitor programs at run time and check that they dynamically adhere to constraints specified by a security policy. Whenever a program monitor detects that untrusted software is attempting to execute a dangerous action, it takes remedial steps to ensure that only safe code actually gets executed. This article improves our understanding of the space of policies enforceable by monitoring the run-time behaviors of programs. We begin by building a formal framework for analyzing policy enforcement: we precisely define policies, monitors, and enforcement. This framework allows us to prove that monitors enforce an interesting set of policies that we call the infinite renewal properties. We show how to construct a program monitor that provably enforces any reasonable infinite renewal property. We also show that the set of infinite renewal properties\u00a0\u2026", "num_citations": "222\n", "authors": ["350"]}
{"title": "More enforceable security policies\n", "abstract": " We analyze the space of security policies that can be enforced by monitoring programs at runtime. Our program monitors are automata that examine the sequence of program actions and transform the sequence when it deviates from the specified policy. The simplest such automaton truncates the action sequence by terminating a program. Such automata are commonly known as security automata, and they enforce Schneider\u2019s EM class of security policies. We define automata with more powerful transformational abilities, including the ability to insert a sequence of actions into the event stream and to suppress actions in the event stream without terminating the program. We give a set-theoretic characterization of the policies these new automata are able to enforce and show that they are a superset of the EM policies.", "num_citations": "175\n", "authors": ["350"]}
{"title": "A theory of aspects\n", "abstract": " This paper define the semantics of MinAML, an idealized aspect-oriented programming language, by giving a type-directed translation from its user-friendly external language to its compact, well-defined core language. We argue that our framework is an effective way to give semantics to aspect-oriented programming languages in general because the translation eliminates shallow syntactic differences between related constructs and permits definition of a clean, easy-to-understand, and easy-to-reason-about core language.The core language extends the simply-typed lambda calculus with two central new abstractions: explicitly labeled program points and first-class advice. The labels serve both to trigger advice and to mark continuations that the advice may return to. These constructs are defined orthogonally to the other features of the language and we show that our abstractions can be used in both functional and\u00a0\u2026", "num_citations": "169\n", "authors": ["350"]}
{"title": "Enforcing non-safety security policies with program monitors\n", "abstract": " We consider the enforcement powers of program monitors, which intercept security-sensitive actions of a target application at run time and take remedial steps whenever the target attempts to execute a potentially dangerous action. A common belief in the security community is that program monitors, regardless of the remedial steps available to them when detecting violations, can only enforce safety properties. We formally analyze the properties enforceable by various program monitors and find that although this belief is correct when considering monitors with simple remedial options, it is incorrect for more powerful monitors that can be modeled by edit automata. We define an interesting set of properties called infinite renewal properties and demonstrate how, when given any reasonable infinite renewal property, to construct an edit automaton that provably enforces that property. We analyze the set of infinite\u00a0\u2026", "num_citations": "120\n", "authors": ["350"]}
{"title": "A theory of secure control flow\n", "abstract": " Control-Flow Integrity (CFI) means that the execution of a program dynamically follows only certain paths, in accordance with a static policy. CFI can prevent attacks that, by exploiting buffer overflows and other vulnerabilities, attempt to control program behavior. This paper develops the basic theory that underlies two practical techniques for CFI enforcement, with precise formulations of hypotheses and guarantees.", "num_citations": "97\n", "authors": ["350"]}
{"title": "Defining code-injection attacks\n", "abstract": " This paper shows that existing definitions of code-injection attacks (e.g., SQL-injection attacks) are flawed. The flaws make it possible for attackers to circumvent existing mechanisms, by supplying code-injecting inputs that are not recognized as such. The flaws also make it possible for benign inputs to be treated as attacks. After describing these flaws in conventional definitions of code-injection attacks, this paper proposes a new definition, which is based on whether the symbols input to an application get used as (normal-form) values in the application's output. Because values are already fully evaluated, they cannot be considered \"code\" when injected. This simple new definition of code-injection attacks avoids the problems of existing definitions, improves our understanding of how and when such attacks occur, and enables us to evaluate the effectiveness of mechanisms for mitigating such attacks.", "num_citations": "80\n", "authors": ["350"]}
{"title": "A theory of runtime enforcement, with results\n", "abstract": " This paper presents a theory of runtime enforcement based on mechanism models called MRAs (Mandatory Results Automata). MRAs can monitor and transform security-relevant actions and their results. Because previous work could not model monitors transforming results, MRAs capture realistic behaviors outside the scope of previous models. MRAs also have a simple but realistic operational semantics that makes it straightforward to define concrete MRAs. Moreover, the definitions of policies and enforcement with MRAs are significantly simpler and more expressive than those of previous models. Putting all these features together, we argue that MRAs make good general models of runtime mechanisms, upon which a theory of runtime enforcement can be based. We develop some enforceability theory by characterizing the policies MRAs can and cannot enforce.", "num_citations": "78\n", "authors": ["350"]}
{"title": "Fault-tolerant typed assembly language\n", "abstract": " A transient hardware fault occurs when an energetic particle strikes a transistor, causing it to change state. Although transient faults do not permanently damage the hardware, they may corrupt computations by altering stored values and signal transfers. In this paper, we propose a new scheme for provably safe and reliable computing in the presence of transient hardware faults. In our scheme, software computations are replicated to provide redundancy while special instructions compare the independently computed results to detect errors before writing critical data. In stark contrast to any previous efforts in this area, we have analyzed our fault tolerance scheme from a formal, theoretical perspective. To be specific, first, we provide an operational semantics for our assembly language, which includes a precise formal definition of our fault model. Second, we develop an assembly-level type system designed to detect\u00a0\u2026", "num_citations": "59\n", "authors": ["350"]}
{"title": "System and methods for authentication using multiple devices\n", "abstract": " A system and method of authentication using an authenticator computing device and at least two registered user devices is described. In operation, the authenticator computing device receives a request to access a resource from one of a plurality of user devices registered to a user. The authenticator computing device generates an authentication challenge in response to the request and the authentication challenge is then transmitted to a subset of the plurality of user devices. One or more of the user devices then subsequently generates and transmits a response to the authentication challenge to the authenticator computing device. The authenticator computing device then determines whether the responses received from the one or more user devices in the subset constitutes a valid response and then grants one or more of the user devices access to the resource if the responses received from the user devices\u00a0\u2026", "num_citations": "56\n", "authors": ["350"]}
{"title": "Composing expressive runtime security policies\n", "abstract": " Program monitors enforce security policies by interposing themselves into the control flow of untrusted software whenever that software attempts to execute security-relevant actions. At the point of interposition, a monitor has authority to permit or deny (perhaps conditionally) the untrusted software's attempted action. Program monitors are common security enforcement mechanisms and integral parts of operating systems, virtual machines, firewalls, network auditors, and antivirus and antispyware tools. Unfortunately, the runtime policies we require program monitors to enforce grow more complex, both as the monitored software is given new capabilities and as policies are refined in response to attacks and user feedback. We propose dealing with policy complexity by organizing policies in such a way as to make them composable, so that complex policies can be specified more simply as compositions of smaller\u00a0\u2026", "num_citations": "55\n", "authors": ["350"]}
{"title": "Policy enforcement via program monitoring\n", "abstract": " One way to guarantee that software behaves securely is to monitor programs at run time and check that they dynamically adhere to constraints specified by a security policy. Whenever a program monitor detects that untrusted software is attempting to execute a dangerous action, it takes remedial steps to ensure that only safe code actually gets executed. This thesis considers the space of policies enforceable by monitoring the run-time behaviors of programs and develops a practical language for specifying monitors' policies.", "num_citations": "53\n", "authors": ["350"]}
{"title": "Software security based on control flow integrity\n", "abstract": " Software control flow integrity is provided by embedding identifying bit patterns at computed control flow instruction sources and destinations. The sources and destinations of computed control flow instructions are determined with reference to a control flow graph. The identifying bit patterns are compared during software execution, and a match between a source and a respective destination ensures control flow consistent with the control flow graph. Security measures are implemented when the comparison results in a mismatch, indicating that control flow has deviated from the anticipated course.", "num_citations": "52\n", "authors": ["350"]}
{"title": "Software memory access control\n", "abstract": " Software memory access control is provided by associating instruction areas with memory areas such that instruction areas are not permitted to access memory areas with which they are not associated. Checks may be inserted in the instruction areas to ensure that data provided by a memory group is provided by an associated memory area. Additionally, control flow integrity for the instruction areas may be provided by embedding identifying bit patterns within computed control flow instructions contained in the instruction groups. In this way, control flow of the instruction areas may be provided, thus preventing diversion of control flow and minimizing required checks.", "num_citations": "46\n", "authors": ["350"]}
{"title": "Modeling runtime enforcement with mandatory results automata\n", "abstract": " This paper presents a theory of runtime enforcement based on mechanism models called mandatory results automata (MRAs). MRAs can monitor and transform security-relevant actions and their results. The operational semantics of MRAs is simple and enables straightforward definitions of concrete MRAs. Moreover, the definitions of policies and enforcement with MRAs are simple and expressive. Putting all of these features together, we argue that MRAs make good general models of runtime mechanisms, upon which a theory of runtime enforcement can be based. We develop some enforceability theory by characterizing the policies deterministic and non-deterministic MRAs can and cannot enforce.", "num_citations": "42\n", "authors": ["350"]}
{"title": "A type-theoretic interpretation of pointcuts and advice\n", "abstract": " This article defines the semantics of MinAML, an idealized aspect-oriented programming language, by giving a type-directed translation from a user-friendly external language to a compact, well-defined core language. We argue that our framework is an effective way to give semantics to aspect-oriented programming languages in general because the translation eliminates shallow syntactic differences between related constructs and permits definition of an elegant and extensible core language.The core language extends the simply-typed lambda calculus with two central new abstractions: explicitly labeled program points and first-class advice. The labels serve both to trigger advice and to mark continuations that the advice may return to. These constructs are defined orthogonally to the other features of the language and we show that our abstractions can be used in both functional and object-oriented contexts. We\u00a0\u2026", "num_citations": "37\n", "authors": ["350"]}
{"title": "Static typing for a faulty lambda calculus\n", "abstract": " A transient hardware fault occurs when an energetic particle strikes a transistor, causing it to change state. These faults do not cause permanent damage, but may result in incorrect program execution by altering signal transfers or stored values. While the likelihood that such transient faults will cause any significant damage may seem remote, over the last several years transient faults have caused costly failures in high-end machines at America Online, eBay, and the Los Alamos Neutron Science Center, among others [6, 44, 15]. Because susceptibility to transient faults is proportional to the size and density of transistors, the problem of transient faults will become increasingly important in the coming decades. This paper defines the first formal, type-theoretic framework for studying reliable computation in the presence of transient faults. More specifically, it defines \u03bbzap, a lambda calculus that exhibits intermittent data\u00a0\u2026", "num_citations": "37\n", "authors": ["350"]}
{"title": "Types and effects for non-interfering program monitors\n", "abstract": " A run-time monitor is a program that runs in parallel with an untrusted application and examines actions from the application\u2019s instruction stream. If the sequence of program actions deviates from a specified security policy, the monitor transforms the sequence or terminates the program. We present the design and formal specification of a language for defining the policies enforced by program monitors.               Our language provides a number of facilities for composing complex policies from simpler ones. We allow policies to be parameterized by values or other policies, and we define operators for forming the conjunction and disjunction of policies. Since the computations that implement these policies modify program behavior, naive composition of computations does not necessarily produce the conjunction (or disjunction) of the policies that the computations implement separately. We use a type and effect\u00a0\u2026", "num_citations": "31\n", "authors": ["350"]}
{"title": "Electronic device with reflective panel\n", "abstract": " An electronic device such as a portable phone has a casing, a display element provided in the casing, and a panel attached to the casing to cover the display element. A half mirror layer and a shading layer are formed on the panel. An opening of the shading layer is above the display element. The surface of the panel is seen in a substantially continuously uniform color when no electricity is supplied to the display element, and a display produced by the display element can be seen through the panel when electricity is supplied to the display element.", "num_citations": "29\n", "authors": ["350"]}
{"title": "A language and system for composing security policies\n", "abstract": " We introduce a new language and system that allows security architects to develop well-structured and easy-to-maintain security policies for Java applications. In our system, policies are first-class objects. Consequently, programmers can define parameterized meta-policies that act as policy combinators and policy modifiers, so that complex security policies can be implemented by composing simple base policies. We demonstrate the effectiveness of our design by building up a library of powerful policy combinators and showing how they can be used. We also describe some issues we encountered while implementing our system and provide performance results.", "num_citations": "23\n", "authors": ["350"]}
{"title": "LoPSiL: A location-based policy-specification language\n", "abstract": " This paper describes the design of LoPSiL, a language for specifying location-dependent security and privacy policies. Policy- specification languages like LoPSiL are domain-specific programming languages intended to simplify the tasks of specifying and enforcing sound security policies on untrusted (i.e., potentially insecure) software. As far as we are aware, LoPSiL is the first imperative policy-specification language to provide abstractions specifically tailored to location-dependent policies for mobile-device applications. We have implemented a proof-of-concept compiler that inputs a LoPSiL policy P and a mobile-device application program A and outputs a new application program A\u2032 equivalent to A, except that A\u2032 contains inlined enforcement code that ensures that A\u2032 satisfies P at runtime. We report our experiences using this compiler to design and implement several policies for mobile-device\u00a0\u2026", "num_citations": "19\n", "authors": ["350"]}
{"title": "Systems and methods for anonymous authentication using multiple devices\n", "abstract": " A system and method of anonymous authentication is described. In operation, the authenticator receives a request to access a resource from one of the user devices of an associated set of user devices, wherein each of the user devices is registered to at least one user requesting access to the resource registered to at least two users. The authenticator generates and transmits an authentication challenge in response to the request to a subset of the user devices. A user device subsequently generates and transmits a response to the authentication challenge to the authenticator. The authenticator determines whether the responses received from the one or more user devices constitutes a valid response and grants any one or more of the user devices of the associated set of user devices access to the resource if the responses received from the user devices constitutes a valid response to the authentication challenge.", "num_citations": "18\n", "authors": ["350"]}
{"title": "Design of adiabatic dynamic differential logic for DPA-resistant secure integrated circuits\n", "abstract": " Production of cost-effective secure integrated chips, such as smart cards, requires hardware designers to consider tradeoffs in size, security, and power consumption. To design successful security-centric designs, the low-level hardware must contain built-in protection mechanisms to supplement cryptographic algorithms, such as advanced encryption standard and triple data encryption standard by preventing side-channel attacks, such as differential power analysis (DPA). Dynamic logic obfuscates the output waveforms and the circuit operation, reducing the effectiveness of the DPA attack. For stronger mitigation of DPA attacks, we propose the implementation of adiabatic dynamic differential logic (ADDL) for applications in secure integrated circuit (IC) design. Such an approach is effective in reducing power consumption, demonstrated using HSPICE simulations with 22-nm predictive technology. The benefits of our\u00a0\u2026", "num_citations": "18\n", "authors": ["350"]}
{"title": "A calculus for composing security policies\n", "abstract": " A runtime monitor is a program that runs in parallel with an untrusted application and examines actions from the application\u2019s instruction stream. If the sequence of program actions deviates from a specified security policy, the monitor transforms the sequence or terminates the program. We present the design and formal specification of a language for defining the policies enforced by program monitors. Our language provides a number of facilities for composing complex policies from simpler ones. We allow policies to be parameterized by values, or other policies. There are also operators for forming the conjunction and disjunction of policies. Since the computations that implement these policies modify program behavior, naive composition of computations does not necessarily produce the conjunction (or disjunction) of the policies that the computations implement separately. We use a type and effect system to ensure that computations do not interfere with one another when they are composed. We also present a preliminary implementation of our language.", "num_citations": "16\n", "authors": ["350"]}
{"title": "On subtyping-relation completeness, with an application to iso-recursive types\n", "abstract": " Well-known techniques exist for proving the soundness of subtyping relations with respect to type safety. However, completeness has not been treated with widely applicable techniques, as far as we\u2019re aware. This article develops techniques for stating and proving that a subtyping relation is complete with respect to type safety and applies the techniques to the study of iso-recursive subtyping. A new proof technique, induction on failing derivations, is provided that may be useful in other domains as well. The common subtyping rules for iso-recursive types\u2014the \u201cAmber rules\u201d\u2014are shown to be incomplete with respect to type safety. That is, there exist iso-recursive types \u03c41 and \u03c42 such that \u03c41 can safely be considered a subtype of \u03c42, but \u03c41 \u2a7d \u03c42 is not derivable with the Amber rules. New, algorithmic rules are defined for subtyping iso-recursive types, and the rules are proved sound and complete with respect to type\u00a0\u2026", "num_citations": "13\n", "authors": ["350"]}
{"title": "Defining injection attacks\n", "abstract": " This paper defines and analyzes injection attacks. The definition is based on the NIE property, which states that an application\u2019s untrusted inputs must only produce Noncode Insertions or Expansions (i.e., NIEs) in output programs. That is, when applications generate output programs (such as SQL queries) based on untrusted inputs, the NIE property requires that inputs only affect output programs by inserting or expanding noncode tokens (such as string and float literals, lambda values, pointers, etc). This paper calls attacks based on violating the NIE property BroNIEs (i.e., Broken NIEs) and shows that all code-injection attacks are BroNIEs. In addition, BroNIEs contain many malicious injections that do not involve injections of code; we call such attacks noncode-injection attacks. In order to mitigate both code- and noncode-injection attacks, this paper presents an algorithm for detecting and preventing BroNIEs.", "num_citations": "13\n", "authors": ["350"]}
{"title": "A location-based policy-specification language for mobile devices\n", "abstract": " The dramatic rise in mobile applications has greatly increased threats to the security and privacy of users. Security mechanisms on mobile devices are currently limited, so users need more expressive ways to ensure that downloaded mobile applications do not act maliciously. Policy-specification languages were created for this purpose; they allow the enforcement of user-defined policies on third-party applications. We have implemented LoPSiL, a location-based policy-specification language for mobile devices. This article describes LoPSiL\u2019s design and implementation, several example policies, and experiments that demonstrate LoPSiL\u2019s viability for enforcing policies on mobile devices.", "num_citations": "13\n", "authors": ["350"]}
{"title": "Fingerprinting far proximity from radio emissions\n", "abstract": " As wireless mobile devices are more and more pervasive and adopted in critical applications, it is becoming increasingly important to measure the physical proximity of these devices in a secure way. Although various techniques have been developed to identify whether a device is close, the problem of identifying the far proximity (i.e., a target is at least a certain distance away) has been neglected by the research community. Meanwhile, verifying the far proximity is desirable and critical to enhance the security of emerging wireless applications. In this paper, we propose a secure far proximity identification approach that determines whether or not a remote device is far away. The key idea of the proposed approach is to estimate the far proximity from the unforgeable \u201cfingerprint\u201d of the proximity. We have validated and evaluated the effectiveness of the proposed far proximity identification method through\u00a0\u2026", "num_citations": "12\n", "authors": ["350"]}
{"title": "Enforcing more with less: Formalizing target-aware run-time monitors\n", "abstract": " Run-time monitors ensure that untrusted software and system behavior adheres to a security policy. This paper defines an expressive formal framework, based on I/O automata, for modeling systems, policies, and run-time monitors in more detail than is typical. We explicitly model, for example, the environment, applications, and the interaction between them and monitors. The fidelity afforded by this framework allows us to explicitly formulate and study practical constraints on policy enforcement that were often only implicit in previous models, providing a more accurate view of what can be enforced by monitoring in practice. We introduce two definitions of enforcement, target-specific and generalized, that allow us to reason about practical monitoring scenarios. Finally, we provide some meta-theoretical comparison of these definitions and we apply them to investigate policy enforcement in scenarios where the\u00a0\u2026", "num_citations": "9\n", "authors": ["350"]}
{"title": "An ethnographic understanding of software (in) security and a co-creation model to improve secure software development\n", "abstract": " We present an ethnographic study of secure software development processes in a software company using the anthropological research method of participant observation. Two PhD students in computer science trained in qualitative methods were embedded in a software company for 1.5 years of total research time. The researchers participated in everyday work activities such as coding and meetings, and observed software (in) security phenomena both through investigating historical data (code repositories and ticketing system records), and through pen-testing the developed software and observing developers\u2019 and management\u2019s reactions to the discovered vulnerabilities. Our study found that 1) security vulnerabilities are sometimes intentionally introduced and/or overlooked due to the difficulty in managing the various stakeholders' responsibilities in an economic ecosystem, and cannot be simply blamed on developers\u2019 lack of knowledge or skills; 2) accidental vulnerabilities discovered in the pen-testing process produce different reactions in the development team, often times contrary to what a security researcher would predict. These findings highlight the nuanced nature of the root causes of software vulnerabilities and indicate the need to take into account a significant amount of contextual information to understand how and why software vulnerabilities emerge during software development. Rather than simply addressing deficits in developer knowledge or practice, this research sheds light on at times forgotten human factors that significantly impact the security of software developed by actual companies. Our analysis also shows that\u00a0\u2026", "num_citations": "8\n", "authors": ["350"]}
{"title": "Completely subtyping iso-recursive types\n", "abstract": " Well-known techniques exist for proving the soundness of subtyping relations with respect to type safety. However, completeness has not been treated with widely applicable techniques, as far as we are aware.This paper develops some techniques for stating and proving that a subtyping relation is complete with respect to type safety and applies the techniques to the study of iso-recursive subtyping. The common subtyping rules for iso-recursive types\u2014the \u201cAmber rules\u201d\u2014are shown to be incomplete with respect to type safety. That is, there exist iso-recursive types \u03c41 and \u03c42 such that \u03c41 can safely be considered a subtype of \u03c42, but \u03c41\u2264 \u03c42 is not derivable with the Amber rules.", "num_citations": "8\n", "authors": ["350"]}
{"title": "Coauthentication\n", "abstract": " This paper introduces and evaluates collaborative authentication, or coauthentication, a single-factor technique in which multiple registered devices work together to authenticate a user. Coauthentication provides security benefits similar to those of multi-factor techniques, such as mitigating theft of any one authentication secret, without some of the inconveniences of multi-factor techniques, such as having to enter passwords or biometrics. Coauthentication provides additional security benefits, including: preventing phishing, replay, and man-in-the-middle attacks; basing authentications on high-entropy secrets that can be generated and updated automatically; and availability protections against, for example, device misplacement and denial-of-service attacks. Coauthentication is amenable to many applications, including m-out-of-n, continuous, group, shared-device, and anonymous authentications. The principal\u00a0\u2026", "num_citations": "7\n", "authors": ["350"]}
{"title": "Poliseer: A tool for managing complex security policies\n", "abstract": " Complex software-security policies are difficult to specify, understand, and update. The same is true for complex software in general, but while many tools and techniques exist for decomposing complex general software into simpler reusable modules (packages, classes, functions, aspects, etc.), few tools exist for decomposing complex security policies into simpler reusable modules. The tools that do exist for modularizing policies either encapsulate entire policies as atomic modules that cannot be decomposed or allow fine-grained policy modularization but require expertise to use correctly. This paper presents PoliSeer, a GUI-based tool designed to enable users who are not expert policy engineers to flexibly specify, visualize, modify, and enforce complex runtime policies on untrusted software. PoliSeer users rely on expert policy engineers to specify universally composable policy modules; PoliSeer users then build complex policies by composing those expert-written modules. This paper describes the design and implementation of PoliSeer and a case study in which we have used PoliSeer to specify and enforce a policy on PoliSeer itself.", "num_citations": "7\n", "authors": ["350"]}
{"title": "A packetclassification algorithm for arbitrary bitmask rules, with automatic time-space tradeoffs\n", "abstract": " We present an algorithm for classifying packets according to arbitrary (including noncontiguous) bitmask rules. As its principal novelty, the algorithm is parameterized by the amount of memory available and can customize its data structures to optimize classification time without exceeding a given memory bound. The algorithm thus automatically trades time for space efficiency as needed. The two extremes of this time-space tradeoff (linear search through the rules versus a single table that maps every possible packet to its class number) are special cases of the general algorithm we present. Additional features of the algorithm include its simplicity, its open-source prototype implementation, its good performance even with worst-case rule sets, and its extendability to handle range rules and dynamic updates to rule sets.", "num_citations": "7\n", "authors": ["350"]}
{"title": "Systems and methods for challengeless coauthentication\n", "abstract": " A system and method of authentication that avoids authentication challenges is described. In operation, an authenticator receives a first request to access a resource generated by a requestor and a participation message generated by a collaborator. The authenticator computing device then analyzes the first request and the participation message to determine whether the requestor requesting access to the resource should be granted access and grants the requestor access to the resource based upon the analysis of the first request to access a resource and the participation message.", "num_citations": "6\n", "authors": ["350"]}
{"title": "SQL-Identifier injection attacks\n", "abstract": " This paper defines a class of SQL-injection attacks that are based on injecting identifiers, such as table and column names, into SQL statements. An automated analysis of GitHub shows that 15.7% of 120,412 posted Java source files contain code vulnerable to SQL-Identifier Injection Attacks (SQL-IDIAs). We have manually verified that some of the 18,939 Java files identified during the automated analysis are indeed vulnerable to SQL-ID IAs, including deployed Electronic Medical Record software for which SQL-IDIAs enable discovery of confidential patient information. Although prepared statements are the standard defense against SQL injection attacks, existing prepared-statement APIs do not protect against SQL-IDIAs. This paper therefore proposes and evaluates an extended prepared-statement API to protect against SQL-IDIAs.", "num_citations": "6\n", "authors": ["350"]}
{"title": "Query monitoring and analysis for database privacy-a security automata model approach\n", "abstract": " Privacy and usage restriction issues are important when valuable data are exchanged or acquired by different organizations. Standard access control mechanisms either restrict or completely grant access to valuable data. On the other hand, data obfuscation limits the overall usability and may result in loss of total value. There are no standard policy enforcement mechanisms for data acquired through mutual and copyright agreements. In practice, many different types of policies can be enforced in protecting data privacy. Hence there is the need for an unified framework that encapsulates multiple suites of policies to protect the data.               We present our vision of an architecture named security automata model (SAM) to enforce privacy-preserving policies and usage restrictions. SAM analyzes the input queries and their outputs to enforce various policies, liberating data owners from the burden of monitoring\u00a0\u2026", "num_citations": "5\n", "authors": ["350"]}
{"title": "A theory of gray security policies\n", "abstract": " This paper generalizes traditional models of security policies, from specifications of whether programs are secure, to specifications of how secure programs are. This is a generalization from qualitative, black-and-white policies to quantitative, gray policies. Included are generalizations from traditional definitions of safety and liveness policies to definitions of gray-safety and gray-liveness policies. These generalizations preserve key properties of safety and liveness, including that the intersection of safety and liveness is a unique allow-all policy and that every policy can be written as the conjunction of a single safety and a single liveness policy. It is argued that the generalization provides several benefits, including that it serves as a unifying framework for disparate approaches to security metrics, and that it separates\u2014in a practically useful way\u2014specifications of how secure systems are from specifications of\u00a0\u2026", "num_citations": "5\n", "authors": ["350"]}
{"title": "Inline visualization of concerns\n", "abstract": " Code modularization provides benefits throughout the software life cycle; however, the presence of crosscutting concerns (CCCs) in software hinders its complete modularization. This paper describes IVCon, a tool with a novel approach for completely modularizing CCCs. IVCon enables users to create, examine, and modify their code in two different views: the woven view and the unwoven view. The woven view displays program code in colors that indicate which CCCs various code segments implement. The unwoven view displays code in two panels, one showing the core of the program and the other showing all the code implementing each concern in an isolated module. IVCon aims to provide an easy-to-use interface for conveniently creating, examining, and modifying code in, and translating between, the woven and unwoven views.", "num_citations": "5\n", "authors": ["350"]}
{"title": "Defining and visualizing many-to-many relationships between concerns and code\n", "abstract": " Code modularization provides benefits throughout the software life cycle; however, the presence of crosscutting concerns (CCCs) in software hinders its complete modularization. In this paper, we describe IVCon, a GUI-based tool that provides a novel approach to modularization of CCCs. IVCon enables users to create, examine, and modify their code in two different views, the woven view and the unwoven view. The woven view displays program code in colors that indicate which CCCs various code segments implement. The unwoven view displays code in two panels, one showing the core of the program and the other showing all the code implementing each concern in an isolated module. IVCon aims to provide an easy-to-use interface for conveniently creating, examining, and modifying code in, and translating between, the woven and unwoven views.", "num_citations": "5\n", "authors": ["350"]}
{"title": "Optical inspection method utilizing ultraviolet light\n", "abstract": " A system and method for inspecting structures formed on the surface of an object using ultraviolet (UV) light. The object is placed in position and illuminated with at least one wavelength of UV light, directed at its surface from a UV source. At the moment of illumination, an image is captured by a UV-light sensitive camera positioned at an angle calculated to intercept light diffracted at particular an angle of diffraction associated with the pattern of structures formed on the surface of the object. To avoid having to repeatedly reposition the camera, one (or more in succession) illumination wavelength is selected to direct an intensity peak associated with a particular order of diffraction at the camera location. Ideally, a visible-light sensitive camera is also used to capture images of the surface when illumination with UV light results in the emanation of light in the visible portion of the spectrum.", "num_citations": "5\n", "authors": ["350"]}
{"title": "ProTO: Proactive Topology Obfuscation Against Adversarial Network Topology Inference\n", "abstract": " The topology of a network is fundamental for building network infrastructure functionalities. In many scenarios, enterprise networks may have no desire to disclose their topology information. In this paper, we aim at preventing attacks that use adversarial, active end-to-end topology inference to obtain the topology information of a target network. To this end, we propose a Proactive Topology Obfuscation (ProTO) system that adopts a detect-then-obfuscate framework: (i) a lightweight probing behavior identification mechanism based on machine learning is designed to detect any probing behavior, and then (ii) a topology obfuscation design is developed to proactively delay all identified probe packets in a way such that the attacker will obtain a structurally accurate yet fake network topology based on the measurements of these delayed probe packets, therefore deceiving the attacker and decreasing its appetency for\u00a0\u2026", "num_citations": "4\n", "authors": ["350"]}
{"title": "Systems and methods for authentication using authentication votes\n", "abstract": " A system and method of authentication is described. In operation, an authenticator computing device receives a request to access a resource from a requesting user. In response to the request, the authenticator computing device generates and transmits an authentication vote query to one or more voting users, wherein the one or more voting users includes at least one user other than the user requesting access to the resources. The one or more voting users then respond by transmitting authentication votes to the authenticator. Alternatively, a proxy may be used to cast the authentication votes of the one or more voting users. The authenticator computing device then analyzes the authentication votes to determine whether the requesting user requesting access to the resource should be granted access and grants the requesting user access to the resource based upon the analysis of the authentication votes.", "num_citations": "3\n", "authors": ["350"]}
{"title": "Through the lens of code granularity: A unified approach to security policy enforcement\n", "abstract": " A common way to characterize security enforcement mechanisms is based on the time at which they operate. Mechanisms operating before a program\u2019s execution are static mechanisms, and mechanisms operating during a program\u2019s execution are dynamic mechanisms. This paper introduces a different perspective and classifies mechanisms based on the granularity of program code that they monitor. Classifying mechanisms in this way provides a unified view of security mechanisms and shows that all security mechanisms can be encoded as dynamic mechanisms that operate at different levels of program code granularity. The practicality of the approach is demonstrated through a prototype implementation of a framework for enforcing security policies at various levels of code granularity on Java bytecode applications.", "num_citations": "2\n", "authors": ["350"]}
{"title": "Cybersecurity Vulnerabilities in Mobile Fare Payment Applications: A Case Study\n", "abstract": " Mobile fare payment applications are becoming increasingly common in the public transportation industry as a convenience for customers and as part of an effort to reduce fare management costs and improve operations for agencies. However, there is relatively little literature on vulnerabilities and liabilities in mobile fare payment applications. Furthermore, few public agencies or supporting vendors have policies or established processes in place to receive vulnerability reports or patch vulnerabilities discovered in their technologies. Given the rapidly increasing number of data breaches in general industry IT systems, as well as that mobile fare payment apps are a nexus between customer and agency financial information, the security of these mobile applications deserves further scrutiny. This paper presents a vulnerability discovered in a mobile fare payment application deployed at a transit agency in Florida that\u00a0\u2026", "num_citations": "2\n", "authors": ["350"]}
{"title": "Poco: A language for specifying obligation-based policy compositions\n", "abstract": " Existing security-policy-specification languages allow users to specify obligations, but challenges remain in the composition of complex obligations, including effective approaches for resolving conflicts between policies and obligations and allowing policies to react to other obligations. This paper presents PoCo, a policy-specification language and enforcement system for the principled composition of atomic-obligation policies. PoCo enables policies to interact meaningfully with other policies' obligations, thus preventing unexpected and insecure behaviors that can arise from partially executed obligations or obligations that execute actions in violation of other policies.", "num_citations": "2\n", "authors": ["350"]}
{"title": "Stream-monitoring automata\n", "abstract": " Over the past nearly twenty years, numerous formal models of enforcement and runtime monitors have been investigated. This paper takes the lessons learned from earlier models and proffers a new general model of runtime enforcement that is more suitable for modeling security mechanisms that operate over infinite event streams. The new model, called Stream-Monitoring Automata (SMAs), enables the constraints and analyses of interest in previous models to be encoded, and overcomes several shortcomings of existing models with respect to expressiveness. SMAs capture the practical abilities of mechanisms to monitor infinite event streams, execute even in the absence of event inputs, enforce non-safety policies, and operate an enforcement model in which extraneous constraints such as transparency and uncontrollable events may be specified as meta-policies.", "num_citations": "2\n", "authors": ["350"]}
{"title": "Composition of Atomic-Obligation Security Policies\n", "abstract": " There has been significant work to date on policy-specification languages that allow specification of arbitrary obligations, but there continues to exist open challenges in the composition of these arbitrary obligations, especially when obligations can be complex (ie consist more than one action). There are currently no solutions that allow complete and automatic resolution of conflicts between policies and other policies' obligations or that allow policies to react to the complex obligations of other policies. In particular, there is minimal work that considers the benefits and challenges of allowing complex obligations that operate in an atomic fashion, that is that execute in their entirety or not at all. This dissertation presents PoCo, a policy-specification language and enforcement system that allows for the principled composition of atomic-obligation policies. PoCo enables policies to interact meaningfully with other policies'\u00a0\u2026", "num_citations": "2\n", "authors": ["350"]}
{"title": "A Dual-Task Interference Game-Based Experimental Framework for Comparing the Usability of Authentication Methods\n", "abstract": " This paper introduces a game-based framework to compare the usability of authentication methods. The framework uses a dual-task interference technique to determine the usability of authentication methods. In the experiment, subjects participate in a multi-tasking game that simulates a conversation being interrupted by authentication requirements. By simulating a conversation, the goal is to reproduce a real use of authentication, and collect ecologically sound data. Participants also perform each authentication method in a standalone manner, which allows for comparison of the usability under two different cognitive loads. The authentication techniques evaluated represent each of the three main authentication factors, specifically password, fingerprint, and coauthentication. The three aspects of usability used to compare authentication techniques in this framework are efficiency, effectiveness, and satisfaction. An\u00a0\u2026", "num_citations": "2\n", "authors": ["350"]}
{"title": "Adiabatic dynamic differential logic for differential power analysis resistant secure integrated circuits\n", "abstract": " An adiabatic dynamic differential logic circuit is provided for mitigating a differential power analysis (DPA) attack on a secure integrated chip including a plurality of transistors configured to perform each of a plurality of two-input logical output calculations, wherein each of the two-input logical output calculations results in a minimal differential power of the logic circuit. In one embodiment, a high-performance adiabatic dynamic differential logic circuit is provided which is optimized for very high operating frequencies. In another embodiment, a body-biased adiabatic dynamic differential logic circuit is provided which utilizes transistor body biasing to improve the switching time and differential power of the design.", "num_citations": "2\n", "authors": ["350"]}
{"title": "IVCon: Inline visualization of concerns\n", "abstract": " Code modularization provides benefits throughout the software life cycle; however, the presence of crosscutting concerns (CCCs) in software hinders its complete modularization. This paper describes IVCon, a tool with a novel approach for completely modularizing CCCs. IVCon enables users to create, examine, and modify their code in two different views: the woven view and the unwoven view. The woven view displays program code in colors that indicate which CCCs various code segments implement. The unwoven view displays code in two panels, one showing the core of the program and the other showing all the code implementing each concern in an isolated module. IVCon provides an interface for conveniently creating, examining, and modifying code in, and translating between, the woven and unwoven views.", "num_citations": "2\n", "authors": ["350"]}
{"title": "An Analysis of the Role of Situated Learning in Starting a Security Culture in a Software Company\n", "abstract": " We conducted an ethnographic study of a software development company to explore if and how a development team adopts security practices into the development lifecycle. A PhD student in computer science with prior training in qualitative research methods was embedded in the company for eight months. The researcher joined the company as a software engineer and participated in all development activities as a new hire would, while also making observations on the development practices. During the fieldwork, we observed a positive shift in the development team's practices regarding secure development. Our analysis of data indicates that the shift can be attributed to enabling all software engineers to see how security knowledge could be applied to the specific software products they worked on. We also observed that by working with other developers to apply security knowledge under the concrete context where the software products were built, developers who possessed security expertise and wanted to push for more secure development practices (security advocates) could be effective in achieving this goal. Our data point to an interactive learning process where software engineers in a development team acquire knowledge, apply it in practice, and contribute to the team, leading to the creation of a set of preferred practices, or\" culture\" of the team. This learning process can be understood through the lens of the situated learning framework, where it is recognized that knowledge transfer happens within a community of practice, and applying the knowledge is the key in individuals (software engineers) acquiring it and the community\u00a0\u2026", "num_citations": "1\n", "authors": ["350"]}
{"title": "An Evaluation of the Power Consumption of Coauthentication as a Continuous User Authentication Method in Mobile Systems\n", "abstract": " Methods for continuous user authentication have become important with the proliferation of mobile devices in m-Health and human-centered systems. These methods must guarantee user identity with high assurance, authenticate without explicit intervention, and be power-aware. We present an evaluation of the power consumption of collaborative authentication (coauthentication) as a continuous authentication method. Coauthentication is a single-factor method in which multiple registered devices work together to authenticate a user, minimizing obtrusiveness while providing high user authentication assurance. To evaluate coauthentication's power consumption, we conducted experiments using two Bluetooth-enabled mobile devices and a stand-alone server in a local area network and running coauthentication continuously for eight hours. We found that the protocol uses approximately between 1.19% and 4.0\u00a0\u2026", "num_citations": "1\n", "authors": ["350"]}
{"title": "Systems and methods for generating symmetric cryptographic keys\n", "abstract": " A system for generating symmetric cryptographic keys for communications between hosts. Hosts use associated devices to generate secret keys. Each key is generated based on a static seed and a dynamic seed. The dynamic seed is created from sensor data or auxiliary data. The secret key allows host machines to encrypt, or decrypt, plaintext messages sent to, or received from, other host machines.", "num_citations": "1\n", "authors": ["350"]}
{"title": "POSTER: Towards precise and automated verification of security protocols in Coq\n", "abstract": " Security protocol verification using commonly-used model-checkers or symbolic protocol verifiers has several intrinsic limitations. Spin suffers the state explosion problem; Proverif may report false attacks. An alternative approach is to use Coq. However, the effort required to verify protocols in Coq is high for two main reasons: correct protocol and property specification is a non-trivial task, and security proofs lack automation. This work claims that (1) using Coq for verification of cryptographic protocols can sometimes yield better results than Spin and Proverif, and (2) the verification process in Coq can be greatly alleviated if specification and proof engineering techniques are applied. Our approach is evaluated by verifying several representative case studies. Preliminary results are encouraging, we were able to verify two protocols that give imprecise results in Spin and Proverif, respectively. Further, we have\u00a0\u2026", "num_citations": "1\n", "authors": ["350"]}
{"title": "Induction on Failing Derivations\n", "abstract": " A proof technique, called induction on failing derivations, is introduced. We wish to prove properties of judgments in deductive systems. Standard techniques exist for proving such properties on valid judgments; this note defines a technique for proving such properties on invalid (underivable) judgments.", "num_citations": "1\n", "authors": ["350"]}
{"title": "System and method for preventing unwanted electronic communications\n", "abstract": " An email system, configured by creating a user controlled email domain for each user, rather than a dedicated email address. The user is then allowed to create unlimited email addresses within the user controlled email domain. The system and method of the present invention provides improved policing of unwanted email communications. When unwanted communications on a compromised email address are detected, they can be identified and effortlessly subverted while known communicators may continue use of the compromised email address.", "num_citations": "1\n", "authors": ["350"]}
{"title": "Dimension-independent Table-based Firewalls\n", "abstract": " A firewall matches network packets to applicable policy rules based on packet dimensions (ie, packet fields such as source and destination IP addresses). The efficiency with which firewalls match packets to rules plays a major role in determining a firewall\u2019s overall efficiency and resistance to flooding-based denial-of-service (DoS) attacks. However, publicly available firewalls perform rule matching with an inefficient, though simple, linear algorithm. The linearsearch algorithm traverses through the firewall\u2019s rule base, one rule at a time, until finding an applicable rule for the given network packet or until exhausting the rule base. The linear-search algorithm is inefficient for medium-and large-sized rule bases. This paper proposes a more efficient, but only slightly more complicated, firewall rule-search algorithm based on statically prepared tables and bit arrays. Each statically prepared table maps a number of packet bits (which do not necessarily correspond to a packet dimension) to a bit array that indicates which rules apply for those packet bits. The firewall determines which rules apply for an entire packet by intersecting the sets of rules that apply for each piece of packet data.We analyze and evaluate our dimension-independent table-based algorithm. We provide techniques that firewalls can use to automatically calculate the optimal number and sizes of lookup tables within given space constraints. Our analysis and experiments confirm that dimensionindependent table-based firewalls are more efficient, and significantly more robust during DoS attacks, than either linear-search firewalls or dimension-dependent table-based firewalls.", "num_citations": "1\n", "authors": ["350"]}
{"title": "A Dynamic Query-Rewriting Mechanism for Role-Based Access Control in Databases\n", "abstract": " Although Role-Based Access Control (RBAC) is a common security model currently, it has not been systematically applied in databases. In this paper, we propose a framework that enforces RBAC based on dynamic query rewriting. This framework grants privileges to data based on an intersection of roles, database structures, content, and privileges. All of this is implemented at the database level, which also offers a centralized location for administering security policies. We have implemented the framework within a healthcare setting.", "num_citations": "1\n", "authors": ["350"]}
{"title": "Special issue on foundations of aspect-oriented programming\n", "abstract": " This SCP special collects articles that make contributions to the foundations of aspectoriented programming (AOP). Aspects have been developed over the last 10 years to facilitate the modularization of crosscutting concerns, ie, concerns that crosscut with the primary modularization of a program. This special issue further continues the efforts of the annual FOAL workshop (Foundations of Aspect-Oriented Languages) in so far that it supports and integrates research on firm foundations of AOP. There are 5 contributions addressing the following issues:(i) a fundamental core language for aspects;(ii) subtleties of so-called around advice;(iii) aspects in higher-order languages;(iv) the interaction between aspects and generics;(v) a notion of aspects for reactive systems based on synchronous languages.", "num_citations": "1\n", "authors": ["350"]}