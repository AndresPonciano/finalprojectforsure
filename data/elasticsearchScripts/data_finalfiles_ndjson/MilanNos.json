{"title": "Recording concerns in source code using annotations\n", "abstract": " A concern can be characterized as a developer\u05f3s intent behind a piece of code, often not explicitly captured in it. We discuss a technique of recording concerns using source code annotations (concern annotations). Using two studies and two controlled experiments, we seek to answer the following 3 research questions: (1) Do programmers\u05f3 mental models overlap? (2) How do developers use shared concern annotations when they are available? (3) Does using annotations created by others improve program comprehension and maintenance correctness, time and confidence? The first study shows that developers\u05f3 mental models, recorded using concern annotations, overlap and thus can be shared. The second study shows that shared concern annotations can be used during program comprehension for the following purposes: hypotheses confirmation, feature location, obtaining new knowledge, finding\u00a0\u2026", "num_citations": "29\n", "authors": ["2167"]}
{"title": "XML to annotations mapping definition with patterns\n", "abstract": " Currently, the most commonly created formal languages are configuration    languages. So far source code annotations and XML are the leading notations    for configuration languages. In this paper, we analyse the correspondence    between these two formats. We show that there are typical XML to annotations    mapping solutions (mapping patterns) that indicate a correspondence between    embedded and external metadata formats in general. We argue that mapping    patterns facilitate creating configuration tools and we use a case study to    show how they can be used to devise a mapping between these two notations.", "num_citations": "22\n", "authors": ["2167"]}
{"title": "Pragmatic model-driven software development from the viewpoint of a programmer: Teaching experience\n", "abstract": " Model-driven software development is surrounded by numerous myths and misunderstandings that hamper its adoption. We have designed our course of model-driven development approach with the goal to introduce it from the viewpoint of a programmer as a pragmatic tool for solving concrete problems in development process. The course covers several techniques and principles of model-driven development instead of concentrating on a single tool. To explain these techniques we use a case-study that is iteratively developed by the students during the course. In the paper we explain the structure of our case study, contents of individual iterations, and our overall experience with this approach.", "num_citations": "20\n", "authors": ["2167"]}
{"title": "Language composition using source code annotations\n", "abstract": " In this paper we examine source code annotations from the viewpoint of formal    languages - we discuss their abstract syntax, concrete syntax, and semantics,    thus showing the correspondence between annotations and formal languages. We    propose to consider a set of all annotations and their parameters processed    by the same reference implementation (they belong to the same domain) to be    called an annotation-based language. The performed analysis also pinpoints a    specificity of annotations in comparison with formal languages in general -    the binding between annotations and a host language. We elaborate this idea    with an analysis of annotations\u2019 potential for language composition, in    particular for pure embedding. We then show how pure embedding with    annotations can be used for language unification, language referencing by    extension, and language extension. This work provides a basis for further    research in the field of source code annotations in the context of formal    languages.", "num_citations": "19\n", "authors": ["2167"]}
{"title": "Reusable software documentation with phrase annotations\n", "abstract": " Abstract", "num_citations": "19\n", "authors": ["2167"]}
{"title": "Leveraging Program Comprehension with Concern-oriented Source Code Projections\n", "abstract": " In this paper we briefly introduce our concern-oriented source code projections that enable looking at same source code in multiple different ways. The objective of this paper is to discuss projection creation process in detail and to explain benefits of using projections to aid program comprehension. We achieve this objective by showing a case study that illustrates using projections on examples. Presented case study was done using our prototypical tool that is implemented as a plugin for NetBeans IDE. We briefly introduce the tool and present an experiment that we have conducted with a group of students at our university. The results of the experiment indicate that projections have positive effect on program comprehension.", "num_citations": "19\n", "authors": ["2167"]}
{"title": "Customizing host IDE for non-programming users of pure embedded DSLs: A case study\n", "abstract": " Pure embedding as an implementation strategy of domain-specific languages (DSLs) benefits from low implementation costs. On the other hand, it introduces undesired syntactic noise that impedes involvement of non-programming domain experts. Due to this, pure embedded DSLs are generally not intended for, nor used by, non-programmers. In this work, we try to challenge this state by experimenting with inexpensive customizations of the host IDE (Integrated Development Environment) to reduce the negative impact of syntactic noise. We present several techniques and recommendations based on standard IDE features (e.g., file templates, code folding, etc.) that aim to reduce syntactic noise and generally improve the user experience with pure embedded DSLs. The techniques are presented using a NetBeans IDE case study. The goal of the proposed techniques is to improve the user experience with pure\u00a0\u2026", "num_citations": "16\n", "authors": ["2167"]}
{"title": "Preliminary report on empirical study of repeated fragments in internal documentation\n", "abstract": " In this paper we present preliminary results of an empirical study, in which we used copy/paste detection (PMD CPD implementation) to search for repeating documentation fragments. The study was performed on 5 open source projects, including Java 8 SDK sources. The study shows that there are many occurrences of copy-pasting documentation fragments in the internal documentation, e.g., copy-pasted method parameter description. Besides these, many of the copy-pasted fragments express some domain or design concern, e.g., that the method is obsolete and deprecated. Therefore the study indicates that the cross-cutting concerns are present in the internal documentation in form of documentation phrases.", "num_citations": "16\n", "authors": ["2167"]}
{"title": "Supporting multiple configuration sources using abstraction\n", "abstract": " Software engineers have long recognized the need to shift focus from developing systems to developing system families. One way to develop software family is to develop configurable systems. A configuration (initial settings of a program), written in application-specific language, can be expressed using many different formats, such as XML, YAML, attribute-oriented programming, etc., each one having pros and cons. Often the target group of users is too wide to meet their expectations by using only one format. This paper analyzes options that system providers have in supporting multiple configuration languages or sources. An enhanced abstraction tool is chosen as the best solution, and its architecture is briefly presented. The main contribution to the tool\u2019s design is advocation of the declarative representation of mapping of input languages to output format.", "num_citations": "16\n", "authors": ["2167"]}
{"title": "Sharing developers' mental models through source code annotations\n", "abstract": " Context: Developers possess mental models containing information far beyond what is explicitly captured in the source code. Objectives: We investigate the possibility to use source code annotations to capture parts of the developers' mental models and later reuse them by other programmers during program comprehension and maintenance. Method: We performed two studies and a controlled experiment. Results: Developers' mental models overlap and thus can be shared. Possible use cases of shared annotations are hypotheses confirmation, feature location, obtaining new knowledge, finding relationships and maintenance notes. In the experiment, the presence of annotations reduced program comprehension and maintenance time by 34%. Conclusion: Annotations are a viable way to share programmers' thoughts.", "num_citations": "13\n", "authors": ["2167"]}
{"title": "Challenges in preserving intent comprehensibility in software\n", "abstract": " Software is not only difficult to create, but it is also difficult to understand. Even the authors themselves in a relatively short time become unable to readily interpret their own code and to explain what intent they have followed by it. Software is being created with the goal to satisfy the needs of a customer or directly of the end users. Out of these needs comes the intent, which is relatively well understandable to all stakeholders. By using other specialized modeling techniques (typically the UML language) or in the code itself, use cases and other high-level specification and analytical artifacts in common software development almost completely dissolve. Along with dedicated initiatives to improve preserving intent comprehensibility in software, such as literate programming, intentional programming, aspect-oriented programming, or the DCI (Data, Context and Interaction) approach, this issue is a subject of contemporary research in the re-revealed area of engaging end users in software development, which has its roots in Alan Kay's vision of a personal computer programmable by end users. From the perspective of the reality of complex software system development, the existing approaches are solving the problem of losing intent comprehensibility only partially by a simplified and limited perception of the intent and do this only at the code level. This paper explores the challenges in preserving the intent comprehensibility in software. The thorough treatment of this problem requires a number of techniques and approaches to be engaged, including preserving use cases in the code, dynamic code structuring, executable intent representation using\u00a0\u2026", "num_citations": "9\n", "authors": ["2167"]}
{"title": "Teaching pragmatic model-driven software development\n", "abstract": " Model-driven software development is surrounded by numerous myths and    misunderstandings that hamper its adoption. For long, our students were    victims of these myths and considered MDSD impractical and only applied in    academy. In this paper we discuss these myths and present our experience with    devising an MDSD course that challenges them and motivates students to    understand MDSD principles. The main contribution of this work is a set of    MDSD teaching guidelines that can make the course pragmatic in the eyes of    students - programmers. These guidelines introduce MDSD from the viewpoint of    a programmer as a pragmatic tool for solving concrete problems in the    development process. In our MDSD course we implemented the presented    guidelines. The course shows several techniques and principles of    model-driven development in multiple incremental iterations instead of    concentrating on a single tool. At the same time we unite these techniques by    using a dynamic visualisation tool that shows to the students the whole    infrastructure in the big picture. The course is implemented as an iterative    incremental MDSD case study. The paper concludes with a survey performed with    our students that indicates positive results of the approach.", "num_citations": "7\n", "authors": ["2167"]}
{"title": "Bootstrapping DSLs from user interfaces\n", "abstract": " Implementation of domain-specific languages (DSLs) is supported by powerful tools that can automatically generate various artifacts from the language specification. Domain analysis and design of a language, however, are usually done manually. Automatic extraction of domain information can be used to generate preliminary version of the language specification and therefore bootstrap the development process. One of the most suitable sources of domain information are graphical user interfaces (GUIs). In this paper we present the experiment validating this approach. Several existing applications were automatically analyzed to extract their domain models and generate a DSL processor based on them.", "num_citations": "4\n", "authors": ["2167"]}
{"title": "Common Abstraction of Configuration from Multiple Sources\n", "abstract": " Configuration is an important part of design of software systems. There are many different configuration formats, such as XML, YAML, attribute-oriented programming, etc., that allow system provider to design configuration language according to his requirements. Target group of system users is often very wide and one configuration language can not meet all user requirements. The paper introduces and analyzes idea of supporting multiple configuration sources using common abstraction of configuration sources in order to meet more user requirements without severe increase of provider\u2019s costs. The paper presents design of tool providing common abstraction of configuration sources. Design is based on analysis of existing tools, and it is extended with idea of declarative representation of mapping of configuration languages to output format and of process of their combining. At last, the paper presents proof-of-concept implementation of the tool called Bridge To Equalia and states several conclusions based on experiments realized with Bridge To Equalia.", "num_citations": "3\n", "authors": ["2167"]}
{"title": "Unified compile-time and runtime java annotation processing\n", "abstract": " Java provides two different options for processing source code annotations. One of them is the annotation processing API used in compile time, and the other is the Reflection API used in runtime. Both options provide different API for accessing program metamodel. In this paper, we examine the differences between those representations and we discuss options on how to unify these models along with advantages and disadvantages of this approach. Based on this proposal, we design a unified Java language model and present a prototype tool which can populate a unified model during both compilation and runtime. The paper includes the designed API of this unified language model. To verify our approach, we have performed experiments to show the usability of the unified metamodel.", "num_citations": "2\n", "authors": ["2167"]}
{"title": "Practical experience with task-driven case studies\n", "abstract": " The problem of effective teaching of programming is still open. Students still face problems with learning and especially understanding of even basic programming principles. In this paper we present our experiences with our modern teaching method for programming that is basically a combination of the task-driven methodology and case study approach. This new method is called task-driven case study approach. In the paper we share our own experiences from the viewpoint of teachers, but we also present results of a survey done with 112 of our students. Presented results show positive experience both from viewpoint of students and teachers.", "num_citations": "2\n", "authors": ["2167"]}
{"title": "Generating Case Studies from Annotated Sources Codes.\n", "abstract": " This paper present method for reducing inconsistency risks between task-driven case studies and their model solutions. The risks are a consequence of the scattered tasks' definitions between model solution and the XML scenarios. We used attribute-oriented programming and generative approach to embed tasks definitions into the model solution and this way we managed to keep all the model solution relevant information on the same place-the source code. The paper presents the motivation for this work and the method itself as well.", "num_citations": "2\n", "authors": ["2167"]}
{"title": "XML to Annotations Mapping Patterns\n", "abstract": " Configuration languages based on XML and source code annotations are very popular in the industry. There are situations in which there are reasons to move configuration languages from one format to the other, or to support multiple configuration languages. In such cases mappings between languages based on these formats have to be defined. Mapping can be used to support multiple configuration languages or to seamlessly move configurations from annotations to XML or vice versa. In this paper, we present XML to annotations mapping patterns that can be used to map languages from one format to the other.", "num_citations": "2\n", "authors": ["2167"]}
{"title": "Towards developer-friendly annotation-based code generation\n", "abstract": " This paper discusses a generative programming technique based on attribute-oriented programming (source code annotations) and aspect-oriented programming. We propose an annotation-based generator framework that combines these two techniques to provide a rapid and easy-to-use implementation options for annotation-based generators. The framework is inspired by internals of the industrial rapid application development tool Spring Roo. We discuss how the technique used in Spring Roo can be enhanced using Convention over Configuration principle. The paper briefly presents the generator framework prototype - AnBaG. We conclude with a discussion that compares the Spring Roo generation with AnBaG.", "num_citations": "1\n", "authors": ["2167"]}