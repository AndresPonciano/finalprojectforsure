{"title": "Partial evaluation of functional logic programs\n", "abstract": " Languages that integrate functional and logic programming with a complete operational semantics are based on narrowing, a unification-based goal-solving mechanism which subsumes the reduction principle of functional languages and the resolution principle of logic languages. In this article, we present a partial evaluation scheme for functional logic languages based on an automatic unfolding algorithm which builds narrowing trees. The method is formalized within the theoretical framework established by Lloyd and Shepherdson for the partial deduction of logic programs, which we have generalized for dealing with functional computations. A generic specialization algorithm is proposed which does not depend on the eager or lazy nature of the narrower being used. To the best of our knowledge,  this is the first generic algorithm for the specialization of functional logic programs. We also discuss the relation to\u00a0\u2026", "num_citations": "134\n", "authors": ["1828"]}
{"title": "Operational semantics for declarative multi-paradigm languages\n", "abstract": " Declarative multi-paradigm languages combine the most important features of functional, logic and concurrent programming. The computational model of such integrated languages is usually based on a combination of two different operational principles: narrowing and residuation. This work is motivated by the fact that a precise definition of an operational semantics including all aspects of modern multi-paradigm languages like laziness, sharing, non-determinism, equational constraints, external functions and concurrency does not exist. Therefore, in this article, we present the first rigorous operational description covering all the aforementioned features in a precise and understandable manner. We develop our operational semantics in several steps. First, we define a natural (big-step) semantics covering laziness, sharing and non-determinism. We also present an equivalent small-step semantics which additionally\u00a0\u2026", "num_citations": "131\n", "authors": ["1828"]}
{"title": "Specialization of lazy functional logic programs\n", "abstract": " Partial evaluation is a method for program specialization based on fold/unfold transformations [8, 25]. Partial evaluation of pure functional programs uses mainly static values of given data to specialize the program [15, 44]. In logic programming, the so-called static/dynamic distinction is hardly present, whereas considerations of determinacy and choice points are far more important for control [12]. We discuss these issues in the context of a (lazy) functional logic language. We formalize a two-phase specialization method for a non-strict, first order, integrated language which makes use of lazy narrowing to specialize the program w.r. t. a goal. The basic algorithm (first phase) is formalized as an instance of the framework for the partial evaluation of functional logic programs of [2, 3], using lazy narrowing. However, the results inherited by [2, 3] mainly regard the termination of the PE method, while the (strong) soundness\u00a0\u2026", "num_citations": "74\n", "authors": ["1828"]}
{"title": "A practical partial evaluator for a multi-paradigm declarative language\n", "abstract": " Partial evaluation is an automatic technique for program optimization which preserves program semantics. The range of its potential applications is extremely large, as witnessed by successful experiences in several fields. This paper summarizes our findings in the development of partial evaluation tools for Curry, a modern multi-paradigm declarative language which combines features from functional, logic and concurrent programming. From a practical point of view, the most promising approach appears to be a recent partial evaluation framework which translates source programs into a maximally simplified representation. We support this statement by extending the underlying method in order to design a practical partial evaluation tool for the language Curry. The process is fully automatic and can be incorporated into a Curry compiler as a source-to-source transformation on intermediate programs. An\u00a0\u2026", "num_citations": "72\n", "authors": ["1828"]}
{"title": "The narrowing-driven approach to functional logic program specialization\n", "abstract": " Partial evaluation is a semantics-based program optimization technique which has been investigated within different programming paradigms and applied to a wide variety of languages. Recently, a partial evaluation framework for functional logic programs has been proposed. In this framework, narrowing\u2014the standard operational semantics of integrated languages\u2014is used to drive the partial evaluation process. This paper surveys the essentials of narrowing-driven partial evaluation.", "num_citations": "65\n", "authors": ["1828"]}
{"title": "CauDEr: a causal-consistent reversible debugger for Erlang\n", "abstract": " Programming languages based on the actor model, such as Erlang, avoid some concurrency bugs by design. However, other concurrency bugs, such as message order violations and livelocks, can still show up in programs. These hard-to-find bugs can be more easily detected by using causal-consistent reversible debugging, a debugging technique that allows one to traverse a computation both forward and backward. Most notably, causal consistency implies that, when going backward, an action can only be undone provided that its consequences, if any, have been undone beforehand. To the best of our knowledge, we present the first causal-consistent reversible debugger for Erlang, which may help programmers to detect and fix various kinds of bugs, including message order violations and livelocks.", "num_citations": "50\n", "authors": ["1828"]}
{"title": "Narrowing-driven partial evaluation of functional logic programs\n", "abstract": " Languages that integrate functional and logic programming with a complete operational semantics are based on narrowing, a unification-based goal-solving mechanism which subsumes the reduction principle of functional languages and the resolution principle of logic languages. Formal methods of transformation of functional logic programs can be based on this well-established operational semantics. In this paper, we present a partial evaluation scheme for functional logic languages based on an automatic unfolding algorithm which builds narrowing trees. We study the semantic properties of the transformation and the conditions under which the technique terminates, is sound and complete, and is also generally applicable to a wide class of programs. We illustrate our method with several examples and discuss the relation with Supercompilation and Partial Evaluation. To the best of our knowledge, this is\u00a0\u2026", "num_citations": "46\n", "authors": ["1828"]}
{"title": "Improving control in functional logic program specialization\n", "abstract": " We have recently defined a framework for Narrowing-driven Partial Evaluation (NPE) of functional logic programs. This method is as powerful as partial deduction of logic programs and positive supercompilation of functional programs. Although it is possible to treat complex terms containing primitive functions (e.g. conjunctions or equations) in the NPE framework, its basic control mechanisms do not allow for effective polygenetic specialization of these complex expressions. We introduce a sophisticated unfolding rule endowed with a dynamic narrowing strategy which permits flexible scheduling of the elements (in conjunctions) which are reduced during specialization. We also present a novel abstraction operator which extends some partitioning techniques defined in the framework of conjunctive partial deduction. We provide experimental results obtained from an implementation using the Indy system\u00a0\u2026", "num_citations": "43\n", "authors": ["1828"]}
{"title": "Specialization of functional logic programs based on needed narrowing\n", "abstract": " Many functional logic languages are based on narrowing, a unification-based goal-solving mechanism which subsumes the reduction mechanism of functional languages and the resolution principle of logic languages. Needed narrowing is an optimal evaluation strategy which constitutes the basis of modern (narrowing-based) lazy functional logic languages. In this work, we present the fundamentals of partial evaluation in such languages. We provide correctness results for partial evaluation based on needed narrowing and show that the nice properties of this strategy are essential for the specialization process. In particular, the structure of the original program is preserved by partial evaluation and, thus, the same evaluation strategy can be applied for the execution of specialized programs. This is in contrast to other partial evaluation schemes for lazy functional logic programs which may change the program\u00a0\u2026", "num_citations": "38\n", "authors": ["1828"]}
{"title": "A semantics for tracing declarative multi-paradigm programs\n", "abstract": " We introduce the theoretical basis for tracing lazy functional logic computations in a declarative multi-paradigm language like Curry. Tracing computations is a difficult task due to the subtleties of the underlying operational semantics which combines laziness and non-determinism. In this work, we define an instrumented operational semantics that generates not only the computed values and bindings but also an appropriate data structure---a sort of redex trail---which can be used to trace computations at an adequate level of abstraction. In contrast to previous approaches, which rely solely on a transformation to instrument source programs, the formal definition of a tracing semantics improves the understanding of the tracing process. Furthermore, it allows us to formally prove the correctness of the computed trail. A prototype implementation of a tracer based on this semantics demonstrates the usefulness of our\u00a0\u2026", "num_citations": "38\n", "authors": ["1828"]}
{"title": "A transformation system for lazy functional logic programs\n", "abstract": " Needed narrowing is a complete operational principle for modern declarative languages which integrate the best features of (lazy) functional and logic programming. We define a transformation methodology for functional logic programs based on needed narrowing. We provide (strong) correctness results for the transformation system w.r.t. the set of computed values and answer substitutions and show that the prominent properties of needed narrowing -namely, the optimality w.r.t. the length of derivations and the number of computed solutions- carry over to the transformation process and the transformed programs. We illustrate the power of the system by taking on in our setting two well-known transformation strategies (composition and tupling). We also provide an implementation of the transformation system which, by means of some experimental results, highlights the benefits of our approach.", "num_citations": "38\n", "authors": ["1828"]}
{"title": "A theory of reversibility for Erlang\n", "abstract": " In a reversible language, any forward computation can be undone by a finite sequence of backward steps. Reversible computing has been studied in the context of different programming languages and formalisms, where it has been used for testing and verifica- tion, among others. In this paper, we consider a subset of Erlang, a functional and concurrent programming language based on the actor model. We present a formal semantics for reversible computation in this language and prove its main properties, including its causal consistency. We also build on top of it a rollback operator that can be used to undo the actions of a process up to a given checkpoint.", "num_citations": "37\n", "authors": ["1828"]}
{"title": "Rules+ strategies for transforming lazy functional logic programs\n", "abstract": " This work introduces a transformation methodology for functional logic programs based on needed narrowing, the optimal and complete operational principle for modern declarative languages which integrate the best features of functional and logic programming. We provide correctness results for the transformation system w.r.t. the set of computed values and answer substitutions and show that the prominent properties of needed narrowing\u2014namely, the optimality w.r.t. the length of derivations and the number of computed solutions\u2014carry over to the transformation process and the transformed programs. We illustrate the power of the system by taking on in our setting two well-known transformation strategies (composition and tupling). We also provide an implementation of the transformation system which, by means of some experimental results, highlights the potentiality of our approach.", "num_citations": "37\n", "authors": ["1828"]}
{"title": "Causal-consistent replay debugging for message passing programs\n", "abstract": " Debugging of concurrent systems is a tedious and error-prone activity. A main issue is that there is no guarantee that a bug that appears in the original computation is replayed inside the debugger. This problem is usually tackled by so-called replay debugging, which allows the user to record a program execution and replay it inside the debugger. In this paper, we present a novel technique for replay debugging that we call controlled causal-consistent replay. Controlled causal-consistent replay allows the user to record a program execution and, in contrast to traditional replay debuggers, to reproduce a visible misbehavior inside the debugger including all and only its causes. In this way, the user is not distracted by the actions of other, unrelated processes.", "num_citations": "32\n", "authors": ["1828"]}
{"title": "Specialization of inductively sequential functional logic programs\n", "abstract": " Functional logic languages combine the operational principles of the most important declarative programming paradigms, namely functional and logic programming. Inductively sequential programs admit the definition of optimal computation strategies and are the basis of several recent (lazy) functional logic languages. In this paper, we define a partial evaluator for inductively sequential functional logic programs. We prove strong correctness of this partial evaluator and show that the nice properties of inductively sequential programs carry over to the specialization process and the specialized programs. In particular, the structure of the programs is preserved by the specialization process. This is in contrast to other partial evaluation methods for functional logic programs which can destroy the original program structure. Finally, we present some experiments which highlight the practical advantages of our approach.", "num_citations": "30\n", "authors": ["1828"]}
{"title": "Measuring the effectiveness of partial evaluation in functional logic languages\n", "abstract": " We introduce a framework for assessing the effectiveness of partial evaluators in functional logic languages. Our framework is based on properties of the rewrite system that models a functional logic program. Consequently, our assessment is independent of any specific language implementation or computing environment. We define several criteria for measuring the cost of a computation: number of steps, number of function applications, and pattern matching effort. Most importantly, we express the cost of each criterion by means of recurrence equations over algebraic data types, which can be automatically inferred from the partial evaluation process itself. In some cases, the equations can be solved by transforming their arguments from arbitrary data types to natural numbers. In other cases, it is possible to estimate the improvement of a partial evaluation by analyzing the associated cost recurrence equations.", "num_citations": "29\n", "authors": ["1828"]}
{"title": "A partial evaluation framework for curry programs\n", "abstract": " In this work, we develop a partial evaluation technique for residuating functional logic programs, which generalize the concurrent computation models for logic programs with delays to functional logic programs. We show how to lift the nondeterministic choices from run time to specialization time. We ascertain the conditions under which the original and the transformed program have the same answer expressions for the considered class of queries as well as the same floundering behavior. All these results are relevant for program optimization in Curry, a functional logic language which is intended to become a standard in this area. Preliminary empirical evaluation of the specialized Curry programs demonstrates that our technique also works well in practice and leads to substantial performance improvements. To our knowledge, this work is the first attempt to formally define and prove correct a general\u00a0\u2026", "num_citations": "28\n", "authors": ["1828"]}
{"title": "A unifying view of functional and logic program specialization\n", "abstract": " We give a general introduction to the particular problems associated with the partial evaluation of functional logic programs, explain the relationship with similar techniques for functional and logic languages, and show that it is useful to transfer the technology of narrowing into a technique for driving specialization in integrated languages. l. FUNCTIONAL LOGIC PROGRAM SPECIALIZATIONThe aim of partial evaluation (PE) is to specialize a given program wrt part of its input data (hence also called program specialization). PE has been widely applied in the field of functional programming (FP)[5; 11] and logic programming (LP)[7; 14]. Although the objectives are similar, the general methods are often different due to the distinct underlying computation models. This separation has the negative consequence of duplicated work since developments are not shared and many similarities are overlooked. In recent years\u00a0\u2026", "num_citations": "28\n", "authors": ["1828"]}
{"title": "A reversible semantics for Erlang\n", "abstract": " In a reversible language, any forward computation can be undone by a finite sequence of backward steps. Reversible computing has been studied in the context of different programming languages and formalisms, where it has been used for debugging and for enforcing fault-tolerance, among others. In this paper, we consider a subset of Erlang, a concurrent language based on the actor model, and formally introduce a semantics for reversible computation. To the best of our knowledge, this is the first attempt to define a reversible semantics for Erlang.", "num_citations": "27\n", "authors": ["1828"]}
{"title": "Program inversion for tail recursive functions\n", "abstract": " Program inversion is a fundamental problem that has been addressed in many different programming settings and applications. In the context of term rewriting, several methods already exist for computing the inverse of an injective function. These methods, however, usually return non-terminating inverted functions when the considered function is tail recursive. In this paper, we propose a direct and intuitive approach to the inversion of tail recursive functions. Our new technique is able to produce good results even without the use of an additional post-processing of determinization or completion. Moreover, when combined with a traditional approach to program inversion, it constitutes a promising approach to define a general method for program inversion. Our experimental results confirm that the new technique compares well with previous approaches.", "num_citations": "27\n", "authors": ["1828"]}
{"title": "Safe folding/unfolding with conditional narrowing\n", "abstract": " Functional logic languages with a complete operational semantics are based on narrowing, a generalization of term rewriting where unification replaces matching. In this paper, we study the semantic properties of a general transformation technique called unfolding in the context of functional logic languages. Unfolding a program is defined as the application of narrowing steps to the calls in the program rules in some appropriate form. We show that, unlike the case of pure logic or pure functional programs, where unfolding is correct w.r.t. practically all available semantics, unrestricted unfolding using narrowing does not preserve program meaning, even when we consider the weakest notion of semantics the program can be given. We single out the conditions which guarantee that an equivalent program w.r.t. the semantics of computed answers is produced. Then, we study the combination of this technique\u00a0\u2026", "num_citations": "27\n", "authors": ["1828"]}
{"title": "Narrowing approximations as an optimization for equational logic programs\n", "abstract": " Solving equations in equational theories is a relevant programming paradigm which integrates logic and equational programming into one unified framework. Efficient methods based on narrowing strategies to solve systems of equations have been devised. In this paper, we formulate a narrowing-based equation solving calculus which makes use of a top-down abstract interpretation strategy to control the branching of the search tree. We define a refined, but still complete, equation solving procedure which allows us to reduce the branching factor. Our main idea consists of building an abstract narrower for equational theories and executing the set of equations to be solved in the approximated narrower. We define a generic technique of loop detection to ensure termination of our method. We prove that the set of answers computed by the abstract narrower has the property that each concrete solution of the set\u00a0\u2026", "num_citations": "27\n", "authors": ["1828"]}
{"title": "Operational semantics for functional logic languages\n", "abstract": " In this work we provide a semantic description of functional logic languages covering notions like laziness, sharing, and non-determinism. Such a semantic description is essential, for instance, to have appropriate language definitions in order to reason about programs and check the correctness of implementations. First, we define a \u201cbig-step\u201d semantics in natural style to relate expressions and their evaluated results. Since this semantics is not sufficient to reason about the operational aspects of programs, we also define a \u201csmall-step\u201d operational semantics covering the main features of functional logic languages. Finally, we demonstrate the equivalence of the \u201csmall-step\u201d semantics and the natural semantics.", "num_citations": "26\n", "authors": ["1828"]}
{"title": "Using an abstract representation to specialize functional logic programs\n", "abstract": " This paper introduces a novel approach for the specialization of functional logic languages. We consider a maximally simplified abstract representation of programs (which still contains all the necessary information) and define a non-standard semantics for these programs. Both things mixed together allow us to design a simple and concise partial evaluation method for modern functional logic languages, avoiding several limitations of previous approaches. Moreover, since these languages can be automatically translated into the abstract representation, our technique is widely applicable. In order to assess the practicality of our approach, we have developed a partial evaluation tool for the multi-paradigm language Curry. The partial evaluator is written in Curry itself and has been tested on an extensive benchmark suite (even a meta-interpreter). To the best of our knowledge, this is the first purely declarative\u00a0\u2026", "num_citations": "26\n", "authors": ["1828"]}
{"title": "Forward slicing by conjunctive partial deduction and argument filtering\n", "abstract": " Program slicing is a well-known methodology that aims at identifying the program statements that (potentially) affect the values computed at some point of interest. Within imperative programming, this technique has been successfully applied to debugging, specialization, reuse, maintenance, etc. Due to its declarative nature, adapting the slicing notions and techniques to a logic programming setting is not an easy task. In this work, we define the first, semantics-preserving, forward slicing technique for logic programs. Our approach relies on the application of a conjunctive partial deduction algorithm for a precise propagation of information between calls. We do not distinguish between static and dynamic slicing since partial deduction can naturally deal with both static and dynamic data. A slicing tool has been implemented in ecce, where a post-processing transformation to remove redundant arguments has\u00a0\u2026", "num_citations": "22\n", "authors": ["1828"]}
{"title": "INDY user's manual\n", "abstract": " Partial evaluation is a semantics-preserving optimization technique for computer programs which consists of the specialization of the program wrt parts of its input [5, 11]. This report introduces the Indy system, which, to our knowledge, is the first automatic partial evaluator for functional logic programs. Indy (Integrated Narrowing-Driven specialization system) is a rather concise implementation of the narrowing-driven partial evaluator of [1, 2]. In contrast to the approach usually taken with pure functional languages, Indy uses the unification-based computation mechanism of narrowing for specialization. This coincides with the usual execution mechanism of functional logic languages, which allows us to deal with expressions containing partial information by means of logical variables and unification in a natural way, as well as to consider efficient evaluation strategies and include a deterministic simplification phase (see, eg,[9]). This provides better opportunities for optimization and improves both the overall specialization and the efficiency of the method [4]).Indy is parametric wrt the narrowing strategy which is used for the automatic construction of (finite) narrowing trees. The system follows a structure which is similar to the framework developed by Martens and Gallagher [12] for partial deduction of logic programs, where a clear distinction between local and global control is done. Roughly speaking, local control concerns the construction of partial narrowing trees for single terms, while global control is dedicated to ensuring the closedness of the partially evaluated program, producing a sufficient number of specialized versions for each function\u00a0\u2026", "num_citations": "22\n", "authors": ["1828"]}
{"title": "Termination of narrowing via termination of rewriting\n", "abstract": " Narrowing extends rewriting with logic capabilities by allowing logic variables in terms and by replacing matching with unification. Narrowing has been widely used in different contexts, ranging from theorem proving (e.g., protocol verification) to language design (e.g., it forms the basis of functional logic languages). Surprisingly, the termination of narrowing has been mostly overlooked. In this work, we present a novel approach for analyzing the termination of narrowing in left-linear constructor systems\u2014a widely accepted class of systems\u2014that allows us to reuse existing methods in the literature on termination of rewriting.", "num_citations": "21\n", "authors": ["1828"]}
{"title": "Quasi-terminating logic programs for ensuring the termination of partial evaluation\n", "abstract": " One of the most important challenges in partial evaluation is the design of automatic methods for ensuring the termination of specialisation. It is well known that the termination of partial evaluation can be ensured when the considered computations are quasiterminating, ie, when only finitely many different calls occur.", "num_citations": "19\n", "authors": ["1828"]}
{"title": "A residualizing semantics for the partial evaluation of functional logic programs\n", "abstract": " Recent proposals for multi-paradigm declarative programming combine the most important features of functional, logic and concurrent programming into a single framework. The operational semantics of these languages is usually based on a combination of narrowing and residuation. In this paper, we introduce a non-standard, residualizing semantics for multi-paradigm declarative programs and prove its equivalence with a standard operational semantics. Our residualizing semantics is particularly relevant within the area of program transformation where it is useful, e.g., to perform computations during partial evaluation. Thus, the proof of equivalence is a crucial result to demonstrate the correctness of (existing) partial evaluation schemes.", "num_citations": "17\n", "authors": ["1828"]}
{"title": "Forward slicing of multi-paradigm declarative programs based on partial evaluation\n", "abstract": " Program slicing has been mainly studied in the context of imperative languages, where it has been applied to many software engineering tasks, like program understanding, maintenance, debugging, testing, code reuse, etc. This paper introduces the first forward slicing technique for multi-paradigm declarative programs. In particular, we show how program slicing can be defined in terms of online partial evaluation. Our approach clarifies the relation between both methodologies and provides a simple way to develop program slicing tools from existing partial evaluators.", "num_citations": "16\n", "authors": ["1828"]}
{"title": "Cost-augmented narrowing-driven specialization\n", "abstract": " The aim of many program transformers is to improve efficiency while preserving program meaning. Correctness issues have been dealt with extensively. However, very little attention has been paid to formally establish the improvements achieved by these transformers. In this work, we introduce the scheme of a narrowing-driven partial evaluator enhanced with abstract costs. They are \"abstract\" in the sense that they measure the number of basic operations performed during a computation rather than actual execution times. Thus, we have available a setting in which one can discuss the effects of the program transformer in a precise framework and, moreover, to quantify these effects. Our scheme may serve as a basis to develop speedup analyses and cost-guided transformers. An implementation of the cost-augmented specializer has been undertaken, which demonstrates the practicality of our approach.", "num_citations": "15\n", "authors": ["1828"]}
{"title": "Closed symbolic execution for verifying program termination\n", "abstract": " Symbolic execution, originally introduced as a method for program testing and debugging, is usually incomplete because of infinite symbolic execution paths. In this work, we adapt some well-known notions from partial evaluation in order to have a complete symbolic execution scheme which can then be used to check liveness properties like program termination. We also introduce a representation of the symbolic transitions as a term rewrite system so that existing termination provers for these systems can be used to verify the termination of the original program.", "num_citations": "14\n", "authors": ["1828"]}
{"title": "An Automatic Composition Algorithm for Functional Logic Programs\n", "abstract": " Functional logic languages with a complete operational semantics are based on narrowing, which combines the instantiation of variables with the reduction of expressions. In this paper, we investigate the relationship between partial evaluation and more general transformations based on folding/unfolding. First, we show that the transformations obtained by partial evaluators can be also achieved by folding/unfolding using a particular kind of eurekas which can be mechanically attained. Then, we propose an algorithm (based on folding/unfolding) which starts with the automatic eureka generation and is able to perform program composition, i. e. it is able to produce a single function definition for some nested functions of the original program. This avoids the construction of intermediate data structures that are produced by the inner function and consumed as inputs by the outer function. As opposed to both\u00a0\u2026", "num_citations": "14\n", "authors": ["1828"]}
{"title": "Symbolic profiling for multi-paradigm declarative languages\n", "abstract": " We present the basis of a source-level profiler for multi-paradigm declarative languages which integrate features from (lazy) functional and logic programming. Our profiling scheme is symbolic in the sense that it is independent of the particular language implementation. This is achieved by counting the number of basic operations performed during the execution of program calls, e.g., the number of unfolding steps, the number of matching operations, etc. The main contribution of this paper is the formal specification of the attribution of execution costs to cost centers, which is particularly difficult in the context of lazy languages. A prototype implementation of the symbolic profiler has been undertaken for the multi-paradigm language Curry. Preliminary results demonstrate the practicality of our approach and its applications in the field of program transformation.", "num_citations": "13\n", "authors": ["1828"]}
{"title": "Reversible term rewriting\n", "abstract": " Essentially, in a reversible programming language, for each forward computation step from state S to state S', there exists a constructive and deterministic method to go backwards from state S'to state S. Besides its theoretical interest, reversible computation is a fundamental concept which is relevant in many different areas like cellular automata, bidirectional program transformation, or quantum computing, to name a few. In this paper, we focus on term rewriting, a computation model that underlies most rule-based programming languages. In general, term rewriting is not reversible, even for injective functions; namely, given a rewrite step t1-> t2, we do not always have a decidable and deterministic method to get t1 from t2. Here, we introduce a conservative extension of term rewriting that becomes reversible. Furthermore, we also define a transformation to make a rewrite system reversible using standard term rewriting.", "num_citations": "12\n", "authors": ["1828"]}
{"title": "Concolic execution and test case generation in Prolog\n", "abstract": " Symbolic execution extends concrete execution by allowing symbolic input data and then exploring all feasible execution paths. It has been defined and used in the context of many different programming languages and paradigms. A symbolic execution engine is at the heart of many program analysis and transformation techniques, like partial evaluation, test case generation or model checking, to name a few. Despite its relevance, traditional symbolic execution also suffers from several drawbacks. For instance, the search space is usually huge (often infinite) even for the simplest programs. Also, symbolic execution generally computes an overapproximation of the concrete execution space, so that false positives may occur. In this paper, we propose the use of a variant of symbolic execution, called concolic execution, for test case generation in Prolog. Our technique aims at full statement coverage. We\u00a0\u2026", "num_citations": "12\n", "authors": ["1828"]}
{"title": "Lazy call-by-value evaluation\n", "abstract": " Designing debugging tools for lazy functional programming languages is a complex task which is often solved by expensive tracing of lazy computations. We present a new approach in which the information collected as a trace is reduced considerably (kilobytes instead of megabytes). The idea is to collect a kind of step information for a call-by-value interpreter, which can then efficiently reconstruct the computation for debugging/viewing tools, like declarative debugging. We show the correctness of the approach, discuss a proof-of-concept implementation with a declarative debugger as back end and present some benchmarks comparing our new approach with the Haskell debugger Hat.", "num_citations": "12\n", "authors": ["1828"]}
{"title": "Symbolic execution and thresholding for efficiently tuning fuzzy logic programs\n", "abstract": " Fuzzy logic programming is a growing declarative paradigm aiming to integrate fuzzy logic into logic programming. One of the most difficult tasks when specifying a fuzzy logic program is determining the right weights for each rule, as well as the most appropriate fuzzy connectives and operators. In this paper, we introduce a symbolic extension of fuzzy logic programs in which some of these parameters can be left unknown, so that the user can easily see the impact of their possible values. Furthermore, given a number of test cases, the most appropriate values for these parameters can be automatically computed. Finally, we show some benchmarks that illustrate the usefulness of our approach.", "num_citations": "11\n", "authors": ["1828"]}
{"title": "Concolic testing in logic programming\n", "abstract": " Software testing is one of the most popular validation techniques in the software industry. Surprisingly, we can only find a few approaches to testing in the context of logic programming. In this paper, we introduce a systematic approach for dynamic testing that combines both concrete and symbolic execution. Our approach is fully automatic and guarantees full path coverage when it terminates. We prove some basic properties of our technique and illustrate its practical usefulness through a prototype implementation.", "num_citations": "11\n", "authors": ["1828"]}
{"title": "Towards Erlang verification by term rewriting\n", "abstract": " This paper presents a transformational approach to the verification of Erlang programs. We define a stepwise transformation from (first-order) Erlang programs to (non-deterministic) term rewrite systems that compute an overapproximation of the original Erlang program. In this way, existing techniques for term rewriting become available. Furthermore, one can use narrowing as a symbolic execution extension of rewriting in order to design a verification technique. We illustrate our approach with some examples, including a deadlock analysis of a simple Erlang program.", "num_citations": "11\n", "authors": ["1828"]}
{"title": "Fast offline partial evaluation of large logic programs\n", "abstract": " In this paper, we present a fast binding-time analysis (BTA) by integrating a size-change analysis, which is independent of a selection rule, into a classical BTA for offline partial evaluation of logic programs. In contrast to previous approaches, the new BTA is conceptually simpler and considerably faster, scaling to medium-sized or even large examples and, moreover, it ensures both the so called local and global termination. We also show that through the use of selective hints, we can achieve both good specialisation results and a fast BTA and specialisation process.", "num_citations": "11\n", "authors": ["1828"]}
{"title": "Cost-augmented partial evaluation of functional logic programs\n", "abstract": " We enhance the narrowing-driven partial evaluation scheme for lazy functional logic programs with the computation of symbolic costs. The enhanced scheme allows us to estimate the effects of the program transformer in a precise framework and, moreover, to quantify these effects. The considered costs are \u201csymbolic\u201d in the sense that they measure the number of basic operations performed during a computation rather than actual execution times. Our scheme may serve as a basis to develop speedup analyses and cost-guided transformers. A cost-augmented partial evaluator, which demonstrates the usefulness of our approach, has been implemented in the multi-paradigm language Curry.", "num_citations": "11\n", "authors": ["1828"]}
{"title": "Uniform lazy narrowing\n", "abstract": " Needed narrowing is a complete and optimal operational principle for modern declarative languages which integrate the best features of lazy functional and logic programming. We investigate the formal relation between needed narrowing and another (not so lazy) narrowing strategy which is the basis for popular implementations of lazy functional logic languages. We demonstrate that needed narrowing and lazy narrowing are computationally equivalent over the class of uniform programs. We also introduce a complete refinement of lazy narrowing, called uniform lazy narrowing, which is still equivalent to needed narrowing over the aforementioned class. Since actual implementations of functional logic languages are based on the transformation of the original program into a uniform one\u2014which is then executed using a lazy narrowing strategy\u2014our results can be thought of as a formal basis for the correctness of\u00a0\u2026", "num_citations": "11\n", "authors": ["1828"]}
{"title": "A compositional semantic basis for the analysis of equational Horn programs\n", "abstract": " We introduce a compositional characterization of the operational semantics of equational Horn programs. Then we show that this semantics and the standard operational semantics based on (basic) narrowing coincide. We define an abstract narrower mimicking this semantics, and show how it can be used as a basis for efficient AND-compositional program analysis. As an application of our framework, we show a compositional analysis to detect the unsatisfiability of an equation set with respect to a given equational theory. We also show that our method allows us to perform computations and analysis incrementally in a Constraint Equational setting and that the test of satisfiability in this setting can be done in parallel.", "num_citations": "11\n", "authors": ["1828"]}
{"title": "Foundations of reversible computation\n", "abstract": " Reversible computation allows computation to proceed not only in the standard, forward direction, but also backward, recovering past states. While reversible computation has attracted interest for its multiple applications, covering areas as different as low-power computing, simulation, robotics and debugging, such applications need to be supported by a clear understanding of the foundations of reversible computation. We report below on many threads of research in the area of foundations of reversible computing, giving particular emphasis to the results obtained in the framework of the European COST Action IC1405, entitled \u201cReversible Computation-Extending Horizons of Computing\u201d, which took place in the years 2015\u20132019. c The Author (s) 2020 I. Ulidowski et al.(Eds.): RC 2020, LNCS 12070, pp. 1\u201340, 2020. https://doi. org/10.1007/978-3-030-47361-7 _ 1", "num_citations": "10\n", "authors": ["1828"]}
{"title": "Reversible computation in term rewriting\n", "abstract": " Essentially, in a reversible programming language, for each forward computation from state S to state S\u2032, there exists a constructive method to go backwards from state S\u2032 to state S. Besides its theoretical interest, reversible computation is a fundamental concept which is relevant in many different areas like cellular automata, bidirectional program transformation, or quantum computing, to name a few. In this work, we focus on term rewriting, a computation model that underlies most rule-based programming languages. In general, term rewriting is not reversible, even for injective functions; namely, given a rewrite step t 1\u2192 t 2, we do not always have a decidable method to get t 1 from t 2. Here, we introduce a conservative extension of term rewriting that becomes reversible. Furthermore, we also define two transformations, injectivization and inversion, to make a rewrite system reversible using standard term rewriting\u00a0\u2026", "num_citations": "10\n", "authors": ["1828"]}
{"title": "Fast offline partial evaluation of logic programs\n", "abstract": " One of the most important challenges in partial evaluation is the design of automatic methods for ensuring the termination of the process. In this work, we introduce sufficient conditions for the strong (i.e., independent of a computation rule) termination and quasi-termination of logic programs which rely on the construction of size-change graphs. We then present a fast binding-time analysis that takes the output of the termination analysis and annotates logic programs so that partial evaluation terminates. In contrast to previous approaches, the new binding-time analysis is conceptually simpler and considerably faster, scaling to medium-sized or even large examples.", "num_citations": "10\n", "authors": ["1828"]}
{"title": "A hybrid approach to conjunctive partial evaluation of logic programs\n", "abstract": " Conjunctive partial deduction is a well-known technique for the partial evaluation of logic programs. The original formulation follows the so called online approach where all termination decisions are taken on-the-fly. In contrast, offline partial evaluators first analyze the source program and produce an annotated version so that the partial evaluation phase should only follow these annotations to ensure the termination of the process. In this work, we introduce a lightweight approach to conjunctive partial deduction that combines some of the advantages of both online and offline styles of partial evaluation.", "num_citations": "9\n", "authors": ["1828"]}
{"title": "Compositional analysis for equational Horn programs\n", "abstract": " We introduce a compositional characterization of the operational semantics of equational Horn programs. Then we show that this semantics and the standard operational semantics based on (basic) narrowing coincide. We define an abstract narrower mimicking this semantics, and show how it can be used as a basis for efficient AND-compositional program analysis. As an application of our framework, we show a compositional analysis to detect the unsatisfiability of an equation set with respect to a given equational theory. We also show that our method allows us to perform computations and analysis incrementally in a Constraint Equational setting and that the test of satisfiability in this setting can be done in parallel.", "num_citations": "8\n", "authors": ["1828"]}
{"title": "A Formal Approach to Reasoning about the Effectiveness of Partial Evaluation.\n", "abstract": " We introduce a framework for assessing the effectiveness of partial evaluators in functional logic languages. Our framework is based on properties of the rewrite system that models a functional logic program. Consequently, our assessment is independent of any specific language implementation or computing environment. We define several criteria for measuring the cost of a computation: number of steps, number of function applications, and pattern matching effort. Most importantly, we express the cost of each criterion by means of recurrence equations over algebraic data types, which can be automatically inferred from the partial evaluation process itself. In some cases, the equations can be solved by transforming their arguments from arbitrary data types to natural numbers. In other cases, it is possible to estimate the improvement of a partial evaluation by analyzing the associated cost recurrence equations.", "num_citations": "7\n", "authors": ["1828"]}
{"title": "A compositional semantics for conditional term rewriting systems\n", "abstract": " The article considers compositions of conditional term rewriting systems as a basis for a modular approach to the design and analysis of equational logic programs. In this context, an equational logic program is viewed as consisting of a set of modules, each module defining a part of the program's functions. We define a compositional semantics for conditional term rewriting systems which we show to be rich enough to capture computational properties related to the use of logical variables. We also study how such a semantics may be safely approximated, and how the results of such approximations may be composed to yield a bottom-up abstract semantics adequate for modular data-flow analysis. A compositional analysis for equational unsatisfiability illustrates the approach.< >", "num_citations": "7\n", "authors": ["1828"]}
{"title": "Concolic execution in functional programming by program instrumentation\n", "abstract": " Concolic execution, a combination of concrete and symbolic execution, has become increasingly popular in recent approaches to model checking and test case generation. In general, an interpreter of the language is augmented in order to also deal with symbolic values. In this paper, in contrast, we present an alternative approach that is based on a program instrumentation. Basically, the execution of the instrumented program in a standard environment produces a sequence of events that can be used to reconstruct the associated symbolic execution.", "num_citations": "6\n", "authors": ["1828"]}
{"title": "Symbolic execution as a basis for termination analysis\n", "abstract": " Program termination is a relevant property that has been extensively studied in the context of many different formalisms and programming languages. Traditional approaches to proving termination are usually based on inspecting the source code. Recently, a new semantics-based approach has emerged, which typically follows a two-stage scheme: first, a finite data structure representing the computation space of the program is built; then, termination is analyzed by inspecting the transitions in this data structure using traditional, syntax-based techniques.Unfortunately, this approach is still specific to a programming language and semantics. In this work, we present instead a general, high-level framework that follows the semantics-based approach to proving termination. In particular, we focus on the first stage and advocate the use of symbolic execution, together with appropriate subsumption and abstraction\u00a0\u2026", "num_citations": "6\n", "authors": ["1828"]}
{"title": "Towards symbolic execution in Erlang\n", "abstract": " The concurrent functional language Erlang has a number of distinguishing features, like dynamic typing, concurrency via asynchronous message passing or hot code loading, that make it especially appropriate for distributed, fault-tolerant, soft real-time applications. In this paper, we introduce a symbolic execution technique for Erlang. We discuss how both an overapproximation and an underapproximation of the concrete semantics can be obtained. We illustrate our approach through some examples. To the best of our knowledge, this is the first attempt to formalize symbolic execution in the context of this language, where previous approaches have only considered exploring different schedulings but have not dealt with symbolic data.", "num_citations": "6\n", "authors": ["1828"]}
{"title": "Computing more specific versions of conditional rewriting systems\n", "abstract": " Rewrite systems obtained by some automated transformation often have a poor syntactic structure even if they have good properties from a semantic point of view. For instance, a rewrite system might have overlapping left-hand sides even if it can only produce at most one constructor normal form (i.e., value). In this paper, we propose a method for computing \u201cmore specific\u201d versions of deterministic conditional rewrite systems (i.e., typical functional programs) by replacing a given rule (e.g., an overlapping rule) with a finite set of instances of this rule. In some cases, the technique is able to produce a non-overlapping system from an overlapping one. We have applied the transformation to improve the systems produced by a previous technique for function inversion with encouraging results (all the overlapping systems were successfully transformed to non-overlapping systems).", "num_citations": "6\n", "authors": ["1828"]}
{"title": "Annotation of logic programs for independent AND-parallelism by partial evaluation\n", "abstract": " Traditional approaches to automatic AND-parallelization of logic programs rely on some static analysis to identify independent goals that can be safely and efficiently run in parallel in any possible execution. In this paper, we present a novel technique for generating annotations for independent AND-parallelism that is based on partial evaluation. Basically, we augment a simple partial evaluation procedure with (run-time) groundness and variable sharing information so that parallel conjunctions are added to the residual clauses when the conditions for independence are met. In contrast to previous approaches, our partial evaluator is able to transform the source program in order to expose more opportunities for parallelism. To the best of our knowledge, we present the first approach to a parallelizing partial evaluator.", "num_citations": "6\n", "authors": ["1828"]}
{"title": "Experiments with the call-by-value partial evaluator\n", "abstract": " This paper summarizes our experience gained using the system, a narrowing-driven partial evaluator for functional logic programs which combines in a useful and e ective way the propagation of partial data structures, by means of logical variables and uni cation, with better opportunities for optimization thanks the functional dimension. allows the user to select either a call-by-value (, eager) or a call-by-name (outside-in,) narrowing strategy to construct local narrowing trees. The trees are stopped according to an unfolding rule which is another parameter of the implementation, and then resultants are extracted from the root-to leaf paths of the tree. A short description of the system is given and some experimental results are presented for the call-by-value (innermost) evaluation strategy. The experiments show in practice that can give signi cant performance improvements and is quite e ective on several interesting transformation problems.Partial evaluation (PE) is a semantics-preserving optimization technique for computer programs which consists of the specialization of the program wrt parts of its input [10, 19]. Recently, a narrowing-driven PE method (NPE) for functional logic programs has been proposed in [4]. The use of narrowing allows NPE to handle expressions containing partial information (by means of logical variables and uni cation) in a natural way, as well as to consider e cient evaluation strategies and include a deterministic simpli cation phase which provides better opportunities for optimization and improves both, the overall specialization and the e ciency of the method [5]. Using the terminology of [16], NPE produces both and\u00a0\u2026", "num_citations": "6\n", "authors": ["1828"]}
{"title": "A Case Study for Reversible Computing: Reversible Debugging of Concurrent Programs.\n", "abstract": " Reversible computing allows one to run programs not only in the usual forward direction, but also backward. A main application area for reversible computing is debugging, where one can use reversibility to go backward from a visible misbehaviour towards the bug causing it. While reversible debugging of sequential systems is well understood, reversible debugging of concurrent and distributed systems is less settled. We present here two approaches for debugging concurrent programs, one based on backtracking, which undoes actions in reverse order of execution, and one based on causal consistency, which allows one to undo any action provided that its consequences, if any, are undone beforehand. The first approach tackles an imperative language with shared memory, while the second one considers a core of the functional message-passing language Erlang. Both the approaches are based on solid formal foundations.", "num_citations": "5\n", "authors": ["1828"]}
{"title": "Static Analysis: 15th International Symposium, SAS 2008, Valencia, Spain, July 16-18, 2008, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 15th International Symposium on Static Analysis, SAS 2008, held in Valencia, Spain in July 2008-co-located with LOPSTR 2008, the International Symposium on Logic-based Program Synthesis and Transformation, PPDP 2008, the International ACM SIGPLAN Symposium on Principles and Practice of Declarative Programming, and PLID 2008, the International Workshop on Programming Language Interference and Dependence. The 22 revised full papers presented together with two invited lectures were carefully reviewed and selected from 63 submissions. The papers address all aspects of static analysis including abstract domains, abstract interpretation, abstract testing, compiler optimizations, control flow analysis, data flow analysis, model checking, program specialization, security analysis, theoretical analysis frameworks, type based analysis, and verification systems.", "num_citations": "5\n", "authors": ["1828"]}
{"title": "Termination of narrowing in left-linear constructor systems\n", "abstract": " Narrowing extends rewriting with logic capabilities by allowing logic variables in terms and replacing matching with unification. Narrowing has been widely used in different contexts, ranging from theorem proving to language design. Surprisingly, the termination of narrowing has been mostly overlooked. In this paper, we present a new approach for analyzing the termination of narrowing in left-linear constructor systems|a widely accepted class of systems|that allows us to reuse existing methods in the literature on termination of rewriting.", "num_citations": "5\n", "authors": ["1828"]}
{"title": "Source-Level Abstract Profiling for Multi-Paradigm Declarative Languages\n", "abstract": " CiteSeerX \u2014 Source-Level Abstract Profiling for Multi-Paradigm Declarative Languages Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Source-Level Abstract Profiling for Multi-Paradigm Declarative Languages Cached Download as a PDF Download Links [www.iasi.rm.cnr.it] Save to List Add to Collection Correct Errors Monitor Changes by Elvira Albert, et al. Citations: 5 - 3 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases multi-paradigm declarative language source-level abstract profiling immediate application Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us Developed at and hosted \u2026", "num_citations": "5\n", "authors": ["1828"]}
{"title": "Realistic Program Specialization in a Multi-Paradigm Language.\n", "abstract": " This paper introduces a novel approach for the specialization of functional logic languages. We consider a maximally simpli ed abstract representation of programs (which still contains all the necessary information) and de ne a non-standard semantics for these programs. Both things mixed together allow us to design a simple and concise partial evaluation method for modern functional logic languages, avoiding several limitations of previous approaches. Moreover, since these languages can be automatically translated into the abstract representation, our technique is widely applicable. In order to assess the practicality of our approach, we have developed a partial evaluation tool for the multi-paradigm language Curry. The partial evaluator is written in Curry itself and has been tested on an extensive benchmark suite (even a meta-interpreter). To the best of our knowledge, this is the rst purely declarative partial evaluator for a functional logic language.", "num_citations": "5\n", "authors": ["1828"]}
{"title": "Causal-consistent reversible debugging: improving CauDEr\n", "abstract": " Causal-consistent reversible debugging allows one to explore concurrent computations back and forth in order to locate the source of an error. In this setting, backward steps can be chosen freely as long as they are causal consistent, i.e., as long as all the actions that depend on the action we want to undo have been already undone. Here, we consider a framework for causal-consistent reversible debugging in the functional and concurrent language Erlang. This framework considered programs translated to an intermediate representation, called Core Erlang. Although using such an intermediate representation simplified both the formal definitions and their implementation in a debugging tool, the choice of Core Erlang also complicated the use of the debugger. In this paper, we extend the framework in order to deal with source Erlang programs, also including some features that were not considered before\u00a0\u2026", "num_citations": "4\n", "authors": ["1828"]}
{"title": "Causal-consistent replay reversible semantics for message passing concurrent programs\n", "abstract": " Causal-consistent reversible debugging is an innovative technique for debugging concurrent systems. It allows one to go back in the execution focusing on the actions that most likely caused a visible misbehavior. When such an action is selected, the debugger undoes it, including all and only its consequences. This operation is called a causal-consistent rollback. In this way, the user can avoid being distracted by the actions of other, unrelated processes. In this work, we introduce its dual notion: causal-consistent replay. We allow the user to record an execution of a running program and, in contrast to traditional replay debuggers, to reproduce a visible misbehavior inside the debugger including all and only its causes. Furthermore, we present a unified framework that combines both causal-consistent replay and causal-consistent rollback. Although most of the ideas that we present are rather general, we focus on a\u00a0\u2026", "num_citations": "4\n", "authors": ["1828"]}
{"title": "On the completeness of selective unification in concolic testing of logic programs\n", "abstract": " Concolic testing is a popular dynamic validation technique that can be used for both model checking and automatic test case generation. We have recently introduced concolic testing in the context of logic programming. In contrast to previous approaches, the key ingredient in this setting is a technique to generate appropriate run-time goals by considering all possible ways an atom can unify with the heads of some program clauses. This is called \u201cselective\u201d unification. In this paper, we show that the existing algorithm is not complete and explore different alternatives in order to have a sound and complete algorithm for selective unification.", "num_citations": "4\n", "authors": ["1828"]}
{"title": "Goal-directed and relative dependency pairs for proving the termination of narrowing\n", "abstract": " In this work, we first consider a goal-oriented extension of the dependency pair framework for proving termination w.r.t. a given set of initial terms. Then, we introduce a new result for proving relative termination in terms of a dependency pair problem. Both contributions put together allow us to define a simple and powerful approach to analyzing the termination of narrowing, an extension of rewriting that replaces matching with unification in order to deal with logic variables. Our approach could also be useful in other contexts where considering termination w.r.t. a given set of terms is also natural (e.g., proving the termination of functional programs).", "num_citations": "4\n", "authors": ["1828"]}
{"title": "Partial Evaluation of Multi-Paradigm Declarative Languages: Foundations, Control, Algorithms and Efficiency\n", "abstract": " Partial evaluation is an automatic technique for program optimization which preserves program semantics. Optimization is achieved by specializing programs wrt parts of their input (hence also called program specialization). Informally, a partial evaluator is a mapping which takes a program P and a function call C and derives a more efficient, specialized program PC which computes the same values and answers for C (and any of its instances) as P does. The range of its potential applications is extremely large, as witnessed by many successful experiences, eg, in the fields of pattern recognition, neural network training, or scientific computing [Jones et al., 1993]. This technique has been investigated in the context of a wide variety of declarative programming languages, specially in both the functional and logic programming paradigms (see, eg,[Consel and Danvy, 1993; Danvy et al., 1996; Gallagher, 1993; Jones et al., 1993; Lloyd and Shepherdson, 1991] and references herein). Recently, a unified framework for the partial evaluation of languages which integrate features from functional and logic programming has been introduced in [Alpuente et al., 1998b, 1999c]. This framework is based on the use of narrowing (the standard operational mechanism of functional logic languages) to drive the specialization process. However, the narrowing-driven method of [Alpuente et al., 1998b, 1999c] is not still suitable for designing an effective partial evaluator for a realistic multi-paradigm language like Curry [Hanus, 2000a], Escher [Lloyd, 1994] or Toy [L\u00f3pez-Fraguas and S\u00e1nchez-Hern\u00e1ndez, 1999], as there are many language features which are not\u00a0\u2026", "num_citations": "4\n", "authors": ["1828"]}
{"title": "Reversible Computations in Logic Programming\n", "abstract": " In this work, we say that a computation is reversible if one can find a procedure to undo the steps of a standard (or forward) computation in a deterministic way. While logic programs are often invertible (e.g., one can use the same predicate for adding and for subtracting natural numbers), computations are not reversible in the above sense. In this paper, we present a so-called Landauer embedding for SLD resolution, the operational principle of logic programs, so that it becomes reversible. A proof-of-concept implementation of a reversible debugger for Prolog that follows the ideas in this paper has been developed and is publicly available.", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Selective Unification in (Constraint) Logic Programming\n", "abstract": " Concolic testing is a well-known validation technique for imperative and object oriented programs. In a previous paper, we have introduced an adaptation of this technique to logic programming. At the heart of our framework lies a specific procedure that we call \u201cselective unification\u201d. It is used to generate appropriate run-time goals by considering all possible ways an atom can unify with the heads of some program clauses. In this paper, we show that the existing algorithm for selective unification is not complete in the presence of non-linear atoms. We then prove soundness and completeness for a restricted version of the problem where some atoms are required to be linear. We also consider concolic testing in the context of constraint logic programming and extend the notion of selective unification accordingly.", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Characterizing compatible view updates in syntactic bidirectionalization\n", "abstract": " Given a function that takes a source data and returns a view, bidirectionalization aims at producing automatically a new function that takes a modified view and returns the corresponding, modified source. In this paper, we consider simple first-order functional programs specified by (conditional) term rewrite systems. Then, we present a bidirectionalization technique based on the injectivization and inversion transformations from [24]. We also prove a number of relevant properties which ensure that changes in both the source and the view are correctly propagated and that no undesirable side-effects are introduced. Furthermore, we introduce the use of narrowing\u2014an extension of rewriting that replaces matching with unification\u2014to precisely characterize compatible (also called in-place) view updates so that the resulting bidirectional transformations are well defined. Finally, we discuss some directions for\u00a0\u2026", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Towards modelling actor-based concurrency in term rewriting\n", "abstract": " In this work, we introduce a scheme for modelling actor systems within sequential term rewriting. In our proposal, a TRS consists of the union of three components: the functional part (which is specific of a system), a set of rules for reducing concurrent actions, and a set of rules for defining a particular scheduling policy. A key ingredient of our approach is that concurrent systems are modelled by terms in which concurrent actions can never occur inside user-defined function calls. This assumption greatly simplifies the definition of the semantics for concurrent actions, since no term traversal will be needed. We prove that these systems are well defined in the sense that concurrent actions can always be reduced. Our approach can be used as a basis for modelling actor-based concurrent programs, which can then be analyzed using existing techniques for term rewrite systems.", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Functional and Logic Programming\n", "abstract": " Functional and Logic Programming - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Functional and Logic Programming Blume, Matthias ; Kobayashi, Naoki ; Vidal, Germ\u00e1n Abstract Publication: Lecture Notes in Computer Science Pub Date: 2010 DOI: 10.1007/978-3-642-12251-4 Bibcode: 2010LNCS......B Keywords: Computer Science; Software Engineering; Logics and Meanings of Programs; Programming Languages; Compilers; Interpreters; Mathematical Logic and Formal Languages; Artificial Intelligence (incl. Robotics); Programming Techniques full text sources Publisher | \u00a9 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo Resources About ADS ADS Help What's New Careers@ADS Social @adsabs ADS \u2026", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Predicting the effectiveness of partial evaluation\n", "abstract": " Partial evaluation aims at improving programs by specializing them wrt part of their input data. In general, however, the effectiveness of the partial evaluation process is hard to measure, even a posteriori. Recent approaches have introduced experimental (often computationally expensive) frameworks for this purpose. In this paper, we present an alternative, symbolic approach for predicting the effectiveness of partial evaluation by combining a trace analysis with a termination analysis. The termination analysis\u2014namely, a size-change analysis\u2014is used to determine which procedures are potentially removable by partial evaluation (ie, can be fully unfolded at specialization time). Then, the trace analysis helps us to put this information into context by producing a compact representation of the call sequences of the program. By inspecting the output of the combined analysis, the user may determine the impact of a partial evaluation before it is performed.", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Call-By Name Partial Evaluation of Functional Logic Programs.\n", "abstract": " Partial evaluation is a method for program specialization based on fold/unfold transformations [4, 16]. Partial evaluation of functional programs uses only static values of given data to specialize the program. In logic programming, the so-called static/dynamic distinction is hardly present, whereas considerations of determinacy and choice points are far more important for control [8]. In this paper, we formalize a two-phase specialization method for a non-strict functional logic language which makes use of (normalizing) lazy narrowing to specialize the program wrt a goal. The basic algorithm (first phase) is formalized as an instance of the framework for the partial evaluation of functional logic programs of [2], using lazy narrowing. However, the results inherited by [2] mainly regard the termination of the PE method, while the (strong) soundness and completeness results must be restated for the lazy strategy. A post-processing renaming scheme (second phase) for obtaining independence is then described and illustrated on the well-known matching example. We show that our method preserves the lazy narrowing semantics and that the inclusion of simplification steps in narrowing derivations can greatly improve control during specialization.", "num_citations": "3\n", "authors": ["1828"]}
{"title": "Relative termination via dependency pairs\n", "abstract": " A term rewrite system is terminating when no infinite reduction sequences are possible. Relative termination generalizes termination by permitting infinite reductions as long as some distinguished rules are not applied infinitely many times. Relative termination is thus a fundamental notion that has been used in a number of different contexts, like analyzing the confluence of rewrite systems or the termination of narrowing. In this work, we introduce a novel technique to prove relative termination by reducing it to dependency pair problems. To the best of our knowledge, this is the first significant contribution to Problem #106 of the RTA List of Open Problems. We first present a general approach that is then instantiated to provide a concrete technique for proving relative termination. The practical significance of our method is illustrated by means of an experimental evaluation.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Towards reversible computation in erlang\n", "abstract": " In a reversible language, any forward computation can be undone by a finite sequence of backward steps. Reversible computing has been studied in the context of different programming languages and formalisms, where it has been used for debugging and for enforcing fault-tolerance, among others. In this paper, we consider a subset of Erlang, a concurrent language based on the actor model. We formally introduce a reversible semantics for this language. To the best of our knowledge, this is the first attempt to define a reversible semantics for Erlang.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Tuning fuzzy logic programs with symbolic execution\n", "abstract": " Fuzzy logic programming is a growing declarative paradigm aiming to integrate fuzzy logic into logic programming. One of the most difficult tasks when specifying a fuzzy logic program is determining the right weights for each rule, as well as the most appropriate fuzzy connectives and operators. In this paper, we introduce a symbolic extension of fuzzy logic programs in which some of these parameters can be left unknown, so that the user can easily see the impact of their possible values. Furthermore, given a number of test cases, the most appropriate values for these parameters can be automatically computed.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "A framework for computing finite SLD trees\n", "abstract": " The search space of SLD resolution, usually represented by means of a so-called SLD tree, is often infinite. However, there are many applications that must deal with possibly infinite SLD trees, like partial evaluation or some static analyses. In this context, being able to construct a finite representation of an infinite SLD tree becomes useful.In this work, we introduce a framework to construct a finite data structure representing the (possibly infinite) SLD derivations for a goal. This data structure, called closed SLD tree, is built using four basic operations: unfolding, flattening, splitting, and subsumption. We prove some basic properties for closed SLD trees, namely that both computed answers and calls are preserved. We present a couple of simple strategies for constructing closed SLD trees with different levels of abstraction, together with some examples of its application. Finally, we illustrate the viability of our approach\u00a0\u2026", "num_citations": "2\n", "authors": ["1828"]}
{"title": "A hybrid approach to conjunctive partial deduction\n", "abstract": " Partial evaluation \u00a7 input program and part of input data (static data) output specialized (residual) program", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Fast and Accurate Strong Termination Analysis with an Application to Partial Evaluation\n", "abstract": " A logic program strongly terminates if it terminates for any selection rule. Clearly, considering a particular selection rule|like Prolog\u2019s leftmost selection rule|allows one to prove more goals terminating. In contrast, a strong termination analysis gives valuable information for those applications in which the selection rule cannot be fixed in advance (e.g., partial evaluation, dynamic selection rules, parallel execution). In this paper, we introduce a fast and accurate size-change analysis that can be used to infer conditions for both strong termination and strong quasi-termination of logic programs. We also provide several ways to increase the accuracy of the analysis without sacrificing scalability. In the experimental evaluation, we show that the new algorithm is up to three orders of magnitude faster than the previous implementation, meaning that we can efficiently deal with programs exceeding 25,000 lines of Prolog.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Improving size-change analysis in offline partial evaluation\n", "abstract": " Some recent approaches for scalable offline partial evaluation of logic programs include a size-change analysis for ensuring both so called local and global termination. In this work|inspired by experimental evaluation|we introduce several improvements that may increase the accuracy of the analysis and, thus, the quality of the associated specialized programs. We aim to achieve this while maintaining the same complexity and scalability of the recent works.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "A transformational approach to polyvariant bta of higher-order functional programs\n", "abstract": " We introduce a transformational approach to improve the first stage of offline partial evaluation of functional programs, the so called binding-time analysis (BTA). For this purpose, we first introduce an improved defunctionalization algorithm that transforms higher-order functions into first-order ones, so that existing techniques for termination analysis and propagation of binding-times of first-order programs can be applied. Then, we define another transformation (tailored to defunctionalized programs) that allows us to get the accuracy of a polyvariant BTA from a monovariant BTA over the transformed program. Finally, we show a summary of experimental results that demonstrate the usefulness of our approach.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "An offline partial evaluator for curry programs\n", "abstract": " Narrowing-driven partial evaluation is a powerful technique for the specialization of functional logic programs. In this paper, we describe the implementation of a narrowing-driven partial evaluator for Curry programs which follows the offline approach to ensuring termination. Although the new partial evaluator is less precise than previous (online) partial evaluators for Curry, it is much faster and, thus, allows the specialization of larger programs.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Offline narrowing-driven partial evaluation\n", "abstract": " Narrowing-driven partial evaluation (NPE) is a powerful technique for the specialization of rewrite systems. Although it gives good results on small programs, it does not scale up well to realistic problems (eg, interpreter specialization). In this work, we introduce a faster partial evaluation scheme by ensuring the termination of the process offline. For this purpose, we first characterize a class of rewrite systems which are quasi-terminating, ie, the computations performed with needed narrowing (the symbolic computation mechanism of NPE) only contain finitely many different terms (and, thus, partial evaluation terminates). Since this class is quite restrictive, we introduce an annotation algorithm for a broader class of systems so that they behave like quasi-terminating rewrite systems wrt a proposed extension of needed narrowing.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Lazy narrowing and needed narrowing: A comparison\n", "abstract": " Functional logic programming [8] allows us to integrate some of the best features of the classical declarative paradigms, namely functional and logic programming. The operational semantics of functional logic languages is usually based on narrowing, an evaluation mechanism which combines the reduction principle of functional languages and the resolution principle of logic languages. Lazy evaluation is a valuable feature of functional (logic) programming languages since it avoids unnecessary computations and allows us to deal with infinite data structures. Recently, Antoy et al.[4] introduced a lazy evaluation strategy for functional logic programs, called needed narrowing, which generalizes Huet and L\u00e9vy\u2019s [11] call by need reduction to deal with logical variables and unification in inductively sequential rewrite systems, where functions are defined in a way which is similar to case expressions.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Forward Slicing by Partial Evaluation\n", "abstract": " Program slicing has been mainly studied in the context of imperative languages, where it has been applied to many software engineering tasks, like program understanding, maintenance, debugging, testing, code reuse, etc. This paper introduces the first forward slicing technique for multi-paradigm declarative programs. In particular, we show how program slicing can be defined in terms of online partial evaluation. Our approach", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Operational Semantics for Lazy Functional Logic Programs\n", "abstract": " In this paper we define an operational semantics for lazy functional logic programs including notions like sharing, concurrency, non-determinism, etc. Such a semantic description is not only important to provide appropriate language definitions to reason about programs and check the correctness of implementations but it is also a basis to develop language-specific tools, like program tracers, profilers, optimizers, etc. First, we consider a\" big-step\" semantics in natural style to relate expressions and their evaluated results. Since this semantics is not sufficient to cover concurrency, search strategies, or to reason about costs associated to particular computations, we define a\" small-step\" operational semantics covering the features of modern functional logic languages.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Narrowing-driven Specialization of Functional Logic Programs\n", "abstract": " Languages that integrate functional and logic programming with a complete operational semantics are based on narrowing, a unification-based goal-solving mechanism which subsumes the reduction principle of functional languages and the resolution principle of logic languages. Formal methods of transformation of functional logic programs can be based on this wellestablished operational semantics. In this paper, we present a partial evaluation scheme for functional logic languages based on an automatic unfolding algorithm which builds narrowing trees. We study the semantic properties of the transformation and the conditions under which the technique terminates, is sound and complete, and is also generally applicable to a wide class of programs. To the best of our knowledge this is the first formal approach to partial evaluation of functional logic programs.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Towards Router Specification in Curry: The Language ROSE\n", "abstract": " The development of modern routers require a significant effort to be designed, built, and verified. While hardware routers are faster, they are difficult to configure and maintain. Software routers, on the other hand, are slower but much more flexible, easier to configure and maintain, less expensive, etc. Recently, a modular architecture and toolkit for building software routers and other packet processors has been introduced: the Click system. It includes a specification language with features for declaring and connecting router elements and for designing abstractions.In this work, we introduce the domain-specific language Rose for the specification of software routers. Rose is embedded in Curry, a modern declarative multi-paradigm language. An advantage of this approach is that we have available a framework where router specifications can be transformed, optimized, verified, etc., by using a number of existing formal techniques already developed for Curry programs. Furthermore, we show that the features of Curry are particularly useful to specify router configurations with a high-level of abstraction. Our first experiments point out that the proposed methodology is both useful and practical.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "O ine Narrowing-Driven Specialization in Practice\n", "abstract": " O ine narrowing-driven partial evaluation is a recent technique for the specialization of functional and functional logic programs. In this work, we describe novel control strategies that can be used to design a powerful narrowingdriven partial evaluator.", "num_citations": "2\n", "authors": ["1828"]}
{"title": "Concolic Testing in CLP\n", "abstract": " Concolic testing is a popular software verification technique based on a combination of concrete and symbolic execution. Its main focus is finding bugs and generating test cases with the aim of maximizing code coverage. A previous approach to concolic testing in logic programming was not sound because it only dealt with positive constraints (by means of substitutions) but could not represent negative constraints. In this paper, we present a novel framework for concolic testing of CLP programs that generalizes the previous technique. In the CLP setting, one can represent both positive and negative constraints in a natural way, thus giving rise to a sound and (potentially) more efficient technique. Defining verification and testing techniques for CLP programs is increasingly relevant since this framework is becoming popular as an intermediate representation to analyze programs written in other programming paradigms.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "Reversible Debugging in Logic Programming\n", "abstract": " Reversible debugging is becoming increasingly popular for locating the source of errors. This technique proposes a more natural approach to debugging, where one can explore a computation from the observable misbehaviour backwards to the source of the error. In this work, we propose a reversible debugging scheme for logic programs. For this purpose, we define an appropriate instrumented semantics (a so-called Landauer embedding) that makes SLD resolution reversible. An implementation of a reversible debugger for Prolog, rever, has been developed and is publicly available.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "Reducing relative termination to dependency pair problems\n", "abstract": " Relative termination, a generalized notion of termination, has been used in a number of different contexts like proving the confluence of rewrite systems or analyzing the termination of narrowing. In this paper, we introduce a new technique to prove relative termination by reducing it to dependency pair problems. To the best of our knowledge, this is the first significant contribution to Problem #106 of the RTA List of Open Problems. The practical significance of our method is illustrated by means of an experimental evaluation.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "More specific term rewriting systems\n", "abstract": " There are properties of rewriting systems that are characterized by means of some syntactic conditions (eg, requiring left-linear and non-overlapping rules for ensuring confluence). Sometimes, though, a given property might hold but the syntactic conditions are not met. This is particularly true when the systems are obtained by some automated transformation. In this paper, we introduce a technique that allows us to replace a rule of a rewriting system by a more specific version (an instance) of this rule so that a particular class of reductions can still be performed in the more specific system. This transformation might help to make some properties explicit (eg, transforming an overlapping system having the unique normal form property into a non-overlapping one). We provide an algorithm to compute more specific versions of rewriting systems based on narrowing.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "Trace Analysis for Predicting the Effectiveness of Partial Evaluation\n", "abstract": " The main goal of partial evaluation [1] is program specialization. Essentially, given a program and part of its input data|the so called static data|a partial evaluator returns a new, residual program which is specialized for the given data. An appropriate residual program for executing the remaining computations|those that depend on the so called dynamic data|is thus the output of the partial evaluator. Despite the fact that the main goal of partial evaluation is improving program efficiency (i.e., producing faster programs), there are very few approaches devoted to formally analyze the effects of partial evaluation, either a priori (prediction) or a posteriori. Recent approaches (e.g., [2,3]) have considered experimental frameworks for estimating the best division (roughly speaking, a classification of program parameters into static or dynamic), so that the optimal choice is followed when specializing the source program.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "A partial evaluation tool for multi-paradigm declarative languages\n", "abstract": " This article describes a practical (online) partial evaluation tool which is applicable to modern multi-paradigm declarative languages (like, eg, Curry). The most recent proposal for multiparadigm declarative programming advocates the integration of features from functional, logic and concurrent programming. The developed tool has been successfully integrated into the PAKCS compiler for the language Curry.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "A Deterministic Operational Semantics for Functional Logic Programs.\n", "abstract": " This paper introduces a deterministic operational semantics for functional logic programs including notions like laziness, sharing, concurrency, non-deterministic functions, etc. Our semantic description is important not only to provide appropriate language definitions to reason about programs and check the correctness of implementations but it is also a basis to develop language-specific tools, like program tracers, profilers, optimizers, etc. Starting from a \u201cbig-step\u201d semantics in natural style which relates expressions and their evaluated results\u2014but it is not sufficient to cover concurrency, search strategies, or to reason about costs associated to particular computations\u2014, we define a \u201csmall-step\u201d operational semantics which actually covers the advanced features of modern functional logic languages.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "A Practical Method for Program Specialization in a Multi-Paradigm Language?\n", "abstract": " This paper summarizes our ndings in the development of partial evaluation tools for Curry, a modern multi-paradigm declarative language which combines features from functional programming, logic programming, and concurrent programming. We present a novel approach to perform automatic program specialization in Curry, which di ers from those presented in the literature for the specialization of functional logic languages mainly by considering the translation of the source program into an intermediate language. This is essential in order to express the di erent features of the language at an appropriate level of abstraction, which allows us to design a simple and concise automatic partial evaluation method covering all the features of the language. Thanks to this simplicity, we have been able to write our partial evaluator in the same language that it partially evaluates (without using any extra-logical feature) and, hence, it is amenable to self-application (able to specialize itself). The partial evaluator has been tested on an extensive set of benchmarks, even a meta-interpreter for Curry, which demonstrates the practicality of our approach. To the best of our knowledge, this is the rst purely declarative partial evaluator for a functional logic language.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "Measuring the Effectiveness of Partial Evaluation.\n", "abstract": " We introduce a framework for assessing the effectiveness of partial evaluators for functional logic programs. Our framework is based on properties of the rewrite system that models a functional logic program and, consequently, our assessment is independent of any specific language implementation or computing environment. We define several criteria for measuring the cost of a computation: number of steps, number of function applications, and effort for pattern matching. Most importantly, we express the cost of each criterion by means of recurrence equations over algebraic data types, which can be automatically inferred from the partial evaluation process itself. In some cases, the equations can be solved by transforming their arguments from arbitrary data types to natural numbers. In other cases, it is possible to estimate the improvement of a partial evaluation by analyzing the recurrence equations.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "Transformation-based strategies for lazy functional logic programs\n", "abstract": " Needed narrowing is an optimal and complete operational principle for modern declarative languages which integrate the best features of (lazy) functional and logic programming. We de ne a transformation methodology for functional logic programs based on needed narrowing. We provide (strong) correctness results for the transformation system wrt the set of computed values and answer substitutions and show that the prominent properties of needed narrowing carry over to the transformation process and the transformed programs. We illustrate the power of the system by taking on in our setting two well-known transformation strategies (composition and tupling). We also provide an implementation of the transformation system which, by means of some experimental results, highlights the bene ts of our approach.", "num_citations": "1\n", "authors": ["1828"]}
{"title": "Reversible term rewriting: foundations and applications\n", "abstract": " Essentially, in a reversible programming language, for each forward computation step from state S to state S, there exists a constructive and deterministic method to go backwards from state S to state S. Besides its theoretical interest, reversible computation is a fundamental concept which is relevant in many different areas like cellular automata, bidirectional program transformation, or quantum computing, to name a few. In this paper, we focus on term rewriting, a computation model that underlies most rule-based programming languages. In general, term rewriting is not reversible, even for injective functions; namely, given a rewrite step t1\u2192 t2, we do not always have a decidable and deterministic method to get t1 from t2. Here, we introduce a conservative extension of term rewriting that becomes reversible. Furthermore, we also define a transformation to make a rewrite system reversible using standard term rewriting, and show some interesting applications.", "num_citations": "1\n", "authors": ["1828"]}