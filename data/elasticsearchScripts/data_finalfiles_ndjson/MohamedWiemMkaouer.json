{"title": "On the classification of software change messages using multi-label active learning\n", "abstract": " In this paper, we present a multi-label active learning-based approach to handle the problem of classification of commit messages. The approach will help developers track software changes, eg, adding or updating existing features, fixing user-reported errors, improving software performance, etc. We first constructed an unlabeled dataset of commit messages where each commit message is represented as a vector of feature values. The set of adopted features were automatically generated from the original commit messages using Term Frequency-Inverse Document Frequency (TF-IDF) technique. Because many commit messages can be assigned more than one commit class at the same time and in order to reduce the effort needed to assign labels to each instance in a large set of commit messages, we adopted an Active Learning multi-label approach. Experimentations have shown that we could train an accurate\u00a0\u2026", "num_citations": "15\n", "authors": ["800"]}
{"title": "Automating the detection of third-party Java library migration at the function level.\n", "abstract": " The process of migrating between different third-party libraries is very complex. Typically, developers need to find functions in the new library that are most adequate in replacing the functions of the retired library. This process is subjective and time-consuming as developers need to fully understand the documentation of both libraries\u2019 Application Programming Interfaces, and find the right match between their functions if it exists. In this context, several studies rely on mining existing library migrations to provide developers with by-example approaches for similar scenarios. In this paper, we propose a mining approach that extracts all the manuallyperformed function replacements for a given library migration. Our approach combines the mined function-change patterns with function-related lexical similarity to accurately detect mappings between replacing/replaced functions. Using our enhanced mining process, we perform a comparative study between state-of-art approaches for detecting migration traces at the function level. Our findings have shown its efficiency in accurately detecting migration fragments and it has enhanced the accuracy of state-of-art approaches in finding correct functions changes. We finally provide the community with a dataset of migrations between popular Java libraries, and their corresponding code changes at the function level.", "num_citations": "11\n", "authors": ["800"]}
{"title": "M-perm: A lightweight detector for android permission gaps\n", "abstract": " Android apps operate under a permissions-based system where access to specific APIs are restricted through the use of permissions. Unfortunately, there is no built-in verification system to ensure that apps do not request too many or too few permissions, which could lead to serious quality and/or privacy concerns. Apps requesting too many permissions create unnecessary vulnerabilities, leaving the potential for abuse by SDKs within the app or other malicious apps installed on the device. In order to assist with the discovery of misused permissions, we created a new detection tool, M-Perm, which combines static and dynamic analysis in a computationally efficient manner compared to existing tools. M-Perm also identifies permission usage in apps including requested normal, dangerous, and 3rd party permissions. The tool, complete usage instructions, and screencast are available online: http://www.m-perm.com.", "num_citations": "11\n", "authors": ["800"]}
{"title": "PLAIN: PLugin for predicting the usAbility of Mobile User INterface.\n", "abstract": " Mobile user interfaces have the potential to improve the interaction between user and system by automatically tailoring the graphical user interface presentation according to the mobile devices. Recently, there is a myriad of works that addressed the problem of designing mobile user interfaces to various contexts of use. But, there are very few proposals about evaluating their quality. Using existing evaluation methods such as questionnaires and experts\u2019 evaluation are time-consuming and error-prone. In this paper, we propose an automatic evaluation plugin that allows detecting the defects related to the quality of mobile user interface. The plugin allows the measurement of several metrics that have been known to constitute the state of the art quality attributes that are used to predict the quality of interfaces from the usability perspective. For a given input mobile applications, it generates a list of defects identified using quantitative evaluation metrics and defects types. We evaluated our plugin on four open source mobile applications and the obtained results confirm that our tool can be used to accurately evaluate the quality of interfaces.", "num_citations": "11\n", "authors": ["800"]}
{"title": "PRICE: Detection of Performance Regression Introducing Code Changes Using Static and Dynamic Metrics\n", "abstract": " Performance regression testing is highly expensive as it delays system development when optimally conducted after each code change. Therefore, it is important to prioritize the schedule of performance tests by executing them when a newly committed change is most likely to introduce performance regression. This paper introduces a novel formulation of the detection of performance regression introducing code changes as an optimization problem. Static and dynamic metrics are combined to generate a detection rule, which is being optimized in terms of its ability to flag problematic code changes, and avoid false positives. We evaluated our approach using performance issues, extracted from the Git project. Results show the effectiveness of our approach in accurately detecting performance regression introducing code changes compared with state-of-the-art techniques. Moreover, our suggested detection\u00a0\u2026", "num_citations": "10\n", "authors": ["800"]}
{"title": "P-lint: a permission smell detector for android applications\n", "abstract": " Android is built upon a permission-based structure, where apps require access to specific permissions in order to carry out specific functionality. While Android has provided a set of best practices intended to aid the developer in properly defining and manipulating these permissions on their source code, developers do not always adhere to these guidelines. Although some of the resulting issues may be minor and lead to slight user confusion, other mistakes may create more serious privacy and security related issues. We've defined improper usage of these permission best practices to be 'permission smells' to indicate possible permissions related syntactic issues and have created a tool P-Lint to assist in the identification of these smells on the source code. P-Lint's goal is to not only help developers create better, more secure apps by providing guidance on properly using permissions, but also in allowing\u00a0\u2026", "num_citations": "9\n", "authors": ["800"]}
{"title": "Comparison of block-based and hybrid-based environments in transferring programming skills to text-based environments\n", "abstract": " Teachers face several challenges when presenting the fundamental concepts of programming in the classroom. Several tools are introduced to give a visual dimension to support the learning process. These tools rely on code blocks, easily manipulated in a plug and play fashion, to build a program. These block-based tools intend to familiarize students with programming logic, before diving into text-based programming languages such as Java, Python, etc. However; when transitioning from block-based to text-based programming, students often encounter a gap in their learning. The student may not be able to apply block-based foundations in a text-based environment. To bridge the gap between both environments, we developed a hybrid-based learning approach. We found that on average a hybrid-based approach increases the students understanding of programming foundations, memorization, and ease of transition by more than 30% when compared to a block-based to text-based learning approach. Finally, we provide the community with an open source, hybrid-based learning tool that can be used by students when learning programming concepts or for future studies.", "num_citations": "7\n", "authors": ["800"]}
{"title": "A Multi-label Active Learning Approach for Mobile App User Review Classification\n", "abstract": " User reviews of mobile applications convey useful feedback from users, e.g. feature requests, bug descriptions, etc. The increasing number of reviews that users submit daily makes it difficult for developers to manually analyze and classify them into proper review categories. Moreover, several review messages may contain more than one information. In this paper, we propose to use multi-label active learning as a convenient solution to the problem of mobile app user reviews classification. An unlabeled and structured dataset was built from the initially unstructured large set of review messages. Moreover, in order to reduce the effort needed to assign labels to each instance in the large constructed dataset, we opted for an Active Learning approach. Experimental results have shown that, by actively querying an oracle for labels during training a binary relevance-based classifier (with logistic regression as a base\u00a0\u2026", "num_citations": "7\n", "authors": ["800"]}
{"title": "Interactive code smells detection: An initial investigation\n", "abstract": " In this paper, we introduced a novel technique to generate more user-oriented detection rules by taking into account their feedback. Our techniques initially generate a set of detection rules that will be used to detect candidate code smells, these reported code smells will be exposed in an interactive fashion to the developer who will give his/her feedback by either approving or rejecting the identified code smell in the code fragment. This feedback will be fed to the GP as constraints and additional examples in order to converge towards more user-preferred detection rules. We initially investigated the detection of three types of code smells in four open source systems and reported that the interactive code smell detection achieves a precision of 89\u00a0% and recall on average when detecting infected classes. Results show that our approach can best imitate the user\u2019s decision while omitting the complexity of\u00a0\u2026", "num_citations": "7\n", "authors": ["800"]}
{"title": "CATE: concolic Android testing using Java pathfinder for Android applications\n", "abstract": " Like all software, Android applications are not immune to bugs, security vulnerabilities, and a wide range of other issues. Concolic analysis, a hybrid software verification technique which performs symbolic execution along with a concrete execution path, has been used for a variety of purposes including software testing, code clone detection, and security-related activities. We created a new publicly available concolic analysis tool for analyzing Android applications: Concolic Android TEster (CATE). Building on Java Path Finder (JPF-SPF), this tool performs concolic analysis on a raw Android application file (or source code) and provides output in a useful and easy to understand format.", "num_citations": "6\n", "authors": ["800"]}
{"title": "An experimental study of weight initialization and Lamarckian inheritance on neuroevolution\n", "abstract": " Weight initialization is critical in being able to successfully train artificial neural networks (ANNs), and even more so for recurrent neural networks (RNNs) which can easily suffer from vanishing and exploding gradients. In neuroevolution, where evolutionary algorithms are applied to neural architecture search, weights typically need to be initialized at three different times: when the initial genomes (ANN architectures) are created, when offspring genomes are generated by crossover, and when new nodes or edges are created during mutation. This work explores the difference between the state-of-the-art Xavier and Kaiming methods, and novel Lamarckian weight inheritance for weight initialization during crossover and mutation operations. These are examined using the Evolutionary eXploration of Augmenting Memory Models (EXAMM) neuroevolution algorithm, which is capable of evolving RNNs with a variety of modern memory cells (eg, LSTM, GRU, MGU, UGRNN and Delta-RNN cells) as well as recurrent connections with varying time skips through a high performance island based distributed evolutionary algorithm. Results show that with statistical significance, the Lamarckian strategy outperforms both Kaiming and Xavier weight initialization, can speed neuroevolution by requiring less backpropagation epochs to be evaluated per genome, and that the neuroevolutionary process provides further benefits to neural network weight optimization.", "num_citations": "3\n", "authors": ["800"]}
{"title": "Learning to rank developers for bug report assignment\n", "abstract": " Bug assignment is a burden for projects receiving many bug reports. To automate the process of assigning bug reports to the appropriate developers, several studies have relied on combining natural language processing and information retrieval techniques to extract two categories of features. One of these categories targets developers who have fixed similar bugs before, and the other determines developers working on source files similar to the description of the bug. Commit messages represent another rich source for profiling developer expertise as the language used in commit messages is closer to that used in bug reports.In this work, we propose a more enhanced profiling of developers through their commits, which are captured in a new set of features that we combine with features used in previous studies. More precisely, we propose an adaptive ranking approach that takes as input a given bug report and\u00a0\u2026", "num_citations": "3\n", "authors": ["800"]}
{"title": "Learning to rank faulty source files for dependent bug reports\n", "abstract": " With the rise of autonomous systems, the automation of faults detection and localization becomes critical to their reliability. An automated strategy that can provide a ranked list of faulty modules or files with respect to how likely they contain the root cause of the problem would help in the automation bug localization. Learning from the history if previously located bugs in general, and extracting the dependencies between these bugs in particular, helps in building models to accurately localize any potentially detected bugs. In this study, we propose a novel fault localization solution based on a learning-to-rank strategy, using the history of previously localized bugs and their dependencies as features, to rank files in terms of their likelihood of being a root cause of a bug. The evaluation of our approach has shown its efficiency in localizing dependent bugs.", "num_citations": "3\n", "authors": ["800"]}
{"title": "Augmenting commit classification by using fine-grained source code changes and a pre-trained deep neural language model\n", "abstract": " Context:Analyzing software maintenance activities is very helpful in ensuring cost-effective evolution and development activities. The categorization of commits into maintenance tasks supports practitioners in making decisions about resource allocation and managing technical debt.Objective:In this paper, we propose to use a pre-trained language neural model, namely BERT (Bidirectional Encoder Representations from Transformers) for the classification of commits into three categories of maintenance tasks \u2014 corrective, perfective and adaptive. The proposed commit classification approach will help the classifier better understand the context of each word in the commit message.Methods:We built a balanced dataset of 1793 labeled commits that we collected from publicly available datasets. We used several popular code change distillers to extract fine-grained code changes that we have incorporated into our\u00a0\u2026", "num_citations": "2\n", "authors": ["800"]}
{"title": "Finding the Needle in a Haystack: On the Automatic Identification of Accessibility User Reviews\n", "abstract": " In recent years, mobile accessibility has become an important trend with the goal of allowing all users the possibility of using any app without many limitations. User reviews include insights that are useful for app evolution. However, with the increase in the amount of received reviews, manually analyzing them is tedious and time-consuming, especially when searching for accessibility reviews. The goal of this paper is to support the automated identification of accessibility in user reviews, to help technology professionals in prioritizing their handling, and thus, creating more inclusive apps. Particularly, we design a model that takes as input accessibility user reviews, learns their keyword-based features, in order to make a binary decision, for a given review, on whether it is about accessibility or not. The model is evaluated using a total of 5,326 mobile app reviews. The findings show that (1) our model can accurately\u00a0\u2026", "num_citations": "2\n", "authors": ["800"]}
{"title": "One thousand and one stories: a large-scale survey of software refactoring\n", "abstract": " Despite the availability of refactoring as a feature in popular IDEs, recent studies revealed that developers are reluctant to use them, and still prefer the manual refactoring of their code. At JetBrains, our goal is to fully support refactoring features in IntelliJ-based IDEs and improve their adoption in practice. Therefore, we start by raising the following main questions. How exactly do people refactor code? What refactorings are the most popular? Why do some developers tend not to use convenient IDE refactoring tools?", "num_citations": "1\n", "authors": ["800"]}
{"title": "Recommending pull request reviewers based on code changes\n", "abstract": " Pull-based development supports collaborative distributed development. It enables developers to collaborate on projects hosted on GitHub. If a developer wants to collaborate on a project, he/she will fork the repository, make modifications on the forked repository and send a pull request to the development team to ask for a merge of the code changes to the official repository. When the development team receives a pull request, the team members will review the changes and make a decision on whether to accept the changes or not. However, efficiently finding suitable pull request reviewers is a challenge. In this paper, we propose a multi-instance-based deep neural network model to recommend reviewers for pull requests. Given a pull request, our model extracts three features, which pull request title, commit message, and code change. The proposed model extracts the three features automatically from the code\u00a0\u2026", "num_citations": "1\n", "authors": ["800"]}
{"title": "Multi-label Classification of Commit Messages using Transfer Learning\n", "abstract": " Commit messages are used in the industry by developers to annotate changes made to the code. Accurate classification of these messages can help monitor the software evolution process and enable better tracking for various industrial stakeholders. In this paper, we present a state of the art method for commit message classification into categories as per Swanson\u2019s maintenance activities i.e. \u201cCorrective\u201d, \u201cPerfective\u201d, and \u201cAdaptive\u201d. This is a challenging task because not all commit messages are well written and informative. Existing approaches rely on keyword-based techniques to solve this problem. However, these approaches are oblivious to the full language model and do not recognize the contextual relationship between words. State of the art methodology in Natural Language Processing (NLP), is to train a context-aware neural network (Transformer) on a very large data set that encompasses the entire\u00a0\u2026", "num_citations": "1\n", "authors": ["800"]}