{"title": "Conquering aspects with Caesar\n", "abstract": " Join point interception (JPI), is considered an important cornerstone of aspect-oriented languages. However, we claim that JPI alone does not suffice for a modular structuring of aspects. We propose CAESAR, a model for aspect-oriented programming with a higher-level module concept on top of JPI, which enables reuse and componentization of aspects, allows us to use aspects polymorphically, and introduces a novel concept for dynamic aspect deployment.", "num_citations": "394\n", "authors": ["263"]}
{"title": "Learning from examples to improve code completion systems\n", "abstract": " The suggestions made by current IDE's code completion features are based exclusively on static type system of the programming language. As a result, often proposals are made which are irrelevant for a particular working context. Also, these suggestions are ordered alphabetically rather than by their relevance in a particular context. In this paper, we present intelligent code completion systems that learn from existing code repositories. We have implemented three such systems, each using the information contained in repositories in a different way. We perform a large-scale quantitative evaluation of these systems, integrate the best performing one into Eclipse, and evaluate the latter also by a user study. Our experiments give evidence that intelligent code completion systems which learn from examples significantly outperform mainstream code completion systems in terms of the relevance of their suggestions and\u00a0\u2026", "num_citations": "370\n", "authors": ["263"]}
{"title": "Aspect-oriented web service composition with AO4BPEL\n", "abstract": " Web services have become a universal technology for integration of distributed and heterogeneous applications over the Internet. Many recent proposals such as the Business Process Modeling Language (BPML) and the Business Process Execution Language for Web Services (BPEL4WS) focus on combining existing web services into more sophisticated web services. However, these standards exhibit some limitations regarding modularity and flexibility. In this paper, we advocate an aspect-oriented approach to web service composition and present AO4BPEL, an aspect-oriented extension to BPEL4WS. With aspects, we capture web service composition in a modular way and the composition becomes more open for dynamic change.", "num_citations": "364\n", "authors": ["263"]}
{"title": "Ao4bpel: An aspect-oriented extension to bpel\n", "abstract": " Process-oriented composition languages such as BPEL allow Web Services to be composed into more sophisticated services using a workflow process. However, such languages exhibit some limitations with respect to modularity and flexibility. They do not provide means for a well-modularized specification of crosscutting concerns such as logging, persistence, auditing, and security. They also do not support the dynamic adaptation of composition at runtime. In this paper, we advocate an aspect-oriented approach to Web Service composition and present the design and implementation of AO4BPEL, an aspect-oriented extension to BPEL. We illustrate through examples how AO4BPEL makes the composition specification more modular and the composition itself more flexible and adaptable.", "num_citations": "340\n", "authors": ["263"]}
{"title": "An overview of CaesarJ\n", "abstract": " CaesarJ is an aspect-oriented language which unifies aspects, classes and packages in a single powerful construct that helps to solve a set of different problems of both aspect-oriented and component-oriented programming. The paper gradually introduces the concepts of the language and illustrates them by showing how they can be used for noninvasive component refinement and integration, as well as for development of well modularized flexible aspects. In this way we demonstrate that the combination of aspect-oriented constructs for joinpoint interception with advanced modularization techniques like virtual classes and propagating mixin composition can open the path towards large-scale aspect components.", "num_citations": "337\n", "authors": ["263"]}
{"title": "Variability management with feature-oriented programming and aspects\n", "abstract": " This paper presents an analysis of feature-oriented and aspect-oriented modularization approaches with respect to variability management as needed in the context of system families. This analysis serves two purposes. On the one hand, our analysis of the weaknesses of feature-oriented approaches (FOAs for short) emphasizes the importance of crosscutting modularity as supported by the aspect-oriented concepts of pointcut and advice. On the other hand, by pointing out some of AspectJ's weaknesses and by demonstrating how Caesar, a language which combines concepts from both AspectJ and FOAs, is more effective in this context, we also demonstrate the power of appropriate support for layer modules.", "num_citations": "317\n", "authors": ["263"]}
{"title": "Adaptive plug-and-play components for evolutionary software development\n", "abstract": " In several works on design methodologies, design patterns, and programming language design, the need for program entities that capture the patterns of collaboration between several classes has been recognized. The idea is that in general the unit of reuse is not a single class, but a slice of behavior affecting a set of collaborating classes. The absence of large-scale components for expressing these collaborations makes object-oriented programs more difficult to maintain and reuse, because functionality is spread over several methods and it becomes difficult to get the\" big picture\". In this paper, we propose Adaptive Plug and Play Components to serve this need. These components are designed such that they not only facilitate the construction of complex software by making the collaborations explicit, but they do so in a manner that supports the evolutionary nature of both structure and behavior.", "num_citations": "281\n", "authors": ["263"]}
{"title": "Hybrid web service composition: business processes meet business rules\n", "abstract": " Over the last few years several process-based web service composition languages have erged, such as BPEL4WS and BPML. These languages define the composition on the basis of a process that specifies the control and data flow among the services to be composed. In this approach, the whole business logic underlying the composition including business policies and constraints is coded as a monolithic block. As a result, business rules are hard to change without affecting the core composition logic.", "num_citations": "251\n", "authors": ["263"]}
{"title": "Virtual machine support for dynamic join points\n", "abstract": " A widespread implementation approach for the join point mechanism of aspect-oriented languages is to instrument areas in code that match the static part of pointcut designators, inserting dynamic checks for that part of matching that depends on run-time conditions, if needed. For performance reasons, such dynamic checks should be avoided whenever possible. One way to do so is to postpone weaving of advice calls until run-time, when conditions determining the emergence of join points hold. This calls for fluid code---code that adapts itself to the join point emergence at run-time, and suggests that AOP concepts should be integrated into the execution model underlying a VM. In this paper, we present first steps toward such an integration in Steamloom, an extension of IBM's Jikes Research Virtual Machine. Steamloom is fairly restricted, but our initial experimental results indicate that aspect-aware VMs and fluid\u00a0\u2026", "num_citations": "231\n", "authors": ["263"]}
{"title": "Expressive pointcuts for increased modularity\n", "abstract": " In aspect-oriented programming, pointcuts are used to describe crosscutting structure. Pointcuts that abstract over irrelevant implementation details are clearly desired to better support maintainability and modular reasoning.               We present an analysis which shows that current pointcut languages support localization of crosscutting concerns but are problematic with respect to information hiding. To cope with the problem, we present a pointcut language that exploits information from different models of program semantics, such as the execution trace, the syntax tree, the heap, static type system, etc., and supports abstraction mechanisms analogous to functional abstraction. We show how this raises the abstraction level and modularity of pointcuts and present first steps toward an efficient implementation by means of a static analysis technique.", "num_citations": "211\n", "authors": ["263"]}
{"title": "Programming with aspectual components\n", "abstract": " Aspect-oriented programming (AOP) controls tangling of concerns by isolating aspects that cross-cut each other into building blocks. Component-based programming (CBP) supports software development by isolating reusable building blocks that can be assembled and connected in many different ways. We show how AOP and CBP can be integrated by introducing a new component construct for programming class collaborations, called aspectual component. Aspectual components extend adaptive plug-and-play components (AP&P) with a modification interface that turns them into an effective tool for AOP. A key ingredient of aspectual components is that they are written in terms of a generic data model, called a participant graph, which is later mapped into a data model. We introduce a new property of this map, called instance-refinement, to ensure the proper deployment of components. We show how aspectual components can be implemented in Java, and demonstrate that aspectual components improve the AspectJ language for AOP from Xerox PARC.", "num_citations": "188\n", "authors": ["263"]}
{"title": "Engineering event-based systems with scopes\n", "abstract": " Event notification services enable loose coupling and they are therefore becoming an essential part of distributed systems\u2019 design. However, the development of event services follows the early stages of programming language evolution, disregarding the need for efficient mechanisms to structure event-based applications. In this paper, the well-known notion of scopes is introduced to event-based systems. We show that limiting the visibility of events is a simple yet powerful mechanism that allows to identify application structure and offers a module construct for the loosely coupled components in event-based systems. We are able to customize the semantics of scoped event notification services by binding meta-objects to the application structure that reify important aspects of notification delivery, like interface mappings and transmission policies. The scoping concept facilitates design and implementation by\u00a0\u2026", "num_citations": "146\n", "authors": ["263"]}
{"title": "Separation of concerns with procedures, annotations, advice and pointcuts\n", "abstract": " There are numerous mechanisms for separation of concerns at the source code level. Three mechanisms that are the focus of recent attention \u2013 metadata annotations, pointcuts and advice \u2013 can be modeled together with good old-fashioned procedures as providing different kinds of bindings: procedure calls bind program points to operations, annotations bind attributes to program points; pointcuts bind sets of points to various descriptions of those sets; named pointcuts bind attributes to sets of points; and advice bind the implementation of an operation to sets of points. This model clarifies how the mechanisms work together to separate concerns, and yields guidelines to help developers use the mechanisms in practice.", "num_citations": "138\n", "authors": ["263"]}
{"title": "Integrating independent components with on-demand remodularization\n", "abstract": " This paper proposes language concepts that facilitate the separation of an application into independent reusable building blocks and the integration of pre-build generic software components into applications that have been developed by third party vendors. A key element of our approach are on-demand remodularizations, meaning that the abstractions and vocabulary of an existing code base are translated into the vocabulary understood by a set of components that are connected by a common collaboration interface. This general concept allows us to mix-and-match remodularizations and components on demand.", "num_citations": "123\n", "authors": ["263"]}
{"title": "SPLLift: statically analyzing software product lines in minutes instead of years\n", "abstract": " A software product line (SPL) encodes a potentially large variety of software products as variants of some common code base. Up until now, re-using traditional static analyses for SPLs was virtually intractable, as it required programmers to generate and analyze all products individually. In this work, however, we show how an important class of existing inter-procedural static analyses can be transparently lifted to SPLs. Without requiring programmers to change a single line of code, our approach SPLLIFT automatically converts any analysis formulated for traditional programs within the popular IFDS framework for inter-procedural, finite, distributive, subset problems to an SPL-aware analysis formulated in the IDE framework, a well-known extension to IFDS. Using a full implementation based on Heros, Soot, CIDE and JavaBDD, we show that with SPLLIFT one can reuse IFDS-based analyses without changing a\u00a0\u2026", "num_citations": "122\n", "authors": ["263"]}
{"title": "Defining and continuous checking of structural program dependencies\n", "abstract": " Dependencies between program elements need to be modeled from different perspectives reflecting architectural, design, and implementation level decisions. To avoid erosion of the intended structure of the code, it is necessary to explicitly codify these different perspectives on the permitted dependencies and to detect violations continuously and incrementally as software evolves.", "num_citations": "115\n", "authors": ["263"]}
{"title": "Da capo con scala: Design and analysis of a scala benchmark suite for the java virtual machine\n", "abstract": " Originally conceived as the target platform for Java alone, the Java Virtual Machine (JVM) has since been targeted by other languages, one of which is Scala. This trend, however, is not yet reflected by the benchmark suites commonly used in JVM research. In this paper, we thus present the design and analysis of the first full-fledged benchmark suite for Scala. We furthermore compare the benchmarks contained therein with those from the well-known DaCapo 9.12 benchmark suite and show where the differences are between Scala and Java code---and where not.", "num_citations": "111\n", "authors": ["263"]}
{"title": "Using aspects for security engineering of web service compositions\n", "abstract": " Web Service composition languages promise a cheap and effective means for application integration over the Internet as in typical B2B interaction scenarios. BPEL is the upcoming standard for Web Service composition and several implementations of it are already available. However, for Web Service composition languages to keep their promises it is essential to provide more support for security. Companies will embrace Web Service composition languages only if their requirements of confidentiality, integrity, authentication, etc. are fulfilled. In this paper, we look at security in Web Services compositions and present a framework for securing BPEL compositions using WS-Security and WS-Policy. The main components of our framework are the process container implemented by a set of aspects in AO4BPEL, an aspect-oriented extension to BPEL, the security service and the deployment descriptor. We also\u00a0\u2026", "num_citations": "110\n", "authors": ["263"]}
{"title": "REScala: Bridging between object-oriented and functional style in reactive applications\n", "abstract": " Traditionally, object-oriented software adopts the Observer pattern to implement reactive behavior. Its drawbacks are well-documented and two families of alternative approaches have been proposed, extending object-oriented languages with concepts from functional reactive and dataflow programming, respectively event-driven programming. The former hardly escape the functional setting; the latter do not achieve the declarativeness of more functional approaches.", "num_citations": "106\n", "authors": ["263"]}
{"title": "Mining framework usage changes from instantiation code\n", "abstract": " Framework evolution may break existing users, which need to be migrated to the new framework version. This is a tedious and error-prone process that benefits from automation. Existing approaches compare two versions of the framework code in order to find changes caused by refactorings. However, other kinds of changes exist, which are relevant for the migration. In this paper, we propose to mine framework usage change rules from already ported instantiations, the latter being applications build on top of the framework, or test cases maintained by the framework developers. Our evaluation shows that our approach finds usage changes not only caused by refactorings, but also by conceptual changes within the framework. Further, it copes well with some issues that plague tools focusing on finding refactorings such as deprecated program elements or multiple changes applied to a single program element.", "num_citations": "106\n", "authors": ["263"]}
{"title": "A plug-in architecture for self-adaptive web service compositions\n", "abstract": " Several approaches have been proposed to introduce self-management capabilities for Web service compositions.However, most of these works are limited as they are not extensible, i.e., new self-adaptation features cannot be supported, and even if that is possible then still this cannot be done dynamically while the composite services are running.In addition, many of these works are not based on the service composition standard WS-BPEL. In this paper, we propose a plug-in architecture for self-adaptive Web service composition, in which self-adaptation features are well-modularized in aspect based plug-ins. Our approach supports application-specific adaptation scenarios, is easily extensible, and allows self-adaptation logic to be hot-deployed on running process instances. We have implemented this architecture and several plug-ins using the dynamic aspect-oriented workflow language AO4BPEL.", "num_citations": "95\n", "authors": ["263"]}
{"title": "What should developers be aware of? An empirical study on the directives of API documentation\n", "abstract": " Application Programming Interfaces (API) are exposed to developers in order to reuse software libraries. API directives are natural-language statements in API documentation that make developers aware of constraints and guidelines related to the usage of an API. This paper presents the design and the results of an empirical study on the directives of API documentation of object-oriented libraries. Its main contribution is to propose and extensively discuss a taxonomy of 23 kinds of API directives.", "num_citations": "91\n", "authors": ["263"]}
{"title": "Aspect-oriented business process modeling with AO4BPMN\n", "abstract": " Many crosscutting concerns in business processes need to be addressed already at the business process modeling level such as compliance, auditing, billing, and separation of duties. However, existing business process modeling languages including OMG\u2019s Business Process Modeling Notation (BPMN) lack appropriate means for expressing such concerns in a modular way. In this paper, we motivate the need for aspect-oriented concepts in business process modeling languages and propose an aspect-oriented extension to BPMN called AO4BPMN. We also present a graphical editor supporting that extension.", "num_citations": "90\n", "authors": ["263"]}
{"title": "Component integration with pluggable composite adapters\n", "abstract": " In this chapter we address object-oriented component integration issues. We argue that traditional framework customization techniques are inappropriate for component-based programming since they lack support for non-invasive, encapsulated, dynamic customization. We propose a new language construct, called a pluggable composite adapter, for expressing component gluing. A pluggable composite adapter allows the separation of customization code from component implementation, resulting in better modularity, flexible extensibility, and improved maintenance and understandability. We also discuss alternative realizations of the construct.", "num_citations": "90\n", "authors": ["263"]}
{"title": "Distributed REScala: an update algorithm for distributed reactive programming\n", "abstract": " Reactive programming improves the design of reactive applications by relocating the logic for managing dependencies between dependent values away from the application logic to the language implementation. Many distributed applications are reactive. Yet, existing change propagation algorithms are not suitable in a distributed setting. We propose Distributed REScala, a reactive language with a change propagation algorithm that works without centralized knowledge about the topology of the dependency structure among reactive values and avoids unnecessary propagation of changes, while retaining safety guarantees (glitch freedom). Distributed REScala enables distributed reactive programming, bringing the benefits of reactive programming to distributed applications. We demonstrate the enabled design improvements by a case study. We also empirically evaluate the performance of our algorithm in\u00a0\u2026", "num_citations": "89\n", "authors": ["263"]}
{"title": "Detecting missing method calls in object-oriented software\n", "abstract": " When using object-oriented frameworks it is easy to overlook certain important method calls that are required at particular places in code. In this paper, we provide a comprehensive set of empirical facts on this problem, starting from traces of missing method calls in a bug repository. We propose a new system, which automatically detects them during both software development and quality assurance phases. The evaluation shows that it has a low false positive rate (<5%) and that it is able to find missing method calls in the source code of the Eclipse IDE.", "num_citations": "79\n", "authors": ["263"]}
{"title": "EScala: modular event-driven object interactions in Scala\n", "abstract": " Event-driven programming style in OO languages based on imperatively triggered events does not support separate and more declarative event definitions by composition or transformation of other events. AO language mechanisms for defining events as declarative queries over implicitly available low-level events seem good candidates to approach these problems. However, being designed for modularizing mostly globally scoped, crosscutting concerns, AO mechanisms deliberately break with the OO design and modular reasoning style and are thus inappropriate for addressing modularity concerns related to event-based interactions in OO designs.", "num_citations": "78\n", "authors": ["263"]}
{"title": "Aspect-oriented workflow languages\n", "abstract": " Most available aspect-oriented languages today are extensions to programming languages. However, aspect-orientation, which is a paradigm for decomposition and modularization, is not only applicable in that context. In this paper, we introduce aspect-oriented software development concepts to workflow languages in order to improve the modularity of workflow process specifications with respect to crosscutting concerns and crosscutting changes. In fact, crosscutting concerns such as data validation and security cannot be captured in a modular way when using the constructs provided by current workflow languages. We will propose a concern-based decomposition of workflow process specifications and present the main concepts of aspect-oriented workflow languages using AO4BPEL, which is an aspect-oriented workflow language for Web Service composition.", "num_citations": "73\n", "authors": ["263"]}
{"title": "Pointcuts as functional queries\n", "abstract": " Most aspect-oriented languages provide only a fixed, built-in set of pointcut designators whose denotation is only described informally. As a consequence, these languages do not provide operations to manipulate or reason about pointcuts beyond weaving. In this paper, we investigate the usage of the functional query language XQuery for the specification of pointcuts. Due to its abstraction and module facilities, XQuery enables powerful composition and reusability mechanisms for pointcuts.", "num_citations": "71\n", "authors": ["263"]}
{"title": "FrUiT: IDE support for framework understanding\n", "abstract": " Frameworks provide means to reuse existing design and functionality, but first require developers to understand how to use them. Learning the correct usage of a framework can be difficult due to the large number of rules to obey and the complex collaborations between the classes. We propose the use of data mining techniques to extract reuse patterns from existing framework instantiations. Based on these patterns, suggestions about other relevant parts of the framework are presented to novice users in a context-dependent manner. We have built FrUiT, an Eclipse plug-in that implements this approach and present a first assessment by mining parts of the Eclipse framework.", "num_citations": "69\n", "authors": ["263"]}
{"title": "Middleware services for web service compositions\n", "abstract": " WS-* specifications cover a variety of issues ranging from security and reliability to transaction support in web services. However, these specifications do not address web service compositions. On the other hand, BPEL as the future standard web service composition language allows the specification of the functional part of the composition as a business process but it fails short in expressing non-functional properties such as security, reliability and persistence. In this paper, we propose an approach for the transparent integration of technical concerns in web service compositions. Our approach is driven by the analogy between web services and software components and is inspired from server-side component models such as Enterprise Java Beans. The main components of our framework are the process container, the middleware services and the deployment descriptor.", "num_citations": "69\n", "authors": ["263"]}
{"title": "PIROL: A case study for multidimensional separation of concerns in software engineering environments\n", "abstract": " In this paper, we present our experience with applying multidimensional separation of concerns to a software engineering environment. By comparing two different designs of our system, we show the importance of separating integration issues from the implementation of the individual concerns. We present a model in which integration issues are encapsulated into rst--class connector objects and indicate how this facilitates the understandability, maintenance and evolution of the system. We identify issues of binding time, binding granularity and binding cardinality as important criteria in selecting an appropriate model for separation of concerns. We finally show how a good choice following these criteria and considering the requirements of software engineering environments leads to a system with dynamic configurability, high--level component integration and support for multiple instantiable views.", "num_citations": "69\n", "authors": ["263"]}
{"title": "The SEXTANT software exploration tool\n", "abstract": " In this paper, we discuss a set of functional requirements for software exploration tools and provide initial evidence that various combinations of these features are needed to effectively assist developers in understanding software. We observe that current tools for software exploration only partly support these features. This has motivated the development of SEXTANT, a software exploration tool tightly integrated into the Eclipse IDE that has been developed to fill this gap. By means of case studies, we demonstrate how the requirements fulfilled by SEXTANT are conducive to an understanding needed to perform a maintenance task", "num_citations": "68\n", "authors": ["263"]}
{"title": "Object-oriented composition untangled\n", "abstract": " Object-oriented languages come with pre-defined composition mechansims, such as inheritance, object composition, or delegation, each characterized by a certain set of composition properties, which do not themselves individually exist as abstractions at the language level. However, often non-standard composition semantics is needed, with a mixture of composition mechanisms. Such non-standard semantics are simulated by complicated architectures that are sensitive to requirement changes and cannot easily be adapted without invalidating existing clients. In this paper, we propose compound references, a new abstraction for object references, that allows us to provide explicit linguistic means for expressing and combining individual composition properties on-demand. The model is statically typed and allows the programmer to express a seamless spectrum of composition semantics in the interval between\u00a0\u2026", "num_citations": "68\n", "authors": ["263"]}
{"title": "Semi-automatically extracting FAQs to improve accessibility of software development knowledge\n", "abstract": " Frequently asked questions (FAQs) are a popular way to document software development knowledge. As creating such documents is expensive, this paper presents an approach for automatically extracting FAQs from sources of software development discussion, such as mailing lists and Internet forums, by combining techniques of text mining and natural language processing. We apply the approach to popular mailing lists and carry out a survey among software developers to show that it is able to extract high-quality FAQs that may be further improved by experts.", "num_citations": "66\n", "authors": ["263"]}
{"title": "Pegasus: first steps toward a naturalistic programming language\n", "abstract": " In this article a new programming paradigm is discussed: naturalistic programming. Naturalistic Programming means writing computer programs with the help of natural language. The authors are convinced that contemporary programming techniques have reached a level where only a fundamental change of paradigm can develop them any further. Introducing, philosophical and epistemological issues related to programming and human thinking are discussed. After that, the programming language Pegasus is presented. It has been developed as a scientific prototype of a naturalistic programming language at the Darmstadt University of Technology. Pegasus can read natural language and create executable program files from that. In addition to that, Pegasus can automatically translate programs between different natural languages, by the time of writing: German and English. Subsequently, an overview on related\u00a0\u2026", "num_citations": "64\n", "authors": ["263"]}
{"title": "Reliable, secure, and transacted web service compositions with ao4bpel\n", "abstract": " Web service compositions in BPEL have several nonfunctional requirements such as security, reliable messaging, and transactions. Although many WS-* specifications address such non-functional concerns in the Web service context, they focus only on the messaging-level requirements without addressing the process-level requirements. In this paper, we discuss different non-functional requirements in BPEL workflows and observe that current orchestration engines lack support for the specification and enforcement of such requirements, especially for process-level requirements. To solve this problem, we present a container framework, which introduces an XML-based deployment descriptor to specify the non-functional requirements in a declarative way. To enforce these requirements, a process container intercepts the process execution and calls dedicated middleware Web services. We implemented the\u00a0\u2026", "num_citations": "63\n", "authors": ["263"]}
{"title": "A dynamic software product line approach using aspect models at runtime\n", "abstract": " Dynamic software product lines (DSPLs) are software product lines, which support late variability that is built into the system to address requirements that change at runtime. But it is difficult to ensure at runtime that all possible adaptations lead to a correct configuration. In this paper, we propose a novel approach for DSPLs that uses a dynamic feature model to describe the variability in the DSPLs and that uses a domain-specific language for declaratively implementing variations and their constraints. The approach combines several trends in aspect-oriented programming for DSPLs, namely dynamic aspects, runtime models of aspects, as well as detection and resolution of aspect interactions. The advantage is, that reconfigurations must not be specified for every feature combination, but only for interacting features. We have validated the approach in an example dynamic software product line from industry and preliminarily evaluated the approach.", "num_citations": "61\n", "authors": ["263"]}
{"title": "Specifying and monitoring temporal properties in web services compositions\n", "abstract": " Current Web service composition approaches and languages such as WS-BPEL do not allow to define temporal constraints in a declarative and separate way. Also it is not possible to verify if there are contradictions between the temporal constraints implemented in the composition. These limitations lead to maintainability and correctness problems. In this paper, we tackle these problems through a novel approach to temporal constraints in Web service compositions, which combines formal methods and aspect-oriented programming. In this approach, we use a powerful and expressive formal language, called XTUS-Automata, for specifying time-related properties and we introduce specification patterns that ease the definition of such constraints. The formal specifications are translated automatically into AO4BPEL aspects, which ensure the runtime monitoring of the temporal constraints. Our approach enables a\u00a0\u2026", "num_citations": "59\n", "authors": ["263"]}
{"title": "Envelope-based weaving for faster aspect compilers\n", "abstract": " Current compilers for aspect-oriented programs are rather costly in terms of memory and time consumed at compile-time. this is because member accesses that are advised by aspects, generally, occur several times in the program code. these sites are in complex methods whose control flows must be updated when weaving advice. In this paper we present a new weaving technique that introduces indirections into the program code which makes weaving advice easier. We will show that the time and memory consumption at compile-time benefits from this approach and still the loss of runtime-performance is acceptable as the introduced indirections are optimized away by the execution environment.", "num_citations": "59\n", "authors": ["263"]}
{"title": "Dynamic object evolution without name collisions\n", "abstract": " Support for modular evolution of objects is required in many application areas. However, existing mechanisms for incremental behavior composition either do not support evolving objects at all, or do not satisfactorily solve the encapsulation and name collision problems associated with them. In this paper, a new approach to behavior composition in a class-based environment is presented. It is based on the encapsulated object model of class-based inheritance, but introduces an additional abstraction layer between objects and classes. By being responsible for the compositional aspects of the behavior of objects, this layer provides support for the evolution of behavior while at the same time solving the name conflicts that may occur. A formal description of the approach is provided and its feasibility is demonstrated by implementing it as a metalevel extension of Smalltalk-80.", "num_citations": "59\n", "authors": ["263"]}
{"title": "Xirc: A kernel for cross-artifact information engineering in software development environments\n", "abstract": " We describe XIRC, a tool and architecture that enables to define queries over a uniform representation of all artifacts of a software project. These queries can be used for general cross-artifact information retrieval or for more special applications like checking implementation restrictions or conformance to style guides. XIRC is also a good basis to implement a broad range of tools for refactoring, generators, aspect-oriented programming and many other domains on top of it.", "num_citations": "58\n", "authors": ["263"]}
{"title": "Maintaining the consistency of class libraries during their evolution\n", "abstract": " Two important problems of object-oriented reuse are the propagation of design and implementation specifics of the base software to the inheritors, and the protection of the inheritors against changes in the base software. In this paper, we argue that the simple inheritance rules of existing object-oriented languages are not sufficient for properly dealing with these problems. In the proposal presented in this paper, programmers are enabled to make metalevel declarations of the internal protocols and dependencies of their classes. Additionally, changes of the base module are automatically monitored to filter out information about the alterations that may invalidate already existing inheritors. Based on these informations, the subclassing semantics is adjusted such that the maintenance of the base module properties and the protection of the inheritor is ensured during their integration, In this way, language support is\u00a0\u2026", "num_citations": "57\n", "authors": ["263"]}
{"title": "On aspectualizing component models\n", "abstract": " Server\u2010side component models such as Enterprise JavaBeans (EJB) add powerful abstractions to the bare \u2018business objects\u2019 layer in order to support a clean separation of server\u2010side application logic from other concerns such as distribution, security, transaction management and persistence. An improved separation of concerns is also the main goal of aspect\u2010oriented programming (AOP). This paper compares the two approaches and reasons about the possibility of substituting (parts of) component models using AOP mechanisms. We conclude that AOP is a promising approach to eliminate important shortcomings of the container\u2010based component approach. However, our analysis of concrete aspect\u2010oriented languages shows that current AOP technology is not yet mature enough to supersede component models. Copyright \u00a9 2003 John Wiley & Sons, Ltd.", "num_citations": "55\n", "authors": ["263"]}
{"title": "An aspect-based process container for BPEL\n", "abstract": " In recent years, several WS-* specifications have been proposed to address the middleware requirements of web services such as security, reliable messaging, and transactions. On the other hand side, BPEL is the upcoming standard for composing existing web services into more complex ones. In this paper, we look at the middleware requirements of web service compositions and specifically those specified in BPEL. We argue that the WS-* specifications such as WS-Security and WS-Reliability do not address these requirements appropriately. We introduce a framework for providing middleware support in BPEL engines based on a process container, which intercepts the execution of BPEL processes and calls dedicated middleware services to plug in support for security, persistence, reliable messaging, etc. The container is implemented as a lightweight container using AO4BPEL aspects and the middleware\u00a0\u2026", "num_citations": "51\n", "authors": ["263"]}
{"title": "Finding duplicates of your yet unwritten bug report\n", "abstract": " Software projects often use bug-tracking tools to keep track of reported bugs and to provide a communication platform to discuss possible solutions or ways to reproduce failures. The goal is to reduce testing efforts for the development team. However, often, multiple bug reports are committed for the same bug, which, if not recognized as duplicates, can result in work done multiple times by the development team. Duplicate recognition is, in turn, tedious, requiring to examine large amounts of bug reports. Previous work addresses this problem by employing natural-language processing and text similarity measures to automate bug-report duplicate detection. The downside of these techniques is that, to be applicable, they require a reporting user to go through the time-consuming process of describing the problem, just to get informed that the bug is already known. To address this problem, we propose an approach that\u00a0\u2026", "num_citations": "50\n", "authors": ["263"]}
{"title": "Detecting missing method calls as violations of the majority rule\n", "abstract": " When using object-oriented frameworks it is easy to overlook certain important method calls that are required at particular places in code. In this article, we provide a comprehensive set of empirical facts on this problem, starting from traces of missing method calls in a bug repository. We propose a new system that searches for missing method calls in software based on the other method calls that are observable. Our key insight is that the voting theory concept of majority rule holds for method calls: a call is likely to be missing if there is a majority of similar pieces of code where this call is present. The evaluation shows that the system predictions go further missing method calls and often reveal different kinds of code smells (e.g., violations of API best practices).", "num_citations": "46\n", "authors": ["263"]}
{"title": "Using annotations to check structural properties of classes\n", "abstract": " The specification of meta-information, by using attributes in .NET or annotations in Java, along with the source code is gaining widespread use. Meta-information is used for different purposes such as code generation or configuration of the environment in which a class is deployed. However, in most cases using an annotation also implies that constraints, beyond those defined by the language\u2019s semantics, have to be followed. E.g., a class must define a no-arguments constructor or the parameters of a method must have specific types. Currently, these constraints are not checked at all or only to a very limited extend. Hence, a violation can remain undetected and result in deployment-time or even subtle run-time errors. In this paper, we present a user-extensible framework that enables the definition of constraints to check the properties of annotated elements. Further, we demonstrate the application of the\u00a0\u2026", "num_citations": "46\n", "authors": ["263"]}
{"title": "An execution layer for aspect-oriented programming languages\n", "abstract": " Language mechanisms deserve language implementation effort. While this maxim has led to sophisticated support for language features specific to object-oriented, functional and logic programming languages, aspect-oriented programming languages are still mostly implemented using postprocessors. The Steamloom virtual machine, based on IBM's Jikes RVM, provides support for aspect-oriented programming at virtual machine level. A bytecode framework called BAT was integrated with the Jikes RVM to replace its bytecode management logic. While preserving the functionality needed by the VM, BAT also allows for querying application code for join point shadows, avoiding redundancy in bytecode representation. Performance measurements show that an AOP-enabled virtual machine like Steamloom does not inflict unnecessary performance penalties on a running application; when it comes to executing AOP\u00a0\u2026", "num_citations": "45\n", "authors": ["263"]}
{"title": "Micro-measurements for dynamic aspect-oriented systems\n", "abstract": " The benefits of aspect-oriented programming (AOP) with respect to software design are getting more and more accepted, and measurements have shown that AOP does not necessarily introduce severe performance penalties. A benchmark suite for measuring the performance of AspectJ software is being developed. However, general benchmarks are missing for the emerging field of dynamic AOP, even though major J2EE application server vendors begin to employ dynamic aspects in their systems. Instead, work on dynamic AOP frequently comprises varying measurements. To be eventually able to classify such systems along their performance qualities, it is important to develop a benchmark suite for dynamic AOP. In this paper, we present a first building block for such a benchmark suite in the form of micro-measurements. We also present and discuss results gained by running the measurements in\u00a0\u2026", "num_citations": "44\n", "authors": ["263"]}
{"title": "The art of the meta-aspect protocol\n", "abstract": " Alternative semantics for aspect-oriented abstractions can be defined by language designers using extensible aspect compiler frameworks. However, application developers are prevented from tailoring the language semantics in an application-specific manner. To address this problem, we propose an architecture for aspect-oriented languages with an explicit meta-interface to language semantics. We demonstrate the benefits of such an architecture by presenting several scenarios in which aspect-oriented programs use the meta-interface of the language to tailor its semantics to a particular application execution context.", "num_citations": "41\n", "authors": ["263"]}
{"title": "Debugging for reactive programming\n", "abstract": " Reactive programming is a recent programming technique that provides dedicated language abstractions for reactive software. Reactive programming relieves developers from manually updating outputs when the inputs of a computation change, it overcomes a number of well-know issues of the Observer design pattern, and it makes programs more comprehensible. Unfortunately, complementing the new paradigm with proper tools is a vastly unexplored area. Hence, as of now, developers can embrace reactive programming only at the cost of a more challenging development process. In this paper, we investigate a primary issue in the field: debugging programs in the reactive style. We analyze the problem of debugging reactive programs, show that the reactive style requires a paradigm shift in the concepts needed for debugging, and propose RP Debugging, a methodology for effectively debugging reactive\u00a0\u2026", "num_citations": "40\n", "authors": ["263"]}
{"title": "Dependent classes\n", "abstract": " Virtual classes allow nested classes to be refined in subclasses. In this way nested classes can be seen as dependent abstractions of the objects of the enclosing classes. Expressing dependency via nesting, however, has two limitations: Abstractions that depend on more than one object cannot be modeled and a class must know all classes that depend on its objects. This paper presents dependent classes, a generalization of virtual classes that expresses similar semantics by parameterization rather than by nesting. This increases expressivity of class variations as well as the flexibility of their modularization. Besides, dependent classes complement multimethods in scenarios where multi-dispatched abstractions rather than multi-dispatched methods are needed. They can also be used to express more precise signatures of multimethods and even extend their dispatch semantics. We present a formal semantics of\u00a0\u2026", "num_citations": "40\n", "authors": ["263"]}
{"title": "Alice: Modularization of middleware using aspect-oriented programming\n", "abstract": " In this paper, we identify three problems with current component middleware. First, the implementation of services is usually not modularized, making it hard to adapt the platform to application specific needs, to exchange services to cope with changing requirements or to use it on different devices. Second, mapping components to objects results in a complex programming model and is making the component code dependent on the used component framework. Third, application level crosscutting concerns are not modularized.               To solve these problems, we propose an aspect-oriented programming approach, complemented by standard Java 1.5 annotations to provide meta information about the components, and a sophisticated query language for pointcut designation based on annotations.", "num_citations": "39\n", "authors": ["263"]}
{"title": "The convergence of aop and active databases: Towards reactive middleware\n", "abstract": " Reactive behavior is rapidly becoming a key feature of modern software systems in such diverse areas as ubiquitous computing, autonomic systems, and event-based supply chain management. In this paper we analyze the convergence of techniques from aspect oriented programming, active databases and asynchronous notification systems to form reactive middleware. We identify the common core of abstractions and explain both commonalities and differences to start a dialogue across community boundaries. We present existing options for implementation of reactive software and analyze their run-time semantics. We do not advocate a particular approach but concentrate on identifying how the various disciplines can benefit from each other. We believe that AOP can solve the impedance mismatch found in reactive systems that are implemented through inherently static languages, while AOP can benefit\u00a0\u2026", "num_citations": "39\n", "authors": ["263"]}
{"title": "CodeMatch: obfuscation won't conceal your repackaged app\n", "abstract": " An established way to steal the income of app developers, or to trick users into installing malware, is the creation of repackaged apps. These are clones of-typically-successful apps. To conceal their nature, they are often obfuscated by their creators. But, given that it is a common best practice to obfuscate apps, a trivial identification of repackaged apps is not possible. The problem is further intensified by the prevalent usage of libraries. In many apps, the size of the overall code base is basically determined by the used libraries. Therefore, two apps, where the obfuscated code bases are very similar, do not have to be repackages of each other. To reliably detect repackaged apps, we propose a two step approach which first focuses on the identification and removal of the library code in obfuscated apps. This approach-LibDetect-relies on code representations which abstract over several parts of the underlying bytecode\u00a0\u2026", "num_citations": "38\n", "authors": ["263"]}
{"title": "Variational Object-Oriented Programming Beyond Classes and Inheritance\n", "abstract": " Purpose of the Book This book presents an approach to improve the standard object-oriented pro gramming model. The proposal is aimed at supporting a larger range of incre mental behavior variations and thus promises to be more effective in mastering the complexity of today's software. The ability of dealing with the evolutionary nature of software is one of main merits of object-oriented data abstraction and inheritance. Object-orientation allows to organize software in a structured way by separating the description of different kinds of an abstract data type into different classes and loosely connecting them by the inheritance hierarchy. Due to this separation, the soft ware becomes free of conditional logics previously needed for distinguishing between different kinds of abstractions and can thus more easily be incremen tally extended to support new kinds of abstractions. In other words, classes and inheritance are means to properly model variations of behavior related to the existence of different kinds of an abstract data type. The support for extensi bility and reuse with respect to such kind-specific behavior variations is among the main reasons for the increasing popularity of object-oriented programming in the last two decades. However, this popularity does not prevent us from questioning the real effec tiveness of current object-oriented techniques in supporting incremental vari ations. In fact, this popularity makes a critical investigation of the variations that can actually be performed incrementally even more important.", "num_citations": "37\n", "authors": ["263"]}
{"title": "Mind the GAP: Security & privacy risks of contact tracing apps\n", "abstract": " Google and Apple have jointly provided an API for exposure notification in order to implement decentralized contract tracing apps using Bluetooth Low Energy, the so-called \u201cGoogle/Apple Proposal\u201d, which we abbreviate by \u201cGAP\u201d. We demonstrate that in real-world scenarios the current GAP design is vulnerable to (i) profiling and possibly de-anonymizing infected persons, and (ii) relay-based wormhole attacks that basically can generate fake contacts with the potential of affecting the accuracy of an app-based contact tracing system. For both types of attack, we have built tools that can easily be used on mobile phones or Raspberry Pis (e.g., Bluetooth sniffers). The goal of our work is to perform a reality check towards possibly providing empirical real-world evidence for these two privacy and security risks. We hope that our findings provide valuable input for developing secure and privacy-preserving digital contact\u00a0\u2026", "num_citations": "36\n", "authors": ["263"]}
{"title": "Mining subclassing directives to improve framework reuse\n", "abstract": " To help developers in using frameworks, good documentation is crucial. However, it is a challenge to create high quality documentation especially of hotspots in white-box frameworks. This paper presents an approach to documentation of object-oriented white-box frameworks which mines from client code four different kinds of documentation items, which we call subclassing directives. A case study on the Eclipse JFace user-interface framework shows that the approach can improve the state of API documentation w.r.t. subclassing directives.", "num_citations": "36\n", "authors": ["263"]}
{"title": "Querying source code with natural language\n", "abstract": " One common task of developing or maintaining software is searching the source code for information like specific method calls or write accesses to certain fields. This kind of information is required to correctly implement new features and to solve bugs. This paper presents an approach for querying source code with natural language.", "num_citations": "35\n", "authors": ["263"]}
{"title": "Call graph construction for java libraries\n", "abstract": " Today, every application uses software libraries. Yet, while a lot of research exists wrt analyzing applications, research that targets the analysis of libraries independent of any application is scarce. This is unfortunate, because, for developers of libraries, such as the Java Development Kit (JDK), it is crucial to ensure that the library behaves as intended regardless of how it is used. To fill this gap, we discuss the construction of call graphs for libraries that abstract over all potential library usages. Call graphs are particularly relevant as they are a precursor of many advanced analyses, such as inter-procedural data-flow analyses.", "num_citations": "34\n", "authors": ["263"]}
{"title": "Reactive behavior in object-oriented applications: an analysis and a research roadmap\n", "abstract": " Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies-like functional reactive programming and dataflow languages-provide undoubted advantages but do not fit well with mutable objects. In this paper, we provide a research roadmap to overcome the limitations of the current approaches and to support reactive applications in the OO setting. To establish a solid background for our investigation, we propose a conceptual framework to model the design space of reactive applications and we study the flaws of the existing solutions. Then we highlight how reactive languages have the potential to address those issues and we formulate our research plan.", "num_citations": "34\n", "authors": ["263"]}
{"title": "Automatic incrementalization of prolog based static analyses\n", "abstract": " Modern development environments integrate various static analyses into the build process. Analyses that analyze the whole project whenever the project changes are impractical in this context. We present an approach to automatic incrementalization of analyses that are specified as tabled logic programs and evaluated using incremental tabled evaluation, a technique for efficiently updating memo tables in response to changes in facts and rules. The approach has been implemented and integrated into the Eclipse IDE. Our measurements show that this technique is effective for automatically incrementalizing a broad range of static analyses.", "num_citations": "33\n", "authors": ["263"]}
{"title": "i3QL: Language-integrated live data views\n", "abstract": " An incremental computation updates its result based on a change to its input, which is often an order of magnitude faster than a recomputation from scratch. In particular, incrementalization can make expensive computations feasible for settings that require short feedback cycles, such as interactive systems, IDEs, or (soft) real-time systems.", "num_citations": "31\n", "authors": ["263"]}
{"title": "JP2: Call-site aware calling context profiling for the Java Virtual Machine\n", "abstract": " Calling context profiling fulfills programmers\u2019 information needs to obtain a complete picture of a program\u2019s inter- and intra-procedural control flow, which are important for workload characterization, debugging, profiling, program comprehension, and reverse engineering. Many existing calling context profilers for Java, however, resort to sampling or other incomplete instrumentation techniques; thus, they collect incomplete profiles only. In this article we present JP2, a new calling context profiler for the Java Virtual Machine, which collects profiles that are not only complete but also call-site aware; that is, JP2 is able to distinguish between multiple call sites within a single method. JP2 supports selective profiling of the dynamic extent of chosen methods and supports profiling of native method invocations. Moreover, produced profiles contain execution statistics at the level of individual basic blocks of code, thereby\u00a0\u2026", "num_citations": "31\n", "authors": ["263"]}
{"title": "Towards distributed reactive programming\n", "abstract": " Reactive applications is a wide class of software that responds to user input, network messages, and other events. Recent research on reactive languages successfully addresses the drawbacks of the Observer pattern \u2013 the traditional way reactive applications are implemented in the object-oriented setting \u2013 by introducing time-changing values and other ad-hoc programming abstractions.             However, those approaches are limited to local settings, but most applications are distributed. We highlight the research challenges of distributed reactive programming and present a research roadmap. We argue that distributed reactive programming not only moves reactive languages to the distributed setting, but is a promising concept for middleware and distributed systems design.", "num_citations": "31\n", "authors": ["263"]}
{"title": "Dynamic component gluing\n", "abstract": " Frameworks elevate encapsulation and reuse to the level of large-grained components, namely groups of collaborating classes. The abstract collaboration defined in a framework is easily customized by an application through static subclassing. However, this implies non-independent development of the application and framework models and excludes the possibility of dynamically deploying the framework. We propose the dynamic composite adapter design pattern, which employs the use of Java inner classes to achieve dynamic, modular, non-invasive, component adaptation. We also present a new scoping construct for succinctly defining dynamic adaptation of Java components.", "num_citations": "29\n", "authors": ["263"]}
{"title": "Blending and reusing rules for architectural degradation prevention\n", "abstract": " As software systems are maintained, their architecture often de-grades through the processes of architectural drift and erosion. These processes are often intertwined and the same modules in the code become the locus of both drift and erosion symptoms. Thus, architects should elaborate architecture rules for detecting occur-rences of both degradation symptoms. While the specification of such rules is time-consuming, they are similar across software projects adhering to similar architecture decompositions. Unfortu-nately, existing anti-degradation techniques are limited as they focus only on detecting either drift or erosion symptoms. They also do not support the reuse of recurring anti-degradation rules. In this context, the contribution of this paper is twofold. First, it presents TamDera, a domain-specific language for:(i) specifying rule-based strategies to detect both erosion and drift symptoms, and (ii) promoting the\u00a0\u2026", "num_citations": "28\n", "authors": ["263"]}
{"title": "Heuristic strategies for recommendation of exception handling code\n", "abstract": " Software developers have difficulties in implementing exception handling code in their systems. In particular, they fail in implementing appropriate handling actions. Not surprisingly, recurring failures and performance issues are often related to the poor exception handling actions implemented in real software systems. In this paper we propose, implement and evaluate a set of three heuristic strategies used to recommend exception handling code in programming tasks. Given a method in which the developer wants to handle an exception, the heuristics recommend a list of code fragments implementing exception handling. The heuristics' goal is to accurately find code fragments implementing exception handling and recommend these fragments according to the context of developers' implementation task. Hence, the proposed heuristics may assist developers in the process of discovering exception handling actions\u00a0\u2026", "num_citations": "27\n", "authors": ["263"]}
{"title": "Modules for crosscutting models\n", "abstract": " Traditional programming languages assume that real-world systems have \u201cintuitive\u201d, mind-independent, preexisting concept hierarchies. However, our perception of the world depends heavily on the context from which it is viewed: Every software system can be viewed from multiple different perspectives, and each of these perspectives may imply a different decomposition of the concerns. The hierarchy which we choose to decompose our software system into modules is to a large degree arbitrary, although it has a big influence on the software engineering properties of the software. We identify this arbitrariness of the decomposition hierarchy as the main cause of \u2018code tangling\u2019 and present a new model called Caesar                         1, within which it is possible to have multiple different decompositions simultaneously and to add new decompositions on-demand.", "num_citations": "27\n", "authors": ["263"]}
{"title": "An architecture for composing embedded domain-specific languages\n", "abstract": " Embedded domain-specific languages (EDSLs) are said to be easier to compose than DSLs that are implemented by preprocessors. However, existing approaches focus on composition scenarios where the use of abstractions from one domain does not affect the interpretation of abstractions from another domain. This leads to programs that exhibit scattering and tangling symptoms if multiple EDSLs with crosscutting domain semantics are used. To address this issue, we propose an architecture for embedding DSLs that makes use of meta-object protocols and aspect-oriented concepts to support crosscutting composition of EDSLs. This enables to write modularized EDSL programs where each program addresses one concern.", "num_citations": "25\n", "authors": ["263"]}
{"title": "Towards more flexibility in software visualization tools\n", "abstract": " Software visualization has been researched for years, but current IDEs lack support for modern visualization techniques. It seems that the tools are either focused and not applicable to a broad range of tasks, or they are generic but do not provide good support for specific tasks. What is needed are tools that provide flexibility to customize the visualization technique, layout, and appearance, and enable users to aggregate and filter information based on various attributes. We make a case for a layered software visualization framework, which exposes such flexibility to the user. Having such a tool, developers are capable to customize visualization in an easy manner, so that it is most appropriate for their current task", "num_citations": "25\n", "authors": ["263"]}
{"title": "Declaring and enforcing dependencies between. net custom attributes\n", "abstract": " Custom attributes as e.g., supported by the .NET framework complemented by pre- or post-processing tools can be used to integrate domain-specific concepts into general-purpose language technology, representing an interesting alternative to domain-specific languages in supporting model-driven development. For this purpose, it is important that dependency relationships between custom attributes, e.g., stating that a certain attribute requires or excludes another attribute, can be specified and checked for during model processing (compilation). Such dependencies can be viewed as an important part of expressing the meta-model of the domain-specific concepts represented by custom attributes.               In this paper, we present an approach to specifying and enforcing dependencies between .NET custom attributes, which naturally extends the built-in .NET support. In this approach, dependencies are\u00a0\u2026", "num_citations": "25\n", "authors": ["263"]}
{"title": "new Scala () instance of Java: a comparison of the memory behaviour of Java and Scala programs\n", "abstract": " While often designed with a single language in mind, managed runtimes like the Java virtual machine (JVM) have become the target of not one but many languages, all of which benefit from the runtime's services. One of these services is automatic memory management. In this paper, we compare and contrast the memory behaviour of programs written in Java and Scala, respectively, two languages which both target the same platform: the JVM. We both analyze core object demographics like object lifetimes as well as secondary properties of objects like their associated monitors and identity hash-codes. We find that objects in Scala programs have lower survival rates and higher rates of immutability, which is only partly explained by the memory behaviour of objects representing closures or boxed primitives. Other metrics vary more by benchmark than language.", "num_citations": "24\n", "authors": ["263"]}
{"title": "On evaluating recommender systems for API usages\n", "abstract": " To ease framework understanding, tools have been developed that analyze existing framework instantiations to extract API usage patterns and present them to the user. However, detailed quantitative evaluations of such recommender systems are lacking. In this paper we present an automated evaluation process which extracts queries and expected results from existing code bases. This enables the validation of recommendation systems with large test beds in an objective manner by means of precision and recall measures. We demonstrate the applicability of our approach by evaluating an improvement of an existing API recommender tool that takes into account the framework-method context for recommendations.", "num_citations": "24\n", "authors": ["263"]}
{"title": "Programming with implicit flows\n", "abstract": " Modern software differs significantly from traditional computer applications that mostly process reasonably small amounts of static input data-sets in batch mode. Modern software increasingly processes massive amounts of data, whereby it is also often the case that new input data is produced and/or existing data is modified on the fly. Consequently, programming models that facilitate the development of such software are emerging. What characterizes them is that data, respectively changes thereof, implicitly flow through computation modules. The software engineer declaratively defines computations as compositions of other computations without explicitly modeling how data should flow along dependency relations between data producer and data consumer modules, letting the runtime to automatically manage and optimize data flows.", "num_citations": "23\n", "authors": ["263"]}
{"title": "Towards reactive programming for object-oriented applications\n", "abstract": " Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies \u2013 like functional reactive programming and dataflow languages \u2013 provide undoubted advantages but do not fit well with mutable objects.               In this paper, we provide a research roadmap to overcome the limitations of the current approaches and to support reactive applications in the OO setting. To establish a solid background for our investigation, we propose a conceptual framework to model the design space of reactive applications and we study the flaws of the existing solutions. Then we highlight how reactive languages have the potential to address those issues and we formulate our research\u00a0\u2026", "num_citations": "23\n", "authors": ["263"]}
{"title": "A co-contextual formulation of type rules and its application to incremental type checking\n", "abstract": " Type rules associate types to expressions given a typing context. As the type checker traverses the expression tree top-down, it extends the typing context with additional context information that becomes available. This way, the typing context coordinates type checking in otherwise independent subexpressions, which inhibits parallelization and incrementalization of type checking. We propose a co-contextual formulation of type rules that only take an expression as input and produce a type and a set of context requirements. Co-contextual type checkers traverse an expression tree bottom-up and merge context requirements of independently checked subexpressions. We describe a method for systematically constructing a co-contextual formulation of type rules from a regular context-based formulation and we show how co-contextual type rules give rise to incremental type checking. Using our method, we derive\u00a0\u2026", "num_citations": "22\n", "authors": ["263"]}
{"title": "Fault-tolerant distributed reactive programming\n", "abstract": " In this paper, we present a holistic approach to provide fault tolerance for distributed reactive programming. Our solution automatically stores and recovers program state to handle crashes, automatically updates and shares distributed parts of the state to provide eventual consistency, and handles errors in a fine-grained manner to allow precise manual control when necessary. By making use of the reactive programming paradigm, we provide these mechanisms without changing the behavior of existing programs and with reasonable performance, as indicated by our experimental evaluation.", "num_citations": "21\n", "authors": ["263"]}
{"title": "Naturalistic types\n", "abstract": " The typical properties of natural language-redundancy avoidance, locality, and immediacy-support high semantic density and improve readability, and therefore, are also interesting for the design of programming languages. To achieve these properties, natural language heavily relies on types, which are used for referencing, generalization, and description of instances. With naturalistic types we conceptualize the idea of natural language types for use in programming. This article demonstrates possible applications of naturalistic types for programming and gives a detailed analysis of their constituents-concepts, properties, quantities, and conditions.", "num_citations": "21\n", "authors": ["263"]}
{"title": "Dynamically linked domain-specific extensions for advice languages\n", "abstract": " Domain-specific aspect languages allow defining aspects for a certain problem domain faster and easier by providing specialized expressivity and by reducing the complexity of the language interface. However, providing domain-specific aspect languages is a rather complex task. With current approaches only specialists can build new domain specific aspect languages; in doing so they have to replicate large parts of the tool set. In this paper, we have extended a general-purpose aspect language to support embedded domain-specific syntax in the advice language. The approach has several advantages. First, it allows reusing a large part of existing tools and infrastructure. Second domain-specific extensions can be defined in separated modules, which can be dynamically linked into the advice language; these modules can be inherited from, they can be refined from existing implementations, and can be\u00a0\u2026", "num_citations": "21\n", "authors": ["263"]}
{"title": "Portable and accurate collection of calling-context-sensitive bytecode metrics for the Java virtual machine\n", "abstract": " Calling-context profiles and dynamic metrics at the bytecode level are important for profiling, workload characterization, program comprehension, and reverse engineering. Prevailing tools for collecting calling-context profiles or dynamic bytecode metrics often provide only incomplete information or suffer from limited compatibility with standard JVMs. However, completeness and accuracy of the profiles is essential for tasks such as workload characterization, and compatibility with standard JVMs is important to ensure that complex workloads can be executed. In this paper, we present the design and implementation of JP2, a new tool that profiles both the inter-and intra-procedural control flow of workloads on standard JVMs. JP2 produces calling-context profiles preserving callsite information, as well as execution statistics at the level of individual basic blocks of code. JP2 is complemented with scripts that compute\u00a0\u2026", "num_citations": "20\n", "authors": ["263"]}
{"title": "Judge: identifying, understanding, and evaluating sources of unsoundness in call graphs\n", "abstract": " Call graphs are widely used; in particular for advanced control-and data-flow analyses. Even though many call graph algorithms with different precision and scalability properties have been proposed, a comprehensive understanding of sources of unsoundness, their relevance, and the capabilities of existing call graph algorithms in this respect is missing. To address this problem, we propose Judge, a toolchain that helps with understanding sources of unsoundness and improving the soundness of call graphs. In several experiments, we use Judge and an extensive test suite related to sources of unsoundness to (a) compute capability profiles for call graph implementations of Soot, WALA, DOOP, and OPAL,(b) to determine the prevalence of language features and APIs that affect soundness in modern Java Bytecode,(c) to compare the call graphs of Soot, WALA, DOOP, and OPAL\u2013highlighting important differences\u00a0\u2026", "num_citations": "18\n", "authors": ["263"]}
{"title": "Type systems for the masses: Deriving soundness proofs and efficient checkers\n", "abstract": " The correct definition and implementation of non-trivial type systems is difficult and requires expert knowledge, which is not available to developers of domain-specific languages (DSLs) in practice. We propose Veritas, a workbench that simplifies the development of sound type systems. Veritas provides a single, high-level specification language for type systems, from which it automatically tries to derive soundness proofs and efficient and correct type-checking algorithms. For verification, Veritas combines off-the-shelf automated first-order theorem provers with automated proof strategies specific to type systems. For deriving efficient type checkers, Veritas provides a collection of optimization strategies whose applicability to a given type system is checked through verification on a case-by-case basis. We have developed a prototypical implementation of Veritas and used it to verify type soundness of the simply-typed\u00a0\u2026", "num_citations": "18\n", "authors": ["263"]}
{"title": "Systematic evaluation of the unsoundness of call graph construction algorithms for Java\n", "abstract": " Call graphs are at the core of many static analyses ranging from the detection of unused methods to advanced control-and data-flow analyses. Therefore, a comprehensive understanding of the precision and recall of the respective graphs is crucial to enable an assessment which call-graph construction algorithms are suited in which analysis scenario. For example, malware is often obfuscated and tries to hide its intent by using Reflection. Call graphs that do not represent reflective method calls are, therefore, of limited use when analyzing such apps.", "num_citations": "17\n", "authors": ["263"]}
{"title": "Hidden truths in dead software paths\n", "abstract": " Approaches and techniques for statically finding a multitude of issues in source code have been developed in the past. A core property of these approaches is that they are usually targeted towards finding only a very specific kind of issue and that the effort to develop such an analysis is significant. This strictly limits the number of kinds of issues that can be detected. In this paper, we discuss a generic approach based on the detection of infeasible paths in code that can discover a wide range of code smells ranging from useless code that hinders comprehension to real bugs. Code issues are identified by calculating the difference between the control-flow graph that contains all technically possible edges and the corresponding graph recorded while performing a more precise analysis using abstract interpretation. We have evaluated the approach using the Java Development Kit as well as the Qualitas Corpus (a\u00a0\u2026", "num_citations": "17\n", "authors": ["263"]}
{"title": "JEScala: Modular coordination with declarative events and joins\n", "abstract": " Advanced concurrency abstractions overcome the drawbacks of low-level techniques such as locks and monitors, freeing programmers that implement concurrent applications from the burden of concentrating on low-level details. However, with current approaches the coordination logic involved in complex coordination schemas is fragmented into several pieces including join patterns, data emissions triggered in different places of the application, and the application logic that implicitly creates dependencies among communication channels, hence indirectly among join patterns. We present JEScala, a language that captures coordination schemas in a more expressive and modular way by leveraging a seamless integration of an advanced event system with join abstractions. We validate our approach with case studies and provide a first performance assessment.", "num_citations": "17\n", "authors": ["263"]}
{"title": "Composing non-functional concerns in composite web services\n", "abstract": " The support for non-functional concerns (NFC) is essential for the success and adoption of web services. However, state of the art works offer only a limited support for these concerns especially when it comes to the composition of multiple non-functional concerns with composite web services. In this paper, we focus on the composition of non-functional actions (NFA) with composite web services whose composition logic is made explicit using languages such as BPMN2 or WS-BPEL (gray box view). In contrast to the black box view where only the interface of the service is visible the gray box view reveals additional information on control flow, data flow, composed services, etc. NFAs can also be composite and constitute complex processes such as secure conversations or transactions which have to be integrated with composite web services. Additionally, the execution order of multiple superimposing NFA has to be\u00a0\u2026", "num_citations": "17\n", "authors": ["263"]}
{"title": "Transactional BPEL processes with AO4BPEL aspects\n", "abstract": " Recently, OASIS approved two standards respectively for Web Service composition and for Web Service transactions. Nevertheless, it is still unclear how WS-BPEL and the WS-TX family of specifications interoperate, i.e., how to use atomic transactions and business activities in the context of BPEL processes. In this paper, we present several transactional requirements in BPEL processes and argue that BPEL's compensation mechanism provides only limited support for a few of these requirements, e.g., it cannot cope with atomic transactions with the ACID properties. To support transactional BPEL processes, we use the AO4BPEL process container framework. In this framework, the transaction requirements of the process activities are specified declaratively in a deployment descriptor and an aspectbased container is generated automatically to integrate the process execution with the transaction middleware, which\u00a0\u2026", "num_citations": "16\n", "authors": ["263"]}
{"title": "DTN7: An open-Source disruption-tolerant networking implementation of Bundle Protocol 7\n", "abstract": " In disruption-tolerant networking (DTN), data is transmitted in a store-carry-forward fashion from network node to network node. In this paper, we present an open source DTN implementation, called DTN7, of the recently released Bundle Protocol Version 7 (draft version 13). DTN7 is written in Go and provides features like memory safety and concurrent execution. With its modular design and interchangeable components, DTN7 facilitates DTN research and application development. Furthermore, we present results of a comparative experimental evaluation of DTN7 and other DTN systems including Serval, IBR-DTN, and Forban. Our results indicate that DTN7 is a flexible and efficient open-source multi-platform implementation of the most recent Bundle Protocol Version 7.", "num_citations": "15\n", "authors": ["263"]}
{"title": "Versatile event correlation with algebraic effects\n", "abstract": " We present the first language design to uniformly express variants of n-way joins over asynchronous event streams from different domains, e.g., stream-relational algebra, event processing, reactive and concurrent programming. We model asynchronous reactive programs and joins in direct style, on top of algebraic effects and handlers. Effect handlers act as modular interpreters of event notifications, enabling fine-grained control abstractions and customizable event matching. Join variants can be considered as cartesian product computations with \u201ddegenerate\u201d control flow, such that unnecessary tuples are not materialized a priori. Based on this computational interpretation, we decompose joins into a generic, naive enumeration procedure of the cartesian product, plus variant-specific extensions, represented in terms of user-supplied effect handlers. Our microbenchmarks validate that this extensible design avoids\u00a0\u2026", "num_citations": "15\n", "authors": ["263"]}
{"title": "Turbo DiSL: partial evaluation for high-level bytecode instrumentation\n", "abstract": " Bytecode instrumentation is a key technique for the implementation of dynamic program analysis tools such as profilers and debuggers. Traditionally, bytecode instrumentation has been supported by low-level bytecode engineering libraries that are difficult to use. Recently, the domain-specific aspect language DiSL has been proposed to provide high-level abstractions for the rapid development of efficient bytecode instrumentations. While DiSL supports user-defined expressions that are evaluated at weave-time, the DiSL programming model requires these expressions to be implemented in separate classes, thus increasing code size and impairing code readability and maintenance. In addition, the DiSL weaver may produce a significant amount of dead code, which may impair some optimizations performed by the runtime. In this paper we introduce Turbo, a novel partial evaluator for DiSL, which\u00a0\u2026", "num_citations": "15\n", "authors": ["263"]}
{"title": "Complete and platform-independent calling context profiling for the Java virtual machine\n", "abstract": " Calling context profiling collects statistics separately for each calling context. Complete calling context profiles that faithfully represent overall program execution are important for a sound analysis of program behavior, which in turn is important for program understanding, reverse engineering, and workload characterization. Many existing calling context profilers for Java rely on sampling or on incomplete instrumentation techniques, yielding incomplete profiles; others rely on Java Virtual Machine (JVM) modifications or work only with one specific JVM, thus compromising portability. In this paper we present a new calling context profiler for Java that reconciles completeness of the collected profiles and full compatibility with any standard JVM. In order to reduce measurement perturbation, our profiler collects platform-independent dynamic metrics, such as the number of method invocations and the number of executed\u00a0\u2026", "num_citations": "15\n", "authors": ["263"]}
{"title": "\u03c0: a pattern language\n", "abstract": " Current programming languages and techniques realize many features which allow their users to extend these languages on a semantic basis: classes, functions, interfaces, aspects and other entities can be defined. However, there is a lack of modern programming languages which are both semantically and syntactically extensible from within the language itself, ie, with no additional tool or meta-language. In this paper we present \u03c0 as an approach that aims to overcome this lack. \u03c0 provides an abstraction mechanism based on parameterized symbols which is capable of semantically and syntactically unifying programming concepts like variables, control-structures, procedures and functions into one concept: the pattern. We have evaluated the abstraction potential and the syntactic extensibility of \u03c0 by successfully creating patterns for the aforementioned programming concepts. \u03c0 could serve as a tool for\u00a0\u2026", "num_citations": "15\n", "authors": ["263"]}
{"title": "Reliable messaging for BPEL processes\n", "abstract": " There are currently two specifications that address reliable messaging in Web services: WS-reliablemessaging and WS-reliability. Both specifications consider the general case of Web services as being black boxes with WSDL interfaces. In this paper, we address the reliable messaging requirements of composite Web wervices in BPEL. In such Web services, the BPEL programmer sees not only the WSDL interface but also the implementation, i.e., the process definition. BPEL processes have several reliable messaging requirements, which cannot be supported by current reliable messaging specifications. The most challenging of those requirements is to support ordered message delivery between many endpoints. Current reliable messaging specifications support only reliable messaging between two endpoints. This paper presents several approaches to support multi-party reliable messaging and introduces a\u00a0\u2026", "num_citations": "15\n", "authors": ["263"]}
{"title": "Dynamically balanced synchronization-avoiding LU factorization with multicore and GPUs\n", "abstract": " Graphics processing units (GPUs) brought huge performance improvements in the scientific and numerical fields. We present an efficient hybrid CPU/GPU approach that is portable, dynamically and efficiently balances the workload between the CPUs and the GPUs, and avoidsdata transfer bottlenecks that are frequently present in numerical algorithms. Our approach determines the amount of initial work to assign to the CPUs before the execution, and then dynamically balances workloads during the execution. Then, we present a theoretical model to guide the choice of the initial amount of work for the CPUs. The validation of our model allows our approach to self-adapt on any architecture using the manufacturer's characteristics of the underlying machine. We illustrate our method for the LU factorization. For this case, we show that the use of our approach combined with a communication avoiding LU algorithm is\u00a0\u2026", "num_citations": "14\n", "authors": ["263"]}
{"title": "From formal access control policies to runtime enforcement aspects\n", "abstract": " We present an approach that addresses both formal specification and verification as well as runtime enforcement of RBAC access control policies including application specific constraints such as separation of duties (SoD). We introduce Temporal                 , a formal language based on Z and temporal logic, which provides domain specific predicates for expressing RBAC and SoD constraints. An aspect-oriented language with domain specific concepts for RBAC and SoD constraints is used for the runtime enforcement of policies. Enforcement aspects are automatically generated from Temporal                  specifications hence avoiding the possibility of errors and inconsistencies that may be introduced when enforcement code is written manually. Furthermore, the use of aspects ensures the modularity of the enforcement code and its separation from the business logic.", "num_citations": "14\n", "authors": ["263"]}
{"title": "Mobcon: A generative middleware framework for java mobile applications\n", "abstract": " While dedicated technologies such as e.g., Sun's J2ME MIDP offer a simple programming model for mobile applications, appropriate support for modularizing the implementation of technical concerns such as data persistence, screen management, session management, etc. is still missing. As the result, the implementation of such concerns cuts across several applications, or even several places within a single application. In this paper, we introduce the notion of a logical mobile container aimed at automating the process of nearly transparently adding technical concerns to the core functionality of a MIDP application. The container we introduce is logical: Code generation allows us to profit from high-level abstractions without adding physical layers which are too costly for a mobile application. We present an extensible mobile container framework for MIDP applications, called MobCon, which is implemented as a\u00a0\u2026", "num_citations": "14\n", "authors": ["263"]}
{"title": "Untangling crosscutting models with CAESAR\n", "abstract": " As early as 1972, Parnas (22) noted that the criteria that we choose for decomposing software systems into modules have an important impact on the software engineering properties of the resulting system. For example, a data-centric decomposition eases changes in the representation of data structures (22), whereas function-centric decomposition makes it easy to modify functions of the system or add new features (10). With the aspect-oriented software development paradigm, the decomposition problem is considered under a new light: The question is now not as much about which criteria to choose as it is about how to support the decomposition of systems simultaneously according to several independent criteria. Such simultaneous decompositions are needed because our perception of the world and especially our perception of software systems depend heavily on this idea: Observing a software system from different perspectives may imply completely different decompositions of the concerns, yielding crosscutting models.For a technical definition of the term \u201ccrosscutting,\u201d the reader is referred to Masuhara and Kiczales (16). Here we give an informal (graphical) characterization. Consider Figure 8-1. Each shape stands for a particular object (in the most general sense) of a software system. We have three options for organizing this space: by size (see Figure 8-2), by shape (see Figure 8-3), or by color (see Figure 8-4). The resulting classifications are all equally reasonable models of the space, but they are not hierarchically related. That is, they do not represent more or less detailed views of the", "num_citations": "14\n", "authors": ["263"]}
{"title": "Thread-safe reactive programming\n", "abstract": " The execution of an application written in a reactive language involves transfer of data and control flow between imperative and reactive abstractions at well-defined points. In a multi-threaded environment, multiple such interactions may execute concurrently, potentially causing data races and event ordering ambiguities. Existing RP languages either disable multi-threading or handle it at the cost of reducing expressiveness or weakening consistency. This paper proposes a model for thread-safe reactive programming (RP) that ensures abort-free strict serializability under concurrency while sacrificing neither expressiveness nor consistency. We also propose an architecture for integrating a corresponding scheduler into the RP language runtime, such that thread-safety is provided \"out-of-the-box\" to the applications.   We show the feasibility of our proposal by providing and evaluating a ready-to-use implementation\u00a0\u2026", "num_citations": "13\n", "authors": ["263"]}
{"title": "Exploration of language specifications by compilation to first-order logic\n", "abstract": " Exploration of language specifications helps to discover errors and inconsistencies early during the development of a programming language. We propose exploration of language specifications via application of existing automated first-order theorem provers (ATPs). To this end, we translate language specifications and exploration tasks to first-order logic, which many ATPs accept as input. However, there are several different strategies for compiling a language specification to first-order logic, and even small variations in the translation may have a large impact on the time it takes ATPs to find proofs.In this paper, we first present a systematic empirical study on how to best compile language specifications to first-order logic such that existing ATPs can solve typical exploration tasks efficiently. We have developed a compiler product line that implements 36 different compilation strategies and used it to feed language\u00a0\u2026", "num_citations": "13\n", "authors": ["263"]}
{"title": "Incremental concrete syntax for embedded languages with support for separate compilation\n", "abstract": " Embedded domain-specific languages (EDSLs) are known to improve the productivity of developers. However, for many domains no DSL implementation is available and two important reasons for this are: First, the effort to implement EDSLs that provide the domain\u2019s established syntax (called concrete syntax) is very high. Second, the EDSL and its underlying general-purpose programming language (GPL) are typically tightly integrated. This hampers reusability across different GPLs. Besides these implementation issues, the productivity gains of using EDSLs are also limited by the lack of explicit tool support for EDSL users\u2014such as syntax highlighting or code analyses.In this paper, we present an approach that significantly reduces the necessary effort to implement embedded DSLs with concrete syntax. The idea is to use island grammars to specify the EDSL\u2019s concrete syntax. This enables the developer to\u00a0\u2026", "num_citations": "13\n", "authors": ["263"]}
{"title": "Non-functional concerns in web services: requirements and state of the art analysis\n", "abstract": " For the success and adoption of web services it is essential that not only functional concerns (FC) are addressed but also non-functional concerns (NFC) such as security, reliable messaging, performance, and availability. The support for non-functional concerns encompasses two aspects: the specification and the enforcement and we focus thereby on two views: the black box view (only the interface) and the gray box view (the internal process of a composite service).", "num_citations": "13\n", "authors": ["263"]}
{"title": "Language support for model-driven software development\n", "abstract": " This paper is about language technology for facilitating model-driven software development. We argue that two features are important for this purpose: (a) support for explicit meta-representation of programs as an AST-like structure (AST stands for abstract syntax tree) accessible in a programmatic way before and beyond the compilation, and (b) support for user-defined annotations of program elements. That is, we argue for language platforms organized around a Generalized Annotated AST, or GAAST languages for short. We outline the problems with a model-driven development process based on languages without such a support and show how GAAST language technology addresses these problems.", "num_citations": "13\n", "authors": ["263"]}
{"title": "A co-contextual type checker for featherweight java (incl. proofs)\n", "abstract": " This paper addresses compositional and incremental type checking for object-oriented programming languages. Recent work achieved incremental type checking for structurally typed functional languages through co-contextual typing rules, a constraint-based formulation that removes any context dependency for expression typings. However, that work does not cover key features of object-oriented languages: Subtype polymorphism, nominal typing, and implementation inheritance. Type checkers encode these features in the form of class tables, an additional form of typing context inhibiting incrementalization. In the present work, we demonstrate that an appropriate co-contextual notion to class tables exists, paving the way to efficient incremental type checkers for object-oriented languages. This yields a novel formulation of Igarashi et al.'s Featherweight Java (FJ) type system, where we replace class tables by the dual concept of class table requirements and class table operations by dual operations on class table requirements. We prove the equivalence of FJ's type system and our co-contextual formulation. Based on our formulation, we implemented an incremental FJ type checker and compared its performance against javac on a number of realistic example programs.", "num_citations": "12\n", "authors": ["263"]}
{"title": "Modular specification and checking of structural dependencies\n", "abstract": " Checking a software's structural dependencies is a line of research on methods and tools for analyzing, modeling and checking the conformance of source code wrt specifications of its intended static structure. Existing approaches have focused on the correctness of the specification, the impact of the approaches on software quality and the expressiveness of the modeling languages. However, large specifications become unmaintainable in the event of evolution without the means to modularize such specifications. We present Vespucci, a novel approach and tool that partitions a specification of the expected and allowed dependencies into a set of cohesive slices. This facilitates modular reasoning and helps individual maintenance of each slice. Our approach is suited for modeling high-level as well as detailed low-level decisions related to the static structure and combines both in a single modeling formalism. To\u00a0\u2026", "num_citations": "12\n", "authors": ["263"]}
{"title": "A recommendation system for exception handling code\n", "abstract": " Even though exception handling mechanisms are part of most mainstream programming languages, software developers still struggle to implement proper exception handling code. In particular, they fail in implementing effective handler actions. This position paper discusses our ongoing work on implementing and assessing a recommendation system for recommending code fragments implementing exception handling code. These fragments are not meant to be reused as-is. Instead, they are meant to be used by the developers as examples of how to possibly handle their exceptions. The goal of the proposed recommendation system is to assist the learning process of software developers by providing concrete examples of exception handling code.", "num_citations": "12\n", "authors": ["263"]}
{"title": "Component composition using feature models\n", "abstract": " In general, components provide and require services and two components are bound if the first component provides a service required by the second component. However, certain variability in services \u2013 w.r.t. how and which functionality is provided or required \u2013 cannot be described using standard interface description languages. If this variability is relevant when selecting a matching component then human interaction is required to decide which components can be bound. We propose to use feature models for making this variability explicit and (re-)enabling automatic component binding. In our approach, feature models are one part of service specifications. This enables to declaratively specify which service variant is provided by a component. By referring to a service\u2019s variation points, a component that requires a specific service can list the requirements on the desired variant. Using these specifications\u00a0\u2026", "num_citations": "12\n", "authors": ["263"]}
{"title": "Redundancy-free residual dispatch: using ordered binary decision diagrams for efficient dispatch\n", "abstract": " State-of-the-art implementations of common aspect-oriented languages weave residual dispatching logic for advice whose applicability cannot be determined at compile-time. But being derived from the residue's formula representation the woven code often implements an evaluation strategy which mandates redundant evaluations of atomic pointcuts. In order to improve upon the average-case run-time cost, this paper presents an alternative representation which enables efficient residual dispatch, namely ordered binary decision diagrams. In particular, this representation facilitates the complete elimination of redundant evaluations across all pointcuts sharing a join point shadow.", "num_citations": "12\n", "authors": ["263"]}
{"title": "Combining formal methods and aspects for specifying and enforcing architectural invariants\n", "abstract": " Several types of invariants should be maintained when the architecture of a software application evolves. To specify these invariants in a reliable way, formal methods are used. However, current approaches suffer from two limitations. First, they support only certain types of invariants. Second, checking and enforcing the invariants is generally done by adding appropriate logic to the application implementation in a manual way, which is error-prone and may lead to architectural erosion.               In this paper, we combine the Z notation and Petri nets to specify formally architectural invariants in distributed object-oriented software applications. Moreover, we use a generative aspect-based approach to checking and enforcing these invariants. Thus, we bridge the gap between the formal specification and the implementation. Our approach brings several other benefits as the code that checks and enforces\u00a0\u2026", "num_citations": "12\n", "authors": ["263"]}
{"title": "A comparison of program generation with aspect-oriented programming\n", "abstract": " Program generation and transformation techniques have gained considerable attention in the context of domain-specific languages (DSLs) and model-driven architecture (MDA). In this paper we compare domain-specific program generators with general-purpose aspect-oriented languages. We argue that program generation techniques have severe disadvantages with respect to composability, scalability, understandability, and other important software engineering issues. Finally, we advocate general-purpose aspect-oriented languages as an alternative for the implementation of domain-specific languages.", "num_citations": "12\n", "authors": ["263"]}
{"title": "Hidden in plain sight: Obfuscated strings threatening your privacy\n", "abstract": " String obfuscation is an established technique used by proprietary, closed-source applications to protect intellectual property. Furthermore, it is also frequently used to hide spyware or malware in applications. In both cases, the techniques range from bit-manipulation over XOR operations to AES encryption. However, string obfuscation techniques/tools suffer from one shared weakness: They generally have to embed the necessary logic to deobfuscate strings into the app code. In this paper, we show that most of the string obfuscation techniques found in malicious and benign applications for Android can easily be broken in an automated fashion. We developed StringHound, an open-source tool that uses novel techniques that identify obfuscated strings and reconstruct the originals using slicing. We evaluated StringHound on both benign and malicious Android apps. In summary, we deobfuscate almost 30 times\u00a0\u2026", "num_citations": "11\n", "authors": ["263"]}
{"title": "CPL: A core language for cloud computing\n", "abstract": " Running distributed applications in the cloud involves deployment. That is, distribution and configuration of application services and middleware infrastructure. The considerable complexity of these tasks resulted in the emergence of declarative JSON-based domain-specific deployment languages to develop deployment programs. However, existing deployment programs unsafely compose artifacts written in different languages, leading to bugs that are hard to detect before run time. Furthermore, deployment languages do not provide extension points for custom implementations of existing cloud services such as application-specific load balancing policies. To address these shortcomings, we propose CPL (Cloud Platform Language), a statically-typed core language for programming both distributed applications as well as their deployment on a cloud platform. In CPL, application services and deployment programs\u00a0\u2026", "num_citations": "11\n", "authors": ["263"]}
{"title": "Composing non-functional concerns in web services\n", "abstract": " Support for non-functional concerns (NFC) is essential for the success and adoption of web services. This support encompasses two aspects: the specification of NFCs and their realization. However, state-of-the-art works offer only limited support for these aspects. This is especially true for the composition of multiple non-functional concerns with one web service, which is a highly complex task. It is complex because specific knowledge from different domains is required, as well as an understanding of the interdependencies between non-orthogonal NFCs. In this paper, we present an approach and a toolset for the specification and realization of the composition of multiple NFCs in web services. We also present a well-defined process involving different roles and we introduce graphical modeling notations for specifying non-functional requirements, actions realizing the requirements, action compositions and the\u00a0\u2026", "num_citations": "11\n", "authors": ["263"]}
{"title": "Joint efforts to dispel an approaching modularity crisis. Divide et impera, quo vadis?\n", "abstract": " In this paper we consider two important trends in improving separation of concerns:(a) the emergence of server-side component frameworks, and (b) the emergence of advanced approaches to software decomposition/composition. These two trends have emerged independently from each other, the first one in an industrial setting and the second one originating mostly from the object-oriented languages research community. Despite this independent development, both trends have quite some commonalities: not only do they follow the same goals, the key concepts are also basically the same. However, an effort to put both trends into a common reference frame, showing their commonalities, their differences, drawing boundaries on their application areas, analyzing how they complement each other and eventually profit from each other, etc., is still missing today. This paper is a modest effort to fill this gap.", "num_citations": "11\n", "authors": ["263"]}
{"title": "Multimodal complex event processing on mobile devices\n", "abstract": " Mobile devices are increasingly being used in edge and fog computing environments to process contextual data collected by sensors. Although complex event processing (CEP) is a suitable approach for realizing context-aware services on mobile devices in these environments, existing mobile CEP engines do not leverage the full potential of modern mobile hardware/software architectures. In this paper, we present multimodal CEP, a novel approach to process streams of events on-device in user space (user mode), in the operating system (kernel mode), on the Wi-Fi chip (Wi-Fi mode), and/or on a sensor hub (hub mode), providing significant improvements in terms of power consumption and throughput. Multimodal CEP automatically breaks up CEP queries and selects the most adequate execution mode for the involved CEP operators. Filter, aggregation, and correlation operators can be expressed in a high\u00a0\u2026", "num_citations": "10\n", "authors": ["263"]}
{"title": "Weaving aspects and business processes through model transformation\n", "abstract": " Concerns such as logging, auditing and accounting need to be addressed already in the business process modeling phase and not only in the process implementation phase. Mostly, such concerns are modeled as part of the normal flow in business process models. However, the crosscutting nature of such concerns leads to complex, scattered, and tangled models that are hard to understand and to manage. The lack of appropriate means to modularize crosscutting concerns in business process modeling languages seriously affects understandability, maintainability and reusability. In a previous work we proposed AO4BPMN 1.0 as an aspect-oriented extension of BPMN that allows the modularization of crosscutting concerns. However, there were several open issues in that proposal. First, it lacks a concrete weaving mechanism for composing business processes and aspects. Second, it lacks a well-defined\u00a0\u2026", "num_citations": "10\n", "authors": ["263"]}
{"title": "Next in line, please! exploiting the indirect benefits of inlining by accurately predicting further inlining\n", "abstract": " Inlining is an important optimization that can lead to significant runtime improvements. When deciding whether or not to inline a method call, a virtual machine has to weigh an increase in compile time against the expected decrease in program time. To estimate the latter, however, state-of-the-art heuristics only use information local to the call-site in question. But inlining is a powerful enabling optimization; by eliminating the actual call it not only offers an obvious direct benefit but also indirect benefits, as information about the method's arguments is propagated from caller to callee. One such indirect benefit is the elimination of guards in case the callee inlines a method called on one of its arguments. In this paper, we show how to enhance an inlining heuristic by accurately predicting where this further inlining occurs--and where not. To do so, we only use information readily available to many virtual machines: the\u00a0\u2026", "num_citations": "10\n", "authors": ["263"]}
{"title": "Incremental concrete syntax for embedded languages\n", "abstract": " Embedded domain-specific languages (EDSLs) are known to improve the productivity of developers. However, for many domains no DSL implementation is available. Two important reasons are: First, the effort to implement embedded DSLs that provide the domain's established syntax (called concrete syntax) is very high. Second, the embedded DSL and its underlying general-purpose programming language (GPL) are typically tightly integrated which hampers reusability across different GPLs.", "num_citations": "10\n", "authors": ["263"]}
{"title": "Dynamic virtual join point dispatch\n", "abstract": " Conceptually, join points are points in the execution of a program and advice is late-bound to them. We propose the notion of virtual join points that makes this concept ex-plicit not only at a conceptual, but also at implementation level. In current implementations of aspect-oriented lan-guages, binding is performed early, at deploy-time, and only a limited residual dispatch is executed. Current implemen-tations fall in the categories of modifying the application code, modifying the meta-level of an application, or inter-acting with the application by means of events\u2014the latter two already realizing virtual join points to some degree. We provide an implementation of an aspect-oriented execution environment that supports truly virtual join points and dis-cuss how this approach also favors optimizations in the ex-ecution environment. 1.", "num_citations": "10\n", "authors": ["263"]}
{"title": "Reusability of concerns\n", "abstract": " Various recent approaches aim at improving the application of the separation of concerns principle by introducing new system units. Although they seem to have the potential to improve the system development process, additional challenges evolve. This paper addresses some challenges concerning the reusability of these new system units. Our considerations about reusability are twofold. First, the independence of these system units is regarded on the mechanism level. Second, the composition validation problem emerging from the composition of these new and also reusable system units is investigated. The problems are illustrated by means of two examples.", "num_citations": "10\n", "authors": ["263"]}
{"title": "Language-integrated privacy-aware distributed queries\n", "abstract": " Distributed query processing is an effective means for processing large amounts of data. To abstract from the technicalities of distributed systems, algorithms for operator placement automatically distribute sequential data queries over the available processing units. However, current algorithms for operator placement focus on performance and ignore privacy concerns that arise when handling sensitive data. We present a new methodology for privacy-aware operator placement that both prevents leakage of sensitive information and improves performance. Crucially, our approach is based on an information-flow type system for data queries to reason about the sensitivity of query subcomputations. Our solution unfolds in two phases. First, placement space reduction generates deployment candidates based on privacy constraints using a syntax-directed transformation driven by the information-flow type system. Second, constraint solving selects the best placement among the candidates based on a cost model that maximizes performance. We verify that our algorithm preserves the sequential behavior of queries and prevents leakage of sensitive data. We implemented the type system and placement algorithm for a new query language SecQL and demonstrate significant performance improvements in benchmarks.", "num_citations": "9\n", "authors": ["263"]}
{"title": "Hermes: assessment and creation of effective test corpora\n", "abstract": " An integral part of developing a new analysis is to validate the correctness of its implementation and to demonstrate its usefulness when applied to real-world code. As a foundation for addressing both challenges developers typically use custom or well-established collections of Java projects. The hope is that the collected projects are representative for the analysis\u2019 target domain and therefore ensure a sound evaluation. But, without proper means to understand how and to which degree the features relevant to an analysis are found in the projects, the evaluation necessarily remains inconclusive. Additionally, it is likely that the collection contains many projects which are\u2013wrt the developed analysis\u2013basically identical and therefore do not help the overall evaluation/testing of the analysis, but still cost evaluation time. To overcome these limitations we propose Hermes, a framework that enables the systematic\u00a0\u2026", "num_citations": "9\n", "authors": ["263"]}
{"title": "Online reprogrammable multi tenant switches\n", "abstract": " Recent research shows many benefits for cloud workloads and network operations when putting software functionality onto switches. Sharing the physical resources of a programmable switch between multiple tenants and workloads enables the widespread deployment of on-switch software functionality. Currently, changing the program on a programmable switch incurs significant switch downtime, connectivity loss, and service interruption. We, therefore propose a modification to the common programmable switch architecture to enable hot-pluggability, the ability to insert, modify, and remove on-path software functionality without interrupting the network operation. With hot-pluggability, a programmable switch can be shared between applications of different on-switch lifetime and therefore also between different tenants. Such sharing requires performance and program isolation between different on-switch functions\u00a0\u2026", "num_citations": "8\n", "authors": ["263"]}
{"title": "A fault-tolerant programming model for distributed interactive applications\n", "abstract": " Ubiquitous connectivity of web, mobile, and IoT computing platforms has fostered a variety of distributed applications with decentralized state. These applications execute across multiple devices with varying reliability and connectivity. Unfortunately, there is no declarative fault-tolerant programming model for distributed interactive applications with an inherently decentralized system model. We present a novel approach to automating fault tolerance using high-level programming abstractions tailored to the needs of distributed interactive applications. Specifically, we propose a calculus that enables formal reasoning about applications' dataflow within and across individual devices. Our calculus reinterprets the functional reactive programming model to seamlessly integrate its automated state change propagation with automated crash recovery of device-local dataflow and disconnection-tolerant distribution with guaranteed automated eventual consistency semantics based on conflict-free replicated datatypes. As a result, programmers are relieved of handling intricate details of distributing change propagation and coping with distribution failures in the presence of interactivity. We also provides proofs of our claims, an implementation of our calculus, and an empirical evaluation using a common interactive application.", "num_citations": "8\n", "authors": ["263"]}
{"title": "A unified lattice model and framework for purity analyses\n", "abstract": " Analyzing methods in object-oriented programs whether they are side-effect free and also deterministic, i.e., mathematically pure, has been the target of extensive research. Identifying such methods helps to find code smells and security related issues, and also helps analyses detecting concurrency bugs. Pure methods are also used by formal verification approaches as the foundations for specifications and proving the pureness is necessary to ensure correct specifications. However, so far no common terminology exists which describes the purity of methods. Furthermore, some terms (e.g., pure or side-effect free) are also used inconsistently. Further, all current approaches only report selected purity information making them only suitable for a smaller subset of the potential use cases. In this paper, we present a fine-grained unified lattice model which puts the purity levels found in the literature into relation and which\u00a0\u2026", "num_citations": "8\n", "authors": ["263"]}
{"title": "Opportunistic named functions in disruption-tolerant emergency networks\n", "abstract": " Information-centric disruption-tolerant networks (ICN-DTNs) are useful to re-establish mobile communication in disaster scenarios when telecommunication infrastructures are partially or completely unavailable. In this paper, we present opportunistic named functions, a novel approach to operate ICN-DTNs during emergencies. Affected people and first responders use their mobile devices to specify their interests in particular content and/or application-specific functions that are then executed in the network on the fly, either partially or totally, in an opportunistic manner. Opportunistic named functions rely on user-defined interests and on locally optimal decisions based on battery lifetimes and device capabilities. In the presented emergency scenario, they are used to preprocess, analyze, integrate and transfer information extracted from images produced by smartphone cameras, with the aim of supporting the search\u00a0\u2026", "num_citations": "8\n", "authors": ["263"]}
{"title": "Using Vampire in Soundness Proofs of Type Systems.\n", "abstract": " Type systems for programming languages shall detect type errors in programs before runtime. To ensure that a type system meets this requirement, its soundness must be formally verified. We aim at automating soundness proofs of type systems to facilitate the development of sound type systems for domain-specific languages. Soundness proofs for type systems typically require induction. However, many of the proofs of individual induction cases only require first-order reasoning. For the development of our workbench Veritas, we build on this observation by combining automated first-order theorem provers such as Vampire with automated proof strategies specific to type systems. In this paper, we describe how we encode type soundness proofs in first-order logic using TPTP. We show how we use Vampire to prove the soundness of type systems for the simply-typed lambda calculus and for parts of a typed SQL. We report on which parts of the proofs are handled well by Vampire, and what parts work less well with our current approach.", "num_citations": "8\n", "authors": ["263"]}
{"title": "Model-driven engineering of machine executable code\n", "abstract": " Implementing static analyses of machine-level executable code is labor intensive and complex. We show how to leverage model-driven engineering to facilitate the design and implementation of programs doing static analyses. Further, we report on important lessons learned on the benefits and drawbacks while using the following technologies: using the Scala programming language as target of code generation, using XML-Schema to express a metamodel, and using XSLT to implement (a) transformations and (b) a lint like tool. Finally, we report on the use of Prolog for writing model transformations.", "num_citations": "8\n", "authors": ["263"]}
{"title": "Aspects and class-based security: a survey of interactions between advice weaving and the java 2 security model\n", "abstract": " Various aspect-oriented languages, eg, AspectJ, Aspect-Werkz, and JAsCo, have been proposed as extensions to one particular object-oriented base language, namely Java. But these extensions do not fully take the interactions with the Java 2 security model into account. In particular, the implementation technique of advice weaving gives rise to two security issues: the erroneous assignment of aspects to protection domains and the violation of namespace separation. Therefore, a comprehensive discussion of the design choices available with respect to interactions with the dynamic class loading facilities of the Java VM is provided.", "num_citations": "8\n", "authors": ["263"]}
{"title": "Clustering for generating framework top-level views\n", "abstract": " To use a framework, developers need to understand its building blocks. In this paper, we present a clustering technique that employs usage data from framework instantiations as examples to produce an overview of a framework's main building blocks as seen from a user's perspective. The evaluation of the approach by two case studies shows that the automatically generated building blocks are similar to a manually defined overview created by framework experts, even in cases where only few framework instantiations are available.", "num_citations": "8\n", "authors": ["263"]}
{"title": "Flexible abstraction techniques for graph-based visualizations\n", "abstract": " Graph-based visualizations have the potential to help in analyzing the complex structure of software systems. However, they do not scale for large software projects. Flexible higher-level abstractions addressing this scalability problem are required. Moreover, the provided abstraction techniques should be expressive enough to bridge the gap between the abstractions in user\u2019s questions about the system and abstractions in the visualization of the system. In this paper we present ISPACE, a software visualization tool with simple but flexible abstraction strategies that address these problems.", "num_citations": "8\n", "authors": ["263"]}
{"title": "DTN-RPC: Remote procedure calls for disruption-tolerant networking\n", "abstract": " Remote Procedure Calls (RPCs) realize client-server interactions via a request-response message-passing protocol. They simplify distributed application programming by eliminating the need for explicitly having to code the details of a remote interaction. However, none of the existing RPC implementations are designed to work properly for Delay/Disruption-Tolerant Networking (DTN) where network connectivity is periodic, intermittent, and prone to disruptions. In this paper, we present DTN- RPC, a new approach to provide RPCs for DTN environments. DTN-RPC relies on (a) control and data channels to cope with potentially short contact durations in DTN where large amounts of data cannot be transmitted, (b) explicit and implicit modes to address remote servers, (c) Non-DTN and DTN transport protocols for issuing calls and receiving results, and (d) predicates that servers check to decide whether a procedure\u00a0\u2026", "num_citations": "7\n", "authors": ["263"]}
{"title": "Getting to know you: Towards a capability model for java\n", "abstract": " Developing software from reusable libraries lets developers face a security dilemma: Either be efficient and reuse libraries as they are or inspect them, know about their resource usage, but possibly miss deadlines as reviews are a time consuming process. In this paper, we propose a novel capability inference mechanism for libraries written in Java. It uses a coarse-grained capability model for system resources that can be presented to developers. We found that the capability inference agrees by 86.81% on expectations towards capabilities that can be derived from project documentation. Moreover, our approach can find capabilities that cannot be discovered using project documentation. It is thus a helpful tool for developers mitigating the aforementioned dilemma.", "num_citations": "7\n", "authors": ["263"]}
{"title": "Object creation aspects with flexible aspect deployment\n", "abstract": " A great deal of the power of aspect-oriented languages is due to the new and sophisticated notions of software composition they provide. The question how a specific aspect is deployed, ie, how a language supports the programmer in expressing under which conditions and within which scope of the base program the aspect definitons are made effective, is an important design decision. We call this design decision the deployment strategy. In this paper, we discuss the space of possible deployment strategies and present Minos, an aspect-oriented language for object creation that incorporates a more flexible deployment strategy than previous approaches. The usefulness of Minos is demonstrated by three case studies: Context-sensitive and dynamic application of optimization aspects based on runtime conditions, the distributed execution of \u201clegacy\u201d code, and the implementation of the Minos compiler itself as a non-invasive extension aspect of the Java compiler javac.", "num_citations": "7\n", "authors": ["263"]}
{"title": "Visibility as central abstraction in event-based systems\n", "abstract": " We introduce scopes as basic abstraction in event-based systems. While existing work disregarded the role of an administrator and simply focused on using pub and sub primitives in flat design spaces, we devise on top of the visibility concept abstractions that support bundling and composing of new components, refining delivery semantics in these bundles, and mappings in heterogeneous systems.", "num_citations": "7\n", "authors": ["263"]}
{"title": "Dynamic view connectors for separating concerns in software engineering environments\n", "abstract": " ABSTRACT Software Engineering Environments (SEE) are complex systems, for which configurability is an important requirement. Constructing SEEs out of existing tools is evidently desirable. During such a composition mismatches in the data models of different tools need to be dealt with. The brute force technique by hacking data translators into the implementation of individual tools has severe drawbacks regarding modularity, maintainability and extensibility of the composed system. We propose a novel technique for designing SEEs that uses explicit language constructs for bridging the mismatches in the data models, called dynamic view connectors (DVCs for short). We show how the separation of tool functionality from the concerns of bridging data model mismatches imposed by DVCs improved the configurability and maintainability of an existing SEE.", "num_citations": "7\n", "authors": ["263"]}
{"title": "Supporting evolving objects without giving up classes\n", "abstract": " There are two main models of inheritance employed in object-oriented systems: class-based and object-based inheritance. Although classbased inheritance is bene cial for providing abstractions to encapsulate, classify and structure objects, it is too rigid to deal with the dynamic and unanticipated incremental modi cations required in application domains where the functionality of objects is supposed to evolve. In contrast, object-based inheritance is particularly suitable in situations where the dynamic evolution of objects is desired, but this is achieved at the expense of an object model which does not maintain the encapsulation property. In this paper, we propose a new approach for supporting evolving objects while preserving the advantages of the class-based model. The approach is based on maintaining the object-class separation of the class-based model and on introducing an additional abstraction level between objects and their class. The new abstraction relaxes the static object-class connection, changes the way behavior de nition entities are related to each other, and enables the coexistence of di erent collision resolution strategies within a single environment.", "num_citations": "7\n", "authors": ["263"]}
{"title": "On the extensibility requirements of business applications\n", "abstract": " Business applications play a crucial role for the day-to-day running of a business. These applications typically support a wide range of standard business processes like opportunity-to-order and order-to-cash. Customers using these solutions often demand extensions that will complement the existing functionalities offered by the standard application. The requirements for extensibility can be different for each customer which makes the enablement of business software for extensibility very challenging. In this paper we demonstrate some of these challenges and requirements through an example application and evaluate them against some state-of-the-art works on extensibility.", "num_citations": "6\n", "authors": ["263"]}
{"title": "Headroom-based pretenuring: dynamically pretenuring objects that live\" long enough\"\n", "abstract": " Many modern garbage collectors are generational, operating under the assumption that\" most objects die young.\" Such collectors allocate all objects in a frequently collected nursery and tenure only surviving objects to a less-frequently collected, older generation. But these survivors induce copying costs upon tenuring. To avoid these costs, pretenuring schemes construct classifiers to predict whether an object will be long-lived or short-lived; accordingly, it is tenured or not immediately upon allocation. Up to now, however, these predictions did not account for one important fact: the proximity of the next collection. In contrast, headroom-based pretenuring does take this into account; thus, it can dynamically pretenure objects whenever they live\" long enough.\"", "num_citations": "6\n", "authors": ["263"]}
{"title": "Supporting variability with late semantic adaptations of domain-specific modeling languages\n", "abstract": " Meta-object protocols are used to open up the implementations of object-oriented general-purpose languages to support semantic variability. They enable performing application level semantic adaptations to the language even at runtime. However, such meta-object protocols are not available for domain specific-modeling languages. Also, existing approaches to implementing domain-specific modeling languages do not support semantic adaptations, where the application basically redefines specific parts of the language semantics. We propose a new approach for the implementation of domain-specific modeling languages that uses meta-objects and meta-object protocols to open up the implementation of domain-specific abstractions. This approach enables runtime semantic variability of the form of application-specific late semantic adaptations of domain-specific model-ing languages that depend on the runtime application context .", "num_citations": "6\n", "authors": ["263"]}
{"title": "Untangling crosscutting concerns in domain-specific languages with domain-specific join points\n", "abstract": " Like programs written in general-purpose languages, programs written in DSLs may also suffer from tangling and scattering in the presence of domain-specific crosscutting concerns. This paper presents an architecture that supports aspect-oriented features for domain-specific base languages. Both base programs and advices are written in different domain-specific languages. The framework relies on the concept of domain-specific join point.", "num_citations": "6\n", "authors": ["263"]}
{"title": "Aspect-based enforcement of formal delegation policies\n", "abstract": " Delegation is a powerful concept in access control systems, which allows users to assign all or part of their permissions to other users. Several types of delegation models for role-based access control have been proposed so far. However, most existing works focus on the specification of delegation policies and there is very little work on the monitoring and enforcement of such policies at runtime. In this paper, we use a security approach combining formal methods and aspect-oriented programming for specifying and enforcing delegation policies. In our approach, delegation models and their characteristics are specified formally using TemporalZ, which is a combination of Z notation and temporal logic. Then, we verify the formal specification to ensure consistency using theorem proving. Finally, we generate automatically a set of aspects in the aspect-oriented language ALPHA from the TemporalZ specifications\u00a0\u2026", "num_citations": "6\n", "authors": ["263"]}
{"title": "On the Management Requirements of Web Service Compositions\n", "abstract": " Several works have addressed the management of individual Web Services. However, the specific management requirements of workflow-based web service compositions such as those specified in the WS-BPEL have not yet been considered. In this paper, we present several management requirements in web service compositions such as discovery and selection management, SLA and policy management, middleware services management, and management of the composite service. Supporting these requirements is crucial for providing a reliable service composition with well-defined QoS properties. We also introduce web service composition management and present our vision of having dedicated tool support for it in future WS-BPEL engines.", "num_citations": "6\n", "authors": ["263"]}
{"title": "Towards variational object-oriented programming: The rondo model\n", "abstract": " This paper presents a proposal to improve the standard object-oriented programming model with respect to supporting a larger range of incremental behavior variations. It will be demonstrated that classes and inheritance perfectly support the incremental modeling of di erent variants of a base abstract data type, but they do not properly model what we call context-dependent variations. These behavior variations are due to other factors including the internal state of an object in a computational system, di erent perspectives of how the object can be viewed by other participants of the same system, di erent usage patterns of the system, and di erent characteristics of the environment in which the system is operating. To deal with such context-dependent behavior variations, the Rondo model is proposed. It goes beyond classes and inheritance to support the separation of the description of a base behavior and its context-dependent variations in the same way that classes and inheritance support the separate description of a base behavior and its kind-of related variations. This separation results in improving the reusability and extensibility of software.", "num_citations": "6\n", "authors": ["263"]}
{"title": "Building modular object-oriented systems with reusable collaborations\n", "abstract": " The growing importance of mobile networks has stimulated active research into how multimedia information can be distributed over a slow and reliable network. In this paper, we propose a multi-channel approach for transmitting video frames over a GSM network. A number of strategies are proposed for channel allocation so that sufficient bandwidth can be provided to satisfy the timing requirements of the video frames. Their performance evaluated using simulation.", "num_citations": "6\n", "authors": ["263"]}
{"title": "Modeling behavior with personalities\n", "abstract": " Decoupling behavior modeling from a specific inheritance hierarchy has become one of the challenges for object-oriented software engineering. The goal is to encapsulate behavior on its own, and yet be able to freely apply it to a given class structure. We claim that standard object-oriented languages do not directly address this problem and propose the concept of Personalities as a design and programming artifice to model stand alone behavior that embodies what we have termed microframework style of programming. Allowing behavior to stand alone enables its reuse in different places in an inheritance hierarchy. Dynamic personalities, a variation to the basic ideas that helps, among other things, with the object migration problem, is also discussed. We present a potential Personalities implementation by extending the Java programming language.", "num_citations": "6\n", "authors": ["263"]}
{"title": "Dynamic metaclass construction for an explicit specialization interface\n", "abstract": " The de nition of a class library is an iterative process involving both the designer who provides basic functionality, and the users who subsequently specialize it. In order to ensure the coherence of possible modi cations, suitable means for coordinating the activity of both are required. In this paper, we propose a metaclass based approach for bridging the gap between library designers and specializers, by enabling the designer to express specialization constraints which are automatically imposed on all possible modi cations. The approach adopted for the design of the meta-level provides for modularity and extensibility. It is based on a dispersed meta-representation of how classes behave and an automatic metaclass construction by deriving procedural code from a set of metadescriptions chosen according to the constraints to be satis ed.", "num_citations": "6\n", "authors": ["263"]}
{"title": "A programming model for semi-implicit parallelization of static analyses\n", "abstract": " Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal-yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized\u00a0\u2026", "num_citations": "5\n", "authors": ["263"]}
{"title": "How to avoid making a billion-dollar mistake: Type-safe data plane programming with SafeP4\n", "abstract": " The P4 programming language offers high-level, declarative abstractions that bring the flexibility of software to the domain of networking. Unfortunately, the main abstraction used to represent packet data in P4, namely header types, lacks basic safety guarantees. Over the last few years, experience with an increasing number of programs has shown the risks of the unsafe approach, which often leads to subtle software bugs. This paper proposes SafeP4, a domain-specific language for programmable data planes in which all packet data is guaranteed to have a well-defined meaning and satisfy essential safety guarantees. We equip SafeP4 with a formal semantics and a static type system that statically guarantees header validity---a common source of safety bugs according to our analysis of real-world P4 programs. Statically ensuring header validity is challenging because the set of valid headers can be modified at runtime, making it a dynamic program property. Our type system achieves static safety by using a form of path-sensitive reasoning that tracks dynamic information from conditional statements, routing tables, and the control plane. Our evaluation shows that SafeP4's type system can effectively eliminate common failures in many real-world programs.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Lattice based modularization of static analyses\n", "abstract": " Static analyses which compute conceptually independent information, eg, class immutability or method purity are typically developed as standalone, closed analyses. Complementary information that could improve the analyses is either ignored by making a sound over-approximation or it is also computed by the analyses, but at a rudimentary level. For example, an immutability analysis requires field mutability information, alias/escape information, and information about the concurrent behavior of methods to correctly classify classes like java. lang. String or java. util. BigDecimal. As a result, without properly supporting the integration of independently developed, mutually benefiting analysis, many analyses will not correctly classify relevant entities.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Reactive programming experience with rescala\n", "abstract": " Reactive programming is a recent programming paradigm that specifically targets reactive applications. Over the years, a number of reactive languages have been proposed, with different combinations of features, and various target domains.", "num_citations": "5\n", "authors": ["263"]}
{"title": "SecureScala: Scala embedding of secure computations\n", "abstract": " Cloud computing offers an attractive and cost-efficient computing platform and hence it has been widely adopted by the industry and the government. At the same time, cloud computing poses a serious security challenge because sensitive data must often be outsourced to third party entities that can access the data and perform computations on them. Partial homomorphic encryption is promising for secure computation, since it allows programs to be executed over encrypted data. Despite advances in cryptographic techniques have improved the expressivity of such programs, integration with mainstream languages has seen little progress. To this end, we present SecureScala, a domain-specific language in Scala that allows expressing secure programs without requiring any cryptographic knowledge. SecureScala is based on a novel combination of free monads and free applicative functors and supports parallel\u00a0\u2026", "num_citations": "5\n", "authors": ["263"]}
{"title": "Automating Proof Steps of Progress Proofs: Comparing Vampire and Dafny.\n", "abstract": " Developing provably sound type systems is a non-trivial task which, as of today, typically requires expert skills in formal methods and a considerable amount of time. Our Veritas [4] project aims at providing support for the development of soundness proofs of type systems and efficient type checker implementations from specifications of type systems. To this end, we investigate how to best automate typical steps within type soundness proofs. In this paper, we focus on progress proofs for type systems of domain-specific languages. As a running example for such a type system, we model a subset SQL and augment it with a type system. We compare two different approaches for automating proof steps of the progress proofs for this type system against each other: firstly, our own tool Veritas, which translates proof goals and specifications automatically to TPTP [14] and calls Vampire [9] on them, and secondly, the programming language Dafny [7], which translates proof goals and specifications to the intermediate verification language Boogie 2 [6] and calls the SMT solver Z3 [10] on them. We find that Vampire and Dafny are equally well-suited for automatically proving simple steps within progress proofs.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Incremental confined types analysis\n", "abstract": " Research related to alias protection and related concepts, such as, confined types and ownership types has a long tradition and is a promising concept for the design and implementation of more reliable and secure software. Unfortunately, the use of these concepts is not widespread as most implementations are proofs of concept and fall short with respect to the integration with standard software development tools and processes.In this paper, we discuss an implementation of confined types based on Java 5 annotations. The contribution of this paper is twofold: First, we discuss the incrementalization of the confined types analysis and second, we present the integration of the analysis into Eclipse using the static analysis platform Magellan.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Integrating and scheduling an open set of static analyses\n", "abstract": " To improve the productivity of the development process, more and more tools for static software analysis are tightly integrated into the incremental build process of an IDE. If multiple interdependent analyses are used simultaneously, the coordination between the analyses becomes a major obstacle to keep the set of analyses open. We propose an approach to integrating and scheduling an open set of static analyses which decouples the individual analyses and coordinates the analysis executions such that the overall time and space consumption is minimized. The approach has been implemented for the Eclipse IDE and has been used to integrate a wide range of analyses such as finding bug patterns, detecting violations of design guidelines, or type system extensions for Java", "num_citations": "5\n", "authors": ["263"]}
{"title": "Search Browser: An efficient index based search feature for the Eclipse IDE\n", "abstract": " Searching in source code is an integral part of many software engineering activities and is also used in the back-end of many IDE tools. Unfortunately, current search tools lack performance for large-scale software projects. We present an approach that uses information retrieval techniques to make searching scalable, and a tool called SearchBrowser that implements this approach. The performance comparison against Eclipse\u2019s search feature shows that critical search times can be mitigated using our tool.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Connectors for bridging mismatches between the components of a software engineering environment\n", "abstract": " Software engineering environments (SEEs) are complex systems, for which configurability is an important requirement. Constructing SEEs out of existing tools is evidently desirable. During such a composition, mismatches between the data models of different tools will arise. The brute-force technique of hacking data translators into the implementation of individual tools has severe drawbacks regarding the modularity, maintainability and extensibility of the composed system. This paper proposes a novel technique for designing SEEs that uses explicit language constructs for bridging the mismatches in the data models, called dynamic view connectors. It shows how the separation of tool functionality from the concerns of bridging data-model mismatches improves the configurability and maintainability of an existing SEE.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Dynamic object modification without name collisions\n", "abstract": " Support for modular evolution of objects is required in many application areas. However, existing mechanisms for incremental behavior composition either do not support evolving objects at all, or do not satisfactorily solve the encapsulation and name collision problems associated with them. In this paper, a new approach to behavior composition in a class-based environment is presented. It is based on the encapsulated object model of class-based inheritance, but introduces an additional abstraction layer between objects and classes. By being responsible for the compositional aspects of the behavior of objects, this layer provides support for the evolution of behavior while at the same time solving the name conflicts that may occur. A formal description of the approach is provided and its feasibility is demonstrated by implementing it as a metalevel extension of Smalltalk-80.", "num_citations": "5\n", "authors": ["263"]}
{"title": "Modular collaborative program analysis in OPAL\n", "abstract": " Current approaches combining multiple static analyses deriving different, independent properties focus either on modularity or performance. Whereas declarative approaches facilitate modularity and automated, analysis-independent optimizations, imperative approaches foster manual, analysis-specific optimizations.", "num_citations": "4\n", "authors": ["263"]}
{"title": "A dataset of parametric cryptographic misuses\n", "abstract": " Cryptographic APIs (Crypto APIs) provide the foundations for the development of secure applications. Unfortunately, most applications do not use Crypto APIs securely and end up being insecure, e.g., by the usage of an outdated algorithm, a constant initialization vector, or an inappropriate hashing algorithm. Two different studies [1], [2] have recently shown that 88% to 95% of those applications using Crypto APIs are insecure due to misuses. To facilitate further research on these kinds of misuses, we created a collection of 201 misuses found in real-world applications along with a classification of those misuses. In the provided dataset, each misuse consists of the corresponding open-source project, the project's build information, a description of the misuse, and the misuse's location. Further, we integrated our dataset into MUBench [3], a benchmark for API misuse detection. Our dataset provides a foundation for\u00a0\u2026", "num_citations": "4\n", "authors": ["263"]}
{"title": "Incremental overload resolution in object-oriented programming languages\n", "abstract": " Object-oriented programming languages feature static and dynamic overloading: Multiple methods share the same name but provide different implementations. Dynamic overloading (also know as dynamic dispatch) is resolved at run time based on the type of the receiver object. In this paper, we focus on static overloading in Featherweight Java, which is resolved at compile time based on the types of the method arguments.", "num_citations": "4\n", "authors": ["263"]}
{"title": "Towards virtual traits in Scala\n", "abstract": " Scala is a powerful language that supports a variety of features, but it lacks virtual traits. Virtual traits are class-valued object attributes and can be redefined within subtraits. They support higher-order hierarchies and family polymorphism. This work introduces virtual traits into Scala and explains how to encode virtual traits on top of existing Scala features. We have implemented this encoding using Scala annotation macros and have conducted two small case studies.", "num_citations": "4\n", "authors": ["263"]}
{"title": "Understanding multilayered applications for building extensions\n", "abstract": " Modern software applications typically consist of several logical layers (for example user interface, databases, business process, code, etc.). Software is usually delivered by a software provider to support a certain application domain through a set of predefined functionalities. A user acquiring the software can obtain extra functionalities through extensions. Extensions can be developed by the software provider, by the customer, or a third-party and then integrated with the core software. In order to enable core software for accommodating extensions, software providers must give the right means for enabling developers to build extensions. Based on the new functionalities required, developers building extensions usually consider different layers of the core software when developing extensions. For example, a simple user interface extension in a business application would need a developer to consider extensible\u00a0\u2026", "num_citations": "4\n", "authors": ["263"]}
{"title": "Declarative events for object-oriented programming\n", "abstract": " In object-oriented designs inversion of control is achieved by an event-driven programming style based on imperatively triggered events. An alternative approach can be found in aspect-oriented programming, which defines events as declarative queries over implicitly available events. This helps to localize definition of events and avoid preplanning, but lacks a clean integration with object-oriented features and principles. The contribution of this work is a concept of object-oriented events that combines imperative, declarative and implicit events and provides their seamless integration with object-oriented features, preserving encapsulation and modular reasoning. We present an efficient and type-safe implementation of the concept as an extension to the Scala language.", "num_citations": "4\n", "authors": ["263"]}
{"title": "A holistic approach for access control policies: from formal specification to aspect-based enforcement\n", "abstract": " We present in this paper a novel approach to non-functional safety properties, combining formal methods and Aspect-Oriented Programming (AOP). The approach supports both the formal specification and the enforcement of such properties through runtime monitoring. We apply our approach for security policies and especially Role-Based Access Control (RBAC) policies including application-specific constraints such as separation of duties and delegation. For formal specification, we introduce TemporalZ, a formal language based on Z and temporal logic, which provides domain specific predicates for expressing RBAC policies. For the enforcement, we generate automatically modular enforcement code out of the formal specification using the aspect-oriented language ALPHA.", "num_citations": "4\n", "authors": ["263"]}
{"title": "Blurring the borders between object composition, inheritance, and delegation\n", "abstract": " Object-oriented languages come with pre-defined composition mechanisms, such as inheritance, object composition, or delegation, each characterized by a certain set of composition properties, which do not themselves individually exist as abstractions at the language level. However, often non-standard composition semantics is needed, with a mixture of composition properties, which is not provided as such by any of the standard composition mechanisms. Such non-standard semantics are simulated by complicated architectures that are sensitive to requirement changes and cannot easily be adapted without invalidating existing clients. This paper is an appetizer3 for compound references and Latte Macchiato4, a Java implementation of compound references. Compound references are a new abstraction for object references, that allows us to provide explicit linguistic means for expressing and combining individual composition properties on-demand. The model is statically typed and allows the programmer to express a seamless spectrum of composition semantics in the interval between object composition and inheritance.", "num_citations": "4\n", "authors": ["263"]}
{"title": "Towards exploring cross-cutting concerns\n", "abstract": " Aspect-oriented re-engineering of legacy systems means to discover all parts of code that are involved in the implementation of cross-cutting concerns so that they can be refactored into aspects. Currently, some tools exist that support the process of identifying initial elements of code most likely to be involved in the implementation of a crosscutting concern (seeds), which serve as starting points for discovering all elements of the concern at hand. However, this expansion from initial seeds to complete concerns requires searching and browsing the source code manually, which can be very time-consuming and error-prone. In this paper, we propose the use of software exploration tools to support this task. Our solution complements other aspect mining tools in that it creates a complete representation of a concern, which can be used as a base for aspect-oriented refactoring and for program understanding.", "num_citations": "4\n", "authors": ["263"]}
{"title": "On the need for a unified MDSOC model: Experiences from constructing a modular software engineering environment\n", "abstract": " this paper, we make a modest e# ort to fill this gap by reporting our experience with applying the principle of MDSOC to a real software engineering environment (SEE). SEEs are integrated environments consisting of a collection of software engineering tools that work together, freeing the user from the need of manual coordination [28]. Hence, although our case--study is an SEE, the results of the work presented here apply to Position paper for the OOPSLA 2000 workshop on Advanced Separation", "num_citations": "4\n", "authors": ["263"]}
{"title": "Incremental redefinition of open implementations\n", "abstract": " In this paper, an architecture for modular and incremental construction of open implementations is proposed. It is based on the automatic generation of metaprotocols by dynamically combining partial metadescriptions selected with respect to the speci cs of the environment an open implementation is operating in. The combination is realized by means of a new technique for behavioral combination, the ClassCombiner, which supports a dynamically evolving object model. Metaprograms are employed for incrementally extending the metarepresentation and for introducing client requirements into the system.", "num_citations": "4\n", "authors": ["263"]}
{"title": "ReactiFi: Reactive Programming of Wi-Fi Firmware on Mobile Devices.\n", "abstract": " Network programmability will be required to handle future increased network traffic and constantly changing application needs. However, there is currently no way of using a high-level, easy to use programming language to program Wi-Fi firmware. This impedes rapid prototyping and deployment of novel network services/applications and hinders continuous performance optimization in Wi-Fi networks, since expert knowledge is required for both the used hardware platforms and the Wi-Fi domain. In this paper, we present ReactiFi, a high-level reactive programming language to program Wi-Fi chips on mobile consumer devices. ReactiFi enables programmers to implement extensions of PHY, MAC, and IP layer mechanisms without requiring expert knowledge of Wi-Fi chips, allowing for novel applications and network protocols. ReactiFi programs are executed directly on the Wi-Fi chip, improving performance and power consumption compared to execution on the main CPU. ReactiFi is conceptually similar to functional reactive languages, but is dedicated to the domain-specific needs of Wi-Fi firmware. First, it handles low-level platform-specific details without interfering with the core functionality of Wi-Fi chips. Second, it supports static reasoning about memory usage of applications, which is important for typically memory-constrained Wi-Fi chips. Third, it limits dynamic changes of dependencies between computations to dynamic branching, in order to enable static reasoning about the order of computations. We evaluate ReactiFi empirically in two real-world case studies. Our results show that throughput, latency, and power consumption are\u00a0\u2026", "num_citations": "3\n", "authors": ["263"]}
{"title": "LoRAgent: A DTN-based Location-aware Communication System using LoRa\n", "abstract": " Modern information and communication technology (ICT) is often very vulnerable to disruptions through disasters. Yet, the ability to communicate and distribute messages is vital for efficient disaster response. Furthermore, ad hoc deployment of flexible, robust, and affordable communication systems in a disaster area are often necessary. Therefore, we propose a disruption-tolerant networking bundle agent that uses LoRa radio technology to provide decentralized basic means of communication. To address the hardware\u2019s technological limitations as well as the uncertainty of the user locations and their movement behavior, we propose a geospatial routing mechanism for efficient message forwarding. In conjunction with the communication and routing solutions presented, we also designed specific pager-like hardware for intuitive message reception and bridging of smartphones into LoRa networks. We evaluated\u00a0\u2026", "num_citations": "3\n", "authors": ["263"]}
{"title": "Smart street lights and mobile citizen apps for resilient communication in a digital city\n", "abstract": " While information and communication technology is crucial for the operation of urban infrastructures and the wellbeing of its inhabitants, current technology is quite vulnerable to disruptions of various kinds. In future smart cities, a more resilient urban infrastructure is imperative to handle the increasing number of hazardous situations. We present a novel resilient communication approach based on smart street lights as part of the public infrastructure. It supports people in their everyday life and adapts its functionality to the challenges of emergency situations. Our approach relies on various environmental sensors and in-situ processing for automatic situation assessment, and a range of communication mechanisms for maintaining a communication network. Furthermore, resilience is not only achieved based on infrastructure deployed by a digital city's municipality, but also based on integrating citizens through\u00a0\u2026", "num_citations": "3\n", "authors": ["263"]}
{"title": "From Debugging Towards Live Tuning of Reactive Applications\n", "abstract": " Directly visualizing the effect of changes to applications improves developers productivity as they gain immediate insights on the resulting application behavior. Yet, immediate feedback requires a representation of the dataflow in the application to correctly propagate and apply the effect of the changes. Reactive programming is a programming paradigm which directly expresses applications dataflow in a declarative way. Recently, researchers developed dedicated debugging techniques for reactive programming that use the dataflow graph to enable inspections and visualization.In this paper, we adopt reactive debugging as a basis for live modifications and tuning of reactive applications. To this end we extend the debugger to allow live modifications to the dataflow graph in a structured manner to change the application behavior. We also suggest how developers of reactive applications can use such extension to enable flexible tuning of applications at run time. Our early experience shows that the combination of reactive programming and live programming allows modifications and tuning of applications while ensuring safety and consistency guarantees.", "num_citations": "3\n", "authors": ["263"]}
{"title": "Cooperative decoupled processes: the e-calculus and linearity\n", "abstract": " Event-driven programming has become a major paradigm in developing concurrent, distributed systems. Its benefits are often informally captured by the key tenet of \u201cdecoupling\u201d, a notion which roughly captures the ability of modules to join and leave (or fail) applications dynamically, and to be developed by independent parties. Programming models for event-driven programming either make it hard to reason about global control flow, thus hampering sound execution, or sacrifice decoupling to aid in reasoning about control flow. This work fills the gap by introducing a programming model\u2013dubbed cooperative decoupled processes\u2013that achieves both decoupling and reasoning about global control flow. We introduce this programming model through an event calculus, loosely inspired by the Join calculus, that enables reasoning about cooperative decoupled processes through the concepts of pre-and\u00a0\u2026", "num_citations": "3\n", "authors": ["263"]}
{"title": "Template constructors for reusable object initialization\n", "abstract": " Reuse of and abstraction over object initialization logic is not properly supported in mainstream object-oriented languages. This may result in significant amount of boilerplate code and proliferation of constructors in subclasses. It also makes it impossible for mixins to extend the initialization interface of classes they are applied to. We propose template constructors, which employ template parameters and pattern matching of them against signatures of superclass constructors to enable a one-to-many binding of super-calls. We demonstrate how template constructors solve the aforementioned problems. We present a formalization of the concept, a Java-based implementation, and use cases which exercise its strengths.", "num_citations": "3\n", "authors": ["263"]}
{"title": "A survey on non\u2010functional concerns in web services\n", "abstract": " Purpose \u2013 More and more organizations make parts of their information systems available to their business partners and often face integration and interoperability issues. To counter these problems, web services appeared as a promising technology to bridge the gap between organizations and their partners. While web services generally focus on the implementation of functional concerns (FC) such as ordering of goods, the reservation of flights, etc. also non\u2010functional concerns (NFC) such as security, reliable messaging, performance, and availability have to be addressed appropriately. The purpose of this paper is to identify web services' requirements.Design/methodology/approach \u2013 In this paper the authors provide a survey on works in the area of NFCs in web services. After presenting a common terminology, the most important requirements in that context are presented. Further, the authors assess these\u00a0\u2026", "num_citations": "3\n", "authors": ["263"]}
{"title": "Product line implementation with ECaesarJ\n", "abstract": " This chapter takes a closer look at the difficulties of feature-oriented modularisation of product lines and demonstrate how a better modularisation can be achieved with the ECaesarJ programming language, through a type-safe and stable decomposition of a broad spectrum of software abstractions: classes, methods, events, and state machines, based on late binding and mixin composition.", "num_citations": "3\n", "authors": ["263"]}
{"title": "Vm performance evaluation with functional models: an optimist's outlook\n", "abstract": " The performance evaluation of virtual machines is notoriously difficult. Therefore, experimental methodology has recently drawn attention, leading to proposals on how to choose benchmarks, interpret results, and detect measurement bias. But this latter task currently relies on the presence of anomalous measurement results, ie, on outliers, to raise suspicion. We therefore propose the use of functional performance models to detect bias even when benchmark results might appear unsuspicious. Failure to validate the model indicates either bias or a need to refine the model.", "num_citations": "3\n", "authors": ["263"]}
{"title": "Improving code recommender systems using Boolean factor analysis and graphical models\n", "abstract": " The demands of modern software engineering to develop highquality software in the least possible amount of time has become a crucial challenge in software engineering-and reuse of code has become an effective method to satisfy these demands. One approach to code reuse are application frameworks which provide a generic infrastructure that can be reused and customized by developers to build new applications with less efforts. However, before using a framework efficiently a developer has to learn the underlying framework concepts and (framework) documentation becomes a vital source of information. Unfortunately, the available documentation frequently does not provide all required information and other resources like mailing lists, code snippets or source code of already existing (and working) framework instantiations are used to learn possible usages of the framework [2]. Motivated by manual code reading techniques several research tools have been developed each aiming to support novice developers on different framework understanding problems.Closely related to our proposal are code recommender systems like FrUiT [3], CodeWeb [5], and Mapo [6]. These tools examine code of existing framework instantiations to find framework elements that co-occur frequently together in code. From these observations FrUiT and CodeWeb derive API usage rules like \u201cIn 95% of the cases where you extend class Wizard, you also override its method Wizard. addPage.\u201d or \u201cIn 80% of the cases you called Button.< init> 1, you also call Button. setText\u201d. Mapo instead uses the information about frequently co-occurring method calls to infer typical\u00a0\u2026", "num_citations": "3\n", "authors": ["263"]}
{"title": "Detecting evolution incompatibilities by analyzing java binaries\n", "abstract": " Customizing component functionality to application needs generally involves inheritance, known to suffer from the fragile base class problem: changes in a base class may cause preexisting inheritor classes to malfunction, or even become undefined. We present a framework for binary detection of such incompatible changes at component (re)integration time. This avoids unexpected erroneous runtime behavior of the integrated components.", "num_citations": "3\n", "authors": ["263"]}
{"title": "GRASS: generic reactive application-specific scheduling\n", "abstract": " High resource utilization is important to operate compute infrastructures and data centers efficiently. High utilization is achieved by multiplexing several applications over the same physical infrastructure. Yet, with this approach, the different requirements of each application have to be taken into account when scheduling resources. We propose GRASS, a reactive domain-specific abstraction that allows specifying application-tailored resource scheduling policies. We demonstrate how the declarative approach of GRASS enables extension and composition of scheduling policies. Our evaluation shows the performance benefits of considering application-specific information in a composition of scheduling policies that adapt at run time.", "num_citations": "2\n", "authors": ["263"]}
{"title": "Building extensions for applications: Towards the understanding of extension possibilities\n", "abstract": " Software extensions enable developers to introduce new features to a software system for supporting new requirements. In order for a developer to build an extension for a certain software system, the developer has to understand what extension possibilities exist, which software artifacts provide these possibilities, the constraints and dependencies between the extensible software artifacts, and how to correctly implement an extension. Building extensions for multilayered applications can be very challenging. For example, a simple user interface extension in a business application can require a developer to consider extensible artifacts from underlying user interfaces, business processes, databases, and code. In commercial applications, extension developers can depend on classical means like APIs, frameworks, documentation, tutorials, and example code provided by the software provider to understand the\u00a0\u2026", "num_citations": "2\n", "authors": ["263"]}
{"title": "Transactions on Aspect-Oriented Software Development VII: A Common Case Study for Aspect-Oriented Modeling\n", "abstract": " \u2013Those who want to learn about AOM? nd in this special issue a concise collection of descriptions of solid and mature AOM approaches. They only have to take the time to understand one case study in order to appreciate the sample models shown in all papers.\u2013Those who want to apply AOM for a particular purpose and are looking for the most appropriate AOM technique can use the papers presented in this specialissue to identify the mostpromisingapproach (es). By identifying similarities between their problem and the case study they should be able to determine candidate AOM approaches easily.\u2013Those working on their own AOM approach can readily identify approaches that were able to handle concerns that their own approach is not able to handle elegantly. This stimulates cross-fertilization between approaches and collaborative research.\u2013Thoseengineering researchersthat areworkingon enhancing softwaredev-opment processes can use the example models presented in this special issue to understand the potential bene? ts of using AOM techniques at di? erent phases of the software development life-cycle.", "num_citations": "2\n", "authors": ["263"]}
{"title": "Architektur f\u00fcr Ambient Intelligence\n", "abstract": " Architecture for Ambient Intelligence The architecture is the central element of a holistic and domain independent solution to Ambient Intelligence. The heterogeneity of the components, the dynamic reconfiguration of the systems, and historically grown solutions make it impossible to define a single, all-encompassing architecture. Instead, a framework is needed, in which the required functionality can be mapped to different technologies, and heterogeneous components and technologies can be composed in a controlled manner into specific architecture instances.", "num_citations": "2\n", "authors": ["263"]}
{"title": "A survey on interactive grouping and filtering in graph-based software visualizations\n", "abstract": " Interactive grouping and filtering in software visualization tools are essential mechanisms enabling the users to build views that match the information needs of their software comprehension task at hand. In this paper we systematically survey these mechanisms in eight graph-based software visualization tools.", "num_citations": "2\n", "authors": ["263"]}
{"title": "Middleware support for bpel workflows in the ao4bpel engine\n", "abstract": " This paper focuses on middleware concerns in BPEL workflows. When looking at those workflows from the implementation perspective, we observe that they have several BPEL-specific middleware requirements, which are not supported by current WS-* specifications and by most BPEL engines available to date. This demo paper will show the AO4BPEL Engine, which implements a container framework that allows the specification and enforcement of middleware requirements in BPEL processes. A deployment descriptor is used to specify the quality of service requirements of BPEL activities. A light-weight and aspectbased process container is used to enforce those requirements by calling dedicated middleware Web Services. We implemented those middleware Web Services by extending open source implementations of WS-* specifications for security, reliable messaging, and transactions.", "num_citations": "2\n", "authors": ["263"]}
{"title": "Automatic incrementalization of static analyses\n", "abstract": " Modern development environments integrate various static analyses into the build process. But, analyses that analyze the whole project whenever the project changes are impractical in this context. We present an approach to automatic incrementalization of analyses that are specified as tabled logic programs and evaluated using incremental tabled evaluation, a technique for efficiently updating memo tables in response to changes in facts and rules. The approach has been implemented and integrated into the Eclipse IDE. Our measurements show that this technique is effective for automatically incrementalizing a broad range of static analyses. 1", "num_citations": "2\n", "authors": ["263"]}
{"title": "eAssignment: a case for EMF\n", "abstract": " Developing Eclipse plug-ins often involves the creation of data structures and corresponding data processing code. In developing eAssignment, an Eclipse-bases application to support electronic programming exercises, we identified several issues with implicit models of data structures and hand-written code needed to access them. In this paper, we report on our experiences of using the Eclipse Modeling Framework to overcome these shortcomings.", "num_citations": "2\n", "authors": ["263"]}
{"title": "Building modular object-oriented systems with reusable collaborations (tutorial session)\n", "abstract": " New approaches propose to deal with the tangling of logical units by extending the object-oriented language to support module (de) composition along more than one dimension of concern. The tutorial will briefly survey Aspect-Oriented Programming (@@@@ ectJ tool), Adaptive Programming (the Demeter tool), and Hyper-dimensional Separation of Concerns (the Hyper/J tool). The primary focus of the tutorial, however, will be on A daptive Plug-and-Play Components (AP&PC)[2, 1].", "num_citations": "2\n", "authors": ["263"]}
{"title": "Modeling Civilian Mobility in Large-Scale Disasters\n", "abstract": " When disasters destroy critical communication infrastructure, smartphone-based Delay-Tolerant Networks (DTNs) can provide basic communication for civilians. Although field tests have shown the practicability of such systems, real-world experiments are expensive and hardly repeatable. Therefore, simulations are required for the design and extensive evaluation of novel DTN protocols, but meaningful assertions require realistic mobility models for civilians.This paper analyzes trace files from a large-scale disaster field test with respect to typical human behavioral patterns in a disaster area. Based on this, we derive a novel civilian disaster mobility model, encompassing identified behavior like group-based movement and clustering around points-of-interests like hospitals and shelters. We evaluate the impact of mobility on DTN communication performance by comparing our model against other established mobility models and against the trace file dataset in a simulative evaluation based on the field test scenario. In general, our mobility model results in a more realistic assessment of DTN communication performance in comparison to other mobility models.", "num_citations": "1\n", "authors": ["263"]}
{"title": "TACAI: an intermediate representation based on abstract interpretation\n", "abstract": " Most Java static analysis frameworks provide an intermediate presentation (IR) of Java Bytecode to facilitate the development of static analyses. While such IRs are often based on three-address code, the transformation itself is a great opportunity to apply optimizations to the transformed code, such as constant propagation.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Optimizing Data Plane Programs for the Network\n", "abstract": " With the move of Software-defined networking from fixed to programmable data planes, network functions are written with P4 or eBPF for targets such as programmable switches, CPU based flow processors [5] and commodity CPUs [7]. These data plane programs are, however, limited in per-packet time budget [3](eg, 67.2 ns at 10GbE) and program size, making program optimization imperative [6]. Existing approaches focus on optimizing the distribution of flow rules in fixed data planes [4] or they are limited to a single switch [2]. We see great potential in integrating the network topology into program optimization.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Type-safe, polyvariadic event correlation\n", "abstract": " The pivotal role that event correlation technology plays in todays applications has lead to the emergence of different families of event correlation approaches with a multitude of specialized correlation semantics, including computation models that support the composition and extension of different semantics. However, type-safe embeddings of extensible and composable event patterns into statically-typed general-purpose programming languages have not been systematically explored so far. Event correlation technology has often adopted well-known and intuitive notations from database queries, for which approaches to type-safe embedding do exist. However, we argue in the paper that these approaches, which are essentially descendants of the work on monadic comprehensions, are not well-suited for event correlations and, thus, cannot without further ado be reused/re-purposed for embedding event patterns. To close this gap we propose PolyJoin, a novel approach to type-safe embedding for fully polyvariadic event patterns with polymorphic correlation semantics. Our approach is based on a tagless final encoding with uncurried higher-order abstract syntax (HOAS) representation of event patterns with n variables, for arbitrary . Thus, our embedding is defined in terms of the host language without code generation and exploits the host language type system to model and type check the type system of the pattern language. Hence, by construction it impossible to define ill-typed patterns. We show that it is possible to have a purely library-level embedding of event patterns, in the familiar join query notation, which is not restricted to monads\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "Comprehensive Multiparty Session Types\n", "abstract": " Multiparty session types (MST) are a well-established type theory that describes the interactive structure of a fixed number of components from a global point of view and type-checks the components through projection of the global type onto the participants of the session. They guarantee communicationsafety for a language of multiparty sessions (LMS), i.e., distributed, parallel components can exchange values without deadlocking and unexpected message types. Several variants of MST and LMS have been proposed to study key features of distributed and parallel programming. We observe that the population of the considered variants follows from only one ancestor, i.e., the original LMS/MST, and there are overlapping traits between features of the considered variants and the original. These hamper evolution of session types and languages and their adoption in practice. This paper addresses the following question: What are the essential features for MST and LMS, and how can these be modelled with simple constructs? To the best of our knowledge, this is the first time this question has been addressed. We performed a systematic analysis of the features and the constructs in MST, LMS, and the considered variants to identify the essential features. The variants are among the most influential (according to Google Scholar) and well-established systems that cover a wide set of areas in distributed, parallel programming. We used classical techniques of formal models such as BNF, structural congruence, small step operational semantics and typing judgments to build our language and type system. Lastly, the coherence of operational semantics and type\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "System Description: An Infrastructure for Combining Domain Knowledge with Automated Theorem Provers\n", "abstract": " Computer science has seen much progress in the area of automated verification in the last decades. Yet, there are many domains where abstract strategies for verifying standard properties are well-understood by domain experts, but still not automated to a satisfactory degree. One example for such a domain are type soundness proofs. Being able to express domain-specific verification strategies using domain-specific terminology and concepts can help to narrow down this gap toward more automated verification.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Cooperative decoupled processes\n", "abstract": " Event-driven programming has become a major paradigm in developing concurrent, distributed systems. Its benefits are often informally captured by the key tenet of \u201cdecoupling,\u201d a notion which roughly captures the ability of processes to join and leave (or fail) applications dynamically, and to be developed by independent parties. Programming  models for event-driven programming either make it hard to globally reason about control flow, thus hampering sound execution, or sacrifice decoupling to aid in reasoning about control flow. This work fills the gap by introducing a programming model\u2014dubbed cooperative decoupled processes\u2014that achieves both decoupling and global reasoning about control flow. We introduce this programming model through an event calculus, loosely inspired by the Join calculus, that enables reasoning about cooperative decoupled processes through the concepts of pre- and\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "On the impact of order information in api usage patterns\n", "abstract": " Many approaches have been proposed for learning Application Programming Interface (API) usage patterns from code repositories. Depending on the underlying technique, the mined patterns may (1) be strictly sequential, (2) consider partial order between method calls, or (3) not consider order information. Understanding the trade-offs between these pattern types with respect to real code is important in many applications (e.g. misuse detection), given that APIs often have usage constraints, such as restrictions on call order. API misuses, i.e., violations of these constraints, may lead to software crashes, bugs and vulnerabilities.               In this paper, we present the results of a work that addresses this need. We have constructed a benchmark based on an episode mining algorithm that can be configured to learn three type of patterns: sequential, partial, and no-order patterns. We use the benchmark in two\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "Using Vampire with Support for Algebraic Datatypes in Type Soundness Proofs\n", "abstract": " In our ongoing project VeriTaS, we aim at automating soundness proofs for type systems of domain-specific languages. In the past, we successfully used previous Vampire versions for automatically discharging many intermediate proof obligations arising within standard soundness proofs for small type systems. With older Vampire versions, encoding the individual proof problems required manual encoding of algebraic datatypes via the theory of finite term algebras. One of the new Vampire versions now supports the direct specification of algebraic datatypes and integrates reasoning about term algebras into the internally used superposition calculus.In this work, we investigate how many proof problems that typically arise within type soundness proofs different Vampire 4.1 versions can prove. Our test set consists of proof problems from a progress proof of a type system for a subset of SQL. We compare running Vampire 4.1 with our own encodings of algebraic datatypes (in untyped as well as in typed first-order logic) to running Vampire 4.1 with support for algebraic datatypes, which uses SMTLIB as input format. We observe that with our own encodings, Vampire 4.1 still proves more of our input problems. We discuss the differences between our own encoding of algebraic datatypes and the ones used within Vampire 4.1 with support for algebraic datatypes.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Towards safe modular composition of network functions\n", "abstract": " Network Function Virtualization (NFV) aims to overcome the limitations of hardware middleboxes by moving network functions to software. Ultimately, this approach enables deployment into virtualized environments with higher flexibility, reducing deployment time and costs. In common industrial practice, multiple smaller network functions are often chained together into service function chains. Yet, service function chains are extremely fragile, lacking basic guarantees on correct composition and dependency reasoning. In this position paper, we propose a roadmap towards language abstractions that address this issue. We introduce the problems with current service function chaining technology and present the research program we envision.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Abmash: mashing up legacy Web applications by automated imitation of human actions\n", "abstract": " Many business Web\u2010based applications do not offer APIs to enable other applications to access their data and functions in a programmatic manner. This makes their composition difficult (for instance to synchronize data between two applications). To address this challenge, this paper presents Abmash, an approach to facilitate the integration of such legacy Web applications by automatically imitating human interactions with them. By automatically interacting with the GUI of Web applications, the system supports all forms of integrations including bidirectional interactions and is able to interact with AJAX\u2010based applications. Furthermore, the integration programs are easy to write because they deal with end\u2010user, visual UI elements. The integration code is simple enough to be called a \u2018mash\u2010up\u2019. Copyright \u00a9 2013 John Wiley & Sons, Ltd.", "num_citations": "1\n", "authors": ["263"]}
{"title": "XPoints: Extension Interfaces for Multilayered Applications\n", "abstract": " Extensibility is a key requirement in modern software applications. In the context of business applications it is one of the major selection criteria from the customer perspective. However, there are some challenges concerning the specification and enforcement of extension interfaces. Extension interfaces define the resources of the base applications that are allowed to be extended, where and when the extension code will run, and what resources of the base application an extension is allowed to access. While concepts for such interfaces are still a hot research topic for \"traditional\" software constructed using a single programming language, they are completely missing for complex systems consisting of several abstraction layers. In addition, state-of-the-art approaches do not support providing different extension interfaces for different stakeholders. This paper attempts to fill this gap by introducing XPoints, an\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "Towards conflict-free composition of non-functional concerns\n", "abstract": " In component-based software development, applications are decomposed, e.g., into functional and non-functional components which have to be composed to a working system. The composition of non-functional behavior from different non-functional domains such as security, reliability, and performance is particularly complex. Finding a valid composition is challenging because there are different types of interdependencies between concerns, e.g. mutual exclusion, conflicts, and ordering restrictions, which should not be violated.               In this paper we formalize a set of interdependency types between non-functional actions realizing non-functional behavior. These interdependencies can either be specified explicitly or implicitly by taking action properties into account. This rich set of interdependencies can then be used to ease the task of action composition by validating compositions against\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "An aspect-oriented framework for specification and enforcement of non-functional concerns in WS-BPEL\n", "abstract": " Web Service processes in WS-BPEL have several non-functional requirements such as security and reliable messaging. Although there are many WS-* specifications that address these concerns, their integration with WSBPEL is still open. In this paper, we discuss these non-functional requirements and present a survey on the current support for their specification and enforcement in WS-BPEL engines. Moreover, we introduce an aspect-oriented container framework that uses a declarative deployment descriptor to specify the non-functional requirements. For the enforcement, aspects in AO4BPEL 2.0 are generated, which intercept the process execution and call dedicated middleware Web Services.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Magic for the masses: safer high-level low-level programming through customizable static analyses\n", "abstract": " Writing high-performance virtual machines in a high-level language requires an escape-hatch, such that unavoidable low-level tasks can be performed efficiently. To this end, the org. vmmagic framework used by Jikes RVM and other VMs makes it possible to extend the Java language with the needed low-level facilities. For these facilities and the constraints they impose, though, tool support is almost nonexistent, making it difficult for implementers not to violate the additional constraints imposed by the language extension. We thus propose an declarative approach based on customizable static analyses to make specification and checking of these constraints easily accessible to implementers", "num_citations": "1\n", "authors": ["263"]}
{"title": "Komponenten in ereignisbasierten systemen\n", "abstract": " Im Folgenden analysieren wir die Anforderungen, die ereignisbasierte Systeme an den Entwurf stellen, und f\u00fchren Sichtbarkeitsbereiche (Scopes) als einen grundlegenden Strukturierungsmechanismus ein, der diesen Anforderungen gen\u00fcgt. Die Sichtbarkeitsbereiche b\u00fcndeln mehrere Basiskomponenten und schr\u00e4nken die Sichtbarkeit von Notifikationen zun\u00e4chst auf die Konsumenten ein, die sich im gleichen Bereich wie der Produzent befinden. Zusammen mit einer eigenen Schnittstellenbeschreibung dienen die Sichtbarkeitsbereiche als Komponentenbegriff im Sinne von [13] und offerieren ein Modulkonzept, wie es oben gefordert wurde. Damit ist man in der Lage, ereignisbasierte Systeme graduell weiterzuentwickeln und die Leistung und Semantik des Notifikations-Dienstes an die Struktur zu binden und darin anzupassen.", "num_citations": "1\n", "authors": ["263"]}
{"title": "Weiterentwicklung objektorientierter Softwaresysteme: Risiken und deren Vermeidung\n", "abstract": " Vererbung geh\u00f6rt zu den wichtigsten Mechanismen objektorientierter Programmierung. Durch Vererbung k\u00f6nnen vorhandene Implementierungen spezialisiert und an bestimmte Aufgaben angepasst werden. Doch w\u00e4hrend der Zugriff auf Instanzen \u00fcber eine klar definierte Schnittstelle erfolgt, existiert f\u00fcr die Vererbung kein \u00e4quivalenter Mechanismus. Deshalb k\u00f6nnen \u00c4nderungen innerhalb der Vererbungshierarchie nicht absch\u00e4tzbare Auswirkungen auf das Verhalten des Gesamtsystems haben. Insbesondere \u00c4nderungen in Basiskomponenten k\u00f6nnen dazu fuhren, dass das Gesamtsystem syntaktisch korrekt und damit \u00fcbersetzbar ist, aber semantische Konflikte ein Fehlverhalten des Gesamtsystems zur Folge haben.               In aktuellen Entwicklungsumgebungen wird die Weiterentwicklung objektorientierter Systeme durch Versionsverwaltungen unterst\u00fctzt. \u00c4nderungen unterschiedlicher\u00a0\u2026", "num_citations": "1\n", "authors": ["263"]}
{"title": "A Study of Java's Binary Compatibility\n", "abstract": " In this paper, we investigate Java's approach to release-torelease binary compatibility and argue that it is restricted in two ways. First, binary compatibility is coupled to the mechanism for resolving references, ensuring binary compatibility of new releases of a base component with existing clients components that use and or inherit from the base component only if existing clients are never recompiled. Second, some release-to-release modifications to a base component that might cause its clients to malfunction are not at all considered. We conclude that proper change management should be the responsibility of a dedicated module of the language, a Change Manager. We present a framework for analyzing Java binaries to detect incompatible changes. The framework will be one part of the independent change management module. Another part will be responsible for reestablishing compatibility when possible.", "num_citations": "1\n", "authors": ["263"]}