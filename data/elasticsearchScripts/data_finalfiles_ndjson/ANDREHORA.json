{"title": "Understanding the factors that impact the popularity of GitHub repositories\n", "abstract": " Software popularity is a valuable information to modern open source developers, who constantly want to know if their systems are attracting new users, if new releases are gaining acceptance, or if they are meeting user's expectations. In this paper, we describe a study on the popularity of software systems hosted at GitHub, which is the world's largest collection of open source software. GitHub provides an explicit way for users to manifest their satisfaction with a hosted repository: the stargazers button. In our study, we reveal the main factors that impact the number of stars of GitHub projects, including programming language and application domain. We also study the impact of new features on project popularity. Finally, we identify four main patterns of popularity growth, which are derived after clustering the time series representing the number of stars of 2,279 popular GitHub repositories. We hope our results provide\u00a0\u2026", "num_citations": "189\n", "authors": ["89"]}
{"title": "Historical and Impact Analysis of API Breaking Changes: A Large-Scale Study\n", "abstract": " Change is a routine in software development. Like any system, libraries also evolve over time. As a consequence, clients are compelled to update and, thus, benefit from the available API improvements. However, some of these API changes may break contracts previously established, resulting in compilation errors and behavioral changes. In this paper, we study a set of questions regarding API breaking changes. Our goal is to measure the amount of breaking changes on real-world libraries and its impact on clients at a large-scale level. We assess (i) the frequency of breaking changes, (ii) the behavior of these changes over time, (iii) the impact on clients, and (iv) the characteristics of libraries with high frequency of breaking changes. Our large-scale analysis on 317 real-world Java libraries, 9K releases, and 260K client applications shows that (i) 14.78% of the API changes break compatibility with previous\u00a0\u2026", "num_citations": "92\n", "authors": ["89"]}
{"title": "A novel approach for estimating truck factors\n", "abstract": " Truck Factor (TF) is a metric proposed by the agile community as a tool to identify concentration of knowledge in software development environments. It states the minimal number of developers that have to be hit by a truck (or quit) before a project is incapacitated. In other words, TF helps to measure how prepared is a project to deal with developer turnover. Despite its clear relevance, few studies explore this metric. Altogether there is no consensus about how to calculate it, and no supporting evidence backing estimates for systems in the wild. To mitigate both issues, we propose a novel (and automated) approach for estimating TF-values, which we execute against a corpus of 133 popular project in GitHub. We later survey developers as a means to assess the reliability of our results. Among others, we find that the majority of our target systems (65%) have TF \u2264 2. Surveying developers from 67 target systems\u00a0\u2026", "num_citations": "85\n", "authors": ["89"]}
{"title": "Predicting the popularity of GitHub repositories\n", "abstract": " GitHub is the largest source code repository in the world. It provides a git-based source code management platform and also many features inspired by social networks. For example, GitHub users can show appreciation to projects by adding stars to them. Therefore, the number of stars of a repository is a direct measure of its popularity. In this paper, we use multiple linear regressions to predict the number of stars of GitHub repositories. These predictions are useful both to repository owners and clients, who usually want to know how their projects are performing in a competitive open source development market. In a large-scale analysis, we show that the proposed models start to provide accurate predictions after being trained with the number of stars received in the last six months. Furthermore, specific models---generated using data from repositories that share the same growth trends---are recommended for\u00a0\u2026", "num_citations": "64\n", "authors": ["89"]}
{"title": "apiwave: Keeping track of API popularity and migration\n", "abstract": " Every day new frameworks and libraries are created and existing ones evolve. To benefit from such newer or improved APIs, client developers should update their applications. In practice, this process presents some challenges: APIs are commonly backward-incompatible (causing client applications to fail when updating) and multiple APIs are available (making it difficult to decide which one to use). To address these challenges, we propose apiwave, a tool that keeps track of API popularity and migration of major frameworks/libraries. The current version includes data about the evolution of top 650 GitHub Java projects, from which 320K APIs were extracted. We also report an experience using apiwave on real-world scenarios.", "num_citations": "61\n", "authors": ["89"]}
{"title": "Why and How Java Developers Break APIs\n", "abstract": " Modern software development depends on APIs to reuse code and increase productivity. As most software systems, these libraries and frameworks also evolve, which may break existing clients. However, the main reasons to introduce breaking changes in APIs are unclear. Therefore, in this paper, we report the results of an almost 4-month long field study with the developers of 400 popular Java libraries and frameworks. We configured an infrastructure to observe all changes in these libraries and to detect breaking changes shortly after their introduction in the code. After identifying breaking changes, we asked the developers to explain the reasons behind their decision to change the APIs. During the study, we identified 59 breaking changes, confirmed by the developers of 19 projects. By analyzing the developers' answers, we report that breaking changes are mostly motivated by the need to implement new\u00a0\u2026", "num_citations": "42\n", "authors": ["89"]}
{"title": "On the popularity of GitHub applications: A preliminary note\n", "abstract": " GitHub is the world's largest collection of open source software. Therefore, it is important both to software developers and users to compare and track the popularity of GitHub repositories. In this paper, we propose a framework to assess the popularity of GitHub software, using their number of stars. We also propose a set of popularity growth patterns, which describe the evolution of the number of stars of a system over time. We show that stars tend to correlate with other measures, like forks, and with the effective usage of GitHub software by third-party programs. Throughout the paper we illustrate the application of our framework using real data extracted from GitHub.", "num_citations": "31\n", "authors": ["89"]}
{"title": "APIDiff: Detecting API Breaking Changes\n", "abstract": " Libraries are commonly used to increase productivity. As most software systems, they evolve over time and changes are required. However, this process may involve breaking compatibility with previous versions, leading clients to fail. In this context, it is important that libraries creators and clients frequently assess API stability in order to better support their maintenance practices. In this paper, we introduce APIDIFF, a tool to identify API breaking and non-breaking changes between two versions of a Java library. The tool detects changes on three API elements: types, methods, and fields. We also report usage scenarios of APIDIFF with four real-world Java libraries.", "num_citations": "27\n", "authors": ["89"]}
{"title": "Why We Engage in FLOSS: Answers from Core Developers\n", "abstract": " The maintenance and evolution of Free/Libre Open Source Software (FLOSS) projects demand the constant attraction of core developers. In this paper, we report the results of a survey with 52 developers, who recently became core contributors of popular GitHub projects. We reveal their motivations to assume a key role in FLOSS projects (eg, improving the projects because they are also using it), the project characteristics that most helped in their engagement process (eg, a friendly community), and the barriers faced by the surveyed core developers (eg, lack of time of the project leaders). We also compare our results with related studies about others kinds of open source contributors (casual, one-time, and newcomers).", "num_citations": "25\n", "authors": ["89"]}
{"title": "Why Do We Break APIs? First Answers from Developers\n", "abstract": " Breaking contracts have a major impact on API clients. Despite this fact, recent studies show that libraries are often backward incompatible and that the rate of breaking changes increase over time. However, the specific reasons that motivate library developers to break contracts with their clients are still unclear. In this paper, we describe a qualitative study with library developers and real instance of API breaking changes. Our goal is to (i) elicit the reasons why developers introduce breaking changes; and (ii) check if they are aware about the risks of such changes. Our survey with the top contributors of popular Java libraries contributes to reveal a list of five reasons why developers break API contracts. Moreover, it also shows that most of developers are aware of these risks and, in some cases, adopt strategies to mitigate them. We conclude by prospecting a future study to strengthen our current findings. With this\u00a0\u2026", "num_citations": "12\n", "authors": ["89"]}
{"title": "What is the Truck Factor of popular GitHub applications? A first assessment\n", "abstract": " The Truck Factor designates the minimal number of developers that have to be hit by a truck (or quit) before a project is incapacitated. It can be seen as a measurement of the concentration of information in individual team members. We calculate the Truck Factor for 133 popular GitHub applications, in six languages. To infer the authors of a file we use the Degree-of-Authorship (DOA) metric, which is computed using version history data, and to estimate the Truck Factor, we use a greedy heuristic. Results show that most systems have a small truck factor (46% have Truck Factor=1 and 28% have Truck Factor=2).", "num_citations": "12\n", "authors": ["89"]}
{"title": "Refactoring Graphs: Assessing Refactoring over Time\n", "abstract": " Refactoring is an essential activity during software evolution. Frequently, practitioners rely on such transformations to improve source code maintainability and quality. As a consequence, this process may produce new source code entities or change the structure of existing ones. Sometimes, the transformations are atomic, i.e., performed in a single commit. In other cases, they generate sequences of modifications performed over time. To study and reason about refactorings over time, in this paper, we propose a novel concept called refactoring graphs and provide an algorithm to build such graphs. Then, we investigate the history of 10 popular open-source Java-based projects. After eliminating trivial graphs, we characterize a large sample of 1,150 refactoring graphs, providing quantitative data on their size, commits, age, refactoring composition, and developers. We conclude by discussing applications and\u00a0\u2026", "num_citations": "11\n", "authors": ["89"]}
{"title": "You Broke My Code: Understanding the Motivations for Breaking Changes in APIs\n", "abstract": " As most software systems, libraries and frameworks also evolve, which may break existing clients. However, the main reasons to introduce breaking changes in APIs are unclear. Therefore, in this paper, we first report the results of an almost 4-month long field study with popular Java libraries and frameworks. We configured an infrastructure to observe all changes in these libraries and to detect breaking changes shortly after their introduction in the code. We detected possible breaking changes in 61 projects. After identifying breaking changes, we asked the developers to explain the reasons behind their decision to change the APIs. By analyzing the developers\u2019 answers, we report that breaking changes are mostly motivated by the need to implement new features, by the desire to make the APIs simpler and with fewer elements, and to improve maintainability. To complement this first study, we describe a second\u00a0\u2026", "num_citations": "11\n", "authors": ["89"]}
{"title": "Assessing Code Authorship: The Case of the Linux Kernel\n", "abstract": " Code authorship is a key information in large-scale opensource systems. Among others, it allows maintainers to assess division of work and identify key collaborators. Interestingly, open-source communities lack guidelines on how to manage authorship. This could be mitigated by setting to build an empirical body of knowledge on how authorship-related measures evolve in successful open-source communities. Towards that direction, we perform a case study on the Linux kernel. Our results show that:(a) only a small portion of developers (26%) makes significant contributions to the code base;(b) the distribution of the number of files per author is highly skewed\u2014a small group of top-authors (3%) is responsible for hundreds of files, while most authors (75%) are responsible for at most 11 files;(c) most authors (62%) have a specialist profile;(d) authors with a high number of co-authorship connections tend to collaborate with others with less connections.", "num_citations": "10\n", "authors": ["89"]}
{"title": "Measuring and analyzing code authorship in 1+ 118 open source projects\n", "abstract": " Code authorship is a key information about large-scale software projects. Among others, it reveals the division of work, key collaborators, and developers' profiles. Seeking to better understand authorship in large and successful open source communities, we take the Linux kernel as our first case study. In total, we analyze authorship across 66 stable releases. Our analysis is centered around the Degree-of-Authorship (DOA) metric, which accounts for first authorship events (file creation), as well as further code changes. Authorship along the Linux kernel evolution reveals that (a) only a small portion of developers (26%) makes significant contributions to the code base; this ratio is almost constant during the Linux kernel evolution; (b) the number of files per author is highly skewed\u2014a small group of top-authors (2%) is responsible for hundreds of files, while most authors (75%) are responsible for at most 10 files; (c\u00a0\u2026", "num_citations": "9\n", "authors": ["89"]}
{"title": "Generating XML/GML Schemas from Geographic Conceptual Schemas.\n", "abstract": " A large volume of data with complex structures is currently represented in GML (Geography Markup Language) for storing and exchanging geographic information. As the size and complexity of such documents and their schemas grow, techniques and rules for designing and creating such documents become indispensable. This paper introduces a method for mapping geographic conceptual specifications (defined in OMT-G) to GML Schema. Our method avoids semantic or structural losses and provides redundancy-free data. It also reduces the use of integrity constraints and improves the nesting of XML elements in the resulting schema. We have implemented the method in order to automate the process of obtaining the target schema from the original geographic model. Experimental results show that spatial and non-spatial queries over the GML documents created from schemas generated using our method are more efficient than on documents created with a traditional, direct mapping process.", "num_citations": "7\n", "authors": ["89"]}
{"title": "What Are the Characteristics of Popular APIs? A Large Scale Study on Java, Android, and 165 Libraries\n", "abstract": " Software systems are commonly implemented with the support of libraries, which provide features via APIs. Ideally, APIs should have some characteristics, for example, they should be well documented and stable so that client systems can confidently rely on them. However, not all APIs are equal in number of clients: while some APIs are very popular and used worldwide, other may face much lower usage rates. In this context, one question appears: are there particular characteristics that differentiate popular APIs from ordinary APIs? Answering this question can uncover how worldwide APIs are actually implemented and maintained, revealing practices to better support both research and development on APIs. In this paper, we assess the characteristics of popular APIs, including their size, legibility, documentation, stability, and client adoption. We analyze 1491 APIs provided by Java, Android, and 165 libraries. We\u00a0\u2026", "num_citations": "6\n", "authors": ["89"]}
{"title": "APISonar: Mining API Usage Examples\n", "abstract": " Developers spend a significant part of their time searching for code examples on the web. Often, they look for Application Programming Interface (API) usage examples, that is, how to use APIs provided by libraries and frameworks. For this purpose, several programming websites are available. Some programming websites provide manually created examples: unfortunately, as millions of APIs are available nowadays, they do not cover the majority of the APIs. To alleviate this limitation, other programming websites focus on automatically mining API usage examples from code repositories. To the best of our knowledge, however, these solutions are still very limited: they often present poor, duplicated, and similar API usage examples. In this article, we propose an approach, APISonar, to automatically mine API usage examples from code repositories. Our approach aims to overcome the limitations of current solutions\u00a0\u2026", "num_citations": "5\n", "authors": ["89"]}
{"title": "Characteristics of Method Extractions in Java: A Large Scale Empirical Study\n", "abstract": " Extract method is the \u201cSwiss army knife\u201d of refactorings: developers perform method extraction to introduce alternative signatures, decompose long code, improve testability, among many other reasons. Although the rationales behind method extraction are well explored, we are not yet aware of its characteristics. Assessing this information can provide the basis to better understand this important refactoring operation as well as improve refactoring tools and techniques based on the actual behavior of developers. In this paper, we assess characteristics of the extract method refactoring. We rely on a state-of-the-art technique to detect method extraction, and analyze over 70K instances of this refactoring, mined from 124 software systems. We investigate five aspects of this operation: magnitude, content, transformation, size, and degree. We find that (i) the extract method is among the most popular refactorings;(ii) extracted methods are over represented on operations related to creation, validation, and setup;(iii) methods that are targets of the extractions are 2.2 x longer than the average, and they are reduced by one statement after the extraction; and (iv) single method extraction represents most, but not all, of the cases. We conclude by proposing improvements to refactoring detection, suggestion, and automation tools and techniques to support both practitioners and researchers.", "num_citations": "5\n", "authors": ["89"]}
{"title": "Framework Code Samples: How Are They Maintained and Used by Developers?\n", "abstract": " Background: Modern software systems are commonly built on the top of frameworks. To accelerate the learning process of features provided by frameworks, code samples are made available to assist developers. However, we know little about how code samples are actually developed. Aims: In this paper, we aim to fill this gap by assessing the characteristics of framework code samples. We provide insights on how code samples are maintained and used by developers. Method: We analyze 233 code samples of Android and SpringBoot, and assess aspects related to their source code, evolution, popularity, and client usage. Results: We find that most code samples are small and simple, provide a working environment to the clients, and rely on automated build tools. They change frequently over time, for example, to adapt to new framework versions. We also detect that clients commonly fork the code samples\u00a0\u2026", "num_citations": "4\n", "authors": ["89"]}
{"title": "Mapping network relationships from spatial database schemas to GML documents\n", "abstract": " Spatial data encoded in GML documents are used in various applications and are especially suited to storing, manipulating and exchanging geographic information. However, a large share of currently available spatial data is stored in spatial databases. This article presents a method to map arcs and nodes, organized in a network using spatial relationships, from a spatial database to a GML document. Specifically, a geographical conceptual schema and the corresponding GML schema are used as guide to retrieve and reorganize networking information found in the spatial database, thus generating a GML document. The proposed methodology is verified in a case study, in which networking relationships from real-world databases are mapped to GML documents that can be queried using standard XML languages such as XPath and XQuery.", "num_citations": "4\n", "authors": ["89"]}
{"title": "Googling for Software Development: What Developers Search For and What They Find\n", "abstract": " Developers often search for software resources on the web. In practice, instead of going directly to websites (eg, Stack Overflow), they rely on search engines (eg, Google). Despite this being a common activity, we are not yet aware of what developers search from the perspective of popular software development websites and what search results are returned. With this knowledge, we can understand real-world queries, developers\u2019 needs, and the query impact on the search results. In this paper, we provide an empirical study to understand what developers search on the web and what they find. We assess 1.3 M queries to popular programming websites and we perform thousands of queries on Google to explore search results. We find that (i) developers\u2019 queries typically start with keywords (eg, Python, Android, etc.), are short (3 words), tend to omit functional words, and are similar among each other;(ii) minor changes to queries do not largely affect the Google search results, however, some cosmetic changes may have a non-negligible impact; and (iii) search results are dominated by Stack Overflow, but YouTube is also a relevant source nowadays. We conclude by presenting detailed implications for researchers and developers.", "num_citations": "3\n", "authors": ["89"]}
{"title": "JSCity\u2013Visualiza\u00e7\u00e3o de Sistemas JavaScript em 3D\n", "abstract": " JavaScript is one of the most used languages on the web. A wide range of frameworks and libraries widely adopted on the market make use of Javascript. In order to support the development and maintenance of such systems, source code visual representations can be used for restructuring, refactoring and understanding JavaScript software. Although there are tools that generate visual representations of code in other languages such as CodeCity for Java, no similar tool is available for JavaScript applications. This paper presents JSCity, a tool for the interactive visualization of JavaScript systems in 3D, using a city metaphor. For this work, we analyzed 40 popular open source systems written in JavaScript hosted in GitHub.Resumo. JavaScript \u00e9 uma das linguagens mais utilizadas da web. Muitos frameworks e bibliotecas adotados no mercado fazem uso de JavaScript. Para dar suporte ao desenvolvimento e manuten\u00e7\u00e3o desses sistemas, representa\u00e7\u00f5es visuais podem ser utilizadas na reestrutura\u00e7\u00e3o, refatora\u00e7\u00e3o e entendimento de c\u00f3digo. Embora existam ferramentas que gerem representa\u00e7\u00f5es visuais de c\u00f3digo em outras linguagens, como proposta pelo sistema CodeCity, nenhuma ferramenta realiza essas representa\u00e7\u00f5es para sistemas em JavaScript. Esse artigo apresenta JSCity, uma ferramenta para a visualiza\u00e7\u00e3o de sistemas JavaScript em 3D usando a met\u00e1fora de uma cidade. Para esse trabalho, foram analisados 40 sistemas populares escritos em JavaScript, que est\u00e3o hospedados no GitHub.", "num_citations": "3\n", "authors": ["89"]}
{"title": "Identifying Utility Functions in Java and JavaScript\n", "abstract": " Utility functions provide generic services that can be reused in different types of systems. Theoretically, they must be implemented in specific modules. However, it is common to find such functions implemented with domain specific functions, decreasing their chances of reuse. In this paper, we propose a set of heuristics to identify utility functions. With such heuristics, recommendations can be provided to move the functions to appropriate modules. In a survey conducted with 33 developers, the proposed heuristics showed a precision of 66% and 67% when applied to Java and JavaScript systems, respectively.", "num_citations": "2\n", "authors": ["89"]}
{"title": "Mapeamento de Relacionamentos em Rede Armazenados em Bancos de Dados Espaciais para Documentos GML.\n", "abstract": " Dados representados em documentos GML sao utilizados em diversas aplica\u00e7oes GIS e na Web visando principalmente o armazenamento, a manipula\u00e7ao e a troca de informa\u00e7oes geogr\u00e1ficas. Entretanto, uma grande parte das informa\u00e7oes geogr\u00e1ficas estao armazenadas em bancos de dados espaciais. Este trabalho apresenta uma metodologia para mapear dados geogr\u00e1ficos, estruturados usando relacionamentos em rede e armazenados nesses bancos de dados, para documentos GML. Para isso, um esquema conceitual geogr\u00e1fico e seu esquema GML correspondente sao utilizados para a interpreta\u00e7 ao da informa\u00e7 ao geogr\u00e1fica armazenada, resultando na gera\u00e7 ao do documento GML. A metodologia proposta \u00e9 verificada atrav\u00e9s da gera\u00e7ao de documentos GML representando relacionamentos em rede reais armazenados em bancos de dados espaciais.", "num_citations": "2\n", "authors": ["89"]}
{"title": "Simple: uma ferramenta de suporte ao processo de ensino-aprendizagem de processamento digital de imagens\n", "abstract": " Processamento digital de imagens (PDI) \u00e9 uma \u00e1rea da pesquisa cient\u00edfica bastante produtiva e desafiadora, com uma gama variada de aplica\u00e7\u00f5es em diversos ramos da iniciativa cient\u00edfica, comercial, e t\u00e9cnica. Contudo, apesar de seu cunho eminentemente pr\u00e1tico, grande parte das iniciativas de ensino/aprendizagem de PDI adota uma estrat\u00e9gia predominantemente te\u00f3rica. A fim de desenvolver habilidades pr\u00e1ticas em PDI, o uso de ferramentas educacionais para o ensino/aprendizagem pr\u00e1tico parece ser uma estrat\u00e9gia bastante satisfat\u00f3ria e efetiva. SImPLe \u00e9 um sistema projetado e implementado em Java para oferecer apoio ao aprendizado de uma s\u00e9rie de funcionalidades b\u00e1sicas e avan\u00e7adas a estudantes de PDI.", "num_citations": "2\n", "authors": ["89"]}
{"title": "Characterizing Top Ranked Code Examples in Google\n", "abstract": " Developers often look for code examples on the web to improve learning and accelerate development. Google indexes millions of pages with code examples: pages with better content are likely to be top ranked. In practice, many factors may influence the rank: page reputation, content quality, etc. Consequently, the most relevant information on the page, i.e.,\u00a0the code example, may be overshadowed by the search engine. Thus, a better understanding of how Google would rank code examples in isolation may provide the basis to detect its strengths and limitations on dealing with such content. In this paper, we assess how the Google search engine ranks code examples. We build a website with 1,000 examples and submit it to Google. After being fully indexed, we query and analyze the returned examples. We find that pages with multiple code examples are more likely to top ranked by Google. Overall, single code\u00a0\u2026", "num_citations": "1\n", "authors": ["89"]}
{"title": "Assessing Mock Classes: An Empirical Study\n", "abstract": " During testing activities, developers frequently rely on dependencies (e.g., web services, etc) that make the test harder to be implemented. In this scenario, they can use mock objects to emulate the dependencies\u2019 behavior, which contributes to make the test fast and isolated. In practice, the emulated dependency can be dynamically created with the support of mocking frameworks or manually hand-coded in mock classes. While the former is well-explored by the research literature, the latter has not yet been studied. Assessing mock classes would provide the basis to better understand how those mocks are created and consumed by developers and to detect novel practices and challenges. In this paper, we provide the first empirical study to assess mock classes. We analyze 12 popular software projects, detect 604 mock classes, and assess their content, design, and usage. We find that mock classes: often emulate\u00a0\u2026", "num_citations": "1\n", "authors": ["89"]}
{"title": "On the Evolution of Feature Dependencies: An Exploratory Study of Preprocessor-based Systems\n", "abstract": " Feature dependencies are the subject of several studies and have been approached with different goals, such as software quality. However, we still It is not known whether feature dependencies are prone to change during the lifetime of configurable systems. To minimize this lack, we perform an empirical study to assess the evolution of feature dependencies. We focus in feature dependencies at the source-code level written with preprocessor directives, for this, we analyze the history of feature dependency changes in 15 preprocessor based systems written in C. In order to identify the most common types of changes on feature dependencies, we propose a catalog of possible changes in these dependencies. We found out that about 9% of the feature dependencies between two subsequent versions are added, and less of 4% are excluded. Whereas, about 87% of the dependencies between two subsequent\u00a0\u2026", "num_citations": "1\n", "authors": ["89"]}
{"title": "CodeCity for (and by) JavaScript\n", "abstract": " JavaScript is one of the most popular programming languages on the web. Despite the language popularity and the increasing size of JavaScript systems, there is a limited number of visualization tools that can be used by developers to comprehend, maintain, and evolve JavaScript software. In this paper, we introduce JSCity, an implementation in JavaScript of the well-known Code City software visualization metaphor. JSCity relies on JavaScript features and libraries to show \"software cities\" in standard web browsers, without requiring complex installation procedures. We also report our experience on producing visualizations for 40 popular JavaScript systems using JScity.", "num_citations": "1\n", "authors": ["89"]}
{"title": "Um Estudo em Larga Escala sobre Estabilidade de APIs\n", "abstract": " APIs are constantly being evolved. As a consequence, their clients are compelled to update and, thus, benefit from the available improvements. However, some of these changes may break contracts previously established, resulting in compilation errors or behavioral changes. In this paper, questions related to API evolution and stability are studied, with the purpose of characterizing (i) the frequency of changes inserted,(ii) the behavior of these changes among time and (iii) the impact in client applications. Therefore, the top-100 GitHub most popular Java libraries are analyzed, and so their possible clients. As a result, insights are provided for the development of tools to support both library developers and clients in evolution and maintenance activities.Resumo. APIs estao em constante evolu\u00e7 ao. Como consequ\u00eancia, seus clientes sao compelidos a atualizarem-se e, assim, aproveitarem as melhorias disponibilizadas. Entretanto, algumas dessas mudan\u00e7as podem quebrar contratos previamente estabelecidos, resultando em erros de compila\u00e7ao ou mudan\u00e7as comportamentais. Neste artigo, estudam-se questoes relativas a evolu\u00e7ao e estabilidade de APIs, visando caracterizar (i) a frequ\u00eancia de mudan\u00e7as inseridas,(ii) o comportamento dessas mudan\u00e7as ao longo do tempo e (iii) o impacto em aplica\u00e7 oes clientes. Dessa forma, foram analisadas as 100 bibliotecas Java mais populares do GitHub, bem como seus poss\u0131veis clientes. Como resultado, sao apresentados insights de ferramentas para auxiliar ambos os clientes e os desenvolvedores de bibliotecas em suas atividades de evolu\u00e7 ao e manuten\u00e7 ao.", "num_citations": "1\n", "authors": ["89"]}
{"title": "Assessing and Improving Rules to Support Software Evolution\n", "abstract": " Software systems evolve by adding new features, fixing bugs or refactoring existing source code. During this process, some problems may occur (e.g., backward-incompatibility, missing or unclear method deprecation) causing evolving systems and their clients to be inconsistent or to fail, decreasing code quality. As nowadays software systems are frequently part of bigger ecosystems, such problems are even harder to handle because the impact may be large and unknown.One solution to deal with such maintainability problems is the usage of rules to ensure consistency. These rules may be created by experts or extracted from source code repositories, which are commonly evaluated in small-scale case studies. We argue that existing approaches lack of: (i) a deep understanding of the benefits provided by expert-based rules, (ii) a better use of source code repositories to extract history-based rules, and (iii) a large-scale analysis of the impact of source code evolution on the actual clients.In this thesis we propose to analyze and improve rules to better support developers keeping track of source code evolution. We cover three aspects. The benefits provided by expert-based rules: we report on an investigation of rules created based on expert opinion to understand whether they are worthwhile to be adopted given the cost to produce them. The improvement of history-based rules: we propose two solutions to extract better rules from source code history. The impact of source code evolution on a software ecosystem: we undergo an investigation, in a large-scale ecosystem, on the awareness of the client systems about source code evolution.We\u00a0\u2026", "num_citations": "1\n", "authors": ["89"]}