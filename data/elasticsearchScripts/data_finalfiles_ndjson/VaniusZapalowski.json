{"title": "Revealing the relationship between architectural elements and source code characteristics\n", "abstract": " Understanding how a software system is structured, ie its architecture, is crucial for software comprehension. It allows developers to understand an implemented system and reason about how non-functional requirements are addressed. Yet, many systems lack any architectural documentation, or it is often outdated due to software evolution. In current practice, the process of recovering a system's architecture relies primarily on developer knowledge. Although existing architecture recovery approaches can help to identify architectural elements, these approaches require improvement to identify architectural concepts of a system automatically. Towards this goal, we analyze the usefulness of adopting different code-level characteristics to group elements into architectural modules. Our main contributions are an evaluation of the relationships between different sets of characteristics and their corresponding accuracies\u00a0\u2026", "num_citations": "12\n", "authors": ["1923"]}
{"title": "Understanding technical debt at the code level from the perspective of software developers\n", "abstract": " Keeping the source code clean and organized throughout the software development and evolution is a challenging task. Due to many factors, design choices that cause the overall code structure to decay may be made and implemented, so that benefits, such as reduced development time, can be obtained in the short term. In order to deal with these situations, the metaphor of technical debt emerged to allow such situations to be systematically managed. Although this concept is already known in academia, there are limited evidences that the industry widely adopts it. Therefore, this paper presents the results of a survey involving 74 participants that work in the Brazilian software industry, in order to understand why technical debt is introduced, eliminated and how it is managed in practice, with a focus on the code level. Our survey is not limited to the explicit management of technical debt but also includes the notion\u00a0\u2026", "num_citations": "6\n", "authors": ["1923"]}
{"title": "Autonomic management of context data based on application requirements\n", "abstract": " Pervasive computing allows users to benefit from information and services provided by advanced applications using smart and interconnected devices. Given the inherent complexity of this software environment, platforms become a typical means of easing the development and execution of pervasive applications. These platforms are usually in charge of managing the application context, ensuring that data are reliable and available to applications. Most platforms provide this feature, making real-time information available, even when applications do not need such information in real-time. This occurs, for example, when sensors continuously provide measurements to in-house temperature controllers and these measurements have limited time variance. Therefore, controllers can be updated only occasionally, reducing application overload without compromising effectiveness. To address this issue, in this paper, we\u00a0\u2026", "num_citations": "3\n", "authors": ["1923"]}
{"title": "Archviz: a tool to support architecture recovery research\n", "abstract": " In order to produce documented software architectures, many software architecture recovery methods have been proposed. Developing such methods involves a not trivial data analysis, and this calls for different data visualisations, which help compare predicted and target software architectures. Moreover, comparing methods is also difficult, because they use divergent measurements to evaluate their performance. With the goal of improving and supporting architecture recovery research, we developed the ArchViz tool, which is presented in this paper. Our tool provides metrics and visualisations of software architectures, supporting the analysis of the output of architecture recovery methods, and possibly the standardisation of their evaluation and comparison. Video link: http://youtu. be/Gjo5cOzk4kM.", "num_citations": "3\n", "authors": ["1923"]}
{"title": "Understanding architecture non-conformance: why is there a gap between conceptual architectural rules and source code dependencies?\n", "abstract": " Evaluations of approaches and tools that assess the matching between a conceptual software architecture and its implementation show that divergences typically occur. However, there is limited investigation of the nature of these divergences. Such an investigation can reveal underlying problems, eg the use of inadequate granularity to document the architecture. In this paper, we evaluate and characterize the divergences between conceptual architectural rules and dependencies among modules implemented in the source code, potentially reflecting implemented rules. This was done by means of a study involving six subject systems, in which we extracted source code dependencies and compared them against architectural rules using an association rule algorithm that provides a metric based on frequency. This allowed us to make a quantitative and qualitative analysis of the rule-dependency conformance. We\u00a0\u2026", "num_citations": "2\n", "authors": ["1923"]}
{"title": "The WGB method to recover implemented architectural rules\n", "abstract": " Context: The identification of architectural rules, which specify allowed dependencies among architectural modules, is a key challenge in software architecture recovery. Existing approaches either retrieve a large set of rules, compromising their practical use, or are limited to supporting the understanding of such rules, which are manually recovered.Objective: To propose and evaluate a method to recover architectural rules, focusing on those implemented in the source code, which may differ from planned or conceptual rules.Method: We propose the WGB method, which analyzes dependencies among architectural modules as a graph, adding weights that correspond to the proposed module dependency strength (MDS) metric and identifies the set of implemented architectural rules by solving a mathematical optimization problem. We evaluated our method with a case study and an empirical study that compared\u00a0\u2026", "num_citations": "1\n", "authors": ["1923"]}
{"title": "Using code quality features to predict bugs in procedural software systems\n", "abstract": " A wide range of metrics have been used as features to build bug (or fault) predictors. However, most of the existing predictors focus mostly on object-oriented (OO) systems, either because they rely on OO metrics or were evaluated mainly with OO systems. Procedural software systems (PSS), less addressed in bug prediction research, often suffer from maintainability problems because they typically consist of low-level applications, using for example preprocessors to cope with variability. Previous work evaluated sets of features (composed of static code metrics) proposed in existing approaches in the PSS context. However, explored metrics are limited to those that are part of traditional metric suites, being often associated with structural code properties. A type of information explored to a smaller extent in this context is the output of code quality tools that statically analyse source code, providing hints of code\u00a0\u2026", "num_citations": "1\n", "authors": ["1923"]}