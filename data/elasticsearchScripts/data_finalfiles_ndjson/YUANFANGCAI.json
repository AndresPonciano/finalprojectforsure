{"title": "The structure and value of modularity in software design\n", "abstract": " The concept of information hiding modularity is a cornerstone of modern software design thought, but its formulation remains casual and its emphasis on changeability is imperfectly related to the goal of creating added value in a given context. We need better explanatory and prescriptive models of the nature and value of information hiding. We evaluate the potential of a new theory---developed to account for the influence of modularity on the evolution of the computer industry---to inform software design. The theory uses design structure matrices to model designs and real options techniques to value them. To test the potential utility of the theory for software we apply it to Parnas's KWIC designs. We contribute an extension to design structure matrices, and we show that the options results are consistent with Parnas's conclusions. Our results suggest that such a theory does have potential to help inform software design.", "num_citations": "447\n", "authors": ["119"]}
{"title": "Modular software design with crosscutting interfaces\n", "abstract": " Aspect-oriented programming (AOP) languages such as AspectJ offer new mechanisms and possibilities for decomposing systems into modules and composing modules into systems. The key mechanism in AspectJ is the advising of crosscutting sets of join points. An aspect module uses a pointcut descriptor (PCD) to declaratively specify sets of points in program executions. Our approach employs crosscut programming interfaces, or XPIs. XPIs are explicit, abstract interfaces that decouple aspects from details of advised code", "num_citations": "327\n", "authors": ["119"]}
{"title": "Information hiding interfaces for aspect-oriented design\n", "abstract": " The growing popularity of aspect-oriented languages, such as AspectJ, and of corresponding design approaches, makes it important to learn how best to modularize programs in which aspect-oriented composition mechanisms are used. We contribute an approach to information hiding modularity in programs that use quantified advising as a module composition mechanism. Our approach rests on a new kind of interface: one that abstracts a crosscutting behavior, decouples the design of code that advises such a behavior from the design of the code to be advised, and that can stipulate behavioral contracts. Our interfaces establish design rules that govern how specific points in program execution are exposed through a given join point model and how conforming code on either side should behave. In a case study of the HyperCast overlay network middleware system, including a real options analysis, we compare\u00a0\u2026", "num_citations": "248\n", "authors": ["119"]}
{"title": "Detecting software modularity violations\n", "abstract": " This paper presents Clio, an approach that detects modularity violations, which can cause software defects, modularity decay, or expensive refactorings. Clio computes the discrepancies between how components should change together based on the modular structure, and how components actually change together as revealed in version history. We evaluated Clio using 15 releases of Hadoop Common and 10 releases of Eclipse JDT. The results show that hundreds of violations identified using Clio were indeed recognized as design problems or refactored by the developers in later versions. The identified violations exhibit multiple symptoms of poor design, some of which are not easily detectable using existing approaches.", "num_citations": "144\n", "authors": ["119"]}
{"title": "A case study in locating the architectural roots of technical debt\n", "abstract": " Our recent research has shown that, in large-scale software systems, defective files seldom exist alone. They are usually architecturally connected, and their architectural structures exhibit significant design flaws which propagate bugginess among files. We call these flawed structures the architecture roots, a type of technical debt that incurs high maintenance penalties. Removing the architecture roots of bugginess requires refactoring, but the benefits of refactoring have historically been difficult for architects to quantify or justify. In this paper, we present a case study of identifying and quantifying such architecture debts in a large-scale industrial software project. Our approach is to model and analyze software architecture as a set of design rule spaces (DRSpaces). Using data extracted from the project's development artifacts, we were able to identify the files implicated in architecture flaws and suggest refactorings\u00a0\u2026", "num_citations": "133\n", "authors": ["119"]}
{"title": "Hotspot patterns: The formal definition and automatic detection of architecture smells\n", "abstract": " In this paper, we propose and empirically validate a suite of hotspot patterns: recurring architecture problems that occur in most complex systems and incur high maintenance costs. In particular, we introduce two novel hotspot patterns, Unstable Interface and Implicit Cross-module Dependency. These patterns are defined based on Baldwin and Clark's design rule theory, and detected by the combination of history and architecture information. Through our tool-supported evaluations, we show that these patterns not only identify the most error-prone and change-prone files, they also pinpoint specific architecture problems that may be the root causes of bug-proneness and change-proneness. Significantly, we show that 1) these structure-history integrated patterns contribute more to error- and change-proneness than other hotspot patterns, and 2) the more hotspot patterns a file is involved in, the more error- and\u00a0\u2026", "num_citations": "122\n", "authors": ["119"]}
{"title": "Coordination implications of software architecture in a global software development project\n", "abstract": " In this paper, we report on our experience of using design structure matrices (DSMs), derived from architecture models developed at early stages of the project, to reveal the coordination needs among globally distributed development teams. Our approach is to automatically transform the box-and-line style software architecture model into an augmented constraint network (ACN), from which a DSM can be automatically generated. After that, we represent the coordination structure among the team members as communication matrices (COMs). We then assess the consistency between the DSM and COMs. Analysis of data gathered during the Global Studio Project Version 3.0 revealed that the architectural DSM model, representing the software modular structure, is highly consistent with the COMs that represent the actual coordination structure, showing that an architectural DSM has the potential to help guide the task\u00a0\u2026", "num_citations": "95\n", "authors": ["119"]}
{"title": "Identifying and quantifying architectural debt\n", "abstract": " Our prior work showed that the majority of error-prone source files in a software system are architecturally connected. Flawed architectural relations propagate defectsamong these files and accumulate high maintenance costs over time, just like debts accumulate interest. We model groups of architecturally connected files that accumulate high maintenance costs as architectural debts. To quantify such debts, we formally define architectural debt, and show how to automatically identify debts, quantify their maintenance costs, and model these costs over time. We describe a novel history coupling probability matrix for this purpose, and identify architecture debts using 4 patterns of architectural flaws shown to correlate with reduced software quality. We evaluate our approach on 7 large-scale open source projects, and show that a significant portion of total project maintenance effort is consumed by paying interest on\u00a0\u2026", "num_citations": "92\n", "authors": ["119"]}
{"title": "Design rule spaces: A new form of architecture insight\n", "abstract": " In this paper, we investigate software architecture as a set of overlapping design rule spaces, formed by one or more structural or evolutionary relationships and clustered using our design rule hierarchy algorithm. Considering evolutionary coupling as a special type of relationship, we investigated (1) whether design rule spaces can reveal structural relations among error-prone files;(2) whether design rule spaces can reveal structural problems contributing to error-proneness. We studied three large-scale open source projects and found that error-prone files can be captured by just a few design rule sub-spaces. Supported by our tool, Titan, we are able to flexibly visualize design rule spaces formed by different types of relationships, including evolutionary dependencies. This way, we are not only able to visualize which error-prone files belong to which design rule spaces, but also to visualize the structural problems\u00a0\u2026", "num_citations": "89\n", "authors": ["119"]}
{"title": "Influence of Thermal Parameters, Microstructure, and Morphology of Si on Machinability of an Al\u20137.0 wt.% Si Alloy Directionally Solidified\n", "abstract": " This study aims to correlate the influence of thermal and microstructural parameters such as growth rate and cooling rate (VL and TR) and secondary dendrite spacing (\u03bb2), respectively, in the machining cutting temperature and tool wear on the necking process of the Al\u20137\u2009wt.% Si alloy solidified in a horizontal directional device using a high-speed steel with a tungsten tool. The dependence of \u03bb2 on VL and TR and dependence of the maximum cutting temperature and maximum flank wear on \u03bb2 were determined by power experimental laws given by \u03bb2\u2009=\u2009constant (VL and TR)n and TMAX, VBMAX\u2009=\u2009constant (\u03bb2)n, respectively. The maximum cutting temperature increased with increasing of \u03bb2. The opposite occurred with the maximum flank wear. The role of Si alloying element on the aforementioned results has also been analyzed. A morphological change of Si along the solidified ingot length has been observed, that is, the morphology of Si in the eutectic matrix has indicated a transition from particles to fibers along the casting together with an increase of the particle diameters with the position from the metal/mold interface.", "num_citations": "84\n", "authors": ["119"]}
{"title": "Analyzing the evolution of large-scale software systems using design structure matrices and design rule theory: Two exploratory cases\n", "abstract": " Designers have long recognized the value of modularity, but important software modularity principles have remained informal. According to Baldwin and Clark's (2000) design rule theory (DRT) , modular architectures add value to system designs by creating options to improve the system by substituting or experimenting on individual modules. In this paper, we examine the design evolution of two software product platforms through the modeling lens of DRT and design structure matrices (DSMs). We show that DSM models and DRT precisely explain how real- world modularization activities in one case allowed for different rates of evolution in different software modules and in another case conferred distinct strategic advantages on a firm by permitting substitution of an at-risk software module without substantial change to the rest of the system. Our results provide positive evidence that DSM and DRT can inform\u00a0\u2026", "num_citations": "78\n", "authors": ["119"]}
{"title": "Modular aspect-oriented design with XPIs\n", "abstract": " The emergence of aspect-oriented programming (AOP) languages has provided software designers with new mechanisms and strategies for decomposing programs into modules and composing modules into systems. What we do not yet fully understand is how best to use such mechanisms consistent with common modularization objectives such as the comprehensibility of programming code, its parallel development, dependability, and ease of change. The main contribution of this work is a new form of information-hiding interface for AOP that we call the crosscut programming interface, or XPI. XPIs abstract crosscutting behaviors and make these abstractions explicit. XPIs can be used, albeit with limited enforcement of interface rules, with existing AOP languages, such as AspectJ. To evaluate our notion of XPIs, we have applied our XPI-based design methodology to a medium-sized network overlay application\u00a0\u2026", "num_citations": "74\n", "authors": ["119"]}
{"title": "Modularity analysis of logical design models\n", "abstract": " Traditional design representations are inadequate for generalized reasoning about modularity in design and its technical and economic implications. We have developed an architectural modeling and analysis approach, and automated tool support, for improved reasoning in these terms. However, the complexity of constraint satisfaction limited the size of models that we could analyze. The contribution of this paper is a more scalable approach. We exploit the dominance relations in our models to guide a divide-and-conquer algorithm, which we have implemented it in our Simon tool. We evaluate its performance in case studies. The approach reduced the time needed to analyze small but representative models from hours to seconds. This work appears to make our modeling and analysis approach practical for research on the evolvability and economic properties of software design architectures", "num_citations": "72\n", "authors": ["119"]}
{"title": "Design rule hierarchies and parallelism in software development tasks\n", "abstract": " As software projects continue to grow in scale, being able to maximize the work that developers can carry out in parallel as a set of concurrent development tasks, without incurring excessive coordination overhead, becomes increasingly important. Prevailing design models, however, are not explicitly conceived to suggest how development tasks on the software modules they describe can be effectively parallelized. In this paper, we present a design rule hierarchy based on the assumption relations among design decisions. Software modules located within the same layer of the hierarchy suggest independent, hence parallelizable, tasks. Dependencies between layers or within a module suggest the need for coordination during concurrent work. We evaluate our approach by investigating the source code and mailing list of Apache Ant. We observe that technical communication between developers working on\u00a0\u2026", "num_citations": "70\n", "authors": ["119"]}
{"title": "Decoupling level: a new metric for architectural maintenance complexity\n", "abstract": " Despite decades of research on software metrics, we still cannot reliably measure if one design is more maintainable than another. Software managers and architects need to understand whether their software architecture is \"good enough\", whether it is decaying over time and, if so, by how much. In this paper, we contribute a new architecture maintainability metric---Decoupling Level (DL)---derived from Baldwin andClark's option theory. Instead of measuring how coupled an architecture is, we measure how well the software can be decoupled into small and independently replaceable modules. We measured the DL for 108 open source projects and 21 industrial projects, each of which has multiple releases. Our main result shows that the larger the DL, the better thearchitecture. By \"better\" we mean: the more likely bugs and changes can be localized and separated, and the more likely that developers can make\u00a0\u2026", "num_citations": "63\n", "authors": ["119"]}
{"title": "Non-modularity in aspect-oriented languages: integration as a crosscutting concern for AspectJ\n", "abstract": " Aspect-oriented (AO) methods and languages seek to enable the preservation of design modularity through mappings to program structures, especially where common (object-oriented) languages fail to do so. The general claim is made that AO approaches enable the modularization of crosscutting concerns. The problem that we address is that it is unclear to what extent such claims are valid. We argue that there are meaningful bounds on the abilities of past, present, and future languages to succeed in this regard---bounds that we need to understand better. To make this idea concrete we exhibit a significant bound: Component integration (Sullivan & Notkin 1992, 1994) is not adequately modularizable in AspectJ", "num_citations": "56\n", "authors": ["119"]}
{"title": "From retrospect to prospect: Assessing modularity and stability from software architecture\n", "abstract": " Architecture level decisions, directly influenced by environmental factors, are crucial to preserve modularity and stability throughout software development life cycle. Tradeoffs of modularization alternatives, such as aspect oriented vs. object-oriented decompositions, thus need to be assessed from architecture models instead of source code. In this paper, we present a suite of architecture level metrics, taking external factors that drive software changes into consideration and measuring how well an architecture produces independently substitutable modules. We formalize these metrics using logical models to automate quantitative stability and modularity assessment. We evaluate the metrics using eight aspect oriented and object-oriented releases of a software product line architecture, driven by a series of heterogeneous changes. By contrasting with an implementation level analysis, we observe that these metrics\u00a0\u2026", "num_citations": "55\n", "authors": ["119"]}
{"title": "Modularity in design: Formal modeling and automated analysis\n", "abstract": " Reasoning about the evolvability properties and economic implications of design structures is critical to high-consequence decision-making, but it remains difficult. One key impediment is the lack of analyzable high-level design representations that both convey design architectures and enable designers to reason precisely about their modularity properties and economics. This dissertation contributes such a formal and analyzable representation. It supports formal design modeling and enables automation of a number of evolvability and economic-related analyses.", "num_citations": "53\n", "authors": ["119"]}
{"title": "Automatic modularity conformance checking\n", "abstract": " According to Parnas's information hiding principle and Baldwin and Clark's design rule theory, the key step to decomposing a system into modules is to determine the design rules (or in Parnas's terms, interfaces) that decouple otherwise coupled design decisions and to hide decisions that are likely to change in independent modules. Given a modular design, it is often difficult to determine whether and how its implementation realizes the designed modularity. Manually comparing code with abstract design is tedious and error-prone. We present an automated approach to check the conformance of implemented modularity to designed modularity, using design structure matrices as a uniform representation for both. Our experiments suggest that our approach has the potential to manifest the decoupling effects of design rules in code, and to detect modularity deviation caused by implementation faults. We also show\u00a0\u2026", "num_citations": "52\n", "authors": ["119"]}
{"title": "Manufacturing execution systems: A vision for managing software development\n", "abstract": " Software development suffers from a lack of predictability with respect to cost, time, and quality. Predictability is one of the major concerns addressed by modern manufacturing execution systems (MESs). A MES does not actually execute the manufacturing (e.g., controlling equipment and producing goods), but rather collects, analyzes, integrates, and presents the data generated in industrial production so that employees have better insights into processes and can react quickly, leading to predictable manufacturing processes. In this paper, we introduce the principles and functional areas of a MES. We then analyze the gaps between MES-vision-driven software development and current practices. These gaps include: (1) lack of a unified data collection infrastructure, (2) lack of integrated people data, (3) lack of common conceptual frameworks driving improvement loops from development data, and (4) lack of support\u00a0\u2026", "num_citations": "48\n", "authors": ["119"]}
{"title": "Measuring architecture quality by structure plus history analysis\n", "abstract": " This case study combines known software structure and revision history analysis techniques, in known and new ways, to predict bug-related change frequency, and uncover architecture-related risks in an agile industrial software development project. We applied a suite of structure and history measures and statistically analyzed the correlations between them. We detected architecture issues by identifying outliers in the distributions of measured values and investigating the architectural significance of the associated classes. We used a clustering method to identify sets of files that often change together without being structurally close together, investigating whether architecture issues were among the root causes. The development team confirmed that the identified clusters reflected significant architectural violations, unstable key interfaces, and important undocumented assumptions shared between modules. The\u00a0\u2026", "num_citations": "48\n", "authors": ["119"]}
{"title": "Functionality-Oriented Microservice Extraction Based on Execution Trace Clustering\n", "abstract": " The main task of microservice extraction is to find which software entities (e.g., methods, classes) should be grouped together from existing monolithic software as candidate microservices, responsible for specific functionalities and evolving independently. Current methods extract microservices by analyzing source code and following the assumption that \"classes with strong relation should be in the same service\", which originates from software structure analysis. We find that 1) many program behaviors cannot be explicitly reflected in the source code, and 2) the relation at code-level is not equivalent to the same functionality. Thus, we propose a functionality-oriented microservice extraction (FoME) method in this study by monitoring program dynamic behavior and clustering execution traces. Instead of source code analysis, the execution traces of a program are applied to group source code entities that are\u00a0\u2026", "num_citations": "43\n", "authors": ["119"]}
{"title": "Leveraging design rules to improve software architecture recovery\n", "abstract": " In order to recover software architecture, various clustering techniques have been created to automatically partition a software system into meaningful subsystems. While these techniques have demonstrated their effectiveness, we observe that a key feature within most software systems has not been fully exploited: most well-designed systems follow strong architectural design rules that split the overall system into modules. These design rules are often manifested as special program constructs, such as shared data structures or abstract interfaces, which should not belong to any of the subordinate modules. We contribute a new perspective of architecture recovery based on this rationale, which enables the combination of design-rule-based clustering with other clustering techniques, as well as enabling the splitting of a large system into subsystems. We evaluated our approach both quantitatively and qualitatively\u00a0\u2026", "num_citations": "38\n", "authors": ["119"]}
{"title": "Prioritization of code anomalies based on architecture sensitiveness\n", "abstract": " Code anomalies are symptoms of software maintainability problems, particularly harmful when contributing to architectural degradation. Despite the existence of many automated techniques for code anomaly detection, identifying the code anomalies that are more likely to cause architecture problems remains a challenging task. Even when there is tool support for detecting code anomalies, developers often invest a considerable amount of time refactoring those that are not related to architectural problems. In this paper we present and evaluate four different heuristics for helping developers to prioritize code anomalies, based on their potential contribution to the software architecture degradation. Those heuristics exploit different characteristics of a software project, such as change-density and error-density, for automatically ranking code elements that should be refactored more promptly according to their potential\u00a0\u2026", "num_citations": "35\n", "authors": ["119"]}
{"title": "An exploratory study of the design impact of language features for aspect-oriented interfaces\n", "abstract": " A variety of language features to modularize crosscutting concerns have recently been discussed, eg open modules, annotation-based pointcuts, explicit join points, and quantified-typed events. All of these ideas are essentially a form of aspect-oriented interface between object-oriented and crosscutting modules, but the representation of this interface differs. While previous works have studied maintenance of AO programs versus OO programs, an empirical comparison of different AO interfaces to each other to investigate their benefits has not been performed. The main contribution of this work is a rigorous empirical study that evaluates the effectiveness of these proposals for AO interfaces towards software maintenance by applying them to 35 different releases of a software product line called MobileMedia and 50 different releases of a web application called Health Watcher. Our comparative analysis using\u00a0\u2026", "num_citations": "32\n", "authors": ["119"]}
{"title": "Service Candidate Identification from Monolithic Systems based on Execution Traces\n", "abstract": " Monolithic systems increasingly suffer from maintainability and scalability issues as they grow in functionality, size, and complexity. It is widely believed that (micro)service-based architectures can alleviate these problems as each service is supposed to have the following characteristics: clearly defined functionality, sufficient modularity, and the ability to evolve independently. Industrial practices show that service extraction from a legacy monolithic system is labor-intensive and complex. Existing work on service candidate identification aims to group entities of a monolithic system into potential service candidates, but this process has two major challenges: first, it is difficult to extract service candidates with consistent quality; second, it is hard to evaluate the identified service candidates regarding the above three characteristics. To address these challenges, this paper proposes the Functionality-oriented Service\u00a0\u2026", "num_citations": "30\n", "authors": ["119"]}
{"title": "Expression of p53 upregulated modulator of apoptosis (PUMA) and C-myb in gallbladder adenocarcinoma and their pathological significance\n", "abstract": " Purpose                 An increasing number of studies have shown that PUMA and C-myb signaling pathways are involved in various human cancers including colon carcinomas. However, few studies have examined gallbladder cancer specimens, and little is known about the clinical and pathological significance signaling changes may have in gallbladder adenocarcinoma. This study has investigated the expression of PUMA and C-myb in benign and malignant lesions of gallbladder and its pathological significance.                                               Methods                 Tissue specimens from 108 gallbladder adenocarcinoma patients, 46 adjacent tissues, 15 cases of adenomatous polyps, and 35 surgical specimens from chronic cholecystitis patients were routinely paraffin embedded and sectioned. PUMA and C-myb expressions were detected with EnVision immunohistochemistry\u00a0\u2026", "num_citations": "23\n", "authors": ["119"]}
{"title": "An evolutionary approach to software modularity analysis\n", "abstract": " Modularity determines software quality in terms of evolvability, changeability, maintainability, etc. and a module could be a vertical slicing through source code directory structure or class boundary. Given a modularized design, we need to determine whether its implementation realizes the designed modularity. Manually comparing source code modular structure with abstracted design modular structure is tedious and error-prone. In this paper, we present an automated approach to check the conformance of source code modularity to the designed modularity. Our approach uses design structure matrices (DSMs) as a uniform representation; it uses existing tools to automatically derive DSMs from the source code and design, and uses a genetic algorithm to automatically cluster DSMs and check the conformance. We applied our approach to a small canonical software system as a proof of concept experiment. The\u00a0\u2026", "num_citations": "23\n", "authors": ["119"]}
{"title": "Architecture Anti-patterns: Automatically Detectable Violations of Design Principles\n", "abstract": " In large-scale software systems, error-prone or change-prone files rarely stand alone. They are typically architecturally connected and their connections usually exhibit architecture problems causing the propagation of error-proneness or change-proneness. In this paper, we propose and empirically validate a suite of architecture anti-patterns that occur in all large-scale software systems and are involved in high maintenance costs. We define these architecture anti-patterns based on fundamental design principles and Baldwin and Clark's design rule theory. We can automatically detect these anti-patterns by analyzing a project's structural relationships and revision history. Through our analyses of 19 large-scale software projects, we demonstrate that these architecture anti-patterns have significant impact on files' bug-proneness and change-proneness. In particular, we show that 1) files involved in these architecture\u00a0\u2026", "num_citations": "22\n", "authors": ["119"]}
{"title": "Design rule spaces: A new model for representing and analyzing software architecture\n", "abstract": " In this paper, we propose an architecture model called Design Rule Space (DRSpace). We model the architecture of a software system as multiple overlapping DRSpaces, reflecting the fact that any complex software system must contain multiple aspects, features, patterns, etc. We show that this model provides new ways to analyze software quality. In particular, we introduce an Architecture Root detection algorithm that captures DRSpaces containing large numbers of a project's bug-prone files, which are called Architecture Roots (ArchRoots). After investigating ArchRoots calculated from 15 open source projects, the following observations become clear: from 35 to 91 percent of a project's most bug-prone files can be captured by just 5 ArchRoots, meaning that bug-prone files are likely to be architecturally connected. Furthermore, these ArchRoots tend to live in the system for significant periods of time, serving as\u00a0\u2026", "num_citations": "22\n", "authors": ["119"]}
{"title": "Predicting change impact from logical models\n", "abstract": " To improve the ability of predicting the impact scope of a given change, we present two approaches applicable to the maintenance of object-oriented software systems. Our first approach exclusively uses a logical model extracted from UML relations among classes, and our other, hybrid approach additionally considers information mined from version histories. Using the open source Hadoop system, we evaluate our approaches by comparing our impact predictions with predictions generated using existing data mining techniques, and with actual change sets obtained from bug reports. We show that both our approaches produce better predictions when the system is immature and the version history is not well-established, and our hybrid approach produces comparable results with data mining as the system evolves.", "num_citations": "20\n", "authors": ["119"]}
{"title": "Generalizing evolutionary coupling with stochastic dependencies\n", "abstract": " Researchers have leveraged evolutionary coupling derived from revision history to conduct various software analyses, such as software change impact analysis (IA). The problem is that the validity of historical data depends on the recency of changes and varies with different evolution paths-thus, influencing the accuracy of analysis results. In this paper, we formalize evolutionary coupling as a stochastic process using a Markov chain model. By varying the parameters of this model, we define a family of stochastic dependencies that accounts for different types of evolution paths. Each member of this family weighs historical data differently according to their recency and frequency. To assess the utility of this model, we conduct IA on 78 releases of five open source systems, using 16 stochastic dependency types, and compare with the results of several existing approaches. The results show that our stochastic-based IA\u00a0\u2026", "num_citations": "18\n", "authors": ["119"]}
{"title": "A sensitive amperometric acetylcholine biosensor based on carbon nanosphere and acetylcholinesterase modified electrode for detection of pesticide residues\n", "abstract": " A sensitive biosensor based on acetylcholinesterase (AChE) and carbon nanosphere (CNS) immobilized on a glassy carbon electrode was developed for the detection of pesticides by the inhibition of AChE activity. The inhibition effect of the pesticides resulted in a decrease of current response of the acetylthiocholine chloride that was used as a substrate to obtain an electrochemical signal. When applied to the pesticides carbofuran and fenitrothion, the designed biosensor exhibited high sensitivity and low detection limits. The inhibition ratio of carbofuran and fenitrothion were linearly proportional to their concentrations ranging from 0.40 to 4.79 and 6.26 to 125.31 \u00b5g/L, respectively. The theoretical detection limits were found to be 0.082 \u00b5g/L for carbofuran and 2.61 \u00b5g/L for fenitrothion. Furthermore, as the biosensor offers good reproducibility and stability, it could be used for trace detection of pesticides in real samples. Compared with other AChE biosensors, the proposed biosensor was convenient and it exhibited extreme sensitivity to pesticides.", "num_citations": "16\n", "authors": ["119"]}
{"title": "A value-oriented theory of modularity in design\n", "abstract": " We were motivated to undertake the research we describe here by a conversation with two practicing software engineers, who described a dilemma they faced at work. They worked for small company that earned revenues by delivering to a large customer a stream of enhancements to a software tool. The engineers' jobs were to estimate the time to make enhancements and to implement selected enhancements. They were good at estimating, but dissatisfied with the system design, believing that it significantly slowed new feature implementation. They had proposed to management to restructure the tool. However, the management, concerned about disrupting the flow of enhancements thus revenues, and having no clear model of likely benefits, declined. The engineers believed that refactoring would increase the velocity of feature delivery, but they had no sense or ability to analyze the situation quantitatively or to\u00a0\u2026", "num_citations": "16\n", "authors": ["119"]}
{"title": "How security bugs are fixed and what can be improved: an empirical study with Mozilla\n", "abstract": " Study design. To help developers fix security bugs more quickly and easily, there is a need to learn how security bugs are fixed in practice and how it can be improved by answering the following research questions.", "num_citations": "14\n", "authors": ["119"]}
{"title": "A formal model for automated software modularity and evolvability analysis\n", "abstract": " Neither the nature of modularity in software design, characterized as a property of the structure of dependencies among design decisions, or its economic value are adequately well understood. One basic problem is that we do not even have a sufficiently clear definition of what it means for one design decision to depend on another. The main contribution of this work is one possible mathematically precise definition of dependency based on an augmented constraint network model. The model provides an end-to-end account of the connection between modularity and its value in terms of options to make adaptive changes in uncertain and changing design spaces. We demonstrate the validity and theoretical utility of the model, showing that it is consistent with, and provides new insights into, several previously published results in design theory.", "num_citations": "14\n", "authors": ["119"]}
{"title": "Simon: modeling and analysis of design space structures\n", "abstract": " The structure of the coupling relation on design decisions is a key factor influencing the evolvability properties and the economic value of a design. The work of Baldwin and Clark is an important step toward a theory of the relationship between structure and value. A key step to enabling rigorous validation and perhaps the eventual use of their ideas for software engineering is formalization of their model. In this paper, we present a brief overview of such a formal model and a prototype software tool, Simon, implementing it. We present Simon's functions for deriving design structure matrices and computing impacts of changes in design decisions, and we sketch an initial experimental evaluation in the form of a replication study of our earlier analysis of Parnas's 1972 paper on information hiding modularity.", "num_citations": "14\n", "authors": ["119"]}
{"title": "Improving the efficiency of dependency analysis in logical decision models\n", "abstract": " To address the problem that existing software dependency extraction methods do not work on higher-level software artifacts, do not express decisions explicitly, and do not reveal implicit or indirect dependencies, our recent work explored the possibility of formally defining and automatically deriving a pairwise dependence relation from an augmented constraint networks (ACN) that models the assumption relation among design decisions. The current approach is difficult to scale, requiring constraint solving and solution enumeration. We observe that the assumption relation among design decisions for most software systems can be abstractly modeled using a special form of ACN. For these more restrictive, but highly representative models, we present an O(n 3 ) algorithm to derive the dependency relation without solving the constraints. We evaluate our approach by computing design structure matrices for existing\u00a0\u2026", "num_citations": "13\n", "authors": ["119"]}
{"title": "Assessment of contemporary modularization techniques-ACoM'07: Workshop report\n", "abstract": " The effective assessment of emerging modularization technologies plays a pivotal role on: (i) a better understanding of their real benefits and drawbacks when compared to conventional development techniques, and (ii) their effective transfer to mainstream software development. This report is intended to summarize the results of the 1st International Workshop on Assessment of Contemporary Modularization Techniques (ACoM'07) held in Minneapolis, USA, May 22, 2007, as part of the 29th International Conference on Software Engineering (ICSE'07). The main purpose of this workshop was to share and pool the collective experience of people interested in and actively working on assessment of innovative modularization techniques. The workshop consisted of an opening presentation, several paper presentations organized into three technical sessions, and four discussion groups. During the workshop\u00a0\u2026", "num_citations": "13\n", "authors": ["119"]}
{"title": "Experiences applying automated architecture analysis tool suites\n", "abstract": " In this paper, we report our experiences of applying three complementary automated software architecture analysis techniques, supported by a tool suite, called DV8, to 8 industrial projects within a large company. DV8 includes two state-of-the-art architecture-level maintainability metrics-Decoupling Level and Propagation Cost, an architecture flaw detection tool, and an architecture root detection tool. We collected development process data from the project teams as input to these tools, reported the results back to the practitioners, and followed up with telephone conferences and interviews. Our experiences revealed that the metrics scores, quantitative debt analysis, and architecture flaw visualization can effectively bridge the gap between management and development, help them decide if, when, and where to refactor. In particular, the metrics scores, compared against industrial benchmarks, faithfully reflected the\u00a0\u2026", "num_citations": "12\n", "authors": ["119"]}
{"title": "Making the case for a manufacturing execution system for software development\n", "abstract": " Seeking to improve information integration throughout the manufacturing process.", "num_citations": "12\n", "authors": ["119"]}
{"title": "Language features for software evolution and aspect-oriented interfaces: An exploratory study\n", "abstract": " A variety of language features to modularize cross-cutting concerns have recently been discussed, e.g., open modules, annotation-based pointcuts, explicit join points, and quantified-typed events. All of these ideas are essentially a form of aspect-oriented interface between object-oriented and cross-cutting modules, but the representation of this interface differs. Previous works have studied maintenance benefits of AO programs compared to OO programs, by usually looking at a single AO interface. Other works have looked at several AO interfaces, but only on relatively small systems or systems with only one type of aspectual behavior. Thus, there is a need for a study that examines large, realistic systems for several AO interfaces to determine what problems arise and in which interface(s). The main contribution of this work is a rigorous empirical study that evaluates the effectiveness of these proposals for 4\u00a0\u2026", "num_citations": "12\n", "authors": ["119"]}
{"title": "Design rule hierarchy, task parallelism, and dependency analysis in logical decision models\n", "abstract": " A binary augmented constraint network (BACN) allows dependency relationships to be determined without solving constraints. BACN models design decisions as first-class members and expresses how decisions make assumptions upon each other using logical constraints. Pairwise dependency relations (PWDRs) are determined based on the BACN. A design rule hierarchy (DRH) based on assumption relations among design decisions identifies parallelizable tasks within software design. Modules within the same layer of the hierarchy suggest concurrent tasks. Dependencies between layers or within a module suggest possible need for communication. In one configuration, decisions within the top layer of the hierarchy are the most influential design rules, which dominate the rest of the system, and are kept stable. The decisions within subsequent layers assume design decisions in previous layers. The design\u00a0\u2026", "num_citations": "11\n", "authors": ["119"]}
{"title": "Leveraging design structure matrices in software design education\n", "abstract": " Important software design concepts, such as information hiding and separation of concerns, are often conveyed to students informally. The modularity and hence maintainability of student software is difficult to assess. In this paper, we report our study of using design structure matrix (DSM) to assess the modularity of student software by comparing the differences between the DSM representing the intended design and the DSMs representing the software implemented by the students. We applied this approach to a software design class at Drexel University. We found that even though the lab and homework assignments were of small scale, and in many cases, detailed designs were given to the students in the form of UML class diagrams, 74% of the 85 student submissions, although fulfilled the required functionality, introduced unexpected dependencies so that the modules that designed to be independent are\u00a0\u2026", "num_citations": "11\n", "authors": ["119"]}
{"title": "Automatic transformation of UML models into analytical decision models\n", "abstract": " Emerging software dependency models, such as design structure matrices (DSMs), have been used in software design to capture and assess software modular structure and modularization activities. However, thinking and modeling design in terms of decisions and enumerating their dependencies are not straightforward. On the other hand, the Unified Modeling Language (UML) is a well-known and widely-used modeling technique. UML diagrams embody important design decisions and their relations. This paper presents an approach to automatically transform a UML class diagram into a logical design model, from which a DSM model can be automatically derived and the system can be automatically decomposed into modules (independent task assignments). Our approach is to formalize the dependency relations of UML class diagrams, automatically translate these relations into augmented constraint networks (ACN), decompose the ACN model into smaller sub-models, and derive DSM models. We use a small example to illustrate our approach, and evaluate the approach using a UML class diagram reverse engineered from Apache Ant. We show that our approach enables automatic translation of a UML model into analytical decision models and support automatic decomposition of a large system into independent decision modules.", "num_citations": "11\n", "authors": ["119"]}
{"title": "Exploring Blueprints on the Prioritization of Architecturally Relevant Code Anomalies--A Controlled Experiment\n", "abstract": " The progressive insertion of code anomalies in evolving programs may lead to architecture degradation symptoms. Several approaches have been proposed aiming to detect code anomalies in the source code, such as God Class and Shotgun Surgery. However, most of them fail to assist developers on prioritizing code anomalies harmful to the software architecture. These approaches often rely on source code analysis and do not provide developers with useful information to help the prioritization of those anomalies that impact on the architectural design. In this context, this paper presents a controlled experiment aiming at investigating how developers, when supported by architecture blueprints, are able to prioritize different types of code anomalies in terms of their architectural relevance. Our contributions include: (i) quantitative indicators on how the use of blueprints may improve process of prioritizing code\u00a0\u2026", "num_citations": "10\n", "authors": ["119"]}
{"title": "A decision-support system approach to economics-driven modularity evaluation\n", "abstract": " Modularity debt is the most difficult kind of technical debt to quantify and manage. Modularity decay, thus modularity debt, causes huge losses over time in terms of reduced ability to provide new functionality and fix bugs, operational failures, and even canceled projects. As modularity debt accumulates over time, software system managers are often faced with a challenging task of deciding when and whether to refactor, for example, choosing to improve modularity or not. While the costs of refactoring are significant and immediate, their benefits are largely invisible, intangible, and long term. Existing research lacks effective methods to quantify the costs and benefits of refactoring to support refactoring decision making. In this chapter, we present a decision-support system (DSS) approach to the modularity debt management. Using such a system, managers would be able to play out various \u201cwhat-if\u201d scenarios to make\u00a0\u2026", "num_citations": "10\n", "authors": ["119"]}
{"title": "Introducing tool-supported architecture review into software design education\n", "abstract": " While modularity is highly regarded as an important quality of software, it poses an educational dilemma: the true value of modularity is realized only as software evolves, but student homework, assignments and labs, once completed, seldom evolve. In addition, students seldom receive feedback regarding the modularity and evolvability of their designs. Prior work has shown that it is extremely easy for students and junior developers to introduce extra dependencies in their programs. In this paper, we report on a first experiment applying a tool-supported architecture review process in a software design class. To scientifically address this education problem, our first objective is to advance our understanding of why students make these modularity mistakes, and how the mistakes can be corrected. We propose tool-guided architecture review so that modularity problems in students' implementation can be revealed and\u00a0\u2026", "num_citations": "10\n", "authors": ["119"]}
{"title": "Assessing the effectiveness of software modularization techniques through the dynamics of software evolution\n", "abstract": " Given the development of new modularization techniques, such as aspect-oriented programming, featureoriented programming, new assessment techniques are also proposed, such as concern-based metrics [3][4][6] and the metrics based on design structure matrix modeling [2][7] and design rule theory [1]. These metrics assess how concerns are separated in a given software source code or design, or the number of components that are added, deleted or changed between versions. When a modularization technique is chosen, the designer is making some assumptions about how the software will change. For example, choosing to apply observer pattern implies that the designer assumed that multiple observers will be added later. The software will, almost certainly, be better modularized at the time the modularization technique is applied. However, after the software is changed, it is possible that the software does not change as the designer originally assumed, and the software may suffer from modularity degradation due to this discrepancy. Using a suite of metrics to assess a static software artifact may not be sufficient to assess how well a modularization technique is in terms of accommodating changes. It seems necessary to develop software metrics that takes the dynamic of software evolution into consideration. We propose to develop a suite of metrics that measure how easily changes are accommodated, eg by measuring the average number of modules touched by the modification requests between versions. We call such metrics as dynamic metrics. Using these dynamic metrics, the designer can assess whether the software is changing\u00a0\u2026", "num_citations": "10\n", "authors": ["119"]}
{"title": "Investigating the impact of multiple dependency structures on software defects\n", "abstract": " Over the past decades, numerous approaches were proposed to help practitioner to predict or locate defective files. These techniques often use syntactic dependency, history co-change relation, or semantic similarity. The problem is that, it remains unclear whether these different dependency relations will present similar accuracy in terms of defect prediction and localization. In this paper, we present our systematic investigation of this question from the perspective of software architecture. Considering files involved in each dependency type as an individual design space, we model such a design space using one DRSpace. We derived 3 DRSpaces for each of the 117 Apache open source projects, with 643,079 revision commits and 101,364 bug reports in total, and calculated their interactions with defective files. The experiment results are surprising: the three dependency types present significantly different\u00a0\u2026", "num_citations": "9\n", "authors": ["119"]}
{"title": "Software Architecture Measurement\u2014Experiences from a Multinational Company\n", "abstract": " In this paper, we present our 4-year experience of creating, evolving, and validating an automated software architecture measurement system within Huawei. This system is centered around a comprehensive scale called the Standard Architecture Index (SAI), which is composed of a number of measures, each reflecting a recurring architecture problem. Development teams use this as a guide to figure out how to achieve a better score by addressing the underlying problems. The measurement practice thus motivates desired behaviors and outcomes. In this paper, we present our experience of creating and validating SAI 1.0 and 2.0, which has been adopted as the enterprise-wide standard, and our directions towards SAI 3.0. We will describe how we got the development teams to accept and apply SAI through pilot studies, constantly adjusting the formula based on feedback, and correlating SAI scores with\u00a0\u2026", "num_citations": "9\n", "authors": ["119"]}
{"title": "A preliminary study of quantified, typed events\n", "abstract": " In previous work, Rajan and Leavens presented the design of Ptolemy, a language which incorporates the notion of quantified, typed events for improved separation of concerns. In this work, we present an empirical study to evaluate the effectiveness of Ptolemy\u2019s design by applying it to a series of architectural releases of a software product line (SPL) for handling multimedia on mobile devices, called MobileMedia, and the comparison and contrast of our findings with a previous in-depth analysis by Figueiredo et al of the objectoriented and aspect-oriented designs of the same system. Our comparative analysis using quantitative metrics proposed by Chidambar and Kemerer (and subsequently used by Garcia et al) and a net-options value analysis used earlier by Cai, Sullivan and Lopes shows that quantified, typed events significantly improve the separation of concerns and further decouple components in the MobileMedia design.", "num_citations": "9\n", "authors": ["119"]}
{"title": "Inhibition of retinopathy of prematurity in rat by intravitreal injection of sorafenib\n", "abstract": " AIMTo investigate the effect of intravitreal injection administered sorafenib, a multikinase inhibitor, in a rat model of oxygen-induced retinopathy (OIR).METHODSSeven-day-old Sprague-Dawley rats (n= 144) were randomly assigned to six groups. Group A received normal partial oxygen pressure and groups B, C, D, E and F were exposed to hyperoxia (75\u00b12)% from postnatal 7d (P7) to P12 to induce retinopathy of prematurity. The rats in groups C, D, E and F were received intravitreal injections of either vehicle (DMSO) or sorafenib at P12 (5, 20 and 80 \u00b5g, respectively). Then they returned to normoxia after P12. The retinas were whole-mounted and imaged with a confocal microscopy. The vascular branching points were counted to quantify neovascularization at P17. Cross-sections of the retina were stained with hematoxylin and eosin (HE). The nuclei of new vessels breaking the internal limiting membrane were\u00a0\u2026", "num_citations": "8\n", "authors": ["119"]}
{"title": "ENRE: a tool framework for extensible eNtity relation extraction\n", "abstract": " Understanding the dependencies among code entities is fundamental to many software analysis tools and techniques. However, with the emergence of new programming languages and paradigms, the increasingly common practice of writing systems in multiple languages, and the increasing popularity of dynamic languages, no existing framework can reliably extract this information. That is, no tools exist to accurately extract dependencies from systems written in multiple and dynamic languages. To address this problem, we have designed and implemented the Extensible eNtity Relation Extraction (ENRE) framework. ENRE supports the extraction of entities and their dependencies from systems written in multiple languages, enables the customization of dependencies of interest to the user, and makes implicit dependencies explicit. To demonstrate feasibility of this framework, we developed two ENRE instances\u00a0\u2026", "num_citations": "7\n", "authors": ["119"]}
{"title": "Experimental study on pretreatment of maize stalk cellulose with H2O2 and alkaline.\n", "abstract": " In this paper, the effect of different concentrations of H 2 O 2 together with 5% NaOH solution on pretreatment of maize maize Subject Category: Commodities and Products", "num_citations": "7\n", "authors": ["119"]}
{"title": "Change impact analysis with stochastic dependencies\n", "abstract": " Researchers have shown that software change impact analysis (IA) can be improved by investigating logical coupling embodied in revision histories. However, prevailing historybased IA techniques do not take the temporal dimension of revision history into consideration to account for design evolution. In this paper, we formalize logical coupling as a stochastic process using a Markov chain model. By varying the length and the smoothing function of the model, we define a family of stochastic dependencies. Each member of this family weights historical data differently according to their recency and frequency. To assess its utility, we conduct IA on 86 releases of five open source systems by using 16 members of the stochastic dependency family and compare with the result of several existing approaches. Our results show that in four out of the five systems, our stochastic-based IA technique is the most accurate.", "num_citations": "7\n", "authors": ["119"]}
{"title": "Design rule hierarchy and analytical decision model transformation\n", "abstract": " We present two contributions to help make design rule theory operable in software engineering practice. First, we develop an approach to automatically transform a design, expressed in the prevailing unified modeling language, into an augmented constraint network (ACN), from which a design structure matrix (DSM) can be generated. Using ACNs formalizes design rule theory and using DSMS enables option-based reasoning. Second, we design an algorithm to derive a design rule hierarchy from an ACN, revealing the impact scope of each design rule and identifying the independent modules. This hierarchy defines an order in which decisions can be made to maximize task parallelism, constrained by the dependency structure of the architecture. We evaluate the accuracy and scalability of our approaches using both small, but canonical, systems and the open-source Apache Ant system.", "num_citations": "7\n", "authors": ["119"]}
{"title": "Evolution analysis of large-scale software systems using design structure matrices and design rule theory\n", "abstract": " Designers often seek modular architectures to better accommodate expected changes and to enable parallel development. However, we lack a formal theory and model of modularity and software evolution, which can be used for description, prediction, and prescription. According to Baldwin and Clark\u2019s [1] theory, modular architectures add value to system designs by creating options to improve the system by substituting or experimenting on individual modules. In this paper, we evaluate their theory by looking at the design evolution of two software product platforms through the modeling lens of design structure matrices (DSMs) and design rule theory. Our analysis shows that DSM models and options theory can explain how real-world modularization activities in one case allowed for different rates of evolution in different software modules and in another case conferred distinct strategic advantages on a firm (by permitting substitution of an at-risk software module without substantial change to the rest of the system). The experiment supports our hypothesis that these formal models and theory can account for important aspects of software design evolution in large-scale systems.", "num_citations": "7\n", "authors": ["119"]}
{"title": "Machine tool\n", "abstract": " A machine tool, particularly a hand machine tool, including an indexing mechanism which is switchable by an actuating element via at least one coupling element, and including at least one spring element arranged in the flux of force between the actuating element and the coupling element. The spring element in the flux of force from the actuating element in the direction of the coupling element is fixedly connected to a first component in at least two actuating directions, and in the opposite direction of the flux of force, is fixedly connected to a second component at least in the two actuating directions.", "num_citations": "7\n", "authors": ["119"]}
{"title": "Architecture-sensitive heuristics for prioritizing critical code anomalies\n", "abstract": " The progressive insertion of code anomalies in evolving software systems might lead to architecture degradation symptoms. Code anomalies are particularly harmful when they contribute to the architecture degradation. Although several approaches have been proposed aiming to detect anomalies in the source code, most of them fail to assist developers when prioritizing code anomalies critical to the architectural design. Blueprints of the architecture design are artifacts often available in industry software projects. However, such blueprints are rarely explored to support the prioritization of code anomalies in terms of their architecture relevance. This paper proposes and evaluates 2 sets of blueprint-based heuristics for supporting the prioritization of critical code anomalies. The prioritization is based on their potential impact on revealing architectural drift problems. The heuristics allow developers prioritizing critical\u00a0\u2026", "num_citations": "6\n", "authors": ["119"]}
{"title": "Detecting design defects caused by design rule violations\n", "abstract": " Research has shown that unintended violations of dependencies can incur modularity decay, higher maintenance cost, and software defects. However, dependency violations may be undetected by traditional software verification and validation techniques. In this paper, we present an approach to detect potential design defects caused by the violation of design rules. We identify the patterns of how different components change together to implement modification requests, and use a logical model to predict change scope according to the design rule theory. We then calculate the differences between the predicted and actual co-change patterns to reveal potential defects. To evaluate our approach, we investigated the version history of 15 releases of Hadoop and 9 releases of Derby. Our approach revealed such issues as poorly designed inheritance hierarchies, tightly coupled cyclical dependencies, and code clones. Some problems we identified were indeed refactored in later versions, validating the effectiveness of our approach.", "num_citations": "6\n", "authors": ["119"]}
{"title": "Software architecture health monitor\n", "abstract": " In this paper, we first discuss the concept of architecture debt and how this debt grows in virtually every software-intensive project. Next we propose a methodology for developers to monitor the health of a project's architecture through an analysis of the development artifacts that a project produces. Our objective is to monitor and manage architecture debt by leveraging an architecture model that we proposed recently, called the Design Rule Space (DRSpace). We use DRSpaces to split a complex system into smaller subsystems based on features, patterns, refactoring targets, etc., so that we can monitor and analyze the evolution and interaction of each subsystem separately. We also employ a recently proposed architectural metric---Decoupling Level---to quantitatively monitor changes in a project's overall level of architecture maintainability. Using these tools, we describe our vision for a software architecture\"\u00a0\u2026", "num_citations": "5\n", "authors": ["119"]}
{"title": "Measuring Software Design Modularity\n", "abstract": " Common metrics of design modularity include coupling, cohesion, separation of concerns, etc. Large number of modularity assessment work has been done at the level of source code as retrospective empirical studies, but few at design level. In addition, these metrics are limited in terms of showing how tasks can be assigned to independent groups, and how the design enables parallel development. In fact, the term module used in traditional modularity assessment is not always consistent with Parnas\u2019s canonical definition: independent task assignment. In this paper, we propose to measure modularity in design in term of independent task modules. The idea is to use design structure matrices to represent a design, automatically cluster the DSM to reveal independent modules, and assess to what extent the design can be independently implemented or changed.", "num_citations": "5\n", "authors": ["119"]}
{"title": "Rule spaces and architecture root detection\n", "abstract": " Errors in software may be detected via the use of design rule spaces and architecture root detection. Design rule spaces may reveal multiple overlapping modular structures of a software system, and reveal structural relations among error-prone files and structural problems contributing to error-proneness. Root detection may extract a few groups of architecturally connected files, which may be connected through problematic architecture relations that propagate errors among these files, and thus influence system error-proneness. The root detector may locate the core architecturally connected file groups that contribute to the error-proneness of a system. The root detection process may, beginning with a set of error-prone files, search and link other files that are architecturally related. The output of the root detection process may be a set of design rule spaces ordered by the number of error-prone contained therein.", "num_citations": "3\n", "authors": ["119"]}
{"title": "Detecting source code changes to maintain the consistence of behavioral model\n", "abstract": " It is well-known that as software system evolves, the source code tends to deviate from its design model so that maintaining their consistence is challenging. Our objective is to detect code changes that influence designed program behaviour which are referred as design level changes and update the behavioural model timely and automatically to maintain consistence. We propose an approach that filters out low-level source code changes that do not influence program behaviour, abstracts code changes into updating operations for behavioral model, and automates the integration and update of activity diagrams to maintain consistence. We've recognised that it is not uncommon for developers to introduce quick and dirty implementation that unnecessarily increases program complexity or introduces suboptimal behaviour changes. So while merging code changes into behaviour model, our approach also calculates\u00a0\u2026", "num_citations": "3\n", "authors": ["119"]}
{"title": "Road fugitive dust emission inventory in Huhhot Urban Area\n", "abstract": " PM10 (particle matter less than 10\u03bcm) with fugitive road dust is one of the main sources has become the primary pollutant which influence Chinese urban air quality in recent years. Emission inventory is the basis of air quality modeling, cost-benefit control, regulation planning and environmental management. In this study, silt loading was sampled for 30 roads and traffic volume was investigated. AP-42 emission factor was used to calculate the emission of road fugitive dust PM10 in Huhhot urban area. GIS based inventory was completed. Road fugitive dust PM10 emission was 22 715t in 2006. The emission factor for different types of roads were localring roadcollectorsminor arterialmajor arterial, and the emission strength for different types of roads were ring roadmajor arterialminor arterialcollectorslocal. The emission strength within in ring road was high and the highest emission strength is in the down town area.", "num_citations": "3\n", "authors": ["119"]}
{"title": "On the interplay of architecture and collaboration on software evolution and maintenance\n", "abstract": " With the growing popularity of globally distributed teams in software development, software architectures 1 must be designed and maintained with an organizational perspective in mind. Software architects often decompose systems into modules that are intended to be developed and maintained independently and in parallel [96, 156]. However, prevailing techniques for modularizing software designs often rely on intuition and experience based on informal principles and theories (eg information hiding principle [156], design rule theory [22]), leading to modules that are not guaranteed to be independent tasks. Even when a design is well modularized in the beginning, the software can evolve in ways that deviate from the designed modular structure\u2014making tasks that are initially designed to be independent, not actually independent. The problem is that prevailing design models and metrics (eg the unified modeling language [153, 164], coupling and cohesion [64,179]):1. are not designed for identifying independent modules for parallel work, 2. do not account for organizational structure, and 3. do not facilitate the early detection of design problems that harm task parallelism.", "num_citations": "3\n", "authors": ["119"]}
{"title": "Influence of heat-and mass-transfer coupling on the optimal performance of a non-isothermal chemical engine\n", "abstract": " The cyclic model of a non-isothermal chemical engine operated between two reservoirs with different temperatures and chemical potentials is established, in which the irreversibilities resulting from the heat and mass transfer between the working fluid and the reservoirs are taken into account. Expressions for the power output and efficiency of the engine are analytically derived and used to analyze the performance characteristics of the engine at the maximum power output. The general characteristics of the efficiency of the engine are searched in detail. The optimal criteria for some important parameters, such as the power output and efficiency, are obtained and the reasonably operating region of the engine is determined. Some interesting cases are specially discussed. The results obtained here can reveal the performance characteristics of a non-isothermal chemical engine affected by the irreversibilities of heat- and mass-transfer coupling.", "num_citations": "3\n", "authors": ["119"]}
{"title": "Assessing design modularity and stability using analytical decision models\n", "abstract": " Various new modularization techniques, such as aspectoriented (AO) programming, are proposed to improve software stability and modularity, and there is a pressing need to assess tradeoffs of modularization alternatives from highlevel design models instead of source code. We present the following contributions in this context: we first present a technique to automatically transform a UML component diagram into analytical decision models, the augmented constraint network (ACN) and design structure matrix (DSM). Second, we define and formalize a suite of design stability and modularity metrics, based on ACN and DSM modeling. These metrics improve prevailing metrics by taking environmental conditions and option reasoning into consideration. Finally, we evaluate our techniques using eight OO and AO releases of a software product line. We show that these metrics allow us to assess which technique generates a more stable, modular design, given a series of envisioned changes, verified by previous source code analysis.", "num_citations": "3\n", "authors": ["119"]}
{"title": "A case study of integrating design rule theory and analytical decision models into a software development process\n", "abstract": " The interdependencies of design decisions, made at various stages of software development, determine the modular structure in design, and hence the maintainability and evolvability of the implemented software product. It has been understood that the key step to decompose a system into modules is to identify the design rules that decouple otherwise coupled design decisions. Emerging analytical decision models, such as design structure matrices (DSMs) and augmented constraint networks (ACNs) have been used to explicitly model design rules and to analyze software modular structure. In this paper, we present a case study of integrating the design rule theory and these analytical decision models into the development process of a real project, to govern the creation and realization of design rules and to monitor the modular structure of the system throughout the development life cycle. Our experience shows the feasibility and benefits of the integrated process: this integration allowed us to detect poorly-modularized design before coding, to make the design rules and their decoupling effects explicit in both design and implementation, and to detect improper implementation by checking modularity deviation between design and source code.", "num_citations": "3\n", "authors": ["119"]}
{"title": "Assessing an architecture's ability to support feature evolution\n", "abstract": " Enabling rapid feature delivery is essential for product success and is therefore a goal of software architecture design. But how can we determine if and to what extent an architecture is\" good enough\" to support feature addition and evolution, or determine if a refactoring effort is successful in that features can be added more easily? In this paper, we contribute a concept called the Feature Space, and a formal definition of Feature Dependency, derived from a software project's revision history. We capture the dependency relations among the features of a system in a feature dependency structure matrix (FDSM), using features as first-class design elements. We also propose a Feature Decoupling Level (FDL) metric that can be used to measure the level of independence among features. Our investigation of 17 open source projects shows that files within each feature space are much more likely to be changed together\u00a0\u2026", "num_citations": "2\n", "authors": ["119"]}
{"title": "Detecting design rule violations\n", "abstract": " In this paper, we present an approach to detect design rule violations that could cause software defects, modularity decay, or expensive refactorings. Our approach is to compute the discrepancies between how components should change together based on the modular structure framed by design rules, and how components actually changed together revealed by how modification requests were fulfilled. Our contributions include a design violation detection framework and a design-rule based impact scope prediction algorithm. We evaluated our approach using the version history of three large-scale open source software projects. We examined all identified violations to check whether they were refactored or recognized by the developers in later versions. Our results show that (1) on average 73% of the violations we identified were either recognized or refactored in later releases (when using. 5 confidence and varying support from 2 to 10 in Hadoop);(2) our approach can identify problematic design violations much earlier than manual identification by developers; and (3) the identified violations cover multiple bad smells, such as tight coupling and code clone.", "num_citations": "2\n", "authors": ["119"]}
{"title": "Active Hotspot: An Issue-Oriented Model to Monitor Software Evolution and Degradation\n", "abstract": " Architecture degradation has a strong negative impact on software quality and can result in significant losses. Severe software degradation does not happen overnight. Software evolves continuously, through numerous issues, fixing bugs and adding new features, and architecture flaws emerge quietly and largely unnoticed until they grow in scope and significance when the system becomes difficult to maintain. Developers are largely unaware of these flaws or the accumulating debt as they are focused on their immediate tasks of address individual issues. As a consequence, the cumulative impacts of their activities, as they affect the architecture, go unnoticed. To detect these problems early and prevent them from accumulating into severe ones we propose to monitor software evolution by tracking the interactions among files revised to address issues. In particular, we propose and show how we can automatically\u00a0\u2026", "num_citations": "1\n", "authors": ["119"]}
{"title": "Understanding evolutionary coupling by fine-grained co-change relationship analysis\n", "abstract": " Frequent co-changes to multiple files, i.e., evolutionary coupling, can demonstrate active relations among files, explicit or implicit. Although evolutionary coupling has been used to analyze software quality, there is no systematic study on the categorization of frequent co-changes between files which may used for characterizing various quality problems. In this paper, we report an empirical study on 27,087 co-change commits of 6 open-source systems with the purpose of understanding the observed evolutionary coupling. We extracted fine-grained change information from version control system to investigate whether two files exhibit particular kinds of co-change relationships. We consider code changes on 5 types of program entities (i.e., field, method, control statement, non-control statement, and class) and identified 6 types of dominating co-change relationships. Our manual analysis showed that each of the 6\u00a0\u2026", "num_citations": "1\n", "authors": ["119"]}
{"title": "The birth, growth, death and rejuvenation of software maintenance communities\n", "abstract": " Background: Though much research has been conducted to investigate software maintenance activities, there has been little work charactering maintenance files as a community and exploring the evolution of this community. Aims: The goal of our research is to identify maintenance communities and monitor their evolution-birth, growth, death and rejuvenation. Method: In this paper, we leveraged a social community detection algorithm---clique prelocation method (CPM)---to identify file communities. Then we implemented an algorithm to detect new communities, active communities, inactive communities and reactivated communities by cumulatively detecting and constantly comparing communities in time sequences. Results: Based on our analysis of 14 open-source projects, we found that new communities are mostly caused by bug and improvement issues. An active community can be vigorous, on and off\u00a0\u2026", "num_citations": "1\n", "authors": ["119"]}
{"title": "Software design spaces: Logical modeling and formal dependence analysis\n", "abstract": " We lack a useful, formal theory of modularity in abstract software design. A missing key is a framework for the abstract representation of software design spaces that supports analysis of design decision coupling structures. We contribute such a framework. We represent design spaces as constraint networks and develop a concept of design decision coupling based on the minimal change sets of a variable. This work supports derivation, from logical models, of design structure matrices (DSM\u2019s), for which we have a promising but inadequate theory of modularity. We present complexity results and a brute force algorithm. To test for potential software engineering utility, we analyzed the design spaces of Parnas\u2019s 1972 information hiding paper, with positive results that were surprising in several ways.", "num_citations": "1\n", "authors": ["119"]}
{"title": "Stochastic Optimal Switching: Theory, Architecture, Prototype\n", "abstract": " Information hiding modularity (IHM) creates valuable options to switch one hidden module to another. The binding time for such switching is generally design time: as conditions change, new modules are created and switched in to keep a system current. Run-time switching is a clear analog and is sometimes beneficial. However, in face of switching costs and uncertainty about future conditions, when to switch is not clear. In recent work, we showed that it might be possible to estimate the economic value of design-time switching options created by IHM using real options theory. In this paper, we explore the flexibility to switch dynamically with a focus on optimal timing of decisions to switch. Our contribution is the idea that options theory holds an answer: Deciding when to switch under uncertainty is tantamount to deciding when to exercise a real option, which, in turn, is a special case stopping problem in stochastic optimal control. We give mathematical formulation of the problem and a reflective architecture for implementing our approach. As a feasibility test, we present a prototype that automates switching between dense and sparse matrix representations in an open implementation style based on estimates of the uncertainty in client behavior derived from runtime profiling. Our insight has potential relevance to the design of adaptive middleware and security and survivability control systems. The thought is to make internal switching decisions contingent on the ongoing resolution of monitored endogenous and exogenous uncertainties, such as the likelihood of system-level failure or security threat level.", "num_citations": "1\n", "authors": ["119"]}