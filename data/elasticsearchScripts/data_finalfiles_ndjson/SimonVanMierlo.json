{"title": "AToMPM: A web-based modeling environment\n", "abstract": " We introduce AToMPM, an open-source framework for designing domain-specific modeling environments, performing model transformations, manipulating and managing models. It runs completely over the web, making it independent from any operating system, platform, or device it may execute on. AToMPM offers an online collaborative experience for modeling. Its unique architecture makes the framework flexible and completely customizable, given that AToMPM is modeled by itself, and external applications can be easily integrated. Demo: https://www. youtube. com/watch? v= iBbdpmpwn6M", "num_citations": "167\n", "authors": ["1851"]}
{"title": "Debugging Parallel DEVS\n", "abstract": " To this day, debugging support for the DEVS formalism has been provided, at best, in an ad-hoc way. The intricacies of dealing with the interplay of different notions of (simulated) time, formalism semantics, and user input have not been thoroughly investigated. This paper presents a visual modeling, simulation, and debugging environment for Parallel DEVS, which builds on a theoretical foundation for debugging DEVS models. We take inspiration from both code debugging and the simulation world to model our environment; we transpose a set of useful code debugging concepts onto Parallel DEVS, and combine those with simulation-specific operations, such as as-fast-as-possible simulation and (scaled) real-time execution. Apart from these common debugging operations, we introduce new features to the debugging of Parallel DEVS models, such as \u201cgod events,\u201d which can alter the model state during simulation\u00a0\u2026", "num_citations": "32\n", "authors": ["1851"]}
{"title": "Multi-level modelling in the Modelverse\n", "abstract": " In this paper, we introduce the Modelverse, a metamodelling framework and model repository. It clearly distinguishes and supports physical and linguistic conformance relations and allows for deep characterization and deep instantiation using potency. We introduce language fragments, which are reusable pieces of a language definition, consisting of an abstract syntax definition, as well as the definition of concrete syntax, semantics, and a mapping onto physical (representational) concepts, as suitable concepts for modular language design and reuse. We focus on multi-level modelling, and use the Modelverse to model a four-level language hierarchy, demonstrating its deep instantiation and characterization capabilities, as well as the use of modelling language fragments.", "num_citations": "29\n", "authors": ["1851"]}
{"title": "SCCD: SCXML Extended with Class Diagrams\n", "abstract": " We introduce the SCCD formalism, which is a hybrid of Statecharts and Class Diagrams, and its SCCDXML representation, which is an extension of SCXML. SCCD facilitates the specification of complex timed, reactive, interactive discrete-event, dynamic-structure systems (eg, complex user interfaces, control systems), as we demonstrate using a representative example. We present an SCCD compiler that supports (a) semantic variation points for different Statecharts variants (eg, Rhapsody and Statemate),(b) code generation for different platforms (eg, Tkinter and HTML/Javascript), and (c) code generation for different families of runtimes (eg, event-based platforms and game loops). Furthermore, we discuss the history and future work of SCCD to reveal our research agenda.", "num_citations": "17\n", "authors": ["1851"]}
{"title": "Explicit Modelling of a Parallel DEVS Experimentation Environment\n", "abstract": " In this paper, we explicitly model an interactive debugging and experimentation environment for the simulation of Parallel DEVS models. We take inspiration from the code debugging world, as well as from the simulation world (including different notions of time) to model our environment. We support both as-fast-as-possible and (scaled) real-time execution of the model. To achieve this, the PythonPDEVS simulator is de/re-constructed: the modal part of the simulator, as well as the debugging operations, are modelled using the Statecharts formalism. These models are combined, resulting in a model of the timed, reactive behaviour of a debugger for Parallel DEVS, which is used to regenerate the code of the simulator. It is then combined with a modelling and simulation environment to visually model, simulate, and debug Parallel DEVS models.", "num_citations": "15\n", "authors": ["1851"]}
{"title": "Explicit Modelling of a CBD Experimentation Environment\n", "abstract": " In this paper, we explicitly model an experimentation and debugging environment for the interactive simulation of Causal Block Diagram (CBD) models. This is achieved by deconstructing the coded CBD simulator and subsequently reconstructing it. During this re-construction, the environment, as well as the modal part of the simulator, are modelled using the Statecharts formalism. These models are combined, resulting in a model of the timed, reactive behaviour of our experimentation and debugging environment for CBDs. In the model of our environment, inspiration is taken from the code debugging world, as well as from the simulation world (including different notions of time). The environment is implemented using a client-server architecture, with a browser front-end.", "num_citations": "15\n", "authors": ["1851"]}
{"title": "Cloud-based multi-view modeling environments\n", "abstract": " Complex systems typically involve many stakeholder groups working in a coordinated manner on different aspects of a system. In Model-Driven Engineering (MDE), stakeholders work on models in order to design, transform, simulate, and analyze the system. Therefore, there is a growing need for collaborative platforms for modelers to work together. A cloud-based system allows them to concurrently work together. This chapter presents the challenges for building such environments. It also presents the architecture of a cloud-based multi-view modeling environment based on AToMPM.", "num_citations": "13\n", "authors": ["1851"]}
{"title": "Domain-specific modelling for human\u2013computer interaction\n", "abstract": " Model-driven engineering (MDE) is an important enabler in the development of complex, reactive, often real-time, and software-intensive systems, as it shifts the level of specification from computing concepts (the \u201chow\u201d) to conceptual models or abstractions in the problem domain (the \u201cwhat\u201d). Domain-specific modelling (DSM) in particular allows to specify these models in a domain-specific modelling language (DSML), using concepts and notations of a specific domain. It allows the use of a custom visual syntax which is closer to the problem domain and therefore more intuitive. Models created in DSMLs are used, among others, for simulation, (formal) analysis, documentation, and code synthesis for different platforms. The goal is to enable domain experts, such as a power plant engineer, to develop, to understand, and to verify models more easily, without having to use concepts outside of their own domain\u00a0\u2026", "num_citations": "12\n", "authors": ["1851"]}
{"title": "Explicitly Modelling Model Debugging Environments\n", "abstract": " Programmers spend a large portion of their time debugging the code they write. This is supported by a variety of debugging techniques such as pause/resume, the setting of breakpoints, stepping over functions, etc. Today, modelling and simulation become increasingly important enablers in the development of complex, reactive, often real-time, software-intensive systems, as they allow rapid prototyping and early validation of designs. Simulation models, though at a higher level of abstraction than code, can however still contain bugs. There is hence a need for model-level debuggers, that are adapted to the semantics of the modelling formalism (s) used, and can properly deal with the timed nature of many of these models. This paper presents a method for constructing model debugging environments for deterministic, operational formalisms. In order to manage the inherent complexity, the timed, reactive behaviour of the debugger is modelled explicitly. The feasibility of the approach is demonstrated by constructing a visual debugging environment for Causal-Block Diagrams.", "num_citations": "12\n", "authors": ["1851"]}
{"title": "A multi-paradigm modelling approach to live modelling\n", "abstract": " To develop complex systems and tackle their inherent complexity, (executable) modelling takes a prominent role in the development cycle. But whereas good tool support exists for programming, tools for executable modelling have not yet reached the same level of functionality and maturity. In particular, live programming is seeing increasing support in programming tools, allowing users to dynamically change the source code of a running application. This significantly reduces the edit\u2013compile\u2013debug cycle and grants the ability to gauge the effect of code changes instantly, aiding in debugging and code comprehension in general. In the modelling domain, however, live modelling only has limited support for a few formalisms. In this paper, we propose a Multi-Paradigm Modelling approach to add liveness to modelling languages in a generic way, which is reusable across multiple formalisms. Live\u00a0\u2026", "num_citations": "11\n", "authors": ["1851"]}
{"title": "Concrete syntax: A multi-paradigm modelling approach\n", "abstract": " Domain-Specific Modelling Languages (DSLs) allow domain experts to create models using abstractions they are most familiar with. A DSL's syntax is specified in two parts: the abstract syntax defines the language's concepts and their allowed combinations, and the concrete syntax defines how those concepts are presented to the user (typically using a graphical or textual notation). However important concrete syntax is for the usability of the language, current modelling tools offer limited possibilities for defining the mapping between abstract and concrete syntax. Often, the language designer is restricted to defining a single icon representation of each concept, which is then rendered to the user in a (fixed) graphical interface. This paper presents a framework that explicitly models the bi-directional mapping between the abstract and concrete syntax, thereby making these restrictions easy to overcome. It is more\u00a0\u2026", "num_citations": "9\n", "authors": ["1851"]}
{"title": "A multi-paradigm modelling approach for engineering model debugging environments\n", "abstract": " This chapter introduces the thesis by providing the motivation, stating the contributions, and by explaining the structure of this document.", "num_citations": "8\n", "authors": ["1851"]}
{"title": "Towards adaptive abstraction in agent based simulation\n", "abstract": " Humans often switch between different levels of abstraction when reasoning about salient properties of systems with complex dynamics. In this paper, we study and compare multiple modelling and simulation techniques for switching between abstractions. This improves insight and explainability as well as simulation performance, while still producing identical answers to questions about properties. Traffic flow modelled using an Agent Based Simulation formalism is used to demonstrate the introduced concepts. The technique requires explicit models (1) of the dynamics of both individual cars and of emergent \"jams\", (2) of the conditions -often involving complex temporal patterns- under which switching between the levels of abstraction becomes possible/necessary and (3) of the state initialization after a switch. While aggregation is natural when going from detailed to abstract, the opposite direction requires\u00a0\u2026", "num_citations": "6\n", "authors": ["1851"]}
{"title": "A multi-paradigm approach for modelling service interactions in model-driven engineering processes\n", "abstract": " To tackle the growing complexity of engineered systems, Model-Driven Engineering (MDE) proposes to promote models to first-class citizens in the development process. Within MDE, Multi-Paradigm Modelling (MPM) advocates modelling every relevant aspect of a system explicitly, using the most appropriate formalism (s), at the most appropriate level (s) of abstraction, while explicitly modelling the underlying process. Often, activities of the process require interaction with (domain-specific) engineering and modelling tools. These interactions are, however, typically captured in scripts and program code, which is ill-suited for describing the timed, reactive, and concurrent behaviour of these protocols. Additionally, formal analysis of the overall process is limited due to the incorporation of black-box activities. In this paper, we propose an approach for the explicit modelling of service interaction protocols in the activities of MDE processes. We also explicitly model the execution semantics of our process model, to promote reuse and allow for future analysability. For both purposes, we propose to use SCCD, a Statecharts variant, resulting in a unified and concise formalism.", "num_citations": "6\n", "authors": ["1851"]}
{"title": "Integrating a neutral action language in a DEVS modelling environment.\n", "abstract": " Visual environments for the modelling and simulation of complex, software-intensive systems are increasingly popular. While visual languages have many advantages, they may not be appropriate to render all details of a Discrete EVent system Specification (DEVS) model. Textual may be more appropriate, both to completely describe all details of a DEVS model (ie, the content of transition and output functions), and to make the specification independent of the implementation platform (ie, simulation implementation language).In this paper, we propose two textual notations that are used as part of an integrated modelling and simulation environment for the Parallel DEVS formalism. Both notations allow the specification of DEVS functions by means of neutral action code. DEVSPro uses Python-like textual syntax and supports the full power of Parallel DEVS. From this neutral specification, simulator-specific code is synthesized. DEVSLang supports blended textual/visual modelling. It is more restricted in expressiveness to match the limited expressiveness of visual notations. For example, the sequential states in an Atomic model must be explicitly enumerated. Visual DEVSLang models are transformed to their textual form in order to carry out syntactic and semantic checks. Possible detected errors are fed back to the visual modelling environment allowing the modeller to make changes directly in the source model. DEVSLang models are further translated automatically to DEVSPro models to allow for possible combination with DEVSPro models and subsequent analysis and simulation.", "num_citations": "6\n", "authors": ["1851"]}
{"title": "Modelverse specification\n", "abstract": " In this technical report, we present the specification of the Modelverse, a self-describable environment for multi-paradigm modelling. This specification defines how all hardcoded aspects of the Modelverse are defined, necessary to create a compliant Modelverse implementation. Apart from the core specification of the Modelverse, we also present the standardized API used between the different components. We do not commit ourselves to a single language, as this specification can be implemented in any language.", "num_citations": "5\n", "authors": ["1851"]}
{"title": "Explicit Modelling of Model Debugging and Experimentation\n", "abstract": " In this paper, I present the topic of my PhD: the explicit modelling of model debugging and experimentation. Semantics of modelling formalisms include non-determinism, concurrency, and hierarchy, amongst others. Moreover, simulated time can have different relations to the wall-clock time and supports certain operations such as pausing. Providing debugging support for model simulations is non-trivial using traditional software development techniques. We therefore propose to model simulators, their debuggers, and environments explicitly.", "num_citations": "5\n", "authors": ["1851"]}
{"title": "Exploring Validity Frames in Practice\n", "abstract": " Model-Based Systems Engineering (MBSE) provides workflows, methods, techniques and tools for optimal simulation-based design and realization of complex Software-Intensive, Cyber-Physical Systems. One of the key benefits of this approach is that the behavior of the realized system can be reasoned about and predicted in-silico, before any prototype has been developed. Design models are increasingly used after the system has been realized as well. For example, a (design) digital twin can be used for runtime monitoring to detect and diagnose discrepancies between the simulated and realized system. Inconsistencies may arise, however, because models were used at design time that are not valid within the operating context of the realized system. It is often left to the domain expert to ensure that the models used are valid with respect to their realized counterpart. Due to system complexity and\u00a0\u2026", "num_citations": "4\n", "authors": ["1851"]}
{"title": "Adding rule-based model transformation to modelling languages in metaedit+\n", "abstract": " MetaEdit+ is a commercial tool by MetaCase for creating domain-specific, syntax-directed visual modelling environments. MetaEdit+ synthesizes such environments from user-provided metamodels and contains a Generator Editor for code/report generation. An API is provided to allow external manipulation of models through SOAP. Currently, the MetaEdit+ tool does not natively support rule-based model-to-model transformation. Such transformations are useful as they allow domain experts to intuitively (using domain-specific notations) model either operational semantics (a simulator) or denotational semantics (through model-to-model transformation onto a model in a known formalism) of a modelling language. We will demonstrate how to add rule-based operational semantics to modelling languages in MetaEdit+. In our approach, transformation rules are visually created in MetaEdit+. The rule editor is synthesized using modified versions of the original language's metamodel. This modification is performed in a structured fashion using a process called RAMification. Both the model and the rules are exported from MetaEdit+ to Python code. This code is combined with Py-T-Core, our library of transformation language primitives, to apply the rules on the model. Our demonstration has a client-server architecture, with the MetaEdit+ visual modelling environment as the client and the transformation engine as the server. After each transformation step, in-place changes to the model are propagated to MetaEdit+ for visualization using the SOAP API. A simple (manufacturing) Production System modelling language is used as an example.", "num_citations": "4\n", "authors": ["1851"]}
{"title": "Introduction to statecharts modeling, simulation, testing, and deployment\n", "abstract": " Statecharts, introduced by David Harel in 1987, is a formalism used to specify the behavior of timed, autonomous, and reactive systems using a discrete-event abstraction. It extends Timed Finite State Automata with depth, orthogonality, broadcast communication, and history. Its visual representation is based on higraphs, which combine hypergraphs and Euler diagrams. Many tools offer visual editing, simulation, and code synthesis support for Statecharts. Examples include STATEMATE, Rhapsody, Yakindu, and Stateflow, each implementing different variants of Harels original semantics. This tutorial introduces modeling, simulation, testing, and deployment of Statecharts. We start from the basic concepts of states and transitions and explain the more advanced concepts of Statecharts by extending a running example (a traffic light) incrementally. We use Yakindu to model the example system. This is an updated\u00a0\u2026", "num_citations": "3\n", "authors": ["1851"]}
{"title": "Time-and space-conscious omniscient debugging of parallel DEVS\n", "abstract": " Current Parallel DEVS simulation tools provide a wide set of debugging features. Omniscient debugging, or debugging backwards in time, is only rarely implemented, presumably due to its high resource consumption. Outside of DEVS simulation, omniscient debugging implementations are often lossy: some parts of the model or code are ignored, or they consider only a time window of most recent events. In this paper, we consider efficient and lossless omniscient debugging, particularly in the context of Parallel DEVS. We take inspiration from optimistic synchronization protocols, which can roll back simulation. We investigate how this technique can be tailored to omniscient debugging of Parallel DEVS models. Our algorithm limits simulation overhead and memory consumption, while remaining lossless. We compare the traditional approach with our approach. Our approach significantly decreases time and space overhead, at the cost of slightly slower debugging operations.", "num_citations": "3\n", "authors": ["1851"]}
{"title": "Debugging Non-determinism: a Petrinets Modelling, Analysis, and Debugging Tool.\n", "abstract": " Non-deterministic formalisms are used to model systems whose runtime behaviour is inherently non-deterministic (its runtime execution might be different in consecutive runs, even for the same inputs). To analyse these systems, the full state space is explored to check whether an unwanted state (for example: deadlock, unsafe) can be reached. Debugging support for such formalisms is currently limited. This paper presents a prototype tool which allows to interactively construct the reachability graph (by manually stepping). The construction can be automatically paused at the moment a state of interest is reached (breakpointing). This should lead to earlier detection of errors and easier resolution, since the user can observe and control the reachability analysis.", "num_citations": "3\n", "authors": ["1851"]}
{"title": "The computational notebook paradigm for multi-paradigm modeling\n", "abstract": " Computational notebooks are gaining widespread acceptance as a paradigm for storage, dissemination, and re-production of experimental results. In this paper, we define the computational notebook paradigm (CNP) consisting of entities and processes and discuss how the reproducibility of the experimental process and results is enhanced by each element. This paper also details the interactions of CNP and multi-paradigm modeling (MPM), with an aim of understanding how to support MPM within the CNP, and improve the reproducibility aspects of both the CNP and MPM.", "num_citations": "2\n", "authors": ["1851"]}
{"title": "A Generalized Stepping Semantics for Model Debugging.\n", "abstract": " Stepping is arguably one of the most important operations for model execution, and model debugging specifically. Each formalism, however, has a different set of supported stepping operations (eg, big step, combo step, and small step). Furthermore, many tools provide a different terminology for these different steps (eg, small step, micro step, and epsilon step). As such, the exact semantics of stepping is unknown to the modellers, and might even differ between different tools. Additionally, tool developers have no framework to check whether they have implemented all useful stepping operations for their formalism. In this paper, we define a hierarchical terminology of stepping operations to provide a generalized vocabulary for both users and developers of debuggers. We distinguish four \u201clevels\u201d of stepping operations, related to the available knowledge in the execution trace. From a high to low level of abstraction, we term them simulation stepping, black-box stepping, white-box stepping, and implementation stepping. After introducing the framework and terminology, we apply it to a number of already existing debuggers for a large variety of formalisms.", "num_citations": "2\n", "authors": ["1851"]}
{"title": "Report on the 1 st International Workshop on Debugging in Model-Driven Engineering (MDEbug'17)\n", "abstract": " System developers spend a significant part of their time debugging systems (i.e., locating and fixing the cause of failures observed through verification and validation (V&V)). While V&V techniques are commonly used in model-driven engineering, locating and fixing the cause of a failure in a modelled system is most often still a manual task without tool-support. Although debugging techniques are well-established for programming languages, only a few debugging techniques and tools for models have been proposed. Debugging models faces various challenges: handling a wide variety of models and modelling languages; adapting debugging techniques initially proposed for programming languages; tailoring debugging approaches for the domain expert using the abstractions of the considered language. The aim of the first edition of the MDEbug workshop was to bring together researchers wanting to contribute to the emerging field of debugging in model-driven engineering by discussing new ideas and compiling a research agenda. This paper summarizes the workshop's discussion session and distils a list of challenges that should be addressed in future research.", "num_citations": "2\n", "authors": ["1851"]}
{"title": "AToMPM User\u2019s Manual\n", "abstract": " AToMPM supports two modes of real-time distributed collaboration, namely, screenshare and modelshare. In the former, all collaborating developers share the same concrete and abstract syntax. This implies that if one developer moves an entity or cycles to another concrete syntax representation, the change will be replicated for all collaborators. In contrast, in the latter mode, only abstract syntax is shared. This means that all collaborators can have distinct concrete syntax representations and distinct layouts (provided layout and abstract syntax are not intricately related), and are only affected by others\u2019 abstract syntax changes (eg, modifying abstract attribute values).", "num_citations": "2\n", "authors": ["1851"]}
{"title": "Extending Explicitly Modelled Simulation Debugging Environments with Dynamic Structure\n", "abstract": " The widespread adoption of Modelling and Simulation (M8S) techniques hinges on the availability of tools supporting each phase in the M8S-based workflow. This includes tasks such as specifying, implementing, experimenting with, as well as debugging, simulation models. We have previously developed a technique where advanced debugging environments are generated from an explicit behavioural model of the user interface and the simulator. These models are extracted from the code of existing modelling environments and simulators and instrumented with debugging operations. This technique can be reused for a large family of modelling formalisms but was not yet considered for dynamic-structure formalisms; debugging models in these formalisms is challenging, as entities can appear and disappear during simulation. In this article, we adapt and apply our approach to accommodate dynamic-structure\u00a0\u2026", "num_citations": "1\n", "authors": ["1851"]}
{"title": "Statecharts: A Formalism to Model, Simulate and Synthesize Reactive and Autonomous Timed Systems\n", "abstract": " Abstract Statecharts, introduced by David Harel in 1987, is a formalism used to specify the behaviour of timed, autonomous, and reactive systems using a discrete-event abstraction. It extends Timed Finite State Automata with depth, orthogonality, broadcast communication, and history. Its visual representation is based on higraphs, which combine graphs and Euler diagrams. Many tools offer visual editing, simulation, and code synthesis support for the Statechart formalism. Examples include STATEMATE, Rhapsody, Yakindu, and Stateflow, each implementing different variants of Harel\u2019s original semantics. This tutorial introduces modelling, simulation, and testing with Statecharts. As a running example, the behaviour of a digital watch, a simple yet sufficiently complex timed, autonomous, and reactive system is modelled. We start from the basic concepts of states and transitions and explain the more advanced concepts of Statecharts by extending the example incrementally. We discuss several semantic variants, such as STATEMATE and Rhapsody. We use Yakindu to model the example system.", "num_citations": "1\n", "authors": ["1851"]}
{"title": "Preface to the 1st Multi-Paradigm Modeling for Cyber-Physical Systems (MPM4CPS 2019)\n", "abstract": " Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.", "num_citations": "1\n", "authors": ["1851"]}
{"title": "Efficient Software Controller Variant Development and Validation (ECoVaDeVa) Overview of a Flemish ICON Project.\n", "abstract": " This paper describes the goals,(partial) results and lessons learned of the ECoVaDeVa project, a Flemish project that groups academic and industrial partners around the efficient, model-based development of software controller variants for Cyber-Physical Systems (CPSs). ECoVaDeVa\u2019s high-level goal is to apply Product Line Engineering (PLE) techniques to CPS controller design in all phases of the development lifecycle (design, simulation, testing, deployment) as an extension of existing software product line techniques. While PLE is well researched in software development, it is not clear whether these results apply to CPS controller design. The added complexity stems from the heterogeneity of models representing the system, involving plant, controller and environment, software and hardware, and virtual test benches (model-in-theloop, hardware-in-the-loop, etc.). The envisioned result of the project is a set of tools, techniques, and guidelines for the efficient management of CPS controller product variants. The techniques developed during the project are demonstrated on a common use case: a windshield wiper.", "num_citations": "1\n", "authors": ["1851"]}