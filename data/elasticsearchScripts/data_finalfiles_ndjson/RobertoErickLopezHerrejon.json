{"title": "Evaluating support for features in advanced modularization technologies\n", "abstract": " A software product-line is a family of related programs. Each program is defined by a unique combination of features, where a feature is an increment in program functionality. Modularizing features is difficult, as feature-specific code often cuts across class boundaries. New modularization technologies have been proposed in recent years, but their support for feature modules has not been thoroughly examined. In this paper, we propose a variant of the expression problem as a canonical problem in product-line design. The problem reveals a set of technology-independent properties that feature modules should exhibit. We use these properties to evaluate five technologies: AspectJ, Hyper/J, Jiazzi, Scala, and AHEAD. The results suggest an abstract model of feature composition that is technology-independent and that relates compositional reasoning with algebraic reasoning.", "num_citations": "178\n", "authors": ["1516"]}
{"title": "Enhancing clone-and-own with systematic reuse for developing software variants\n", "abstract": " To keep pace with the increasing demand for custom-tailored software systems, companies often apply a practice called clone-and-own, whereby a new variant of a software system is built by coping and adapting existing variants. Instead of a single and configurable system, clone-and-own leads to ad hoc product portfolios of multiple yet similar variants that soon become impossible to maintain effectively. Clone-and-own has widespread industrial use because it requires no major upfront investments and is intuitive, but it lacks a methodology for systematic reuse. In this work we propose ECCO (Extraction and Composition for Clone-and-Own), a novel approach to enhance clone and-own that actively supports the development and maintenance of software product variants. A software engineer selects the desired features and ECCO finds the proper software artifacts to reuse and then provides guidance during the\u00a0\u2026", "num_citations": "152\n", "authors": ["1516"]}
{"title": "A disciplined approach to aspect composition\n", "abstract": " Aspect-oriented programming is a promising paradigm that challenges traditional notions of program modularity. Despite its increasing acceptance, aspects have been documented to suffer limited reuse, hard to predict behavior, and difficult modular reasoning. We develop an algebraic model that relates aspects to program transformations and uncovers aspect composition as a significant source of the problems mentioned. We propose an alternative model of composition that eliminates these problems, preserves the power of aspects, and lays an algebraic foundation on which to build and understand AOP tools.", "num_citations": "141\n", "authors": ["1516"]}
{"title": "Generating product-lines of product-families\n", "abstract": " GenVoca is a methodology and technology for generating product-lines, i.e. building variants of a program. The primitive components from which applications are constructed are refinements or layers, which are modules that implement a feature that many programs of a product-line can share. Unlike conventional components (e.g., COM, CORBA, EJB), a layer encapsulates fragments of multiple classes. Sets of fully formed classes can be produced by composing layers. Layers are modular, albeit unconventional, building blocks of programs. But what are the building blocks of layers? We argue that facets is an answer. A facet encapsulates fragments of multiple layers, and compositions of facets yields sets of fully formed layers. Facets arise when refinements scale from producing variants of individual programs to producing variants of multiple integrated programs, as typified byproduct families (e.g., MS Office). We\u00a0\u2026", "num_citations": "115\n", "authors": ["1516"]}
{"title": "Reengineering legacy applications into software product lines: a systematic mapping\n", "abstract": " Software Product Lines (SPLs) are families of systems that share common assets allowing a disciplined reuse. Rarely SPLs start from scratch, instead they usually start from a set of existing systems that undergo a reengineering process. Many approaches to conduct the reengineering process have been proposed and documented in research literature. This scenario is a clear testament to the interest in this research area. We conducted a systematic mapping study to provide an overview of the current research on reengineering of existing systems to SPLs, identify the community activity in regarding of venues and frequency of publications in this field, and point out trends and open issues that could serve as references for future research. This study identified 119 relevant publications. These primary sources were classified in six different dimensions related to reengineering phases, strategies applied, types\u00a0\u2026", "num_citations": "113\n", "authors": ["1516"]}
{"title": "A systematic mapping study of search-based software engineering for software product lines\n", "abstract": " ContextSearch-Based Software Engineering (SBSE) is an emerging discipline that focuses on the application of search-based optimization techniques to software engineering problems. Software Product Lines (SPLs) are families of related software systems whose members are distinguished by the set of features each one provides. SPL development practices have proven benefits such as improved software reuse, better customization, and faster time to market. A typical SPL usually involves a large number of systems and features, a fact that makes them attractive for the application of SBSE techniques which are able to tackle problems that involve large search spaces.ObjectiveThe main objective of our work is to identify the quantity and the type of research on the application of SBSE techniques to SPL problems. More concretely, the SBSE techniques that have been used and at what stage of the SPL life cycle\u00a0\u2026", "num_citations": "102\n", "authors": ["1516"]}
{"title": "Variability extraction and modeling for product variants\n", "abstract": " Fast-changing hardware and software technologies in addition to larger and more specialized customer bases demand software tailored to meet very diverse requirements. Software development approaches that aim at capturing this diversity on a single consolidated platform often require large upfront investments, e.g., time or budget. Alternatively, companies resort to developing one variant of a software product at a time by reusing as much as possible from already-existing product variants. However, identifying and extracting the parts to reuse is an error-prone and inefficient task compounded by the typically large number of product variants. Hence, more disciplined and systematic approaches are needed to cope with the complexity of developing and maintaining sets of product variants. Such approaches require detailed information about the product variants, the features they provide and their relations\u00a0\u2026", "num_citations": "74\n", "authors": ["1516"]}
{"title": "Reverse engineering feature models from programs' feature sets\n", "abstract": " Successful software is more and more rarely developed as a one-of-a-kind system. Instead, different system variants are built from a common set of assets and customized for catering to the different functionality or technology needs of the distinct clients and users. The Software Product Line Engineering (SPLE) paradigm has proven effective to cope with the variability described for this scenario. However, evolving a Software Product Line (SPL) from a family of systems is not a simple endeavor. A crucial requirement is accurately capturing the variability present in the family of systems and representing it with Feature Models (FMs), the de facto standard for variability modeling. Current research has focused on extracting FMs from configuration scripts, propositional logic expressions or natural language. In contrast, in this short paper we present an algorithm that reverse engineers a basic feature model from the\u00a0\u2026", "num_citations": "63\n", "authors": ["1516"]}
{"title": "On extracting feature models from sets of valid feature combinations\n", "abstract": " Rather than developing individual systems, Software Product Line Engineering develops families of systems. The members of the software family are distinguished by the features they implement and Feature Models (FMs) are the de facto standard for defining which feature combinations are considered valid members. This paper presents an algorithm to automatically extract a feature model from a set of valid feature combinations, an essential development step when companies, for instance, decide to convert their existing product variations portfolio into a Software Product Line. We performed an evaluation on 168 publicly available feature models, with 9 to 38 features and up to 147456 feature combinations. From the generated feature combinations of each of these examples, we reverse engineered an equivalent feature model with a median performance in the low milliseconds.", "num_citations": "56\n", "authors": ["1516"]}
{"title": "The ECCO tool: Extraction and composition for clone-and-own\n", "abstract": " Software reuse has become mandatory for companies to compete and a wide range of reuse techniques are available today. However, ad hoc practices such as copying existing systems and customizing them to meet customer-specific needs are still pervasive, and are generically called clone-and-own. We have developed a conceptual framework to support this practice named ECCO that stands for Extraction and Composition for Clone-and-Own. In this paper we present our Eclipse-based tool to support this approach. Our tool can automatically locate reusable parts from previously developed products and subsequently compose a new product from a selection of desired features. The tools demonstration video can be found here: http://youtu.be/N6gPekuxU6o.", "num_citations": "45\n", "authors": ["1516"]}
{"title": "Detecting inconsistencies in multi-view models with variability\n", "abstract": " Multi-View Modeling (MVM) is a common modeling practice that advocates the use of multiple, different and yet related models to represent the needs of diverse stakeholders. Of crucial importance in MVM is consistency checking \u2014 the description and verification of semantic relationships amongst the views. Variability is the capacity of software artifacts to vary, and its effective management is a core tenet of the research in Software Product Lines (SPL). MVM has proven useful for developing one-of-a-kind systems; however, to reap the potential benefits of MVM in SPL it is vital to provide consistency checking mechanisms that cope with variability. In this paper we describe how to address this need by applying Safe Composition \u2014 the guarantee that all programs of a product line are type safe. We evaluate our approach with a case study.", "num_citations": "42\n", "authors": ["1516"]}
{"title": "From requirements to features: An exploratory study of feature-oriented refactoring\n", "abstract": " More and more frequently successful software systems need to evolve into families of systems, known as Software Product Lines (SPLs), to be able to cater to the different functionality requirements demanded by different customers while at the same time aiming to exploit as much common functionality as possible. As a first step, this evolution demands a clear understanding of how the functional requirements map into the features of the original system. Using this knowledge, features can be refactored so that they are reused for building the new systems of the evolved SPL. In this paper we present our experience in refactoring features based on the requirements specifications of a small and a medium size systems. Our work identified eight refactoring patterns that describe how to extract the elements of features which were subsequently implemented using Feature Oriented Software Development (FOSD) a novel\u00a0\u2026", "num_citations": "39\n", "authors": ["1516"]}
{"title": "Feature model synthesis with genetic programming\n", "abstract": " Search-Based Software Engineering (SBSE) has proven successful on several stages of the software development life cycle. It has also been applied to different challenges in the context of Software Product Lines (SPLs) like generating minimal test suites. When reverse engineering SPLs from legacy software an important challenge is the reverse engineering of variability, often expressed in the form of Feature Models (FMs). The synthesis of FMs has been studied with techniques such as Genetic Algorithms. In this paper we explore the use of Genetic Programming for this task. We sketch our general workflow, the GP pipeline employed, and its evolutionary operators. We report our experience in synthesizing feature models from sets of feature combinations for 17 representative feature models, and analyze the results using standard information retrieval metrics.", "num_citations": "37\n", "authors": ["1516"]}
{"title": "Using interactive technology in a short Java course: An experience report\n", "abstract": " Keeping students alert and responsive during lectures is a challenge even for experienced teachers in small group settings. Research has shown the importance of student participation and involvement in the learning process. Many ideas and strategies have been proposed to promote these two vital education elements [5]. Among them is the use of interactive technology where the instructor asks a question to the class and each student answers individually. These answers are tallied and the professor can get immediate, quantitative, and real-time feedback information that can be used to detect and address comprehension problems and to adapt the lecture plan accordingly. In this paper we report our experiences using a wireless interactive system named the Classroom Performance System (CPS) [9] in a fast-paced, short but comprehensive Java programming course. We present the challenges we faced and\u00a0\u2026", "num_citations": "37\n", "authors": ["1516"]}
{"title": "Improving incremental development in AspectJ by bounding quantification\n", "abstract": " Incremental software development is a process of building complex programs from simple ones by successively adding programmatic details. It is an effective and common design practice that helps control program complexity. However, incrementally building software using aspects can be more challenging than using traditional modules. AspectJ quantification mechanisms do not distinguish different developmental stages, and thus pointcuts can capture join points from later stages that they originally were not intended to advise.In this paper we present an algebraic model to describe aspects and their composition in AspectJ. We show that the way AspectJ\u2019s composes aspects plays a significant role in this problem. We propose an alternative model to compose aspects that improves the support for incremental development. It bounds the scope of quantification and still preserves the power of AspectJ. We also show how bounded quantification contributes to aspect reuse.", "num_citations": "35\n", "authors": ["1516"]}
{"title": "Co-evolution of metamodels and models through consistent change propagation\n", "abstract": " In model-driven engineering (MDE), metamodels and domain-specific languages are key artifacts as they are used to define syntax and static semantics of domain models. However, metamodels are evolving over time, requiring existing domain models to be co-evolved. Though approaches have been proposed for performing such co-evolution automatically, those approaches typically support only specific metamodel changes. In this paper, we present a vision of co-evolution between metamodels and models through consistent change propagation. The approach addresses co-evolution issues without being limited to specific metamodels or evolution scenarios. It relies on incremental management of metamodel-based constraints that are used to detect co-evolution failures (i.e., inconsistencies between metamodel and model). After failure detection, the approach automatically generates suggestions for correction\u00a0\u2026", "num_citations": "32\n", "authors": ["1516"]}
{"title": "Supporting the co-evolution of metamodels and constraints through incremental constraint management\n", "abstract": " Design models must abide by constraints that can come from diverse sources, like metamodels, requirements, or the problem domain. Modelers intent to live by these constraints and thus desire automated mechanism that provide instant feedback on constraint violations. However, typical approaches assume that constraints do not evolve over time, which, unfortunately, is becoming increasingly unrealistic. For example, the co-evolution of metamodels and models requires corresponding constraints to be co-evolved continuously. This demands efficient constraint adaptation mechanisms to ensure that validated constraints are up-to-date. This paper presents an approach based on constraint templates that tackles this evolution scenario by automatically updating constraints. We developed the Cross-Layer Modeler (XLM) approach which relies on incremental consistency-checking. As a case study, we\u00a0\u2026", "num_citations": "31\n", "authors": ["1516"]}
{"title": "Cross-layer modeler: a tool for flexible multilevel modeling with consistency checking\n", "abstract": " Model-driven engineering has become a popular methodology in software engineering. Most available modeling tools support the creation of models based on a fixed metamodel. Typically, tool users cannot change the metamodel to reflect domain changes or newly emerged requirements. As a consequence, an updated version of the tool with an evolved metamodel must be developed and models as well as constraints that ensure model consistency have to be co-evolved, often manually, to conform to the new metamodel. Both, tool evolution and the necessary co-evolutions, are time consuming and error prone tasks. Furthermore, common tools often restrict the number of metalevels that can be modeled and force modelers to use workarounds to express certain facts. To overcome these issues we present the Cross-Layer Modeler (XLM), a modeling tool that supports multilevel modeling and allows co-evolution\u00a0\u2026", "num_citations": "25\n", "authors": ["1516"]}
{"title": "A variability aware configuration management and revision control platform\n", "abstract": " Modern systems need to run in many different contexts like hardware and software platforms or environmental conditions. Additionally different customers might have slightly different requirements towards systems. Therefore software systems need to be highly configurable and provide variable sets of features for different customers. There are various approaches to developing and managing such systems, like ad-hoc clone-and-own approaches or structured software product line approaches for each of which again several different techniques and tools exist to support them. While the different approaches come with advantages they also have several disadvantages and shortcomings. Some work only with specific implementation artifacts (e.g. source code but not models) and others exist only as plugins for specific IDEs which makes them intrusive or even unusable in some development environments. In our work\u00a0\u2026", "num_citations": "24\n", "authors": ["1516"]}
{"title": "Consistent merging of model versions\n", "abstract": " While many engineering tasks can, and should be, manageable independently, it does place a great burden on explicit collaboration needs\u2014including the need for frequent and incremental merging of artifacts that software engineers manipulate using these tools. State-of-the-art merging techniques are often limited to textual artifacts (e.g., source code) and they are unable to discover and resolve complex merging issues beyond simple conflicts. This work focuses on the merging of models where we consider not only conflicts but also arbitrary syntactic and semantic consistency issues. Consistent artifacts are merged fully automatically and only inconsistent/conflicting artifacts are brought to the users\u2019 attention, together with a systematic proposal of how to resolve them. Our approach is neutral with regard to who made the changes and hence reduces the bias caused by any individual engineer\u2019s limited point of\u00a0\u2026", "num_citations": "24\n", "authors": ["1516"]}
{"title": "Using feature model knowledge to speed up the generation of covering arrays\n", "abstract": " Combinatorial Interaction Testing has shown great potential for effectively testing Software Product Lines (SPLs). An important part of this type of testing is determining a subset of SPL products in which interaction errors are more likely to occur. Such sets of products are obtained by computing a so called t-wise Covering Array (tCA), whose computation is known to be NP-complete. Recently, the ICPL algorithm has been proposed to compute these covering arrays. In this research-in-progress paper, we propose a set of rules that exploit basic feature model knowledge to reduce the number of elements (ie t-sets) required by ICPL without weakening the strength of the generated arrays. We carried out a comparison of runtime performance that shows a significant reduction of the needed execution time for the majority of our SPL case studies.", "num_citations": "23\n", "authors": ["1516"]}
{"title": "Using traceability for incremental construction and evolution of software product portfolios\n", "abstract": " Software reuse has become mandatory for companies to compete and a wide range of reuse techniques are available today. Despite the great benefits of these techniques, they also have the disadvantage that they do not necessarily support the creation and evolution of closely related products - products that are customized to different infrastructures, ecosystems, machinery, or customers. In this paper we outline an approach for incrementally constructing and evolving software product portfolios of similar product variants. An initial proof of concept demonstrates its feasibility.", "num_citations": "22\n", "authors": ["1516"]}
{"title": "A systematic mapping study of information visualization for software product line engineering\n", "abstract": " Software product lines (SPLs) are families of related systems whose members are distinguished by the set of features they provide. Over 2 decades of research and practice can attest to the substantial benefits of applying SPL practices such as better customization, improved software reuse, and faster time to market. Software product line engineering (SPLE) refers to the paradigm of developing SPLs. Typical SPLE efforts involve a large number of features that are combined to form also large numbers of products, implemented using multiple and different types of software artifacts. Because of the sheer amount of information and its complexity, visualization techniques have been used for different SPLE activities. In this paper, we present an extended systematic mapping study on this subject. Our research questions aim to gather information regarding the techniques that have been applied, at what SPLE activities\u00a0\u2026", "num_citations": "21\n", "authors": ["1516"]}
{"title": "Using AspectJ to implement product-lines: A case study\n", "abstract": " Aspect-Oriented Programming (AOP) is an emerging technology whose goal is to modularize concerns that cross-cut multiple classes. The purpose of this report is to describe how one of the main representatives of AOP, namely AspectJ, was used to implement a simple yet illustrative product-line of graph algorithms so that we can focus on the implementation details. We expect that studies like this can shed light on the applicability of AOP beyond the traditional examples of logging and debugging.", "num_citations": "21\n", "authors": ["1516"]}
{"title": "From crosscutting concerns to product lines: a function composition approach\n", "abstract": " Aspects offer sophisticated mechanisms to modularize crosscutting concerns. Aspect Oriented Programming (AOP) has been successfully applied to many domains; however, its application to product line engineering has not been thoroughly explored. Features are increments in program functionality and are building blocks of software product lines. Work on Feature Oriented Programming (FOP) has shown that a crucial factor to synthesize product lines is composing features by function composition. In this paper we describe a way to emulate function composition using AspectJ for the synthesis of a non-trivial product line, present a general mechanism to support it and highlight its potential reuse benefits. Our study also profiles the role different aspect constructs play in the synthesis of product lines and offers venues of research on the use of aspects in product line implementations.", "num_citations": "19\n", "authors": ["1516"]}
{"title": "Automatic extraction of product line architecture and feature models from UML class diagram variants\n", "abstract": " ContextSoftware Product Lines (SPLs) are families of related products developed for specific domains. SPLs commonly emerge from existing variants when their individual maintenance and/or evolution become complex. Even though there exists a vast research literature on SPL extraction, the majority of the approaches have only focused on source code, are partially automated, or do not reflect domain constraints. Such limitations can make more difficult the extraction, management, documentation and generation of some important SPL artifacts such as the product line architecture, a fact that can impact negatively the evolution and maintenance of SPLs.ObjectiveTo tackle these limitations, this work presents ModelVars2SPL (Model Variants to SPL Core Assets), an automated approach to aid the development of SPLs from existing system variants.MethodThe input for ModelVars2SPL is a set of Unified Modeling\u00a0\u2026", "num_citations": "18\n", "authors": ["1516"]}
{"title": "Multi-objective reverse engineering of variability-safe feature models based on code dependencies of system variants\n", "abstract": " Maintenance of many variants of a software system, developed to supply a wide range of customer-specific demands, is a complex endeavour. The consolidation of such variants into a Software Product Line is a way to effectively cope with this problem. A crucial step for this consolidation is to reverse engineer feature models that represent the desired combinations of features of all the available variants. Many approaches have been proposed for this reverse engineering task but they present two shortcomings. First, they use a single-objective perspective that does not allow software engineers to consider design trade-offs. Second, they do not exploit knowledge from implementation artifacts. To address these limitations, our work takes a multi-objective perspective and uses knowledge from source code dependencies to obtain feature models that not only represent the desired feature combinations but that\u00a0\u2026", "num_citations": "18\n", "authors": ["1516"]}
{"title": "Towards interactive visualization support for pairwise testing software product lines\n", "abstract": " Software Product Lines (SPLs) are families of related software products. SPL practices have proven substantial technological and economical benefits such as improved software reuse and reduced time to market. Software testing is a key development activity in SPLs, and it is uniquely challenging because of the usually large number of feature combinations present in typical SPLs. Pairwise testing is a combinatorial testing technique that aims at selecting products to test based on the pairs of feature combinations such products provide. Our previous work on evolutionary approaches for SPL testing and their comparative analysis has yielded a large amount of data that prompted us to explore ways by which to convey and represent this information. In this paper we present our early results in this effort. We describe three basic visualization applications to pairwise testing and highlight some of the open questions that\u00a0\u2026", "num_citations": "16\n", "authors": ["1516"]}
{"title": "Automatically generating and adapting model constraints to support co-evolution of design models\n", "abstract": " Design models must abide by constraints that can come from diverse sources, like their metamodels, requirements, or the problem domain. Software modelers expect these constraints to be enforced on their models and receive instant error feedback if they fail. This works well when constraints are stable. However, constraints may evolve much like their models do. This evolution demands efficient constraint adaptation mechanisms to ensure that models are always validated against the correct constraints. In this paper, we present an idea based on constraint templates that tackles this evolution scenario by automatically generating and updating constraints.", "num_citations": "16\n", "authors": ["1516"]}
{"title": "Towards fixing inconsistencies in models with variability\n", "abstract": " Recent years have witnessed a convergence between research in SPL and Model-Driven Engineering (MDE) that leverages the complementary capabilities that both paradigms can offer. A crucial factor for the success of MDE is the availability of effective support for detecting and fixing inconsistencies among model elements. The importance of such support is attested by the extensive literature devoted to the topic. However, when coupled with variability, the research focus has been devoted to inconsistency detection, while leaving the important issue of fixing the inconsistency largely unaddressed. In this research-in-progress paper, we explore one of the issues that variability raises for inconsistency fixing. Namely, in which features to locate the fixes. We compute what is the minimal number of fixes and use it as a baseline to compare fixes obtained with a heuristic based on feature model analysis and random\u00a0\u2026", "num_citations": "15\n", "authors": ["1516"]}
{"title": "Understanding feature modularity\n", "abstract": " Features are increments in program functionality. Feature abstraction, the process of abstracting programs into their constituent features, is a relatively common yet informal practice in software design. It is common because it simplifies program understanding. It is also important for software product lines whose essence is the systematic and efficient creation of software products from a shared set of assets or features, where each product exhibits common functionality with other products but also has unique functionalities.", "num_citations": "15\n", "authors": ["1516"]}
{"title": "Extracting variability-safe feature models from source code dependencies in system variants\n", "abstract": " To effectively cope with increasing customization demands, companies that have developed variants of software systems are faced with the challenge of consolidating all the variants into a Software Product Line, a proven development paradigm capable of handling such demands. A crucial step in this challenge is to reverse engineer feature models that capture all the required feature combinations of each system variant. Current research has explored this task using propositional logic, natural language, and search-based techniques. However, using knowledge from the implementation artifacts for the reverse engineering task has not been studied. We propose a multi-objective approach that not only uses standard precision and recall metrics for the combinations of features but that also considers variability-safety, ie the property that, based on structural dependencies among elements of implementation artifacts\u00a0\u2026", "num_citations": "14\n", "authors": ["1516"]}
{"title": "Constraint-driven modeling through transformation\n", "abstract": " In model-driven software engineering, model transformation plays a key role for automatically generating and updating models. Transformation rules define how source model elements are to be transformed into target model elements. However, defining transformation rules is a complex task, especially in situations where semantic differences or incompleteness allow for alternative interpretations or where models change continuously before and after transformation. This paper proposes constraint-driven modeling where transformation is used to generate constraints on the target model rather than the target model itself. We evaluated the approach on three case studies that address the above difficulties and other common transformation issues. We also developed a proof-of-concept implementation that demonstrates its feasibility. The implementation suggests that constraint-driven transformation is an\u00a0\u2026", "num_citations": "14\n", "authors": ["1516"]}
{"title": "Towards an ontology-based approach for deriving product architectures\n", "abstract": " Software product line (SPL) engineering has proven to improve software quality and shorten costs and development time. An important aspect in the product line development process involves variability, which is the ability of a system for being customised, changed, or extended. Approaches are required for modelling and resolving variability as well as for verifying the selections. In this paper, we outline our ongoing research towards an approach that automates the derivation of product architectures from an SPL architecture. The proposed approach relies on ontology-based reasoning and model-driven techniques, the former supports the validation of the generated architectures and the generation of the transformation rules while the latter realises the actual target product architectures. We sketch our approach with a voice over IP case example.", "num_citations": "13\n", "authors": ["1516"]}
{"title": "Modeling features in aspect-based product lines with use case slices: An exploratory case study\n", "abstract": " A significant number of techniques that exploit aspects in software design have been proposed in recent years. One technique is use case slices by Jacobson and Ng, that builds upon the success of use cases as a common modeling practice. A use case slice modularizes the implementation of a use case and typically consists of a set of aspects, classes, and interfaces. Work on Feature Oriented Programming (FOP) has shown how features, incre ments in program functionality, can be modularized and algebraically mod eled for the synthesis of product lines. When AspectJ is used in FOP, the structure of feature modules resembles that of use case slices. In this paper, we explore the relations between use case slices modeling and FOP program synthesis and describe their potential synergy for modeling and synthesizing aspect-based product lines.", "num_citations": "13\n", "authors": ["1516"]}
{"title": "Constraint-driven modeling through transformation\n", "abstract": " In model-driven software engineering, model transformations play a key role since they are used to automatically generate and update models from existing information. However, defining concrete transformation rules is a complex task because the designer has to cope with incompleteness, ambiguity, bidirectionality, and rule dependencies. In this paper, we propose a vision of Constraint-driven Modeling in which transformation is used to automate the generation of model constraints instead of generating entire models. Three illustrative scenarios show how this approach addresses common transformation issues and how designers can benefit from using model constraints and guidance. We developed a proof-of-concept implementation that covers an important part of this vision and thus demonstrates its feasibility. The implementation also suggests that a constraint-driven transformation is efficient and\u00a0\u2026", "num_citations": "12\n", "authors": ["1516"]}
{"title": "From abstract to concrete repairs of model inconsistencies: An automated approach\n", "abstract": " A common task performed in model-driven software engineering is evolving models. This task is typically performed manually during the design or implementation phase of software projects and is known to cause inconsistencies. Despite extensive research on consistency checking, existing approaches either provide abstract (i.e., incomplete) repairs only, or they require manually predefined strategies on how to repair inconsistencies. In this paper, we present a novel approach that provides concrete (i.e., executable) repairs without the need of predefined repair strategies. Furthermore, our approach proposes functions which automate the generation of concrete repairs at runtime. An empirical assessment of the approach on six case studies from industry, academia and GitHub demonstrates its feasibility, and shows that the provided concrete repairs are relevant and can fix their corresponding inconsistencies\u00a0\u2026", "num_citations": "11\n", "authors": ["1516"]}
{"title": "Fine-tuning model transformation: Change propagation in context of consistency, completeness, and human guidance\n", "abstract": " An important role of model transformation is in exchanging modeling information among diverse modeling languages. However, while a model is typically constrained by other models, additional information is often necessary to transform said models entirely. This dilemma poses unique challenges for the model transformation community. To counter this problem we require a smart transformation assistant. Such an assistant should be able to combine information from diverse models, react incrementally to enable transformation as information becomes available, and accept human guidance \u2013 from direct queries to understanding the designer(s) intentions. Such an assistant should embrace variability to explicitly express and constrain uncertainties during transformation \u2013 for example, by transforming alternatives (if no unique transformation result is computable) and constraining these alternatives during\u00a0\u2026", "num_citations": "10\n", "authors": ["1516"]}
{"title": "A web specific language for content management systems\n", "abstract": " Many web applications can be specified in terms of the content-types and security policies they provide. Some web frameworks aim to ease the implementation of this family of programs. We propose an extensible domainspecific language to specify these programs, and methods to synthesize the applications from their specification. This allows domain experts, notably web designers, to describe the business domain at higher level than code and automate the implementation process. We target a software product line architecture for content-management systems. This allows new features of the product line to be derived on demand rather than limiting the variability of new products to existing features. A case study is presented that demonstrates how the application design can be captured in our language and its implementation fully automated as features of a product line. The final product is then a composite of the derived features and selected existing features.", "num_citations": "9\n", "authors": ["1516"]}
{"title": "Towards a fault-detection benchmark for evaluating software product line testing approaches\n", "abstract": " Software Product Lines (SPLs) are families of related software systems distinguished by the set of features each one provides. The commonly large number of variants that can be derived from an SPL poses a unique set of challenges, because it is not feasible to test all the individual variants. Over the last few years many approaches for SPL testing have been devised. They usually select a set of variants to test based on some covering criterion. A problem when evaluating these testing approaches is properly comparing them to one another. Even though some benchmarks have been proposed, they focus on covering criteria and do not consider fault data in their analysis. Considering the dire lack of publicly available fault data, in this paper we present the first results of our ongoing project to introduce simulated faults into SPLs along with using evolutionary techniques for synthesizing unit test cases for SPL examples.", "num_citations": "8\n", "authors": ["1516"]}
{"title": "Visualization for software product lines: a systematic mapping study\n", "abstract": " Software Product Lines (SPLs) are families of related systems whose members are distinguished by the set of features they provide. Over two decades of research and practice can attest to the substantial benefits of applying SPL practices such as better customization, improved software reuse, and faster time to market. Typical SPLs involve large number of features which are combined to form also large numbers of products, implemented using multiple and different types of software artifacts. Because of the sheer amount of information and its complexity visualization techniques have been used at different stages of the life cycle of SPLs. In this paper we present a systematic mapping study on this subject. Our research questions aim to gather information regarding the techniques that have been applied, at what stages, how they were implemented, and the publication fora employed. Our goal is to identify common\u00a0\u2026", "num_citations": "8\n", "authors": ["1516"]}
{"title": "Searching the variability space to fix model inconsistencies: A preliminary assessment\n", "abstract": " Recent years have witnessed a convergence between research in Software Product Lines (SPL) and Model-Driven Engineering (MDE) that leverages the complementary capabilities that both paradigms can offer. A crucial factor for the success of MDE is the availability of effective support for detecting and fixing inconsistencies among model elements. The importance of such support is attested by the extensive literature devoted to the topic. However, when MDE is coupled with SPL, the research focus has been devoted to inconsistency detection, while leaving fixing largely unexplored. To address this issue, a first step is locating where to apply the required fix (es) such that the necessary feature combinations of a product line are considered. It is not uncommon for the number of such feature combinations\u2013variability space\u2013to be quite large which renders unfeasible any exhaustive exploration. In this paper, we present early results of our ongoing work which relies on a basic search technique to effectively identify the places where the fixes should be placed. We evaluated our approach with sixty SPL examples.", "num_citations": "8\n", "authors": ["1516"]}
{"title": "A source level empirical study of features and their interactions in variable software\n", "abstract": " Robust and effective support for the detection and management of features and their interactions is crucial for many software development tasks but has proven to be an elusive goal despite the extensive research and practice on the subject. Providing the required support becomes even more challenging with variable software whereby multiple variants of a system and their features must be collectively considered. An important premise to provide better support for feature interactions in variable systems is the need of a deeper understanding on how features interact at different levels starting from the source level. In this context, recent work has looked at feature interactions from different angles and for different purposes, for instance for developing performance models, extracting interfaces for maintenance or describing feature evolution patterns. However, there is a gap in understanding how features interact in fact\u00a0\u2026", "num_citations": "7\n", "authors": ["1516"]}
{"title": "Co-evolution of Metamodels and Models through Consistent Change Propagation.\n", "abstract": " In Model-Driven Engineering (MDE), metamodels and domain-specific languages are key artifacts as they are used to define syntax and semantics of domain models. However, metamodels are evolving over time, requiring existing domain models to be co-evolved. Though approaches have been proposed for performing such co-evolution automatically, those approaches typically support only specific metamodel changes. In this paper, we present a vision of co-evolution between metamodels and models through consistent change propagation. The approach addressed co-evolution issues without being limited to specific metamodels or evolution scenarios. It relies on incremental management of metamodel-based constraints that are used to detect co-evolution failures (ie, inconsistencies between metamodel and model). After failure detection, the approach automatically generates suggestions for correction (ie, repairs for inconsistencies). Preliminary validation results are promising as they indicate that the approach computes correct suggestions for model adaptations, and that it scales and can be applied live without interrupting tool users.", "num_citations": "7\n", "authors": ["1516"]}
{"title": "C2mv2: Consistency and composition for managing variability in multi-view systems\n", "abstract": " C2MV2 is an ongoing FP7-People Intra-European Marie Curie Fellowship project that runs for two years. The driving goal of the project is to apply and extend work on incremental consistency management to Software Product Lines that are developed with compositional approaches.", "num_citations": "7\n", "authors": ["1516"]}
{"title": "On the need of safe software product line architectures\n", "abstract": " A Software Product Line (SPL) is a family of related software systems distinguished by the different sets of features each system provides. Over the last decade, the substantial benefits of SPL practices have been extensively documented and corroborated both in academia and industry. Several architecture methods have been proposed that employ different artifacts for expressing the components of a SPL, their properties and relationships. Of crucial importance for any SPL architecture method is to guarantee that the variability, for instance as expressed in feature models, is not only preserved but also kept consistent across all artifacts used. In this research challenge paper we argue that Safe Composition \u2013 the guarantee that all programs of a product line are type safe \u2013 can be leveraged to address this guarantee for structural properties of SPL architectures and the challenges that that entails.", "num_citations": "7\n", "authors": ["1516"]}
{"title": "Understanding feature modularity in feature oriented programming and its implications to aspect oriented programming\n", "abstract": " My research is in software product lines. My focus is on feature modularity, a basis for product line development, and the cornerstone of Feature Oriented Programming (FOP). Additionally, I have studied the support that different novel modularity technologies provide for features, with emphasis on those categorized as Aspect Oriented Programming (AOP). Also, the relationship between FOP and AOP is a common source of misunderstandings and misconceptions. My dissertation develops an algebraic model that exposes the differences between both programming paradigms and indicates possible venues for mutual benefit.", "num_citations": "7\n", "authors": ["1516"]}
{"title": "The expression problem as a product line and its implementation in AHEAD\n", "abstract": " Software product lines are defined in terms of feature sets. A family member is defined with the set of features it implements. Several modularization techniques have recently appeared so in an effort to evaluate their usability to implement product lines, we propose a simple yet illustrative product line example based on the expression problem that we believe captures the most basic requirements to modularize features.", "num_citations": "7\n", "authors": ["1516"]}
{"title": "Discovering software architectures with search-based merge of UML model variants\n", "abstract": " Software reuse is a way to reduce costs and improve quality. However, in industry, the reuse of existing software artifacts is commonly done by ad hoc strategies such as clone-and-own. Clone-and-own leads to a set of system variants developed independently, despite of having similar parts. The maintenance of these independent variants is a difficult task, because of duplication and spread functionalities. One problem faced by developers and engineers is the lack of a global view of such variants, providing a better understanding of the actual state of the systems. In this paper we present an approach to discover the architecture of system variants using a search-based technique. Our approach identifies differences between models and uses these differences to generate candidate architectures. The goal is to find a candidate architecture most similar to a set of UML model variants. Our contribution is\u00a0\u2026", "num_citations": "6\n", "authors": ["1516"]}
{"title": "Automatic and incremental product optimization for software product lines\n", "abstract": " Software Product Lines (SPLs) have gained popularity in industry as they foster the reuse of artifacts, such as code, and reduce product development effort. Although some SPLs ensure that only valid products are configurable, those products are not necessarily optimal. For instance, they may include code that is not necessary for providing the desired functionality -- often because of erroneous traceability between features and code. Such unnecessary code may be disallowed in safety critical domains, it may lead to losses in runtime performance, or it may lead to errors during later SPL evolution. In this paper, we present an approach for automatic and incremental product optimization. Our approach leverages product functionality tests to ensure that configured products do not include unnecessary artifacts -- an automatic re-optimization of products after SPL evolution is performed incrementally. The evaluation\u00a0\u2026", "num_citations": "6\n", "authors": ["1516"]}
{"title": "Sbse4vm: Search based software engineering for variability management\n", "abstract": " SBSE4VM is an ongoing Lise Meitner Fellowship project sponsored by the Austrian Science Fund (FWF) that runs for two years. The driving goal of the project is to explore the application of Search Based Software Engineering techniques to reverse engineer, evolve, and fix inconsistencies in systems with variability.", "num_citations": "6\n", "authors": ["1516"]}
{"title": "Realizing feature oriented software development with equational logic: An exploratory study\n", "abstract": " Realizing feature oriented software development with equational logic: An exploratory study - Espace \u00c9TS ENGLISH Logo La vitrine de diffusion des publications et contributions des chercheurs de l'\u00c9TS RECHERCHER Se connecter Accueil D\u00e9poser Nouveaut\u00e9s Recherche Rep\u00e9rage \u00c0 propos Conditions d'utilisation Politique de d\u00e9p\u00f4t M\u00e9moires et th\u00e8ses Nous joindre Realizing feature oriented software development with equational logic: An exploratory study Lopez-Herrejon, Roberto E. et Rivera, Jos\u00e9 Eduardo. 2009. \u00ab Realizing feature oriented software development with equational logic: An exploratory study \u00bb. In XIV Jornadas de Ingenier\u00eda del Software y Bases de Datos (JISBD) (San Sebasti\u00e1n, Spain, Sept. 08-11, 2009) p. 269-274. Mondragon Unibertsitatea. Le plein texte de ce document n'est pas h\u00e9berg\u00e9 sur ce serveur. Rechercher dans Google Scholar Type de document: Compte rendu de conf\u00e9rence \u2026", "num_citations": "6\n", "authors": ["1516"]}
{"title": "Consistent change propagation within models\n", "abstract": " Developers change models with clear intentions\u2014e.g., for refactoring, defects removal, or evolution. However, in doing so, developers are often unaware of the consequences of their changes. Changes to one part of a model may affect other parts of the same model and/or even other models, possibly created and maintained by other developers. The consequences are incomplete changes and with it inconsistencies within or across models. Extensive works exist on detecting and repairing inconsistencies. However, the literature tends to focus on inconsistencies as errors in need of repairs rather than on incomplete changes in need of further propagation. Many changes are non-trivial and require a series of coordinated model changes. As developers start changing the model, intermittent inconsistencies arise with other parts of the model that developers have not yet changed. These inconsistencies are cues for\u00a0\u2026", "num_citations": "5\n", "authors": ["1516"]}
{"title": "Towards visualization of feature interactions in software product lines\n", "abstract": " Software Product Lines (SPLs) are families of related systems whose members are distinguished by the set of features they provide. To effectively evolve and maintain SPLs it is vital to understand how features are implemented and how they interact at different levels from source code to runtime. However the large number of features and the complex nature of interactions in typical SPLs make maintenance and evolution tasks challenging, and demand robust tool support for the software engineers to carry out these tasks. In this paper we present the first results of our ongoing work to address this need. We put forward four visualizations that focus on features and their interactions at source code level, evaluate them with four case studies, and sketch our future work.", "num_citations": "5\n", "authors": ["1516"]}
{"title": "Genetic improvement for software product lines: An overview and a roadmap\n", "abstract": " Software Product Lines (SPLs) are families of related software systems that provide different combinations of features. Extensive research and application attest to the significant economical and technological benefits of employing SPL practices. However, there are still several challenges that remain open. Salient among them is reverse engineering SPLs from existing variants of software systems and their subsequent evolution. In this paper, we aim at sketching connections between research on these open SPL challenges and ongoing work on Genetic Improvement. Our hope is that by drawing such connections we can spark the interest of both research communities on the exciting synergies at the intersection of these subject areas.", "num_citations": "5\n", "authors": ["1516"]}
{"title": "Language and UML Support for Features: Two Research Challenges.\n", "abstract": " Features have been recognized as important building blocks of software product lines. Unfortunately, features have been mostly confined to modeling activities as they were originally conceived by Kang and his group in the early 90\u2019s. In this paper we address the negative impact this has had on product line development and how research on programming languages and UML support for features can help.", "num_citations": "5\n", "authors": ["1516"]}
{"title": "Taming aspect composition: A functional approach\n", "abstract": " Aspect Oriented Programing is a promising paradigm that challenges traditional notions of program modularity. Despite its increasing acceptance, aspects have been documented to suffer limited reuse, unpredictable behavior, and difficult modular reasoning. We develop an algebraic model that treats aspects as program transformations and uncovers aspect composition as the source of the problems mentioned. We propose an alternative model of composition that eliminates these problems, preserves the power of aspects, and lays out an algebraic foundation on which to build and understand AOP tools.", "num_citations": "5\n", "authors": ["1516"]}
{"title": "Customization support in computer-based technologies for autism: A systematic mapping study\n", "abstract": " Autism Spectrum Disorder (ASD) is a neurodevelopmental condition characterized by social interaction and communication difficulties, along with narrow and repetitive interests. Being a spectrum disorder, ASD affects individuals with a large range of combinations of challenges along dimensions such as intelligence, social skills, or sensory processing. Hence, any computer-based technology for ASD ought to be customizable to fit the particular profile of each individual that uses it. The main goal of our survey is to collect and characterize the customization support that has been researched for these technologies, which we analyze along clinical and technological dimensions. Our survey revealed that despite its importance, customization support for these technologies remains a subject largely unexplored. Furthermore, we propose alternatives on how to address the limitations identified.", "num_citations": "3\n", "authors": ["1516"]}
{"title": "Predicting higher order structural feature interactions in variable systems\n", "abstract": " Robust and effective support for the detection and management of software features and their interactions is crucial for many development tasks but has proven to be an elusive goal despite extensive research on the subject. This is especially challenging for variable systems where multiple variants of a system and their features must be collectively considered. Here an important issue is the typically large number of feature interactions that can occur in variable systems. We propose a method that computes, from a set of known source code level interactions of n features, the relevant interactions involving n+1 features. Our method is based on the insight that, if a set of features interact, it is much more likely that these features also interact with additional features, as opposed to completely different features interacting. This key insight enables us to drastically prune the space of potential feature interactions to those\u00a0\u2026", "num_citations": "3\n", "authors": ["1516"]}
{"title": "Towards crosscutting metrics for aspect-based features\n", "abstract": " Features are increments in program functionality and are the building blocks of product lines. Typical implementation of features using Object Oriented techniques commonly crosscuts several classes and interfaces. There exist many techniques that implement crosscuts, of which Aspect Oriented ones distinguish themselves by their support of dynamic crosscuts expressed with advice. Despite being a core tenet of AOP, very little attention has been paid to measuring crosscuts and how they are implemented by different language constructs in particular advice. In this paper we present a semi-formal definition of a set of basic metrics to measure crosscutting in features that use aspects. Our metrics categorize features within a crosscutting spectrum that ranges from heterogeneous to homogeneous according to the relative number and types of crosscuts features implement. This categorization helps assessing the actual use of aspects for feature implementation and provides a quantitative framework to gauge at and analyze the impact of aspects for product line development. We apply our metrics to a nontrivial product line case study implemented using AspectJ and relate our results to the ongoing assessment of aspects vs. collaboration-based designs for feature implementation.", "num_citations": "3\n", "authors": ["1516"]}
{"title": "An assessment of the effectiveness of interactive technology in an introductory programming course for non-majors\n", "abstract": " Programming skills are in increasing demand in nearly all disciplines. To cater to this demand the Computer Sciences department, at our institution, offers programming courses tailored for non-majors. Historically, we have observed the highest drop rate in the introductory course even though most of the students have had some prior experience with computers. Course evaluations indicate that most of them feel that programming is a challenging intellectual exercise. To allay student concerns we decided to apply active learning techniques in the lectures as well as in the discussion sessions. We wanted to give students feedback on their understanding of the lecture material during the class period and thereby reinforce their learning process. We also wanted some insight on how well the lecture material was being assimilated. For these purposes, we used the classroom performance system (CPS), which is a\u00a0\u2026", "num_citations": "3\n", "authors": ["1516"]}
{"title": "Answering the Call of the Wild? Thoughts on the Elusive Quest for Ecological Validity in Variability Modeling\n", "abstract": " Ecological validity is a term commonly used in several disciplines to refer to the fact that in a research study, the methods, the materials, and the settings must approximate the real world, ie what happens in everyday life. Variability modeling is no exception, it has striven for this form of validity by looking at two main sources, industrial projects and open source projects. Despite their unquestionable value, industrial projects inherently pose limitations; for instance, in terms of open access or results replication, which are two important tenets for any scientific endeavor. In this paper, we present our first findings on the use of open source projects in variability modeling research, and identify trends and avenues for further research.", "num_citations": "2\n", "authors": ["1516"]}
{"title": "Improving CASA runtime performance by exploiting basic feature model analysis\n", "abstract": " In Software Product Line Engineering (SPLE) families of systems are designed, rather than developing the individual systems independently. Combinatorial Interaction Testing has proven to be effective for testing in the context of SPLE, where a representative subset of products is chosen for testing in place of the complete family. Such a subset of products can be determined by computing a so called t-wise Covering Array (tCA), whose computation is NP-complete. Recently, reduction rules that exploit basic feature model analysis have been proposed that reduce the number of elements that need to be considered during the computation of tCAs for Software Product Lines (SPLs). We applied these rules to CASA, a simulated annealing algorithm for tCA generation for SPLs. We evaluated the adapted version of CASA using 133 publicly available feature models and could record on average a speedup of  of median execution time, while at the same time preserving the coverage of the generated array.", "num_citations": "2\n", "authors": ["1516"]}
{"title": "Models, features and algebras: An exploratory study of model composition and software product lines\n", "abstract": " Models, features and algebras: An exploratory study of model composition and software product lines - Espace \u00c9TS ENGLISH Logo La vitrine de diffusion des publications et contributions des chercheurs de l'\u00c9TS RECHERCHER Se connecter Accueil D\u00e9poser Nouveaut\u00e9s Recherche Rep\u00e9rage \u00c0 propos Conditions d'utilisation Politique de d\u00e9p\u00f4t M\u00e9moires et th\u00e8ses Nous joindre Models, features and algebras: An exploratory study of model composition and software product lines Lopez-Herrejon, Roberto E.. 2008. \u00ab Models, features and algebras: An exploratory study of model composition and software product lines \u00bb. In Proceedings of the Third International Conference on Software and Data Technologies (Porto, Portugal, July 05-08, 2008) p. 293-296. ScitePress. Le plein texte de ce document n'est pas h\u00e9berg\u00e9 sur ce serveur. Rechercher dans Google Scholar URL Officielle: https://dx.doi.org/10.5220/\u2026", "num_citations": "2\n", "authors": ["1516"]}
{"title": "Feature designer-a feature modeling tool for. net\n", "abstract": " Feature designer - a feature modeling tool for .NET - Espace \u00c9TS ENGLISH Logo La vitrine de diffusion des publications et contributions des chercheurs de l'\u00c9TS RECHERCHER Se connecter Accueil D\u00e9poser Nouveaut\u00e9s Recherche Rep\u00e9rage \u00c0 propos Conditions d'utilisation Politique de d\u00e9p\u00f4t M\u00e9moires et th\u00e8ses Nous joindre Feature designer - a feature modeling tool for .NET Demetriou, Michalis et Lopez-Herrejon, Roberto E.. 2007. \u00ab Feature designer - a feature modeling tool for .NET \u00bb. In 11th International Conference Software Product Lines (SPLC) - Workshop - ViSPLE 2007 (Kyoto, Japan, Sept. 10-14, 2007) p. 94-99. IEEE Computer Society. Le plein texte de ce document n'est pas h\u00e9berg\u00e9 sur ce serveur. Rechercher dans Google Scholar Type de document: Compte rendu de conf\u00e9rence Professeur: Professeur Lopez-Herrejon, Roberto E. Affiliation: Autres Date de d\u00e9p\u00f4t: 08 d\u00e9c. 2020 19:50 Derni\u00e8re \u2026", "num_citations": "2\n", "authors": ["1516"]}