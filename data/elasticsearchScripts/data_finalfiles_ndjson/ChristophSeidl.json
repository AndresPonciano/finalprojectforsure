{"title": "A metamodel family for role-based modeling and programming languages\n", "abstract": " Role-based modeling has been proposed almost 40 years ago as a means to model complex and dynamic domains, because roles are able to capture both context-dependent and collaborative behavior of objects. Unfortunately, while several researchers have introduced the notion of roles to modeling and programming languages, only few have captured both the relational and the context-dependent nature of roles. In this work, we classify various proposals since 2000 and show the discontinuity and fragmentation of the whole research field. To overcome discontinuity, we propose a family of metamodels for role-based modeling languages. Each family member corresponds to a design decision captured in a feature model. In this way, it becomes feasible to generate a metamodel for each role-based approach. This allows for the combination and improvement of the different role-based modeling and\u00a0\u2026", "num_citations": "108\n", "authors": ["752"]}
{"title": "Co-evolution of models and feature mapping in software product lines\n", "abstract": " Software Product Lines (SPLs) are a successful approach to software reuse in the large. Even though tools exist to create SPLs, their evolution is widely unexplored. Evolving an SPL manually is tedious and error-prone as it is hard to avoid unintended side-effects that may harm the consistency of the SPL. The main contribution of this paper is the conceptual basis of a system for the evolution of model-based SPLs, which maintains consistency of models and feature mapping. As further contribution, a novel classification is introduced that distinguishes evolutions by their potential to harm the mapping of an SPL. In addition, multiple remapping operators are presented that can remedy the negative side-effects of evolutions in order to co-evolve the feature mapping. Finally, an implementation of the evolution system in the SPL tool FeatureMapper is provided to demonstrate the capabilities of the presented approach\u00a0\u2026", "num_citations": "72\n", "authors": ["752"]}
{"title": "Towards modeling and analyzing variability in evolving software ecosystems\n", "abstract": " A software ecosystem (SECO) encompasses a set of interdependent software systems where individual products are created by combining a common software platform with variable extensions. Examples are the SECOs surrounding Eclipse or Android. Due to independent release cycles of the multiple vendors for platform and extensions, SECOs are evolving frequently. This makes it hard to get a concise impression of the structure of a SECO and its variable artifacts during a given period of time. We contribute a metamodel to capture the variability in an arbitrary SECO and its evolution based on the notion of real time. We further present a procedure to create temporal perspectives on the SECO. Additionally, we provide means to analyze evolution of variability in between explicit releases of the platform, eg, in accordance with the different release cycles of individual extensions. We demonstrate feasibility of our\u00a0\u2026", "num_citations": "32\n", "authors": ["752"]}
{"title": "DarwinSPL: An integrated tool suite for modeling evolving context-aware software product lines\n", "abstract": " Software Product Lines (SPLs) are an approach for large-scale reuse for software families by means of variabilities and commonalities. We consider three dimensions of variability representing sources of software systems to behave differently: configuration as spatial variability, dependence on surroundings as contextual variability and evolution as temporal variability. The three dimensions of variability strongly correlate: Contextual variability changes the set of possible configurations in spatial variability. Temporal variability captures changes of spatial and contextual variability over the course of time. However, currently, there is no tool support for integrated modeling of these three dimensions of variability. In this paper, we present DarwinSPL, a tool suite supporting integrated definition of spatial, contextual and temporal variability. With DarwinSPL, spatial variability is modeled as feature models with constraints\u00a0\u2026", "num_citations": "29\n", "authors": ["752"]}
{"title": "Guaranteeing configuration validity in evolving software product lines\n", "abstract": " Software Product Lines (SPLs) are an approach to capture families of closely related software systems in terms of commonalities and variabilities where individual variants are defined by configurations of selected features. Specific (partial) configurations may be of particular importance to SPL manufacturers, eg, if they are very popular or used by major customers. SPLs are subject to evolution, which may inadvertently break existing configurations, eg, if a previously selected feature does no longer exist. This is problematic as it may delay or completely prevent creation of previously existing important variants causing monetary loss and customer dissatisfaction. In this paper, we present a method to lock specific configurations to ensure their validity during evolution of the SPL. For this, we present Temporal Feature Models (TFMs) and dedicated evolution operations as a semantic-enriched first-class notion for\u00a0\u2026", "num_citations": "29\n", "authors": ["752"]}
{"title": "A seamless integration, semantic middleware for cyber-physical systems\n", "abstract": " In this work, the process of developing a flexible and semantic middleware (SeMiWa) for cyber-physical systems is presented. The proposed system focus the challenge of controllability in a heterogeneous wireless infrastructure of a smart home environment. With the semantic and model-based approach, it is possible to react on this rapidly changing environment and therefore, assist the user seamless integrate its devices, e.g. new sensors. To solve the problem of interoperability, we use semantic annotated XMPP messages as transmission format, a semantic annotator for unifying all heterogeneous sensor data and a semantic query language for handling later registered or removed devices without changing ongoing processes. We evaluate our solution with a test installation by using the requirements for middleware-based cyber-physical systems.", "num_citations": "19\n", "authors": ["752"]}
{"title": "Program dependency analysis for consolidating customized product copies\n", "abstract": " To cope with project constraints, copying and customizing existing software products is a typical practice to flexibly serve customer-specific needs. In the long term, this practice becomes a limitation for growth due to redundant maintenance efforts or wasted synergy and cross selling potentials. To mitigate this limitation, customized copies need to be consolidated into a single, variable code base of a software product line (SPL). However, consolidation is tedious as one must identify and correlate differences between the copies to design future variability. For one, existing consolidation approaches lack support of the implementation level. In addition, approaches in the fields of difference analysis and feature detection are not sufficiently integrated for finding relationships between code modifications. In this paper, we present remedy to this problem by integrating a difference analysis with a program dependency\u00a0\u2026", "num_citations": "14\n", "authors": ["752"]}
{"title": "A capability-based framework for programming small domestic service robots\n", "abstract": " Currently, small domestic service robots are on the verge of becoming a mass product for assisting end customers with everyday tasks. Despite open programming interfaces provided by robot manufacturers, many different robot systems exist that have to be programmed individually due to technical differences. The Robot Operating System (ROS) helps alleviate this problem, but provides only a low abstraction level, which hinders easy application development for entire classes of robots. This paper presents a high-level abstraction API for uniform programming and control of small domestic service-robots that support moving to various locations, grabbing items and basic two-way communication. The programming framework employs robot capabilities as abstractions and thereby facilitates intuitive use and extensibility. It builds on ROS functionality but hides underlying complexity from developers. We demonstrate\u00a0\u2026", "num_citations": "11\n", "authors": ["752"]}
{"title": "Formal foundations for analyzing and refactoring delta-oriented model-based software product lines\n", "abstract": " Model-Based Software Product Line (MBSPL) Engineering combines Model-Based Software Engineering (MBSE) and Software Product Line (SPL) Engineering by specifying variability in models and generating model variants as products of an MBSPL. Delta Modeling (DM) is a transformational approach for implementing MBSPLs by adding, removing or modifying model elements through delta modules to activate individual features. To date, the applicability of DM to real-world MBSPLs is severely hindered due to the resulting complex network of interrelated delta modules in which errors are hard to identify and fix without unintentionally harming overall consistency. To address this challenge, we present a set of analyses to identify problems in a network of delta modules as well as a construction kit to assemble refactorings to remedy these problems and simplify the network. We give a modeling-language\u00a0\u2026", "num_citations": "9\n", "authors": ["752"]}
{"title": "A technology-neutral role-based collaboration model for software ecosystems\n", "abstract": " In large-scale software ecosystems, many developers contribute extensions to a common software platform. Due to the independent development efforts and the lack of a central steering mechanism, similar functionality may be developed multiple times by different developers. We tackle this problem by contributing a role-based collaboration model for software ecosystems to make such implicit similarities explicit and to raise awareness among developers during their ongoing efforts. We extract this model based on realization artifacts in a specific programming language located in a particular source code repository and present it in a technology-neutral way. We capture five essential collaborations as independent role models that may be composed to present developer collaborations of a software ecosystem in their entirety, which fosters overview of the software ecosystem, analyses of duplicated\u00a0\u2026", "num_citations": "5\n", "authors": ["752"]}
{"title": "A combined simulation and test case generation strategy for self-adaptive systems\n", "abstract": " With the introduction of self-adaptivity in software architecture, it becomes feasible to automate tasks that are performed under changing conditions. In order to validate systems with such capabilities, the conditions have to be enforced and reactions verified. An adequate set of scenarios must be performed to assure the required quality level. In our previous work, we investigated a set of requirements for a self-adaptive system validation strategy as well as a high-level solution scheme. In this paper, we instantiate this scheme and propose a set of timed models that work together as black box test model for our example SAS HomeTurtle. The model can be either used for simulation or test case generation; for both approaches, a unifying infrastructure is described. We further show an example simulation run and present our implementation\u2014the Modeldriven Adaptivity Test Environment. The proposed methodology enables test experts to maintain the complex behavior of SAS and cover an adequate part of it in testing.", "num_citations": "5\n", "authors": ["752"]}
{"title": "A black box validation strategy for self-adaptive systems\n", "abstract": " Self-adaptive systems are able to operate autonomously by reconfiguring themselves for changing context conditions and tasks. This capability requires a process of decision making that can only be partially hard-coded. Some parts of the logic are the result of reasoning and, thus, implicit to the system designer or user. In consequence, the quality of the systems functionality has to be extensively validated before delivery. During the validation, firstly, the response of adaptation decisions as a result of environment change has to be examined. Secondly, it is necessary to check the interaction of adaptation and non-adaptationrelated behavior. The management of all this information is expensive. Therefore, we propose an approach that separates environment change, functionality and adaptation concerns using expressive models. The models are executed by a simulator and validated against the real behavior of the system under test. We illustrate the complete approach using an example SAS operating a domestic service robot. Our design process and the proposed modeling principles equip engineers with a toolset that allows them to face the challenging complexity of self-adaptive system validation.", "num_citations": "4\n", "authors": ["752"]}
{"title": "Delta-oriented development of model-based software product lines with DeltaEcore and SiPL: A comparison\n", "abstract": " Model-based development has become a widely used approach to implement software, especially for embedded systems. Such systems must often be delivered to customers in a large number of variants exposing slightly different functionality. This need is addressed by model-based software product line (MBSPL) engineering. Implementation methodologies for MBSPLs have to be able to specify variability in models and to generate models as instances of an MBSPL. Delta modeling is a transformational approach to implement variability of an MBSPL. Variants are generated by applying one or several delta modules onto a core model. While the basic concepts of delta modeling for MBSPLs are well understood, essential development tasks such as implementation and analysis of delta modules as well as managing entire networks of delta modules are barely supported by many tools. Both our tool suites\u00a0\u2026", "num_citations": "3\n", "authors": ["752"]}
{"title": "Evolution in feature-oriented model-based software product line engineering\n", "abstract": " Software is almost everywhere\u2014as application for smart phones, in the multimedia system of cars or as desktop program for home computers. With this wide variety of platforms, it becomes more and more important to provide programs supporting multiple systems. For instance, an application for a home computer might also be available in a smart phone version. However, different platforms have different characteristics, such as processor speed or display size. Thus, there are equally different requirements for the software of these systems. One successful approach of dealing with this variety is the concept of software product lines. In a software product line, functionality is described in terms of so called features that each realize a set of requirements. For example, one particular feature might provide a user interface for large displays for home computers whereas another feature creates a version for the small displays of smart phones. The appropriate feature may then be chosen to build one particular application for a specified platform.However, the area of possible applications for software product lines extends beyond providing customized versions of one application for different platforms. In a more general setting, software product lines encompass an entire set of related applications. For example, an office suite might be implemented in terms of features that can be used to create the individual tools such as a text processor or a spread sheet calculation program. These characteristics make software product lines appealing to the industry and a successful approach to software reuse.", "num_citations": "3\n", "authors": ["752"]}
{"title": "Deployment by construction for multicore architectures\n", "abstract": " In stepwise program development, abstract specifications can be transformed into (parallel) programs which preserve functional correctness. Although tackling bad performance after a program\u2019s deployment may require a costly redesign, deployment decisions are usually made very late in program development. This paper argues for the introduction of deployment decisions as an integrated part of a development-by-construction process: Deployment decisions should be expressed as part of a program\u2019s high-level model and evaluated by how they affect program performance, using metrics at an appropriate level of abstraction. To illustrate such a deployment-by-construction process, we sketch how deployment decisions may be modelled and evaluated, concerning data layout in shared memory for parallel programs targeting shared-memory multicore architectures with caches. For simplicity, we use an\u00a0\u2026", "num_citations": "2\n", "authors": ["752"]}
{"title": "Integrated Management of Variability in Space and Time in Software Families\n", "abstract": " Abstract (EN) Software Product Lines (SPLs) and Software Ecosystems (SECOs) are approaches to capturing families of closely related software systems in terms of common and variable functionality (variability in space). SPLs and especially SECOs are subject to software evolution to adapt to new or changed requirements resulting in different versions of the software family and its variable assets (variability in time). Both dimensions may be interconnected (eg, through version incompatibilities) and, thus, have to be handled simultaneously as not all customers upgrade their respective products immediately or completely. However, there currently is no integrated approach allowing variant derivation of features in different version combinations. In this thesis, remedy is provided in the form of an integrated approach making contributions in three areas:(1) As variability model, Hyper-Feature Models (HFMs) and a\u00a0\u2026", "num_citations": "2\n", "authors": ["752"]}
{"title": "Automated metamodel augmentation for seamless model evolution tracking and planning\n", "abstract": " In model-based software engineering, models are central artifacts used for management, design and implementation. To meet new requirements, engineers need to plan and perform model evolution. So far, model evolution histories are captured using Version Control Systems (VCSs), eg, Git. However, these systems are unsuitable for planning model evolution as they do not have a notion of future changes. Furthermore, formally assigning responsibilities to engineers for performing evolution of model parts is achieved by using additional tools for access control. To remedy these shortcomings, we provide a method to generate evolution-aware modeling notations by augmenting existing metamodels with concepts for capturing past and planned evolution as first-class entity. Our method enables engineers to seamlessly plan future model evolution while actively developing the current model state, both using a\u00a0\u2026", "num_citations": "1\n", "authors": ["752"]}
{"title": "Teaching variability engineering to cognitive psychologists\n", "abstract": " In research of cognitive psychology, experiments to measure cognitive processes may be run in many similar yet slightly different configurations. Variability engineering offers techniques to handle variable configurations both conceptually and technically. However, these techniques are largely unknown to cognitive psychologists so that experiment configurations are specified informally or too coarse grain. This is problematic, because it becomes difficult to get an overview of paradigm configurations used in the so far conducted experiments. Variability engineering techniques provide, ia, concise notations for capturing variability in software and can also be used to express the configurable nature of a wide range of experiments in cognitive psychology. Furthermore, it enables cognitive psychologists to structure configuration knowledge, to identify suitably similar experiment setups and to more efficiently identify\u00a0\u2026", "num_citations": "1\n", "authors": ["752"]}