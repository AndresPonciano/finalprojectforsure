{"title": "XQuery 1.0: An XML query language\n", "abstract": " XML is a versatile markup language, capable of labeling the information content of diverse data sources including structured and semi-structured documents, relational databases, and object repositories. A query language that uses the structure of XML intelligently can express queries across all these kinds of data, whether physically stored in XML or viewed as XML via middleware. This specification describes a query language called XQuery, which is designed to be broadly applicable across many types of XML data sources.", "num_citations": "1270\n", "authors": ["1886"]}
{"title": "From XML schema to relations: A cost-based approach to XML storage\n", "abstract": " As Web applications manipulate an increasing amount of XML, there is a growing interest in storing XML data in relational databases. Due to the mismatch between the complexity of XML's tree structure and the simplicity of flat relational tables, there are many ways to store the same document in an RDBMS, and a number of heuristic techniques have been proposed. These techniques typically define fixed mappings and do not take application characteristics into account. However, a fixed mapping is unlikely to work well for all possible applications. In contrast, LegoDB is a cost-based XML storage mapping engine that explores a space of possible XML-to-relational mappings and selects the best mapping for a given application. LegoDB leverages current XML and relational technologies: (1) it models the target application with an XML Schema, XML data statistics, and an XQuery workload; (2) the space of\u00a0\u2026", "num_citations": "504\n", "authors": ["1886"]}
{"title": "Integrity constraints for XML\n", "abstract": " Integrity constraints have proved fundamentally important in database management. The ID/IDREF mechanism provided by XML DTDs relies on a simple form of constraints to describe references. Yet, this mechanism is sufficient neither for specifying references in XML documents, nor for expressing semantic constraints commonly found in databases. In this paper, we extend XML DTDs with several classes of integrity constraints and investigate the complexity of reasoning about these constraints. The constraints range over keys, foreign keys, inverse constraints as well as ID constraints for capturing the semantics of object identities. They improve semantic specifications and provide a better reference mechanism for native XML applications. They are also useful in information exchange and data integration for preserving the semantics of data originating in relational and object-oriented databases. We establish\u00a0\u2026", "num_citations": "313\n", "authors": ["1886"]}
{"title": "XQuery: A query language for XML\n", "abstract": " XQuery: A Query Language for XML Page 1 XQuery: A Query Language for XML Don Chamberlin IBM Almaden Research Center June 11, 2003 Page 2 2 History \u25cf 1998: W3C sponsors workshop on XML Query \u25cf 1999: W3C charters XML Query working group \u25cf Chair: Paul Cotton \u25cf Currently 39 members, representing 25 companies \u25cf 2000: WG publishes req'ts, use cases, data model \u25cf 2001: WG publishes draft language spec's \u25cf 2002: Working drafts updated periodically \u25cf 2003: WG publishes full-text req'ts and use cases; XQuery Version 1 working drafts enter \"last call\" Page 3 3 Resources \u25cf Public website: www.w3.org/XML/Query \u25cf Working drafts of language spec's \u25cf Links to reference implementations \u25cf Link to XQuery grammar test applet \u25cf Member's website: www.w3.org/XML/Group/Query \u25cf Minutes, membership, internal documents \u25cf Public comments: \u25cf Post to: public-qt-comments@w3.org \u2026", "num_citations": "305\n", "authors": ["1886"]}
{"title": "XQuery 1.0: An XML query language\n", "abstract": " XML is an extremely versatile markup language, capable of labeling the information content of diverse data sources including structured and semi-structured documents, relational databases, and object repositories. A query language that uses the structure of XML intelligently can express queries across all these kinds of data, whether physically stored in XML or viewed as XML via middleware. Because query languages have traditionally been designed for specific kinds of data, most existing proposals for XML query languages are robust for particular types of data sources but weak for other types. This specification describes a new query language called XQuery, which is designed to be broadly applicable across all types of XML data sources.", "num_citations": "281\n", "authors": ["1886"]}
{"title": "Querying documents in object databases\n", "abstract": " structuring schemas                that consist in grammars annotated with database programs. To query documents, we introduce an extension of OQL, the ODMG standard query language for object databases. Our extension (named OQL-doc) allows us to query documents without a precise knowledge of their structure using in particular generalized path expressions and pattern matching. This allows us to introduce in a declarative language (in the style of SQL or OQL), navigational and information retrieval styles of accessing data. Query processing in the context of documents and path expressions leads to challenging implementation issues. We extend an object algebra with new operators to deal with generalized path expressions. We then consider two essential complementary optimization techniques. We show that almost standard database optimization techniques can be used to answer queries without having to\u00a0\u2026", "num_citations": "235\n", "authors": ["1886"]}
{"title": "Projecting XML documents\n", "abstract": " Publisher SummaryThis chapter presents projection techniques that can be used to support main-memory XQuery evaluation over large XML documents. The chapter introduces a path analysis technique that infers the set of paths used for an arbitrary XQuery expression. The experiments show that this technique can be used to evaluate queries on files up to two Gigabyte even on machines with limited memory. The chapter reveals that XQuery is not only useful to query XML in databases, but also to applications that must process XML documents as files or streams. These applications suffer from the limitations of current main-memory XQuery processors, which break for rather small documents. This chapter proposes techniques, based on a notion of projection for XML, which can be used to drastically reduce memory requirements in XQuery processors. The chapter presents a loading algorithm that takes the\u00a0\u2026", "num_citations": "218\n", "authors": ["1886"]}
{"title": "StatiX: making XML count\n", "abstract": " The availability of summary data for XML documents has many applications, from providing users with quick feedback about their queries, to cost-based storage design and query optimization. StatiX is a novel XML Schema-aware statistics framework that exploits the structure derived by regular expressions (which define elements in an XML Schema) to pinpoint places in the schema that are likely sources of structural skew. As we discuss below, this information can be used to build concise, yet accurate, statistical summaries for XML data. StatiX leverages standard XML technology for gathering statistics, notably XML Schema validators, and it uses histograms to summarize both the structure and values in an XML document. In this paper we describe the StatiX system. We develop algorithms that decompose schemas to obtain statistics at different granularities and discuss how statistics can be gathered as\u00a0\u2026", "num_citations": "189\n", "authors": ["1886"]}
{"title": "Constraints for semistructured data and XML\n", "abstract": " Integrity constraints play a fundamental role in database design. We review initial work on the expression of integrity constraints for semistructured data and XML.", "num_citations": "183\n", "authors": ["1886"]}
{"title": "The essence of XML\n", "abstract": " The World-Wide Web Consortium (W3C) promotes XML and related standards, including XML Schema, XQuery, and XPath. This paper describes a formalization of XML Schema. A formal semantics based on these ideas is part of the official XQuery and XPath specification, one of the first uses of formal methods by a standards body. XML Schema features both named and structural types, with structure based on tree grammars. While structural types and matching have been studied in other work (notably XDuce, Relax NG, and a previous formalization of XML Schema), this is the first work to study the relation between named types and structural types, and the relation between matching and validation.", "num_citations": "147\n", "authors": ["1886"]}
{"title": "XQuery from the experts: a guide to the W3C XML query language\n", "abstract": " &\u2022 Nobody knows XQuery better than this group of &\" experts, &\" after all they created it. We've cornered the market on expertise in XQuery. & &\u2022 Allows readers to focus on either or both a tutorial or reference-style approach as best suits them. & &\u2022 Currently, there are no other competing XQuery books. Authors' personal perspectives offer a welcome change to formal standards specs.", "num_citations": "136\n", "authors": ["1886"]}
{"title": "The Yin/Yang web: XML syntax and RDF semantics\n", "abstract": " XML is the W3C standard document format for writing and exchanging information on the Web. RDF is the W3C standard model for describing the semantics and reasoning about information on the Web. Unfortunately, RDF and XML---although very close to each other---are based on two different paradigms. We argue that in order to lead the Semantic Web to its full potential, the syntax and the semantics of information needs to work together. To this end, we develop a model-theoretic semantics for the XML XQuery 1.0 and XPath 2.0 Data Model, which provides a unified model for both XML and RDF. This unified model can serve as the basis for Web applications that deal with both data and semantics. We illustrate the use of this model on a concrete information integration scenario. Our approach enables each side of the fence to benefit from the other, notably, we show how the RDF world can take advantage of\u00a0\u2026", "num_citations": "126\n", "authors": ["1886"]}
{"title": "An algebra for XML query\n", "abstract": " This document proposes an algebra for XML Query. The algebra has been submitted to the W3CXM L Query Working Group. A novel feature of the algebra is the use of regular-expression types, similar in power to DTDs or XML Schemas, and closely related to Hasoya, Pierce, and Vouillon\u2019s work on Xduce. The iteration construct involves novel typing rules not encountered elsewhere (even in Xduce).", "num_citations": "119\n", "authors": ["1886"]}
{"title": "Implementing xquery 1.0: The galax experience\n", "abstract": " Publisher SummaryThis chapter demonstrates the Galax system as well as its most advanced features, including support for XPath 2.0, XML Schema, and static type checking. It also presents some of the first experiments with optimization. The chapter demonstrates query-rewriting capabilities in the Galax compiler, and the ability to run queries on documents up to a Gigabyte without the need for preindexing. Although early versions of Galax have been shown in industrial conferences over the past, this is the first time it is demonstrated in the database community. Galax is a light-weight, portable, open-source implementation of XQuery 1.0. Started in December 2000 as a small prototype designed to test the XQuery static type system, Galax has now become a solid implementation, aiming at full conformance with the family of XQuery 1.0 specifications. Because of its completeness and open architecture, Galax also\u00a0\u2026", "num_citations": "112\n", "authors": ["1886"]}
{"title": "A complete and efficient algebraic compiler for XQuery\n", "abstract": " As XQuery nears standardization, more sophisticated XQuery applications are emerging, which often exploit the entire language and are applied to non-trivial XML sources. We propose an algebra and optimization techniques that are suitable for building an XQuery compiler that is complete, correct, and efficient. We describe the compilation rules for the complete language into that algebra and present novel optimization techniques that address the needs of complex queries. These techniques include new query unnesting rewritings and specialized join algorithms that account for XQuery\u2019s complex predicate semantics. The algebra and optimizations are implemented in the Galax XQuery engine, and yield execution plans that are up to three orders of magnitude faster than earlier versions of Galax.", "num_citations": "100\n", "authors": ["1886"]}
{"title": "Tools for data translation and integration\n", "abstract": " A broad spectrum of data is available on the Web in distinct heterogeneous sources, stored under different formats. As the number of systems that utilize this data grows, the importance of data conversion mechanisms increases greatly. We present here an overview of a French-Israeli research project aimed at developing tools to simplify the intricate task of data translation. The solution is based on a middleware data model to which various data sources are mapped, and a declarative language for specifying translations within the middleware model. A complementary schema-based mechanism is used to automate some of the translation. Some particular aspects of the solution are detailed in [3, 7, 10].", "num_citations": "97\n", "authors": ["1886"]}
{"title": "A semi-monad for semi-structured data (ICDT version)\n", "abstract": " This document proposes an algebra for XML Query. The algebra has been submitted to the W3C XML Query Working Group. A novel feature of the algebra is the use of regular-expression types, similar in power to DTDs or XML Schemas, and closely related to Hasoya and Pierce\u2019s work on Xduce. The iteration construct is based on the notion of a monad, and involves novel typing rules not encountered elsewhere.", "num_citations": "88\n", "authors": ["1886"]}
{"title": "XML query languages: Experiences and exemplars\n", "abstract": " This paper identi es essential features of an XML query language by examining four existing query languages: XML-QL, YATL, Lorel, and XQL. The rst three languages come from the database community and possess striking similarities. The fourth comes from the document community and lacks some key functionality of the other three.", "num_citations": "83\n", "authors": ["1886"]}
{"title": "Cost-based storage of extensible markup language (XML) data\n", "abstract": " Extensible Markup Language (XML) data is mapped to be stored in an alternative data base management system (DBMS) by generating a plurality of alternative ones of mappings in response to a supplied XML document and corresponding XML schema; evaluating at least a prescribed attribute of each of the plurality of mappings with respect to an expected workload for the storage system; and selecting one of the alternative mappings based on the prescribed attribute which is the most advantageous for the expected system workload. More specifically, applicants employ a unique process that utilizes a unique notion of physical XML Schemas, ie, P-Schemas; a P-Schema costing procedure; a set of P-Schema rewritings; and a search strategy to heuristically determine the P-Schema with the least cost. Specifically, the unique notion of physical XML Schemas, extend XML Schemas to contain data statistics; a P\u00a0\u2026", "num_citations": "78\n", "authors": ["1886"]}
{"title": "A unified constraint model for XML\n", "abstract": " Integrity constraints are an essential part of modern schema definition languages. They are useful for semantic specification, update consistency control, query optimization, information preservation, etc. In this paper, we propose UCM, a model of integrity constraints for XML that is both simple and expressive.Because it relies on a single notion of keys and foreign keys, the UCM model is easy to use and makes formal reasoning possible. Because it relies on a powerful type system, the UCM model is expressive, capturing in a single framework the constraints found in relational databases, objectoriented schemas and XML DTDs. We study the problem of consistency of UCM constraints, the interaction between constraints and subtyping, and algorithms for implementing these constraints.", "num_citations": "73\n", "authors": ["1886"]}
{"title": "An XQuery-based language for processing updates in XML\n", "abstract": " Extensive usage of XML for information exchange and data processing has led to the development of standard languages for querying and publishing of XML data. However, a key problem in XML data management is the absence of a standard language to update XML. As a result, updates are carried out in a mostly ad-hoc fashion at the application level by writing code to modify tree-based structures representing XML documents in memory. So far very little research has been conducted on language-based updates and their impact on XML processing. In this paper we present UpdateX, our implementation of a declarative update language that can be used to directly update XML data using queries. Our update language is based on XQuery 1.0, W3C\u2019s XML query language, and seamlessly integrates with all of its constructs and capabilities. We describe the user-level syntax of our update language and present a framework for its implementation. The UpdateX prototype, which has been implemented on top of the Galax XQuery 1.0 processor, is fully functional and its source code distribution is publicly available on the Web.", "num_citations": "68\n", "authors": ["1886"]}
{"title": "Building the semantic web on XML\n", "abstract": " The semantic discontinuity between World-Wide Web languages, e.g., XML, XML Schema, and XPath, and Semantic Web languages, e.g., RDF, RDFS, and DAML+OIL, forms a serious barrier for the stated goals of the Semantic Web. This discontinuity results from a difference in modeling foundations between XML and logics. We propose to eliminate that discontinuity by creating a common semantic foundation for both the World-Wide Web and the Semantic Web, taking ideas from both. The common foundation results in essentially no change to XML, and only minor changes to RDF. But it allows the Semantic Web to get closer to its goal of describing the semantics of the World Wide Web. Other Semantic Web languages (including RDFS and DAML+OIL) are considerably changed because of this common foundation.", "num_citations": "63\n", "authors": ["1886"]}
{"title": "Subsumption for XML types\n", "abstract": " XML data is often used (validated, stored, queried, etc) with respect to different types. Understanding the relationship between these types can provide important information for manipulating this data. We propose a notion of subsumption for XML to capture such relationships. Subsumption relies on a syntactic mapping between types, and can be used for facilitating validation and query processing. We study the properties of subsumption, in particular the notion of the greatest lower bound of two schemas, and show how this can be used as a guide for selecting a storage structure. While less powerful than inclusion, subsumption generalizes several other mechanisms for reusing types, notably extension and refinement from XML Schema, and subtyping.", "num_citations": "59\n", "authors": ["1886"]}
{"title": "Xml path language (xpath)\n", "abstract": " XPath 2.0 is an expression language that allows the processing of values conforming to the data model defined in [XQuery/XPath Data Model (XDM)]. The data model provides a tree representation of XML documents as well as atomic values such as integers, strings, and booleans, and sequences that may contain both references to nodes in an XML document and atomic values. The result of an XPath expression may be a selection of nodes from the input documents, or an atomic value, or more generally, any sequence allowed by the data model. The name of the language derives from its most distinctive feature, the path expression, which provides a means of hierarchic addressing of the nodes in an XML tree. XPath 2.0 is a superset of [XPath 1.0], with the added capability to support a richer set of data types, and to take advantage of the type information that becomes available when documents are validated\u00a0\u2026", "num_citations": "57\n", "authors": ["1886"]}
{"title": "XQuery 1.0 formal semantics\n", "abstract": " This document presents the formal semantics of [XQuery 1.0: A Query Language for XML], an XML query language. This document replaces the [XML Query Algebra].", "num_citations": "56\n", "authors": ["1886"]}
{"title": "XQuery at your web service\n", "abstract": " XML messaging is at the heart of Web services, providing the flexibility required for their deployment, composition, and maintenance. Yet, current approaches to Web services development hide the messaging layer behind Java or C# APIs, preventing the application to get direct access to the underlying XML information. To address this problem, we advocate the use of a native XML language, namely XQuery, as an integral part of the Web services development infrastructure. The main contribution of the paper is a binding between WSDL, the Web Services Description Language, and XQuery. The approach enables the use of XQuery for both Web services deployment and composition. We present a simple command-line tool that can be used to automatically deploy a Web service from a given XQuery module, and extend the XQuery language itself with a statement for accessing one or more Web services. The\u00a0\u2026", "num_citations": "55\n", "authors": ["1886"]}
{"title": "Static and dynamic semantics of NoSQL languages\n", "abstract": " We present a calculus for processing semistructured data that spans differences of application area among several novel query languages, broadly categorized as \"NoSQL\". This calculus lets users define their own operators, capturing a wider range of data processing capabilities, whilst providing a typing precision so far typical only of primitive hard-coded operators. The type inference algorithm is based on semantic type checking, resulting in type information that is both precise, and flexible enough to handle structured and semistructured data. We illustrate the use of this calculus by encoding a large fragment of Jaql, including operations and iterators over JSON, embedded SQL expressions, and co-grouping, and show how the encoding directly yields a typing discipline for Jaql as it is, namely without the addition of any type definition or type annotation in the code.", "num_citations": "53\n", "authors": ["1886"]}
{"title": "The Xquery formal semantics: A foundation for implementation and optimization\n", "abstract": " XQuery is a strongly typed, functional language, which supports the common processing, transformation, and querying tasks of a wide variety of XML applications. Following the tradition of other functional languages, XQuery includes a complete formal semantics. In this paper, we argue that basing an XQuery implementation on the XQuery Formal Semantics not only ensures correctness, but is a good foundation for optimization. We describe an architecture that we have implemented and that is based on the XQuery Formal Semantics and describe several logical and physical optimizations that can be easily integrated in the above architecture.", "num_citations": "51\n", "authors": ["1886"]}
{"title": "Put a tree pattern in your algebra\n", "abstract": " To address the needs of data intensive XML applications, a number of efficient tree pattern algorithms have been proposed. Still, most XQuery compilers do not support those algorithms. This is due in part to the lack of support for tree patterns in XML algebras, but also because deciding which part of a query plan should be evaluated as a tree pattern is a hard problem. In this paper, we extend a tuple algebra for XQuery with a tree pattern operator, and present rewrit-ings suitable to introduce that operator in query plans. We demonstrate the robustness of the proposed rewritings under syntactic variations commonly found in queries. The proposed tree pattern operator can be implemented using popular algorithms such as Twig joins and Staircase joins. Our experiments yield useful information to decide which algorithm should be used in a given plan.", "num_citations": "49\n", "authors": ["1886"]}
{"title": "XQuery!: An XML query language with side effects\n", "abstract": " As XML applications become more complex, there is a growing interest in extending XQuery with side-effect operations, notably XML updates. However, the presence of side-effects is at odds with XQuery\u2019s declarative semantics in which evaluation order is unspecified. In this paper, we define \u201cXQuery!\u201d, an extension of XQuery 1.0 that supports first-class XML updates and user-level control over update application, preserving the benefits of XQuery\u2019s declarative semantics when possible. Our extensions can be easily implemented within an existing XQuery processor and we show how to recover basic database optimizations for such a language.", "num_citations": "49\n", "authors": ["1886"]}
{"title": "Using YAT to build a web server\n", "abstract": " Integration of heterogeneous data sources in a Web environment has become a major concern of the database community. Novel architectures, data models and query languages have been proposed but the complementary problem of data conversion has been less studied. The YAT system provides a means to build software components based on data conversion in a simple and declarative way. We show that the YAT system can also be used to create integrated Web views over heterogeneous data sources very easily. Only minor changes were required for YAT to provide data integration (as opposed to data conversion) in a Web environment. Finally, we report on our experience while building the Verso Web site using YAT.", "num_citations": "48\n", "authors": ["1886"]}
{"title": "LegoDB: Customizing relational storage for XML documents\n", "abstract": " Publisher SummaryeXtensible Markup Language (XML) is becoming the predominant data exchange format in a variety of application domains (supply-chain, scientific data processing, telecommunication infrastructure, etc.). Not only is an increasing amount of XML data now being processed, but XML is also increasingly being used in business-critical applications. Efficient and reliable storage is an important requirement for these applications. By relying on relational engines for this purpose, XML developers can benefit from a complete set of data management services (including concurrency control, crash recovery, and scalability) and from the highly optimized relational query processors. Strategies that automate the process of generating XML to relational mappings have been proposed in the literature. Due to the flexibility of the XML infrastructure, different XML applications exhibit widely different characteristics\u00a0\u2026", "num_citations": "46\n", "authors": ["1886"]}
{"title": "Workflow mediation using VorteXML.\n", "abstract": " The Internet and Web are revolutionizing the way companies interact with their suppliers, partners, and clients, by enabling substantial automation of the full spectrum of their business activities. In the 21st century economy, the primary form of automation will be B2B e-commerce, in which enterprises interact with each other through entirely automated means. As an example, consider an electronic market place in a vertical industry segment, in which suppliers and buyers tie into a common IT infrastructure to exchange goods and services. This forms a supply chain in which buyers investigate possible suppliers,(b) check the terms and conditions under which suppliers can do business,(c) interoperate with the suppliers\u2019 enterprise support systems, ie, workflows, and (d) monitor ordering/purchasing for possible delays, unexpected events, react to such events, etc. This paper presents a new framework for specifying, enacting and supervising e-services on the Web, based on XML and rules-based support for products/services description and workflow mediation across organizations. Traditionally, WorkFlow Management Systems (WFMS) have focused on homogeneous and centrally controlled environments for binding people and processes within the boundary of a single organization. In the context of B2B e-commerce, WFMSs need to support collaboration between various autonomous parties, some of which may even have conflicting business goals. More precisely, they must cope with heterogeneous enterprise support environments (eg, through different WF systems), to model the interaction of independent partners by abstracting the internal\u00a0\u2026", "num_citations": "39\n", "authors": ["1886"]}
{"title": "Having a ChuQL at XML on the Cloud.\n", "abstract": " MapReduce/Hadoop has gained acceptance as a framework to process, transform, integrate, and analyze massive amounts of Web data on the Cloud. The MapReduce model (simple, fault tolerant, data parallelism on elastic clouds of commodity servers) is also attractive for processing enterprise and scientific data. Despite XML ubiquity, there is yet little support for XML processing on top of MapReduce. In this paper, we describe ChuQL, a MapReduce extension to XQuery, with its corresponding Hadoop implementation. The ChuQL language incorporates records to support the key/value data model of MapReduce, leverages higher-order functions to provide clean semantics, and exploits side-effects to fully expose to XQuery developers the Hadoop framework. The ChuQL implementation distributes computation to multiple XQuery engines, providing developers with an expressive language to describe tasks over big data.", "num_citations": "38\n", "authors": ["1886"]}
{"title": "Optimizing sorting and duplicate elimination in XQuery path expressions\n", "abstract": " XQuery expressions can manipulate two kinds of order: document order and sequence order. While the user can impose or observe the order of items within a sequence, the results of path expressions must always be returned in document order. Correctness can be obtained by inserting explicit (and expensive) operations to sort and remove duplicates after each XPath step. However, many such operations are redundant. In this paper, we present a systematic approach to remove unnecessary sorting and duplicate elimination operations in path expressions in XQuery 1.0. The technique uses an automaton-based algorithm which we have applied successfully to path expressions within a complete XQuery implementation. Experimental results show that the algorithm detects and eliminates most redundant sorting and duplicate elimination operators and is very effective on common XQuery path expressions.", "num_citations": "38\n", "authors": ["1886"]}
{"title": "Highly distributed XQuery with DXQ\n", "abstract": " Many modern applications, from Grid computing to RSS handling, need to support data processing in a distributed environment. Currently, most such applications are implemented using a general purpose programming language, which can be expensive to maintain, hard to configure and modify, and require hand optimization of the distributed data processing operations. We present Distributed XQuery (DXQ), a simple, yet powerful, extension of XQuery to support distributed applications. This extension includes the ability to deploy networks of XQuery servers, to remotely invoke XQuery programs on those servers, and to ship code between servers. Our demonstration presents two applications implemented in DXQ: the resolution algorithm of DNS, the Domain Name System, and the Narada overlay-network protocol. We show that our system can flexibly accommodate different patterns of distributed computation\u00a0\u2026", "num_citations": "36\n", "authors": ["1886"]}
{"title": "YATL: a Functional and Declarative Language for XML\n", "abstract": " This paper describes YATL, a language to query, convert and integrate XML data. YATL comes from the database community: it is not Turing complete, but it captures a large class of useful data transformations, it is declarative and subject to optimization. The rst version of YATL was based on logic programming and datalog. This paper presents the new version of YATL which bene ts from functional programming in two ways. First, YATL is a functional language. The functional design aided in areas that are traditionally problematic for database languages: notably recursion, treatment of references, pattern matching, and processing of alternatives. Second, YATL is implemented in ML.", "num_citations": "34\n", "authors": ["1886"]}
{"title": "XQuery update facility 1.0\n", "abstract": " This document defines an update facility that extends the XML Query language, XQuery. The XQuery Update Facility provides expressions that can be used to make persistent changes to instances of the XQuery 1.0 and XPath 2.0 Data Model.", "num_citations": "33\n", "authors": ["1886"]}
{"title": "The XML query algebra\n", "abstract": " The XML Query Algebra Page 1 Peter Fankhauser, XML Query WG 1 The XML Query Algebra State & Challenges Peter Fankhauser GMD-IPSI fankhaus@darmstadt.gmd.de Page 2 Peter Fankhauser, XML Query WG 2 Overview \u2022 Context \u2022 Algebra \u2013 Data Level \u2022 Algebra \u2013 Type Level \u2022 Challenges Page 3 Peter Fankhauser, XML Query WG 3 XML Query \u2013 Requirements \u2022 General: \u2013 Formal Basis: XML Query Datamodel, XML Query Algebra \u2013 XML Schema: operators on all types, (static) typing \u2013 Declarativity: Optimizability \u2022 Functional (Dave Maier) \u2013 Selection: of documents/elements by content, structure, or attributes \u2013 Extraction: selection of subelements from an element \u2013 Reduction: projection of subelements from an element \u2013 Restructuring: nesting, unnesting, aggregations \u2013 Combination: joins Page 4 Peter Fankhauser, XML Query WG 4 XML Query Algebra \u2013 Context XML Query Datamodel PSV Infoset XML \u2026", "num_citations": "31\n", "authors": ["1886"]}
{"title": "XQuery streaming \u00e0 la carte\n", "abstract": " Existing work on XML query evaluation has either focused on algebraic optimization techniques suitable for XML databases, or on algorithms to efficiently process XML messages represented as a stream of parsing events. In practice, complex applications often must handle both. In this paper, we develop a physical algebra that combines streaming operators with other standard relational and XML operators. Our physical model includes marked XML streams, which permit efficient XPath evaluation, but can only be consumed once. This constraint restricts the use of streaming operators to fragments of a query plan that only access data using depth-first traversal. We develop static analysis techniques to decide which fragment of a plan can be streamed. Our experiments demonstrate the benefits of blending streaming with other evaluation techniques.", "num_citations": "30\n", "authors": ["1886"]}
{"title": "Dxq: A distributed xquery scripting language\n", "abstract": " We present DXQ, an extension of XQuery to support the effective and efficient development of distributed XML applications. A DXQ program can invoke remote DXQ programs both synchronously and asynchronously and can dynamically ship DXQ code to execute at remote servers. We illustrate the power of the language with two distributed applications: the resolution algorithm of the Domain Name System (DNS) and the Narada overlay-network protocol. Our implementation permits concurrent evaluation of DXQ expressions at each server and can produce results extensionally (as XML values) or intensionally (as DXQ expressions).", "num_citations": "29\n", "authors": ["1886"]}
{"title": "Compiling XSLT 2.0 into XQuery 1.0\n", "abstract": " As XQuery is gathering momentum as the standard query language for XML, there is a growing interest in using it as an integral part of the XML application development infrastructure. In that context, one question which is often raised is how well XQuery interoperates with other XML languages, and notably with XSLT. XQuery 1.0 [16] and XSLT 2.0 [7] share a lot in common: they share XPath 2.0 as a common sub-language and have the same expressiveness. However, they are based on fairly different programming paradigms. While XSLT has adopted a highly declarative template based approach, XQuery relies on a simpler, and more operational, functional approach. In this paper, we present an approach to compile XSLT 2.0 into XQuery 1.0, and a working implementation of that approach. The compilation rules explain how XSLT's template-based approach can be implemented using the functional approach of\u00a0\u2026", "num_citations": "29\n", "authors": ["1886"]}
{"title": "Growing xquery\n", "abstract": " XQuery is a typed, functional language for querying XML data sources. XQuery has features of both traditional query languages and modern functional languages. In this paper, we introduce XQuery from both a \u201cprogramming language\u201d and a \u201cquery language\u201d perspective and consider how these features impact the implementation and the evolution of XQuery. We conclude with a discussion of features currently missing from XQuery, but that we expect users will soon demand.", "num_citations": "28\n", "authors": ["1886"]}
{"title": "Commutativity analysis for XML updates\n", "abstract": " An effective approach to support XML updates is to use XQuery extended with update operations. This approach results in very expressive languages which are convenient for users but are difficult to optimize or reason about. A crucial question underlying many static analysis problems for such languages, from optimization to view maintenance, is whether two expressions commute. Unfortunately, commutativity is undecidable for most existing XML update languages. In this article, we propose a conservative analysis for an expressive XML update language that can be used to determine commutativity. The approach relies on a form of path analysis that computes upper bounds for the nodes that are accessed or modified in a given expression. Our main result is a theorem that can be used to identify commuting expressions. We illustrate how the technique applies to concrete examples of query optimization in the\u00a0\u2026", "num_citations": "24\n", "authors": ["1886"]}
{"title": "Commutativity analysis in XML update languages\n", "abstract": " A common approach to XML updates is to extend XQuery with update operations. This approach results in very expressive languages which are convenient for users but are difficult to reason about. Deciding whether two expressions can commute has numerous applications from view maintenance to rewriting-based optimizations. Unfortunately, commutativity is undecidable in most recent XML update languages. In this paper, we propose a conservative analysis for an expressive XML update language that can be used to determine whether two expressions commute. The approach relies on a form of path analysis that computes upper bounds for the nodes that are accessed or modified in a given update expression. Our main result is a commutativity theorem that can be used to identify commuting expressions.", "num_citations": "22\n", "authors": ["1886"]}
{"title": "Chuql: processing xml with xquery using hadoop\n", "abstract": " Hadoop provides an economical tool for processing large amounts of data; its success has been fueled in part by features such as fault-tolerance and a simple processing model. The amount of XML used in scientific, government, and enterprise data has grown substantially. and there are several high-level languages developed for Hadoop that can process semi-structured data like XML. ChuQL is a recently proposed extension to XQuery for processing XML natively using Hadoop.", "num_citations": "20\n", "authors": ["1886"]}
{"title": "Generating chat bots from web API specifications\n", "abstract": " Companies want to offer chat bots to their customers and employees which can answer questions, enable self-service, and showcase their products and services. Implementing and maintaining chat bots by hand costs time and money. Companies typically have web APIs for their services, which are often documented with an API specification. This paper presents a compiler that takes a web API specification written in Swagger and automatically generates a chat bot that helps the user make API calls. The generated bot is self-documenting, using descriptions from the API specification to answer help requests. Unfortunately, Swagger specifications are not always good enough to generate high-quality chat bots. This paper addresses this problem via a novel in-dialogue curation approach: the power user can improve the generated chat bot by interacting with it. The result is then saved back as an API specification\u00a0\u2026", "num_citations": "19\n", "authors": ["1886"]}
{"title": "The Simplest XML Storage Manager Ever.\n", "abstract": " After almost five years of incubation within the W3C, XQuery 1.0 is close to completion. Even before its official release, development of numerous XQuery implementations are underway. However, those implementations have focused only on either completeness or performance. In this paper, we report on our experience building Jungle, a secondary storage manager for Galax. We designed Jungle to be the \u201csimplest XML storage manager ever\u201d that supports the complete XQuery 1.0 language, and we show it can scale to documents up to several hundred megabytes. Interestingly, the process of developing Jungle lead us to revisit several core aspects of currently proposed XML indices. In particular, we propose alternative indices that can improve the performances for the child axis and for serialization. Jungle is fully operational and now being deployed in production applications.", "num_citations": "19\n", "authors": ["1886"]}
{"title": "A data model and algebra for XML query\n", "abstract": " CiteSeerX \u2014 A Data Model and Algebra for XML Query Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA A Data Model and Algebra for XML Query (1999) Cached Download as a PDF Download Links [www-db.research.bell-labs.com] [homepages.inf.ed.ac.uk] Save to List Add to Collection Correct Errors Monitor Changes by Mary Fernandez , Jerome Simeon , Dan Suciu , Philip Wadler Citations: 4 - 0 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases xml query data model Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us Developed at and hosted by The College of Information Sciences and \u2026", "num_citations": "19\n", "authors": ["1886"]}
{"title": "Bridging the XML-relational divide with LegoDB: a demonstration\n", "abstract": " We present LegoDB, a cost-based XML storage mapping engine that automatically explores a space of possible XML-to-relational mappings and selects an efficient mapping for a given application.", "num_citations": "18\n", "authors": ["1886"]}
{"title": "XML query optimization in the presence of side effects\n", "abstract": " The emergence of database languages with side effects, notably for XML, raises significant challenges for database compilers and optimizers. In this paper, we extend an algebra for the W3C XML query language with operations that allow data to be immediately updated. We study the impact of that extension on logical optimization, join detection, and pipelining. The main result of this work is to show that, with proper care, a number of important optimizations based on nested relational algebras remain applicable in the presence of side effects. Our approach relies on an analysis of the conditions that must be checked in order for algebraic rewritings to hold. An implementation and experimental results demonstrate the effectiveness of the approach.", "num_citations": "17\n", "authors": ["1886"]}
{"title": "A pattern calculus for rule languages: Expressiveness, compilation, and mechanization\n", "abstract": " This paper introduces a core calculus for pattern-matching in production rule languages: the Calculus for Aggregating Matching Patterns (CAMP). CAMP is expressive enough to capture modern rule languages such as JRules, including extensions for aggregation. We show how CAMP can be compiled into a nested-relational algebra (NRA), with only minimal extension. This paves the way for applying relational techniques to running rules over large stores. Furthermore, we show that NRA can also be compiled back to CAMP, using named nested-relational calculus (NNRC) as an intermediate step. We mechanize proofs of correctness, program size preservation, and type preservation of the translations using modern theorem-proving techniques. A corollary of the type preservation is that polymorphic type inference for both CAMP and NRA is NP-complete. CAMP and its correspondence to NRA provide the foundations for efficient implementations of rules languages using databases technologies.", "num_citations": "14\n", "authors": ["1886"]}
{"title": "Adaptive XML shredding: Architecture, implementation, and challenges\n", "abstract": " As XML data becomes central to business-critical applications, there is a growing need for efficient and reliable XML storage. Two main approaches have been proposed for storing XML data: native and colonial systems. Native systems (e.g., [19], [20]) are designed from the ground up specifically for XML and XML query languages. Colonial systems (e.g., [5],[7], [19]), on the other hand, attempt to reuse existing commercial database systems (DBMS) by mapping XML into the underlying model used by the DBMS. Colonial systems can thus leverage features, such as concurrency control, crash recovery, scalability, and highly optimized query processors available in the DMBS, making them an attractive alternative for managing XML data. However, several technical challenges need to be addressed in terms of architecture, algorithms, and implementation of these systems.In this paper, we described how\u00a0\u2026", "num_citations": "13\n", "authors": ["1886"]}
{"title": "Handling environments in a nested relational algebra with combinators and an implementation in a verified query compiler\n", "abstract": " Algebras based on combinators, ie, variable-free, have been proposed as a better representation for query compilation and optimization. A key benefit of combinators is that they avoid the need to handle variable shadowing or accidental capture during rewrites. This simplifies both the optimizer specification and its correctness analysis, but the environment from the source language has to be reified as records, which can lead to more complex query plans.", "num_citations": "12\n", "authors": ["1886"]}
{"title": "How to Recognise Different Kinds of Tree Patterns From Quite a Long Way Away.\n", "abstract": " Tree patterns are one of the main abstractions used to access XML data. Tree patterns are used to define XML indexes, and can be evaluated using efficient algorithms. Unfortunately deciding whether a particular query, or query fragment, is a tree pattern is undecidable for most XML Query languages. In this paper, we identify a subset of XQuery for which the problem is decidable. We develop a normal form for that XQuery subset and a rewrite system to produce that normal form, which we show to be sound and complete. That normal form is useful in two ways. First it allows to recognize the tree pattern a query corresponds to. Second it is suitable for compilation and tree pattern detection in an XML algebra.", "num_citations": "12\n", "authors": ["1886"]}
{"title": "Yoo-Hoo! Building a presence service with XQuery and WSDL\n", "abstract": " XML is at the heart of Web services: It is used as the format for the messages exchanged between services and applications (using SOAP [7]), to describe the structure of those messages (using XML Schema [6, 8]), and to describe Web services interfaces (using WSDL [12]). Current approaches [5] to development of Web services hide the XML layer behind Java or C# APIs, preventing the application direct access to the original data and interface. The goal of the XButler project is to support fast and reliable development of Web services by enabling direct access to the XML data and Web-service interfaces. The main technical contribution of XButler is a binding between WSDL [12], the Web Services Description Language, and XQuery [14], the W3C XML query language. In particular, we extend XQuery with an import service statement, which provides transparent access to Web services from within an XQuery\u00a0\u2026", "num_citations": "12\n", "authors": ["1886"]}
{"title": "Generating chat bots from web API specifications\n", "abstract": " Automatic generation of a chat bot from an API specification to carry out a dialog with a user and invoke an API call described in the API specification. Based on input API specification, a conversational bot specification representing a dialog flow is constructed. A natural language expression is received and transformed into instructions based on the conversational bot specification. Based on the instructions, a natural language prompt to the user and executable computer code for invoking the API call may be generated.", "num_citations": "11\n", "authors": ["1886"]}
{"title": "Reactive chatbot programming\n", "abstract": " Chatbots are reactive applications with a conversational interface. They are usually implemented as compositions of client-side components and cloud-hosted services, including artificial-intelligence technology. Unfortunately, programming such reactive multi-tier applications with traditional programming languages is cumbersome. This paper introduces wcs-ocaml, a new multi-tier chatbot generator library designed for use with the reactive language ReactiveML. The paper explains our library with small didactic examples throughout, and closes with a larger case-study of a chatbot for authoring event-processing rules.", "num_citations": "11\n", "authors": ["1886"]}
{"title": "XML path language (XPath) 2.0\n", "abstract": " XPath 2.0 is an expression language that allows the processing of values conforming to the data model defined in [XQuery 1.0 and XPath 2.0 Data Model (Second Edition)]. The data model provides a tree representation of XML documents as well as atomic values such as integers, strings, and booleans, and sequences that may contain both references to nodes in an XML document and atomic values. The result of an XPath expression may be a selection of nodes from the input documents, or an atomic value, or more generally, any sequence allowed by the data model. The name of the language derives from its most distinctive feature, the path expression, which provides a means of hierarchic addressing of the nodes in an XML tree. XPath 2.0 is a superset of [XPath 1.0], with the added capability to support a richer set of data types, and to take advantage of the type information that becomes available when documents are validated using XML Schema. A backwards compatibility mode is provided to ensure that nearly all XPath 1.0 expressions continue to deliver the same result with XPath 2.0; exceptions to this policy are noted in [I Backwards Compatibility with XPath 1.0].", "num_citations": "11\n", "authors": ["1886"]}
{"title": "I can parse you: Grammars for dialogs\n", "abstract": " Humans and computers increasingly converse via natural language. Those conversations are moving from today's simple question answering and command-and-control to more complex dialogs. Developers must specify those dialogs. This paper explores how to assist developers in this specification. We map out the staggering variety of applications for human-computer dialogs and distill it into a catalog of flow patterns. Based on that, we articulate the requirements for dialog programming models and offer our vision for satisfying these requirements using grammars. If our approach catches on, computers will soon parse you to better assist you in your daily life.", "num_citations": "10\n", "authors": ["1886"]}
{"title": "Entity matching for semistructured data in the Cloud\n", "abstract": " The rapid expansion of available information, on the Web or inside companies, is increasing. With Cloud infrastructure maturing (including tools for parallel data processing, text analytics, clustering, etc.), there is more interest in integrating data to produce higher-value content. New challenges, notably include entity matching over large volumes of heterogeneous data.", "num_citations": "10\n", "authors": ["1886"]}
{"title": "Experiences with JSON and XML Transformations\n", "abstract": " \u2022 A JSON-to-XML mapping is friendly when the generated XML has meaningful element and attribute names, rather than a name value pair design.\u2022 An XML-to-JSON mapping is friendly when the generated JSON has flat structure, making it easy for JavaScript programmers to consume it.\u2022 A JSON-to-XML mapping is round-trippable when the generated XML contains all the information that was in the original JSON, without any loss.\u2022 An XML-to-JSON mapping is round-trippable when the generated JSON contains all the information that was in the original XML, without any loss.", "num_citations": "10\n", "authors": ["1886"]}
{"title": "A better semantics for XQuery with side-effects\n", "abstract": " Formal semantics for XQuery with side-effects have been proposed in [13,16]. We propose a different semantics which is better suited for database compilation. We substantiate this claim by formalizing the compilation of XQuery extended with updates into a database algebra. We prove the correctness of the proposed compilation by mapping both the source language and the algebra to a common core language with list comprehensions and extensible tuples.", "num_citations": "10\n", "authors": ["1886"]}
{"title": "Influences on the Design of XQuery\n", "abstract": " The process of representing this input data in the Query data model causes each element node to receive a type annotation. If the input document is validated against a schema, the employee node might receive a type annotation of employeetype, and the salary and bonus nodes might receive a type annotation of xs: decimal.Suppose that a query binds a variable named $ fred to the employee element, and evaluates the expression $ fred/salary+ $ fred/bonus. Each of the operands of the+ operator evaluates to an element node whose type annotation is xs: decimal. The+ operator extracts the decimal values from the nodes and adds them together. The result of the expression is an atomic value of type xs: decimal.", "num_citations": "10\n", "authors": ["1886"]}
{"title": "Integration de sources de donnees heterogenes ou comment marier simplicite et efficacite\n", "abstract": " Ce travail est consacre a la conception et a la realisation d'outils pour faciliter la reutilisation de sources de donnees heterogenes. Jusqu'a present, deux approches se sont opposees. Les systemes d'integration structures utilisent les technologies des bases de donnees. Ils fonctionnent sur de grandes quantites d'informations mais n'offrent pas la flexibilite necessaire a un contexte reellement heterogene. Les systemes semistructures utilisent des modeles de representation sans schema qui favorisent l'integration simple et rapide de sources quelconques. L'absence de schema est cependant un handicap important pour la bonne comprehension des donnees et pour l'evaluation efficace des requetes. Nous introduisons un systeme de types pour un modele semistructure et yatl, un langage declaratif pour la specification de programmes d'integration. Outre la resolution des conflits structurels entre les sources, yatl permet un traitement complet des collections et des references. Les informations de type servent a guider l'ecriture des programmes et a verifier leur conformite par rapport aux structures d'entree et de sortie. L'utilisation de la genericite dans les programmes permet de conserver une grande flexibilite. Le systeme yat implante l'ensemble de ces outils. Il a permis la realisation rapide de plusieurs applications, grace a une architecture concue pour reduire au maximum le travail d'integration. Afin de decrire l'evaluation de programmes yatl, nous definissons un modele operationnel et une algebre pour donnees semistructurees. Les equivalences verifiees par les operateurs de l'algebre permettent non seulement de retrouver les techniques d\u00a0\u2026", "num_citations": "9\n", "authors": ["1886"]}
{"title": "Data integration based on data conversion and restructuring\n", "abstract": " Due to the development of the World Wide Web, the integration of heterogeneous data sources has become a major concern. Appropriate architectures and query languages have been proposed but the problem of data conversion remains largely unexplored. We present the YAT system for data conversion which provides tools for the specification and the implementation of data conversions among heterogeneous data sources. It relies on a middleware model, a declarative language to described conversion/integration programs, a graphical representation for the language, and several mechanisms allowing to easily reuse existing programs. The model is based on named trees with ordered and labeled nodes. Like semistructured data models, it is simple enough to facilitate the representation of any data. The main originality of the model is its ability to capture various levels of representation. A YAT model can be instantiated into another, more specific (eventually\" ground\"), model. This novel fe...", "num_citations": "9\n", "authors": ["1886"]}
{"title": "Xqueryp: An XML application development language\n", "abstract": " The three main parts of a typical business application are storage, logic, and presentation. XML is playing an increasing role in storage (using XML databases) and presentation (using AJAX and similar web technologies). Application logic, however, still relies to a large extent on traditional programming languages such as Java. Operating on XML data with a traditional programming language leads to a serious\" impedance mismatch\" because the type system of the programming language is not based on XML. This paper explores ways of eliminating this impedance mismatch by extending XQuery, an XML query language, to implement business logic. This approach can potentially support XML-based applications with a unified type system and programming environment.", "num_citations": "8\n", "authors": ["1886"]}
{"title": "Q* cert: A platform for implementing and verifying query compilers\n", "abstract": " We present Q* cert, a platform for the specification, verification, and implementation of query compilers written using the Coq proof assistant. The Q* cert platform is open source and includes some support for SQL and OQL, and for code generation to Spark and Cloudant. It internally relies on familiar database intermediate representations, notably the nested relational algebra and calculus and a novel extension of the nested relational algebra that eases the handling of environments. The platform also comes with simple but functional and extensible query optimizers.", "num_citations": "7\n", "authors": ["1886"]}
{"title": "Virtual lightweight snapshots for consistent analytics in NoSQL stores\n", "abstract": " Increasingly, applications that deal with big data need to run analytics concurrently with updates. But bridging the gap between big and fast data is challenging: most of these applications require analytics' results that are fresh and consistent, but without impacting system latency and throughput. We propose virtual lightweight snapshots (VLS), a mechanism that enables consistent analytics without blocking incoming updates in NoSQL stores. VLS requires neither native support for database versioning nor a transaction manager. Besides, it is storage-efficient, keeping additional versions of records only when needed to guarantee consistency, and sharing versions across multiple concurrent snapshots. We describe an implementation of VLS in MongoDB and present a detailed experimental evaluation which shows that it supports consistency for analytics with small impact on query evaluation time, update throughput\u00a0\u2026", "num_citations": "7\n", "authors": ["1886"]}
{"title": "Automata for avoiding unnecessary ordering operations in XPath implementations\n", "abstract": " XPath 2.0 path expressions can observe and preserve the document order and identity of XML values in a document. In particular, their semantics requires that the complete result and the result of each individual step in a path expression be in document order and duplicate-free. Implementations of this semantics often guarantee correctness by inserting explicit operations that sort and remove duplicates after each step. Such operations, however, can be redundant, because an intermediate result may already be sorted and/or duplicate-free. This work presents a sound and complete set of inference rules that decide whether each step in a path expression always yields a result in document order and with no duplicates. The inference rules are implemented by an efficient, automaton-based algorithm. Experimental results show that the algorithm detects and eliminates all redundant sorting and duplicate elimination operators, and is effective on most", "num_citations": "7\n", "authors": ["1886"]}
{"title": "Smart supply web: an application of web-based data and workflow mediation.\n", "abstract": " This paper describes our vision of a Supply Web as the next major advance in the e-commerce world in terms of how e-services are delivered. After highlighting shortcomings of existing supply chain solutions, we give an architecture to show how three important technologies, namely, workflow systems, data integration and on-line decision support, will have to come together to enable seamless deployment of e-service supply web solutions. We first discuss research efforts (namely, XRL, YAT and DecisionFlows) that support the three technologies separately, and then describe the challenges of integrating them effectively.", "num_citations": "7\n", "authors": ["1886"]}
{"title": "Event processing over a distributed JSON store: Design and performance\n", "abstract": " Web applications are increasingly built to target both desktop and mobile users. As a result, modern Web development infrastructure must be able to process large numbers of events (e.g., for location-based features) and support analytics over those events, with applications ranging from banking (e.g., fraud detection) to retail (e.g., just-in-time personalized promotions). We describe a system specifically designed for those applications, allowing high-throughput event processing along with analytics. Our main contribution is the design and implementation of an in-memory JSON store that can handle both events and analytics workloads. The store relies on the JSON model in order to serve data through a common Web API. Thanks to the flexibility of the JSON model, the store can integrate data from systems of record (e.g., customer profiles) with data transmitted between the server and a large number of\u00a0\u2026", "num_citations": "6\n", "authors": ["1886"]}
{"title": "An algebraic approach to XQuery view maintenance\n", "abstract": " View maintenance is a problem in data management that arises whenever a view is materialized over a source that changes over time. When the source is large, or when the source and view reside on different hosts, it is not practical to recompute the view and retransmit it over the network each time the source is updated. A better idea, commonly used in systems built with view maintenance in mind, is to translate source updates to ones that can be applied to the view directly. The cost of calculating, transmitting, and applying a translated update is typically dramatically less than the cost of recomputing and retransmitting the entire view. This paper addresses the problem of maintaining XQuery views over XML data. The core algorithm translates updates through queries as expressed in the tree algebra used internally in the Galax engine. This algorithm extends previous work on maintenance for relational views, although there are significant complications due to the data model, which is both ordered and nested. To overcome these obstacles, we propose a scheme for storing auxiliary data that guides the translation of updates in this more complicated setting. A novel aspect of our approach compared to previous work is that the amount and content of annotations can be controlled by users, making it possible to balance the tradeoffs between the size of the auxiliary data and the quality of translated updates. We have built a prototype implementation to test these ideas. Our system extends Galax, and handles a core set of operators and built-in functions capable of expressing many typical firstorder queries. Its design is fully compositional, so it can\u00a0\u2026", "num_citations": "6\n", "authors": ["1886"]}
{"title": "Building an extensible XQuery engine: Experiences with Galax\n", "abstract": " XQuery 1.0 and its sister language XPath 2.0 have set a fire underneath database vendors and researchers alike. More than thirty commercial and research XQuery implementations are listed on the XML Query working group home page (http://www.w3.org/XML/Query). Most of these implementations are targeted to particular storage systems or application domains.               Galax (http://www.galaxquery.org) is an open-source, general-purpose XQuery engine, designed for maximal extensibility. In this talk, we will discuss Galax\u2019s extensibility features and the design trade-offs that we continuously face between extensibility and performance.", "num_citations": "6\n", "authors": ["1886"]}
{"title": "Optimizing generalized path expressions using full text indexes\n", "abstract": " Etendre les langages de requ^ etes des SGBD objet avec des expressions de chemin g en eralis ees permet d'interroger les donn ees sans une connaissance exacte de leur structure. Cependant, l'evaluation e cace des requ^ etes contenant des expressions de chemin g en eralis ees reste un probl eme ouvert et les techniques d'indexation classiques ne conviennent pas a ce nouveau contexte. Nous proposons d'utiliser conjointement index classiques et index plein-texte pour obtenir une evaluation e cace des requ^ etes avec expressions de chemin g en eralis ees. Nous de nissons un cadre alg ebrique permettant de combiner etroitement l'utilisation des index plein-texte et les techniques standard d'optimisation. En n, nous donnons quelques r esultats sur les performances d'un premier prototype.", "num_citations": "6\n", "authors": ["1886"]}
{"title": "Prototyping a query compiler using coq (experience report)\n", "abstract": " Designing and prototyping new features is important in many industrial projects. Functional programming and formal verification tools can prove valuable for that purpose, but lead to challenges when integrating with existing product code or when planning technology transfer.   This article reports on our experience using the Coq proof assistant as a prototyping environment for building a query compiler intended for use in IBM's ODM Insights product. We discuss the pros and cons of using Coq for this purpose and describe our methodology for porting the compiler to Java, as required for product integration.", "num_citations": "5\n", "authors": ["1886"]}
{"title": "Xml path language (xpath) 2.0\n", "abstract": " XPath 3.0 is an expression language that allows the processing of values conforming to the data model defined in [XQuery and XPath Data Model (XDM) 3.0]. The data model provides a tree representation of XML documents as well as atomic values such as integers, strings, and booleans, and sequences that may contain both references to nodes in an XML document and atomic values. The result of an XPath expression may be a selection of nodes from the input documents, or an atomic value, or more generally, any sequence allowed by the data model. The name of the language derives from its most distinctive feature, the path expression, which provides a means of hierarchic addressing of the nodes in an XML tree. XPath 3.0 is a superset of [XML Path Language (XPath) Version 2.0]. A list of changes made since XPath 2.0 can be found in J Change Log. Here are some of the new features in XPath 3.0:", "num_citations": "5\n", "authors": ["1886"]}
{"title": "Conversational authoring of event processing applications\n", "abstract": " A computer natural language conversational agent authors an event-processing rule by carrying out a dialog in natural language with a user. A data model that customizes a dialog and building of the event-processing rule is received. A partial tree data structure is constructed based on a rule's grammar, and specialized based on tokens extracted from the data model. An utterance is received from a user and interpreted according to the grammar as specialized to the data model. Based on the interpreting of the utterance, the grammar, the data model, and context of interactions with the user, a natural language prompt is determined for the computer natural language conversational agent to output to the user. The partial tree data structure is filled based on the natural language prompt and the utterance from the user. The event-processing rule is generated based on the partial tree data structure filled during the dialog.", "num_citations": "4\n", "authors": ["1886"]}
{"title": "Web data processing on the cloud\n", "abstract": " Cloud computing is emerging as a highly scalable, fault-tolerant, and cost-effective way to process large amounts of information on the Web. Thanks in part to new data processing paradigms designed with the Cloud in mind (such as MapReduce [1], HDFS [2], Cassandra [3], etc), it is quickly gaining acceptance as a viable platform for organizations that need to store, process, and publish large amounts of data. MapReduce is attractive for processing data on the Cloud, to a large extent, because of its simplicity and flexibility. Implementations of MapReduce usually include a simple API used to describe which part of the processing is done in parallel (Map phase), and which part of the processing is done after grouping data on a single machine (Reduce phase). It does not rely on a pre-existing data model, making it possible to process any kind of information independently of the model. Cloud applications have\u00a0\u2026", "num_citations": "4\n", "authors": ["1886"]}
{"title": "XQuery\n", "abstract": " Chapter 7: XQuery Objectives Overview Introduction (1) Page 1 7-1 Chapter 7: XQuery \u2022 Scott Boag, Don Chamberlin, Mary F. Fernnndez, Daniela Florescu, Jonathan Robie, J\u00e9r\u00f4me Sim\u00e9on (Eds.): XQuery 1.0: An XML Query Language. W3C Recommendation 23 January 2007. [http://www.w3.org/TR/xquery/] \u2022 Wolfgang Lehner, Harald Sch\u00f6ning: XQuery. Grundlagen und fortgeschrittene Methoden. dpunkt.verlag, 2004, ISBN 3-89864-266-6, 290 Seiten. [http://www.xquery-buch.de/] \u2022 Howard Katz (Ed.), Don Chamberlin, Denise Draper, Mary Fern\u00e1ndez, Michael Kay, Jonathan Robie, Michael Rys, J\u00e9r\u00f4me Sim\u00e9on, Jim Tivy, Philip Wadler: XQuery from the Experts. A Guide to the W3C XML Query Language. Pearson Education Inc., 2004, ISBN 0-321-18060-7, 484 pages. \u2022 Jim Melton, Stephen Buxton: Querying XML: XQuery, XPath, and SQL/XML in Context. Morgan Kaufmann/Elsevier, 2006, ISBN 1-55860-711-0, 815 \u2026", "num_citations": "4\n", "authors": ["1886"]}
{"title": "Implementing XQuery 1.0: The Story of Galax\n", "abstract": " XQuery 1.0 and its sister language XPath 2.0 have set a fire underneath database vendors and researchers alike. More than thirty commercial and research XQuery implementations are listed on the XML Query working group home page. Galax [FS] is an open-source, general-purpose XQuery engine, designed to be complete, efficient, and extensible. During Galax's development, we have focused on each of these three requirements in turn, while never losing sight of the other two. Our success or failure in satisfying these requirements depends entirely on the design and implementation of Galax's architecture. We describe Galax's architecture in detail and identify several key principles that guide our decisions on Galax's design and implementation.", "num_citations": "3\n", "authors": ["1886"]}
{"title": "Galax implementation of XQuery\n", "abstract": " Galax implementation of XQuery Page 1 Lucent Technologies http://db.bell-labs.com/galax/ Galax implementation of XQuery Jer\u00f4me Simeon Lucent Technologies XQuery Implementation Panel, XML 2001, Orlando Page 2 Lucent Technologies http://db.bell-labs.com/galax/ What is Galax? \u25b6 A Reference Implementation of XQuery 1.0 \u25b6 XQuery 1.0, Data Model, F. and O., Formal Semantics \u25c0 \u25b6 As complete as possible \u25b6 As faithful as possible \u25b6 A Typed Implementation of XQuery 1.0 \u25b6 Static typing & Dynamic typing (Schema validation) \u25b6 An Experimental Implementation of XQuery 1.0 \u25b6 Follows the XQuery working drafts evolution \u25b6 Face 2 face demo Oct. 2000 (XML Algebra Nov. 2000 WD) \u25b6 XML Dev\u20192001 demo Apr. 2001 (XQuery Feb. 2001 WD) \u25b6 XML\u20192001 demo Dec. 2001 (XQuery June 2001 WD\u2019s) XQuery Implementation Panel, XML 2001, Orlando Page 3 Lucent Technologies http://db.bell-labs.com/\u2026", "num_citations": "3\n", "authors": ["1886"]}
{"title": "Generating chat bots from web API specifications\n", "abstract": " Automatic generation of a chat bot from an API specification to carry out a dialogue with a user and invoke an API call described in the API specification. Based on input API specification, a conversational bot specification representing a dialog flow is constructed. A natural language expression is received and transformed into instructions based on the conversational bot specification. Based on the instructions, a natural language prompt to the user and executable computer code for invoking the API call may be generated.", "num_citations": "2\n", "authors": ["1886"]}
{"title": "Prototyper un compilateur de requ\u00eates avec Coq\n", "abstract": " La sp\u00e9cification et le prototypage de nouvelles fonctionnalit\u00e9s sont importantes dans de nombreux projets industriels. Une approche fonctionnelle et l'usage d'outils de v\u00e9rification formelle peuvent s'av\u00e9rerparticul\u00ec erement utiles dans ce contexte, mais cr\u00e9ent des d\u00e9fis suppl\u00e9mentaires lors de l'int\u00e9gration dans un code produit existant ou pendant le transfert de technologie. Dans cet article, nous pr\u00e9sentons comment nous avons utilis\u00e9 Coq pour le prototypage d'un compilateur de requ\u00eates int\u00e9gr\u00e9 au produit ODM Insights d'IBM. Nous discutons des avantages et inconv\u00e9nients de Coq dans ce contexte et d\u00e9crivons la m\u00e9thodologie employ\u00e9e pour la r\u00e9-implantation en Java n\u00e9cessair\u00e8 a l'int\u00e9gration dans le produit.", "num_citations": "2\n", "authors": ["1886"]}
{"title": "A branding strategy for business types\n", "abstract": " In the course of building a compiler from business rules to a database run-time, we encounter the need for a type system that includes a class hierarchy and subtyping in the presence of complex record operations. Since our starting point is based on structural typing and targets a data-centric language, we develop an approach inspired by Wadler\u2019s work on XML types (Sim\u00e9on and Wadler 2003). Our proposed type system has strong similarities with branded or tagged objects, combining nominal and structural typing, and is designed to support a rich set of operations on records commonly found in database languages. We show soundness of the type system and illustrate its use on two of the intermediate languages involved in our compiler for business rules: a calculus for pattern matching with aggregation (CAMP) that captures rules semantics, and the nested relational algebra (NRA) used for optimization\u00a0\u2026", "num_citations": "2\n", "authors": ["1886"]}
{"title": "A restful workflow implementation on top of distributed XQuery\n", "abstract": " Workflow languages are the norm when it comes to representing and implementing business processes. With the emergence of Webenabled workflow languages, such as BPEL, there is an increasing need to support XML processing along with those languages. In this paper we extend the REST-based workflow language Bite with XQuery processing capabilities. We show how the resulting language can be implemented on top of a stand-alone XQuery processor by compiling its core constructs into DXQ, a distributed extension of XQuery. From an XQuery perspective, this approach demonstrates the expressiveness of the DXQ framework. From a workflow perspective, it opens interesting opportunities for lightweight implementations of Web workflows, cross-activity optimization, and experimentation with distributed workflows.", "num_citations": "2\n", "authors": ["1886"]}
{"title": "XQuery 1.0 and XPath 2.0 formal semantics\n", "abstract": " CiNii \u8ad6\u6587 - XQuery 1.0 and XPath 2.0 formal semantics CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831 \u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f \u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9 \u306e\u518d\u958b\u306b\u3064\u3044\u3066 XQuery 1.0 and XPath 2.0 formal semantics SIMEON J. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 SIMEON J. \u53ce\u9332\u520a\u884c\u7269 W3C recommendation W3C recommendation, 2007 W3C \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u66f8\u63db\u3048\u306b\u57fa\u3065\u304f\u6700\u9069\u5316\u306e\u305f\u3081\u306e XQuery \u306e\u76f8\u5bfe\u30b3\u30b9\u30c8\u30e2\u30c7\u30eb \u65e5\u9ad8 \u5b97\u4e00\u90ce , \u52a0\u85e4 \u5f18\u4e4b , \u5409\u5ddd \u6b63\u4fca \u96fb\u5b50\u60c5\u5831\u901a\u4fe1\u5b66\u4f1a\u8ad6\u6587\u8a8c. D, \u60c5\u5831\u30fb\u30b7\u30b9\u30c6\u30e0 = The IEICE transactions on information and systems (Japanese edition) 91(4), 873-888, 2008-04-01 \u53c2\u8003\u6587\u732e30\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10025468646 \u8cc7\u6599\u7a2e\u5225 \u305d\u306e\u4ed6 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 \u2026", "num_citations": "2\n", "authors": ["1886"]}
{"title": "Build your own XQuery processor\n", "abstract": " Build your own XQuery processor Page 1 Build your own XQuery processor Mary Fern\u00e1ndez, AT&T Labs Research J\u00e9r\u00f4me Sim\u00e9on, IBM TJ Watson Research Center 1 Page 2 Part I Introduction 2 Page 3 Why another talk on XQuery? \u25b6 What you should have learned so far: \u25b6 What is XQuery? \u25b6 General XQuery processing principles \u25b6 XML storage and indexing techniques \u25b6 XQuery optimization \u25b6 XQuery on top of a relational system \u25b6 What is missing? \u25b6 How to put all the pieces together... \u25b6 ...to build a real XML query engine 3 Page 4 Requirements & Technical Challenges \u25b6 Completeness \u25b6 Complex implicit semantics \u25b6 Functions & modules \u25b6 ... many more ... \u25b6 Performance \u25b6 Nested queries \u25b6 Memory management \u25b6 ... many more ... \u25b6 Extensibility \u25b6 Variety of XML & non-XML data representations \u25b6 Updates \u25b6 ... many more ... 4 Page 5 Completeness: Implicit Semantics \u25b6 User: W3C Working \u2026", "num_citations": "2\n", "authors": ["1886"]}
{"title": "Interpreting conversational authoring of information models\n", "abstract": " A method and a system for interpreting conversational authoring of information models. The system includes an understanding module, a managing module, and a generating module. The understanding module is configured to understand a natural language input to interpret an output. The managing module is configured to construct an information model based on the output of the understanding module. The generating module configured is to prompt, as a response to the natural language inputs, wherein the natural language inputs determine concepts and relationships of the concepts. The method includes receiving an interactive dialog between a conversational agent and an information model designer in natural language to produce an information model. The method can further include validating the information model using an information model management system. The method can include interpreting the\u00a0\u2026", "num_citations": "1\n", "authors": ["1886"]}
{"title": "Programmer des chatbots en OCaml avec Watson Conversation Service\n", "abstract": " Les chatbots sont des applications avec une interface conversationnelle. Ils sont compos\u00e9s d\u2019une partie application et d\u2019un moteur de conversation. Dans cet article nous introduisons la biblioth\u00e8que wcs-ocaml qui permet de programmer les deux parties d\u2019un chatbot en OCaml en se reposant sur le moteur de conversation Watson Conversation Service (WCS).", "num_citations": "1\n", "authors": ["1886"]}
{"title": "The next 700 NoSQL languages\n", "abstract": " We present a calculus for processing semistructured data that spans differences of application area among several novel query languages, broadly categorized as \u201cNoSQL\u201d. This calculus lets users define their own operators, capturing a wider range of data processing capabilities, whilst providing a typing precision so far typical only of primitive hard-coded operators. The type inference algorithm is based on semantic type checking, resulting in type information that is both precise, and flexible enough to handle structured and semistructured data. We illustrate the use of that calculus by encoding a large fragment of Jaql, including operations and iterators over JSON, embedded SQL expressions, and co-grouping.", "num_citations": "1\n", "authors": ["1886"]}
{"title": "XQuery 1.0 Web Services Facility (Proposal)\n", "abstract": " XQuery is a powerful language for processing XML. In the context of the Web, XML data is often provided through Web services. Several XQuery implementations already support access to such services (for both WSDL and REST). We propose here an extension to XQuery 1.0 that allows interoperability with WSDL services in a simple and transparent way.", "num_citations": "1\n", "authors": ["1886"]}
{"title": "06472 Abstracts Collection--XQuery Implementation Paradigms\n", "abstract": " From 19.11. 2006 to 22.11. 2006, the Dagstuhl Seminar 06472``XQuery Implementation Paradigms''was held in the International Conference and Research Center (IBFI), Schloss Dagstuhl. During the seminar, several participants presented their current research, and ongoing work and open problems were discussed. Abstracts of the presentations given during the seminar as well as abstracts of seminar results and ideas are put together in this paper. The first section describes the seminar topics and goals in general. Links to extended abstracts or full papers are provided, if available.", "num_citations": "1\n", "authors": ["1886"]}
{"title": "Automata for Avoiding Unneccessary Ordering Operations in XPath Evaluation Plans\n", "abstract": " XPath 2.0 path expressions can observe and preserve the document order and identity of XML values in a document. In particular, their semantics requires that the complete result and the result of each individual step in a path expression be in document order and duplicate-free. Implementations of this semantics often guarantee correctness by inserting explicit operations that sort and remove duplicates after each step. Such operations, however, can be redundant, because an intermediate result may already be sorted and/or duplicate-free. This work presents a sound and complete set of inference rules that decide whether each step in a path expression always yields a result in document order and with no duplicates. The inference rules are implemented by an efficient, automaton-based algorithm. Experimental results show that the algorithm detects and eliminates all redundant sorting and duplicate elimination operators, and is effective on most common path expressions.", "num_citations": "1\n", "authors": ["1886"]}
{"title": "The Essence of XML (preliminary version)\n", "abstract": " The World-Wide Web Consortium (W3C) promotes XML and related standards, including XML Schema, XQuery, and XPath. This paper describes a formalization XML Schema. A formal semantics based on these ideas is part of the official XQuery and XPath specification, one of the first uses of formal methods by a standards body. XML Schema features both named and structural types, with structure based on tree grammars. While structural types and matching have been studied in other work (notably XDuce, Relax NG, and previous formalizations of XML Schema), this is the first work to study the relation between named types and structural types, and the relation between matching and validation.", "num_citations": "1\n", "authors": ["1886"]}
{"title": "A unified constraint model for XML (full version)\n", "abstract": " Integrity constraints are an essential part of a modern schema definition language. They are useful for semantic specification, update consistency control, query optimization, information preservation, etc. In this paper, we propose UCM, a model of integrity constraints for XML that is both simple and expressive.Because it relies on a single notion of keys and foreign keys, the UCM model is easy to use and makes formal reasoning possible. Because it relies on a powerful type system, the UCM model is expressive, capturing in a single framework the constraints found in relational databases, object-oriented schemas and XML DTDs. We study the problem of consistency of UCM constraints, look at the interaction between constraints and subtyping, and discuss algorithms for implementing these constraints.", "num_citations": "1\n", "authors": ["1886"]}