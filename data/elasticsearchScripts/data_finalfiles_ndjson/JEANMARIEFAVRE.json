{"title": "Towards a basic theory to model model driven engineering\n", "abstract": " What is a model? What is a metamodel? What is a language? What is a transformation? How are these concepts related? It is striking to see that, though MDE is supposed to be about precise modelling, MDE core concepts are usually described in natural language or at best, using sketchy\" \u00e0-la\" UML diagrams. These diagrams are very often inconsistent and too vague to reason about. Most of the time, they are neither validated, not even used by their authors. When precise descriptions are provided, it is only to describe a specific technology. But since Model Driven Engineering is a about supporting multiple Technological Spaces (TS), the concepts of model, metamodel, and transformation should be declined, not only in the MDA TS, but also in the Grammarware TS, Documentware TS, Dataware TS, etc. To cope with these problems, we decided to start research on defining a megamodel of MDE. This paper shown how the set theory and language theory could help in understanding MDE concepts and their relationships. The megamodel could also be seen as a first version of a rudimentary theory for reasoning about MDE concepts.", "num_citations": "394\n", "authors": ["123"]}
{"title": "L'ing\u00e9nierie dirig\u00e9e par les mod\u00e8les: au-del\u00e0 du MDA\n", "abstract": " L'IDM, g\u00e9n\u00e9ralisation du MDA de l'OMG, est une nouvelle approche qui met les mod\u00e8les, et non pas les programmes, au centre de la d\u00e9marche en G\u00e9nie Logiciel. Les avantages annonc\u00e9s de l'IDM sont nombreux : ind\u00e9pendance vis \u00e0 vis des \u00e9volutions technologiques, meilleure ma\u00eetrise de la complexit\u00e9, meilleure r\u00e9utilisation etc. Mais qu'en est-il en r\u00e9alit\u00e9 ? Cet ouvrage s'adresse aux scientifiques, enseignants, \u00e9tudiants, et plus g\u00e9n\u00e9ralement \u00e0 toutes les personnes curieuses qui recherchent un point de vue objectif et critique sur l'IDM. Cet ouvrage propose un discours argument\u00e9 sur les points forts et les points faibles de l'IDM, en essayant d'identifier les fondements de cette approche plut\u00f4t que d'en rester aux techniques du moment. L'ouvrage s'attache \u00e0 montrer les emprunts et les synergies entre l'IDM et des disciplines plus anciennes. Il donne une vision vaste et critique des diverses facettes, des tendances\u00a0\u2026", "num_citations": "167\n", "authors": ["123"]}
{"title": "Foundations of model (driven)(reverse) engineering: Models--episode I: stories of the fidus papyrus and of the solarus\n", "abstract": " Model Driven Engineering (MDE) received a lot of attention in the last years, both from academia and industry. However, there is still a debate on which basic concepts form the foundation of MDE. The Model Driven Architecture (MDA) from the OMG does not provided clear answers to this question. This standard instead provides a complex set of interdependent technologies. This paper is the first of a series aiming at defining the foundations of MDE independently from a particular technology. A megamodel is introduced in this paper and incrementally refined in further papers from the series. This paper is devoted to a single concept, the concept of model, and to a single relation, the RepresentationOf relation. The lack of strong foundations for the MDA 4-layers meta-pyramid leads to a common mockery:``So, MDA is just about Egyptology?!''. This paper is the pilot of the series called``From Ancient Egypt to Model Driven Engineering''. The various episodes of this series show that Egyptology is actually a good model to study MDE.", "num_citations": "157\n", "authors": ["123"]}
{"title": "Foundations of meta-pyramids: Languages vs. metamodels--episode ii: Story of thotus the baboon1\n", "abstract": " Despite the recent interest for Model Driven Engineering approaches, the so-called four-layers metamodelling architecture is subject to a lot of debate. The relationship that exists between a model and a metamodel is often called instanceOf, but this terminology, which comes directly from the object oriented technology, is not appropriate for the modelling of similar meta-pyramids in other domains. The goal of this paper is to study which are the foundations of the meta-pyramids independently from a particular technology. This paper is actually the second episode of the series\" From Ancient Egypt to Model Driven Engineering\". In the pilot episode, the notion of megamodel was introduced to model essential Model Driven Engineering concepts. The notion of models was thoroughly discussed and only one association, namely RepresentationOf was introduced. In this paper the megamodel is extended with one fundamental relation in order to model the notion of languages and of metamodels. It is shown how Thotus the Baboon helped Nivizeb the priest in designing strong foundations for meta-pyramids. The secrets of some ancient pyramids are revealed.", "num_citations": "153\n", "authors": ["123"]}
{"title": "Towards a megamodel to model software evolution through transformations\n", "abstract": " Model Driven Engineering is a promizing approach that could lead to the emergence of a new paradigm for software evolution, namely Model Driven Software Evolution. Models, Metamodels and Transformations are the cornerstones of this approach. Combining these concepts leads to very complex structures which revealed to be very difficult to understand especially when different technological spaces are considered such as XMLWare (the technology based on XML), Grammarware and BNF, Modelware and UML, Dataware and SQL, etc. The concepts of model, metamodel and transformation are usually ill-defined in industrial standards like the MDA or XML. This paper provides a conceptual framework, called a megamodel, that aims at modelling large-scale software evolution processes. Such processes are modeled as graphs of systems linked with well-defined set of relations such as RepresentationOf (\u03bc\u00a0\u2026", "num_citations": "151\n", "authors": ["123"]}
{"title": "Languages evolve too! changing the software time scale\n", "abstract": " Humans will have to live with software for a long time. As demonstrated by the Y2K problem, computer professionals used a wrong time scale when thinking about software. Large software products live much longer than expected. It took a few decades to the research community to admit that software engineering was not only about software development, but above all, about software evolution. However, most academics still consider languages as immutable artefacts. Language/software co-evolution issues are still neglected. Migration issues are however commonplace in software industry. It is therefore time to recognize that languages evolve too. Languages are integral parts of software products. Languages are software too. This paper surveys a few models of evolution taking decades and centuries as time-scales. Then programming languages evolution over the last half-century is sketched by means of a\u00a0\u2026", "num_citations": "93\n", "authors": ["123"]}
{"title": "A model-driven engineering approach for the usability of plastic user interfaces\n", "abstract": " Plastic User Interfaces (UI) are able to adapt to their context of use while preserving usability. Research efforts have focused so far, on the functional aspect of UI adaptation, while neglecting the usability dimension. This paper investigates how the notion of mapping as promoted by Model Driven Engineering (MDE), can be exploited to control UI adaptation according to explicit usability criteria. In our approach, a run-time UI is a graph of models related by mappings. Each model (e.g., the task model, the Abstract UI, the Concrete UI, and the final UI) describes the UI from a specific perspective from high-level design decisions (conveyed by the task model) to low-level executable code (i.e. the final UI). A mapping between source and target models specifies the usability properties that are preserved when transforming source models into target models. This article presents a meta-model for the notion of\u00a0\u2026", "num_citations": "92\n", "authors": ["123"]}
{"title": "Understanding-in-the-large\n", "abstract": " Developing and maintaining large industrial software products implies programming-in-the-large activities. Related concepts are usually represented in terms of low level features such as file system hierarchies, preprocessor files, makefiles, shell scripts, sccs archives, etc. Understanding the information embedded in such artifacts is an important but difficult task, especially with neither conceptual framework, nor tool assistance. To emphasize the importance of this issue, this paper makes the distinction between understanding-in-the-large and understanding-in-the-small. Using a conceptual classification, understanding-in-the-large problems are described in a structured way. Difficulties in building reverse-engineering-in-the-large tools are then analyzed and illustrated taking preprocessor files as a case study. The Champollion approach to these problems is briefly presented.", "num_citations": "87\n", "authors": ["123"]}
{"title": "Model-driven adaptation for plastic user interfaces\n", "abstract": " User Interface (UI) plasticity denotes UI adaptation to the context of use (user, platform, physical and social environments) while preserving usability. In this article, we focus on the use of Model-Driven Engineering and demonstrate how the intrinsic flexibility of this approach can be exploited by designers for UI prototyping as well as by end-users in real settings. For doing so, the models developed at design-time, which convey high-level design decisions, are still available at run-time. As a result, an interactive system is not limited to a set of linked pieces of code, but is a graph of models that evolves, expresses and maintains multiple perspectives on the system from top-level tasks to the final UI. A simplified version of a Home Heating Control System is used to illustrate our approach and technical implementation.", "num_citations": "75\n", "authors": ["123"]}
{"title": "Meta-model and model co-evolution within the 3D software space\n", "abstract": " Software evolution-in-the-large is a challenging issue. While most research work concentrates on the evolution of \u201cprograms\u201d, large scale software evolution should be driven by much higher levels of abstraction. Software architecture is an example of such abstraction. The notion of co-evolution between architecture and implementation has been identified and studied recently. This paper claims that other abstraction dimensions should also be taken into account, leading to what we call the 3D software space. This conceptual framework is used to reason about evolution-in-the-large phenomena occurring in industry. The meta dimension, which constitutes the core of the MDA approach, is considered as fundamental. This paper makes the distinction between appliware and metaware and put the lights on meta-model and model co-evolution. Conversely to the MDA approach which makes the implicit assumption that meta-models are neat, stable and standardized, in this paper meta-models are considered as complex evolving software artefacts that are most often recovered from existing metaware tools rather than engineered from scratch. In fact, we identified the notion of meta-model and model co-evolution in the context of the evolution of a multimillion LOC component-based software developed by one of the largest software companies in Europe.", "num_citations": "75\n", "authors": ["123"]}
{"title": "Toward scm/pdm integration?\n", "abstract": " Software Configuration Management (SCM) is the discipline of controlling the evolution of a software product. Product Data Management (PDM) is the disciple of designing and controlling the evolution of a product design. For a long time, these two domains have been disconnected, but they probably share common concepts and techniques. Furthermore, any large product development includes a substantial (and growing) part of software development. There is a need to control the evolution of both the product and its associated software. Thus we are faced with the question: are the involved concepts and techniques close enough to envision a common tool capable of supporting both domains. This paper tries to answer this question, through an analysis of the PDM standard STEP and tools characteristic of both domains: Metaphase for PDM; Clear Case and Adele for SCM.             \u201cThose who know only\u00a0\u2026", "num_citations": "74\n", "authors": ["123"]}
{"title": "G/sup SEE: a Generic Software Exploration Environment\n", "abstract": " Large software products are very difficult to understand. One way to cope with this problem is to provide tools generating different software views. Unfortunately, there are so many different entity types and relationships in a large software product that building a specific tool for each view is not cost-effective. This paper presents G/sup SEE/ (Generic Software Exploration Environment). G/sup SEE/ consists of an object-oriented framework and a set of customizable tools. Thanks to this environment, only a few lines are needed to produce graphical views from virtually any data source. G/sup SEE/ has been successfully applied to improving the understanding of different software artifacts, including a multi-million lines-of-code (LOC) program.", "num_citations": "73\n", "authors": ["123"]}
{"title": "Cacophony: Metamodel-driven software architecture reconstruction\n", "abstract": " Far too often, architecture descriptions of existing software systems are out of sync with the implementation. If they are, they must be reconstructed, but this is a very challenging task. The first problem to be solved is to define what \"software architecture\" means in the company. The answer can greatly vary, especially among the many stakeholders. In order to solve this problem, This work presents CaCOphoNy, a generic metamodel-driven process for reconstructing software architecture. This work provides a methodological guide and shows how metamodels can be used (1) to define architectural viewpoints, (2) to link these viewpoints to existing metaware and (3) to drive architecture reconstruction processes. The concepts presented Were identified over the last decade in the context of Dassault Systemes, one of the largest software companies in Europe, with more than 1200 developers. CaCOphoNy is however a\u00a0\u2026", "num_citations": "67\n", "authors": ["123"]}
{"title": "Preprocessors from an abstract point of view\n", "abstract": " Paper reprinted from ICSM '96. It is well known that the extensive use of preprocessors can lead to serious maintenance problems. However these tools are still heavily used by developers and maintainers to implement software variants. Without adequate tools, understanding complex preprocessor files is a really tedious task. Problems are difficult to formulate and seem very specific. This paper shows that considering preprocessors from an abstract point of view can lead to surprising results. The use of abstractions considerably increases problem comprehension and solutions can be derived directly from existing techniques like slicing, program specialization or interprocedural data flow analysis. The preprocessor of the C language (CPP), is taken as a case study, and the functionalities of Champollion/APP, a tool for preprocessor maintenance, are briefly described.", "num_citations": "60\n", "authors": ["123"]}
{"title": "Towards model driven engineering of plastic user interfaces\n", "abstract": " Ubiquitous computing has introduced the need for interactive systems to run on multiple platforms in different physical environments. Providing a user interface specially crafted for each context of use (<user, platform, environment>) is costly, may result in inconsistent behaviors [5] and above all is limited to the contexts of use that have been envisioned at design time. Opportunistic interaction in a changing environment requires enabling approaches and techniques for gracefully adapting the interactive system to its context of use. In Human-Computer Interaction, this ability of an interactive system to withstand variations of context of use while preserving its quality in use is called plasticity [7]. This paper shows how Model Driven Engineering is suited for supporting plasticity both at design time and run time.", "num_citations": "52\n", "authors": ["123"]}
{"title": "Megamodelling and etymology\n", "abstract": " Is a model of a model, a metamodel? Is the relational model a metamodel? Is it a model? What is a component metamodel? Is it a model of a component model? The word MODEL is subject to a lot of debates in Model Driven Engineering. Add the notion of metamodel on top of it and you will just enter what some people call the Meta-muddle. Recently megamodels have been proposed to avoid the meta-muddle. This approach is very promising but it does not solve however the primary problem. That is, even a simple use of the word Model could lead to misunderstanding and confusion. This paper tackles this problem from its very source: the polysemic nature of the word MODEL. The evolution and semantic variations of the word MODEL are modelled from many different perspectives. This papers tells how the prefix MED in indo-european has lead, five millenniums after, to the acronym MDE, and this via the word MODEL. Based on an extensive study of encyclopedias, dictionaries, thesauri, and etymological sources, it is shown that the many senses of the word MODEL can be clustered into four groups, namely model-as-representation, model-as-example, model-as-type, and model-as-mold. All these groups are fundamental to understand the real nature of Model Driven Engineering. Megamodels and Etymology are indeed keys to avoid the Meta-muddle. on.", "num_citations": "48\n", "authors": ["123"]}
{"title": "Modeling the linguistic architecture of software products\n", "abstract": " Understanding modern software products is challenging along several dimensions. In the past, much attention has been focused on the logical and physical architecture of the products in terms of the relevant components, features, files, and tools. In contrast, in this paper, we focus on the linguistic architecture of software products in terms of the involved software languages and related technologies, and technological spaces with linguistic relationships such as membership, subset, or conformance. We develop a designated form of megamodeling with corresponding language and tool support. An important capability of the megamodeling approach is that entities and relationships of the megamodel are linked to illustrative software artifacts. This is particularly important during the understanding process for validation purposes. We demonstrate such megamodeling for a technology for Object/XML mapping\u00a0\u2026", "num_citations": "47\n", "authors": ["123"]}
{"title": "101companies: a community project on software technologies and software languages\n", "abstract": " 101companies is a community project in computer science (or software science) with the objective of developing a free, structured, wiki-accessible knowledge resource including an open-source repository for different stakeholders with interests in software technologies, software languages, and technological spaces; notably: teachers and learners in software engineering or software languages as well as software developers, software technologists, and ontologists. The present paper introduces the 101companies Project. In fact, the present paper is effectively a call for contributions to the project and a call for applications of the project in research and education.", "num_citations": "40\n", "authors": ["123"]}
{"title": "Megamodeling and metamodel-driven engineering for plastic user interfaces: mega-ui\n", "abstract": " Models are not new in Human Computer Interaction (HCI). Consider all the Model-Based Interface Design Environments (MB-IDE) that emerged in the 1990s for generating User Interfaces (UI) from more abstract descriptions. Unfortunately, the resulting poor usability killed the approach, burying the models in HCI for a long time until new requirements sprung, pushed by ubiquitous computing (e.g., the need for device independence). These requirements, bolstered by the large effort expended in Model-Driven Engineering (MDE) by the Software Engineering (SE) community, have brought the models back to life in HCI. This paper utilizes both the know-how in HCI and recent advances in MDE to address the challenge of engineering Plastic UIs, i.e., UIs capable of adapting to their context of use (User, Platform, Environment) while preserving usability. Although most of the work has concentrated on the\u00a0\u2026", "num_citations": "40\n", "authors": ["123"]}
{"title": "Ing\u00e9nierie de l'Interaction Homme-Machine Dirig\u00e9e par les mod\u00e8les\n", "abstract": " Alors qu\u2019en Ing\u00e9nierie de l\u2019Interaction Homme-Machine les mod\u00e8les \u00e9taient rest\u00e9s jusqu\u2019ici associ\u00e9s \u00e0 la d\u00e9cevante g\u00e9n\u00e9ration automatique des Interfaces Homme-Machine (IHM), ils reviennent aujourd\u2019hui, investis d\u2019espoir, comme solution \u00e0 la diversit\u00e9 des contextes d'usage en informatique ambiante. Par contexte d'usage, on entend un triplet< utilisateur, plate-forme, environnement> d\u00e9finissant les conditions humaines, mat\u00e9rielles, logicielles, lumineuses, sonores, sociales, etc. h\u00e9bergeant l\u2019interaction. R\u00e9cemment, un cadre de r\u00e9f\u00e9rence en Plasticit\u00e9 des IHM articulait la m\u00e9thode de conception des IHM autour d'un ensemble de mod\u00e8les et de transformations. Ce cadre de r\u00e9f\u00e9rence est ici formalis\u00e9 par la d\u00e9finition de m\u00e9tamod\u00e8les explicites. Cet article montre comment la notion de plate-forme, et plus g\u00e9n\u00e9ralement les concepts de l'Ing\u00e9nierie Dirig\u00e9e par les Mod\u00e8les, s' appliquent au domaine des IHM. La conception d'une IHM y est vue comme une s\u00e9rie de correspondances entre cinq m\u00e9tamod\u00e8les: les t\u00e2ches utilisateur, concepts du domaine, espaces de travail, interacteurs et finalement programme. Ce cadre de r\u00e9f\u00e9rence, ici exprim\u00e9 en termes de l'IDM, pourra, en perspective, servir de grille d'analyse \u00e0 l\u2019examen de l\u2019\u00e9tat de l\u2019art en mati\u00e8re de langages et outils d\u2019ing\u00e9nierie d'IHM.", "num_citations": "39\n", "authors": ["123"]}
{"title": "Reverse engineering a large component-based software product\n", "abstract": " Most research done to date on software maintenance has been focused mainly on the evolution of legacy systems based on obsolete technologies. However, the use of more recent, yet evolving technologies, like component-based techniques, also raises various issues about software comprehension and evolution. In particular, current industrial-strength component models such as COM are based on many technical aspects that make them difficult to understand and use. The evolution of large component-based software products is thus an emerging issue. This paper takes as a case study the component model developed and used by Dassault Syste/spl grave/mes, one of the largest software companies in Europe, for the development of its product lines, namely CATIA, DELMIA and ENOVIA. This paper shows how the use of a meta-model can help in understanding and reasoning about components, and how this\u00a0\u2026", "num_citations": "39\n", "authors": ["123"]}
{"title": "Visualization in the Context of Model Driven Engineering.\n", "abstract": " Understanding and maintenance of complex information spaces is often supported through visual interfaces. These interfaces must be highly flexible in order to adapt to both the user\u2019s role and their current task. Program comprehension tools are one class of tools that make heavy use of information visualization techniques, and Software Engineers use these tools to help understand and maintain software systems. This paper presents a model-driven approach to address the customization requirements of visual user interfaces, and does so in the domain of program comprehension.", "num_citations": "38\n", "authors": ["123"]}
{"title": "Foundations of model (driven)(reverse) engineering: Models\n", "abstract": " Model Driven Engineering (MDE) received a lot of attention in the last years, both from academia and industry. However, there is still a debate on which basic concepts form the foundation of MDE. The Model Driven Architecture (MDA) from the OMG does not provided clear answers to this question. This standard instead provides a complex set of interdependent technologies. This paper is the first of a series aiming at defining the foundations of MDE independently from a particular technology. A megamodel is introduced in this paper and incrementally refined in further papers from the series. This paper is devoted to a single concept, the concept of model, and to a single relation, the RepresentationOf relation. The lack of strong foundations for the MDA\u20194-layers meta-pyramid leads to a common mockery:\" So, MDA is just about Egyptology?!\". This paper is the pilot of the series called\" From Ancient Egypt to Model Driven Engineering\". The various episodes of this series show that Egyptology is actually a good model to study MDE.", "num_citations": "35\n", "authors": ["123"]}
{"title": "Towards mapping and model transformation for consistency of Plastic User Interfaces\n", "abstract": " Developing many variants of a same User Interface (UI) on different platforms is challenging. Plasticity is even more demanding. In Human Computer Interaction, plasticity denotes the capacity of a UI to withstand variations of context of use while preserving usability. A context of use is a triplet< user, platform, environment>. Plasticity raises many issues both at design time and run time. This paper shows how Model Driven Engineering (MDE) can be used for reasoning at different levels of abstraction when developing and executing a UI. These levels of abstraction define different perspectives on a same UI. This paper shows how MDE based mappings are powerful for ensuring consistency between these perspectives both at design time and run time.", "num_citations": "32\n", "authors": ["123"]}
{"title": "Empirical language analysis in software linguistics\n", "abstract": " Software linguistics is the science of software languages. In this short paper, we sketch the general discipline of software linguistics, but our focus is on one part of it: empirical analysis of software languages. Such analysis is concerned with understanding language usage on the grounds of a corpus. In this short paper, we sketch a survey on empirical language analysis, and we argue that the research method of content analysis is needed for a thorough survey.", "num_citations": "31\n", "authors": ["123"]}
{"title": "Natural modelling\n", "abstract": " While modelling research typically concentrates on its more technical and formal aspects, this paper provides a case for what we coin natural modelling. Modelling has always been and will always remain a humanintensive activity. To be adopted at large, modelling technologies should be perceived as natural as possible. In order to characterise what natural means, this paper briefly provides an anthropological and historical perspective on modelling. Constituting per se a first contribution, this retrospective allows to exhibit fundamental modelling concepts, spanning across ages. By looking backwards to understand what was natural (in) modelling in the past, this paper aims to define some elements for what could what computer-assisted natural modelling could be in the future. More specifically, it is argued that (1) the need for compromises between flexibility and formality is rather natural than extreme,(2) languages are emergent by their very nature and continuously evolve, and (3) natural interaction with modelling technology should be provided to all stakeholders, as it strongly promotes stakeholders participation. Although these aspects took different forms in historical developments of technology, we argue that the principles are still relevant today, and that these should be considered in the future research. The paper ends with some simple illustrations, which help provide the insight on how computer-assisted natural modelling could look like in a possible future.", "num_citations": "30\n", "authors": ["123"]}
{"title": "On squeezing M0, M1, M2, and M3 into a single object diagram\n", "abstract": " We propose an approach for the integrated description of a metamodel and its formal relationship to its models and the model instantiations. The central idea is to use so-called layered graphs permitting to describe type graphs and instance graphs. A type graph can describe a collection of types and their relationships whereas an instance graph can represent instances belonging to the types and respecting the relationships required by the type graph. Type graphs and instance graphs are used iteratively, ie, an instance graph on one layer can be regarded as a type graph of the next lower layer. Our approach models layered graphs with a UML class diagram, and operations and invariants are formally characterized with OCL and are validated with the USE tool. Metamodeling properties like strictness or well-typedness and features like potency can be formulated as OCL constraints and operations. We are providing easily understandable definitions for several metamodeling notions which are currently used in a loose way by modelers. Such properties and features can then be discussed on a rigorous, formal ground. This issue is also the main purpose of the paper, namely, to provide a basis for discussing metamodeling topics.", "num_citations": "25\n", "authors": ["123"]}
{"title": "Megamodeling and etymology-a story of words: From MED to MDE via MODEL in five milleniums\n", "abstract": " Is a model of a model, a metamodel? Is the relational model a metamodel? Is it a model? What is a component metamodel? Is it a model of a component model? The word MODEL is subject to a lot of debates in Model Driven Engineering. Add the notion of metamodel on top of it and you will just enter what some people call the Meta-muddle. Recently megamodels have been proposed to avoid the meta-muddle. This approach is very promising but it does not solve however the primary problem. That is, even a simple use of the word Model could lead to misunderstanding and confusion. This paper tackles this problem from its very source: the polysemic nature of the word MODEL. The evolution and semantic variations of the word MODEL are modelled from many different perspectives. This papers tells how the prefix MED in indo-european has lead, five millenniums after, to the acronym MDE, and this via the word MODEL. Based on an extensive study of encyclopedias, dictionaries, thesauri, and etymological sources, it is shown that the many senses of the word MODEL can be clustered into four groups, namely model-as-representation, model-as-example, model-as-type, and model-as-mold. All these groups are fundamental to understand the real nature of Model Driven Engineering. Megamodels and Etymology are indeed keys to avoid the Meta-muddle.", "num_citations": "25\n", "authors": ["123"]}
{"title": "Tool adoption issues in a very large software company\n", "abstract": " Tool adoption is a major issue in software engineering. In the last decades many ideas and tools have been developed by academics but only a few have had a direct impact on software industry. This paper describes the major issues in tool adoption and presents some technological approaches to cope with these issues. The focus is then on adoption-in-the-large. The results of a ten-years collaboration between the LSR laboratory and Dassault Syst\u00e8mes are presented. Dassault Syst\u00e8mes is one of the major software companies in Europe. Two scenarii in tool adoption are described. The first one describes the successful adoption of a configuration management tool, the second one describes adoption issues related with a reverse architecting tool.", "num_citations": "25\n", "authors": ["123"]}
{"title": "Towards efficient visualization support for single-block and multi-block datasets\n", "abstract": " Large simulation grids and multi-grid configurations impose many constraints on commercial visualization software. When available RAM is limited and graphics primitives are numbered in millions, alternative techniques for data access and processing are necessary. In this case study, we present our contributions to a visualization environment based on the AVS/Express software. We demonstrate how the efficient visualization of large datasets relies upon several forms of resource sharing, and alternate and efficient data access techniques.", "num_citations": "24\n", "authors": ["123"]}
{"title": "The CPP paradox\n", "abstract": " CPP is the C preprocessor. For most researchers this is a tool of the past. For most practitioners it is a tool from the past but one which is currently used. The heavy use of CPP can lead to unreadable programs; nevertheless large amounts of code are written using it. CPP makes maintenance difficult, but CPP is largely used for maintenance... CPP can convert good programs on which many program understanding tools apply, to incomprehensible programs with no tool assistance... The presence of CPP constructs in programs is a headache for maintainers and for tools builders, and CPP is still here... Most software engineering researchers consider CPP as an uninteresting tool of the past but, when implementing their research prototypes, they turn into practitioners and use it.This introduction is controversial. The aim of this paper is to present what lies behind these paradoxes and assess what should be done. Such paradox are representative of other distinctions: Industry vs Research, State-of-the-practice vs State-of-the-art, Maintenance vs Development, Reengineering vs Engineering.", "num_citations": "24\n", "authors": ["123"]}
{"title": "An object oriented design for the visualization of multi-variable data objects\n", "abstract": " This paper presents an object-oriented system design supporting the composition of scientific data visualization techniques based on the definition of hierarchies of typed data objects and tools. Traditional visualization systems focus on creating graphical objects which often cannot be re-used for further processing. Our approach provides objects of different topological dimension to offer a natural way of describing the results of visualization mappings. Serial composition of data extraction tools is allowed, while each intermediate visualization object shares a common description and behavior. Visualization objects can be re-used, facilitating the data exploration process by expanding the available analysis and correlation functions provided. This design offers an open-ended architecture for the development of new visualization techniques. It promotes data and software re-use, eliminates the need for writing special\u00a0\u2026", "num_citations": "24\n", "authors": ["123"]}
{"title": "Models at runtime for sustaining user interface plasticity\n", "abstract": " With ubiquitous computing, the Human-Computer Interaction (HCI) community has now to cope with various, variable and unforeseeable contexts of use. By context of use, we mean the triple< User, Platform, Environment>. This evolution is problematic as the know-how in HCI relies on an explicit description of the targeted context of use that is supposed to be fixed. From now on, UIs have to be plastic, ie capable of adapting to their context of use while preserving usability. This paper explores Model Driven Engineering (MDE) for sustaining plasticity. The challenge is all the most crucial that it would save a long and strong expertise in model-based design in HCI. As sketched in section 3, the key of our approach is a unification between design-time and run-time making the design-time models alive at run-time. UIs are envisioned as octopuses made of a net of models [1] and mappings, whose transformations plastify the UI. The paper is illustrated on a small running example that is described in section 2. Section 4 opens the paper on a research agenda.", "num_citations": "22\n", "authors": ["123"]}
{"title": "Linking documentation and source code in a software chrestomathy\n", "abstract": " The software chrestomathy of the 101companies community project demonstrates 'many' software languages and software technologies by implementing 'many' variants of a human resources management system, each implementation selects from 'many' optional features. All implementations are available through a source-code repository and they are documented on a wiki. Source code and documentation encode references to software languages, software technologies, software concepts, and product features, which, by themselves, are also documented and linked on the wiki. This setup implies the challenges of establishing links between source code and documentation as well as verifying that source code and documentation are in agreement. We describe an approach that addresses these challenges, it relies on a rule-based system which extracts relevant information from source-code artifacts (e.g\u00a0\u2026", "num_citations": "20\n", "authors": ["123"]}
{"title": "A new approach to software exploration: back-packing with G/sup SEE\n", "abstract": " Maintaining software is very difficult, not only because of the number of software artifacts, but also due to the large variety of artifacts. Software includes programs as well as makefiles, architectural information, change logs, etc. Different software exploration tools have been proposed in the last decade. Unfortunately, these tools are either specific (e.g. a class browser), or customizable (e.g. Rigi or PBS) but require significant preparation before exploration. This paper presents a new approach to software exploration: software back-packing. This approach allows a simultaneous exploration of software entities and meta-information. Our experience with this approach is briefly presented through G/sup SEE/, a generic software exploration environment.", "num_citations": "20\n", "authors": ["123"]}
{"title": "An intelligent system for task-specific visualization assistance\n", "abstract": " As the size and complexity of scientific data sets increase, scientists need help in analyzing relationships and structure within the data. Designing effective visualizations for such data sets is an extremely complex process. In this paper we describe a tool, which we call Visualization Assistant, that can provide assistance in deriving perceptually effective designs which will enhance the user's task performance. This tool considers the scientist's task and the interaction between perceptual dimensions, perceptual organization and texture segregation in generating design constraints. These constraints will limit the number of potential designs to those that will most effectively convey relationships within the data. Visualization Assistant then guides the user by ranking designs according to their perceptual effectiveness and assists the user in reading designs by offering 'attention directions'. Finally, we outline a plan for\u00a0\u2026", "num_citations": "19\n", "authors": ["123"]}
{"title": "Visualization of component-based software\n", "abstract": " New component-based techniques are emerging, leading to new ways to develop software. Industrial component technologies such as COM, JavaBeans, EJB, or CCM are powerful but their extensive use leads to component-based software products that are difficult to understand. This paper discusses several issues in visualizing component-based software products, namely the visualization of the component model itself, the visualization of software components and finally the visualization of software assemblies.", "num_citations": "18\n", "authors": ["123"]}
{"title": "Mapping Model: A First Step to Ensure Usability for sustaining User Interface Plasticity.\n", "abstract": " Ubiquitous computing has introduced the need for interactive systems to be able to adapt to their context of use (< User, Platform, Environment>) while preserving usability. This property has been called plasticity. Until now, efforts have been put on the functional aspect of adaptation, neglecting the usability part of the definition. This paper investigates MDE mappings for embedding both the description and control of usability. It first provides a general definition and metamodel of the notion of \u201cmapping\u201d that are not devoted to Human-Computer Interaction (HCI). A mapping describes a transformation that preserves properties. A transformation is performed by a set of transformation functions that can be described either by a function and/or an execution trace. The mappings properties provide the designer with a means for both selecting the most appropriate transformation functions and previewing the resulting design. When applied to HCI, mappings are an easy way for both describing and controlling ergonomic criteria either at design time or runtime. Mappings are rubber bands that link together different perspectives of a same User Interface (UI). They break when the UI goes outside its plasticity domain.", "num_citations": "17\n", "authors": ["123"]}
{"title": "Component models and technology\n", "abstract": " The many definitions of what a component is\u2014and what it is not\u2014often try to define a component in opposition either to object-oriented programming languages or to architecture description languages (ADLs). This chapter does not intend to provide yet another definition, but tries to clarify the situation showing the models of the different component technologies currently available in the industry: JavaBeans [1], COM+[2], CCM [3, 4], .NET [5, 6], and the Open Service Gateway Initiative (OSGI)[7]. A difficulty is that industrial component technologies focus on practical problems and are described in technical terms, thus providing many implementation details and making it difficult for users to understand concepts and principles. Available documentation is either oriented toward decision makers and provides mostly marketing arguments, or it is oriented toward programmers or tool implementers and includes pieces of code and complex API specifications.", "num_citations": "17\n", "authors": ["123"]}
{"title": "A framework for natural enterprise modelling\n", "abstract": " Within enterprise modelling, models are typically needed for a range of different purposes, ranging from vision and strategy development to computer-aided analyses. It is well known that model's content and form need to be adapted to its purpose. This typically concerns the tuning in terms of granularity, visualisation, precision and formality of the model, as well as in terms of the concepts/language in which the model is expressed. However, typical modelling tools lack such support. A number of empirical observations points at a lack in flexibility of tools and underlying modelling languages to aptly fit the needs of specific modelling situations. For instance, it is observed that fixed metamodels make it difficult to align the language with e.g. organisation-specific domains/concerns. This often leads to the different levels of discipline in which a fixed modelling language is obeyed to, or even the use of home-grown\u00a0\u2026", "num_citations": "15\n", "authors": ["123"]}
{"title": "Guest editors' introduction to the special section on software language engineering\n", "abstract": " HUMANKIND is defined by Language; Civilization is defined by Writing [5]. Since the Stone Age and then the shift from Prehistory to History, nothing has really changed in this respect. What remains constant is that no information can be shared without languages. But, as we are entering the so-called Information Age, we are definitively facing new challenges in Information Technologies (IT). This special section considers one of these challenges, namely, the disciplined and systematic Engineering of what is coined Software Languages (SL). Starting to address this challenge now may make a difference in the Software Century [8].Before entering into the technical aspects of Software Language Engineering and illustrating some of them via the technical papers selected in this special section, it is worth explaining the rationale that led to the combination of the three words \u201cSoftware,\u201d\u201cLanguage,\u201d and \u201cEngineering.\u201d In fact, we believe that Software Language Engineering (SLE) could constitute an emerging subfield of Software Engineering. We bet that its importance will significantly increase in the future as the need for new Software Languages will become even more important. The current increase in attention to Domain Specific Languages (DSL)(which is largely reflected in the papers in this special section) might constitute one trend toward this direction [2],[4],[6],[7]. We should move from the black art of language design to an engineering discipline. However, in order to put the papers included in this special section in a broader perspective, let us consider for a moment the past. Let us go back to the early ages of mankind and consider languages\u00a0\u2026", "num_citations": "13\n", "authors": ["123"]}
{"title": "A language perspective on the development of plastic multimodal user interfaces\n", "abstract": " Designing complex interactive systems requires the collaboration of actors with very different background. As a result, several languages and tools are used in a single project with no hope for interoperability. In this article, we examine whether a universal language is a realistic approach to UI specification by looking for answers into the domain of Linguistics while finding analogies in software engineering. Then, we explore one particular avenue from main-stream software engineering: that of Model Driven Engineering where the notion of transformation is key to the definition of bridges between languages and tools. Building upon these two analyses, we then show how model-driven engineering can be successfully exploited in the development and execution of plastic multimodal UIs illustrated with a variety of complementary tools.", "num_citations": "12\n", "authors": ["123"]}
{"title": "AVS and AVS/Express\n", "abstract": " CiNii \u8ad6\u6587 - AVS and AVS/Express CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e \u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7 \u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 [\u6a5f\u95a2\u8a8d\u8a3c] \u5229\u7528\u7d99\u7d9a\u624b\u7d9a\u304d\u306e\u3054\u6848\u5185 \u5b66\u8a8d\u8a8d\u8a3c\u306e\u4e0d\u5177\u5408\u306b\u3064\u3044\u3066 AVS and AVS/Express FAVRE J. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 FAVRE J. \u53ce\u9332\u520a\u884c\u7269 Visualization Handbook Visualization Handbook, 2004 Academic Press \u88ab\u5f15\u7528 \u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 GADGET/FV : \u6d41\u308c\u5834\u306e\u53ef\u8996\u5316\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u8a2d\u8a08\u652f\u63f4\u30b7\u30b9\u30c6\u30e0 \u7af9\u5cf6 \u7531\u91cc\u5b50 , \u85e4\u4ee3 \u4e00\u6210 \u753b\u50cf\u96fb\u5b50\u5b66\u4f1a\u8a8c = Imaging & Visual Computing The Journal of the Institute of Image Electronics Engineers of Japan 36(5), 796-806, 2007-09-25 \u53c2\u8003\u6587\u732e21\u4ef6 Tweet \u5404\u7a2e \u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10019823234 \u8cc7\u6599\u7a2e\u5225 \u56f3\u66f8\u306e\u4e00\u90e8 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 \u306b\u306b\u2026", "num_citations": "11\n", "authors": ["123"]}
{"title": "CPP denotational semantics\n", "abstract": " We show that CPP, the preprocessor of the C language, can be seen as a programming language in which directives are statements, parametrized macros are functions, files are procedures, directories are modules, and command lines are programs. The semantics of CPP can therefore be described using traditional techniques. We describe the semantics of CPP in a denotational style. By contrast with previous work, the full semantics is taken into account including nontrivial aspects such as recursive macros, stringification and concatenation.", "num_citations": "11\n", "authors": ["123"]}
{"title": "Comparing JavaBeans and OSGi towards an integration of two complementary component models\n", "abstract": " In today's software engineering practices, building applications from components is the ongoing trend. What can be noticed however is that there really is not a clear consensus about the definition of components, and instead in the literature we find many definitions of what components are. This renders a comparison between component models difficult. However, it is possible to compare different component models over a list of characteristics that several authors agree should be found in a component model. In this article, Sun's JavaBeans and the Open Services Gateway Initiative's framework (OSGi) are compared. These are two technologies that target very different types of applications. Their study reveals, however, that both technologies cover, at different levels, a set of important features that characterize components. It also reveals that these component models are in some ways complementary. The paper\u00a0\u2026", "num_citations": "11\n", "authors": ["123"]}
{"title": "Foundations of model (driven)(reverse) engineering\n", "abstract": " Model Driven Engineering (MDE) received a lot of attention in the last years, both from academia and industry. However, there is still a debate on which basic concepts form the foundation of MDE. The Model Driven Architecture (MDA) from the OMG does not provided clear answers to this question. This standard instead provides a complex set of interdependent technologies. This paper is the first of a series aiming at defining the foundations of MDE independently from a particular technology. A megamodel is introduced in this paper and incrementally refined in further papers from the series. This paper is devoted to a single concept, the concept of model, and to a single relation, the RepresentationOf relation. The lack of strong foundations for the MDA\u20194-layers meta-pyramid leads to a common mockery:\" So, MDA is just about Egyptology?!\". This paper is the pilot of the series called\" From Ancient Egypt to Model Driven Engineering\". The various episodes of this series show that Egyptology is actually a good model to study Model Driven Engineering.", "num_citations": "9\n", "authors": ["123"]}
{"title": "Describing hierarchical compositions of java beans with the beanome language\n", "abstract": " To better understand the conceptual issues concerning hierarchical composition, that is the possibility of an assembly of components to become itself a component, we are developing a simple component model that includes a language called Beanome where this kind of compositions can be described. In this paper we will describe the Beanome language, along with details about its execution and the results we have obtained with it.", "num_citations": "9\n", "authors": ["123"]}
{"title": "A flexible approach to visualize large software products\n", "abstract": " There are so many kinds of software structures in a very large software product, that it is almost impossible to build a specific visualization tool for each specific need. In such a context, flexibility is very important. In this paper we claim, that producing a specific view on a large software product, should be as simple as using a spreadsheet to produce a new view on an arbitrary set of data. Instead of building visualization tools from scratch, existing components should be reused whenever possible. In particular it should be possible to connect interactively source components (those providing information on software) and visualization components (those displaying graphical views). To support this approach, we have built GSEE, a Generic Software Exploration Environment making it possible to visualize virtually any kind of software structures at a very low cost.", "num_citations": "9\n", "authors": ["123"]}
{"title": "Une approche pour la maintenance et la r\u00e9-ing\u00e9nierie globale des logiciels\n", "abstract": " Alors que l'informatique est r\u00e9solument tourn\u00e9e vers l'avenir, cette th\u00e8se se concentre sur le pass\u00e9 ; non pas par nostalgie mais plut\u00f4t parce que le futur des logiciels \u00e2g\u00e9s est une question d'actualit\u00e9. Plus particuli\u00e8rement trois th\u00e8mes sont abord\u00e9s : la maintenance, la r\u00e9-ing\u00e9nierie et la programmation globale. L'objectif de cette \u00e9tude est d'explorer l'intersection entre la r\u00e9-ing\u00e9nierie et la programmation globale, domaine que nous avons baptis\u00e9 r\u00e9-ing\u00e9nierie globale. L'id\u00e9e principale est de r\u00e9utiliser des concepts et des techniques de programmation d\u00e9taill\u00e9e. En fait nous proposons de d\u00e9finir la programmation globale en distinguant 4 aspects du logiciel : l'architecture, la manufacture, la variation et l'\u00e9volution. Un mod\u00e8le abstrait bas\u00e9 sur des concepts ensemblistes est propos\u00e9 pour mod\u00e9liser les diff\u00e9rentes entit\u00e9s de programmation globale. La technologie relative \u00e0 ce domaine est ensuite d\u00e9crite en consid\u00e9rant aussi bien l'\u00e9tat de l'art que l'\u00e9tat de la pratique. La diff\u00e9rence entre ces deux aspects souligne l'int\u00e9r\u00eat de la r\u00e9-ing\u00e9nierie globale. A titre d'illustration, nous \u00e9tudions le cas des pr\u00e9processeurs en tant qu'outils de programmation globale. Ces outils de bas niveau provenant des ann\u00e9es 70 sont traditionnellement utilis\u00e9s pour d\u00e9crire des familles de programmes. Pour faciliter la compr\u00e9hension de tels artefacts nous proposons d'utiliser des techniques comme l'\u00e9valuation partielle, l'analyse inter-proc\u00e9durale de flot de donn\u00e9es ou encore le d\u00e9coupage. Ces techniques, d\u00e9finies de mani\u00e8re rigoureuse, s'appuient sur la s\u00e9mantique d\u00e9notationnelle du pr\u00e9processeur utilis\u00e9. Un prototype montrant leur utilit\u00e9 a \u00e9t\u00e9 r\u00e9alis\u00e9. Il prouve qu'une\u00a0\u2026", "num_citations": "9\n", "authors": ["123"]}
{"title": "IHM & IDM: Un tandem prometteur\n", "abstract": " Models and transformations are well known in HCI. More recently, the MDE community has emerged in Software Engineering. HCI and MDE work now together for the engineering of advanced user interfaces.", "num_citations": "7\n", "authors": ["123"]}
{"title": "Structuring large versioned software products\n", "abstract": " A discussion is presented of the solutions proposed by the Nomade project: a language-independent kernel and a specialized tool. The kernel manages coarse-grained objects (from files to abstractions such as modules or subsystems), while the tool manages fine-grained objects (basically the external objects of modules: procedures types, etc.). Concepts and properties of variants and revisions are defined. The kernel, enforcing these properties, allows tools to work safely in a monoversioned context. One of these tools, mainly dedicated to interface control, is then presented.< >", "num_citations": "7\n", "authors": ["123"]}
{"title": "A rigorous approach to support the maintenance of large portable software\n", "abstract": " Very often, portability of large software products is achieved via the empirical use of old tools like CPP, the preprocessor of the C language. Though powerful low level features like conditional compilation cause serious maintenance problems. There is a lack of adequate tools to support such activities. The paper presents our approach to this problem. We introduce APP, an abstract language semantically equivalent to CPP but based on traditional programming-in-the-small concepts. A rigorous description of the semantics of this language makes it possible to develop reliable reverse engineering tools.", "num_citations": "6\n", "authors": ["123"]}
{"title": "Evolution, r\u00e9tro-ing\u00e9nierie et l'IDM: du code aux mod\u00e8les\n", "abstract": " Evolution, r\u00e9tro-ing\u00e9nierie et l'IDM : du code aux mod\u00e8les - Universit\u00e9 Grenoble Alpes Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support Portail HAL de l'Universit\u00e9 Grenoble Alpes HAL archives-ouvertes.fr Accueil Rechercher D\u00e9poser Consulter Services hal-00483579, version 1 Direction d'ouvrage, Proceedings, Dossier Evolution, r\u00e9tro-ing\u00e9nierie et l'IDM : du code aux mod\u00e8les Jean-Marie Favre 1 Jean B\u00e9zivin 2, 3 R. Ian Bull 4 D\u00e9tails 1 LIG - Laboratoire d'Informatique de Grenoble 2 ATLAS - Complex data management in distributed systems UN - Universit\u00e9 de Nantes, Inria Rennes \u2013 Bretagne Atlantique 3 LINA - Laboratoire d'Informatique de Nantes Atlantique 4 Department of Computer Science [] : '\u2026", "num_citations": "5\n", "authors": ["123"]}
{"title": "Natural modeling: Retrospective and perspectives an anthropological point of view\n", "abstract": " Is extreme modeling so extreme? We advocate that natural modeling might be a better term. After all, the ultimate goal is to enable modelers to perform their job naturally. In the century of the\" disappearing computer\", it definitively makes sense to search for non invasive and flexible modeling technologies. This paper considers modeling from an anthropological point of view. A retrospective starting back to the Prehistoric Age leads to new perspectives for natural modeling in the Information Age. It is shown (1) that the need for compromises between flexibility and formality is\" natural\" rather than\" extreme\",(2) that the languages are emergent by nature, and (3) that natural interfaces should be provided to all stakeholders. We advocate that surface computing, tangible user-interfaces, collaborative modeling and emergent (meta) modeling are future research directions to be investigated in order to make\" extreme\"\u00a0\u2026", "num_citations": "4\n", "authors": ["123"]}
{"title": "Towards Social Information Systems\n", "abstract": " The development and usage of complex information systems leads to both technical and human challenges as large numbers of stakeholders with conflicting requirements are involved. Though global consistency must be preserved at the corporate level, software applications have to be adapted to particular needs. However, while individual users have the best knowledge about how to perform their job, they have little influence on the corporate information system. Our experience in industry shows that the \u201cKnowledge/Influence Mismatch\u201d leads to the \u201cInformation System Fragmentation\u201d problem: departments, teams or individuals unsatisfied by corporate information systems tend to develop \u201cparallel\u201d ad-hoc applications. To cope with this problem this paper proposes core concepts for Social Information Systems in which much more power will be given to user communities, allowing them to extend existing applications for their particular needs, but also to share these extensions with colleagues; and this in a social way. This approach, based on the notion of \u201cperspectives\u201d linked to people, opens the possibility of a social adaptation and democratic evolution of the information system.", "num_citations": "4\n", "authors": ["123"]}
{"title": "Transformation et v\u00e9rification de coh\u00e9rence entre mod\u00e8les du G\u00e9nie Logiciel et mod\u00e8les de l'Interface Homme-Machine.\n", "abstract": " Dans le cadre de la conception collaborative, il est n\u00e9cessaire que les sp\u00e9cialistes de divers domaines puissent g\u00e9rer, de mani\u00e8re automatis\u00e9e, les liens entre des mod\u00e8les diff\u00e9rents qui sont proches s\u00e9mantiquement. Bas\u00e9 sur un exemple concret de transformation d\u2019un diagramme de cas d\u2019utilisation (G\u00e9nie Logiciel) en un arbre de t\u00e2ches (IHM), des langages propos\u00e9s par l\u2019Ing\u00e9nierie dirig\u00e9e par les mod\u00e8les (IDM) sont \u00e9valu\u00e9s. Le but est alors de trouver un langage ad\u00e9quat \u00e0 notre transformation de mod\u00e8les. Une comparaison de certains outils d\u2019IDM est ensuite r\u00e9alis\u00e9e par rapport \u00e0 des crit\u00e8res \u00e9tablis suivant nos besoins en conception collaborative. Les outils correspondant le mieux \u00e0 nos attentes sont alors plus pr\u00e9cis\u00e9ment test\u00e9s \u00e0 partir de l\u2019exemple concret de la transformation.ABSTRACT. Within the framework of collaborative design, it is necessary that specialists of any domain can automatically manage links between different models that are semantically close. Based on a concrete transformation example from a use case diagram (Software Engineering) to a task tree (HCI), languages proposed by model driven engineering (MDE) are evaluated. Our goal is to find an adequate language for our model transformation. Among the multitude of MDE tools, a comparison is realised with respect to criteria according to our collaborative design needs. The tools that best correspond to our expectations are then tested more thoroughly on the concrete example of the transformation.", "num_citations": "4\n", "authors": ["123"]}
{"title": "Helping various stakeholders to understand a very large component-based software\n", "abstract": " Nowadays many software products are made up of millions of lines of code. Moreover, they are subject to a continuous evolution. These products are often bused on component technologies such as COM, EJB or Corba. Understanding and controlling the evolution of such complex software products is a difficult task, especially if undertaken at the code level. It is thus necessary to reason at a higher level of abstraction, i.e. the software architecture. This article reports on an industrial experience. The goal was to answer Dassault Systemes' needs by using a software architecture approach. This company maintains and develops a huge software called CATIA. In this article, we show how the architecture of CATIA can be described by the use of multiple, concurrent architectural views. This allows both to separately address the concerns of the various stakeholders of the architecture and to improve the communication\u00a0\u2026", "num_citations": "4\n", "authors": ["123"]}
{"title": "Issues in reengineering the architecture of component-based software\n", "abstract": " \" Architecture\", then\" component\", became buzzwords in the last decade. The precise meanings of these terms have been evolving over time, and vary among different research communities. Traditionally the reengineering community has focused on recovering the architecture of unstructured or modular software. Recently, significant amount of work has been dedicated to the integration of the reengineering and object-oriented worlds. In this paper we claim that the next step could be the integration of reengineering and component-based development. Our collaboration with Dassault Syst\u00e8mes, the world leader in the CAD/CAM market, shows that time has come to investigate this issue.", "num_citations": "4\n", "authors": ["123"]}
{"title": "Declarative Software Development: Distilled Tutorial\n", "abstract": " Software development could be said to be declarative, if declarative programming languages were used significantly in the development of a software system. Software development could also be said to be declarative, if lightweight or heavyweight formal methods or model-driven engineering and model transformation were used as the primary development methods. This tutorial discusses another view on'declarative software development'. That is, we promote the use of declarative methods for understanding software systems, software languages, software technologies, and software concepts. More specifically, we discuss a method package of a software ontology, automated software analysis, a modeling approach for software technologies, and Linked Data-based publication and exploration of software data.", "num_citations": "3\n", "authors": ["123"]}
{"title": "Concepts fondamentaux de l'IDM\n", "abstract": " Au-del\u00e0 du standard MDA de l'OMG, l'Ing\u00e9nierie Dirig\u00e9e par les Mod\u00e8les (IDM) est devenue en quelques ann\u00e9es un th\u00e8me de discussion chez les informaticiens, aussi bien dans le monde acad\u00e9mique que dans l'industrie. Le nombre de conf\u00e9rences et d'ateliers portant sur ce th\u00e8me est en pleine expansion comme en t\u00e9moigne par exemple la section\" \u00e9v\u00e9nements\" de http://planetmde. org. Les discussions portant sur l'IDM m\u00e8nent souvent \u00e0 des pol\u00e9miques entre d\u00e9tracteurs et proph\u00e8tes visionnaires. Ponctu\u00e9es d'acronymes (MDA, CWM, PIM, HUTN, MOF, CIM, EXPRESS, SDAI, MDR, EMOF, JMI, EMF, ECORE, QVT, SPEM, XMI, pour n'en citer que quelques uns), mais aussi de standards aussi vari\u00e9s que complexes \u00e0 ma\u00eetriser, le ticket d'entr\u00e9e dans la jungle de l'IDM est tr\u00e8s \u00e9lev\u00e9. Derri\u00e8re ce foisonnement de technologies plus o\u00f9 moins obscures, et cette terminologie qui semble \u00e9sot\u00e9rique, certains se demandent d'ailleurs si la communaut\u00e9 du MDA n'est pas en train de tenter de\" r\u00e9-inventer la roue\", sans m\u00eame peut \u00eatre s' en apercevoir.Ce qui avant s' appelait un\" fichier\", s' appelle d\u00e9sormais un\" mod\u00e8le\"; une grammaire s' appelle d\u00e9sormais\" m\u00e9tamod\u00e8le\", etc. En fait le jargon m\u00e9ta-tralala n'est pas fait pour arranger les choses. Il a m\u00eame plut\u00f4t tendance \u00e0 jouer le r\u00f4le de repoussoir. D\u00e9j\u00e0 que le monde de la mod\u00e9lisation et ses dessins\" \u00e0 la UML\" n'avait pas n\u00e9cessairement bonne presse dans le monde des\" vrais\" d\u00e9veloppeurs, rajouter des niveaux d'abstractions semble le meilleur moyen de se d\u00e9connecter d\u00e9finitivement de la r\u00e9alit\u00e9 informatique, c'est-\u00e0dire du code.", "num_citations": "3\n", "authors": ["123"]}
{"title": "First International Workshop on Meta-Models and Schemas for Reverse Engineering-ateM 2003.\n", "abstract": " The International Workshop on Meta-Models and Schemas for Reverse Engineering aims at utilizing meta-technology for the development of reverse engineering toolsets. The workshop objective is to determine and specify areas in reverse engineering which will benefit from meta-technology and to discover and discuss meta-technologies which will provide significant additional support for developing and using program understanding and analysis tools.", "num_citations": "3\n", "authors": ["123"]}
{"title": "Reengineering-In-The-Large vs Reengineering-In-The-Small\n", "abstract": " Software Reengineering is still in its infancy but is rapidly gaining importance. The need to provide an overall view of this discipline has recently led to the proposal of various taxonomies. Using the separation between Programming-In-The-Large and Programming-In-The-Small this paper suggests a new distinction: Reengineering-In-The-Large vs Reengineering-In-The-Small. It is emphasized that understanding and reengineering the multi-versioned aspect of software products is an important subject. We believe that it will be a future research topic.", "num_citations": "3\n", "authors": ["123"]}
{"title": "Model-driven reverse engineering and program comprehension: An example\n", "abstract": " En este art\u00edculo se presenta un ejemplo que describe c\u00f3mo la Ingenier\u00eda Dirigida por Modelos (IDM) puede ser aplicada al desarrollo de herramientas para la ingenier\u00eda reversa y comprensi\u00f3n de programas. Se seleccion\u00f3 como caso de estudio la herramienta CodeCrawler, espec\u00edficamente la funcionalidad denominada polymetric view, desarrollada mediante tecnolog\u00edas y t\u00e9cnicas de la IDM. Para ello, se emplearon dos metamodelos (entrada y salida) y transformaciones a nivel de los metamodelos que permiten generar la informaci\u00f3n de un polymetric view asociado a un proyecto de software, utilizando la informaci\u00f3n extra\u00edda del c\u00f3digo fuente. Las tecnolog\u00edas utilizadas para el desarrollo del ejemplo, las relacionadas con el Eclipse Modeling Project, espec\u00edficamente el lenguaje de transformaci\u00f3n ATL y el lenguaje KM3. El enfoque seguido para obtener la implementaci\u00f3n resultante puede ser utilizado para desarrollar una herramienta de ingenier\u00eda reversa y comprensi\u00f3n de software mediante t\u00e9cnicas de la IDM, incorporando el vocabulario del dominio en la implementaci\u00f3n.", "num_citations": "2\n", "authors": ["123"]}
{"title": "Introduction to gamma 2006 first international workshop on global integrated model management\n", "abstract": " Model Driven Engineering is currently attracting a lot of attention [2][8][9]. This does not mean that all problems are solved but, on the contrary, that we should anticipate problems if this approach is going to be adopted at large in software industry. The recent success of generative techniques and model-based approaches raise the question of dealing with the large amount of models, metamodels, transformations, and other related artifacts produced by different teams spread around the world.We need to recognize that Modeling-in-the-small is different from Modeling-in-the-Large. In other words, Model Driven Engineering, is not only about modeling a particular individual piece of software from the particular view point of a particular stakeholder, working in a particular place and using a particular modeling language with a particular code generator. The success of MDE and its ability to deal with industrial scale\u00a0\u2026", "num_citations": "2\n", "authors": ["123"]}
{"title": "Metamodel-Driven Architecture Recovery\n", "abstract": " Recovering the architecture of large evolving software is challenging. The first problem to be solved is to define what \u201csoftware architecture\u201d means in the company, and which architectural viewpoints are required by each stakeholder. In order to solve this problem, this paper provides a metamodel-driven implementation of the View Set Scenario. This paper shows how metamodels help in defining architectural viewpoints and how metamodels can be use to drive architecture recovery processes. The concepts presented in this paper were identified over the last decade in the context of a tight collaboration with Dassault Syst\u00e8mes, one of the largest software companies in Europe. The process pattern identified is however general and can be applied in other contexts. This process fits in the MDA and ADM approaches from the OMG. It also complies with the IEEE Standard 1471 for software architecture.", "num_citations": "2\n", "authors": ["123"]}
{"title": "Meta-Model Driven Reverse Engineering\n", "abstract": " Understanding and evolving very large software is challenging. Abstraction which is key to success, can be be considered along two independent dimensions: software architecture and software meta-models. This paper shows how to combine both dimensions to solve large-scale industrial issues. Software architecture considers the overall structure of software instead of its internal details.", "num_citations": "2\n", "authors": ["123"]}
{"title": "Continuous discovery of software architecture in a large evolving company\n", "abstract": " There is a wide agreement that software architecture is a useful notion. Unfortunately there is no agreement on what does this term means exactly. Despite of that, the recovery of the architecture is certainly necessary since (1) source code does not provide the good level of abstraction and (2) software architecture is almost never described explicitly in large software companies. In this paper we claim that:(A) evolving software companies using evolving technologies continuously need to discover what is architecture about, and this in order to control the development of their software products;(B) the notion of software architecture is actually a moving target. Supporting the discovery/recovery of software architecture therefore implies the use of very flexible tools. These claims are based on our experience on discovering/recovering the software architecture of CATIA, a multi million LOC software product line developed\u00a0\u2026", "num_citations": "2\n", "authors": ["123"]}
{"title": "Demumieux R.: ModelDriven Adaptation for Plastic User Interfaces\n", "abstract": " User Interface (UI) plasticity denotes UI adaptation to the context of use (user, platform, physical and social environments) while preserving usabil-ity. In this article, we focus on the use of Model-Driven Engineering and dem-onstrate how the intrinsic flexibility of this approach can be exploited by de-signers for UI prototyping as well as by end-users in real settings. For doing so, the models developed at design-time, which convey high-level design deci-sions, are still available at run-time. As a result, an interactive system is not li+ mited to a set of linked pieces of code, but is a graph of models that evolves, expresses and maintains multiple perspectives on the system from top-level tasks to the final UI. A simplified version of a Home Heating Control System is used to illustrate our approach and technical implementation.", "num_citations": "2\n", "authors": ["123"]}
{"title": "Software language engineering\n", "abstract": " Software languages play an important role in software development. Software languages are the artificial languages that are used to describe software systems at various abstraction levels. They are applied to describe requirements and designs for software, definitions of software architectures, and implementations of software systems. A huge variety of different technological spaces exist to describe languages: programming languages, software modeling languages, data modeling languages, domain-specific languages, ontology language, and others.", "num_citations": "1\n", "authors": ["123"]}
{"title": "4th international workshop on language engineering (ATEM 2007)\n", "abstract": " Following the great success of previous editions, ATEM2007 is the 4th edition of the ATEM workshop series. The first two editions were held with WCRE in 2003 and 2004, while the 3rd one was held with MoDELS 2006. ATEM has always been focused on engineering of language descriptions. In order to cover as many aspects of language descriptions important for greater success and adoption of model-driven engineering, ATEM has been evolving so as its scope:                                                                        The first edition was about metamodels and schemas.                                                            The second about was metamodels, schemas and grammars.                                                           The third edition was about metamodels, schemas, grammars and ontologies.", "num_citations": "1\n", "authors": ["123"]}
{"title": "3rd international workshop on metamodels, schemas, grammars and ontologies\n", "abstract": " In 2003 the ateM workshop series was established to discuss the use of Schemas and Metaschemas in reverse engineering (ateM is Meta reverse). ateM 2003, which was part of the 10th International Conference on Reverse Engineering held in Victoria, Canada, already dealt with model driven approaches to support program analysis and comprehension. Since models in reverse engineering mostly deal with documents written in certain programming or modeling languages, the extension of ateM towards grammars was a consistent step. Thus, ateM\u00a02004, held at the 11th International Conference on Reverse Engineering, Delft, The Netherlands, viewed Metamodels, Schemas and Grammars. Nowadays model driven approaches are common in software engineering and furthermore, ontologies complement modeling technologies used today. So, the third ateM-workshop, which was part of the 9th\u00a0\u2026", "num_citations": "1\n", "authors": ["123"]}
{"title": "First international workshop on global integrated model management\n", "abstract": " The aim of the First International Workshop on Global Integrated Model Management is to bring together researchers working on outstanding model driven engineering issues, with a view to discussing them, comparing their approaches, techniques or ideas, and letting these researchers take advantage of different perspectives on these issues. More particularly we are now see the second-generation modeling environments coming up, where the focus is no more on one unique general purpose modeling language (like UML 2.1 for example), but on a large family of more or less related domain specific languages (DSLs) corresponding to different corporations, different needs, different levels of abstraction, etc. First generation tools were mainly based on one unique metamodel (eg UML) while most recent tools are metamodel agnostic and able to deal with various kinds of metamodels or DSLs. The advantages of\u00a0\u2026", "num_citations": "1\n", "authors": ["123"]}
{"title": "Meta-model and model co-exploration with GSEE\n", "abstract": " Software visualization tools produce graphical views which are models of software artefacts. Meta-models describe the type of information presented in each model and act therefore as a key. Most visualization tools support only the production of fixed set of models kinds. They are usually restricted to the visualization of conventional software artefacts such as call graphs. While effective in the context of small development projects, this approach is not suited to very large scale software development. These projects typically involve a quite complex set of software concepts and quite complex meta-models. In this paper we briefly present the main features of GSEE, the Generic Software Exploration Environment. GSEE is independent from any meta-models and it supports the discovery and exploration of both models and meta-models, all this at the same time.", "num_citations": "1\n", "authors": ["123"]}
{"title": "Issues in Reengineering the Architecture of Evolving Component-Based Software\n", "abstract": " \" Architecture\", then\" component\", became buzzwords in the last decade. The precise meanings of these terms have been evolving over time, and vary among different research communities. Traditionally the reengineering community has focused on recovering the architecture of unstructured or modular software. Recently, significant amount of work has been dedicated to the integration of the reengineering and object-oriented worlds. In this paper we claim that the next step could be the integration of reengineering and component-based development. Our collaboration with Dassault Syst\u00e8mes, the world leader in the CAD/CAM market, shows that time has come to investigate this issue.", "num_citations": "1\n", "authors": ["123"]}
{"title": "Support for Reengineering-in-the-large\u201d\n", "abstract": " The ever increasing size of software products makes the distinction between programming-in-thelarge (PITL) and programming-in-the-small (PITS)[Der76]. Some activities and tools consider software products with a coarse grain; a configuration manager, for example, consider only files without any knowledge of their content. This fact creates a deep gap between PITL and PITS tools; even when the services they provide overlap [Est89]. For example, Module Interconnection Languages and modular programming languages provide redundant descriptions; versionning, primarily addressed at PITL level, is also provided through PITS concepts like genericity or conditional compilation.Software products, must be maintained for 10 to 20 years, even when developed with obsolete tools and techniques. Most often only the source code is still available. Software re-engineering can be seen both as a way to reduce maintenance costs and to use state of the art tools and techniques on old products [Arn93].", "num_citations": "1\n", "authors": ["123"]}