{"title": "Expectations, outcomes, and challenges of modern code review\n", "abstract": " Code review is a common software engineering practice employed both in open source and industrial contexts. Review today is less formal and more \u201clightweight\u201d than the code inspections performed and studied in the 70s and 80s. We empirically explore the motivations, challenges, and outcomes of tool-based code reviews. We observed, interviewed, and surveyed developers and managers and manually classified hundreds of review comments across diverse teams at Microsoft. Our study reveals that while finding defects remains the main motivation for review, reviews are less about defects than expected and instead provide additional benefits such as knowledge transfer, increased team awareness, and creation of alternative solutions to problems. Moreover, we find that code and change understanding is the key aspect of code reviewing and that developers employ a wide range of mechanisms to meet their\u00a0\u2026", "num_citations": "626\n", "authors": ["194"]}
{"title": "On the naturalness of buggy code\n", "abstract": " Real software, the kind working programmers produce by the kLOC to solve real-world problems, tends to be \u201cnatural\u201d, like speech or natural language; it tends to be highly repetitive and predictable. Researchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines, porting tools, coding standards checkers, and idiom miners. This suggests that code that appears improbable, or surprising, to a good statistical language model is \u201cunnatural\u201d in some sense, and thus possibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. 7,139), from 10 different Java projects, and focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic (i.e. unnatural), becoming less so as bugs are fixed. Ordering files for\u00a0\u2026", "num_citations": "204\n", "authors": ["194"]}
{"title": "Seahawk: Stack Overflow in the IDE\n", "abstract": " Services, such as Stack Overflow, offer a web platform to programmers for discussing technical issues, in form of Question and Answers (Q&A). Since Q&A services store the discussions, the generated \u201ccrowd knowledge\u201d can be accessed and consumed by a large audience for a long time. Nevertheless, Q&A services are detached from the development environments used by programmers: Developers have to tap into this crowd knowledge through web browsers and cannot smoothly integrate it into their workflow. This situation hinders part of the benefits of Q&A services. To better leverage the crowd knowledge of Q&A services, we created Seahawk, an Eclipse plugin that supports an integrated and largely automated approach to assist programmers using Stack Overflow. Seahawk formulates queries automatically from the active context in the IDE, presents a ranked and interactive list of results, lets users import\u00a0\u2026", "num_citations": "152\n", "authors": ["194"]}
{"title": "Improving low quality stack overflow post detection\n", "abstract": " Stack Overflow is a popular questions and answers (Q&A) website among software developers. It counts more than two millions of users who actively contribute by asking and answering thousands of questions daily. Identifying and reviewing low quality posts preserves the quality of site's contents and it is crucial to maintain a good user experience. In Stack Overflow the identification of poor quality posts is performed by selected users manually. The system also uses an automated identification system based on textual features. Low quality posts automatically enter a review queue maintained by experienced users. We present an approach to improve the automated system in use at Stack Overflow. It analyzes both the content of a post (e.g., simple textual features and complex readability metrics) and community-related aspects (e.g., popularity of a user in the community). Our approach reduces the size of the review\u00a0\u2026", "num_citations": "126\n", "authors": ["194"]}
{"title": "Modern Code Review: A Case Study at Google\n", "abstract": " Employing lightweight, tool-based code review of code changes (aka modern code review) has become the norm for a wide variety of open-source and industrial systems. In this paper, we make an exploratory investigation of modern code review at Google. Google introduced code review early on and evolved it over the years; our study sheds light on why Google introduced this practice and analyzes its current status, after the process has been refined through decades of code changes and millions of code reviews. By means of 12 interviews, a survey with 44 respondents, and the analysis of review logs for 9 million reviewed changes, we investigate motivations behind code review at Google, current practices, and developers' satisfaction and challenges.", "num_citations": "124\n", "authors": ["194"]}
{"title": "Harnessing Stack Overflow for the IDE\n", "abstract": " Developers often consult online tutorials and message boards to find solutions to their programming issues. Among the many online resources, Question & Answer websites are gaining popularity. This is no wonder if we consider a case like Stack Overflow, where more than 92% questions on expert topics are answered in a median time of 11 minutes. This new resource has scarcely been acknowledged by any Integrated Development Environment (IDE): Even though developers spend a large part of their working time in IDEs, and the usage of Q&A services has dramatically increased, developers can only use such resources using external applications. We introduce Seahawk, an Eclipse plugin to integrate Stack Overflow crowd knowledge in the IDE. It allows developers to seamlessly access Stack Overflow data, thus obtaining answers without switching the context. We present our preliminary work on Seahawk\u00a0\u2026", "num_citations": "113\n", "authors": ["194"]}
{"title": "Leveraging crowd knowledge for software comprehension and development\n", "abstract": " Question and Answer (Q&A) services, such as Stack Overflow, rely on a community of programmers who post questions, provide and rate answers, to create what is termed \"crowd knowledge\". As a consequence, these services archive voluminous and potentially useful information to help developers to solve programming-specific issues. Programmers tap into this crowd knowledge through web browsers. This requires them to step out of their integrated development environments (IDE), formulate a query, inspect the returned results and manually port the solution back to the IDE. We present an integrated and largely automated approach to assist programmers who want to leverage the crowd knowledge of Q&A services. We give a form to our approach by implementing Seahawk, an Eclipse plugin. Seahawk automatically formulates queries from the current context in the IDE, and presents a ranked and interactive\u00a0\u2026", "num_citations": "88\n", "authors": ["194"]}
{"title": "Will they like this?: Evaluating code contributions with language models\n", "abstract": " Popular open-source software projects receive and review contributions from a diverse array of developers, many of whom have little to no prior involvement with the project. A recent survey reported that reviewers consider conformance to the project's code style to be one of the top priorities when evaluating code contributions on Github. We propose to quantitatively evaluate the existence and effects of this phenomenon. To this aim we use language models, which were shown to accurately capture stylistic aspects of code. We find that rejected change sets do contain code significantly less similar to the project than accepted ones, furthermore, the less similar change sets are more likely to be subject to thorough review. Armed with these results we further investigate whether new contributors learn to conform to the project style and find that experience is positively correlated with conformance to the project's code style.", "num_citations": "72\n", "authors": ["194"]}
{"title": "Understanding and classifying the quality of technical forum questions\n", "abstract": " Technical questions and answers (Q&A) services have become a valuable resource for developers. A prominent example of technical Q&A website is StackOverflow (SO), which relies on a growing community of more than two millions of users who actively contribute by asking questions and providing answers. To maintain the value of this resource, poor quality questions - among the more than 6,000 asked daily - have to be filtered out. Currently, poor quality questions are manually identified and reviewed by selected users in SO, this costs considerable time and effort. Automating the process would save time and unload the review queue, improving the efficiency of SO as a resource for developers. We present an approach to automate the classification of questions according to their quality. We present an empirical study that investigates how to model and predict the quality of a question by considering as features\u00a0\u2026", "num_citations": "67\n", "authors": ["194"]}
{"title": "Classifying code comments in Java open-source software systems\n", "abstract": " Code comments are a key software component containing information about the underlying implementation. Several studies have shown that code comments enhance the readability of the code. Nevertheless, not all the comments have the same goal and target audience. In this paper, we investigate how six diverse Java OSS projects use code comments, with the aim of understanding their purpose. Through our analysis, we produce a taxonomy of source code comments, subsequently, we investigate how often each category occur by manually classifying more than 2,000 code comments from the aforementioned projects. In addition, we conduct an initial evaluation on how to automatically classify code comments at line level into our taxonomy using machine learning, initial results are promising and suggest that an accurate classification is within reach.", "num_citations": "57\n", "authors": ["194"]}
{"title": "A dataset for API usage\n", "abstract": " An Application Programming Interface (API) provides a specific set of functionalities to a developer. The main aim of an API is to encourage the reuse of already existing functionality. There has been some work done into API popularity trends, API evolution and API usage. For all the aforementioned research avenues there has been a need to mine the usage of an API in order to perform any kind of analysis. Each one of the approaches that has been employed in the past involved a certain degree of inaccuracy as there was no type check that takes place. We introduce an approach that takes type information into account while mining API method invocations and annotation usages. This approach accurately makes a connection between a method invocation and the class of the API to which the method belongs to. We try collecting as many usages of an API as possible, this is achieved by targeting projects hosted on\u00a0\u2026", "num_citations": "40\n", "authors": ["194"]}
{"title": "Quality questions need quality code: Classifying code fragments on stack overflow\n", "abstract": " Stack Overflow (SO) is a question and answers (Q&A) web platform on software development that is gaining in popularity. With increasing popularity often comes a very unwelcome side effect: A decrease in the average quality of a post. To keep Q&A websites like SO useful it is vital that this side effect is countered. Previous research proved to be reasonably successful in using properties of questions to help identify low quality questions to be later reviewed and improved. We present an approach to improve the classification of high and low quality questions based on a novel source of information: the analysis of the code fragments in SO questions. We show that we get similar performance to classification based on a wider set of metrics thus potentially reaching a better overall classification.", "num_citations": "36\n", "authors": ["194"]}
{"title": "fine-GRAPE: fine-grained APi usage extractor\u2013an approach and dataset to investigate API usage\n", "abstract": " An Application Programming Interface (API) provides a set of functionalities to a developer with the aim of enabling reuse. APIs have been investigated from different angles such as popularity usage and evolution to get a better understanding of their various characteristics. For such studies, software repositories are mined for API usage examples. However, many of the mining algorithms used for such purposes do not take type information into account. Thus making the results unreliable. In this paper, we aim to rectify this by introducing fine-GRAPE, an approach that produces fine-grained API usage information by taking advantage of type information while mining API method invocations and annotation. By means of fine-GRAPE, we investigate API usages from Java projects hosted on GitHub. We select five of the most popular APIs across GitHub Java projects and collect historical API usage information by\u00a0\u2026", "num_citations": "35\n", "authors": ["194"]}
{"title": "RTFM (read the factual mails)-augmenting program comprehension with REmail\n", "abstract": " The advent of globalization has led to the adoption of distributed software development as a common practice. One of its drawbacks-the absence of impromptu meetings - is tackled with other communication means, such as emails, instant messaging, or forums. Mailing lists have proven to be effective for enabling developers' collaboration and coordination: Being asynchronous, emails can evade time zone barriers, being public, mailing lists maintain developers' awareness, being recorded, email archives offer information on system evolution. Emails can provide information about a task, clarify implementation details, or reveal hidden connections among entities, always within the clear context of a discussion. As a result, we argue that emails might help program comprehension. We devised Remail, an Eclipse plug in to integrate email communication in the IDE. It allows developers to seamlessly handle code\u00a0\u2026", "num_citations": "32\n", "authors": ["194"]}
{"title": "On the effectiveness of manual and automatic unit test generation\n", "abstract": " The importance of testing has recently seen a significant growth, thanks to its benefits to software design (e.g. think of test-driven development), implementation and maintenance support. As a consequence of this, nowadays it is quite common to introduce a test suite into an existing system, which was not designed for it. The software engineer must then decide whether using tools which automatically generate unit tests (test suites necessary foundations) and how. This paper tries to deal with the issue of choosing the best approach. We will describe how different generation techniques (both manual and automatic) have been applied to a real case study. We will compare achieved results using several metrics in order to identify different approaches benefits and shortcomings. We will conclude showing the measure how the adoption of tools for automatic test creation can shift the trade-off between time and quality.", "num_citations": "32\n", "authors": ["194"]}
{"title": "Does single blind peer review hinder newcomers?\n", "abstract": " Several fields of research are characterized by the coexistence of two different peer review modes to select quality contributions for scientific venues, namely double blind (DBR) and single blind (SBR) peer review. In the first, the identities of both authors and reviewers are not known to each other, whereas in the latter the authors\u2019 identities are visible since the start of the review process. The need to adopt either one of these modes has been object of scholarly debate, which has mostly focused on issues of fairness. Past work reported that SBR is potentially associated with biases related to the gender, nationality, and language of the authors, as well as the prestige and type of their institutions. Nevertheless, evidence is lacking on whether revealing the identities of the authors favors reputed authors and hinder newcomers, a bias with potentially important consequences in terms of knowledge production\u00a0\u2026", "num_citations": "31\n", "authors": ["194"]}
{"title": "What makes a code change easier to review: An empirical investigation on code change reviewability\n", "abstract": " Peer code review is a practice widely adopted in software projects to improve the quality of code. In current code review practices, code changes are manually inspected by developers other than the author before these changes are integrated into a project or put into production. We conducted a study to obtain an empirical understanding of what makes a code change easier to review. To this end, we surveyed published academic literature and sources from gray literature (blogs and white papers), we interviewed ten professional developers, and we designed and deployed a reviewability evaluation tool that professional developers used to rate the reviewability of 98 changes. We find that reviewability is defined through several factors, such as the change description, size, and coherent commit history. We provide recommendations for practitioners and researchers. Public preprint [https://doi. org/10.5281/zenodo\u00a0\u2026", "num_citations": "30\n", "authors": ["194"]}
{"title": "PathMiner: a library for mining of path-based representations of code\n", "abstract": " One recent, significant advance in modeling source code for machine learning algorithms has been the introduction of path-based representation - an approach consisting in representing a snippet of code as a collection of paths from its syntax tree. Such representation efficiently captures the structure of code, which, in turn, carries its semantics and other information. Building the path-based representation involves parsing the code and extracting the paths from its syntax tree; these steps build up to a substantial technical job. With no common reusable toolkit existing for this task, the burden of mining diverts the focus of researchers from the essential work and hinders newcomers in the field of machine learning on code. In this paper, we present PathMiner - an open-source library for mining path-based representations of code. PathMiner is fast, flexible, well-tested, and easily extensible to support input code in any\u00a0\u2026", "num_citations": "27\n", "authors": ["194"]}
{"title": "Understanding Developers\u2019 Needs on Deprecation as a Language Feature\n", "abstract": " Deprecation is a language feature that allows API producers to mark a feature as obsolete. We aim to gain a deep understanding of the needs of API producers and consumers alike regarding deprecation. To that end, we investigate why API producers deprecate features, whether they remove deprecated features, how they expect consumers to react, and what prompts an API consumer to react to deprecation. To achieve this goal we conduct semi-structured interviews with 17 third-party Java API producers and survey 170 Java developers. We observe that the current deprecation mechanism in Java and the proposal to enhance it does not address all the needs of a developer. This leads us to propose and evaluate three further enhancements to the deprecation mechanism.", "num_citations": "27\n", "authors": ["194"]}
{"title": "One-day flies on stackoverflow-why the vast majority of stackoverflow users only posts once\n", "abstract": " Stack Overflow (SO) is a popular question and answers (Q&A) platform related to software development. An interesting characteristic of SO is that about half of its users makes only one contribution to the platform in total. In this work, we study this group of users, which we call one-day flies, and we investigate why they do not continue to contribute to the platform. By achieving this understanding we can find ways to enable users to become more active.", "num_citations": "27\n", "authors": ["194"]}
{"title": "Team design communication patterns in e-learning design and development\n", "abstract": " Prescriptive stage models have been found insufficient to describe the dynamic aspects of designing, especially in interdisciplinary e-learning design teams. There is a growing need for a systematic empirical analysis of team design processes that offer deeper and more detailed insights into instructional design (ID) than general models can offer. In this paper we present findings from two case studies of team design meetings involved in the development of fully online courses at two well-established European Distance Universities. We applied an activity-based approach to an extended verbal protocol dataset. This method proved to be adequate to describe the emerging team design process by taking into account both cognitive and social aspects of team activity in this specific context. Our findings provide evidence that design is more than problem solving, mainly because the design process is strongly\u00a0\u2026", "num_citations": "24\n", "authors": ["194"]}
{"title": "Does reviewer recommendation help developers?\n", "abstract": " Selecting reviewers for code changes is a critical step for an efficient code review process. Recent studies propose automated reviewer recommendation algorithms to support developers in this task. However, the evaluation of recommendation algorithms, when done apart from their target systems and users (i.e., code review tools and change authors), leaves out important aspects: perception of recommendations, influence of recommendations on human choices, and their effect on user experience. This study is the first to evaluate a reviewer recommender in vivo. We compare historical reviewers and recommendations for over 21,000 code reviews performed with a deployed recommender in a company environment and set out to measure the influence of recommendations on users' choices, along with other performance metrics. Having found no evidence of influence, we turn to the users of the recommender\u00a0\u2026", "num_citations": "23\n", "authors": ["194"]}
{"title": "Classifying code comments in Java software systems\n", "abstract": " Code comments are a key software component containing information about the underlying implementation. Several studies have shown that code comments enhance the readability of the code. Nevertheless, not all the comments have the same goal and target audience. In this paper, we investigate how 14 diverse Java open and closed source software projects use code comments, with the aim of understanding their purpose. Through our analysis, we produce a taxonomy of source code comments; subsequently, we investigate how often each category occur by manually classifying more than 40,000 lines of code comments from the aforementioned projects. In addition, we investigate how to automatically classify code comments at line level into our taxonomy using machine learning; initial results are promising and suggest that an accurate classification is within reach, even when training the machine learner on\u00a0\u2026", "num_citations": "20\n", "authors": ["194"]}
{"title": "A security perspective on code review: The case of Chromium\n", "abstract": " Modern Code Review (MCR) is an established software development process that aims to improve software quality. Although evidence showed that higher levels of review coverage relates to less post-release bugs, it remains unknown the effectiveness of MCR at specifically finding security issues. We present a work we conduct aiming to fill that gap by exploring the MCR process in the Chromium open source project. We manually analyzed large sets of registered (114 cases) and missed (71 cases) security issues by backtracking in the project's issue, review, and code histories. This enabled us to qualify MCR in Chromium from the security perspective from several angles: Are security issues being discussed frequently? What categories of security issues are often missed or found? What characteristics of code reviews appear relevant to the discovery rate? Within the cases we analyzed, MCR in Chromium\u00a0\u2026", "num_citations": "18\n", "authors": ["194"]}
{"title": "Social diversity and growth levels of open source software projects on GitHub\n", "abstract": " Background: Projects of all sizes and impact are leveraging the services of the social coding platform GitHub to collaborate. Since users' information and actions are recorded, GitHub has been mined for over 6 years now to investigate aspects of the collaborative open source software (OSS) development paradigm. Aim: In this research, we use this data to investigate the relation between project growth as a proxy for success, and social diversity. Method: We first categorize active OSS projects into a five-star rating using a benchmarking system we based on various project growth metrics; then we study the relation between this rating and the reported social diversities for the team members of those projects. Results: Our findings highlight a statistically significant relation; however, the effect is small. Conclusions: Our findings suggest the need for further research on this topic; moreover, the proposed benchmarking\u00a0\u2026", "num_citations": "18\n", "authors": ["194"]}
{"title": "Eta: Estimated time of answer predicting response time in stack overflow\n", "abstract": " Question and Answer (Q&A) sites help developers dealing with the increasing complexity of software systems and third-party components by providing a platform for exchanging knowledge about programming topics. A shortcoming of Q&A sites is that they provide no indication on when an answer is to be expected. Such an indication would help, for example, the developers who posed the questions in managing their time. We try to fill this gap by investigating whether and how answering time for a question posed on Stack Overflow, a prominent example of Q&A websites, can be predicted considering its tags. To this aim, we first determine the types of answers to be considered valid answers to the question, after which the answering time was predicted based on similarity of the set of tags. Our results show that the classification is correct in 30%-35% of the cases.", "num_citations": "17\n", "authors": ["194"]}
{"title": "Why are features deprecated? An investigation into the motivation behind deprecation\n", "abstract": " In this study, we investigate why API producers deprecate features. Previous work has shown us that knowing the rationale behind deprecation of an API aids a consumer in deciding to react, thus hinting at a diversity of deprecation reasons. We manually analyze the Javadoc of 374 deprecated methods pertaining four mainstream Java APIs to see whether the reason behind deprecation is mentioned. We find that understanding the rationale from just the Javadoc is insufficient; hence we add other data sources such as the source code, issue tracker data and commit history. We observe 12 reasons that trigger API producers to deprecate a feature. We evaluate an automated approach to classify these motivations.", "num_citations": "13\n", "authors": ["194"]}
{"title": "A Mixed Methods Approach to Mining Code Review Data: Examples and a study of multicommit reviews and pull requests\n", "abstract": " Software code review has been considered an important quality assurance mechanism for the last 35 years. The techniques for conducting modern code reviews have evolved along with the software industry, and have become progressively incremental and lightweight. We have studied code review in a number of contemporary settings, including Apache, Linux, KDE, Microsoft, Android, and GitHub. Code review is an inherently social activity, so we have used both quantitative and qualitative methods to understand the underlying parameters (or measures) of the process, as well as the rich interactions and motivations for doing code review. In this chapter, we describe how we have used a mixed methods approach to triangulate our findings on code review. We also describe how we use quantitative data to help us sample the most interesting cases from our data to be analyzed qualitatively. To illustrate code\u00a0\u2026", "num_citations": "11\n", "authors": ["194"]}
{"title": "Authorship attribution of source code: A language-agnostic approach and applicability in software engineering\n", "abstract": " Authorship attribution (ie, determining who is the author of a piece of source code) is an established research topic. State-of-the-art results for the authorship attribution problem look promising for the software engineering field, where they could be applied to detect plagiarized code and prevent legal issues. With this article, we first introduce a new language-agnostic approach to authorship attribution of source code. Then, we discuss limitations of existing synthetic datasets for authorship attribution, and propose a data collection approach that delivers datasets that better reflect aspects important for potential practical use in software engineering. Finally, we demonstrate that high accuracy of authorship attribution models on existing datasets drastically drops when they are evaluated on more realistic data. We outline next steps for the design and evaluation of authorship attribution models that could bring the research\u00a0\u2026", "num_citations": "10\n", "authors": ["194"]}
{"title": "Code review for newcomers: is it different?\n", "abstract": " Onboarding is a critical stage in the tenure of software developers with a project, because meaningful contribution requires familiarity with the codebase. Some software teams employ practices, such as mentoring, to help new developers get accustomed faster. Code review, ie, the manual inspection of code changes, is an opportunity for sharing knowledge and helping with onboarding.", "num_citations": "9\n", "authors": ["194"]}
{"title": "Manhattan-3D city visualizations in eclipse\n", "abstract": " Software visualization eases program comprehension through visual metaphors, which leverage the power of the human eye to identify colors, shapes, patterns, and differences. Even though many powerful software visualization tools exist, the majority of them consists of stand-alone systems that are not integrated with the development tools already in use. We present Manhattan, an Eclipse plugin that visualizes projects in the workspace as 3D cities. While working on a software system project, developers can see its representation, updated in real time according to the code changes performed. Moreover, Manhattan does not work in isolation: When other developers modify the same project in their Eclipse instance, Manhattan visualizes them to increase developers\u2019 awareness to facilitate team collaboration and coordination.", "num_citations": "9\n", "authors": ["194"]}
{"title": "Miler-a tool infrastructure to analyze mailing lists\n", "abstract": " The information that can be used to analyze software systems is not limited to the raw source code, but also to any other artifact produced during its evolution. In our recent work we have focused on how archives of e-mails that concern a system can be exploited to enhance program comprehension.", "num_citations": "9\n", "authors": ["194"]}
{"title": "Towards integrating e-mail communication in the IDE\n", "abstract": " Software developers spend a large part of their working time using an Integrated Development Environment (IDE). However, IDEs are usually disconnected from the means of communication programmers use to interact and discuss with other co-workers. Because of this, many context switches are required and the existing connection between source code artifacts and artifacts generated from recorded communications, such as e-mails, cannot be effectively put to good use.", "num_citations": "8\n", "authors": ["194"]}
{"title": "Primers or Reminders? The Effects of Existing Review Comments on Code Review\n", "abstract": " In contemporary code review, the comments put by reviewers on a specific code change are immediately visible to the other reviewers involved. Could this visibility prime new reviewers' attention (due to the human's proneness to availability bias), thus biasing the code review outcome? In this study, we investigate this topic by conducting a controlled experiment with 85 developers who perform a code review and a psychological experiment. With the psychological experiment, we find that \u224870% of participants are prone to availability bias. However, when it comes to the code review, our experiment results show that participants are primed only when the existing code review comment is about a type of bug that is not normally considered; when this comment is visible, participants are more likely to find another occurrence of this type of bug. Moreover, this priming effect does not influence reviewers' likelihood of\u00a0\u2026", "num_citations": "4\n", "authors": ["194"]}
{"title": "Investigating Type Declaration Mismatches in Python\n", "abstract": " Past research provided evidence that developers making code changes sometimes omit to update the related documentation, thus creating inconsistencies that may contribute to faults and crashes. In dynamically typed languages, such as Python, an inconsistency in the documentation may lead to a mismatch in type declarations only visible at runtime. With our study, we investigate how often the documentation is inconsistent in a sample of 239 methods from five Python open-source software projects. Our results highlight that more than 20% of the comments are either partially defined or entirely missing and that almost 1% of the methods in the analyzed projects contain type inconsistencies. Based on these results, we create a tool, PyID, to early detect type mismatches in Python documentation and we evaluate its performance with our oracle.", "num_citations": "4\n", "authors": ["194"]}
{"title": "On the road to hades-helpful automatic development email summarization\n", "abstract": " During the development of software systems, programmers often discuss issues such as structural decisions, defects, time management, etc. Especially in distributed development, where most of the discussions among developers take place via email, developers receive daily dozens, if not hundreds, of messages, either personally sent to them or broadcasted by mailing lists they are subscribed to. Dealing with these emails requires developers to spend long time reading voluminous amounts of text.A way to solve this problem is summarization: Producing a summary of a text means reducing it to a version based only on fundamental elements, by removing the parts unnecessary for the comprehension. Since researchers presented techniques for automatically summarizing natural language documents or source code, we are interested in investigating whether it would be possible to also summarize development emails, so that developers could consult small summaries instead of long threads. In this paper, on the basis of our first experiences in tackling development email summarization, we discuss the challenges that go hand in hand with such an endeavor.", "num_citations": "4\n", "authors": ["194"]}
{"title": "Appendix to expectations, outcomes, and challenges of modern code review\n", "abstract": " As part of our research on code review at Microsoft, we developed two surveys designed from the responses that we received during interviews. This appendix contains the questions that were asked in those surveys. The discussion or the results of the survey is included in our research paper.", "num_citations": "4\n", "authors": ["194"]}
{"title": "Exploring, exposing, and exploiting emails to include human factors in software engineering\n", "abstract": " Researchers mine software repositories to support software maintenance and evolution. The analysis of the structured data, mainly source code and changes, has several benefits and offers precise results. This data, however, leaves communication in the background, and does not permit a deep investigation of the human factor, which is crucial in software engineering.", "num_citations": "3\n", "authors": ["194"]}
{"title": "Building Implicit Vector Representations of Individual Coding Style\n", "abstract": " We propose a new approach to building vector representations of individual developers by capturing their individual contribution style, or coding style. Such representations can find use in the next generation of software development team collaboration tools, for example by enabling the tools to track knowledge transfer in teams. The key idea of our approach is to avoid using explicitly defined metrics of coding style and instead build the representations through training a model for authorship recognition and extracting the representations of individual developers from the trained model. By empirically evaluating the output of our approach, we find that implicitly built individual representations reflect some properties of team structure: developers who report learning from each other are represented closer to each other.", "num_citations": "2\n", "authors": ["194"]}
{"title": "Erase and rewind\u2014Learning by replaying examples\n", "abstract": " Much of human learning is built on observing, retaining, and replicating behavior witnessed in a model. On this basis, instructors often teach informatics by providing programming examples to be observed and analyzed by learners. By retaining and replicating the steps leading to the final artifacts, students learn. However, professors usually illustrate an example program only once and provide only its finalized version. This hinders the students' need of repeated observation and replication. With the Eclipse plug-in Replay, we strive to overcome the limitations of the current approach to learning by example. Replay records every code edit of a programming session, making it available as an interactive executable\" tape\". Professors can accurately design the steps of an example, and\" play\" them as live sessions in class, without the burden of concurrent coding and explaining; students have their hands in the complete\u00a0\u2026", "num_citations": "2\n", "authors": ["194"]}
{"title": "Mining motivated trends of usage of Haskell libraries\n", "abstract": " We propose an initial approach to minethe usage trends of libraries in Haskell, a popular functional programminglanguage. We integrate it with a novel, initial method to automaticallydetermine the reasons of clients for switching to different versions. Based onthese, we conduct a preliminary investigation of trends of usage in Haskelllibraries. Results suggest that trends are similar to those in the Javaecosystem and in line with Rogers' theory on the diffusion of innovation. Our results also provide indication on Haskell libraries being allby and large stable.", "num_citations": "1\n", "authors": ["194"]}
{"title": "Structure your unstructured data first!: The case of summarizing unstructured data with tag clouds\n", "abstract": " Unstructured software data, such as emails and discussions in technical forum, are a rich form of information about software systems. Nevertheless, mining this form of data is hard as it comprises different languages that cannot be processed with the same techniques.In this chapter, we show how we can summarize unstructured software data by first giving it the structure it needs.", "num_citations": "1\n", "authors": ["194"]}
{"title": "Mining unstructured software data\n", "abstract": " Our thesis is that the analysis of unstructured data supports software understanding and evolution analysis, and complements the data mined from structured sources. To this aim, we implemented the necessary toolset and investigated methods for exploring, exposing, and exploiting unstructured data. To validate our thesis, we focused on development email data. We found two main challenges in using it to support program comprehension and software development: The disconnection between emails and code artifacts and the noisy and mixed-language nature of email content. We tackle these challenges proposing novel approaches. First, we devise lightweight techniques for linking email data to code artifacts. We use these techniques for creating a tool to support program comprehension with email data, and to create a new set of email based metrics to improve existing defect prediction approaches. Subsequently, we devise techniques for giving a structure to the content of email and we use this structure to conduct novel software analyses to support program comprehension. In this dissertation we show that unstructured data, in the form of development emails, is a valuable addition to structured data and, if correctly mined, can be used successfully to support software engineering activities.", "num_citations": "1\n", "authors": ["194"]}
{"title": "REmail\u2013Blending Talk and Work in Eclipse\n", "abstract": " Integrated Development Environments (IDEs) are isolated from those communication means that programmers use daily to interact with each other\u2014as if talk and work were unrelated in software development. We present REmail, an Eclipse plugin, that aims at filling this gap. REmail integrates email communication in the IDE, allowing developers to quickly and easily retrieve emails related to the class at hand, perform customized searches, or watch trends in discussions about code. REmail also allows developers to produce information, eg, by rating the value of any message or by sending contextual emails.", "num_citations": "1\n", "authors": ["194"]}
{"title": "How to compare and exploit different techniques for unit-test generation\n", "abstract": " The size and complexity of software is continuously growing, and testing is one of the most important strategies for improving software reliability, quality, and design. Unit testing, in particular, forms the foundation of the testing process and it is effectively supported by automated testing frameworks. Manual unit-test creation is difficult, monotonous and time-consuming. In order to reduce the effort spent on this task, several tools have been developed. Many of them can almost automatically produce unit tests for regression avoidance or failure detection. This paper presents a practical comparison methodology to analyze different unit-testing creation tools and techniques. It validates the effectiveness of tools and spots their weaknesses and strengths. The validity of this methodology is confirmed through a real case experiment, in which both the manual implementation and different automatic test generation tools (based on random testing) are used. In addition, in order to integrate and exploit the benefits of each technique, which result from the comparison process, a testing procedure based on \u201cbest practices\u201d is developed.", "num_citations": "1\n", "authors": ["194"]}