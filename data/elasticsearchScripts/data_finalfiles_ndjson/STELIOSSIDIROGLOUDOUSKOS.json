{"title": "Managing performance vs. accuracy trade-offs with loop perforation\n", "abstract": " Many modern computations (such as video and audio encoders, Monte Carlo simulations, and machine learning algorithms) are designed to trade off accuracy in return for increased performance. To date, such computations typically use ad-hoc, domain-specific techniques developed specifically for the computation at hand. Loop perforation provides a general technique to trade accuracy for performance by transforming loops to execute a subset of their iterations. A criticality testing phase filters out critical loops (whose perforation produces unacceptable behavior) to identify tunable loops (whose perforation produces more efficient and still acceptably accurate computations). A perforation space exploration algorithm perforates combinations of tunable loops to find Pareto-optimal perforation policies. Our results indicate that, for a range of applications, this approach typically delivers performance increases of over a\u00a0\u2026", "num_citations": "575\n", "authors": ["340"]}
{"title": "Dynamic knobs for responsive power-aware computing\n", "abstract": " We present PowerDial, a system for dynamically adapting application behavior to execute successfully in the face of load and power fluctuations. PowerDial transforms static configuration parameters into dynamic knobs that the PowerDial control system can manipulate to dynamically trade off the accuracy of the computation in return for reductions in the computational resources that the application requires to produce its results. These reductions translate directly into performance improvements and power savings. Our experimental results show that PowerDial can enable our benchmark applications to execute responsively in the face of power caps that would otherwise significantly impair responsiveness. They also show that PowerDial can significantly reduce the number of machines required to service intermittent load spikes, enabling reductions in power and capital costs.", "num_citations": "415\n", "authors": ["340"]}
{"title": "Methods, systems, and media for detecting covert malware\n", "abstract": " Methods, systems, and media for detecting covert malware are provided. In accordance with some embodiments, a method for detecting covert malware in a computing environment is provided, the method comprising: generating simulated user activity outside of the computing environment; conveying the simulated user activity to an application inside the computing environment; and determining whether a decoy corresponding to the simulated user activity has been accessed by an unauthorized entity.", "num_citations": "375\n", "authors": ["340"]}
{"title": "Systems and methods for detecting and inhibiting attacks using honeypots\n", "abstract": " In accordance with some embodiments, systems and methods that protect an application from attacks are provided. In some embodiments, traffic from a communication network is received by an anomaly detection component. The anomaly detection component monitors the received traffic and routes the traffic either to the protected application or to a honeypot, where the honeypot shares all state information with the application. If the received traffic is routed to the honeypot, the honeypot monitors the traffic for an attack. If an attack occurs, the honeypot repairs the protected application (eg, discarding any state changes incurred from the attack, reverting to previously saved state information, etc.).", "num_citations": "348\n", "authors": ["340"]}
{"title": "Detecting targeted attacks using shadow honeypots\n", "abstract": " We present Shadow Honeypots, a novel hybrid architecture that combines the best features of honeypots and anomaly detection. At a high level, we use a variety of anomaly detectors to monitor all traffic to a protected network/service. Traffic that is considered anomalous is processed by a \u201cshadow honeypot\u201d to determine the accuracy of the anomaly prediction. The shadow is an instance of the protected software that shares all internal state with a regular (\u201cproduction\u201d) instance of the application, and is instrumented to detect potential attacks. Attacks against the shadow are caught, and any incurred state changes are discarded. Legitimate traffic that was misclassified will be validated by the shadow and will be handled correctly by the system transparently to the end user. The outcome of processing a request by the shadow is used to filter future attack instances and could be used to update the anomaly detector.Our architecture allows system designers to fine-tune systems for performance, since false positives will be filtered by the shadow. Contrary to regular honeypots, our architecture can be used both for server and client applications. We demonstrate the feasibility of our approach in a proof-of-concept implementation of the Shadow Honeypot architecture for the Apache web server and the Mozilla Firefox browser. We show that despite a considerable overhead in the instrumentation of the shadow honeypot (up to 20% for Apache), the overall impact on the system is diminished by the ability to minimize the rate of false-positives.", "num_citations": "299\n", "authors": ["340"]}
{"title": "Quality of service profiling\n", "abstract": " Many computations exhibit a trade off between execution time and quality of service. A video encoder, for example, can often encode frames more quickly if it is given the freedom to produce slightly lower quality video. A developer attempting to optimize such computations must navigate a complex trade-off space to find optimizations that appropriately balance quality of service and performance.", "num_citations": "266\n", "authors": ["340"]}
{"title": "Building a reactive immune system for software services\n", "abstract": " We propose a reactive approach for handling a wide variety of software failures, ranging from remotely exploitable vulnerabilities to more mundane bugs that cause abnormal program termination (eg, illegal memory dereference) or other recognizable bad behavior (eg, computational denial of service). Our emphasis is in creating \u201cself-healing\u201d software that can protect itself against a recurring fault until a more comprehensive fix is applied.Briefly, our system monitors an application during its execution using a variety of external software probes, trying to localize (in terms of code regions) observed faults. In future runs of the application, the \u201cfaulty\u201d region of code will be executed by an instruction-level emulator. The emulator will check for recurrences of previously seen faults before each instruction is executed. When a fault is detected, we recover program execution to a safe control flow. Using the emulator for small pieces of code, as directed by the observed failure, allows us to minimize the performance impact on the immunized application.", "num_citations": "245\n", "authors": ["340"]}
{"title": "Control jujutsu: On the weaknesses of fine-grained control flow integrity\n", "abstract": " Control flow integrity (CFI) has been proposed as an approach to defend against control-hijacking memory corruption attacks. CFI works by assigning tags to indirect branch targets statically and checking them at runtime. Coarse-grained enforcements of CFI that use a small number of tags to improve the performance overhead have been shown to be ineffective. As a result, a number of recent efforts have focused on fine-grained enforcement of CFI as it was originally proposed. In this work, we show that even a fine-grained form of CFI with unlimited number of tags and a shadow stack (to check calls and returns) is ineffective in protecting against malicious attacks. We show that many popular code bases such as Apache and Nginx use coding practices that create flexibility in their intended control flow graph (CFG) even when a strong static analyzer is used to construct the CFG. These flexibilities allow an attacker to\u00a0\u2026", "num_citations": "237\n", "authors": ["340"]}
{"title": "Assure: automatic software self-healing using rescue points\n", "abstract": " Software failures in server applications are a significant problem for preserving system availability. We present ASSURE, a system that introduces rescue points that recover software from unknown faults while maintaining both system integrity and availability, by mimicking system behavior under known error conditions. Rescue points are locations in existing application code for handling a given set of programmer-anticipated failures, which are automatically repurposed and tested for safely enabling fault recovery from a larger class of (unanticipated) faults. When a fault occurs at an arbitrary location in the program, ASSURE restores execution to an appropriate rescue point and induces the program to recover execution by virtualizing the program's existing error-handling facilities. Rescue points are identified using fuzzing, implemented using a fast coordinated checkpoint-restart mechanism that handles multi\u00a0\u2026", "num_citations": "220\n", "authors": ["340"]}
{"title": "Missing the point (er): On the effectiveness of code pointer integrity\n", "abstract": " Memory corruption attacks continue to be a major vector of attack for compromising modern systems. Numerous defenses have been proposed against memory corruption attacks, but they all have their limitations and weaknesses. Stronger defenses such as complete memory safety for legacy languages (C/C++) incur a large overhead, while weaker ones such as practical control flow integrity have been shown to be ineffective. A recent technique called code pointer integrity (CPI) promises to balance security and performance by focusing memory safety on code pointers thus preventing most control-hijacking attacks while maintaining low overhead. CPI protects access to code pointers by storing them in a safe region that is protected by instruction level isolation. On x86-32, this isolation is enforced by hardware, on x86-64 and ARM, isolation is enforced by information hiding. We show that, for architectures that do\u00a0\u2026", "num_citations": "185\n", "authors": ["340"]}
{"title": "Countering network worms through automatic patch generation\n", "abstract": " To counter zero-day worms that exploit software flaws such as buffer overflows, this end-point architecture uses source code transformations to automatically create and test software patches for vulnerable segments of targeted applications.", "num_citations": "161\n", "authors": ["340"]}
{"title": "Using code perforation to improve performance, reduce energy consumption, and respond to failures\n", "abstract": " Many modern computations (such as video and audio encoders, Monte Carlo simulations, and machine learning algorithms) are designed to trade off accuracy in return for increased performance. To date, such computations typically use ad-hoc, domain-specific techniques developed specifically for the computation at hand. We present a new general technique, code perforation, for automatically augmenting existing computations with the capability of trading off accuracy in return for performance. In contrast to existing approaches, which typically require the manual development of new algorithms, our implemented SpeedPress compiler can automatically apply code perforation to existing computations with no developer intervention whatsoever. The result is a transformed computation that can respond almost immediately to a range of increased performancedemands while keeping any resulting output distortion within acceptable user-defined bounds. We have used SpeedPress to automatically apply code perforation to applications from the PARSEC benchmark suite. The results show that the transformed applications can run as much as two to three times faster than the original applications while distorting the output by less than 10%. Because the transformed applications can operate successfully at many points in the performance/accuracy tradeoff space, they can (dynamically and on demand) navigate the tradeoff space to either maximize performance subject to a given accuracy constraint, or maximize accuracy subject to a given performance constraint. We also demonstrate the SpeedGuard runtime system which uses code perforation to\u00a0\u2026", "num_citations": "155\n", "authors": ["340"]}
{"title": "Ubiquitous computing in home networks\n", "abstract": " In the past decade, there have been numerous efforts in ubiquitous. computing. For home networks, we believe that ubiquitous computing requires a global-scale system that is securable, administered by, multiple independent nonspecialist administrators, and integrates off-the-shelf hardware and software. In this system every home owner acts as an administrator of the network in the home. We are developing such a system based on the Session Initiation Protocol (SIP), with Bluetooth devices for location sensing and the Service Location Protocol (SLP) for service discovery. We also introduce context-aware location information to augment device discovery bind user communication. The system builds on our CINEMA infrastructure.", "num_citations": "146\n", "authors": ["340"]}
{"title": "Automatic error elimination by horizontal code transfer across multiple applications\n", "abstract": " We present Code Phage (CP), a system for automatically transferring correct code from donor applications into recipient applications that process the same inputs to successfully eliminate errors in the recipient. Experimental results using seven donor applications to eliminate ten errors in seven recipient applications highlight the ability of CP to transfer code across applications to eliminate out of bounds access, integer overflow, and divide by zero errors. Because CP works with binary donors with no need for source code or symbolic information, it supports a wide range of use cases. To the best of our knowledge, CP is the first system to automatically transfer code across multiple applications.", "num_citations": "130\n", "authors": ["340"]}
{"title": "Methods and systems for repairing applications\n", "abstract": " Applications may terminate due to any number of threats, program errors, software faults, attacks, or any other Suitable Software failure. Computer viruses, worms, trojans, hackers, key recovery attacks, malicious executables, probes, etc. area constant menace to users of computers connected to public computer networks (such as the Internet) and/or private net works (such as corporate computer networks). In response to these threats, many computers are protected by antivirus Soft ware and firewalls. However, these preventative measures are not always adequate. For example, many services must main tain a high availability when faced by remote attacks, high Volume events (such as fast-spreading worms like Slammer and Blaster), or simple application-level denial of service (DoS) attacks.Aside from these threats, applications generally contain errors during operation, which typically result from program mer\u00a0\u2026", "num_citations": "129\n", "authors": ["340"]}
{"title": "Systems, methods, and media protecting a digital data processing device from attack\n", "abstract": " In accordance with some embodiments of the disclosed subject matter, systems, methods, and media for protecting a digital data processing device from attack are provided. For example, in some embodiments, a method for protecting a digital data processing device from attack is provided, that includes, within a virtual environment: receiving at least one attachment to an electronic mail; and executing the at least one attachment; and based on the execution of the at least one attachment, determining whether anomalous behavior occurs.", "num_citations": "118\n", "authors": ["340"]}
{"title": "A network worm vaccine architecture\n", "abstract": " The ability of worms to spread at rates that effectively preclude human-directed reaction has elevated them to a first-class security threat to distributed systems. We present the first reaction mechanism that seeks to automatically patch vulnerable software. Our system employs a collection of sensors that detect and capture potential worm infection vectors. We automatically test the effects of these vectors on appropriately-instrumented sandboxed instances of the targeted application, trying to identify the exploited software weakness. Our heuristics allow us to automatically generate patches that can protect against certain classes of attack, and test the resistance of the patched application against the infection vector. We describe our system architecture, discuss the various components, and propose directions for future research.", "num_citations": "111\n", "authors": ["340"]}
{"title": "Methods, media and systems for detecting anomalous program executions\n", "abstract": " Methods, media, and systems for detecting anomalous program executions are provided. In some embodiments, methods for detecting anomalous program executions are provided, comprising: executing at least a part of a program in an emulator; comparing a function call made in the emulator to a model of function calls for the at least a part of the program; and identifying the function call as anomalous based on the comparison. In some embodiments, methods for detecting anomalous program executions are provided, comprising: modifying a program to include indicators of program-level function calls being made during execution of the program; comparing at least one of the indicators of program-level function calls made in the emulator to a model of function calls for the at least a part of the program; and identifying a function call corresponding to the at least one of the indicators as anomalous based on the\u00a0\u2026", "num_citations": "103\n", "authors": ["340"]}
{"title": "Automatic runtime error repair and containment via recovery shepherding\n", "abstract": " We present a system, RCV, for enabling software applications to survive divide-by-zero and null-dereference errors. RCV operates directly on off-the-shelf, production, stripped x86 binary executables. RCV implements recovery shepherding, which attaches to the application process when an error occurs, repairs the execution, tracks the repair effects as the execution continues, contains the repair effects within the application process, and detaches from the process after all repair effects are flushed from the process state. RCV therefore incurs negligible overhead during the normal execution of the application. We evaluate RCV on all divide-by-zero and null-dereference errors available in the CVE database [2] from January 2011 to March 2013 that 1) provide publicly-available inputs that trigger the error which 2) we were able to use to trigger the reported error in our experimental environment. We collected a total\u00a0\u2026", "num_citations": "102\n", "authors": ["340"]}
{"title": "A dynamic mechanism for recovering from buffer overflow attacks\n", "abstract": " We examine the problem of containing buffer overflow attacks in a safe and efficient manner. Briefly, we automatically augment source code to dynamically catch stack and heap-based buffer overflow and underflow attacks, and recover from them by allowing the program to continue execution. Our hypothesis is that we can treat each code function as a transaction that can be aborted when an attack is detected, without affecting the application\u2019s ability to correctly execute. Our approach allows us to enable selectively or disable components of this defensive mechanism in response to external events, allowing for a direct tradeoff between security and performance. We combine our defensive mechanism with a honeypot-like configuration to detect previously unknown attacks, automatically adapt an application\u2019s defensive posture at a negligible performance cost, and help determine worm signatures\u00a0\u2026", "num_citations": "98\n", "authors": ["340"]}
{"title": "Software self-healing using collaborative application communities\n", "abstract": " Software monocultures are usually considered dangerous because their size and uniformity represent the potential for costly and widespread damage. The emerging concept of collaborative security provides the opportunity to re-examine the utility of software monoculture by exploiting the homogeneity and scale that typically define large software monocultures. Monoculture can be leveraged to improve an application\u2019s overall security and reliability. We introduce and explore the concept of Application Communities: collections of large numbers of independent instances of the same application. Members of an application community share the burden of monitoring for flaws and attacks, and notify the rest of the community when such are detected. Appropriate mitigation mechanisms are then deployed against the newly discovered fault. We explore the concept of an application community and determine its feasibility through analytical modeling and a prototype implementation focusing on software faults and vulnerabilities. Specifically, we identify a set of parameters that define application communities and explore the tradeoffs between the minimal size of an application community, the marginal overhead imposed on each member, and the speed with which new faults are detected and isolated. We demonstrate the feasibility of the scheme using Selective Transactional EMulation (STEM) as both the monitoring and remediation mechanism for low-level software faults, and provide some preliminary experimental results using the Apache web server as the protected application. Our experiments show that ACs are practical and feasible for current\u00a0\u2026", "num_citations": "90\n", "authors": ["340"]}
{"title": "Ubiquitous computing using SIP\n", "abstract": " In the past decade, there have been numerous efforts in ubiquitous computing, making computational resources or communication more widely available. We believe that it is time to move to a global-scale ubiquitous computing system that is securable, administered by multiple independent administrators and integrates off-the-shelf hardware and software. We are developing such a system based on the Session Initiation Protocol (SIP), with Bluetooth devices for location sensing and Service Location Protocol (SLP) for service discovery. We also introduce context-aware location information to augment device discovery and user communication. The system builds on our CINEMA infrastructure and can support a range of activities, from home-based settings to collaboration between distant sites.", "num_citations": "87\n", "authors": ["340"]}
{"title": "Automatic input rectification\n", "abstract": " We present a novel technique, automatic input rectification, and a prototype implementation, SOAP. SOAP learns a set of constraints characterizing typical inputs that an application is highly likely to process correctly. When given an atypical input that does not satisfy these constraints, SOAP automatically rectifies the input (i.e., changes the input so that it satisfies the learned constraints). The goal is to automatically convert potentially dangerous inputs into typical inputs that the program is highly likely to process correctly. Our experimental results show that, for a set of benchmark applications (Google Picasa, ImageMagick, VLC, Swfdec, and Dillo), this approach effectively converts malicious inputs (which successfully exploit vulnerabilities in the application) into benign inputs that the application processes correctly. Moreover, a manual code analysis shows that, if an input does satisfy the learned constraints, it is\u00a0\u2026", "num_citations": "69\n", "authors": ["340"]}
{"title": "Proximity Breeds Danger: Emerging Threats in Metro-area Wireless Networks.\n", "abstract": " The growing popularity of wireless networks and mobile devices is starting to attract unwanted attention especially as potential targets for malicious activities reach critical mass. In this study, we try to quantify the threat from large-scale distributed attacks on wireless networks, and, more specifically, wifi networks in densely populated metropolitan areas. We focus on three likely attack scenarios:\u201cwildfire\u201d worms that can spread contagiously over and across wireless LANs, coordinated citywide phishing campaigns based on wireless spoofing, and rogue systems for compromising location privacy in a coordinated fashion. The first attack illustrates how dense wifi deployment may provide opportunities for attackers who want to quickly compromise large numbers of machines. The last two attacks illustrate how botnets can amplify wifi vulnerabilities, and how botnet power is amplified by wireless connectivity. To quantify these threats, we rely on real-world data extracted from wifi maps of large metropolitan areas in the States and Singapore. Our results suggest that a carefully crafted wireless worm can infect up to 80% of all wifi connected hosts in some metropolitan areas within 20 minutes, and that an attacker can launch phishing attacks or build a tracking system to monitor the location of 10-50% of wireless users in these metropolitan areas with just 1,000 zombies under his control.", "num_citations": "65\n", "authors": ["340"]}
{"title": "Sound input filter generation for integer overflow errors\n", "abstract": " We present a system, SIFT, for generating input filters that nullify integer overflow errors associated with critical program sites such as memory allocation or block copy sites. SIFT uses a static pro-gram analysis to generate filters that discard inputs that may trigger integer overflow errors in the computations of the sizes of allocated memory blocks or the number of copied bytes in block copy operations. Unlike all previous techniques of which we are aware, SIFT is sound--if an input passes the filter, it will not trigger an integer overflow error at any analyzed site. Our results show that SIFT successfully analyzes (and therefore generates sound input filters for) 56 out of 58 memory allocation and block memory copy sites in analyzed input processing modules from five applications (VLC, Dillo, Swfdec, Swftools, and GIMP). These nullified errors include six known integer overflow vulnerabilities. Our results also show that\u00a0\u2026", "num_citations": "58\n", "authors": ["340"]}
{"title": "Application communities: Using monoculture for dependability\n", "abstract": " Artificial diversity is one method for mitigating the security risks of software monoculture. Introducing diversity increases resilience by obfuscating the system parameters an attacker must control for a successful exploit. We take a different approach to resilience and introduce the concept of Application Communities (AC): collections of independent instances of the same application that cooperatively monitor their execution for flaws and attacks and notify the community when such events are detected. We propose a set of parameters that define an AC and explore the tradeoffs between the minimal size of an AC, the marginal overhead imposed on each member, and the speed with which new faults are detected. We provide a sketch of both analytical and experimental results that show ACs are feasible for current applications: an AC of 15,000 members can monitor Apache for new faults with a 6% performance degradation for each member.", "num_citations": "53\n", "authors": ["340"]}
{"title": "Patterns and statistical analysis for understanding reduced resource computing\n", "abstract": " We present several general, broadly applicable mechanisms that enable computations to execute with reduced resources, typically at the cost of some loss in the accuracy of the result they produce.We identify several general computational patterns that interact well with these resource reduction mechanisms, present a concrete manifestation of these patterns in the form of simple model programs, perform simulationbased explorations of the quantitative consequences of applying these mechanisms to our model programs, and relate the model computations (and their interaction with the resource reduction mechanisms) to more complex benchmark applications drawn from a variety of fields.", "num_citations": "51\n", "authors": ["340"]}
{"title": "Targeted automatic integer overflow discovery using goal-directed conditional branch enforcement\n", "abstract": " We present a new technique and system, DIODE, for auto-matically generating inputs that trigger overflows at memory allocation sites. DIODE is designed to identify relevant sanity checks that inputs must satisfy to trigger overflows at target memory allocation sites, then generate inputs that satisfy these sanity checks to successfully trigger the overflow. DIODE works with off-the-shelf, production x86 binaries. Our results show that, for our benchmark set of applications, and for every target memory allocation site exercised by our seed inputs (which the applications process correctly with no overflows), either 1) DIODE is able to generate an input that triggers an overflow at that site or 2) there is no input that would trigger an overflow for the observed target expression at that site.", "num_citations": "50\n", "authors": ["340"]}
{"title": "An email worm vaccine architecture\n", "abstract": " We present an architecture for detecting \u201czero-day\u201d worms and viruses in incoming email. Our main idea is to intercept every incoming message, pre-scan it for potentially dangerous attachments, and only deliver messages that are deemed safe. Unlike traditional scanning techniques that rely on some form of pattern matching (signatures), we use behavior-based anomaly detection. Under our approach, we \u201copen\u201d all suspicious attachments inside an instrumented virtual machine looking for dangerous actions, such as writing to the Windows registry, and flag suspicious messages. The attachment processing can be offloaded to a cluster of ancillary machines (as many as are needed to keep up with a site\u2019s email load), thus not imposing any computational load on the mail server. Messages flagged are put in a \u201cquarantine\u201d area for further, more labor-intensive processing. Our implementation shows that we\u00a0\u2026", "num_citations": "50\n", "authors": ["340"]}
{"title": "Using rescue points to navigate software recovery\n", "abstract": " We present a new technique that enables software recovery in legacy applications by retrofitting exception-handling capabilities, error virtualization using rescue points. We introduce the idea of \"rescue points\" as program locations to which an application can recover its execution in the presence of failures. The use of rescue points reduces the chance of unanticipated execution paths thereby making recovery more robust by mimicking system behavior under controlled error conditions. These controlled error conditions can be thought of as a set erroneous inputs, like the ones used by most quality-assurance teams during software development, designed to stress-test an application. To discover rescue points applications are profiled and monitored during tests that bombard the program with bad/random inputs. The intuition is that by monitoring application behavior during these runs, we gain insight into how\u00a0\u2026", "num_citations": "48\n", "authors": ["340"]}
{"title": "Botswindler: Tamper resistant injection of believable decoys in vm-based hosts for crimeware detection\n", "abstract": " We introduce BotSwindler, a bait injection system designed to delude and detect crimeware by forcing it to reveal during the exploitation of monitored information. The implementation of BotSwindler relies upon an out-of-host software agent that drives user-like interactions in a virtual machine, seeking to convince malware residing within the guest OS that it has captured legitimate credentials. To aid in the accuracy and realism of the simulations, we propose a low overhead approach, called virtual machine verification, for verifying whether the guest OS is in one of a predefined set of states. We present results from experiments with real credential-collecting malware that demonstrate the injection of monitored financial bait for detecting compromises. Additionally, using a computational analysis and a user study, we illustrate the believability of the simulations and we demonstrate that they are sufficiently\u00a0\u2026", "num_citations": "44\n", "authors": ["340"]}
{"title": "Dancing with uncertainty\n", "abstract": " We present Dubstep, a novel system that uses the find-transform-navigate paradigm to automatically explore new parallelization opportunities in already parallelized (fully-synchronized) programs by opportunistically relaxing synchronization primitives. This set of transformations generates a space of alternative, possibly non-deterministic, parallel programs with varying performance and accuracy characteristics. The freedom to generate parallel programs whose output may differ (within statistical accuracy bounds) from the output of the original program enables a significantly larger optimization space. Dubstep then searches this space to find a parallel program that will, with high likelihood, produce outputs that are acceptably close to the outputs that the original, fully synchronized parallel program would have produced.", "num_citations": "39\n", "authors": ["340"]}
{"title": "Shadow honeypots\n", "abstract": " We present Shadow Honeypots, a novel hybrid architecture that combines the best features of honeypots and anomaly detection. At a high level, we use a variety of anomaly detectors to monitor all traffic to a protected network or service. Traffic that is considered anomalous is processed by a \u201cshadow honeypot\u201d to determine the accuracy of the anomaly prediction. The shadow is an instance of the protected software that shares all internal state with a regular (\u201cproduction\u201d) instance of the application, and is instrumented to detect potential attacks. Attacks against the shadow are caught, and any incurred state changes are discarded. Legitimate traffic that was misclassified will be validated by the shadow and will be handled correctly by the system transparently to the end user. The outcome of processing a request by the shadow is used to filter future attack instances and could be used to update the anomaly detector. Our architecture allows system designers to fine-tune systems for performance, since false positives will be filtered by the shadow. We demonstrate the feasibility of our approach in a proof-ofconcept implementation of the Shadow Honeypot architecture for the Apache web server and the Mozilla Firefox browser. We show that despite a considerable overhead in the instrumentation of the shadow honeypot (up to 20% for Apache), the overall impact on the system is diminished by the ability to minimize the rate of false-positives.", "num_citations": "26\n", "authors": ["340"]}
{"title": "Methods, media, and systems for detecting anomalous program executions\n", "abstract": " Methods, media, and systems for detecting anomalous program executions are provided. In some embodiments, methods for detecting anomalous program executions are provided, comprising: executing at least a part of a program in an emulator; comparing a function call made in the emulator to a model of function calls for the at least a part of the program; and identifying the function call as anomalous based on the comparison. In some embodiments, methods for detecting anomalous program executions are provided, comprising: modifying a program to include indicators of program-level function calls being made during execution of the program; comparing at least one of the indicators of program-level function calls made in the emulator to a model of function calls for the at least a part of the program; and identifying a function call corresponding to the at least one of the indicators as anomalous based on the\u00a0\u2026", "num_citations": "25\n", "authors": ["340"]}
{"title": "Band-aid patching\n", "abstract": " Testing vendor-issued patches remains one of the major hurdles to their speedy deployment. Studies have shown that administrators remain reluctant to quickly patch their systems, even when they have the capability to do so, partly because security patches in particular are often incomplete or altogether non-functional.We propose Band-aid Patching, a new approach for concurrently testing application patches. Using binary runtime injection techniques, we patch binaries such that when program execution reaches a program segment that has been affected by an issued patch, two (or more) program execution threads are created. These threads speculatively execute both parts of the code (patched and unpatched). Our system then retroactively selects one of the execution threads based on a variety of criteria, including obvious faultiness, prior history, and user input. We believe this approach to offer significant advantages to accelerating deployment of hot fixes while providing some assurance to system administrators. In this paper, we describe our initial thoughts on the system architecture, and provide some preliminary indications on the feasibility and performance impact of our scheme.", "num_citations": "25\n", "authors": ["340"]}
{"title": "Using execution transactions to recover from buffer overflow attacks\n", "abstract": " We examine the problem of containing buffer overflow attacks in a safe and efficient manner. Briefly, we dynamically augment source code to catch stack and heap-based buffer overflow and underflow attacks, and recover from them by allowing the program to continue execution. Our hypothesis is that we can treat each code function as a transaction that can be aborted when an attack is detected, without affecting the application\u2019s ability to correctly execute. Furthermore, our approach allows us to selectively enable or disable components of this defensive mechanism in response to external events, allowing for a direct tradeoff between security and performance. We apply our system to the problem of containing worms, combining this defensive mechanism with a honeypot-like configuration. This approach allows us to detect previously unknown attacks and automatically adapt an application\u2019s defensive posture at a negligible performance cost.The primary benefits of our scheme are its low impact on application performance, its ability to respond to attacks without human intervention, its capacity to handle previously unknown vulnerabilities, and the preservation of service availability. We implemented the scheme as a stand-alone tool, DYBOC, which we use to instrument a number of vulnerable applications. Our performance benchmarks indicate a slow-down of 20.1% for Apache in full-protection mode. We validate our transactional hypothesis via two experiments: first, by applying our scheme to 17 vulnerable applications, successfully fixing 14 of them; second, by examining the behavior of Apache when each of 154 potentially vulnerable\u00a0\u2026", "num_citations": "24\n", "authors": ["340"]}
{"title": "CodeCarbonCopy\n", "abstract": " We present CodeCarbonCopy (CCC), a system for transferring code from a donor application into a recipient application. CCC starts with functionality identified by the developer to transfer into an insertion point (again identified by the developer) in the recipient. CCC uses paired executions of the donor and recipient on the same input file to obtain a translation between the data representation and name space of the recipient and the data representation and name space of the donor. It also implements a static analysis that identifies and removes irrelevant functionality useful in the donor but not in the recipient. We evaluate CCC on eight transfers between six applications. Our results show that CCC can successfully transfer donor functionality into recipient applications.", "num_citations": "22\n", "authors": ["340"]}
{"title": "Principled Sampling for Anomaly Detection.\n", "abstract": " Anomaly detection plays an important role in protecting computer systems from unforeseen attack by automatically recognizing and filter atypical inputs. However, it can be difficult to balance the sensitivity of a detector\u2013an aggressive system can filter too many benign inputs while a conservative system can fail to catch anomalies. Accordingly, it is important to rigorously test anomaly detectors to evaluate potential error rates before deployment. However, principled systems for doing so have not been studied\u2013testing is typically ad hoc, making it difficult to reproduce results or formally compare detectors.To address this issue we present a technique and implemented system, Fortuna, for obtaining probabilistic bounds on false positive rates for anomaly detectors that process Internet data. Using a probability distribution based on PageRank and an efficient algorithm to draw samples from the distribution, Fortuna computes an estimated false positive rate and a probabilistic bound on the estimate\u2019s accuracy. By drawing test samples from a well defined distribution that correlates well with data seen in practice, Fortuna improves on ad hoc methods for estimating false positive rate, giving bounds that are reproducible, comparable across different anomaly detectors, and theoretically sound.", "num_citations": "21\n", "authors": ["340"]}
{"title": "Automatic error elimination by multi-application code transfer\n", "abstract": " We present pDNA, a system for automatically transfer- ring correct code from donor applications into recipient applications to successfully eliminate errors in the recipient. Experimental results using six donor applications to eliminate nine errors in six recipient applications highlight the ability of pDNA to transfer code across applications to eliminate otherwise fatal integer and buffer overflow errors. Because pDNA works with binary donors with no need for source code or symbolic information, it supports a wide range of use cases. To the best of our knowledge, pDNA is the first system to eliminate software errors via the successful transfer of correct code across applications.", "num_citations": "20\n", "authors": ["340"]}
{"title": "Methods, systems, and media for detecting covert malware\n", "abstract": " Methods, systems, and media for detecting covert malware are provided. In accordance with some embodiments, a method for detecting covert malware in a computing environment is provided, the method comprising: receiving a first set of user actions; generating a second set of user actions based on the first set of user actions and a model of user activity; conveying the second set of user actions to an application inside the computing environment; determining whether state information of the application matches an expected state after the second set of user actions is conveyed to the application; and determining whether covert malware is present in the computing environment based at least in part on the determination.", "num_citations": "17\n", "authors": ["340"]}
{"title": "Automatic discovery and patching of buffer and integer overflow errors\n", "abstract": " We present Targeted Automatic Patching (TAP), an automatic buffer and integer overflow discovery and patching system. Starting with an application and a seed input that the application processes correctly, TAP dynamically analyzes the execution of the application to locate target memory allocation sites and statements that access dynamically or statically allocated blocks of memory. It then uses targeted error-discovery techniques to automatically generate inputs that trigger integer and/or buffer overflows at the target sites. When it discovers a buffer or integer overflow error, TAP automatically matches and applies patch templates to generate patches that eliminate the error. Our experimental results show that TAP successfully discovers and patches two buffer and six integer overflow errors in six real-world applications.", "num_citations": "15\n", "authors": ["340"]}
{"title": "Defending against next generation through network/endpoint collaboration and interaction\n", "abstract": " Over the past few years we have seen the use of Internet worms, i.e.,malicious self-replicating programs, as a mechanism to rapidly invade and compromise large numbers of remote computers [33]. Although the first worms released on the Internet were large-scale, easy-to-spot massive security incidents [6, 19, 20, 26], also known as flash worms [32], it is currently envisioned (and we see already see signs, in the wild) that future worms will be increasingly difficult to detect, and will be known as stealth worms. This may be partly because the motives of early worm developers are thought to have been centered around self-gratification brought by the achievement of compromising large numbers of remote computers, while the motives of recent worm and malware developers have progressed to more mundane (and sinister) financial and political gains.", "num_citations": "14\n", "authors": ["340"]}
{"title": "Speculative virtual verification: policy-constrained speculative execution\n", "abstract": " A key problem facing current computing systems is the inability to autonomously manage security vulnerabilities as well as more mundane errors. Since the design of computer architectures is usually performance-driven, hardware often lacks primitives for tasks in which raw speed is not the primary goal. There is little architectural support for monitoring execution at the instruction level, and no mechanisms for assisting an automated response. This paper advocates modifying general-purpose processors to provide both program supervision and automatic response via a policy-driven monitoring mechanism and instruction stream rewriting, respectively. These capabilities form the basis of speculative virtual verification (SVV). SVV is a model for the speculative execution of code based on high-level security and safety constraints. We introduce architectural enhancements to support this framework, including the ability\u00a0\u2026", "num_citations": "11\n", "authors": ["340"]}
{"title": "Program fracture and recombination for efficient automatic code reuse\n", "abstract": " We present a new code transfer technique, program fracture and recombination, for automatically replacing, deleting, and/or combining code from multiple applications. Benefits include automatic generation of new applications incorporating the best or most desirable functionality developed anywhere, the automatic elimination of errors and security vulnerabilities, effective software rejuvenation, the automatic elimination of obsolete or undesirable functionality, and improved performance, energy efficiency, simplicity, analyzability, and clarity. The technique may be particularly appropriate for high performance computing. The field has devoted years of effort to developing efficient (but complex) implementations of standard linear algebra operations with good numerical properties. At the same time these operations also have very simple but inefficient implementations, often with poor numerical properties. Program\u00a0\u2026", "num_citations": "9\n", "authors": ["340"]}
{"title": "Privacy as an Operating System Service.\n", "abstract": " The issue of electronic privacy has of late attracted considerable attention. The proliferation of Internet services and, perhaps unavoidably, Internet crime, in conjunction with expanded government monitoring of communications has caused irreparable damage to the basic definition of privacy (the state or condition of being free from unwanted surveillance1).Implementing privacy in personal computer systems has traditionally been the domain of the paranoid computer specialist. In order for basic privacy to become pervasive among the non-technical user base, we believe that it must imitate the usage of other successful security (and other) services. Services like filesystem encryption, email and web security are successful because they are invisible to the user. Other services (not related to security) such as backups, networking, file searching, etc., also gain traction by being well integrated with the user\u2019s operating environment. In most cases, this means embedding such services in the OS.", "num_citations": "9\n", "authors": ["340"]}
{"title": "Execution transactions for defending against software failures: use and evaluation\n", "abstract": " We examine the problem of containing buffer overflow attacks in a safe and efficient manner. Briefly, we automatically augment source code to dynamically catch stack and heap-based buffer overflow and underflow attacks, and recover from them by allowing the program to continue execution. Our hypothesis is that we can treat each code function as a transaction that can be aborted when an attack is detected, without affecting the application's ability to correctly execute. Our approach allows us to enable selectively or disable components of this defensive mechanism in response to external events, allowing for a direct tradeoff between security and performance. We combine our defensive mechanism with a honeypot-like configuration to detect previously unknown attacks, automatically adapt an application's defensive posture at a negligible performance cost, and help determine worm signatures. Our\u00a0\u2026", "num_citations": "9\n", "authors": ["340"]}
{"title": "Hardware support for self-healing software services\n", "abstract": " We propose a new approach for reacting to a wide variety of software failures, ranging from remotely exploitable vulnerabilities to more mundane bugs that cause abnormal program termination (e.g., illegal memory dereference). Our emphasis is in creating \"self-healing\" software that can protect itself against a recurring fault until a more comprehensive fix is applied. Our system consists of a set of sensors that monitor applications for various types of failure and an instruction-level emulator that is invoked for selected parts of a program's code. This emulator allows us to predict recurrences of faults and recover execution to a safe control flow. Using the emulator for small pieces of code, as directed by the sensors, allows us to minimize the performance impact on the immunized application. We describe the overall system architecture, highlighting a prototype implementation for the x86 platform. We discuss a virtual\u00a0\u2026", "num_citations": "9\n", "authors": ["340"]}
{"title": "Systems, methods, and media protecting a digital data processing device from attack\n", "abstract": " In accordance with some embodiments of the disclosed subject matter, systems, methods, and media for protecting a digital data processing device from attack are provided. For example, in some embodiments, a method for protecting a digital data processing device from attack is provided, that includes, within virtual environment: receiving at least one attachment to an electronic mail; and executing the at least one attachment; and based on the execution of the at least one attachment, determining whether anomalous behavior occurs.", "num_citations": "8\n", "authors": ["340"]}
{"title": "Systems, methods, and media for testing software patches\n", "abstract": " Systems, methods, and media for testing software patches are provided (200). The methods include: injecting a software patch into a program (202); running multiple instances of a part of the program containing the software patch (204); obtaining outcomes of the multiple instances (208); and determining, using the outcomes, whether the software patch is executed properly (210).", "num_citations": "8\n", "authors": ["340"]}
{"title": "A source-to-source transformation tool for error fixing\n", "abstract": " We present a methodology and a prototype of a source-to-source transformation tool for error fixing in C/C++ program source code for missing condition checks after a method call. The missing condition checks in a C program could lead to a program crash. This tool can be extended for other programming languages in addition to C/C++. The developed tool includes the ability to generate and apply a fix for a source code without human intervention. The tool can be run on different platforms, including MS Windows, Linux, MAC OS and other operating systems. We evaluate our technique by applying it to five widely used open source programs. Our results show that it is able to successfully detect and add the missing condition check or correct it after a method call in the program, and that our detection and error fixing technique is quite accurate in practice.", "num_citations": "8\n", "authors": ["340"]}
{"title": "Horizontal code transfer via program fracture and recombination\n", "abstract": " We present a new horizontal code transfer technique, program fracture and recombination, for automatically replacing, deleting, and/or combining code from multiple applications. Benefits include automatic generation of new applications incorporating the best or most desirable functionality developed anywhere, the automatic elimination of security vulnerabilities, effective software rejuvenation, the automatic elimination of obsolete or undesirable functionality, and improved performance, simplicity, analyzability, and clarity.", "num_citations": "6\n", "authors": ["340"]}
{"title": "AutoRand: Automatic keyword randomization to prevent injection attacks\n", "abstract": " AutoRand automatically transforms Java applications to use SQL keyword randomization to defend against SQL injection vulnerabilities. AutoRand is completely automatic. Unlike previous approaches it requires no manual modifications to existing code and does not require source (it works directly on Java bytecode). It can thus easily be applied to the large numbers of existing potentially insecure applications without developer assistance. Our key technical innovation is augmented strings. Augmented strings allow extra information (such as random keys) to be embedded within a string. AutoRand transforms string operations so that the extra information is transparent to the program, but is always propagated with each string operation. AutoRand checks each keyword at SQL statements for the random key. Experimental results on large, production Java applications and malicious inputs provided by an\u00a0\u2026", "num_citations": "5\n", "authors": ["340"]}
{"title": "Cloud Intrusion Detection and Repair (CIDAR)\n", "abstract": " Despite decades of effort, defect triage and correction remains a central concern in software engineering. Indeed, modern software projects contain so many defects, and the cost of correcting defects remains so large, that projects typically ship with a long list of known but uncorrected defects. Consequences of this unfortunate situation include pervasive security vulnerabilities and the diversion of resources that would be better devoted to other, more productive, activities. The goal of this research is to automate the process of discovering, neutralizing and repairing software bugs and vulnerabilities. As part of this goal, we build components of a continuous automatic improvement system that can automatically search for errors and generate patches that repair the encountered errors. By removing the human from the loop, patch generation time can be reduced, patch robustness improved, leading to fewer unpatched systems. The systems that we developed during this program lay the foundation for future automatic program repair systems that can significantly reducing the time and effort required to deal with software defects.Descriptors:", "num_citations": "3\n", "authors": ["340"]}
{"title": "Composite Hybrid Techniques For Defending Against Targeted Attacks\n", "abstract": " We investigate the use of hybrid techniques as a defensive mechanism against targeted attacks and introduce Shadow Honeypots, a novel hybrid architecture that combines the best features of honeypots and anomaly detection. At a high level, we use a variety of anomaly detectors to monitor all traffic to a protected network/service. Traffic that is considered anomalous is processed by a \u201dshadow honeypot\u201d to determine the accuracy of the anomaly prediction. The shadow is an instance of the protected software that shares all internal state with a regular (\u201dproduction\u201d) instance of the application, and is instrumented to detect potential attacks. Attacks against the shadow are caught, and any incurred state changes are discarded. Legitimate traffic that was misclassified will be validated by the shadow and will be handled correctly by the system transparently to the end user. The outcome of processing a request\u00a0\u2026", "num_citations": "3\n", "authors": ["340"]}
{"title": "Methods, media and systems for detecting anomalous program executions\n", "abstract": " Methods, media, and systems for detecting anomalous program executions are provided. In some embodiments, methods for detecting anomalous program executions are provided, comprising: executing at least a part of a program in an emulator; comparing a function call made in the emulator to a model of function calls for the at least a part of the program; and identifying the function call as anomalous based on the comparison. In some embodiments, methods for detecting anomalous program executions are provided, comprising: modifying a program to include indicators of program-level function calls being made during execution of the program; comparing at least one of the indicators of program-level function calls made in the emulator to a model of function calls for the at least a part of the program; and identifying a function call corresponding to the at least one of the indicators as anomalous based on the\u00a0\u2026", "num_citations": "2\n", "authors": ["340"]}
{"title": "IEEE SecDev 2016: Prioritizing Secure Development\n", "abstract": " It's clear that developers, researchers, and practitioners need a venue to discuss design approaches and tools for how to build security in and significantly reduce the introduction of vulnerabilities. Great progress is being made in the academic security research community, but the research results aren't transitioning to the engineering and development communities to the necessary extent and at the necessary speed. To address this critical need, the IEEE Cybersecurity Initiative is introducing a new event that aims to expand interactions and bridge the gap between cybersecurity research and development: the IEEE Cybersecurity Development Conference (SecDev).", "num_citations": "2\n", "authors": ["340"]}
{"title": "Self-defending software: Automatically patching security vulnerabilities\n", "abstract": " Self-defending software: Automatically patching security vulnerabilities - HKUST SPD | The Institutional Repository Skip to content Search Publications Advanced Search Profiles Self-defending software: Autom... Please use this identifier to cite or link to this item: http://hdl.handle.net/1783.1/16087 Self-defending software: Automatically patching security vulnerabilities Authors Perkins, Jeff Kim, Sung Hun View this author's profile Larsen, Sam Amarasinghe, Saman Bachrach, Jonathan Carbin, Michael Pacheco, Carlos Sherwood, Frank Sidiroglou, Stelios Sullivan, Greg Wong, Weng-Fai Zibin, Yoav Ernst, Michael Rinard, Martin Issue Date 2009 Source the 21st ACM Symposium on Operating Systems Principles (SOSP 2009) Language English Genre Conference paper Usage Metrics 26 Page views Similar Items Automatically patching errors in deployed software Author(s): Perkins, Jeff H.; Kim, Sunghun; Larsen, ... -(s): \u2026", "num_citations": "2\n", "authors": ["340"]}
{"title": "Systems, methods, and media for testing software patches\n", "abstract": " Systems, methods, and media for testing software patches are provided. The methods include: injecting a software patch into a program; determining a portion of the program modified by the software patch; concurrently executing a first instance of the portion of the program prior to modification by the software patch and a second instance of the portion of the program that has been modified by the software patch; obtaining a first outcome of the first instance and a second outcome of the second instance; comparing the first outcome and the second outcome with a policy associated with the program; and determining whether the software patch has executed correctly based at least in part on the comparison.", "num_citations": "1\n", "authors": ["340"]}
{"title": "Methods, media, and systems for detecting anomalous program executions\n", "abstract": " Methods, media, and systems for detecting anomalous program executions are provided. In some embodiments, methods for detecting anomalous program executions are provided, comprising: executing at least a part of a program in an emulator; comparing a function call made in the emulator to a model of function calls for the at least a part of the program; and identifying the function call as anomalous based on the comparison. In some embodiments, methods for detecting anomalous program executions are provided, comprising: modifying a program to include indicators of program-level function calls being made during execution of the program; comparing at least one of the indicators of program-level function calls made in the emulator to a model of function calls for the at least a part of the program; and identifying a function call corresponding to the at least one of the indicators as anomalous based on the\u00a0\u2026", "num_citations": "1\n", "authors": ["340"]}
{"title": "Automatically Patching Errors in Deployed Software\n", "abstract": " We present ClearView, a system for automatically patching errors in deployed software. ClearView works on stripped Windows x86 binaries without any need for source code, debugging information, or other external information, and without human intervention. ClearView (1) observes normal executions to learn invariants that characterize the application\u2019s normal behavior,(2) uses error detectors to distinguish normal executions from erroneous executions,(3) identifies violations of learned invariants that occur during erroneous executions,(4) generates candidate repair patches that enforce selected invariants by changing the state or flow of control to make the invariant true, and (5) observes the continued execution of patched applications to select the most successful patch. ClearView is designed to correct errors in software with high availability requirements. Aspects of ClearView that make it particularly appropriate for this context include its ability to generate patches without human intervention, apply and remove patches to and from running applications without requiring restarts or otherwise perturbing the execution, and identify and discard ineffective or damaging patches by evaluating the continued behavior of patched applications.ClearView was evaluated in a Red Team exercise designed to test its ability to successfully survive attacks that exploit security vulnerabilities. A hostile external Red Team developed ten code injection exploits and used these exploits to repeatedly attack an application protected by ClearView. ClearView detected and blocked all of the attacks. For seven of the ten exploits, ClearView automatically generated\u00a0\u2026", "num_citations": "1\n", "authors": ["340"]}
{"title": "Software self-healing using error virtualization\n", "abstract": " Despite considerable efforts in both research and development strategies, software errors and subsequent security vulnerabilities continue to be a significant problem for computer systems. The accepted wisdom is to approach the problem with a multitude of tools such as diligent software development strategies, dynamic bug finders and static analysis tools in an attempt to eliminate as many bugs as possible. Unfortunately, history has shown that it is very hard to achieve bug-free software. The situation is further exacerbated by the exorbitant cost of system down-time which some estimates place at six million dollars per hour. In the absence of perfect software, retrofitting error toleration and recovery techniques, in systems not designed to deal with failures, becomes a necessary complement to proactive approaches.", "num_citations": "1\n", "authors": ["340"]}