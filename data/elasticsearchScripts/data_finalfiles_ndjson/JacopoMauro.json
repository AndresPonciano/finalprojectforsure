{"title": "SUNNY: a lazy portfolio approach for constraint solving\n", "abstract": " Within the context of constraint solving, a portfolio approach allows one to exploit the synergy between different solvers in order to create a globally better solver. In this paper we present SUNNY: a simple and flexible algorithm that takes advantage of a portfolio of constraint solvers in order to compute \u2014 without learning an explicit model \u2014 a schedule of them for solving a given Constraint Satisfaction Problem (CSP). Motivated by the performance reached by SUNNY vs. different simulations of other state of the art approaches, we developed sunny-csp, an effective portfolio solver that exploits the underlying SUNNY algorithm in order to solve a given CSP. Empirical tests conducted on exhaustive benchmarks of MiniZinc models show that the actual performance of sunny-csp conforms to the predictions. This is encouraging both for improving the power of CSP portfolio solvers and for trying to export them to fields\u00a0\u2026", "num_citations": "62\n", "authors": ["1944"]}
{"title": "A multicore tool for constraint solving\n", "abstract": " In Constraint Programming (CP), a portfolio solver uses a variety of different solvers for solving a given Constraint Satisfaction/Optimization Problem. In this paper we introduce sunny-cp2: the first parallel CP portfolio solver that enables a dynamic, cooperative, and simultaneous execution of its solvers in a multicore setting. It incorporates state-of-the-art solvers, providing also a usable and configurable framework. Empirical results are very promising. sunny-cp2 can even outperform the performance of the oracle solver which always selects the best solver of the portfolio for a given problem.", "num_citations": "50\n", "authors": ["1944"]}
{"title": "Self-reconfiguring microservices\n", "abstract": " Microservices is an emerging paradigm for the development of distributed systems that, originating from Service-Oriented Architecture, focuses on the small dimension, the loose coupling, and the dynamic topology of services. Microservices are particularly appropriate for the development of distributed systems in the Cloud. However, their dynamic nature calls for suitable techniques for their automatic deployment. In this paper we address this problem and we propose JRO (Jolie Redeployment Optimiser), a tool for the automatic and optimised deployment of microservices written in the Jolie language. The tool uses Zephyrus, a state of the art tool that automatically generates a fully detailed Service-Oriented Architecture configuration starting from a partial and abstract description of the target application.", "num_citations": "47\n", "authors": ["1944"]}
{"title": "AIOCJ: A choreographic framework for safe adaptive distributed applications\n", "abstract": " We present AIOCJ, a framework for programming distributed adaptive applications. Applications are programmed using AIOC, a choreographic language suited for expressing patterns of interaction from a global point of view. AIOC allows the programmer to specify which parts of the application can be adapted. Adaptation takes place at runtime by means of rules, which can change during the execution to tackle possibly unforeseen adaptation needs. AIOCJ relies on a solid theory that ensures applications to be deadlock-free by construction also after adaptation. We describe the architecture of AIOCJ, the design of the AIOC language, and an empirical validation of the framework.", "num_citations": "46\n", "authors": ["1944"]}
{"title": "Portfolio approaches for constraint optimization problems\n", "abstract": " Within the Constraint Satisfaction Problems (CSP) context, a methodology that has proven to be particularly performant consists of using a portfolio of different constraint solvers. Nevertheless, comparatively few studies and investigations have been done in the world of Constraint Optimization Problems (COP). In this work, we provide a generalization to COP as well as an empirical evaluation of different state of the art existing CSP portfolio approaches properly adapted to deal with COP. The results obtained by measuring several evaluation metrics confirm the effectiveness of portfolios even in the optimization field, and could give rise to some interesting future research.", "num_citations": "43\n", "authors": ["1944"]}
{"title": "Dynamic choreographies\n", "abstract": " Programming distributed applications free from communication deadlocks and races is complex. Preserving these properties when applications are updated at runtime is even harder.                 We present DIOC, a language for programming distributed applications that are free from deadlocks and races by construction. A DIOC program describes a whole distributed application as a unique entity (choreography). DIOC allows the programmer to specify which parts of the application can be updated. At runtime, these parts may be replaced by new DIOC fragments from outside the application. DIOC programs are compiled, generating code for each site, in a lower-level language called DPOC. We formalise both DIOC and DPOC semantics as labelled transition systems and prove the correctness of the compilation as a trace equivalence result. As corollaries, DPOC applications are free from communication\u00a0\u2026", "num_citations": "38\n", "authors": ["1944"]}
{"title": "Dynamic choreographies: Theory and implementation\n", "abstract": " Programming distributed applications free from communication deadlocks and race conditions is complex. Preserving these properties when applications are updated at runtime is even harder. We present a choreographic approach for programming updatable, distributed applications. We define a choreography language, called Dynamic Interaction-Oriented Choreography (AIOC), that allows the programmer to specify, from a global viewpoint, which parts of the application can be updated. At runtime, these parts may be replaced by new AIOC fragments from outside the application. AIOC programs are compiled, generating code for each participant in a process-level language called Dynamic Process-Oriented Choreographies (APOC). We prove that APOC distributed applications generated from AIOC specifications are deadlock free and race free and that these properties hold also after any runtime update. We instantiate the theoretical model above into a programming framework called Adaptable Interaction-Oriented Choreographies in Jolie (AIOCJ) that comprises an integrated development environment, a compiler from an extension of AIOCs to distributed Jolie programs, and a runtime environment to support their execution.", "num_citations": "37\n", "authors": ["1944"]}
{"title": "An empirical evaluation of portfolios approaches for solving csps\n", "abstract": " Recent research in areas such as SAT solving and Integer Linear Programming has shown that the performances of a single arbitrarily efficient solver can be significantly outperformed by a portfolio of possibly slower on-average solvers. We report an empirical evaluation and comparison of portfolio approaches applied to Constraint Satisfaction Problems (CSPs). We compared models developed on top of off-the-shelf machine learning algorithms with respect to approaches used in the SAT field and adapted for CSPs, considering different portfolio sizes and using as evaluation metrics the number of solved problems and the time taken to solve them. Results indicate that the best SAT approaches have top performances also in the CSP field and are slightly more competitive than simple models built on top of classification algorithms.", "num_citations": "37\n", "authors": ["1944"]}
{"title": "SUNNY-CP: a sequential CP portfolio solver\n", "abstract": " The Constraint Programming (CP) paradigm allows to model and solve Constraint Satisfaction/Optimization Problems (CSPs/COPs). A CP Portfolio Solver is a particular constraint solver that takes advantage of a portfolio of different CP solvers in order to solve a given problem by properly exploiting Algorithm Selection techniques. In this work we present sunny-cp: a CP portfolio for solving both CSPs and COPs that turned out to be competitive also in the MiniZinc Challenge, the reference competition for CP solvers.", "num_citations": "29\n", "authors": ["1944"]}
{"title": "Zephyrus2: On the fly deployment optimization using SMT and CP technologies\n", "abstract": " Modern cloud applications consist of software components deployed on multiple virtual machines. Deploying such applications is error prone and requires detailed system expertise. The deployment optimization problem is about how to configure and deploy applications correctly while at the same time minimizing resource cost on the cloud. This problem is addressed by tools such as Zephyrus, which take a declarative specification of the components and their configuration requirements as input and propose an optimal deployment. This paper presents Zephyrus2, a new tool which addresses deployment optimization by exploiting modern SMT and CP technologies to handle larger and more complex deployment scenarios. Compared to Zephyrus, Zephyrus2 can solve problems involving hundreds of components to be deployed on hundreds of virtual machines in a matter of seconds instead of minutes\u00a0\u2026", "num_citations": "27\n", "authors": ["1944"]}
{"title": "An enhanced features extractor for a portfolio of constraint solvers\n", "abstract": " Recent research has shown that a single arbitrarily efficient solver can be significantly outperformed by a portfolio of possibly slower on-average solvers. The solver selection is usually done by means of (un) supervised learning techniques which exploit features extracted from the problem specification. In this paper we present an useful and flexible framework that is able to extract an extensive set of features from a Constraint (Satisfaction/Optimization) Problem defined in possibly different modeling languages: MiniZinc, FlatZinc or XCSP.", "num_citations": "26\n", "authors": ["1944"]}
{"title": "A planning tool supporting the deployment of cloud applications\n", "abstract": " Cloud computing offers the possibility to build sophisticated software systems on virtualized infrastructures at a fraction of the cost necessary just a few years ago. Nevertheless, the deployment of such complex systems is a serious issue due to the large number of involved software packages and services, and to their elaborated interdependencies. In this paper we address the challenge of automatizing this complex deployment process. We first formalize it as a planning problem and observe that standard planning tools can effectively solve it only on small and trivial instances. For this reason, we propose an ad hoc planning technique which we validate by means of a prototype implementation able to effectively solve this deployment problem also on instances of realistic size.", "num_citations": "25\n", "authors": ["1944"]}
{"title": "Towards global and local types for adaptation\n", "abstract": " Choreographies allow designers to specify the protocols followed by participants of a distributed interaction. In this context, adaptation may be necessary to respond to external requests or to better suit a changing environment (a self-update). Adapting the behavior of a participant requires to update in a coordinated way possibly all the participants interacting with him. We propose a language able to describe a choreography together with its adaptation strategies, and we discuss the main issues that have to be solved to enable adaptation on a participant code dealing with many interleaved protocols.", "num_citations": "19\n", "authors": ["1944"]}
{"title": "Optimal and automated deployment for microservices\n", "abstract": " Microservices are highly modular and scalable Service Oriented Architectures. They underpin automated deployment practices like Continuous Deployment and Autoscaling. In this paper we formalize these practices and show that automated deployment\u2014proven undecidable in the general case\u2014is algorithmically treatable for microservices. Our key assumption is that the configuration life-cycle of a microservice is split into two phases:(i) creation, which entails establishing initial connections with already available microservices, and (ii) subsequent binding/unbinding with other microservices. To illustrate the applicability of our approach, we implement an automatic optimal deployment tool and compute deployment plans for a realistic microservice architecture, modeled in the Abstract Behavioral Specification (ABS) language.", "num_citations": "16\n", "authors": ["1944"]}
{"title": "Compiling and executing declarative modeling languages to gecode\n", "abstract": " We developed a compiler from SICStus Prolog CLP(FD) to Gecode and a compiler from MiniZinc to Gecode. We compared the running times of the executions of (standard) codes directly in the three languages and of the compiled codes for some classical problems. Performances of the compiled codes in Gecode improve those in the original languages and are comparable with running time of native Gecode code. This is a first step towards the definition of a unified declarative modeling tool for combinatorial problems.", "num_citations": "15\n", "authors": ["1944"]}
{"title": "Declarative elasticity in ABS\n", "abstract": " Traditional development methodologies that separate software design from application deployment have been replaced by approaches such as continuous delivery or DevOps, according to which deployment issues should be taken into account already at the early stages of development. This calls for the definition of new modeling and specification languages. In this paper we show how deployment can be added as a first-class citizen in the object-oriented modeling language ABS. We follow a declarative approach: programmers specify deployment constraints and a solver synthesizes ABS classes exposing methods like deploy (resp. undeploy) that executes (resp. cancels) configuration actions changing the current deployment towards a new one satisfying the programmer\u2019s desiderata. Differently from previous works, this novel approach allows for the specification of incremental modifications, thus\u00a0\u2026", "num_citations": "14\n", "authors": ["1944"]}
{"title": "Automatic component deployment in the presence of circular dependencies\n", "abstract": " In distributed systems like clouds or service oriented frameworks, applications are typically assembled by deploying and connecting a large number of heterogeneous software components, spanning from fine-grained packages to coarse-grained complex services. The complexity of such systems requires a rich set of techniques and tools to support the automation of their deployment process. By relying on a formal model of components, we describe a sound and complete algorithm for computing the sequence of actions allowing the deployment of a desired configuration. Moreover, differently from other proposals in the literature, our technique works even in the presence of circular dependencies among components. We give a proof for the polynomiality of the devised algorithm, thus guaranteeing efficiency and effectiveness of automatic tools for component deployment based on our algorithm.", "num_citations": "14\n", "authors": ["1944"]}
{"title": "Interface-based service composition with aggregation\n", "abstract": " Service-oriented architectures (SOAs) usually comprehend in-the- middle entities such as proxies or service mediators that compose services abstracting from the order in which they exchange messages. Although widely used, these entities are usually implemented by means of ad-hoc solutions.                 In this paper we generalise this composition mechanism by identifying the primitive notion of aggregation. We formally define the semantics of aggregation in terms of a process calculus. We also provide a reference implementation for this primitive by extending the Jolie language, thus allowing for the experimentation with real SOA scenarios.", "num_citations": "14\n", "authors": ["1944"]}
{"title": "Automatic deployment of component-based applications\n", "abstract": " In distributed systems like those based on cloud or service-oriented frameworks, applications are typically assembled by deploying and connecting a large number of heterogeneous software components, spanning from fine-grained packages to coarse-grained complex services. Automation techniques and tools have been proposed to ease the deployment process of these complex system. By relying on a formal model of components, we describe a sound and complete algorithm for computing the sequence of actions that permits the deployment of a desired configuration even in the presence of circular dependencies among components. We give a proof for the polynomiality of the devised algorithm and exploit it to develop METIS, a tool for computing deployment plans. The validation of METIS has been performed in two ways: on the one hand, by considering artificial scenarios consisting of a huge number of\u00a0\u2026", "num_citations": "13\n", "authors": ["1944"]}
{"title": "On the integration of automatic deployment into the ABS modeling language\n", "abstract": " In modern software systems, deployment is an integral and critical part of application development (see, e.g., the DevOps approach to software development). Nevertheless, deployment is usually overlooked at the modeling level, thus losing the possibility to perform deployment conscious decisions during the early stages of development. In this paper, we address the problem of promoting deployment as an integral part of modeling, by focusing on the Abstract Behavioral Specification (ABS) language used for the specification of models of systems composed of concurrent objects consuming resources provided by deployment components. We extend ABS with class annotations expressing the resource requirements of the objects of that class. Then we define a tool that, starting from a high-level declaration of the desired system, computes a model instance of such system that optimally distributes objects\u00a0\u2026", "num_citations": "13\n", "authors": ["1944"]}
{"title": "Developing correct, distributed, adaptive software\n", "abstract": " We illustrate our approach to develop and verify distributed, adaptive software systems. The cornerstone of our framework is the use of choreography languages, which allow us to obtain correctness by construction. Workflow Patterns are also used as abstract tools to design real systems, while techniques based on abstract interpretation and on dynamic verification are integrated in our framework to reduce the complexity of verification.", "num_citations": "13\n", "authors": ["1944"]}
{"title": "A constraint-based model for fast post-disaster emergency vehicle routing\n", "abstract": " Disasters like terrorist attacks, earthquakes, hurricanes, and volcano eruptions are usually unpredictable events that affect a high number of people. We propose an approach that could be used as a decision support tool for a post-disaster response that allows the assignment of victims to hospitals and organizes their transportation via emergency vehicles. By exploiting the synergy between Mixed Integer Programming and Constraint Programming techniques, we are able to compute the routing of the vehicles so as to rescue much more victims than both heuristic based and complete approaches in a very reasonable time.", "num_citations": "13\n", "authors": ["1944"]}
{"title": "Solving XCSP problems by using Gecode\n", "abstract": " Gecode is one of the most efficient libraries that can be used for constraint solving. However, using it requires dealing with C++ programming details. On the other hand several formats for representing constraint networks have been proposed. Among them, XCSP has been proposed as a format based on XML which allows us to represent constraints defined either extensionally or intensionally, permits global constraints and has been the standard format of the international competition of constraint satisfaction problems solvers. In this paper we present a plug-in for solving problems specified in XCSP by exploiting the Gecode solver. This is done by dynamically translating constraints into Gecode library calls, thus avoiding the need to interact with C++.", "num_citations": "12\n", "authors": ["1944"]}
{"title": "A classification-based approach to manage a solver portfolio for csps\n", "abstract": " The utility of using portfolios of solvers for constraint satisfaction problems is well reported. We show that when runtimes are properly clustered, simple classification techniques can be used to predict the class of runtime as, for example, short, medium, long, time-out, etc. Based on runtime classifiers we demonstrate a dispatching approach to solve a set of problem instances in order to minimize the average completion time of each instance. We show that this approach significantly out-performs a well-known CSP solver and performs well against an oracle implementation of a solver portfolio.", "num_citations": "11\n", "authors": ["1944"]}
{"title": "An extensive evaluation of portfolio approaches for constraint satisfaction problems\n", "abstract": " In the context of Constraint Programming, a portfolio approach exploits the complementary strengths of a portfolio of different constraint solvers. The goal is to predict and run the best solver(s) of the portfolio for solving a new, unseen problem. In this work we reproduce, simulate, and evaluate the performance of different portfolio approaches on extensive benchmarks of Constraint Satisfaction Problems. Empirical results clearly show the benefits of portfolio solvers in terms of both solved instances and solving time.", "num_citations": "10\n", "authors": ["1944"]}
{"title": "Why CP portfolio solvers are (under) utilized? Issues and challenges\n", "abstract": " It is well recognized that a single, arbitrarily efficient solver can be significantly outperformed by a portfolio solver exploiting a combination of possibly slower on-average different solvers. Despite the success of portfolio solvers within the context of solving competitions, they are rarely used in practice. In this paper we give an overview of the main limitations that hinder the practical adoption and development of portfolio solvers within the Constraint Programming (CP) paradigm, discussing also possible ways to overcome them and potential extensions outside the CP field.", "num_citations": "10\n", "authors": ["1944"]}
{"title": "Survival prediction of trauma patients: a study on US National Trauma Data Bank\n", "abstract": " Background                 Exceptional circumstances like major incidents or natural disasters may cause a huge number of victims that might not be immediately and simultaneously saved. In these cases it is important to define priorities avoiding to waste time and resources for not savable victims. Trauma and Injury Severity Score (TRISS) methodology is the well-known and standard system usually used by practitioners to predict the survival probability of trauma patients. However, practitioners have noted that the accuracy of TRISS predictions is unacceptable especially for severely injured patients. Thus, alternative methods should be proposed.                                               Methods                 In this work we evaluate different approaches for predicting whether a patient will survive or not according to simple and easily measurable observations. We conducted a rigorous, comparative study based on the\u00a0\u2026", "num_citations": "9\n", "authors": ["1944"]}
{"title": "A model-based scalability optimization methodology for cloud applications\n", "abstract": " Complex applications composed of many interconnected but functionally independent services or components are widely adopted and deployed on the cloud to exploit its elasticity. This allows the application to react to load changes by varying the amount of computational resources used. Deciding the proper scaling settings for a complex architecture is, however, a daunting task: many possible settings exists with big repercussions in terms of performance and cost. In this paper, we present a methodology that, by relying on modeling and automatic parameter configurators, allows to understand the best way to configure the scalability of the application to be deployed on the cloud. We exemplify the approach by using an existing service-oriented framework to dispatch car software updates.", "num_citations": "9\n", "authors": ["1944"]}
{"title": "A formal approach to microservice architecture deployment\n", "abstract": " Following previous work on the automated deployment of component-based applications, we present a formal model specifically tailored for reasoning on the deployment of microservice architectures. The first result that we present is a formal proof of decidability of the problem of synthesizing optimal deployment plans for microservice architectures, a problem which was proved to be undecidable for generic component-based applications. Then, given that such proof translates the deployment problem into a constraint satisfaction problem, we present the implementation of a tool that, by exploiting state-of-the-art constraint solvers, can be used to actually synthesize optimal deployment plans. We evaluate the applicability of our tool on a realistic microservice architecture taken from the literature.", "num_citations": "8\n", "authors": ["1944"]}
{"title": "Release the beasts: When formal methods meet real world data\n", "abstract": " It is well-known that the difference between theory and practice seems smaller in theory than in practice. From the perspective of the coordinator, the coordinated components play the role of wild beasts, fortunately imprisoned in boxes. From the perspective of the care-free semanticist, the development of tools is merely a minor step away (possibly hidden in promises of future work). This paper draws parallels between beasts and tool building by describing challenges we have encountered and sharing experiences and lesson learned when going from a compositional semantics to a well-functioning tool interacting with industrial use cases. Concretely, we discuss the development of the simulation backend for Real-Time ABS.                                        In addition to his scientific contributions, Farhad Arbab has always been an outstanding speaker with a flair for inspiring talks and memorable punchlines. This\u00a0\u2026", "num_citations": "8\n", "authors": ["1944"]}
{"title": "Decidability properties for fragments of CHR\n", "abstract": " We study the decidability of termination for two CHR dialects which, similarly to the Datalog like languages, are defined by using a signature which does not allow function symbols (of arity > 0). Both languages allow the use of the = built-in in the body of rules, thus are built on a host language that supports unification. However each imposes one further restriction. The first CHR dialect allows only range-restricted rules, that is, it does not allow the use of variables in the body or in the guard of a rule if they do not appear in the head. We show that the existence of an infinite computation is decidable for this dialect. The second dialect instead limits the number of atoms in the head of rules to one. We prove that in this case, the existence of a terminating computation is decidable. These results show that both dialects are strictly less expressive1 than Turing Machines. It is worth noting that the language (without function\u00a0\u2026", "num_citations": "7\n", "authors": ["1944"]}
{"title": "SUNNY-CP and the MiniZinc challenge\n", "abstract": " In Constraint Programming, a portfolio solver combines a variety of different constraint solvers for solving a given problem. This fairly recent approach enables to significantly boost the performance of single solvers, especially when multicore architectures are exploited. In this work, we give a brief overview of the portfolio solver sunny-cp, and we discuss its performance in the MiniZinc Challenge\u2014the annual international competition for Constraint Programming solvers\u2014where it won two gold medals in 2015 and 2016.", "num_citations": "6\n", "authors": ["1944"]}
{"title": "Feature selection for SUNNY: A study on the algorithm selection library\n", "abstract": " Given a collection of algorithms, the Algorithm Selection (AS) problem consists in identifying which of them is the best one for solving a given problem. The selection depends on a set of numerical features that characterize the problem to solve. In this paper we show the impact of feature selection techniques on the performance of the SUNNY algorithm selector, taking as reference the benchmarks of the AS library (ASlib). Results indicate that a handful of features is enough to reach similar, if not better, performance of the original SUNNY approach that uses all the available features. We also present sunny-as: a tool for using SUNNY on a generic ASlib scenario.", "num_citations": "6\n", "authors": ["1944"]}
{"title": "SUNNY for algorithm selection: a preliminary study\n", "abstract": " Given a collection of algorithms, the Algorithm Selection (AS) problem consists in identifying which of them is the best one for solving a given problem. In this paper we show how we adapted the algorithm selector SUNNY, originally tailored for constraint solving, to deal with general AS problems. Preliminary investigations based on the AS Library benchmarks already show some promising results: for some scenarios SUNNY is able to outperform AS state-of-the-art approaches.", "num_citations": "6\n", "authors": ["1944"]}
{"title": "Service-oriented volunteer computing for massively parallel constraint solving using portfolios\n", "abstract": " Recent years have witnessed growing interest in parallelising constraint solving based on tree search (see [1] for a brief overview). One approach is search-space splitting in which different parts of the tree are explored in parallel (e.g. [2]). Another approach is the use of algorithm portfolios. This technique exploits the significant variety in performance observed between different algorithms and combines them in a portfolio [3]. In constraint solving, an algorithm can be a solver or a tuning of a solver. Portfolios have often been run in an interleaving fashion (e.g. [4]). Their use in a parallel context is more recent ([5], [1]).", "num_citations": "6\n", "authors": ["1944"]}
{"title": "On the expressive power of priorities in CHR\n", "abstract": " Constraint Handling Rules (CHR) is a committed-choice declarative language which has been originally designed for writing constraint solvers and which is nowadays a general purpose language.", "num_citations": "6\n", "authors": ["1944"]}
{"title": "On the modeling of optimal and automatized cloud application deployment\n", "abstract": " We investigate the problem of modeling the optimal and automatic deployment of cloud applications. We follow an approach based on three main pillars: (i) the specification of the computing resources needed by software components and those provided by the executing environment (e.g. virtual machines or containers), (ii) the declarative description of deployment rules, (iii) and the computation of an optimal deployment that minimizes the total cost by using constraint solving techniques. We experiment with such an approach by applying it to the Abstract Behavioural Specification language ABS, and we validate it by modeling and simulating with ABS (and its tool-suite) the Fredhopper Cloud Services, a worldwide system offering e-Commerce services, currently deployed on Amazon EC2.", "num_citations": "5\n", "authors": ["1944"]}
{"title": "On the complexity of reconfiguration in systems with legacy components\n", "abstract": " In previous works we have proved that component reconfiguration in the presence of conflicts among components is non-primitive recursive, while it becomes poly-time if there are no conflicts and under the assumption that there are no components in the initial configuration. The case with non-empty initial configurations was left as an open problem, that we close in this paper by showing that, if there are legacy components that cannot be generated from scratch, the problem turns out to be PSpace-complete.", "num_citations": "5\n", "authors": ["1944"]}
{"title": "Deadlock freedom by construction for distributed adaptive applications\n", "abstract": " Proving deadlock freedom for distributed applications is complex. It becomes even harder if those applications dynamically adapt to face needs which were unexpected when the application was deployed or even started. We present a framework ensuring this key property by construction. Our framework includes a language called Adaptive Interaction-Oriented Choreography (AIOC) for programming adaptive distributed applications. Adaptation is enacted by rules, which can be defined and added while the application is running. One AIOC describes the behaviour and the interactions of multiple participants from a global viewpoint. Executable code for each participant is automatically generated from the AIOC. We prove correctness of code generation by defining labelled transition system semantics for both AIOCs and the code of the distributed participants, and proving a trace equivalence result. Deadlock freedom follows as a corollary.", "num_citations": "5\n", "authors": ["1944"]}
{"title": "Sunny with algorithm configuration\n", "abstract": " The SUNNY algorithm is a portfolio technique originally tailored for Constraint Satisfaction Problems (CSPs). SUNNY allows to select a set of solvers to be run on a given CSP, and was proven to be effective in the MiniZinc Challenge, ie, the yearly international competition for CP solvers. In 2015, SUNNY was compared with other solver selectors in the first ICON Challenge on algorithm selection with less satisfactory performance. In this paper we briefly describe the new version of the SUNNY approach for algorithm selection, that was submitted to the first Open Algorithm Selection Challenge.", "num_citations": "4\n", "authors": ["1944"]}
{"title": "Constraints meet concurrency\n", "abstract": " It is a great pleasure for me for to write this Preface for the thesis of Jacopo Mauro, for at least three reasons.The first one is the occasion for this Preface. Publishing a Ph. D. thesis in the Atlantis Studies in Computing, after having received a prize from the Italian Chapter of EATCS, is certainly a relevant achievement. Our Ph. D. school in Bologna is proud of such a result, which encourages us to continue on this path toward excellence.", "num_citations": "4\n", "authors": ["1944"]}
{"title": "Fast post-disaster emergency vehicle scheduling\n", "abstract": " Disasters like terrorist attacks, earthquakes, hurricanes, and volcano eruptions are usually unpredictable events that affect a high number of people. We propose an approach that can be used as a decision support tool for a post-disaster response that allows the assignment of victims to hospitals and organizes their transportation via emergency vehicles. Exploiting Operational Research and Constraint Programming techniques we are able to compute assignments and schedules of vehicles that save more victims than heuristic based approaches.", "num_citations": "4\n", "authors": ["1944"]}
{"title": "Graceful interruption of request-response service interactions\n", "abstract": " Bi-directional request-response interaction is a standard communication pattern in Service Oriented Computing (SOC). Such a pattern should be interrupted in case of faults. In the literature, different approaches have been considered: WS-BPEL discards the response, while Jolie waits for it in order to allow the fault handler to appropriately close the conversation with the remote service. We investigate an intermediate approach in which it is not necessary for the fault handler to wait for the response, but it is still possible on response arrival to gracefully close the conversation with the remote service.", "num_citations": "4\n", "authors": ["1944"]}
{"title": "An efficient management of correlation sets with broadcast\n", "abstract": " A fundamental aspect which affects the efficiency and the performance of Service-Oriented Architectures is the mechanism which allows to manage sessions and, in particular, to assign incoming messages to the correct sessions (also known as service instances). A relevant mechanism for solving this problem, first introduced by BPEL and then used in other languages (e.g. Jolie) is that one based on correlation sets. The BPEL and Jolie languages are currently allowing the use of messages whose target is only one session. However there are a lot of scenarios where being able to send a broadcast message to more than one session could be useful. Supporting such a broadcast primitive means to allow correlation sets which can contain unspecified variables and this can be very inefficient, since usual implementations in terms of hash tables cannot be used in this case.             In this paper we propose a\u00a0\u2026", "num_citations": "4\n", "authors": ["1944"]}
{"title": "Allocation Priority Policies for Serverless Function-Execution Scheduling Optimisation\n", "abstract": " Serverless computing is a Cloud development paradigm where developers write and compose stateless functions, abstracting from their deployment and scaling. In this paper, we address the problem of function-execution scheduling, i.e., how to schedule the execution of Serverless functions to optimise their performance against some user-defined goals. We introduce a declarative language of Allocation Priority Policies (APP) to specify policies that inform the scheduling of function execution. We present a prototypical implementation of APP as an extension of Apache OpenWhisk and we validate it by i) implementing a use case combining IoT, Edge, and Cloud Computing and ii) by comparing its performance to an alternative implementation that uses vanilla OpenWhisk.", "num_citations": "3\n", "authors": ["1944"]}
{"title": "Programming adaptive microservice applications: An AIOCJ tutorial\n", "abstract": " This tutorial describes AIOCJ, which stands for Adaptive Interaction Oriented Choreographies in Jolie, a choreographic language for programming microservice-based applications which can be updated at runtime. The compilation of a single AIOCJ program generates the whole set of distributed microservices that compose the application. Adaptation is performed using adaptation rules. Abstractly, each rule replaces a pre-delimited part of the program with the new code contained in the rule itself. Concretely, at runtime, the application of a rule updates part of the microservices that compose the application so to match the behavior specified by the updated program. Thanks to the properties of choreographies, the adaptive application is free from communication deadlocks and message races even after adaptation.", "num_citations": "3\n", "authors": ["1944"]}
{"title": "The expressive power of CHR with priorities\n", "abstract": " Constraint Handling Rules (CHR) is a committed-choice declarative language which has been originally designed for writing constraint solvers and which is nowadays a general purpose language.Recently the language has been extended by introducing user-definable (static or dynamic) rule priorities. The resulting language allows a better control over execution while retaining a declarative and flexible style of programming.In this paper we study the expressive power of this language. We first show that, in the presence of priorities, differently from the case of standard CHR, considering more than two atoms in the heads of rules does not augment the expressive power of the language. Next we show that also dynamic priorities do not augment the expressive power w.r.t. static priorities. These results are proved by providing explicitly a translation of one language into another one, which preserves a reference\u00a0\u2026", "num_citations": "3\n", "authors": ["1944"]}
{"title": "Guess Who\u2019s Coming: Runtime Inclusion of Participants in Choreographies\n", "abstract": " In Choreographic Programming, a choreography specifies in a single artefact the expected behaviour of all the participants in a distributed system. The choreography is used to synthesise correct-by-construction programs for each participant.                 In previous work, we defined Dynamic Choreographies to support the update of distributed systems at runtime.                 In this work, we extend Dynamic Choreographies to include new participants at runtime, capturing those use cases where the system might be updated to interact with new, unforeseen stakeholders. We formalise our extension, prove its correctness, and present an implementation in the AIOCJ choreographic framework.", "num_citations": "2\n", "authors": ["1944"]}
{"title": "Parallelizing constraint solvers for hard RCPSP instances\n", "abstract": " The Resource-Constrained Project Scheduling Problem (RCPSP) is a well-known scheduling problem aimed at minimizing the makespan of a project subject to temporal and resource constraints. In this paper we show that hard RCPSPs can be efficiently tackled by a portfolio approach that combines the strengths of different constraint solvers Our approach seeks to predict and run in parallel the best solvers for a new, unseen RCPSP instance by enabling the bound communication between them. This on-average allows to outperform the oracle solver that always chooses the best available solver for any given instance.", "num_citations": "2\n", "authors": ["1944"]}
{"title": "Adaptive choreographies\n", "abstract": " We present a framework for rule-based adaptation of distributed interacting systems ensuring that adaptation of single participants is coordinated, and that the behavior of the resulting system follows an abstract (adaptive) description. In particular, we are able to guarantee that the distributed adaptive system is deadlock-free under all possible adaptations. Our approach relies on the theory of projection of a global choreography onto single participants.", "num_citations": "2\n", "authors": ["1944"]}
{"title": "A language for (smart) service aggregation: Theory and practice of interface-based service composition\n", "abstract": " Service-oriented computing is a paradigm for programming distributed systems by composing services. In this paper we focus on aggregation, a behaviour-transparent mechanism for composing services that abstracts from the order of their communications. Aggregation is widely used in practice. However, since it is not natively supported by service-oriented languages, it is mostly implemented by means of ad-hoc solutions which typically exploit middleware technology. This leads to a variety of tools which must be used in order to aggregate services at different levels. In this work we investigate the basic linguistic constructs for service aggregation. We propose a formal calculus equipped with primitives for aggregation based on interfaces and a reference implementation.", "num_citations": "2\n", "authors": ["1944"]}
{"title": "sunny-as2: Enhancing SUNNY for Algorithm Selection\n", "abstract": " SUNNY is an Algorithm Selection (AS) technique originally tailored for Constraint Programming (CP). SUNNY is based on the k-nearest neighbors algorithm and enables one to schedule, from a portfolio of solvers, a subset of solvers to be run on a given CP problem. This approach has proved to be effective for CP problems.", "num_citations": "1\n", "authors": ["1944"]}
{"title": "Microservice Dynamic Architecture-Level Deployment Orchestration\n", "abstract": " We develop a novel approach for run-time global adaptation of microservice applications, based on synthesis of architecture-level reconfiguration orchestrations. More precisely, we devise an algorithm for automatic reconfiguration that reaches a target system Maximum Computational Load by performing optimal deployment orchestrations. To conceive and simulate our approach, we introduce a novel integrated timed architectural modeling/execution language based on an extension of the actor-based object-oriented Abstract Behavioral Specification (ABS) language. In particular, we realize a timed extension of SmartDeployer, whose ABS code annotations make it possible to express architectural properties. Our Timed SmartDeployer tool fully integrates time features of ABS and architectural annotations by generating timed deployment orchestrations. We evaluate the applicability of our approach on a\u00a0\u2026", "num_citations": "1\n", "authors": ["1944"]}
{"title": "Anomaly detection in Context-aware Feature Models\n", "abstract": " Feature Models are a mechanism to organize the configuration space and facilitate the construction of software variants by describing configuration options using features, ie, a name representing a functionality. The development of Feature Models is an error prone activity and detecting their anomalies is a challenging and important task needed to promote their usage.", "num_citations": "1\n", "authors": ["1944"]}
{"title": "NightSplitter: a scheduling tool to optimize (sub) group activities\n", "abstract": " Humans are social animals and usually organize activities in groups. However, they are often willing to split temporarily a bigger group in subgroups to enhance their preferences. In this work we present NightSplitter, an on-line tool that is able to plan movie and dinner activities for a group of users, possibly splitting them in subgroups to optimally satisfy their preferences. We first model and prove that this problem is NP-complete. We then use Constraint Programming (CP) or alternatively Simulated Annealing (SA) to solve it. Empirical results show the feasibility of the approach even for big cities where hundreds of users can select among hundreds of movies and thousand of restaurants.", "num_citations": "1\n", "authors": ["1944"]}
{"title": "Service integration via target-transparent mediation\n", "abstract": " In the context of Service-Oriented Architectures (SOAs), the integration of services is an important aspect that is usually addressed by using specific tools, such as Enterprise Service Bus (ESB). In this paper we propose a framework to perform service integration building on the extension of service interfaces, capturing a class of service integrators that are decoupled from the services they integrate in an SOA. We show how our service integrators can be used in practice by evaluating our approach with Jolie, a service-oriented programming language. Finally, we present how our methodology differs from the standard practice with ESB.", "num_citations": "1\n", "authors": ["1944"]}
{"title": "Nutella: US vs Europe\n", "abstract": " Since the dawn of time (or at least since the invention of Nutella) the human kind has strived for the hamletic question \u201cCan human distinguish different version of Nutella sold in different countries.\u201d In this paper we present a simple empirical experiment to shed some light on this important and vital question. Empirical evidence seems to indicate that the Nutella sold in the US can be distinguish from the one sold in Europe. Further investigations are however needed to confirm the statistical significance of the claim.", "num_citations": "1\n", "authors": ["1944"]}