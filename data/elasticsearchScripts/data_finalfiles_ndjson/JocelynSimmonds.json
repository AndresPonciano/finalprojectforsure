{"title": "A tool for automatic UML model consistency checking\n", "abstract": " Automated consistency checking of UML models becomes necessary as models grow in size and complexity. Because the UML metamodel does not enforce model consistency, there are no guidelines as how to approach the consistency problem. Current solutions are partial and tools are mostly of academic nature. The translation of the metamodel and the user designed model into Description Logics has proved to be useful in detecting a large set of inconsistencies. We present MCC, a UML model consistency checker, built as a plug-in for Poseidon for UML, and relying on Racer as a reasoning engine. We propose a usable and scalable solution, interoperable with a known modeling tool.", "num_citations": "40\n", "authors": ["1408"]}
{"title": "Software product line evolution: A systematic literature review\n", "abstract": " Context: Software Product Lines (SPL) evolve when there are changes in the requirements, product structure or the technology being used. Different approaches have been proposed for managing SPL assets and some also address how evolution affects these assets. Existing mapping studies have focused on specific aspects of SPL evolution, but there is no cohesive body of work that gives an overview of the area as a whole.Objective: The goals of this work are to review the characteristics of the approaches reported as supporting SPL evolution, and to synthesize the evidence provided by primary studies about the nature of their processes, as well as how they are reported and validated.Method: We conducted a systematic literature review, considering six research questions formulated to evaluate evolution approaches for SPL. We considered journal, conference and workshop papers published up until March\u00a0\u2026", "num_citations": "38\n", "authors": ["1408"]}
{"title": "Consistency maintenance of UML models with description logics\n", "abstract": " Nowadays, the prevailing methodology used to specify software designs is UML. This language consists of various types of diagrams, each one dedicated to a different design aspect. This variety of views, that overlap with respect to the information depicted in each, can leave the overall system design specification in an inconsistent state. Necessarily, some form of consistency checking must be performed between different UML models. This is especially true in the context of design evolution. Therefore, a means of detecting and solving inconsistencies between related UML models must be provided. With respect to UML models, two types of consistency can be noted: consistency between models belonging to the same design version and consistency between different versions of the same model. These are known as horizontal and evolution consistency, respectively. Current UML CASE tools do not take full advantage of the relationships that exist between the different UML model elements, and, as such, provide poor support for maintaining consistency between (evolving) UML models. By specifying consistency relationships in a formal and precise way, reasoning about model", "num_citations": "35\n", "authors": ["1408"]}
{"title": "Description logics for consistency checking of architectural features in UML 2.0 models\n", "abstract": " UML has become the de facto standard language for software modeling. Although it was first created as a language for documenting detailed object-oriented designs, its newest version-UML 2.0-introduced new features for documenting software architectures as part of the standard. Models in UML include a series of diagrams that describe different views of the system, and even though the standard does not enforce consistency, good software engineering practices do. MCC is a tool based on description logics for UML model checking. In this paper we present how MCC can be used for reasoning about the consistency of UML models and how it can be extended so that it can also deal with UML 2.0 new architectural features following the same strategy.", "num_citations": "30\n", "authors": ["1408"]}
{"title": "MDE software process lines in small companies\n", "abstract": " Software organizations specify their software processes so that process knowledge can be systematically reused across projects. However, different projects may require different processes. Defining a separate process for each potential project context is expensive and error-prone, since these processes must simultaneously evolve in a consistent manner. Moreover, an organization cannot envision all possible project contexts in advance because several variables may be involved, and these may also be combined in different ways. This problem is even worse in small companies since they usually cannot afford to define more than one process. Software process lines are a specific type of software product lines, in the software process domain. A benefit of software process lines is that they allow software process customization with respect to a context. In this article we propose a model-driven approach for software\u00a0\u2026", "num_citations": "29\n", "authors": ["1408"]}
{"title": "Modeling variability in software process lines\n", "abstract": " Software process lines (SPrL) are families of related processes, built from a set of administrated software process elements in a prestablished fashion, similar to how software product lines (SPL) are built with software assets. In SPLs, variability is usually specified using feature models. As SPrLs manage particular kinds of process elements, namely tasks, roles and work products, we explore the feasibility and applicability of feature and orthogonal variability models for specifying variability in SPrLs. In this paper, we present the kinds of variabilities that are relevant in the context of SPrLs and we show how they may be specified with feature models and orthogonal variability models. We use use a simple requirements engineering process as a means for illustrating each issue.", "num_citations": "18\n", "authors": ["1408"]}
{"title": "Dynamic analysis of web services\n", "abstract": " Recent years have seen an emergence of service-oriented applications, where applications are created using existing services. Companies with large legacy back-end systems, like Deutsche Post AG and Credit Suisse, have used this approach to modernize existing infrastructure, repackaging legacy applications as services, leading to an overall reduction in maintenance costs [58]. On the other hand, Web 2.0 companies like Google and Amazon offer services that grant access to data that was (possibly) expensive to collect, allowing 3rd party developers to create new applications using this data. These services are commonly referred to as web services, as they are usually available via the web. As the individual services are developed on a wide variety of platforms, there is a need for a flexible architecture that standardizes how these services interact. The Service-Oriented Architecture (SOA) is such an architecture. Partners develop services and make them available by publishing service interfaces. Web services can be written in a traditional compiled language such as JavaTM, or in an XML-centric language such as BPEL [76], in which predefined activities are used to specify executable workflows. Web service applications are created by specifying how these partner services interact", "num_citations": "17\n", "authors": ["1408"]}
{"title": "Assessing software development skills among K-6 learners in a project-based workshop with scratch\n", "abstract": " Recent literature reports a fair amount of initiatives on how to engage younger populations in achieving computational literacy. However, there is considerable less research on how to effectively deliver software development skills in a way that can be accepted and ultimately adopted by this user group. As a way to bridge this gap, we ran an extracurricular project-based workshop, targeting 10-12 years old learners with no prior coding experience, delivered over five days in the computer labs at the University of Chile. In this workshop, participants follow hands-on activities where they acquire the basics of computer programming and develop a small-scale software application using Scratch. These activities showcase that good software engineering practices can be taught to K-6 students, where these students are guided by experienced computer science undergraduate and graduate students. This paper presents a\u00a0\u2026", "num_citations": "15\n", "authors": ["1408"]}
{"title": "Affirmative action for attracting women to STEM in Chile\n", "abstract": " Women are currently almost half of the work force in Chile, but very few of them work in the software industry. In part, this is because there are strong cultural stereotypes about what careers are\" for men\" in Chile. This idea has been further cemented by the standardized admissions process used by Chilean universities, where female mathematics scores have historically been lower than that of their male peers. In order to break these stereotypes and attract more women into STEM careers, the Faculty of Mathematical and Physical Sciences at the University of Chile has created the Gender Equality Admissions Program (PEG, for its name in Spanish, Programa de Ingreso Prioritario de Equidad de G\u00e9nera) in 2013. Under this program, 40 extra women are selected into the most competitive engineering and science program in the country. In the five years that the PEG has been in place, the number of women accepted\u00a0\u2026", "num_citations": "14\n", "authors": ["1408"]}
{"title": "Semi-automated tool recommender for software development processes\n", "abstract": " Application life-cycle management (ALM) tools are key for streamlining software development processes. However, small and medium development companies (SMBs) cannot afford to carry out time- and people-intensive tool evaluations for each project, and instead adopt fixed toolsets, thus losing flexibility. To simplify the tool selection process, this article proposes formalizing tool selection as a set of Multiple-Criteria Decision-Making (MCDM) problem, one for each ALM domain. Our domain-parametric recommender takes as inputs a domain, a process definition, and a set of tool evaluation criteria, and yields a ranked list of tools. The approach has been prototyped with the Testing domain and evaluated using a real process and project; the recommendations generated by our approach were quite similar to those of three Testing experts. Pending further evaluation, these results suggest that our approach can\u00a0\u2026", "num_citations": "14\n", "authors": ["1408"]}
{"title": "A tool based on DL for UML model consistency checking\n", "abstract": " Automated consistency checking of UML models becomes necessary as models grow in size and complexity. Since the UML metamodel does not enforce model consistency, there are no fixed guidelines on how to approach the consistency problem. Current solutions are generally partial. The translation of the metamodel and the user designed model into Description Logics has proved to provide a solution in detecting a large set of inconsistencies. In order to make this solution available to system designers, we have implemented MCC+, a UML model consistency checker, built as a plug-in for Poseidon for UML, and relying on Jena as a reasoning engine. Compared to other approaches, we propose a usable and scalable solution, interoperable with a known modeling tool. We show the application of MCC+ to a real world large example of a meshing tool.", "num_citations": "13\n", "authors": ["1408"]}
{"title": "Coding or hacking? Exploring inaccurate views on computing and computer scientists among K-6 learners in Chile\n", "abstract": " Advancing computational thinking in elementary education has been rapidly gaining attention due to the prospective of developing 21st century skills. However, interventions in this domain risk failure if they do not explicitly address the particular socio-cultural traits of the deployment scenario. This is the case in most countries of Latin America, where computing has not reached a sustainable penetration in K-12 education. In order to bridge this gap, we designed a one-week workshop for advancing computational thinking targeted to 10-12 years old Chilean students with no prior experience in programming. This paper describes our intervention and presents the results of a qualitative study analyzing positive and negative aspects of the experience. Although most participants effectively acquired basic programming skills by the end of the intervention, we also identified several inaccurate views on computing and\u00a0\u2026", "num_citations": "11\n", "authors": ["1408"]}
{"title": "BehaviorDroid: monitoring Android applications\n", "abstract": " Mobile app developers declare permissions, but these do not guarantee that apps will behave as expected. Existing work focuses on checking predefined app properties, eg, clone detection and API analysis. We propose BehaviorDroid, a framework for monitoring general app properties at runtime. Properties are currently specified using automata, describing desired and unwanted interactions between an app and phone resources. BehaviorDroid is a robust, extensible and configurable framework that can simultaneously monitor multiple apps and properties, showing reasonable CPU and memory usage during execution. Initial experiments show that we can improve memory usage by combining automata that have similar alphabets.", "num_citations": "9\n", "authors": ["1408"]}
{"title": "Gender differences in self and peer assessment in a software engineering capstone course\n", "abstract": " Context: Women are generally underrepresented in software development and probably their behavior is biased by the fact that they are usually a minority within teams. The Engineering School at the Universidad de Chile has put in practice a strong women recruitment program. This brought that, for the first time, women reached 20% of the students enrolled in the fifth year software engineering capstone course. Problem: More women are entering the work force but there is still certain prejudice about women performance in STEM in general, and in software development in particular, since it is perceived as a man's activity. Method: In the context of the fifth year capstone course at the CS Department of the Universidad de Chile we conducted a field study in order to analyze the progression of self and peer assessment of men and women students along one semester. Results: We found that, even though peer\u00a0\u2026", "num_citations": "6\n", "authors": ["1408"]}
{"title": "A teacher workshop for introducing computational thinking in rural and vulnerable environments\n", "abstract": " In Latin America, computational thinking workshops are mostly developed in urban areas, charging participation fees. And although teachers are increasingly being expected to include technology in their classrooms, computational thinking and programming are not mandatory topics in teacher training programs. This hinders the development of digital skills among Latino students, and we expect that the digital gap between urban and rural populations will expand over time, especially in socio-economically vulnerable populations. Believing that teachers can be agents of change, we designed a 12 hour workshop to train the K-8 teaching staff in a rural and vulnerable school. The goal of this experience was to help these teachers develop basic computational thinking skills and devise new ways to incorporate what they learned in their classrooms. In this paper, we report our experience facilitating this workshop, and\u00a0\u2026", "num_citations": "6\n", "authors": ["1408"]}
{"title": "Software process line discovery\n", "abstract": " Companies define software processes for planning and guiding projects. Since process definition is expensive, and in practice, no one process\" fits all\" projects, the current trend is to define a Software Process Line (SPrL): a base process that represents the common process elements, along with its potential variability. Specifying a SPrL is more expensive than just specifying one process, but the SPrL can be adapted to specific project contexts, minimizing the amount of extra work carried out by employees. Mining project logs has proven to be a promising approach for discovering the process that is applied in practice. However, considering all the possible variations that may be logged, the mined process may be overly complex. Some algorithms deal with this by filtering infrequent relations between log events, but they may discard relevant relations. In this paper we propose the v-algorithm that uses two thresholds\u00a0\u2026", "num_citations": "6\n", "authors": ["1408"]}
{"title": "Spin lock killed the performance star\n", "abstract": " The Internet has grown quite quickly, requiring more and more processing power each year to handle user requests in a timely fashion. In the multicore world, the addition of server-side threads should help improve server performance. However, several studies have shown that this is not true, identifying the Linux kernel as the possible culprit. Our working hypothesis is that the kernel does not provide a scalable interface for network communications. Through various tests, we narrowed the problem down to the implementation of the spin lock mechanism (a synchronization structure used mostly at the kernel level), which has been inherited from early versions of the Linux kernel. It is only now, with the emergence of multicore architectures, that users have begun to notice the performance hit that the existing spin lock implementation has on parallel systems, especially in multithreaded network protocols. Thus, our\u00a0\u2026", "num_citations": "5\n", "authors": ["1408"]}
{"title": "The v\u2010algorithm for discovering software process lines\n", "abstract": " A software company can define a software process line (SPrL) to deal with projects with different characteristics. This entails defining a base process and its variation points; the SPrL is then tailored to each project. This approach avoids the co\u2010evolution problems but is expensive to set up. In companies that register project events, this information could be used to discover the SPrL. However, traditional discovery algorithms focus on extracting a single process, which can be overly complex and would not be useful for managing future projects. Filtering out less frequent behavior leads to the discovery of simpler models, but these may not include relevant behavior. To address these issues, we propose the v\u2010algorithm, which discovers a SPrL from process logs. Two thresholds split the log into three clusters based on relation frequency. The first one is used to generate the base process, the second one is used to\u00a0\u2026", "num_citations": "3\n", "authors": ["1408"]}
{"title": "Software engineering for millennials, by millennials\n", "abstract": " Software engineers need to manage both technical and professional skills in order to be successful. Our university offers a 5.5 year program that mixes computer science, software and computer engineering, where the first two years are mostly math and physics courses. As such, our students' first real teamwork experience is during the introductory SE course, where they modify open source projects in groups of 6-8. However, students have problems working in such large teams, and feel that the course material and project are\" disconnected\". We decided to redesign this course in 2017, trying to achieve a balance between theory and practice, and technical and professional skills, with a maximum course workload of 150 hrs per semester. We share our experience in this paper, discussing the strategies we used to improve teamwork and help students learn new technologies in a more autonomous manner. We also\u00a0\u2026", "num_citations": "2\n", "authors": ["1408"]}
{"title": "\u201cTeaching is learning\u201d: Pedagogical material created and evaluated by students\n", "abstract": " The action of teaching reinforces one's learning but requires some external quality control when done by nonprofessionals (e.g., a professor supervising teaching assistants). This quality control is costly and has limited the adoption of peer teaching in schools. Our solution to this problem is to ask students to create pedagogical material that will then be evaluated by the students themselves, where they evaluate a mix of new and already rated materials. One advantage of this technique is that it allows students to develop critical thinking skills, since they must judge if the presented material adequately covers a specific topic. We describe the \u201cTeaching is Learning\u201d project, that implements these ideas. We first discuss two pilot studies: 1) since 2009, engineering students from the University of Chile have been creating and validating pedagogical 3D animations; and 2) during 2015, seventh graders from the Blest Gana\u00a0\u2026", "num_citations": "2\n", "authors": ["1408"]}
{"title": "Formal verification of distributed system using an executable C model\n", "abstract": " Formal verification means to rigorously explore the correctness of system designs expressed as mathematical models, most likely with the assistance of modern computers. Original approaches were to model and express a distributed system using existing theoretical tools such as Petri Nets. Nevertheless the main problems of such approaches are the restrictions imposed by formal tools and the human factor of simplify and model a distributed system. We propose a way to do formal verification of a distributed system by modeling the communication of the system as a concurrent program, instantiating the distributed system using threads and atomic queues and testing/verifying directly to the source code with specialized verifiers for concurrent programs. As an example, we show the verification of a distributed threshold signer using CBMC verifying properties such as memory leaks, index out of bounds, and data races.", "num_citations": "2\n", "authors": ["1408"]}
{"title": "Mobile application monitoring\n", "abstract": " To date, there are more than 800.000 applications available on each of the two largest mobile application markets (Google Play and Apple App Store), each reporting around 40 billion downloads in total. At this scale, it is impossible to analyze each application for malware behavior before making them available for download. Vendors mostly rely on user feedback to remove malware from their marketplaces, so it can take a while for these applications to be removed. In practice, users must be very careful when picking which applications to install. Moreover, it can be hard to detect a malware application once it is installed, unless the application has noticeable side-effects. To improve this situation, we propose a framework for performing runtime monitoring of mobile applications against behavioral correctness properties. These properties specify forbidden and desired interactions between applications and the phone\u00a0\u2026", "num_citations": "2\n", "authors": ["1408"]}
{"title": "Impact of Affirmative Action on Female Computer Science/Software Engineering Undergraduate Enrollment\n", "abstract": " Affirmative action in college admissions has been touted as a way to close the gender gap in science, technology, engineering, and mathematics programs. We report a study of one such program, where we discovered a positive effect on female enrollment and a smaller effect on a combined computer science and software engineering degree.", "num_citations": "1\n", "authors": ["1408"]}
{"title": "Software product line evolution: A systematic literature review\n", "abstract": " Context: Software Product Lines (SPL) evolve when there are changes in the requirements, product structure or the technology being used. Different approaches have been proposed for managing SPL assets and some also address how evolution affects these assets. Existing mapping studies have focused on specific aspects of SPL evolution, but there is no cohesive body of work that gives an overview of the area as a whole. Objective: The goals of this work are to review the characteristics of the approaches reported as supporting SPL evolution, and to synthesize the evidence provided by primary studies about the nature of their processes, as well as how they are reported and validated. Method: We conducted a systematic literature review, considering six research questions formulated to evaluate evolution approaches for SPL. We considered journal, conference and workshop papers published up until March 2017 in leading digital libraries for computer science. Results: After a thorough analysis of the papers retrieved from the digital libraries, we ended up with a set of 60 primary studies. Feature models are widely used to represent SPLs, so feature evolution is frequently addressed. Other assets are less frequently addressed. The area has matured over time: papers presenting more rigorous work are becoming more common. The processes used to support SPL evolution are systematic, but with a low level of automation. Conclusions: Our research shows that there is no consensus about SPL formalization, what assets can evolve, nor how and when these evolve. Case studies are quite popular, but few industrial-sized case studies are\u00a0\u2026", "num_citations": "1\n", "authors": ["1408"]}