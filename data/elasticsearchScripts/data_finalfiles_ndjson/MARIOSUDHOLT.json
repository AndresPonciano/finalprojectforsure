{"title": "Composition, reuse and interaction analysis of stateful aspects\n", "abstract": " Aspect-Oriented Programming promises separation of concerns at the implementation level. However, aspects are not always orrthogonal and aspect interaction is a fundamental problem. In this paper, we extend previous work on a generic framework for the formal definition and interaction analysis of stateful aspects. We propose three important extensions which enhance expressivity while preserving static analyzability of interactions. First, we provide support for variables in aspects in order to share information between different execution points. This allows the definition of more precise aspects and to avoid detection of spurious conflicts. Second, we introduce generic composition operators for aspects. This enables us to provide expressive support for the resolution of conflicts among interacting aspects. Finally, we offer a means to define applicability conditions for aspects. This makes interaction analysis more\u00a0\u2026", "num_citations": "298\n", "authors": ["364"]}
{"title": "A framework for the detection and resolution of aspect interactions\n", "abstract": " Aspect-Oriented Programming (AOP) promises separation of concerns at the implementation level. However, aspects are not always orthogonal and aspect interaction is an important problem. Currently there is almost no support for the detection and resolution of such interactions. The programmer is responsible for identifying interactions between conflicting aspects and implementing conflict resolution code. In this paper, we propose a solution to this problem based on a generic framework for AOP. The contributions are threefold: we present a formal and expressive crosscut language, two static conflict analyses and some linguistic support for conflict resolution.", "num_citations": "264\n", "authors": ["364"]}
{"title": "A formal definition of crosscuts\n", "abstract": " Crosscutting,i.e.relating different program points is one of the key notions of Aspect-Oriented Programming.In this article,we consider a general and operational model for crosscutting based on excusion monitors.               A domain-specific language for definition of crosscuts constitutes the core of the article.The semantics of this language is formally defined by means of parser operators matching event patterns in execution traces. We define an operational semantics of the matching process by means of rules relating the operators.The use of the language is exemplified by several sophisticated crosscut definitions.we sketch a prototype implementation in Java which has been systematically derived from the language definition.", "num_citations": "214\n", "authors": ["364"]}
{"title": "Explicitly distributed AOP using AWED\n", "abstract": " Distribution-related concerns, such as data replication, often crosscut the business code of a distributed application. Currently such crosscutting concerns are frequently realized on top of distributed frameworks, such as EJBs, and initial AO support for the modularization of such crosscutting concerns, eg, JBoss AOP and Spring AOP, has been proposed. Based on an investigation of the implementation of replicated caches using JBoss Cache, we motivate that crosscutting concerns of distributed applications benefit from an aspect language for explicit distributed programming. We propose AWED, a new aspect language with explicit distributed programming mechanisms, which provides three contributions. First, remote pointcut constructors which are more general than those of previous related approaches, in particular, supporting remote sequences. Second, a notion of distributed advice with support for\u00a0\u2026", "num_citations": "158\n", "authors": ["364"]}
{"title": "An expressive aspect language for system applications with Arachne\n", "abstract": " Security, networking and prefetching are typical examples of concerns which crosscut system-level C applications. While a careful design can help to address these concerns, they frequently become an issue at runtime, especially if avoiding server downtime is important. Vulnerabilities caused by buffer overflows and double-free bugs are frequently discovered after deployment, thus opening critical breaches in running applications. Performance issues also often arise at run time: in the case of Web caches, e.g., a prefetching strategy may be required to increase performance. Aspect-oriented programming is an appealing solution to solve these issues. However, none of the current dynamic aspect systems is expressive and efficient enough to support them properly in the context of C applications. Arachne is a new aspect system specifically designed to address these issues. Its aspect language allows\u00a0\u2026", "num_citations": "133\n", "authors": ["364"]}
{"title": "Trace-based aspects\n", "abstract": " More concretely, we first present an expressive model of trace-based aspects enabling proofs of aspect properties by equational reasoning. Using a restriction of the aspect language to regular expressions, we address the difficult problem of interactions between conflicting aspects. Finally, by restricting the actions performed by aspects, we illustrate how to keep the semantic impact of aspects under control and to implement weaving statically.", "num_citations": "88\n", "authors": ["364"]}
{"title": "A model and a tool for event-based aspect-oriented programming (EAOP)\n", "abstract": " Aspect-oriented programming promises support for incremental program development by providing new means for modularization of crosscutting code. In this paper, we briefly introduce a general model for aspect-oriented programming, Event-Based AOP (first introduced in [DMS01a]), which is based on monitoring of execution events. This model extends previous approaches by enabling the systematic treatment of relationships between execution points, supporting operators for aspect composition, and allowing the application of aspects to other aspects. Moreover, we present a tool which implements the model for Java.", "num_citations": "80\n", "authors": ["364"]}
{"title": "StrongAspectJ: flexible and safe pointcut/advice bindings\n", "abstract": " AspectJ was designed as a seamless aspect-oriented extension of the Java programming language. However, unlike Java, AspectJ does not have a safe type system: an accepted binding between a pointcut and an advice can give rise to type errors at runtime. In addition, AspectJ's typing rules severely restrict the definition of certain generic advice behavior.", "num_citations": "68\n", "authors": ["364"]}
{"title": "Concurrent aspects\n", "abstract": " Aspect-Oriented Programming (AOP) promises the modularization of so-called crosscutting functionalities in large applications. Currently, almost all approaches to AOP provide means for the description of sequential aspects that are to be applied to a sequential base program. In particular, there is no formally-defined concurrent approach to AOP, with the result that coordination issues between aspects and base programs as well as between aspects cannot precisely be investigated. This paper presents Concurrent Event-based AOP (CEAOP), which addresses this issue. Our contribution can be detailed as follows. First, we formally define a model for concurrent aspects which extends the sequential Event-based AOP approach. The definition is given as a translation into concurrent specifications using Finite Sequential Processes (FSP), thus enabling use of the Labelled Transition System Analyzer (LTSA) for formal\u00a0\u2026", "num_citations": "58\n", "authors": ["364"]}
{"title": "Towards a generic framework for AOP\n", "abstract": " During the 1st workshop on AOP [AOP97] several fundamental questions were raised: What exactly are aspects? How to weave? What are the join points used to anchor aspects into the component program? Is there a general purpose aspect language? In this position paper, we address these questions for a particular class of aspects: aspects expressible as static, source-to-source program transformations. An aspect is defined as a collection of program transformations acting on the abstract syntax tree of the component program.We discuss the design of a generic framework to express these transformations as well as a generic weaver. The coupling of component and aspect definitions can be defined formally using operators matching subtrees of the component program. The aspect weaver is simply a fixpoint operator taking as parameters the component program and a set of program transformations. In\u00a0\u2026", "num_citations": "56\n", "authors": ["364"]}
{"title": "Aspect-oriented software development in practice: Tales from aosd-europe\n", "abstract": " Aspect-oriented software development techniques provide a means to modularize crosscutting concerns in software systems. A survey of industrial projects reveals the benefits and potential pitfalls of aspectoriented technologies.The past decade has seen the increased use of aspect-oriented software development (AOSD) technique as a means to modularize crosscutting concerns in software systems, thereby improving a development organization's working practices and return on investment (ROI). Numerous industrial-strength aspect-oriented (AO) programming frameworks exist, including AspectJ, JBoss, and Spring, as do various aspect-oriented analysis and design techniques.The software systems using AOSD that we have studied are medium to large-scale and span a wide range of domains including enterprise systems, e-health, e-transport, telecommunications, Web based information systems, multimedia\u00a0\u2026", "num_citations": "54\n", "authors": ["364"]}
{"title": "Cooperative and reactive scheduling in large\u2010scale virtualized platforms with DVMS\n", "abstract": " One of the principal goals of cloud computing is the outsourcing of the hosting of data and applications, thus enabling a per\u2010usage model of computation. Data and applications may be packaged in virtual machines (VM), which are themselves hosted by nodes, that is, physical machines. Several frameworks have been designed to manage VMs on pools of physical machines; most of them, however, do not efficiently address a major objective of cloud providers: maximizing system utilization while ensuring the QoS. Several approaches promote virtualization capabilities to improve this trade\u2010off. However, the dynamic scheduling of a large number of VMs as part of a large distributed infrastructure is subject to important and hard scalability problems that become even worse when VM image transfers have to be managed. Consequently, most current frameworks schedule VMs statically using a centralized control\u00a0\u2026", "num_citations": "45\n", "authors": ["364"]}
{"title": "Cache-based side-channel attacks detection through intel cache monitoring technology and hardware performance counters\n", "abstract": " Research on cache-based side-channel attacks shows the security impact of these attacks on cloud computing. Therefore, the detection of cache-based side-channel attacks has received more attention in IaaS cloud infrastructures because of improvements in the attack techniques. However, such detection requires high resolution information, and it is also a challenging task because of the fine-granularity of the attacks. In this paper, we present an approach to detect cross-VM cache-based side-channel attacks through using hardware fine-grained information provided by Intel Cache Monitoring Technology (CMT) and Hardware Performance Counters (HPCs) following the Gaussian anomaly detection method. The approach shows a high detection rate with 2% performance overhead on the computing platform.", "num_citations": "40\n", "authors": ["364"]}
{"title": "Debugging and testing middleware with aspect-based control-flow and causal patterns\n", "abstract": " Many tasks that involve the dynamic manipulation of middleware and large-scale distributed applications, such as debugging and testing, require the monitoring of intricate relationships of execution events that trigger modifications to the executing system. Furthermore, events often are of interest only if they occur as part of specific execution traces and not all possible non-deterministic interleavings of events in these traces. Current techniques and tools for the definition of such manipulations provide only very limited support for such event relationships and do not allow to concisely define restrictions on the interleaving of events.               In this paper, we argue for the use of aspect-based high-level programming abstractions for the definition of relationships between execution events of distributed systems and the control of non-deterministic interleavings of events. Concretely, we provide the following\u00a0\u2026", "num_citations": "39\n", "authors": ["364"]}
{"title": "On components with explicit protocols satisfying a notion of correctness by construction\n", "abstract": " Component-based programming, which promises to facilitate the construction of large-scale applications, relies to a large degree on interfaces. Interfaces on most component models only declare types and sets of services that components implement, and are not expressive enough to formulate structural and behavioral properties of components. In this paper we show how to integrate one important class of behavioral properties: constraints on the sequentialization of services.We are interested in operators for the construction of components, satisfying a correctness property, allowing a component to be substituted by another one.We define a set of protocol composition operators satisfying the correctness property, we provide a first step toward the integration of additional abstract state information into protocols, and we apply our theory to two widely-used component models: JavaBeans and Enterprise\u00a0\u2026", "num_citations": "36\n", "authors": ["364"]}
{"title": "Expressive scoping of distributed aspects\n", "abstract": " Dynamic deployment of aspects brings greater flexibility and reuse potential, but requires proper means for scoping aspects. Scoping issues are particularly crucial in a distributed context: adequate treatment of distributed scoping is necessary to enable the propagation of aspect instances across host boundaries and to avoid inconsistencies due to unintentional spreading of data and computations in a distributed system.", "num_citations": "30\n", "authors": ["364"]}
{"title": "A generic reification technique for object-oriented reflective languages\n", "abstract": " Computational reflection is gaining interest in practical applications as witnessed by the use of reflection in the Java programming environment and recent work on reflective middleware. Reflective systems offer many different reflection programming interfaces, the so-called Meta-Object Protocols (MOPs). Their design is subject to a number of constraints relating to, among others, expressive power, efficiency and security properties. Since these constraints are different from one application to another, it would be desirable to easily provide specially-tailored MOPs.               In this paper, we present a generic reification technique based on program transformation. It enables the selective reification of arbitrary parts of object-oriented meta-circular interpreters. The reification process is of fine granularity: individual objects of the run-time system can be reified independently. Furthermore, the program transformation\u00a0\u2026", "num_citations": "27\n", "authors": ["364"]}
{"title": "An aspect language for robust programming\n", "abstract": " Robust programs should satisfy two basic conditions. First, compute well-defined output values from well-defined sets of input values, henceforth called the program's standard domain. Second, input values from the complement of the standard domain, henceforth called the program's exceptional domain, should result in well-defined error situations. Most real programs, however, are not robust. While the first condition is the subject of almost all programming methodologies and most programming efforts, the second is violated in most non-trivial programs which often yield incorrect results once an erroneous situation has appeared. Worse, the incorrect results are frequently not recognized as such, for instance, because they approximate correct values quite well or they are immediately used in subsequent computations. In this position paper, we advocate the use of an aspect language for robust programming. AOP is particularly appealing for this task because robustness crosscuts traditional structuring means. Consider, for instance, the problem of ensuring that a global index remains in a given range. The code needed to check such an invariant is typically scattered all over the program. The paper is structured as follows: Section 2 presents an example-driven introduction of the proposed aspect language for program robustness; Section 3 discusses its semantics and implementation; Section 4 suggests extensions and concludes.", "num_citations": "27\n", "authors": ["364"]}
{"title": "Securing car2X applications with effective hardware software codesign for vehicular on-board networks\n", "abstract": " In the scope of the EVITA project, we present an approach to secure the vehicular on-board communication architecture. Computing devices range from simple low-cost sensor control units on low-speed buses to costly multimedia units on high-speed buses, which allow for customized applications. Our architectural approach combines hardware-and software measures and integrates them with cryptographic protocols. These are designed for compatibility with today\u2019s vehicular bus systems like CAN or FlexRay networks, as well as upcoming systems such as IP/Ethernet. In this paper, we present the security architecture and protocols defined in EVITA, explain these on the vehicle-to-vehicle Active Brake scenario and present results of our prototype implementation and simulations.", "num_citations": "24\n", "authors": ["364"]}
{"title": "A model of components with non-regular protocols\n", "abstract": " Behavioral specifications that are integrated into component interfaces are an important means for the correct construction of component-based systems. Currently, such specifications are typically limited to finite-state protocols because more expressive notions of protocol do not support reasonable basic composition properties, such as compatibility and substitutability.               In this paper, we present first results of the integration into component interfaces of a notion of non-regular protocols based on \u201cnon-regular process types\u201d introduced by Puntigam [17]. More concretely, we present three contributions: (i) a motivation of the usefulness of non-regular protocols in the context of peer-to-peer applications, (ii) a language for non-regular protocols and an outline of a suitable formal definition, (iii) a discussion of basic composition properties and an analysis of how to adequately integrate protocol-modifying\u00a0\u2026", "num_citations": "24\n", "authors": ["364"]}
{"title": "Data Distribution Algebras-A Formal Basis for Programming Using Skeletons\n", "abstract": " this paper functional languages are proposed as such a methodology using an extension of the concept of skeletons---higher-order functions coupled with parallel implementation templates. An essential part of the proposed methodology is the use of data distribution algebras", "num_citations": "22\n", "authors": ["364"]}
{"title": "The Transformational Derivation of Parallel Programs using Data-Distribution Algebras and Skeletons\n", "abstract": " The transformational derivation of parallel programs for distributed-memory architectures using skeleton-based approaches is one of the most promising methods for parallel program development. These approaches support the derivation of provably correct, efficient and portable parallel programs using a predefined set of encapsulated efficiently implemented parallel base algorithms. Encapsulation requires that compositions of skeletons are explicitly defined by means of transformations. More flexible approaches which enable the compositional development of parallel programs---that is, without reliance on ad hoc transformations---are, however, often advantageous. The research", "num_citations": "21\n", "authors": ["364"]}
{"title": "Putting the next 500 vm placement algorithms to the acid test: The infrastructure provider viewpoint\n", "abstract": " Most current infrastructures for cloud computing leverage static and greedy policies for the placement of virtual machines. Such policies impede the optimal allocation of resources from the infrastructure provider viewpoint. Over the last decade, more dynamic and often more efficient policies based, e.g., on consolidation and load balancing techniques, have been developed. Due to the underlying complexity of cloud infrastructures, these policies are evaluated either using limited scale testbeds/in-vivo experiments or ad-hoc simulators. These validation methodologies are unsatisfactory for two important reasons: they (i) do not model precisely enough real production platforms (size, workload variations, failure, etc.) and (ii) do not enable the fair comparison of different approaches. More generally, new placement algorithms are thus continuously being proposed without actually identifying their benefits with respect to\u00a0\u2026", "num_citations": "19\n", "authors": ["364"]}
{"title": "Side-channels beyond the cloud edge: New isolation threats and solutions\n", "abstract": " Fog and edge computing leverage resources of end users and edge devices rather than centralized clouds. Isolation is a core security challenge for such paradigms: just like traditional clouds, fog and edge infrastructures are based on virtualization to share physical resources among several self-contained execution environments like virtual machines and containers. Yet, isolation may be threatened due to side-channels, created by the virtualization layer or due to the sharing of physical resources like the processor. Side-channel attacks (SCAs) exploit and use such leaky channels to obtain sensitive data. This paper aims to clarify the nature of this threat for fog and edge infrastructures. Current SCAs are local and exploit isolation challenges of virtualized environments to retrieve sensitive information. We introduce a new concept of distributed side-channel attack (DSCA) that is based on coordinating local attack\u00a0\u2026", "num_citations": "18\n", "authors": ["364"]}
{"title": "Detection and resolution of aspect interactions\n", "abstract": " Aspect-Oriented Programming (AOP) promises separation of concerns at the implementation level. However, aspects are not always orthogonal and aspect interaction is an important problem. Currently there is almost no support for the detection and resolution of such interactions. The programmer is responsible for identifying interactions between con icting aspects and implementing con ict resolution code.In this paper, we propose a solution to this problem based on a generic framework for AOP. The contributions are threefold: we present a formal and expressive crosscut language, two static con ict analyses and some linguistic support for con ict resolution.", "num_citations": "18\n", "authors": ["364"]}
{"title": "A reflective infrastructure for coarse-grained strong mobility and its tool-based implementation\n", "abstract": " We argue that separation of concerns can be advantageously applied to the development of applications relying on coarse-grained strong mobility, ie distributed applications moving entities while these entities are executing. We present the design of an infrastructure for such mobile applications where the mobility concern is cleanly separated from other concerns. We present an overview of a prototype implementation\u2014called RAM (Reflection for Adaptable Mobility)\u2014of such an infrastructure for strong mobility in Java by means of computational reflection. This infrastructure permits the development of mobile applications by plugging a mobility concern implemented at the meta-level into a sequential base program, and enables the dynamic introduction of different migration policies. We show how such an infrastructure can be implemented based on program transformation techniques using appropriate existing tools.", "num_citations": "18\n", "authors": ["364"]}
{"title": "Communicating functional agents and their application to graphical user interfaces\n", "abstract": " We demonstrate how concepts of communicating agents can be integrated into purely functional languages by an orthogonal extension of I/O monads. These agents communicate via so-called service access points and foster concurrent programming in the style of client-server architectures. By applying our approach to the realization of graphical user interfaces it turns out that the combination of functional expressiveness and concurrency monads yields a powerful framework for such systems.", "num_citations": "18\n", "authors": ["364"]}
{"title": "Isolation in cloud computing infrastructures: new security challenges\n", "abstract": " Cloud computing infrastructures share hardware resources among different clients, leveraging virtualization to multiplex physical resources among several self-contained execution environments such as virtual machines or Linux containers. Isolation is a core security challenge for such a computing paradigm. It may be threatened by side-channels, created due to the sharing of physical resources like processor caches, or by mechanisms implemented in the virtualization layer. Side-channel attacks (SCAs) exploit and use such leaky channels to obtain sensitive data such as kernel information. This paper aims to clarify the nature of this threat for cloud infrastructures. Current SCAs are performed locally and exploit isolation challenges of virtualized environments to retrieve sensitive information. This paper also clarifies the concept of distributed side-channel attack (DSCA). We explore how such attacks can\u00a0\u2026", "num_citations": "17\n", "authors": ["364"]}
{"title": "Modularization of distributed web services using Aspects With Explicit Distribution (AWED)\n", "abstract": " With the adoption of Web services technology to realize Service Oriented Architectures, the need arises for more flexible and dynamic technologies for the just-in-time integration and composition of services. As the runtime integration, selection and management of services involves a variety of crosscutting concerns, such as error handling, service monitoring, and QoS enforcements, Aspect Oriented Programming (AOP) is useful to modularize such concerns.               In this paper we investigate aspect-oriented support for crosscutting concerns of distributed management of web service compositions. We propose to use a distributed AOP approach, Aspects with Explicit Distribution (AWED), to modularize such concerns in a distributed variant of the Web Services Management Layer (WSML). Concretely, we present three contributions. First, we present an extension of the WSML to distributed compositions\u00a0\u2026", "num_citations": "16\n", "authors": ["364"]}
{"title": "VPA-based aspects: better support for AOP over protocols\n", "abstract": " Aspect-oriented programming is a promising approach to the construction of large-scale software systems. The declarativeness of aspect definitions and support for verification of AO programs crucially depends on the expressiveness of the aspect languages used. Currently, a large spectrum of pointcut languages, i.e., the languages that define where aspects may apply modifications to an application, have been proposed. Their expressiveness ranges from regular expression languages, which, e.g., provide support for static interaction analysis, to context-free or turing complete languages, the latter almost without any support for analysis or verification. In this paper we investigate the use of visibly pushdown automata (VPA) [4] as a basis for an aspect language in order to enable more declarative aspect definitions (compared to regular approaches) for protocol like relationships and static verification of properties, in\u00a0\u2026", "num_citations": "15\n", "authors": ["364"]}
{"title": "Essential AOP: the A calculus\n", "abstract": " Aspect-oriented programming (AOP) has produced interesting language designs, but also ad hoc semantics that needs clarification. We contribute to this clarification with a calculus that models essential AOP, both simpler and more general than existing formalizations. In AOP, advice may intercept method invocations, and proceed executes the suspended call. Proceed is an ad hoc mechanism, only usable inside advice bodies. Many pointcut mechanisms, e.g. wildcards, also lack regularity. We model proceed using first-class closures, and shift complexity from pointcuts to ordinary object-oriented code. Two well-known pointcut categories, call and execution, are commonly considered similar. We formally expose their differences, and resolve the associated soundness problem. Our calculus includes type ranges, an intuitive and concise alternative to explicit type variables that allows advice to be\u00a0\u2026", "num_citations": "14\n", "authors": ["364"]}
{"title": "Functional development of massively parallel programs\n", "abstract": " The programming of parallel systems requires a much higher level of abstraction than is provided by traditional programming languages and programming techniques. Therefore we aim at an approach that utilizes the clarity and power of mathematical concepts to the highest possible extent. In this paper we investigate, how a combination of higher-order functions with particular data structure specifications can be used for the programming of parallel algorithms.", "num_citations": "14\n", "authors": ["364"]}
{"title": "Security vulnerabilities detection and protection using Eclipse\n", "abstract": " After a decade of existence, still, Cross-site scripting, SQL Injection and other of Input validation associated security vulnerabilities can cause severe damage once exploited. To analyze this fact,[14] conducted an empirical study, while OWASP and SANS defined their respective risk-based approaches. Taking these results into consideration, three deficiencies can be highlighted: a lack of up skilling developers, a high ratio of false positive findings in security code scanners and an erroneous planning of security corrections. In this paper, we present how using the Eclipse platform and the JDT compiler, a proper tooling can be provided to overcome these deficiencies. We present a static analyzer that assists developers to report these security vulnerabilities. We show as well how we integrate an Aspect Oriented tool for semi-automated correction of these findings. Both tools are designed within an architecture that is monitored by security experts and particularly adequate for agile development.", "num_citations": "13\n", "authors": ["364"]}
{"title": "Deriving parallel numerical algorithms using data distribution algebras: Wang's algorithm\n", "abstract": " Parallel and distributed programming are much more difficult than the development of sequential algorithms because of data distribution issues and communication requirements. The paper presents a methodology that enables an abstract description of the distribution of data structures by means of overlapping covers that form data distribution algebras. Algorithms are formulated and derived by transformation in a functional environment using skeletons, i.e. higher order functions with specific parallel implementations. Communication is specified implicitly through the access to overlapping parts of covers. Such specifications enable the derivation of explicit lower level communication statements. We illustrate the concepts by a complete derivation of H.H. Wang's (1981) partition algorithm for the solution of tridiagonal systems of linear equations.", "num_citations": "13\n", "authors": ["364"]}
{"title": "Evolving security requirements in multi-layered service-oriented-architectures\n", "abstract": " Due to today\u2019s rapidly changing corporate environments, business processes are increasingly subject to dynamic configuration and evolution. The evolution of new deployment architectures, as illustrated by the move towards mobile platforms and the Internet Of Services, and the introduction of new security regulations (imposed by national and international regulatory bodies, such as SOX or BASEL) are an important constraint in the design and development of business processes. In such a context, it is not sufficient to apply the corresponding adaptations only at the service orchestration or at the choreography level; there is also the need for controlling the impact of new security requirements to several architectural layers, specially in cloud computing, where the notion of Platforms as Services and Infrastructure as Services are fundamental. In this paper we survey several research questions related to\u00a0\u2026", "num_citations": "12\n", "authors": ["364"]}
{"title": "Sophisticated crosscuts for e-commerce\n", "abstract": " AOP [2] introduced the notion of crosscutting concerns in programming. An aspect groups a crosscut (aka. pointcut in Aspect-J [3]) which relates several points of interest (aka. join points) of the base application with an action (aka. advice) to be performed. This article argues for a clear separation of crosscut and action definitions. The tools for AOP currently available support only simple crosscut definitions, which hinders the separation of crosscuts and actions. In this paper we advocate that more sophisticated crosscuts can solve this problem. This article discusses two aspects in the context of a simple e-commerce application. First, we present this AOP example using simple crosscut definitions only. Then we give an alternative version where sophisticated crosscut definitions enable us to clearly separated crosscuts and actions.", "num_citations": "11\n", "authors": ["364"]}
{"title": "On interprocedural data flow analysis for object oriented languages\n", "abstract": " As object oriented languages ease software construction significantly, these languages are very promising candidates for parallelizing compilers. To combine the advantages of object oriented programming with the power of parallel processing two major problems have to be solved: the virtual function and the class scope problem. We present solutions to these problems and exemplify them by extending a fast interprocedural data flow analysis algorithm.", "num_citations": "11\n", "authors": ["364"]}
{"title": "Scoping strategies for distributed aspects\n", "abstract": " Dynamic deployment of aspects brings greater flexibility and reuse potential, but requires a proper means for scoping aspects. Scoping issues are particularly crucial in a distributed context: adequate treatment of distributed scoping is necessary to enable the propagation of aspect instances across host boundaries and to avoid inconsistencies due to unintentional spreading of data and computations in a distributed system.We motivate the need for expressive scoping of dynamically-deployed distributed aspects by an analysis of the deficiencies of current approaches for distributed aspects. Extending recent work on scoping strategies for non-distributed aspects, we then introduce a set of high-level strategies for specifying locality of aspect propagation and activation, and illustrate the corresponding gain in expressiveness. We present the operational semantics of our proposal using Scheme interpreters, first\u00a0\u2026", "num_citations": "10\n", "authors": ["364"]}
{"title": "An application of dynamic AOP to medical image generation\n", "abstract": " Medical image generation, eg, in computer tomographs, requires the use of sophisticated algorithms in a highly sensitive application domain. These algorithms are characterized (i) by a large variability to enable generation of different types of images and (ii) a strong need for dynamic reconfiguration to adapt image generation to individual patients. These two characteristics suggest the use of AOP techniques to manage variability which is akin to a crosscutting functionality and to enable dynamic reconfiguration. In this paper we present three results related to AOP and medical imaging in the context of medical devices from Siemens AG, Germany:(i) a motivation why imaging software for medical tomographs can benefit from dynamic AOP,(ii) a case study of how system software for medical devices can be adapted using the Arachne system for dynamic AOP in C, and (iii) a detailed presentation of the underlying Arachne implementation and the design of its extension to C++.", "num_citations": "10\n", "authors": ["364"]}
{"title": "Modeling railway control systems using graph grammars: a case study\n", "abstract": " In this paper we develop in three phases a railway control system following the requirements of [2]. We are mainly concerned with the software architecture of the control system and its dynamic evolution; we do not discuss here the implementation details of the components forming the control system. First, we informally discuss our design proposal for the architecture of the control system: a hierarchy of controllers whose leaves are local controllers connected in a network that mimics the underlying railway topology. Second, we formally define by means of particular graph grammars a style of software architectures for the railway control system consisting of two complementary views and ensuring several desirable properties by construction. The dynamic evolution of the architecture is modelled by a set of coordination rules which define graph transformations and are verified with respect to to the graph\u00a0\u2026", "num_citations": "10\n", "authors": ["364"]}
{"title": "A model curriculum for aspect-oriented software development\n", "abstract": " As new software engineering techniques emerge, there's a cognitive shift in how developers approach a problem's analysis and how they design and implement its software-based solution. Future software engineers must be appropriately and effectively trained in new techniques' fundamentals and applications. With techniques becoming more mature, such training moves beyond specialized industrial courses into postgraduate curricula (as advanced topics) and subsequently into undergraduate curricula. A model curriculum for aspect-oriented software development provides guidelines about fundamentals, a common framework, and a step toward developing a body of knowledge", "num_citations": "9\n", "authors": ["364"]}
{"title": "Vmplaces: A generic tool to investigate and compare vm placement algorithms\n", "abstract": " Advanced Virtual Machines placement policies are evaluated either using limited scale in-vivo experiments or ad hoc simulator techniques. These validation methodologies are unsatisfactory. First they do not model precisely enough real production platforms (size, workload representativeness, etc.). Second, they do not enable the fair comparison of different approaches.                 To resolve these issues, we propose VMPlaceS, a dedicated simulation framework to perform in-depth investigations and fair comparisons of VM placement algorithms. Built on top of SimGrid, our framework provides programming support to ease the implementation of placement algorithms and runtime support dedicated to load injection and execution trace analysis. It supports a large set of parameters enabling researchers to design simulations representative of a large space of real-world scenarios. We also report on a\u00a0\u2026", "num_citations": "8\n", "authors": ["364"]}
{"title": "Aspectizing javascript security\n", "abstract": " In this position paper we argue that aspects are well-suited to describe and implement a range of strategies to make secure JavaScript-based applications. To this end, we review major categories of approaches to make client-side applications secure and discuss uses of aspects that exist for some of them. We also propose aspect-based techniques for the categories that have not yet been studied. We give examples of applications where aspects are useful as a general means to flexibly express and implement security policies for JavaScript.", "num_citations": "8\n", "authors": ["364"]}
{"title": "Invasive patterns for distributed programs\n", "abstract": " Software patterns have evolved into a commonly used means to design and implement software systems. Programming patterns, architecture and design patterns have been quite successful in the context of sequential as well as (massively) parallel applications but much less so in the context of distributed applications over irregular communication topologies and heterogeneous synchronization requirements.                 In this paper, we propose a solution for one of the main issues in this context: the need to complement distributed patterns with access to execution state on which it depends but that is frequently not directly available at the sites where the patterns are to be applied. To this end we introduce invasive patterns that couple well-known computation and communication patterns like pipelining and farming out computations with facilities to access non-local state. We present the following\u00a0\u2026", "num_citations": "8\n", "authors": ["364"]}
{"title": "Dynamic adaptation of the Squid web cache with Arachne\n", "abstract": " The Arachne aspect-oriented programming system developers modularize changes to networking software with little perceptible performance overhead. Writing good software is often a challenge; writing adaptable software can be even more difficult. In legacy Web caches such as Squid, such adaptation interfaces are typically needed for functionalities that are applied across the legacy code, functionalities whose code is scattered and tangled in the Web cache code's files and functions. An AOP system's join point model defines the relevant basic execution events of a given base application. Pointcuts allow programmers to refer to all such events, at which a functionality of interest is applied across, or crosscuts, the base application. At the execution events matched by pointcuts, advice can be used to modify the base application's execution. Arachne features two basic kinds of join points: C function calls and read\u00a0\u2026", "num_citations": "8\n", "authors": ["364"]}
{"title": "Un modele et un outil pour la programmation par aspects \u00e9v\u00e9nementiels\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "8\n", "authors": ["364"]}
{"title": "Cross-document dependency analysis for system-of-system integration\n", "abstract": " Systems-of-systems are formed through integration of individual complex systems, often not designed to work together. A number of factors can make this integration very challenging which often leads to catastrophic failures. In this paper, we focus on three major classes of system-of-system integration problems: managerial independence, interface incompatibility, and component-system complexity. We then present an aspect-oriented requirements description language (RDL) which uses natural language analysis capabilities to reason about dependencies across the documentation of the constituent systems of a system-of-systems. The aspect-oriented compositions in the RDL also facilitate specification of cross-document constraints and inconsistency resolution strategies, which can be used for deriving proof obligations and test cases for verification and validation of the emergent behaviour of a system\u00a0\u2026", "num_citations": "7\n", "authors": ["364"]}
{"title": "Property-preserving evolution of components using VPA-based aspects\n", "abstract": " Protocols that govern the interactions between software components are a popular means to support the construction of correct component-based systems. Previous studies have, however, almost exclusively focused on static component systems that are not subject to evolution. Evolution of component-based systems with explicit interaction protocols can be defined quite naturally using aspects (in the sense of AOP) that modify component protocols. A major question then is whether aspect-based evolutions preserve fundamental correctness properties, such as compatibility and substitutability relations between software components.                 In this paper we discuss how such correctness properties can be proven in the presence of aspect languages that allow matching of traces satisfying interaction protocols and enable limited modifications to protocols. We show how common evolutions of distributed\u00a0\u2026", "num_citations": "7\n", "authors": ["364"]}
{"title": "On the construction of components with explicit protocols\n", "abstract": " Component-based programming promises to facilitate the construction of large-scale applications, which is supported by the important concept of interfaces. In most current component models, interfaces essentially declare types and sets of services that a component implements. They are not expressive enough to formulate many properties important for component collaboration.In this paper we consider an important class of such properties, sequencing constraints, which components must obey when calling one another services. We consider the integration into interfaces of sequencing properties by means of protocols formalized in terms of finite-state machines. The paper presents three contributions. First, a set of protocol composition operators and a discussion of correctness properties of such operators useful for component assembly. Second, we provide a first step toward the integration of additional state information into protocols. Finally, we show how JavaBeans can benefit from the techniques we present.", "num_citations": "7\n", "authors": ["364"]}
{"title": "Side channels in the cloud: Isolation challenges, attacks, and countermeasures\n", "abstract": " Cloud computing is based on the sharing of physical resources among several virtual machines through a virtualization layer providing software isolation. Despite advances in virtualization, data security and isolation guarantees remain important challenges for cloud providers. Some of the most prominent isolation violations come from side-channel attacks that aim at exploiting and using a leaky channel to obtain sensitive data such as encryption keys. Such channels may be created by vulnerable implementations of cryptographic algorithms, exploiting weaknesses of processor architectures or of resource sharing in the virtualization layer. In this paper, we provide a comprehensive survey of side-channel attacks (SCA) and mitigation techniques for virtualized environments, focusing on cache-based attacks. We review isolation challenges, attack classes and techniques. We also provide a layer-based taxonomy of applicable countermeasures , from the hardware to the application level, with an assessment of their effectiveness.", "num_citations": "6\n", "authors": ["364"]}
{"title": "Reference monitors for security and interoperability in OAuth 2.0\n", "abstract": " OAuth 2.0 is a recent IETF standard devoted to providing authorization to clients requiring access to specific resources over HTTP. It has been pointed out that this framework is potentially subject to security issues, as well as difficulties concerning the interoperability between protocol participants and application evolution. As we show in this paper, there are indeed multiple reasons that make this protocol hard to implement and impede interoperability in the presence of different kinds of client. Our main contribution consists in a framework that harnesses a type-based policy language and aspect-based support for protocol adaptation through flexible reference monitors in order to handle security, interoperability and evolution issues of OAuth 2.0. We apply our framework in the context of three scenarios that make explicit variations in the protocol and show how to handle those issues.", "num_citations": "6\n", "authors": ["364"]}
{"title": "Structured and flexible gray-box composition: application to task rescheduling for grid benchmarking\n", "abstract": " The evolution of complex distributed software systems often requires intricate composition operations in order to adapt or add functionalities, react to unanticipated changes to security policies, or do performance improvements, which cannot be modularized in terms of existing services or components. They often need controlled access to selected parts of the implementation, e.g., to manage exceptional situations and crosscutting within services and their compositions. However, existing composition techniques typically support only interface-level (black-box) composition or arbitrary access to the implementation (gray-box or white-box composition). In this paper, we present a more structured approach to the composition of complex software systems that require invasive accesses. Concretely, we provide two contributions, we (i) present a small kernel composition language for structured gray-box composition with explicit control mechanisms and a corresponding aspect-based implementation; (ii) present and compare evolutions using this approach to gray-box composition in the context of two real-world software systems: benchmarking of grid algorithms with NASGrid and transactional replication with JBoss Cache.", "num_citations": "6\n", "authors": ["364"]}
{"title": "LTS-based semantics and property analysis of distributed aspects and invasive patterns\n", "abstract": " Invasive patterns are an extension of standard parallel and distributed architectural patterns for complex distributed algorithms. They have previously been implemented in terms of the AWED language, an aspect language with features for explicit distribution. In this paper we present two formal semantics based on labeled transition systems, one for AWED and the other for invasive patterns, for the definition of interaction properties of aspects and pattern compositions. We also show how the semantics can be used to check corresponding liveness and safety properties.", "num_citations": "6\n", "authors": ["364"]}
{"title": "Enforcing expressive accountability policies\n", "abstract": " Accountability policies for the enforcement of the responsible stewardship of personal data have to support the gathering of information at all levels of the service stack and across different policy domains, for instance, for the retrospective enforcement of transparency and remediation properties. Existing approaches to accountability, however, often do not meet these requirements and corresponding implementation support is lacking. In this paper we show how expressive accountability policies can be defined in terms of policy domains, accessible data at all levels of the service stack, and preventive and retrospective mechanisms. Additionally, we present a notion of accountability schemes that support the constructive implementation of our accountability policies. Finally, we motivate and apply our approach in the context of real-world attacks to OAuth-based authorization and authentication protocols.", "num_citations": "5\n", "authors": ["364"]}
{"title": "Well-typed services cannot go wrong\n", "abstract": " Service-oriented applications are frequently used in highly dynamic contexts: ser- vice compositions may change dynamically, in particular, because new services are discovered at runtime. Moreover, subtyping has recently been identified as a strong requirement for service dis- covery. Correctness guarantees over service compositions, provided in particular by type systems, are highly desirable in this context. However, while service oriented applications can be built using various technologies and protocols, none of them provides decent support ensuring that well-typed services cannot go wrong. An emitted message, for instance, may be dangling and remain as a ghost message in the network if there is no agent to receive it. In this article, we introduce a formal model for service compositions and define a type system with subtyping that ensures type soundness by combining static and dynamic checks. We also demonstrate how to preserve type soundness in presence of malicious agents and insecure communication channels.", "num_citations": "5\n", "authors": ["364"]}
{"title": "Invasive patterns: aspect-based adaptation of distributed applications\n", "abstract": " Software patterns are frequently used as a software development tool in sequential as well as (massively) parallel applications but have been less successful in the context of distributed applications over irregular communication topologies and heterogeneous synchronization requirements. In this paper, we argue that lack of flexibility of pattern definitions is a major impediment in distributed environments, especially legacy contexts. We propose invasive patterns that support the modular definition and adaptation of distributed applications in the presence of complex pattern-enabling conditions. Invasive patterns are concisely defined in terms of two abstractions: aspects (in the AOP sense) for the modularization of crosscutting enabling conditions, and groups of hosts for the definition of patterns over complex topologies. Concretely, we motivate the need for invasive patterns in the context of JBoss Cache, introduce the concept of invasive patterns and briefly discuss corresponding language support as well as an implementation.", "num_citations": "5\n", "authors": ["364"]}
{"title": "On the lightweight and selective introduction of reflective capabilities in applications\n", "abstract": " Computational reflection is gaining interest in practical applications: modern software frequently requires strong adaptability conditions to be met in order to fit a heterogenous and evolving computing environment. Most of these applications only need limited but flexible reflective capabilities rather than sophisticated reflective languages and reflective runtime systems. However, there is no notion of a reflective application which is independent from an underlying reflective system. Our paper aims at filling this gap by means of a constructive definition: we introduce a reification technique that allows the transformation of non-reflective applications into reflective ones.", "num_citations": "5\n", "authors": ["364"]}
{"title": "Aspectual session types\n", "abstract": " Multiparty session types allow the definition of distributed processes with strong communication safety properties. A global type is a choreographic specification of the interactions between peers, which is then projected locally in each peer. Well-typed processes behave accordingly to the global protocol specification. Multiparty session types are however monolithic entities that are not amenable to modular extensions. Also, session types impose conservative requirements to prevent any race condition, which prohibit the uni-form application of extensions at different points in a protocol. In this paper, we describe a means to support modular extensions with aspectual session types, a static pointcut/advice mechanism at the session type level. To support the modular definition of crosscut-ting concerns, we augment the expressivity of session types to al-low harmless race conditions. We formally prove that well-formed\u00a0\u2026", "num_citations": "4\n", "authors": ["364"]}
{"title": "A message-passing model for service oriented computing\n", "abstract": " Service-based applications can be built according to multiple technologies. Although there is a clear need for a model integrating them in multiple real-world contexts, no integrated model does (yet) exist. In this paper we introduce a model as a foundation for heterogeneous services, with particularly studying SOAP/WS* and RESTful models. The model completely abstracts away from service implementations, composes them in a truly concurrent manner, and supports asynchronous message passing as well as mobility of typed channels. We consider the application of this model to the problem of type checking messages and communications in presence of channel mobility and malicious agents.", "num_citations": "4\n", "authors": ["364"]}
{"title": "Aspect-based patterns for grid programming\n", "abstract": " The development of grid algorithms is frequently hampered by limited means to describe topologies and lack of support for the invasive composition of legacy components in order to pass data between them. In this paper we present a solution to overcome these limitations using the notion of invasive patterns for the construction of distributed algorithms, a recent extension of well-known computation and communication patterns. Concretely, we present two contributions. First, based on a study of how patterns are instantiated in NAS grid, a well-known benchmark used for evaluating performance of computational grids, we show how invasive patterns can be used for the declarative definition of large-scale grid topologies and checkpointing algorithms. Second, we qualitatively and quantitatively evaluate how our approach can be used to implement the checkpointing on top of grid applications.", "num_citations": "4\n", "authors": ["364"]}
{"title": "Towards a model of concurrent AOP\n", "abstract": " Aspect-Oriented Programming (AOP) is concerned with the modularization of crosscutting functionalities. Such functionalities are problematic, in particular, for the development of concurrent applications, such as graphical user interfaces or multithreaded server applications. However, few approaches address this problem: there is, in particular, no general model for concurrent AOP that enables coordination among concurrently-executing aspects as well as coordination of concurrent aspects and base applications. In this paper, we discuss general requirements for such models, briefly present a specific instance meeting these requirements, and propose a set of general composition operators for the construction of concurrent applications using concurrently executing advice.", "num_citations": "4\n", "authors": ["364"]}
{"title": "On distributed collaboration for biomedical analyses\n", "abstract": " Cooperation of research groups is nowadays common for the development and execution of biomedical analyses. Multiple partners contribute data in this context, data that is often centralized for processing at some cluster-based or supercomputer-based infrastructure. In contrast, real distributed collaboration that involves processing of data from several partners at different sites is rare. However, such distributed analyses are often very interesting, in particular, for scalability, security and privacy reasons. In this article, we motivate the need for real distributed biomedical analyses in the context of several ongoing projects, including the ICAN project that involves 34 French hospitals and affiliated research groups. We present a set of distributed architectures for such analyses that we have derived from discussions with different medical research groups and a study of related work. These architectures allow for\u00a0\u2026", "num_citations": "3\n", "authors": ["364"]}
{"title": "Constructive Privacy for Shared Genetic Data\n", "abstract": " The need for the sharing of genetic data, for instance, in genome-wide association studies is incessantly growing. In parallel, serious privacy concerns rise from a multi-party access to genetic information. Several techniques , such as encryption, have been proposed as solutions for the privacy-preserving sharing of genomes. However, existing programming means do not support guarantees for privacy properties and the performance optimization of genetic applications involving shared data. We propose two contributions in this context. First, we present new cloud-based architectures for cloud-based genetic applications that are motivated by the needs of geneticians. Second, we propose a model and implementation for the composition of watermarking with encryption, fragmentation, and client-side computations for the secure and privacy-preserving sharing of genetic data in the cloud.", "num_citations": "3\n", "authors": ["364"]}
{"title": "A language for the composition of privacy-enforcement techniques\n", "abstract": " Today's large-scale computations, for instance, in the cloud, are subject to a multitude of risks concerning the divulging and ownership of private data. Privacy risks are mainly addressed using encryption-based techniques. These make data private, but costly to operate. Furthermore, today's computations have to ensure privacy properties in the context of complex software compositions, however, no general support for the declarative definition and implementation of privacy-preserving applications has been put forward. This article presents an approach to the correct composition of privacy-preserving applications in the cloud. Our approach provides language support for the composition of encryption-and fragmentation-based privacy-preserving algorithms. This language comes with a set of laws that allows us to verify privacy properties. Finally, we introduce implementation support in Scala that ensures privacy\u00a0\u2026", "num_citations": "3\n", "authors": ["364"]}
{"title": "Advanced validation of the dvms approach to fully distributed vm scheduling\n", "abstract": " The holy grail for Infrastructure as a Service (IaaS) providers is to maximize the utilization of their infrastructure while ensuring the quality of service (QoS) for the virtual machines they host. Although the frameworks in charge of managing virtual machines (VM) on pools of physical ones (PM) have been significantly improved, enabling to manage large-scale infrastructures composed of hundreds of PMs, most of them do not efficiently handle the aforementioned objective. The main reason is that advanced scheduling policies are subject to important and hard scalability problems, that become even worse when VM image transfers have to be considered. In this article, we provide a new validation of the Distributed VM Scheduler approach (DVMS) in a twofold manner. First, we provide a formal proof of the algorithm based on temporal logic. Second, we discuss large-scale evaluations involving up to 4.7K VMs\u00a0\u2026", "num_citations": "3\n", "authors": ["364"]}
{"title": "Flexible and expressive aspect-based control over service compositions in the cloud\n", "abstract": " Accountability properties (e.g., security and privacy proper- ties for trustworthy data stewardship) are becoming increas- ingly important for Cloud applications. Frequently, they have to be enforced on large-scale service-based legacy ap- plications. In this paper we argue that real-world service in- frastructures are best modeled in terms of three abstraction levels and that (partially invasive) adaptations involving all levels are needed to handle the corresponding evolution sce- narios. In this paper, we motivate these issues for the case of Apache CXF, a popular service infrastructure, and secure logging as a basic accountability property. We propose an initial version of a DSL for flexible and expressive control over the execution of service compositions on three levels: service, interceptor and implementation. We also present a corresponding prototype tool and infrastructure we have implemented over CXF. Finally, we\u00a0\u2026", "num_citations": "3\n", "authors": ["364"]}
{"title": "Une technique g\u00e9n\u00e9rique de r\u00e9ification pour les langagesa objets\n", "abstract": " La r\u00e9flexion gagne du terrain dans les applications pratiques comme attest\u00e9 par la pr\u00e9sence d\u2019une API r\u00e9flexive dans l\u2019environnement de programmation JAVA et les r\u00e9cents travaux sur le middleware r\u00e9flexif. Les syst\u00e8mes r\u00e9flexifs offrent de nombreuses interfaces de programmation, aussi connues sous le nom de protocole m\u00e9taobjet (MOP). Leur conception d\u00e9pend de certaines contraintes comme l\u2019expressivit\u00e9, l\u2019efficacit\u00e9 et la s\u00e9curit\u00e9. Puisque ces contraintes sont diff\u00e9rentes d\u2019une application \u00e0 l\u2019autre, nous devons \u00eatre capables de fournir facilement des MOP sur mesure pour des ensembles de contraintes donn\u00e9s. Dans cet article, nous pr\u00e9sentons une technique g\u00e9n\u00e9rique de r\u00e9ification \u00e0 base de transformation de programme. Elle permet la r\u00e9ification s\u00e9lective d\u2019une partie arbitraire d\u2019un interpr\u00e8te de langage \u00e0 objets. La transformation de programme peut aussi \u00eatre appliqu\u00e9e \u00e0 diff\u00e9rents interpr\u00e8tes. Chaque\u00a0\u2026", "num_citations": "3\n", "authors": ["364"]}
{"title": "The next 700 reflective object-oriented languages\n", "abstract": " Since Smith seminal work, there have been numerous reflective language definition and implementation proposals. These proposals, initially restricted to functional languages, have been quickly extended to object-oriented languages. Unfortunately, reflective objectoriented language definitions remained mostly ad hoc. In this paper, we present a generic reification technique which enables the selective reification of arbitrary parts of object-oriented language interpreters. Our program transformation can be applied to different interpreter definitions. Each resulting reflective implementation provides a different meta-object protocol based on the original interpreter definition. This technique paves the way to a systematic study of reflective object-oriented language implementations.", "num_citations": "3\n", "authors": ["364"]}
{"title": "Towards a Redesign of OPAL\n", "abstract": " CiteSeerX \u2014 Towards a Redesign of OPAL Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Towards a Redesign of OPAL (1997) Cached Download as a PDF Download Links [uebb.cs.tu-berlin.de] Other Repositories/Bibliography DBLP Save to List Add to Collection Correct Errors Monitor Changes by Klaus Didrich , J\u00fcrgen Exner , Carola Gerke , Wolfgang Grieskamp , Christian Maeder , Peter Pepper , Mario S\u00fcdholt Citations: 1 - 1 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us Developed at and hosted by The College of Information Sciences and -\u2026", "num_citations": "3\n", "authors": ["364"]}
{"title": "On the semantics of a concurrency monad with choice and services\n", "abstract": " We develop two semantics for the concurrency monad of the purely functional language Opal, which provides a general monadic choice, value-result agents and guarded client-server based communication. The transition semantics supports an operational understanding of the concurrency monad. The state-transformer semantics gives an axiomatic description of the concurrency monad by using a variant of temporal interval logic as syntactic sugar on top of LCF. In order to cope with typing problems in both semantics, a modi ed notion of dynamic types is developed, which entails as a special case local existential quanti cation of type variables in constructor functions.", "num_citations": "3\n", "authors": ["364"]}
{"title": "Functional programming of massively parallel systems\n", "abstract": " Parallel programming is intrinsically more difficult than sequential programming. To this day there is no universal programming methodology which provides a simple programming model applicable to a wide range of architectures. In this report a methodology is presented which aims at solving this dilemma using a transformational approach based on skeletons. First steps towards a general theory of skeletons are set up using results from sheaf theory. These results provide the basis for the formal definition of data distribution algebras underlying our definition of skeletons. The papers presents several examples in some detail which illustrate the use of the presented formalism in application domains important to parallel programming. Keywords: functional programming, parallel programming, skeleton, data distribution algebra.", "num_citations": "3\n", "authors": ["364"]}
{"title": "Secure distributed computing on untrusted fog infrastructures using trusted linux containers\n", "abstract": " Fog and Edge computing provide a large pool of resources at the edge of the network that may be used for distributed computing. Fog infrastructure heterogeneity also results in complex configuration of distributed applications on computing nodes. Linux containers are a mainstream technique allowing to run packaged applications and micro services. However, running applications on remote hosts owned by third parties is challenging because of untrusted operating systems and hardware maintained by third parties. To meet such challenges, we may leverage trusted execution mechanisms. In this work, we propose a model for distributed computing on Fog infrastructures using Linux containers secured by Intel's Software Guard Extensions (SGX) technology. We implement our model on a Docker and OpenSGX platform. The result is a secure and flexible approach for distributed computing on Fog infrastructures.", "num_citations": "2\n", "authors": ["364"]}
{"title": "Towards modular instrumentation of interpreters in JavaScript\n", "abstract": " With an initial motivation based on the security of web applications written in JavaScript, we consider the instrumentation of an interpreter for a dynamic analysis as a crosscutting concern. We define the instrumentation problem\u2014an extension to the expression problem with a focus on modifying interpreters. We then illustrate how we can instrument an interpreter for a simple language using only the bare language features provided by JavaScript.", "num_citations": "2\n", "authors": ["364"]}
{"title": "Adapting workflows using generic schemas: application to the security of business processes\n", "abstract": " Existing approaches to the adaptation of workflows over Web services fall short in two respects. First, they only provide, if ever, limited means for taking into account the execution history of a workflow. Second, they do not support adaptations that require modifications not only at the service composition level but also at the levels of interceptors and service implementations. This is particular problematic for the enforcement of security properties over workflows: enforcing authorization properties, for instance, frequently requires execution contexts to be defined and modifications to be applied at all these abstraction levels of Web services. We present two main contributions in this context. First, we introduce workflow adaptation schemas (WAS), a new notion of generic protocol-based workflow adapters. WAS enable the declarative definition of adaptations involving complex service compositions and implementations\u00a0\u2026", "num_citations": "2\n", "authors": ["364"]}
{"title": "Towards expressive, well-founded and correct Aspect-Oriented Programming\n", "abstract": " This habilitation thesis presents the main results of my research work conducted as part of OBASCO (\u201cObjects, Aspects, Components\u201d) project, a joint project with INRIA that is also part of the \u201cLaboratoire d\u2019Informatique de Nantes Atlantique\u201d(LINA), in the computer science department of Ecole des Mines de Nantes. This work has focused on modularization and software evolution problems investigated as part of the emerging research domain of Aspect-Oriented Programming, in particular, the foundation and design of aspect languages, the relationship between component-based programming and aspects, as well as aspect-oriented support for distributed programming. Similar problems had already been the subject of my previous work. As part of my PhD thesis at TU Berlin I investigated the parallelization of functional programs by means of a skeletonbased approach. This work can, in today\u2019s terminology, easily be framed as the definition of several domain-specific aspect languages for parallel execution at different levels of abstraction, ranging from a high-level language to languages directly representing architectures of parallel machines. I have also provided an implementation in terms of a calculus allowing the transformation between abstraction levels, a method very similar to aspect weaving.In my following year of post-doc studies at IRISA/INRIA-Rennes, I employed shape types\u2014a notion of graph-based types initially developed to provide better structured support for data types in the C language\u2014to devise new abstraction and reasoning mechanisms for software architectures. Such graph-based types allow, in particular, to formally\u00a0\u2026", "num_citations": "2\n", "authors": ["364"]}
{"title": "Atoll: Aspect-oriented toll system\n", "abstract": " Product line development places emphasis on quality attributes like understandability, maintainability, reusability and variability. Better modularization techniques like aspect-oriented programming are supposed to improve these attributes.", "num_citations": "2\n", "authors": ["364"]}
{"title": "Automating adaptive image generation for medical devices using aspect-oriented programming\n", "abstract": " Image generation, e.g., in computer tomographs, requires the use of sophisticated algorithms which are characterized (i) by a large variability to enable generation of different types of images and (ii) a strong need for dynamic reconfiguration to adapt image generation, e.g., to individual patients. On the application level, such characteristics are frequently scattered all over the code of the application. This suggests the use of aspect-oriented programming (AOP) techniques to modularize such crosscutting functionality. In this paper we present an approach to automate image generation tasks using AOP and their application in the context of medical devices from Siemens AG, Germany. Concretely, we present three results: (i) a motivation why imaging software can benefit from dynamic AOP, (ii) a case study of how image generation, in particular for medical devices, can be adapted using the Arachne system for\u00a0\u2026", "num_citations": "2\n", "authors": ["364"]}
{"title": "Composants et aspects\n", "abstract": " Archive ouverte HAL - Composants et aspects Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00457122, version 1 Chapitre d'ouvrage Composants et aspects Jacques Noy\u00e9 1, 2 R\u00e9mi Douence 2, 3 Mario S\u00fcdholt 1, 2 D\u00e9tails 1 LINA - Laboratoire d'Informatique de Nantes Atlantique 2 OBASCO - Objects, aspects and components Mines Nantes - Mines Nantes, Inria Rennes \u2013 Bretagne Atlantique 3 ASCOLA - Aspect and composition languages Inria Rennes \u2013 Bretagne Atlantique , D\u00e9partement - EMN, - d\u2026", "num_citations": "2\n", "authors": ["364"]}
{"title": "Temporal Semantics of a Concurrency Monad with Choice and Services\n", "abstract": " We describe the concurrency monad of the functional language OPAL, which re alizes a smooth integration of concurrent processes in a purely functional frame work, providing a general choice and client-server based communication. We develop an axiomatic semantics for the concurrency monad using a variant of temporal interval logic as syntactic sugar on top of the logic of computable func tions.", "num_citations": "2\n", "authors": ["364"]}
{"title": "Formulation and development of parallel numerical algorithms with data distribution algebras\n", "abstract": " The solution of many numerical problems, especially the so-called grand challenges, requires the use of modern parallel computers. Conversely, numerical algorithms are one of the (if not the) most important application area in the field of parallel programming. Parallel programming, however, is not simply a variation on traditional sequential programming techniques \u2014 rather it requires new ways of thinking: besides the evolution of an algorithm over time, the space aspect is predominant, particularly for modern MIMD architectures. Due to this fact, the conceptual gap between mathematical specifications and concrete implementations becomes much larger than for sequential algorithms. Automatic program derivation by program transformation shows promise as a route to a solution: transform high-level abstract specifications via less abstract intermediate specifications into efficient data-parallel executable\u00a0\u2026", "num_citations": "2\n", "authors": ["364"]}
{"title": "Distributed Contextualization of Biomedical Data: a case study in precision medicine\n", "abstract": " An important aspect of precision medicine consists in patient-centered contextualization analyses that are used as part of biomedical interactive tools. Such analyses often harness data of large populations of patients from different research centers and can often benefit from a distributed implementation. However, performance and the security and privacy concerns of sharing sensitive biomedical data can become a major issue. We have investigated these issues in the context of a kidney transplanted patient contextualization project: the Kidney Transplantation Application (KITAPP). In this paper, we present a motivation for distributed implementations in this context, notably for computing percentiles for contextualization. We present a corresponding system architecture, motivate privacy and performance issues, and present a novel distributed implementation that is evaluated in a realistic multi-site setting.", "num_citations": "1\n", "authors": ["364"]}
{"title": "Extensible modules for JavaScript\n", "abstract": " The module pattern in JavaScript is commonly used to encapsulate definitions by using closures. However, closures prevent module definitions from being extended at runtime. We propose a simple pattern that not only opens the module, but allows one to extend the module definitions in layers. The pattern leverages the with construct and the prototype delegation mechanism of JavaScript to mimick dynamic binding, while minimizing the changes made to the module code.", "num_citations": "1\n", "authors": ["364"]}
{"title": "Essential AOP: The a calculus\n", "abstract": " Aspect-oriented programming (AOP) has produced interesting language designs, but also ad hoc semantics that needs clarification. We contribute to this clarification with a calculus that models essential AOP, both simpler and more general than existing formalizations. In AOP, advice may intercept method invocations, and proceed executes the suspended call. Proceed is an ad hoc mechanism, only usable inside advice bodies. Many pointcut mechanisms, for example, wildcards, also lack regularity. We model proceed using first-class closures, and shift complexity from pointcuts to ordinary object-oriented code. Two well-known pointcut categories, call and execution, are commonly considered similar. We formally expose their differences, and resolve the associated soundness problem. Our calculus includes type ranges, an intuitive and concise alternative to explicit type variables that allows advice to be\u00a0\u2026", "num_citations": "1\n", "authors": ["364"]}
{"title": "Towards a robust model for distributed aspects\n", "abstract": " In this paper, we present some of the problems we have found in distributed aspect models and introduce a set of criteria that we consider necessary for a robust distributed aspect system. We outline of a first version of model based on aspects and actors capable of meeting these criteria.", "num_citations": "1\n", "authors": ["364"]}
{"title": "A study of invasive composition for the evolution of a health information system\n", "abstract": " In this paper we show that some of the evolution tasks in OpenMRS, a health information system, may require the invasive modification of interfaces and implementations in order to offer an appropriate modularization. We introduce a new composition framework in Java that supports the definition of expressive pattern-based invasive compositions. Furthermore, we show that the composition framework allows us to concisely define an evolution scenario of OpenMRS that supports the consolidation of patient data from different remote instances", "num_citations": "1\n", "authors": ["364"]}
{"title": "Structured and flexible gray-box composition using invasive distributed patterns\n", "abstract": " The evolution of complex distributed software systems often requires intricate composition operations in order to adapt or add functionalities, to react to unanticipated changes, or to apply performance improvements that cannot be modularized in terms of existing services and components. These evolutions often need controlled access to selected parts of the implementation, e.g., to manage exceptional situations and crosscutting within services and their compositions. However, existing composition techniques typically support only interface-level (black-box) composition or arbitrary access to the implementation (gray-box or white-box composition). In this paper, we present a structured approach to the composition of complex software systems that require invasive modifications. Concretely, we provide three contributions: (i) we present a small kernel composition language for structured gray-box composition using invasive distributed patterns; (ii) we motivate that gray-box composition approaches should be defined and evaluated in terms of the flexibility and control they provide, a notion of degrees of invasiveness is introduced to help assess this trade-off; (iii) we apply our approach to a new case study of evolution and evaluate it in the context of two previous studies involving two real-world software systems: benchmarking of grid algorithms with NASGrid and transactional replication with JBoss Cache. As a main result, we show that gray-box composition using invasive distributed patterns allows the declarative and modular definition of evolutions of real-world applications that need moderate to high degrees of invasive modifications.", "num_citations": "1\n", "authors": ["364"]}
{"title": "Vers une r\u00e9ification de l'\u00e9nergie dans le domaine du logiciel\n", "abstract": " Archive ouverte HAL - Vers une r\u00e9ification de l'\u00e9nergie dans le domaine du logiciel Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00467411, version 1 Communication dans un congr\u00e8s Vers une r\u00e9ification de l'\u00e9nergie dans le domaine du logiciel Jean-Marc Menaud 1, 2 Adrien Lebre 1, 2 Thomas Ledoux 1, 2 Jacques Noy\u00e9 1, 2 Pierre Cointe 1, 2 R\u00e9mi Douence 1 Mario S\u00fcdholt 1, 2 D\u00e9tails 1 ASCOLA - Aspect and composition languages LINA - Laboratoire d'Informatique de Nantes Atlantique, - EMN, \u2013 '\u2026", "num_citations": "1\n", "authors": ["364"]}
{"title": "Funktionale Programmierung f\u00fcr massiv parallele Systeme\n", "abstract": " Zur Programmierung paralleler Systeme ist ein wesentlich h\u00f6heres Abstraktionsniveau n\u00f6tig, als es die heute g\u00e4ngigen Sprachen bieten. Ein m\u00f6glicher Ansatz sind hier Funktionale h\u00f6herer Ordnung (\u201eSkeletons\u201c), die auf geeigneten Algebren der Datenpartitionie-rung aufbauen. Die Idee dieser Methode wird hier exemplarisch \u2014 soweit der beschr\u00e4nkte Platz dies zul\u00e4\u00dft \u2014 anhand eines ausgew\u00e4hlten Beispiels vorgef\u00fchrt.2", "num_citations": "1\n", "authors": ["364"]}
{"title": "Towards a Generic Framework for AOP\n", "abstract": " During the 1st workshop on AOP AOP97] several fundamental questions were raised: What exactly are aspects? How to weave? What are the join points used to anchor aspects into the component program? Is there a general purpose aspect language? In this position paper, we address these questions for a particular class of aspects: aspects expressible as static, source-to-source program transformations. An aspect is de ned as a collection of program transformations acting on the abstract syntax tree of the component program. We discuss the design of a generic framework to express these transformations as well as a generic weaver. The coupling of component and aspect de nitions can be de ned formally using operators matching subtrees of the component program. The aspect weaver is simply a xpoint operator taking as parameters the component program and a set of program transformations. In many cases, program transformations based solely on syntactic criteria are not satisfactory and one would like to be able to use semantic criteria in aspect de nitions. We show how this can be done using properties expressed on the semantics of the component program and implemented using static analysis techniques. One of our main concerns is to keep weaving predictable. This raises several questions about the semantics (termination, convergence) of weaving.", "num_citations": "1\n", "authors": ["364"]}