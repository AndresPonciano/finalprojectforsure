{"title": "BI as an assertion language for mutable data structures\n", "abstract": " Reynolds has developed a logic for reasoning about mutable data structures in which the pre-and postconditions are written in an intuitionistic logic enriched with a spatial form of conjunction. We investigate the approach from the point of view of the logic BI of bunched implications of O'Hearnand Pym. We begin by giving a model in which the law of the excluded middleholds, thus showing that the approach is compatible with classical logic. The relationship between the intuitionistic and classical versions of the system is established by a translation, analogous to a translation from intuitionistic logic into the modal logic S4. We also consider the question of completeness of the axioms. BI's spatial implication is used to express weakest preconditions for object-component assignments, and an axiom for allocating a cons cell is shown to be complete under an interpretation of triplesthat allows a command to be applied to\u00a0\u2026", "num_citations": "837\n", "authors": ["262"]}
{"title": "Resources, concurrency, and local reasoning\n", "abstract": " In this paper we show how a resource-oriented logic, separation logic, can be used to reason about the usage of resources in concurrent programs. c 2007 Elsevier BV All rights reserved.", "num_citations": "825\n", "authors": ["262"]}
{"title": "The logic of bunched implications\n", "abstract": " We introduce a logic BI in which a multiplicative (or linear) and an additive (or intuitionistic) implication live side-by-side. The propositional version of BI arises from an analysis of the proof-theoretic relationship between conjunction and implication; it can be viewed as a merging of intuitionistic logic and multiplicative intuitionistic linear logic. The naturality of BI can be seen categorically: models of propositional BI's proofs are given by bicartesian doubly closed categories, i.e., categories which freely combine the semantics of propositional intuitionistic logic and propositional multiplicative intuitionistic linear logic. The predicate version of BI includes, in addition to standard additive quantifiers, multiplicative (or intensional) quantifiers and which arise from observing restrictions on structural rules on the level of terms as well as propositions. We discuss computational interpretations, based on sharing, at both the\u00a0\u2026", "num_citations": "638\n", "authors": ["262"]}
{"title": "Permission accounting in separation logic\n", "abstract": " A lightweight logical approach to race-free sharing of heap storage between concurrent threads is described, based on the notion of permission to access. Transfer of permission between threads, subdivision and combination of permission is discussed. The roots of the approach are in Boyland's [3] demonstration of the utility of fractional permissions in specifying non-interference between concurrent threads. We add the notion of counting permission, which mirrors the programming technique called permission counting. Both fractional and counting permissions permit passivity, the specification that a program can be permitted to access a heap cell yet prevented from altering it. Models of both mechanisms are described. The use of two different mechanisms is defended. Some interesting problems are acknowledged and some intriguing possibilities for future development, including the notion of resourcing as a step\u00a0\u2026", "num_citations": "462\n", "authors": ["262"]}
{"title": "Parametricity and local variables\n", "abstract": " We propose that the phenomenon of local state may be understood in terms of Strachey\u2019s concept of parametric (i.e., uniform) polymorphism. The intuitive basis for our proposal is the following analogy: a non-local procedure is independent of locally-declared variables in the same way that a parametrically polymorphic function is independent of types to which it is instantiated.", "num_citations": "162\n", "authors": ["262"]}
{"title": "ALGOL-like Languages\n", "abstract": " To construct a compiler for a modern higher-level programming languagel one needs to structure the translation to a machine-like intermediate language in a way that reflects the semantics of the language. little is said about such struc turing in compiler texts that are intended to cover a wide variety of program ming languages. More is said in the Iiterature on semantics-directed compiler construction [1] but here too the viewpoint is very general (though limited to 1 languages with a finite number of syntactic types). On the other handl there is a considerable body of work using the continuation-passing transformation to structure compilers for the specific case of call-by-value languages such as SCHEME and ML [21 3]. ln this paperl we will describe a method of structuring the translation of ALGOL-like languages that is based on the functor-category semantics devel oped by Reynolds [4] and Oles [51 6]. An alternative approach using category theory to structure compilers is the early work of FL Morris [7] 1 which anticipates our treatment of boolean expressionsl but does not deal with procedures. 2 Types and Syntax An ALGOL-like language is a typed lambda calculus with an unusual repertoire of primitive types. Throughout most of this paper we assume that the primi tive types are comm (and) int (eger) exp (ression) int (eger) acc (eptor) int (eger) var (iable) I and that the set 8 of types is the least set containing these primitive types and closed under the binary operation-.", "num_citations": "141\n", "authors": ["262"]}
{"title": "On bunched typing\n", "abstract": " We study a typing scheme derived from a semantic situation where a single category possesses several closed structures, corresponding to different varieties of function type. In this scheme typing contexts are trees built from two (or more) binary combining operations, or in short, bunches. Bunched typing and its logical counterpart, bunched implications, have arisen in joint work of the author and David Pym. The present paper gives a basic account of the type system, and then focusses on concrete models that illustrate how it may be understood in terms of resource access and sharing. The most basic system has two context-combining operations, and the structural rules of Weakening and Contraction are allowed for one but not the other. This system includes a multiplicative, or substructural, function type \u2212\u2217 alongside the usual (additive) function type inear, binder. We show that the features of this system are, in a\u00a0\u2026", "num_citations": "102\n", "authors": ["262"]}
{"title": "From Algol to polymorphic linear lambda-calculus\n", "abstract": " In a linearly-typed functional language, one can define functions that consume their arguments in the process of computing their results. This is reminiscent of state transformations in imperative languages, where execition of an assignment statement alters the contents of the store. We explore this connection by translating two variations on Algol 60 into a purely functional language with polymorphic linear types. On the one hand, the translations lead to a semantic analysis of Algol-like programs, in terms of a model of the linear language. On the other hand, they demonstrate that a linearly-typed functional language can be at least as expressive as Algol.", "num_citations": "93\n", "authors": ["262"]}
{"title": "Modular verification of a non-blocking stack\n", "abstract": " This paper contributes to the development of techniques for the modular proof of programs that include concurrent algorithms. We present a proof of a non-blocking concurrent algorithm, which provides a shared stack. The inter-thread interference, which is essential to the algorithm, is confined in the proof and the specification to the modular operations, which perform push and pop on the stack. This is achieved by the mechanisms of separation logic. The effect is that inter-thread interference does not pollute specification or verification of clients of the stack.", "num_citations": "87\n", "authors": ["262"]}
{"title": "Kripke logical relations and PCF\n", "abstract": " Sieber has described a model of PCF consisting of continuous functions that are invariant under certain (finitary) logical relations, and shown that it is fully abstract for closed terms of up to third-order types. We show that one may achieve full abstraction at all types using a form of \"Kripke logical relations\" introduced by Jung and Tiuryn to characterize \u03bb-definability.", "num_citations": "87\n", "authors": ["262"]}
{"title": "Syntactic control of interference revisited\n", "abstract": " In \u201csyntactic control of interference\u201d (POPL, 1978), J.C. Reynolds proposes three design principles intended to constrain the scope of imperative state effects in Algol-like languages. The resulting linguistic framework seems to be a very satisfactory way of combining functional and imperative concepts, having the desirable attributes of both purely functional languages (such as PCF) and simple imperative languages (such as the language of while programs). However, Reynolds points out that the \u201cobvious\u201d syntax for interference control has the unfortunate property that \u03b2-reductions do not always preserve typings. Reynolds has subsequently presented a solution to this problem (ICALP, 1989), but it is fairly complicated and requires intersection types in the type system. Here, we present a much simpler solution which does not require intersection types. We first describe a new type system inspired in part by linear\u00a0\u2026", "num_citations": "75\n", "authors": ["262"]}
{"title": "Semantics of local variables\n", "abstract": " This expository article discusses recent progress on the problem of giving sufficiently abstract semantics to local-variable declarations in Algol-like languages, especially work using categorical methods.", "num_citations": "71\n", "authors": ["262"]}
{"title": "Domains and denotational semantics: History, accomplishments and open problems\n", "abstract": " In this collection we try to give an overview of some selected topics in Domain Theory and Denotational Semantics. In doing so, we rst survey the mathematical universes which have been used as semantic domains. The emphasis is on those ordered structures which have been introduced by Dana Scott in 1969 and which gure under the name (Scott-) domains. After surveying developments in the concrete theory of domains we describe two newer developments, the axiomatic and the synthetic approach. In the second part we look at three computational phenomena in detail, namely, sequential computation, polymorphism, and mutable state, and at the challenges that these pose for a mathematical model.This presentation does by no means exhaust the various approaches to denotational semantics and it certainly does not describe all possible mathematical techniques which have been used to describe various aspects of programs. We hope that, nevertheless, it illustrates how a particular challenge (namely the modelling of recursive de nitions) has given rise to an immensely rich theory, both in its general parts and in its applications. Let us start with a few general remarks. Denotational semantics has traditionally been described as the theory of true meanings for programs, or, to put it more poignantly, as the theory of what programs denote. In many cases, denotations have been built with the help of functions in some mathematical universe and so this position presupposes that the ontological status of sets and functions is rmly established. But there has always been an alternative viewpoint in which denotational semantics is seen as a\u00a0\u2026", "num_citations": "70\n", "authors": ["262"]}
{"title": "Relational parametricity and local variables\n", "abstract": " JC Reynolds has argued that Strachey's intuitive concept of\" parametric\"(ie, uniform) polymorphism has essentially to do with representation independence in the programming of data representations, and demonstrated that logical relations could be used to formalize this principle in languages with type variables and user-defined types.Here, we use relational parametricity to address long-standing problems with the semantics of local-variable declarations in Algol-like languages. The new model is based on a cartesian closed category of\" relation-preserving\" functors and natural transformations which is induced by a suitable category of\" possible worlds\" with relations assigned to its objects and morphisms. The semantic interpretation supports straightforward validations of all the test equivalences that have been proposed in the literature; however, it is not known whether it is fully abstract.", "num_citations": "68\n", "authors": ["262"]}
{"title": "Separation Logic\n", "abstract": " Separation logic is a key development in formal reasoning about programs, opening up new lines of attack on longstanding problems.", "num_citations": "63\n", "authors": ["262"]}
{"title": "Concurrent separation logic\n", "abstract": " Concurrent Separation Logic (CSL) was originally advanced in papers of the authors published in Theoretical Computer Science for John Reynolds's 70th Birthday Festschrift (2007). Preliminary versions appeared as invited papers in the CONCUR'04 conference proceedings. Foundational work leading to these papers began in 2002. Since then there have been significant developments stemming from CSL, both in theoretical and practical research. In this retrospective paper we describe the main ideas that underpin CSL, placing these ideas into historical context by summarizing the prevailing tendencies in concurrency verification and programming language semantics when the logic was being invented in 2002-2003. We end with a snapshot of the state-of-the-art as of 2016. Along the way we describe some of the main developments in the intervening period, and we attempt to classify the work that has been\u00a0\u2026", "num_citations": "60\n", "authors": ["262"]}
{"title": "Continuous reasoning: Scaling the impact of formal methods\n", "abstract": " This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry. We suggest that advances in continuous reasoning will allow formal reasoning to scale to more programs, and more programmers. The paper describes the rationale for continuous reasoning, outlines some success cases from within industry, and proposes directions for work by the scientific community.", "num_citations": "51\n", "authors": ["262"]}
{"title": "Syntactic control of interference revisited\n", "abstract": " In \u201cSyntactic Control of Interference\u201d (POPL, 1978), J. C. Reynolds proposes three design principles intended to constrain the scope of imperative state effects in Algol-like languages. The resulting linguistic framework seems to be a very satisfactory way of combining functional and imperative concepts, having the desirable attributes of both purely functional languages (such as PCF) and simple imperative languages (such as the language of while programs).However, Reynolds points out that an \u201cobvious\u201d syntax for interference control has the unfortunate property that \u03b2-reductions do not always preserve typings. Reynolds has subsequently presented a solution to this problem (ICALP, 1989), but it is fairly complicated and requires intersection types in the type system. Here, we present a much simpler solution which does not require intersection types.We first describe a new type system inspired in part by linear\u00a0\u2026", "num_citations": "51\n", "authors": ["262"]}
{"title": "Local reasoning, separation and aliasing\n", "abstract": " Structures built by pointer aliasing, such as DAGs and graphs, are notoriously tricky to deal with. The mechanisms of separation logic can deal with these structures, but so far this has been done by the maintenance of a global invariant. Specifications and proofs which use local reasoning, and which may point the way to a structured programming for pointers, are discussed. An idiom for inclusion sharing, where one structure is included in another, is presented. A notion of \u2018partial graphs\u2019\u2013graphs with dangling pointers\u2013is used to facilitate proof.", "num_citations": "49\n", "authors": ["262"]}
{"title": "A Primer on Separation Logic (and Automatic Program Verification and Analysis).\n", "abstract": " These are the notes to accompany a course at the Marktoberdorf PhD summer school in 2011. The course consists of an introduction to separation logic, with a slant towards its use in automatic program verification and analysis.", "num_citations": "44\n", "authors": ["262"]}
{"title": "A model for syntactic control of interference\n", "abstract": " Two imperative programming language phrases interfere when one writes to a storage variable that the other reads from or writes to. Reynolds has described an elegant linguistic approach to controlling interference in which a refinement of typed \u03bb-calculus is used to limit sharing of storage variables; in particular, different identifiers are required never to interfere. This paper examines semantic foundations of the approach.We describe a category that has (an abstraction of) interference information built into all objects and maps. This information is used to define a \u2018tensor\u2019 product whose components are required never to interfere. Environments are defined using the tensor, and procedure types are obtained via a suitable adjunction. The category is a model of intuitionistic linear logic. Reynolds' concept of passive type - i.e. types for phrases that do not write to any storage variables - is shown to be closely related, in\u00a0\u2026", "num_citations": "40\n", "authors": ["262"]}
{"title": "Semantical analysis of specification logic, 2\n", "abstract": " The \"specification logic\" of J. C. Reynolds (in \"Tools and Notions for Program Construction\" (D. N\u00e9el, Ed.), pp. 121-161, Cambridge Univ. Press, Cambridge, 1982) is a formal system for proving partial-correctness properties of programs in an Algol-like language with higher-order procedures. In a previous publication (Tennent, Inform. and Comput.85, 135-162 (1990)), a model was presented that validates all axioms of the system except those involving non-interference formulas for procedural phrases. Following Reynolds, non-interference for procedural phrases was there defined syntactically, by induction on types. Here, we present a new semantic interpretation of non-interference (for phrases of arbitrary type) which is equivalent to the interpretation given earlier for phrases of basic type. This interpretation provides the first model for all of Reynold\u2032s axioms (except the equivalences formerly used to define\u00a0\u2026", "num_citations": "40\n", "authors": ["262"]}
{"title": "Semantic analysis of pointer aliasing, allocation and disposal in Hoare logic\n", "abstract": " Bornat has recently described an approach to reasoning about pointers, building on work of Morris. Here we describe a semantics that validates the approach, and use it to help devise axioms for operations that allocate and dispose of memory.", "num_citations": "39\n", "authors": ["262"]}
{"title": "Linear logic and interference control\n", "abstract": " Two imperative programming language phrases interfere when one writes to a storage variable (or location, or memory cell) that the other reads from or writes to. Reynolds' syntactic control of interference (SCI) is a linguistic approach to controlling interference in Algol-like languages ([Rey78, 89]). Girard's Linear Logic (LL) is often described as a logical approach to exercising control over resources ([Gir87, 89]). In this report we will show that constraints arising from LL-or more precisely, Intuitionistic Linear Logic (ILL) with Weakening-control access to the (updatable) state in a manner very similar to SCI. To do this, we consider a simple language with an ILL-based type system, which we illustrate by treating a number of typical examples of interference control.The most interesting aspect of our work is that it suggests a substantive connection between SCI and linear functional programming, as set out in [Laf88\u00a0\u2026", "num_citations": "38\n", "authors": ["262"]}
{"title": "Program logic and equivalence in the presence of garbage collection\n", "abstract": " It is generally thought that reasoning about programs in memory safe, garbage collected languages is much easier than in languages where the programmer has more explicit control over memory. Paradoxically, existing program logics are based on a low-level view of storage that is sensitive to the presence or absence of unreachable cells, and Reynolds has pointed out that the Hoare triples derivable in these logics are even incompatible with garbage collection. We present a study of a small language whose operational semantics includes a rule for reclaiming garbage. Our main results include an analysis of propositions that are garbage insensitive, and full abstraction results connecting partial and total correctness to two natural notions of observational equivalence between programs.", "num_citations": "36\n", "authors": ["262"]}
{"title": "Objects, interference, and the Yoneda embedding\n", "abstract": " We present a new semantics for Algol-like languages that combines methods from two prior lines of development:\u2022 the object-based approach of Reddy, where the meaning of an imperative program is described in terms of sequences of observable actions, and\u2022 the functor-category approach initiated by Reynolds, where the varying nature of the run-time stack is explained using functors from a category of store shapes to a category of cpos. The semantics gives an account of both the phemomena of local state and irreversibility of state change. As an indication of the accuracy obtained, we present a full abstraction result for closed terms of second-order type in a language containing active expressions, ie value-returning commands. c 1999 Published by Elsevier Science BV All rights reserved.", "num_citations": "36\n", "authors": ["262"]}
{"title": "Bireflectivity\n", "abstract": " Motivated by a model for syntactic control of interference, we introduce a general categorical concept of bireflectivity. Bireflective subcategories of a category A are subcategories with left and right adjoint equal, subject to a coherence condition. We characterise them in terms of split-idempotent natural transformations on id A. In the special case that A is a presheaf category, we characterise them in terms of the domain, and prove that any bireflective subcategory of A is itself a presheaf category. We define diagonal structure on a symmetric monoidal category which is still more general than asking the tensor product to be the categorical product. We then obtain a bireflective subcategory of [C op, Set] and deduce results relating its finite product structure with the monoidal structure of [C op, Set] determined by that of C. We also investigate the closed structure. Finally, for completeness, we give results on bireflective\u00a0\u2026", "num_citations": "30\n", "authors": ["262"]}
{"title": "Incorrectness logic\n", "abstract": " Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness.", "num_citations": "28\n", "authors": ["262"]}
{"title": "Resource interpretations, bunched implications and the \u03b1\u03bb-calculus (preliminary version)\n", "abstract": " We introduce the \u03b1\u03bb-calculus, a typed calculus that includes a multiplicative function type -* alongside an additive function type \u2192. It arises proof-theoretically as a calculus of proof terms for the logic of bunched implications of O\u2019Hearn and Pym, and semantically from doubly closed categories, where a single category possesses two closed structures. Typing contexts in \u03b1\u03bb are bunches, i.e., trees built from two combining operations, one that admits the structural rules of Weakening and Contraction and another that does not. To illuminate the consequences of \u03b1\u03bb\u2019s approach to the structural rules we define two resource interpretations, extracted from Reynolds\u2019s \u201csharing reading\u201d of affine \u03bb-calculus. Based on this we show how \u03b1\u03bb enables syntactic control of interference and Idealized Algol, imperative languages based on affine and simply-typed \u03bb-calculi, to be smoothly combined in one system.", "num_citations": "27\n", "authors": ["262"]}
{"title": "Resolution in the domain of strongly finite logics\n", "abstract": " In this paper the notion of a resolution counterpart of a propositional logic is introduced and studied. This notion is based on a generalization of the resolution rule of JA Robinson. It is shown that for every strongly finite logic a refutationally complete nonclausal resolution proof system can be constructed and that the completeness of such systems is preserved with respect to the polarity and set of support strategies.", "num_citations": "24\n", "authors": ["262"]}
{"title": "A resolution framework for finitely-valued first-order logics\n", "abstract": " In this paper we propose a resolution proof framework on the basis of which automated proof systems for finitely-valued first-order logics (FFO logics) can be introduced and studied. We define the notion of a first-order resolution proof system and we show that for every disjunctive FFO logic a refutationally complete resolution proof system can be constructed. Moreover, we discuss two theorem proving strategies, the polarity and set of support strategies, and we prove their completeness.", "num_citations": "23\n", "authors": ["262"]}
{"title": "Why separation logic works\n", "abstract": " One might poetically muse that computers have the essence both of logic and machines. Through the case of the history of Separation Logic, we explore how this assertion is more than idle poetry. Separation Logic works because it merges the software engineer\u2019s conceptual model of a program\u2019s manipulation of computer memory with the logical model that interprets what sentences in the logic are true, and because it has a proof theory which aids in the crucial problem of scaling the reasoning task. Scalability is a central problem, and some would even say the central problem, in appli- cations of logic in computer science. Separation Logic is an interesting case because of its widespread success in verification tools. For these two senses of model\u2014the engineering/conceptual and the logical\u2014to merge in a genuine sense, each must maintain their norms of use from their home disciplines. When this occurs\u00a0\u2026", "num_citations": "21\n", "authors": ["262"]}
{"title": "Refinement and separation contexts\n", "abstract": " A separation context is a client program which does not dereference internals of a module with which it interacts. We use certain \u201cprecise\u201d relations to unambiguously describe the storage of a module and prove that separation contexts preserve such relations. We also show that a simulation theorem holds for separation contexts, while this is not the case for arbitrary client programs.", "num_citations": "21\n", "authors": ["262"]}
{"title": "Semantics of noninterference: A natural approach.\n", "abstract": " Degree: Ph. D.DegreeYear: 1990Institute: Queen''s University at Kingston (Canada)This thesis examines noninterference in imperative Algol-like languages. Noninterference is fairly well understood for simple phrases (like commands) that can be executed directly: two simple phrases don''t interfere iff the evaluation or execution of one has no effect on the other. But procedures are not as straightforward because they must be supplied with arguments before being executed. The subtlety for procedural noninterference arises from the need to distinguish between interference that is a result of using arguments to a call and interference that is attributable to the procedure itself. Because of this subtlety, previous semantical approaches to noninterference suffer from various anomalies.", "num_citations": "20\n", "authors": ["262"]}
{"title": "On the relation between concurrent separation logic and concurrent Kleene algebra\n", "abstract": " We investigate the connection between a general form of Concurrent Separation Logic (CSL), a logic for modular reasoning about concurrent programs, and Concurrent Kleene Algebra (CKA), which provides an axiomatic approach to models of concurrency. We show how the proof theory of a general form of CSL can be embedded in a variation on the notion of CKA. Our embedding, however, induces models of a particular form based on predicate transformers. We also investigate the relation between concrete models of CSL based on interleaving of traces and CKA. We find, curiously, that the validity of CSL's Concurrency proof rule in these models does not follow from or otherwise utilize CKA structure, but that a CKA structure exists nonetheless which can give a different model of the CSL proof rules.Our results can be read as providing a completeness theorem showing a sense in which nothing is missing as far\u00a0\u2026", "num_citations": "15\n", "authors": ["262"]}
{"title": "Note on theorem proving strategies for resolution counterparts of non-classical logics\n", "abstract": " Resolution proof systems, ie deductive systems based on Robinson\u2019s resolution principle [8], have attracted a great deal of attention in connection with numerous applications of logical systems and logic based methodologies in computer science, especially in artificial intelligence, logics of programs, and the analysis of distributed systems (cf.[1, 3-5,121). Th ee ffi ciency and usefulness of automated proof systems can be greatly enhanced by restricting and directing the application of inference rules, that is by applying theorem proving strategies. Although such strategies have received much attention in automated proof systems for the classical logic (cf.[5, 6, 13, 14]), relatively little is known about restriction strategies for resolution counterparts of non-classical logics. The aim of this paper is to show that two of the more powerful speed-up techniques available for the cla. ssical first-order logic, namely the set of support\u00a0\u2026", "num_citations": "15\n", "authors": ["262"]}
{"title": "Reasoning about shared mutable data structure\n", "abstract": " Reasoning about Shared Mutable Data Structure Page 1 Reasoning about Shared Mutable Data Structure John C. Reynolds Department of Computer Science Carnegie Mellon University and Peter W. O'Hearn Department of Computer Science Queen Mary and West eld College January 15, 2001 (corrected January 23, 2001) 1 Page 2 2 Basic Ideas Extention of Hoare logic for imperative programs Store/heap dichotomy Heap-manipulation commands (not expressions) Independent conjunction ( ) Unrestricted address arithmetic Heap faults Nondeterministic allocation Inductive de nitions over abstract structures Page 3 3 New Commands hcommi::= jhvari:= cons(hexpi;:::;hexpi) jhvari:= hexpi] jhexpi] := hexpi jdisposehexpi New Assertions hasserti::= jhexpi7! hexpi jemptyheap jhasserti hasserti jhasserti hasserti Why cons, car, and cdr do not occur in expressions (x = x)=x !cons(1;2) is cons(1;2) = cons(1;2) (x = x y = y)=!'\u2026", "num_citations": "14\n", "authors": ["262"]}
{"title": "The complexity of abduction for separated heap abstractions\n", "abstract": " Abduction, the problem of discovering hypotheses that support a conclusion, has mainly been studied in the context of philosophical logic and Artificial Intelligence. Recently, it was used in a compositional program analysis based on separation logic that discovers (partial) pre/post specifications for un-annotated code which approximates memory requirements. Although promising practical results have been obtained, completeness issues and the computational hardness of the problem have not been studied. We consider a fragment of separation logic that is representative of applications in program analysis, and we study the complexity of searching for feasible solutions to abduction. We show that standard entailment is decidable in polynomial time, while abduction ranges from NP-complete to polynomial time for different sub-problems.", "num_citations": "12\n", "authors": ["262"]}
{"title": "On garbage and program logic\n", "abstract": " Garbage collection relieves the programmer of the burden of managing dynamically allocated memory, by providing an automatic way to reclaim unneeded storage. This eliminates or lessens program errors that arise from attempts to access disposed memory, and generally leads to simpler programs. One might therefore expect that reasoning about programs in garbage collected languages would be much easier than in languages where the programmer has more explicit control over memory. But existing program logics are based on a low level view of storage that is sensitive to the presence or absence of unreachable cells, and Reynolds has pointed out that the Hoare triples derivable in these logics are even incompatible with garbage collection. We present a semantics of program logic assertions based on a view of the heap as finite, but extensible; this is for a logical language with primitives for\u00a0\u2026", "num_citations": "11\n", "authors": ["262"]}
{"title": "From categorical logic to Facebook engineering\n", "abstract": " I chart a line of development from category-theoretic models of programs and logics to automatic program verification/analysis techniques that are in deployment at Facebook. Our journey takes in a number of concepts from the computer science logician's toolkit -- including categorical logic and model theory, denotational semantics, the Curry-Howard isomorphism, sub structural logic, Hoare Logic and Separation Logic, abstract interpretation, compositional program analysis, the frame problem, and abductive inference.", "num_citations": "10\n", "authors": ["262"]}
{"title": "Notes on separation logic for shared-variable concurrency\n", "abstract": " Introduction These notes record some ideas on adapting the storage separation logic of [9, 5, 7] to concurrency. We give obvious variants of the usual rules for conditional critical regions (CCRs)[2, 8], using to rule out interference through the heap. We could similarly use to adapt proof rules for monitors [3, 4, 1]. With the modi ed CCR rules we can at once handle many simple examples where a linked data structure rather than, say, an array is used to represent a resource that itself holds pointerfree data. Although the rules themselves are obvious, they have an interesting eect when the resource keeps track of pointers as part of its data, rather than just as part of its implementation. The connective allows us to partition memory in a dynamically recon gurable way, extending the static partioning done by CCRs or monitors when there is no heap. This enables us to handle a number of subtler examples, where a pointer is transferred from one process to another, or between", "num_citations": "9\n", "authors": ["262"]}
{"title": "Note on Algol and conservatively extending functional programming\n", "abstract": " A simple Idealized Algol is considered, based on Reynolds's \u2018essence of Algol\u2019. It is shown that observational equivalence in this language conservatively extends observational equivalence in its assignment-free functional sublanguage.", "num_citations": "9\n", "authors": ["262"]}
{"title": "Experience developing and deploying concurrency analysis at Facebook\n", "abstract": " This paper tells the story of the development of RacerD, a static program analysis for detecting data races that is in production at Facebook. The technical details of RacerD are described in a separate paper; we concentrate here on how the project unfolded from a human point of view. The paper describes, in this specific case, the benefits of feedback between science and engineering, the tension encountered between principle and compromise, and how being flexible and adaptable in the presence of a changing engineering context can lead to surprising results which far exceed initial expectations. I hope to give the reader an impression of what it is like to develop advanced static analyses in industry, how it is both different from and similar to developing analyses for the purpose of advancing science.", "num_citations": "7\n", "authors": ["262"]}
{"title": "Tutorial on separation logic (invited tutorial)\n", "abstract": " Separation logic is an extension of Hoare\u2019s logic for reasoning about programs that manipulate pointers. Its assertion language extends classical logic with a separating conjunction operator A*B, which asserts that A and B hold for separate portions of memory.               In this tutorial I will first cover the basics of the logic, concentrating on highlights from the early work [1,2,3,4].               (i) The separating conjunction fits together with inductive definitions in a way that supports natural descriptions of mutable data structures [1].               (ii) Axiomatizations of pointer operations support in-place reasoning, where a portion of a formula is updated in place when passing from precondition to postcondition, mirroring the operational locality of heap update [1,2].               (iii) Notorious \u201cdirty\u201d features of low-level programming (pointer arithmetic, explicit deallocation) are dealt with smoothly, even embraced [2,3].               (iv\u00a0\u2026", "num_citations": "7\n", "authors": ["262"]}
{"title": "Separation logic and concurrent resource management\n", "abstract": " Concurrent separation logic provides a way of reasoning about the usage of resources in concurrent programs. Proofs in the logic all track the transfer of ownership of portions of memory between concurrent processes, mirroring design principles for concurrent systems programs. This allows the safe treatment of\" daring\" concurrent programs, that access shared memory without explicit protection, outside of critical sections; canonical examples of such daring concurrency are resource managers of various kinds. In this talk I will describe the underpinnings of the concurrent separation logic, andallillustrate it with experimental tools--SMALLFOOT and SPACE INVADER--that are being developed to do automatic proofs with the logic.", "num_citations": "6\n", "authors": ["262"]}
{"title": "Fully abstract translations and parametric polymorphism\n", "abstract": " We examine three languages: call-by-name PCF; an idealized version of Algol called IA; and a call-by-name version of the functional core of ML with a parallel conditional, called PPCF+XML. Syntactic translations from PCF and IA into PPCF+XML are given and shown to be fully abstract, in the sense that they preserve and reflect observational equivalence. We believe that these results suggest the potential unifying force of Strachey's concept of parametric polymorphism.", "num_citations": "6\n", "authors": ["262"]}
{"title": "Verification condition generation and variable conditions in Smallfoot\n", "abstract": " These notes are a companion to [1] which describe - the variable conditions that Smallfoot checks, - the analysis used to check them, - the algorithm used to compute a set of verification conditions corresponding to an annotated program, and - the treatment of concurrent resource initialization code.", "num_citations": "5\n", "authors": ["262"]}
{"title": "Bunches, typed lambda-calculus and interference control\n", "abstract": " and a multiplicative implication. We rst dene the-calculus, a typed-calculus based on BI, and look at some properties of its models. We then show how the calculus allows Syntactic Control of Interference and Idealized Algol, two imperative languages dened by John Reynolds in the late seventies and early eighties, to be combined smoothly. The combination is achieved by using the additive implication for Algol\u2019s function types and the multiplicative implication for the functions of Syntactic Control.", "num_citations": "5\n", "authors": ["262"]}
{"title": "Abductive, inductive and deductive reasoning about resources\n", "abstract": " We describe a method for reasoning about programs that uses a mixture of abductive, inductive and deductive inference. It allows us to synthesize a pre/post spec for a program procedure, without requiring any information about the procedure\u2019s calling context. The method can be used to obtain partial specifications for portions of large code bases in the millions of lines of code.", "num_citations": "4\n", "authors": ["262"]}
{"title": "Algebra, logic, locality, concurrency\n", "abstract": " This talk reports on ongoing work - with Tony Hoare, Akbar Hussain, Bernhard M\u00f6ller, Rasmus Petersen, Georg Struth, Ian Wehrman, and others - on models and logics for concurrent processes [10,6,5]. The approach we are taking abstracts from syntax or particular models. Message passing and shared memory process interaction, and strong (interleaving) and weak (partial order) approaches to sequencing, are accomodated as different models of the same core axioms. Rules of program logic, related to Hoare and Separation logics, flow at once from the algebraic axioms. So, one gets a generic program logic from the algebra, which holds for a range of concrete models.", "num_citations": "3\n", "authors": ["262"]}
{"title": "Separation logic and program analysis\n", "abstract": " Separation logic is a program logic for reasoning about programs that manipulate pointer data structures. It has a strong form of modularity or locality built in, and has led to simpler by-hand proofs of pointer algorithms than was possible in previous formalisms. It is natural to wonder whether, and in what way, its ideas might be used in program analysis.               In this talk I will begin by describing the basics of separation logic, along the way connecting them to concepts from program analysis. I will then describe some initial, unsuccessful attempts at applying the formalism. This is done in an effort to convey that some of the first ideas at application do not work well, and also to help pin down what some of the central outstanding issues are. This will then lead on to, and partially justify, one way of organizing a program analysis, where the abstract domain is built from formulae in separation logic. Finally, I will\u00a0\u2026", "num_citations": "3\n", "authors": ["262"]}
{"title": "Notes on conditional critical regions in spatial pointer logic\n", "abstract": " These notes record some preliminary ideas on adding conditional critical regions to the spatial pointer logic of [5, 2, 3]. CCRs fit the spatial formalism well because of their assumption that storage be partitioned into memory local to each process and memory for each shared resource. Monitors should also fit well. In what follows we give obvious variants of the usual rules for CCRs [1, 4], using\u2217 to partition heap memory. Our aim here is to show the rules in action: We have not yet proven their soundness, but they do seem reasonable. Although the rules are obvious, they have an interesting effect. When a pointer is transferred from one process to another, the ownership of the storage pointed to can transfer with it. The upshot seems to be that\u2217 allows us to partition memory in a dynamically reconfigurable way, extending the static partioning done by CCRs or monitors when there is no heap. As an example of\u00a0\u2026", "num_citations": "3\n", "authors": ["262"]}
{"title": "Separation logic tutorial\n", "abstract": " Separation logic is an extension of Hoare\u2019s logic for reasoning about programs that manipulate pointers. It is based on the separating conjunction                 P\u2009\u2217\u2009Q, which asserts that P and Q hold for separate portions of computer memory.               This tutorial on separation logic has three parts.                                                                        1                                                                      Basics. Concentrating on highlights from the early work [1,2,3,4].                                                                                1                                                                      Model Theory. The model theory of separation logic evolved from the general resource models of bunched logic [5,6,7] and includes an account of program dynamics in terms of their interaction with resource [8,9].                                                                                1                                                                      Proof Theory. I will describe those aspects of the proof theory, particularly new entailment\u00a0\u2026", "num_citations": "2\n", "authors": ["262"]}
{"title": "Scalable specification and reasoning: Challenges for program logic\n", "abstract": " If program verification tools are ever to be used widely, it is essential that they work in a modular fashion. Otherwise, verification will not scale. This paper discusses the scientific challenges that this poses for research in program logic. Some recent work on separation logic is described, and test problems that would be useful in measuring advances on modular reasoning are suggested.", "num_citations": "2\n", "authors": ["262"]}
{"title": "Scalable specification and reasoning: Technical challenges for program logic\n", "abstract": " If program verification tools are ever to be used widely, it is essential that they work in a modular fashion. Otherwise, verification will not scale. This paper discusses the scientific challenges that this poses for research in program logic, and suggests some test problems that would be useful in measuring advances on modular reasoning.", "num_citations": "2\n", "authors": ["262"]}
{"title": "Strong update, disposal and encapsulation in bunched typing\n", "abstract": " We present a bunched intermediate language for strong (type-changing) update and disposal of first-order references. In contrast to other substructural type systems, the additive constructs of bunched types allow the encapsulation of state that is shared by a collection of procedures. Key words: bunched typing, separation logic, strong update, disposal, encapsulation, continuation-passing style 1", "num_citations": "2\n", "authors": ["262"]}
{"title": "Formal reasoning and the hacker way (keynote)\n", "abstract": " In 2013 I moved from to industry after over 25 years in academia, when Facebook acquired a verification startup, Monoidics, that I was involved with. In this talk I\u2019ll recount the clash of cultures I encountered, where traditionally calm and cool formal reasoning techniques came in contact with a heated software development methodology based on rapid modification of large codebases (thousands of modifications per day on 10s MLOC). I will tell how we found that static formal reasoning could thrive, if certain technical approaches (based on compositionality), how the industrial experience caused me to question some of the assumptions I learned in academic static analysis, and how I\u2019ve come out the other side with new science spurred by that experience (most recently, incorrectness logic). Overall, I hope to convey that having science and engineering playing off one another in a tight feedback loop is possible, even\u00a0\u2026", "num_citations": "1\n", "authors": ["262"]}
{"title": "The essence of Reynolds\n", "abstract": " John Reynolds (1935-2013) was a pioneer of programming languages research. In this paper we pay tribute to the man, his ideas, and his influence.", "num_citations": "1\n", "authors": ["262"]}
{"title": "Proceedings of the Third international conference on Verified software: theories, tools, experiments\n", "abstract": " Proceedings of the Third international conference on Verified software: theories, tools, experiments | Guide Proceedings ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsVSTTE'10 ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide Proceedings cover image VSTTE'10: Proceedings of the Third international conference on Verified software: theories, tools, experiments August 2010 215 pages ISBN:364215056X Editors: Gary T. ''\u2026", "num_citations": "1\n", "authors": ["262"]}
{"title": "Petri Net Semantics of Bunched Implications\n", "abstract": " Engberg and Winskel's Petri net semantics of linear logic is re-considered, from the point of view of the logic BI of bunched implications. We rst show how BI can be used to overcome a number of di culties pointed out by Engberg and Winskel, and we argue that it provides a more natural logic for the net semantics. We then brie y consider a more expressive logic based on an extension of BI with classical and modal features.", "num_citations": "1\n", "authors": ["262"]}