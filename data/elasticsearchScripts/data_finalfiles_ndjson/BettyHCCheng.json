{"title": "Research directions in requirements engineering\n", "abstract": " In this paper, we review current requirements engineering (RE) research and identify future research directions suggested by emerging software needs. First, we overview the state of the art in RE research. The research is considered with respect to technologies developed to address specific requirements tasks, such as elicitation, modeling, and analysis. Such a review enables us to identify mature areas of research, as well as areas that warrant further investigation. Next, we review several strategies for performing and extending RE research results, to help delineate the scope of future research directions. Finally, we highlight what we consider to be the \"hot\" current and future research topics, which aim to address RE needs for emerging systems of the future.", "num_citations": "927\n", "authors": ["539"]}
{"title": "Composing adaptive software\n", "abstract": " Interest in adaptive computing systems has increased dramatically in the past few years, and a variety of techniques now allow software to adapt dynamically to its environment. Compositional adaptation enables software to modify its structure and behavior dynamically in response to change in its execution environment. A review of current technology compares how, when, and where recomposition occurs.", "num_citations": "907\n", "authors": ["539"]}
{"title": "Model-based development of dynamically adaptive software\n", "abstract": " Increasingly, software should dynamically adapt its behavior at run-time in response to changing conditions in the supporting computing and communication infrastructure, and in the surrounding physical environment. In order for an adaptive program to be trusted, it is important to have mechanisms to ensure that the program functions correctly during and after adaptations. Adaptive programs are generally more difficult to specify, verify, and validate due to their high complexity. Particularly, when involving multi-threaded adaptations, the program behavior is the result of the collaborative behavior of multiple threads and software components. This paper introduces an approach to create formal models for the behavior of adaptive programs. Our approach separates the adaptation behavior and non-adaptive behavior specifications of adaptive programs, making the models easier to specify and more amenable to\u00a0\u2026", "num_citations": "548\n", "authors": ["539"]}
{"title": "Real-time specification patterns\n", "abstract": " Embedded systems are pervasive and frequently used for critical systems with time-dependent functionality. Dwyer et al have developed qualitative specification patterns to facilitate the specification of critical properties, such as those that must be satisfied by embedded systems. Thus far, no analogous repository has been compiled for real-time specification patterns. This paper makes two main contributions: First, based on an analysis of timing-based requirements of several industrial embedded system applications, we created real-time specification patterns in terms of three commonly used real-time temporal logics. Second, as a means to further facilitate the understanding of the meaning of a specification, we offer a structured English grammar that includes support for real-time properties. We illustrate the use of the real-time specification patterns in the context of property specifications of a real-world automotive\u00a0\u2026", "num_citations": "388\n", "authors": ["539"]}
{"title": "A formal semantics for object model diagrams\n", "abstract": " Informal software development techniques, such as the object modeling technique (OMT), provide the user with easy to understand graphical notations for expressing a wide variety of concepts central to the presentation of software requirements. OMT combines three complementary diagramming notations for documenting requirements: object models, dynamic models, and functional models. OMT is a useful organizational tool in the requirements analysis and system design processes. Currently, the lack of formality in OMT prevents the evaluation of completeness, consistency, and content in requirements and design specifications. A formal method is a mathematical approach to software development that begins with the construction of a formal specification describing the system under development. However, constructing a formal specification directly from a prose description of requirements can be challenging\u00a0\u2026", "num_citations": "315\n", "authors": ["539"]}
{"title": "A general framework for formalizing UML with formal languages\n", "abstract": " Informal and graphical modeling techniques enable developers to construct abstract representations of systems. Object-oriented modeling techniques further facilitate the development process. The Unified Modeling Language (UML), an object-oriented modeling approach, could be broad enough in scope to represent a variety of domains and gain widespread use. Currently, UML comprises several different notations with no formal semantics attached to the individual diagrams. Therefore, it is not possible to apply rigorous automated analysis or to execute a UML model in order to test its behavior: short of writing code and performing exhaustive testing. We introduce a general framework for formalizing a subset of UML diagrams in terms of different formal languages based on a homomorphic mapping between meta models describing UML and the formal language. This framework enables the construction of a\u00a0\u2026", "num_citations": "252\n", "authors": ["539"]}
{"title": "Design patterns for developing dynamically adaptive systems\n", "abstract": " Increasingly, software systems should self-adapt to satisfy new requirements and environmental conditions that may arise after deployment. Due to their high complexity, adaptive programs are difficult to specify, design, verify, and validate. Moreover, the current lack of reusable design expertise that can be leveraged from one adaptive system to another further exacerbates the problem. We studied over thirty adaptation-related research and project implementations available from the literature and open sources to harvest adaptation-oriented design patterns that support the development of adaptive systems. These adaptation-oriented patterns facilitate the separate development of the functional and adaptive logic. In order to support the assurance of adaptive systems, each design pattern includes templates that formally specify invariant properties of adaptive systems. To demonstrate their usefulness, we have\u00a0\u2026", "num_citations": "190\n", "authors": ["539"]}
{"title": "Using security patterns to model and analyze security requirements\n", "abstract": " Recently, there has been growing interest in identifying patterns for the domain of system security, termed security patterns. Currently, those patterns lack comprehensive structure that conveys essential information inherent to security engineering. This paper describes research into investigating an appropriate template for security patterns that is tailored to meet the needs of secure systems development. In order to maximize comprehensibility, we make use of well-known notations such as the Unified Modeling Language (UML) to represent structural and behavioral information. Furthermore, we investigate how verification of requirements properties can be enabled by adding formal constraints to the patterns.", "num_citations": "156\n", "authors": ["539"]}
{"title": "Requirements patterns for embedded systems\n", "abstract": " In software engineering, design patterns propose solution skeletons for common design problems. The solution skeleton is described in such a way that the design can be used for other projects, where each application tailors the design to specific project constraints. This paper describes research into investigating how a similar approach to reuse can be applied to requirements specifications, which we term requirements patterns. Specifically, the paper explores how object-oriented modeling notations, such as the Unified Modeling Language (UML), can be used to represent common requirements patterns. Structural and behavioral information are captured as part of a requirements pattern. In order to maximise reuse, we focus on requirements patterns for embedded systems. This paper also describes case studies that illustrate how we have applied these general patterns to multiple embedded systems\u00a0\u2026", "num_citations": "156\n", "authors": ["539"]}
{"title": "A taxonomy of compositional adaptation\n", "abstract": " Driven by the emergence of pervasive computing and the increasing need for self-managed systems, many approaches have been proposed for building software that can dynamically adapt to its environment. These adaptations involve not only changes in program flow, but also run-time recomposition of the software itself. We discuss the supporting technologies that enable dynamic recomposition and classify different approaches according to how, when and where recomposition occurs. We also highlight key challenges that need to be addressed to realize the full potential of run-time adaptable software. This survey is intended to be a living document, updated periodically to summarize and classify new contributions to the field. The document is maintained under the RAPIDware project web site, specifically, at http://www. cse. msu. edu/rapidware/survey.", "num_citations": "154\n", "authors": ["539"]}
{"title": "Specification matching for software reuse: A foundation\n", "abstract": " Using formal specifications to represent software components facilitates the determination of reusability because they more precisely characterize the functionality of the software, and the well-defined syntax makes processing amenable to automation. We present specification matching as a method for classification, retrieval, and modification of reusable components. A software component is specified in terms of order-sorted predicate logic. For both components and methods, we consider not only exact match, but also relaxed match and logical match for peforming specification matching over a library of reusable software components.", "num_citations": "152\n", "authors": ["539"]}
{"title": "The four levels of requirements engineering for and in dynamic adaptive systems\n", "abstract": " The Four Levels of Requirements Engineering for and in Dynamic Adaptive Systems Page 1 The Four Levels of Requirements Engineering for and in Dynamic Adaptive Systems Daniel M. Berry, U Waterloo Betty HC Cheng, Michigan State U Ji Zhang, Michigan State U \u00a9 2005 DM Berry, BHC Cheng, & J. Zhang Requirements Engineering RE for Adaptive Systems Pg. 1 Page 2 Abbreviations DAS = Dynamic Adaptive System RE = Requirements Engineering AR = Adapt-Ready (Adaptation-Ready) \u00a9 2005 DM Berry, BHC Cheng, & J. Zhang Requirements Engineering RE for Adaptive Systems Pg. 2 Page 3 Dynamic Adaptive Systems A DAS is a computer-based system (CBS) that is capable of recognizing that the domain with which it shares an interface has changed and is capable of changing its behavior to adapt to the changing conditions. \u00a9 2005 DM Berry, BHC Cheng, & J. Zhang Requirements Engineering RE \u2026", "num_citations": "130\n", "authors": ["539"]}
{"title": "Modular verification of dynamically adaptive systems\n", "abstract": " Cyber-physical systems increasingly rely on dynamically adaptive programs to respond to changes in their physical environment; examples include ecosystem monitoring and disaster relief systems. These systems are considered high-assurance since errors during execution could result in injury, loss of life, environmental impact, and/or financial loss. In order to facilitate the development and verification of dynamically adaptive systems, we separate functional concerns from adaptive concerns. Specifically, we model a dynamically adaptive program as a collection of (non-adaptive) steady-state programs and a set of adaptations that realize transitions among steady state programs in response to environmental changes. We use Linear Temporal Logic (LTL) to specify properties of the non-adaptive portions of the system, and we use A-LTL (an adapt-operator extension toLTL) to concisely specify properties that hold\u00a0\u2026", "num_citations": "128\n", "authors": ["539"]}
{"title": "An aspect-oriented approach to dynamic adaptation\n", "abstract": " This paper presents an aspect-oriented approach to dynamic adaptation. A systematic process for defining where, when, and how an adaptation is to be incorporated into an application is presented. Specifically, the paper presents a two-phase approach to dynamic adaptation, where the first phase prepares a non-adaptive program for adaptation, and the second phase implements the adaptation at run time. This approach is illustrated with a distributed conferencing application.", "num_citations": "114\n", "authors": ["539"]}
{"title": "Using temporal logic to specify adaptive program semantics\n", "abstract": " Computer software must dynamically adapt to changing conditions. In order to fully realize the benefit of dynamic adaptation, it must be performed correctly. The correctness of adaptation cannot be properly addressed without precisely specifying the requirements for adaptation. This paper introduces an approach to formally specifying adaptation requirements in temporal logic. We introduce A-LTL, an adaptation-based extension to linear temporal logic, and use this logic to specify three commonly used adaptation semantics. Composition techniques are developed and applied to A-LTL to construct the specification of an adaptive program. We introduce adaptation semantics graphs to visually represent the adaptation semantics, which can also be used to automatically generate specification for adaptive programs.", "num_citations": "112\n", "authors": ["539"]}
{"title": "UML-based analysis of embedded systems using a mapping to VHDL\n", "abstract": " Methods for developing and modeling embedded systems and rigorously verifying behavior before committing to code are increasingly important. A number of object-oriented techniques and notations have been introduced but recently, it appears that the Unified Modeling Language (UML) could be a notation broad enough in scope to represent a variety of domains and gain widespread use. Currently, however, UML is only a notation, with no formal semantics attached to the individual diagrams. In order to address this problem, we have developed a framework for deriving VHDL specifications from the class and state diagrams in order to capture the structure and the behavior of embedded systems. The derived VHDL specifications enable us to perform behavior simulation of the UML models.", "num_citations": "107\n", "authors": ["539"]}
{"title": "Optimal multicast communication in wormhole-routed torus networks\n", "abstract": " This paper presents efficient algorithms that implement one-to-many, or multicast, communication in wormhole-routed torus networks. By exploiting the properties of the switching technology and the use of virtual channels, a minimum-time multicast algorithm is presented for n-dimensional torus networks that use deterministic, dimension-ordered routing of unicast messages. The algorithm can deliver a multicast message to m-1 destinations in [log/sub 2/ m] message-passing steps, while avoiding contention among the constituent unicast messages. Performance results of a simulation study on torus networks with up to 4096 nodes are also given.< >", "num_citations": "106\n", "authors": ["539"]}
{"title": "Object analysis patterns for embedded systems\n", "abstract": " Some of the most challenging tasks in building a software system are capturing, refining, and analyzing requirements. How well these tasks are performed significantly impacts the quality of the developed software system. The difficulty of these tasks is greatly exacerbated for the software of embedded systems as these systems are commonly used for critical applications, have to operate reliably for long periods of time, and usually have a high degree of complexity. Current embedded systems software development practice, however, often deals with the (requirements) analysis phase in a superficial manner, instead emphasizing design and implementation. This research investigates how an approach similar to the well-known design patterns, termed object analysis patterns, can be applied in the analysis phase of embedded systems development, prior to design and coding. Specifically, our research explores how\u00a0\u2026", "num_citations": "102\n", "authors": ["539"]}
{"title": "Formalizing and integrating the dynamic model within OMT\n", "abstract": " ABSTRACT The Object Modeling Technique (OMT), a commonly used object-oriented development technique, comprises the object, dynamic, and functional models to provide three complementary views that graphically describe different aspects of systems. The lack of a well-defined semantics for the integration of the three models hinders the overall development process, particularly during the design phase. Previously, we formalized the object model in terms of algebraic specifications. However, the algebraic specifications only capture the static, structural aspects of a system. They do not explicitly describe the behavior, which is critical for system development, especially for the design phase. It is necessary to formalize the dynamic model in terms of the structural descriptions in order to specify and verify the system behavior using rigorous techniques. This paper presents a well-defined formal model for both the\u00a0\u2026", "num_citations": "91\n", "authors": ["539"]}
{"title": "Facilitating the construction of specification pattern-based properties\n", "abstract": " Formal specification languages are often perceived as difficult to use by practitioners, and are therefore rarely-used in industrial software development practices. Numerous researchers have developed specification pattern systems to facilitate the construction of formal specifications of system properties. Feedback indicates that these patterns are considered helpful, but many practitioners prefer capturing properties using informal notations, such as natural language, instead of formal specification languages. This paper describes a project that addresses this technology gap. First, we introduce a stepwise process for deriving and instantiating system properties in terms of their natural language representations. The key components of this process are structured natural language grammars and specification pattern systems. Second, we describe SPIDER, a prototype implementation of a tool suite supporting this\u00a0\u2026", "num_citations": "88\n", "authors": ["539"]}
{"title": "TRAP/J: Transparent generation of adaptable Java programs\n", "abstract": " This paper describes TRAP/J, a software tool that enables new adaptable behavior to be added to existing Java applications transparently (that is, without modifying the application source code and without extending the JVM). The generation process combines behavioral reflection and aspect-oriented programming to achieve this goal. Specifically, TRAP/J enables the developer to select, at compile time, a subset of classes in the existing program that are to be adaptable at run time. TRAP/J then generates specific aspects and reflective classes associated with the selected classes, producing an adapt-ready program. As the program executes, new behavior can be introduced via interfaces to the adaptable classes. A case study is presented in which TRAP/J is used to introduce adaptive behavior to an existing audio-streaming application, enabling it to operate effectively in a lossy wireless network by\u00a0\u2026", "num_citations": "86\n", "authors": ["539"]}
{"title": "Specifying adaptation semantics\n", "abstract": " Computer software must dynamically adapt to changing conditions. In order to fully realize the benefit of dynamic adaptation, it must be performed correctly. The correctness of adaptation cannot be properly addressed without precisely specifying the requirements for adaptation. This paper introduces an approach to formally specifying adaptation requirements in temporal logic. We introduce A-LTL, an adaptation-based extension to linear temporal logic, and use this logic to specify three commonly used adaptation semantics. Neighborhood composition and sequential composition techniques are developed and applied to A-LTL to construct the specification of an adaptive system. We introduce adaptation semantics graphs to visually present the adaptation semantics. Specifications for adaptive systems can be automatically generated from adaptation semantics graphs.", "num_citations": "81\n", "authors": ["539"]}
{"title": "Strongest postcondition semantics as the formal basis for reverse engineering\n", "abstract": " Reverse engineering of program code is the process of constructing a higher level abstraction of an implementation in order to facilitate the understanding of a system that may be in a \u201clegacy\u201d or \u201cgeriatric\u201d state. Changing architectures and improvements in programming methods, including formal methods in software development and object-oriented programming, have prompted a need to reverse engineer and re-engineer program code. This paper describes the application of the strongest postcondition predicate transformer (sp) as the formal basis for the reverse engineering of imperative program code.", "num_citations": "81\n", "authors": ["539"]}
{"title": "A framework for classifying and comparing software reverse engineering and design recovery techniques\n", "abstract": " Several techniques have been suggested for supporting reverse engineering and design recovery activities. While many of these techniques have been cataloged in various collections and surveys, the evaluation of the corresponding support tools has focused primarily on their usability and supported source languages, mostly ignoring evaluation of the appropriateness of the by-products of a tool for facilitating particular types of maintenance tasks. In this paper, we describe criteria that can be used to evaluate tool by-products based on semantic quality, where the semantic quality measures the ability of a by-product to convey certain behavioral information. We use these criteria to review, compare, and contrast several representative tools and approaches.", "num_citations": "77\n", "authors": ["539"]}
{"title": "Amoeba-rt: Run-time verification of adaptive software\n", "abstract": " Increasingly, software must dynamically adapt its behavior in response to changes in the supporting computing, communication infrastructure, and in the surrounding physical environment. Assurance that the adaptive software correctly satisfies its requirements is crucial if the software is to be used in high assurance systems, such as command and control or critical infrastructure protection systems. Adaptive software development for these systems must be grounded upon formalism and rigorous software engineering methodology to gain assurance. In this paper, we briefly describe AMOebA-RT, a run-time monitoring and verification technique that provides assurance that dynamically adaptive software satisfies its requirements.", "num_citations": "76\n", "authors": ["539"]}
{"title": "Using formal methods to construct a software component library\n", "abstract": " Reusing software may greatly increase the productivity of software engineers and improve the quality of developed software. Software component libraries have been suggested as a means for facilitating reuse. Using formal specifications to represent software components facilitates the determination of reusable software because they more precisely characterize the functionality of the software, and the well-defined syntax makes processing amenable to automation. This paper presents an approach, based on formal methods, to the classification and organization of reusable software components. From a set of formal specifications, a two-tiered hierarchy of software components is constructed. The formal specifications represent software that has been implemented and verified for correctness. The hierarchical organization of the software component specifications provides a means for storing, browsing, and\u00a0\u2026", "num_citations": "75\n", "authors": ["539"]}
{"title": "Current and future research directions in requirements engineering\n", "abstract": " In this paper, we review current requirements engineering (RE) research and identify future research directions suggested by emerging software needs. First, we overview the state of the art in RE research. The research is considered with respect to technologies developed to address specific requirements tasks, such as elicitation, modeling, and analysis. Such a review enables us to identify mature areas of research, as well as areas that warrant further investigation. Next, we review several strategies for performing and extending RE research results, to help delineate the scope of future research directions. Finally, we highlight what we consider to be the \u201chot\u201d current and future research topics, which aim to address RE needs for emerging systems of the future.", "num_citations": "74\n", "authors": ["539"]}
{"title": "Automatically detecting and visualising errors in UML diagrams\n", "abstract": " UML has become the                de facto standard for object-oriented modelling. Currently, UML comprises several different notations with no formal semantics attached to the individual diagrams or their integration, thus preventing rigorous analysis of the diagrams. Previously, we developed a formalisation framework that attaches formal semantics to a subset of UML diagrams used to model embedded systems. This paper describes automated structural and behavioural analyses applicable to UML diagrams using our formalisation framework. In addition to intra- and inter-diagram consistency checks, we discuss how simulation and model checking can be used in tandem for behavioural analysis of the UML diagrams. Our tools also visually interpret the analysis results in terms of the original UML diagrams, thereby facilitating their correction and refinement. We illustrate these capabilities through the modelling and\u00a0\u2026", "num_citations": "72\n", "authors": ["539"]}
{"title": "Goal-oriented specification of adaptation requirements engineering in adaptive systems\n", "abstract": " Adaptive software is being used increasingly frequently by various users, such as the medical community, software industry, and in response to terror attacks. Therefore, understanding the requirements of an adaptive system is crucial to developing them correctly. Developers need to be able to reason about the requirements of a system's adaptive behavior. Adaptation semantics are intended to describe how systems behave during adaptation. Previously, Zhang and Cheng formally specified three commonly occurring adaptation semantics in terms of Adapt operator-extended LTL (A-LTL). This paper presents goal-oriented specifications of these three adaptation semantics. These specifications, specified with the KAOS methodology, provide a graphical wrapper to the formal A-LTL specifications of the semantics. The combination of the goal-oriented, graphical KAOS specifications and A-LTL specifications provides\u00a0\u2026", "num_citations": "70\n", "authors": ["539"]}
{"title": "Automatically generating behavioral models of adaptive systems to address uncertainty\n", "abstract": " Increasingly, high-assurance applications rely on dynamically adaptive systems (DASs) to respond to environmental changes, while satisfying functional requirements and non-functional preferences. Examples include critical infrastructure protection and transportation systems. A DAS comprises a collection of (non-adaptive) target systems (represented as UML models) and a set of adaptations that realize transitions among target systems. Two sources of uncertainty inherent to DASs are: (1) predicting the future execution environment, and (2) using functional and non-functional trade-offs to respond to the changing environment. To address this uncertainty, we are inspired by living organisms that are astonishingly adept at adapting to changing environmental conditions using evolution. In this paper, we describe a digital evolution-based approach to generating models that represent possible target\u00a0\u2026", "num_citations": "67\n", "authors": ["539"]}
{"title": "Path-based multicast communication in wormhole-routed unidirectional torus networks\n", "abstract": " This paper addresses the problem of one-to-many, or multicast, communication in wormhole-routed,n-dimensional torus networks. The proposed methods are designed for systems that support intermediate reception, which permits multidestination messages to be pipelined through several nodes, depositing a copy at each node. A key issue in the design of such systems is the routing function, which must support both unicast and multicast traffic while preventing deadlock among messages. An efficient, deadlock-free routing function is developed and used as a basis for a family of multicast algorithms. TheS-torusmulticast algorithm uses a single multidestination message to perform an arbitrary multicast operation. TheM-torusalgorithm is a generalized multiphase multicast algorithm, in which a combination of multidestination messages is used to perform a multicast in one or more communication steps. Two specific\u00a0\u2026", "num_citations": "64\n", "authors": ["539"]}
{"title": "Adding safeness to dynamic adaptation techniques\n", "abstract": " Recomposable software enables a system to change its structure and behavior during execution, in response to a dynamic execution environment. This paper proposes an approach to ensure that such adaptations are safe with respect to system consistency. The proposed method takes into consideration dependency analysis for target components, specifically determining viable sequences of adaptive actions and those states in which an adaptive action may be applied safely. We demonstrate the technique that ensures safe adaptation (insertion, removal, and replacement of components) in response to changing external conditions in a wireless multicast video application.", "num_citations": "60\n", "authors": ["539"]}
{"title": "Transparent shaping of existing software to support pervasive and autonomic computing\n", "abstract": " The need for adaptability in software is growing, driven in part by the emergence of pervasive and autonomic computing. In many cases, it is desirable to enhance existing programs with adaptive behavior, enabling them to execute effectively in dynamic environments. In this paper, we propose a general programming model called transparent shaping to enable dynamic adaptation in existing programs. We describe an approach to implementing transparent shaping that combines four key software development techniques: aspect-oriented programming to realize separation of concerns at development time, behavioral reflection to support software reconfiguration at run time, component-based design to facilitate independent development and deployment of adaptive code, and adaptive middleware to encapsulate the adaptive functionality. After presenting the general model, we discuss two specific realizations of\u00a0\u2026", "num_citations": "59\n", "authors": ["539"]}
{"title": "Enabling safe dynamic component-based software adaptation\n", "abstract": " Recomposable software enables a system to change its structure and behavior during execution, in response to a dynamic execution environment. This paper proposes an approach to ensure that such adaptations are safe with respect to system consistency. The proposed method takes into consideration dependency analysis for target components, specifically determining viable sequences of adaptive actions and those states in which an adaptive action may be applied safely. We demonstrate that the technique ensures safe adaptation (insertion, removal, and replacement of components) in response to changing external conditions in a wireless multicast video application.", "num_citations": "59\n", "authors": ["539"]}
{"title": "Reusing analogous components\n", "abstract": " Using formal specifications to represent software components facilitates the determination of reusability because they more precisely characterize the functionality of the software, and the well-defined syntax makes processing amenable to automation. This paper presents an approach, based on formal methods, to the search, retrieval, and modification of reusable software components. From a two-tiered hierarchy of reusable software components, the existing components that are analogous to the query specification are retrieved from the hierarchy. The specification for an analogous retrieved component is compared to the query specification to determine what changes need to be applied to the corresponding program component in order to make it satisfy the query specification.", "num_citations": "59\n", "authors": ["539"]}
{"title": "A formal approach to reusing more general components\n", "abstract": " Using formal specifications to represent software components facilitates tire determination of reusability because they more precisely characterize the functionality of the software, and the well-defined syntax makes processing amenable to automation. This paper presents an approach, based on formal methods, to the modification of reusable software components. From a two-tiered hierarchy of reusable software components, the existing components that are more general than the query specification are retrieved from the hierarchy. The specification for a more general retrieved component is compared to the query specification to determine what changes need to be applied to the corresponding program component in order to make it satisfy the query specification. This paper also describes an approach for assisting in the modification of more general components and gives an example to demonstrate its use.< >", "num_citations": "56\n", "authors": ["539"]}
{"title": "Security patterns\n", "abstract": " Design patterns propose generic solutions to recurring design problems. Commonly, they present a solution in a well-structured form that facilitates its reuse in a different context. Recently, there has been growing interest in identifying pattern-based designs for the domain of system security termed Security Patterns. Currently, those patterns lack comprehensive structure that conveys essential information inherent to security engineering. This paper describes research into investigating an appropriate template for Security Patterns that is tailored to meet the needs of secure system development. In order to maximize comprehensibility, we make use of well-known notations such as the Unified Modeling Language (UML) to represent structural and behavioral aspects of design. Furthermore, we investigate how verification can be enabled by adding formal constraints to the patterns.", "num_citations": "53\n", "authors": ["539"]}
{"title": "Automatic derivation of utility functions for monitoring software requirements\n", "abstract": " Utility functions can be used to monitor requirements of a dynamically adaptive system (DAS). More specifically, a utility function maps monitoring information to a scalar value proportional to how well a requirement is satisfied. Utility functions may be manually elicited by requirements engineers, or indirectly inferred through statistical regression techniques. This paper presents a goal-based requirements model-driven approach for automatically deriving state-, metric-, and fuzzy logic-based utility functions for RELAXed goal models. State- and fuzzy logic-based utility functions are responsible for detecting requirements violations, and metric-based utility functions are used to detect conditions conducive to a requirements violation. We demonstrate the proposed approach by applying it to the goal model of an intelligent vehicle system (IVS) and use the derived utility functions to monitor the IVS under different\u00a0\u2026", "num_citations": "51\n", "authors": ["539"]}
{"title": "Towards run-time testing of dynamic adaptive systems\n", "abstract": " It is challenging to design, develop, and validate a dynamically adaptive system (DAS) that satisfies requirements, particularly when requirements can change at run time. Testing at design time can help verify and validate that a DAS satisfies its specified requirements and constraints. While offline tests may demonstrate that a DAS is capable of satisfying its requirements before deployment, a DAS may encounter unanticipated system and environmental conditions that can prevent it from achieving its objectives. In working towards a requirements-aware DAS, this paper proposes run-time monitoring and adaptation of tests as another technique for evaluating whether a DAS satisfies, or is even capable of satisfying, its requirements given its current execution context. To this end, this paper motivates the need and identifies challenges for adaptively testing a DAS at run time, as well as suggests possible methods for\u00a0\u2026", "num_citations": "47\n", "authors": ["539"]}
{"title": "Using automated reasoning techniques to determine software reuse\n", "abstract": " Reusing software may greatly increase the productivity of software engineers and improve the quality of developed software. Software component libraries have been suggested as a means for facilitating reuse. A major difficulty in designing software libraries is in the selection of a component representation that will facilitate the classification and the retrieval processes. Using formal specifications to represent software components facilitates the determination of reusable software because they more precisely characterize the functionality of the software, and the well-defined syntax makes processing amenable to automation.         This paper presents an approach, based on formal methods, to the classification, organization and retrieval of reusable software components. From a set of formal specifications, a two-tiered hierarchy of software components is constructed. The formal specifications represent software that\u00a0\u2026", "num_citations": "45\n", "authors": ["539"]}
{"title": "Abstraction of formal specifications from program code\n", "abstract": " The use of formal methods in software development is gaining increasing attention as software becomes more important to the operation of critical systems. Veri cation of formally speci ed software may be automated. Unfortunately, most existing software has not been formally speci ed. This paper describes the development of a tool that abstracts formal speci cations from program code, using formal methods and object-oriented techniques.", "num_citations": "41\n", "authors": ["539"]}
{"title": "Formal methods applied to reuse\n", "abstract": " This paper presents an approach, based on formal methods, to the classi cation, organization, and retrieval of reusable software components. From a set of formal speci cations, a two-tiered hierarchy of software components is constructed. The formal speci cations represent software that has been implemented and veri ed for correctness. The lower-level hierarchy is created by a subsumption test algorithm that determines whether one component is more general than another; this level facilitates the application of logical reasoning techniques for a ne-grained, exact determination of reusable candidates. The higher-level hierarchy provides a coarse-grained determination of reusable candidates and is constructed by applying a hierarchical clustering algorithm to the most general components from the lower-level hierarchy. The hierarchical organization of the software component speci cations provides a means for\u00a0\u2026", "num_citations": "40\n", "authors": ["539"]}
{"title": "Applying formal methods in automated software development\n", "abstract": " Research into the development of software tools that support formal methods is aimed at simplifying and providing assistance during the development of correct software. This paper describes the development of the Seed system, which demonstrates that the building blocks of a software system can be correctly synthesized from user-supplied formal speci cations using techniques amenable to automation. Seed accepts a formal speci cation of a problem written in predicate logic and generates annotated program source code satisfying the speci cation. The rules for choosing which programming language structures to synthesize are contained in a rule base; background knowledge and domain-speci c information are entered into a fact base. During synthesis, Seed uses the fact base to disambiguate rule applications. In addition to primitive programming language constructs, such as assignment, alternative and iterative statements, Seed is capable of synthesizing recursive and non-recursive procedures and functions, as well as abstract data types.", "num_citations": "38\n", "authors": ["539"]}
{"title": "AutoRELAX: automatically RELAXing a goal model to address uncertainty\n", "abstract": " Dynamically adaptive systems (DAS) must cope with system and environmental conditions that may not have been fully understood or anticipated during development. RELAX is a fuzzy logic-based specification language for identifying and assessing sources of environmental uncertainty, thereby making DAS requirements more tolerant of unanticipated conditions. This paper presents AutoRELAX, an approach that automatically generates RELAXed goal models to address environmental uncertainty. Specifically, AutoRELAX identifies goals to RELAX, which RELAX operators to apply, and the shape of the fuzzy logic function that establishes the goal satisfaction criteria. AutoRELAX generates different solutions by making tradeoffs between minimizing the number of RELAXed goals and maximizing delivered functionality by reducing the number of adaptations triggered by minor and adverse environmental\u00a0\u2026", "num_citations": "35\n", "authors": ["539"]}
{"title": "A two-phase approach to reverse engineering using formal methods\n", "abstract": " Reverse engineering of program code is the process of constructing a higher level abstraction of an implementation in order to facilitate the understanding of a system that may be in a \u201clegacy\u201d or \u201cgeriatric\u201d state. Changing architectures and improvements in programming methods, including formal methods in software development and object-oriented programming, have prompted a need to reverse engineer and re-engineer program code. This paper presents a two-phase approach to reverse engineering, the results of which can be used to guide the re-implementation of an object-oriented version of the system. The first phase abstracts formal specifications from program code, while the second phase constructs candidate objects from the formal specifications obtained from the first phase.", "num_citations": "34\n", "authors": ["539"]}
{"title": "Models@ run. time (Dagstuhl Seminar 11481).\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 11481``Models@ run. time''. Research on models@ run. time seeks to extend the applicability of models and abstractions to the runtime environment, with the goal of providing effective technologies for managing the complexity of evolving software behaviour while it is executing. The Dagstuhl Seminar``Models@ run. time''brought together a diverse set of researchers and practitioners with a broad range of expertise, including MDE, software architectures, reflection, self-adaptive systems, validation and verification, middleware, robotics and requirements engineering.", "num_citations": "33\n", "authors": ["539"]}
{"title": "Automatically discovering properties that specify the latent behavior of UML models\n", "abstract": " Formal analysis can be used to verify that a model of the system adheres to its requirements. As such, traditional formal analysis focuses on whether known (desired) system properties are satisfied. In contrast, this paper proposes an automated approach to generating temporal logic properties that specify the latent behavior of existing UML models; these are unknown properties exhibited by the system that may or may not be desirable. A key component of our approach is Marple, a evolutionary-computation tool that leverages natural selection to discover a set of properties that cover different regions of the model state space. The Marple-discovered properties can be used to refine the models to either remove unwanted behavior or to explicitly document a desirable property as required system behavior. We use Marple to discover unwanted latent behavior in two applications: an autonomous robot\u00a0\u2026", "num_citations": "33\n", "authors": ["539"]}
{"title": "Automatically generating adaptive logic to balance non-functional tradeoffs during reconfiguration\n", "abstract": " Increasingly, high-assurance software systems apply self-reconfiguration in order to satisfy changing functional and non-functional requirements. Most self-reconfiguration approaches identify a target system configuration to provide the desired system behavior, then apply a series of reconfiguration instructions to reach the desired target configuration. Collectively, these reconfiguration instructions define an adaptation path. Although multiple satisfying adaptation paths may exist, most self-reconfiguration approaches select adaptation paths based on a single criterion, such as minimizing reconfiguration cost. However, different adaptation paths may represent tradeoffs between reconfiguration costs and other criteria, such as performance and reliability. This paper introduces an evolutionary computation-based approach to automatically evolve adaptation paths that safely transition an executing system from its\u00a0\u2026", "num_citations": "33\n", "authors": ["539"]}
{"title": "A semantic foundation for specification matching\n", "abstract": " Determining the behavioral relationship between software components is a cen-tral task for many software engineering activities, such as reuse, maintenance, and object-oriented subtyping. With the increasing interest in formal methods and auto-mated software development techniques, specification matching has been proposed as a means to evaluate component relations at an abstract level. A number of specification matches have been proposed to capture the notion of behavioral refinement, or reusability in the context of software reuse. Without a rigorous means to establish the relationship between a given specification match and its suitability for reuse, the usefulness of a specification match is questionable. In this paper, based on total correctness of a program with respect to its specification, we establish a semantic foundation for reasoning about the connections between a specification match and its usefulness for determining reusability, and provide a framework to evaluate various specification matches. In particular, we discuss a special type of specification matching, reuse-ensuring matches. We prove that the set of all equivalence classes of reuse-ensuring matches together with the logical implication (+) operator constitute a complete lattice, thus enabling us to identify the most general (or the best) reuse-ensuring matches.", "num_citations": "33\n", "authors": ["539"]}
{"title": "Facilitating an automated approach to architecture-based software reuse\n", "abstract": " Over the past several years, a number of techniques have been developed to address various issues involving software reuse, such as component classification, retrieval, and integration. However, it is not adequate to only have reuse techniques that address reuse issues separately. Instead, a seamless integration of these reuse techniques is critical to achieve effective reuse. In this paper, we present an integrated approach to software reuse. Based on software architecting techniques and formal methods, this approach addresses various reuse issues in a systematic and (semi) automatic fashion. An architecture-based software reuse and integration environment that supports this approach is also described.", "num_citations": "32\n", "authors": ["539"]}
{"title": "Automated analysis of natural language properties for UML models\n", "abstract": " It is well known that errors introduced early in the development process are commonly the most expensive to correct. The increasingly popular model-driven architecture (MDA) exacerbates this problem by propagating these errors automatically to design and code. This paper describes a round trip engineering process that supports the specification of a UML model using CASE tools, the analysis of specified natural language properties, and the subsequent model refinement to eliminate errors uncovered during the analysis. This process has been implemented in Spider, a tool suite that enables developers to specify and analyze a UML model with respect to behavioral properties specified in terms of natural language.", "num_citations": "30\n", "authors": ["539"]}
{"title": "Efficient collective data distribution in all-port wormhole-routed hypercubes\n", "abstract": " This paper addresses the problem of collective data distribution, specifically multicast, in wormhole-routed hypercubes. The system model allows a processor to send and receive data in all dimensions simultaneously. New theoretical results that characterize contention among messages in wormhole-routed hypercubes are developed and used to design new multicast routing algorithms. The algorithms are compared in terms of the number of steps required in each, their measured execution times when implemented on a relatively small-scale nCUBE-2, and their simulated execution times on larger hypercubes. The results indicate that significant performance improvement is possible when the multicast algorithm actively identifies and uses multiple ports in parallel.", "num_citations": "30\n", "authors": ["539"]}
{"title": "A visualization framework for the modeling and formal analysis of high assurance systems\n", "abstract": " Increasingly, object-oriented technology, specifically the Unified Modeling Language (UML), is being used to develop critical embedded systems. Several efforts have attempted to translate UML models into formal specification languages, thus enabling the models to be analyzed by model checkers. Unfortunately, the complexity and volume of the analysis results often prevents developers from fully taking advantage of the analysis capabilities. This paper introduces a generic visualization framework, Theseus, that provides developers with a model-based, visual interpretation of the analysis results in terms of the original UML diagrams. Within this framework, a playback mechanism displays the execution path that has led to a model checking violation in terms of the original UML state diagram and a newly generated sequence diagram that depicts the problem scenario. A Theseus prototype supporting the\u00a0\u2026", "num_citations": "27\n", "authors": ["539"]}
{"title": "Visualizing requirements in UML models\n", "abstract": " As the Unified Modeling Language (UML) and modeldriven development (MDD) become increasingly common in industry, many developers are faced with the difficult task of understanding how an existing UML model realizes system requirements. Essentially, developers are required to understand the structure and behavior of UML models that they may have not created. Understanding these relationships is non-trivial, because the interactions in the model are not readily apparent. Commonly, the only means to elicit these relationships is visual inspection and guided simulation. This paper describes an alternative approach termed REVU (Requirements Visualization of UML), a process for visualizing functional requirements in terms of behavioral interactions in a UML model. We illustrate the use of this process with the visualization of scenarios for an adaptive light control system.", "num_citations": "27\n", "authors": ["539"]}
{"title": "Using informal and formal techniques for the reverse engineering of C programs\n", "abstract": " Paper reprinted from ICSM '96. Reverse engineering of program code is the process of constructing a higher level abstraction of an implementation in order to facilitate the understanding of a system that may be in a \"legacy\" or \"geriatric\" state. Changing architectures and improvements in programming methods, including formal methods in software development and object-oriented programming, have prompted a need to reverse engineer and re-engineer program code. At the same time, there is a need to preserve the functionality of existing systems as well as reason about the correctness of changed code, each of which is facilitated by the existence of formal specifications. This paper describes an approach that incorporates the use of semi-formal analysis and formal program semantics to reverse engineer C programs. The reverse engineering techniques are applied to a portion of a ground-based command\u00a0\u2026", "num_citations": "27\n", "authors": ["539"]}
{"title": "Automated analysis of timing information in UML diagrams\n", "abstract": " This work introduces an approach to adding timing information to UML diagrams for modeling embedded systems. In order to perform automated formal analysis of these UML diagrams with timing information, we extend a previously developed UML formalization framework to provide Promela semantics for the timing elements of the UML diagrams. The paper describes the application of our approach to an electronically controlled steering system obtained from one of our industrial collaborators.", "num_citations": "26\n", "authors": ["539"]}
{"title": "Enabling automated analysis through the formalization of object-oriented modeling diagrams\n", "abstract": " As the impact of and demand for software increases, there is greater need for rigorous software development techniques that can be used by a typical software engineer. In order to integrate informal and formal approaches to software development, we added formal syntax and semantics definitions to existing object-oriented modeling notations. This formalization enables developers to construct object-oriented models of requirements and designs and then automatically generate formal specifications for the diagrams. This paper describes how the resulting diagrams via their specifications can be analyzed using automated techniques to validate behavior through simulation or to check for numerous properties of the diagrams, including inter- and intramodel consistency.", "num_citations": "26\n", "authors": ["539"]}
{"title": "A graphical environment for formally developing object-oriented software\n", "abstract": " This paper describes a graphics-based software development environment that takes advantage of the visual nature of the Object Modeling Technique (OMT) notation and the benefits of formal methods. We have developed a prototype environment, VISUALSPECS, which enables a user to perform object-oriented analysis graphically using the OMT notation. VISUALSPECS generates a formal specification of the object-model, which can be systematically analyzed for completeness and consistency prior to implementation. The formal specifications can be used to guide the formal software. This graphical environment facilitates the development of reliable software using formal methods, enables automated of requirements and design information, and promotes software design reuse based on graphical notations.< >", "num_citations": "26\n", "authors": ["539"]}
{"title": "Avida-MDE: a digital evolution approach to generating models of adaptive software behavior\n", "abstract": " Increasingly, high-assurance applications rely on autonomic systems to respond to changes in their environment. The inherent uncertainty present in the environment of autonomic systems makes it difficult for developers to identify and model resilient autonomic behavior prior to deployment. In this paper, we propose Avida-MDE, a digital evolution approach to the generation of behavioral models (ie, a set of interacting finite state machines) that capture autonomic system behavior that is potentially resilient to a variety of environmental conditions. We use an evolving population of digital organisms to generate behavioral models, where the organisms are subjected to natural selection and are rewarded for generating behavioral models that meet developer requirements. To illustrate this approach, we successfully applied it to the generation of behavioral models describing the navigation behavior of an autonomous\u00a0\u2026", "num_citations": "25\n", "authors": ["539"]}
{"title": "A requirements patterns-driven approach to specify systems and check properties\n", "abstract": " We previously developed a framework, Hydra, for adding formal semantics to a collection of UML diagrams that enable the automated derivation of formal language specifications for those diagrams. Recently, we have also identified a number of requirements patterns for embedded systems that includes sample UML structural and behavioral diagrams for modeling requirements and high-level design for embedded systems. This paper describes a requirements patterns-driven approach for developing UML diagrams for embedded systems, where each pattern has a constraints section to specify safety and other invariant properties. We show how the diagrams for an industrial automotive system, via specifications generated from Hydra, can be automatically analyzed for adherence to these formally specified constraints using the SPIN model checker. We developed the MINERVA framework to support the\u00a0\u2026", "num_citations": "25\n", "authors": ["539"]}
{"title": "Formalizing and integrating the functional model into object-oriented design\n", "abstract": " The data flow diagram (DFD), originally introduced for structured design purposes, depicts the functions that a system or a module should provide. Having clearly demonstrated its usefulness in the software engineering discipline, DFDs seem to be essential to software development. However, the function-oriented decomposition strategy of DFDs in the conventional design process for structured design conflicts with the spirit of objectorientation. So far, there is no object-oriented method that has successfully integrated DFDs into the objectoriented development process. In this paper, we demonstrate how DFDs can be modified in order to be integrated into object-oriented development. The Object Modeling Technique (OMT) is used as the context for object-oriented development. In addition, a set of formalization rules are proposed to provide formal semantics for DFDs in order to integrate the functional model with the\u00a0\u2026", "num_citations": "25\n", "authors": ["539"]}
{"title": "Efficient multicast in all-port wormhole-routed hypercubes\n", "abstract": " This paper addresses the problem of collective data distribution, specifically multicast, in wormhole-routed hypercubes. The system model allows a processor to send and receive data in all dimensions simultaneously. New theoretical results that characterize contention among messages in wormhole-routed hypercubes are developed and used to design new multicast routing algorithms. The algorithms are compared in terms of the number of steps required in each, their measured execution times when implemented on a relatively small-scale nCUBE-2, and their simulated execution times on larger hypercubes. The results indicate that significant performance improvement is possible when the multicast algorithm actively identifies and uses multiple ports in parallel.", "num_citations": "25\n", "authors": ["539"]}
{"title": "Automated generation of adaptive test plans for self-adaptive systems\n", "abstract": " Self-adaptive systems (SAS) can reconfigure at run-time to mitigate uncertainties posed by environments for which they may not have been explicitly designed. High-assurance SAS applications must continually deliver acceptable behavior for critical services, enabling the need for run-time validation techniques. To this end, run-time testing can provide additional assurance that an SAS will continue to behave as expected while executing under unknown conditions. This paper introduces Proteus, a framework for adaptive run-time testing on an SAS. Proteus facilitates both execution and adaptation of run-time testing activities to ensure that the SAS continues to execute according to its requirements and that both test plans and test cases continually remain relevant to changing operating conditions. We demonstrate our approach by applying it to a simulated self-adaptive remote data mirroring network that must\u00a0\u2026", "num_citations": "24\n", "authors": ["539"]}
{"title": "Lessons learned from automated analysis of industrial UML class models (an experience report)\n", "abstract": " Automated analysis of object-oriented design models can provide insight into the quality of a given software design. Data obtained from automated analysis, however, is often too complex to be easily understood by a designer. This paper examines the use of an automated analysis tool on industrial software UML class models, where one set of models was created as part of the design process and the other was obtained from reverse engineering code. The analysis was performed by DesignAdvisor, a tool developed by Siemens Corporate Research, that supports metrics-based analysis and detection of design guideline violations. The paper describes the lessons learned from using the automated analysis techniques to assess the quality of these models. We also assess the impact of design pattern use in the overall quality of the models. Based on our lessons learned, identify design guidelines that would\u00a0\u2026", "num_citations": "24\n", "authors": ["539"]}
{"title": "A formal approach for reverse engineering: A case study\n", "abstract": " As a program evolves, it becomes increasingly difficult to understand and reason about changes in the source code. Eventually, if enough changes are made, reverse engineering and design recovery techniques must be used in order to understand the current behavior of a system. In this context, the effective use of complementary approaches can facilitate program and system understanding by taking advantage of the relative benefits of different approaches. This paper presents an approach to reverse engineering that combines the use of both informal and formal methods and describes a case study project involving the reverse engineering of a mission control system used by the NASA Jet Propulsion Laboratory to command unmanned spacecraft.", "num_citations": "24\n", "authors": ["539"]}
{"title": "Resource-based approach to feature interaction in adaptive software\n", "abstract": " This paper proposes the RAFTING approach (Resource-based Approach to FeaTure InteractioN) to address the feature interaction problem in the context of dynamically adapted software. RAFTING focuses on the resources used by features, rather than the features themselves. Therefore, for this paper's purposes, resource contention will be considered the main cause for feature interaction. We illustrate how a resource-based approach simplifies the detection of feature interactions, particularly when a limited amount of information is known about the individual components being dynamically added to the system.", "num_citations": "22\n", "authors": ["539"]}
{"title": "Contention-free 2D-mesh cluster allocation in hypercubes\n", "abstract": " Traditionally, each job in a hypercube multiprocessor is allocated with a subcube so that communication interference among jobs may be avoided. Although the hypercube is a powerful processor topology, the 2D mesh is a more popular application topology. This paper presents a 2D-mesh cluster allocation strategy for hypercubes. The proposed auxiliary free list processor allocation strategy can efficiently allocate 2D-mesh dusters without size constraints, can reduce average job turnaround time compared with that based on subcube allocation strategies, and can guarantee no communication interference among allocated clusters when the underlying hypercube implements deadlock-free E-cube routing. The proposed auxiliary free list strategy can be easily implemented on hypercube multicomputers to increase processor utilization.< >", "num_citations": "22\n", "authors": ["539"]}
{"title": "TRAP: Transparent reflective aspect programming\n", "abstract": " ABSTRACT 24\u00a1 V\u00a3 $ &0D!'(\u00a9 0\u00a4\u00a5 C# $\u00a1 b (\u00a9 0\u00a3 7! 4\u00a1\u00a9\u00a3 0\u00a4 $ &!(b 0\u00a4 $ &# $ & (\u00a4 $\u00a3 7\u00a1\u00a9 $ & & (y 0\u00a4\u00a6 570\u00a3! 45 u A ed V\u00a3 i 5\u00a6 $! 4$ &0\u00a3(\u00a4 0q fg0\u00a3 7 $3 hu 70\u00a4 i (\u00a4 j\u00a1\u00a9 C4# 0\u00a9(k $ &l $!'(\u00a2\u00a5%!\u00a3 7\u00a6\u00a3 7!\u00a5 j (\u00a9 0\u00a3 $\u00a2\u00a3 764\" $\u00a3\u00a6\u00a5 4\u00a3 7 4 (\u00a3(\u00a4\u00a6! m! X\u00a1\u00a9 fg (nhu\u00a3 0\u00a4 $\u00a6 B u A $ &! 4\u00a3 6#\" $\u00a1 k\u00a3 7\u00a5#\u00a3 4 (\u00a4 $ q foC#! 4 & (\u00a4\u00a6!#\u00a3 7\" 1 (n% i (\u00a4 e 6$ s\u00a3 7\u00a5#\u00a5 $\u00a2\u00a5 j (\u00a4 p\u00a3! q $3 r4\u00a1)(\u00a4!# 5i\u00a3 4 4\"\u00a3(\u00a4\u00a6! hs 1 (\u00a4 2# 7C4 (\u00a5 ft%! 45A 1 (\u00a4\u00a1\u00a1\u00a9\u00a6 C 0\u00a4 $ S\u00a5 4 $7 B 0\u00a4 $\u00a5 4C# & $ u $ &0\u00a9 24$\u00a2\u00a3\u00a6\u00a5 9 u A $!\u00a3 6#\" $\u00a1 i (\u00a4 2# $\u00a5 4$$ &\" 7$ &0i (\u00a4 u\u00a1\u00a9 $ &\" $ & & (\u00a2 v\u00a3(X 7#\" $(\u00a4 $\u00a6'\u00a3 w\u00a1\u00a9 C# 6#\u00a1\u00a9 $3 (x f9\"\u00a3 7\u00a1\u00a9\u00a1\u00a9 $\u00a1 x (\u00a4 k\u00a1\u00a9 C4# 0\u00a9(u\u00a3 7\u00a5#\u00a3 7 (\u00a3(\u00a4\u00a6!(\u00a4 2 0\u00a4\u00a6 C45\u00a6 2 0\u00a4 C#!(\u00a4 $ q\u00a3\u00a1\u00a9 $ & (G hu $\u00a2\u00a3\u00a2!# 54B u AC#\u00a1\u00a9 $ &\u00a1 A\u00a3\u00a1\u00a9 $ & (\u00a9 y 70\u00a4 $!'(\u00a4 $\u00a2\u00a5 v 0\u00a4\u00a6 5 0\u00a3 7! 45A\u00a3!\u00a5 k 6 $2\u00a3\u00a2 70\u00a3\" 0\u00a4 $3 $ & (\u00a4 7! z (\u00a4\u00a3 7C (\u00a4\u00a6 e\u00a3(\u00a4\u00a2\u00a3\"\"% z 57$!# $ &0\u00a3(\u00a4 $ e (\u00a4 24 $0\u00a4 ${C4 10\u00a4 $\u00a2\u00a5 q\u00a3 7\u00a1\u00a9 $ & (\u00a4\u00a1\u00a3!\u00a5 w 0\u00a4 $ &# $ & (\u00a4 $ Q\"\u00a3 7\u00a1\u00a9\u00a1\u00a9 $\u00a1\u00a3\u00a1\u00a9\u00a1\u00a9'\u00a3(\u00a4 $\u00a2\u00a5 v hs 1 (\u00a4 2q (\u00a4 2# $ Q\u00a1\u00a9 $ &\" $3 (\u00a4 $\u00a2\u00a5(n% $\u00a1 B (Q 0\u00a4 C#!(\u00a4 $\u00a6! 4$ &h|\u00a3 7\u00a5#\u00a3 4 (\u00a4 $ G 6 $2\u00a3\u00a2 70e\u00a2\u00a3 7! e 6$ s! 4 (\u00a9 0\u00a4\u00a5 C# $\u00a5 A (\u00a4 s (\u00a4 24$ Q\u00a3 7# 4\"\u00a3(\u00a4\u00a6! q (\u00a9 0\u00a3 7! 4\u00a1\u00a9\u00a3 0\u00a4 $ &!(\u00a4\" 1% hs (\u00a4 2k 0\u00a4 $\u00a1\u00a9 $ & & (D (\u00a4 S (\u00a4 24 $0\u00a4 5\u00a6!\u00a3\" y\u00a5 4 $7 B u A\u00a2\u00a3 7! j 6$ q\u00a3# 4\" $\u00a2\u00a5 i (\u00a4 e\u00a3 7!'% i\u00a6 6 \u00a7 ) $ & (\u00a9 y 0\u00a4 $ &!(\u00a4 $\u00a5\"\u00a3!# 5\u00a6 C#\u00a3 757$ i (\u00a4 2#\u00a3(q\u00a1\u00a9 C# 4 70\u00a9(\u00a4\u00a1 q\u00a1)(\u00a9 0\u00a4 C# 3 (\u00a4 C40\u00a3 7\" Q 0\u00a4 $ & $ & & (\u00a4\u00a6! DB 0\u00a4 7 (\u00a4(n% $\u00a6 u A e} 7~ V hs2# 2 2#\u00a3 7\u00a1 q 6$$!\u00a5 4$$ &\" 7$\u00a2\u00a5 q fg 70z C#\u00a1\u00a9 $ hs 1 (\u00a4 2~\u00a3 7\u00a3 j\u00a3 4 4\"\u00a3(\u00a4\u00a6! 4\u00a1 9\u00a1 A\u00a5 4$\u00a1\u00a9 30\u00a4 6$\u00a5 bB\u00a2\u00a3\u00a1\u00a9 $ v\u00a1)(\u00a4 C#\u00a5% p\u00a1 G 40\u00a4 $ &\u00a1\u00a9 $!'(\u00a4 $\u00a2\u00a5 j! j hs2# 32 u A hu\u00a3 7\u00a1 k C#\u00a1\u00a9 $\u00a5 X (\u00a4 p $!\u00a3 6#\" $\u00a3! q $ &r\u00a1)(\u00a4!# 5v\u00a3 7C\u00a5 7 y\u00a1)(\u00a9 0\u00a4 $\u00a2\u00a3 7! 45v\u00a3 4 4\"\u00a3(\u00a4\u00a6!(\u00a4 X\u00a6 $ &0\u00a3(\u00a4 $ v $ & 9 $3 (\u00a4\u00a6 $\" 1%!\u00a3 j hs 10\u00a4 $\" $\u00a1\u00a9\u00a1! 4$ & (nhx 70\u00a4 $! 1 0\u00a4 7!# $!'(s 6'% i\u00a3\u00a6\u00a5 4\u00a3 7 (\u00a4! 45s (\u00a4 2\u00a3!# 5\u00a6\u00a0\u2026", "num_citations": "21\n", "authors": ["539"]}
{"title": "Formalizing and integrating the dynamic model for object-oriented modeling\n", "abstract": " The Object Modeling Technique (OMT), a commonly used object-oriented development technique, comprises the object, dynamic, and functional models to provide three complementary views that graphically describe different aspects of systems. The lack of a well-defined semantics for the integration of the three models hinders the overall development process, particularly during the design phase. Previously, we formalized the object model in terms of algebraic specifications. However, the algebraic specifications only capture the static, structural aspects of a system. They do not explicitly describe the behavior, which is critical for system development especially for the design phase. It is necessary to formalize the dynamic model in terms of the structural descriptions in order to specify and verify the system behavior using rigorous techniques. This paper presents a well-defined formal model for both the object and\u00a0\u2026", "num_citations": "21\n", "authors": ["539"]}
{"title": "Generation of self-optimizing wireless network applications\n", "abstract": " Adaptable applications are difficult to develop and maintain especially if adaptive code, which implements the adaptive behavior, is tangled into functional code, which implements the imperative behavior. Our work investigates how to wrap existing applications transparently to generate such management components. Developing manageable components requires some mechanism to support adaptation in behavior. The predominant mechanism for implementing adaptation in object-oriented software is behavioral reflection, which can be used to modify how an object responds to a message. This work describes the application of TRAP/J to a multicast audio application. The audio-streaming application (ASA) is designed to deliver interactive audio from a microphone at one network node to multiple receiving nodes.", "num_citations": "20\n", "authors": ["539"]}
{"title": "An automated approach for supporting software reuse via reverse engineering\n", "abstract": " Formal approaches to software reuse rely heavily upon a specification matching criterion, where a search query using formal specifications is used to search a library of components indexed by specifications. In previous investigations, we addressed the use of formal methods and component libraries to support software reuse and construction of software based on component specifications. A difficulty for all formal approaches to software reuse is the creation of the formal indices. We have developed an approach to reverse engineering that is based on the use of formal methods to derive formal specifications of existing programs. In this paper, we present an approach for combining software reverse engineering and software reuse to support populating specification libraries for the purposes of software reuse. In addition, we discuss the results of our initial investigations into the use of tools to support an entire\u00a0\u2026", "num_citations": "20\n", "authors": ["539"]}
{"title": "Harnessing evolutionary computation to enable dynamically adaptive systems to manage uncertainty\n", "abstract": " This keynote talk and paper intend to motivate research projects that investigate novel ways to model, analyze, and mitigate uncertainty arising in three different aspects of the cyber-physical systems. First, uncertainty about the physical environment can lead to suboptimal, and sometimes catastrophic, results as the system tries to adapt to unanticipated or poorly-understood environmental conditions. Second, uncertainty in the cyber environment can have lead to unexpected and adverse effects, including not only performance impacts (load, traffic, etc.) but also potential threats or overt attacks. Finally, uncertainty can exist with the components themselves and how they interact upon reconfiguration, including unexpected and unwanted feature interactions. Each of these sources of uncertainty can potentially be identified at different stages, respectively run time, design time, and requirements, but their mitigation might\u00a0\u2026", "num_citations": "19\n", "authors": ["539"]}
{"title": "A rigorous object-oriented design process\n", "abstract": " Within the software development process, software design plays an important role in realizing software requirements. A considerable amount of e ort has been expended in the area of software design and design methods in the past three decades. However, unlike other disciplines of engineering, such as mechanical engineering and electronic engineering, the proposed software design methods rarely incorporate mathematical rigor in order to facilitate precise speci cation of requirements and design. This phenomenon can be partly attributed to the fact that formal methods research has largely focused on the development of formal notation and inference rules, and the notation and the grammar of formal speci cation languages require familiarity with discrete mathematics and symbolic logic that most practicing software engineers, designers, and implementors do not have. The Object Modeling Technique (OMT), a\u00a0\u2026", "num_citations": "19\n", "authors": ["539"]}
{"title": "Formalizing and automating component reuse\n", "abstract": " Using existing components to construct software systems has significant potential to improving software productivity and quality. A key problem in software component reuse is the selection of appropriate components for satisfying a given requirement. In this paper we define a component interface generality relation that provides a foundation for component selection. This generality relation, represented in terms of formal specifications, precisely captures the semantic obligations for an existing component to satisfy the requirements of a target system. The formal specifications facilitate the (semi-) automatic determination of the generality relation. We show how this generality relation has been used to determine the reusability of software components in a software architecture-based reuse and integration environment.", "num_citations": "19\n", "authors": ["539"]}
{"title": "Adaptive monitoring of software requirements\n", "abstract": " Requirements monitoring continuously probes system components and sensors to assess whether the system satisfies its requirements and to detect conditions conducive to a requirement violation. Monitoring, however, is typically computationally expensive, intrusive, and presents tradeoffs between monitoring costs and accuracy, or the degree of coverage and coherence of gathered data. As such, it may be desirable to adapt the monitoring behavior of a software system in response to changing system and environmental conditions, as these may differ from those anticipated at design time. This paper presents Plato-RE, an evolutionary computation-based approach for adaptively monitoring the satisfaction of requirements. In particular, Plato-RE detects conditions conducive to a requirements violation and generates, at run time, new monitoring configurations to minimize monitoring costs and maximize monitoring\u00a0\u2026", "num_citations": "18\n", "authors": ["539"]}
{"title": "An approach to implementing dynamic adaptation in c++\n", "abstract": " This paper describes TRAP/C++, a software tool that enables new adaptable behavior to be added to existing C++ programs in a transparent fashion. In previous investigations, we used an aspect-oriented approach to manually define aspects for adaptation infrastructure, which were woven into the original application code at compile time. In follow-on work, we developed TRAP, a transparent shaping technique for automatically generating adaptation aspects, where TRAP/J is a specific instantiation of TRAP. This paper presents our work into building TRAP/C++, which was intended to be a port of TRAP/J into C++. Designing TRAP/C++ required us to overcome two major hurdles: lack of reflection in C++ and the incompatibility between the management of objects in C++ and the aspect weaving technique used in TRAP/J. We used generative programming methods to produce two tools, TrapGen and TrapCC, that\u00a0\u2026", "num_citations": "18\n", "authors": ["539"]}
{"title": "An availability-aware approach to resource placement of dynamic scaling in clouds\n", "abstract": " The availability of Web applications influenced by Virtual Machine (VM)-based physical locations during resource scaling is a crucial concern for customers and cloud providers. In this paper, we present a novel computing model to describe availability attribute of one application in hierarchical structured cloud. Meanwhile, we propose an availability-aware approach to explore how and where to allocate computing resource via vertical and horizontal scaling. Partial experimental results in simulation environment are also presented.", "num_citations": "17\n", "authors": ["539"]}
{"title": "Goal-oriented modeling of requirements engineering for dynamically adaptive system\n", "abstract": " Increasingly, dynamically adaptive systems (DASs) are addressing complex problems that require a high degree of assurance. The inherent complexity of DASs and the safety critical applications they are addressing necessitates rigorous requirements engineering (RE). This problem is further complicated by the multiple stakeholders involved in the RE process. Berry et al. have identified four levels of RE done for a DAS, in which each level implicitly corresponds to the objectives of a different stakeholder. This paper presents a goal-oriented approach to specifying the four levels of RE using the KAOS specification language. This approach enhances the understanding of the role and contributions of each stakeholder and their complex relationships", "num_citations": "17\n", "authors": ["539"]}
{"title": "A specification matching based approach to reverse engineering\n", "abstract": " Specification Matching is a technique that has been used to retrieve reusable components from reuse libraries. The relationship between a query specification and a library specification is typically based on refinement, where a library specification matches a query specification if the library specification is more detailed than the query specification. Reverse engineering is a process of analyzing components and component interrelationships in order to construct descriptions of a system at a higher level of abstraction. In this paper, we define the concept of an abstraction match as a basis for reverse engineering and show how the abstraction match can be used to facilitate a process for generalizing specifications. Finally, we apply the specification generalization technique to a portion of a NASA JPL ground-based mission control system for unmanned flight systems.", "num_citations": "17\n", "authors": ["539"]}
{"title": "Applying adaptation design patterns\n", "abstract": " Dynamic adaptation may be used to prevent software downtime while new requirements and responses to environmental conditions are incorporated into the system. Previously, we studied over thirty adaptation-related projects to develop twelve adaptation-oriented design patterns that can be leveraged from one adaptive system to another. This paper presents a case study in which we apply our adaptation patterns in the design of a dynamically adaptive news web server. This pattern-based design separates the functional logic from the adaptive logic, resulting in a system that supports dynamic adaptation and is easier to maintain and analyze. Furthermore, to address assurance concerns, we applied automated formal verification techniques to ensure instantiated pattern models satisfy invariant properties specified in each adaptation pattern.", "num_citations": "16\n", "authors": ["539"]}
{"title": "Retrieval by construction: A traceability technique to support verification and validation of UML formalizations\n", "abstract": " Recently, there has been growing interest in formalizing UML, thereby enabling rigorous analysis of its many graphical diagrams. Two obstacles currently limit the adoption and use of UML formalizations in practice. First is the need to verify the consistency of artifacts under formalization. Second is the need to validate formalization approaches against domain-specific requirements. Techniques from the emerging field of requirements traceability hold promise for addressing these obstacles. This paper contributes a technique called retrieval by construction (RBC), which establishes traceability links between a UML model and a target model intended to denote its semantics under formalization. RBC provides an approach for structuring and representing the complex one-to-many links that are common between UML and target models under formalization. RBC also uses the notion of value identity in a novel way that\u00a0\u2026", "num_citations": "16\n", "authors": ["539"]}
{"title": "A Multi-Pronged Approach to Bringing Embedded Systems into Undergraduate Education1\n", "abstract": " NOTE: The first page of text has been automatically extracted and included below in lieu of an abstract", "num_citations": "16\n", "authors": ["539"]}
{"title": "Synthesizing procedural abstractions from formal specifications\n", "abstract": " Requirements prioritization aims at identifying the most important requirements for a system (or a release). A large number of approaches have been proposed so far, to help decision makers in performing this activity. Some of them provide supporting tools. Questions on when a prioritization technique should be preferred to another one as well as on how to characterize and measure their properties arise. Several empirical studies have been conducted to analyze characteristics of the available approaches, but their results are often difficult to compare. In this paper we discuss an empirical study aiming at evaluating two state-of-the art, tool-supported requirements prioritization techniques, AHP and CBRanking. The experiment has been conducted with 18 experienced subjects on a set of 20 requirements from a real project. We focus on a crucial variable, namely the ranking accuracy. We discuss different ways to\u00a0\u2026", "num_citations": "16\n", "authors": ["539"]}
{"title": "OO-SPL modelling of the focused case study\n", "abstract": " This document overviews an object-oriented (OO) modeling approach and a software product line (SPL) methodology used to model the Barbados Crash Management System Product Line (referred to as bCMS-SPL), as well as for a reference variant of such a product line (referred to as bCMS). The approaches and the modeling languages used have been chosen in order to comply with widely used practices and/or (de facto) standards.The starting point for this effort is a set of requirements described in a brief requirements document [5]. Products of bCMS-SPL are intended to support distributed crisis management by police and fire personnel for automotive accidents on public roadways. While police and fire personnel have complementary responsibilities to be done concurrently, these efforts need to be coordinated in order to ensure efficient and effective management of a given crisis. As such, the bCMS-SPL models focus on the functionality of the Police Station Coordinator (PS coordinator) and the Fire Station Coordinator (FS coordinator) and their interactions. The scope of the bCMS-SPL starts with the notification of a crisis to the PS coordinator and FS coordinator concludes at the point when all fire and police personnel have been released from the given crisis. The assumption is that high-level requirements have been gathered and stated in the form of use cases for the bCMS. The modeling of the bCMS and bCMS-SPL target the late requirements briefly overviews the refinement to system architecture.", "num_citations": "15\n", "authors": ["539"]}
{"title": "Evolving models at run time to address functional and non-functional adaptation requirements\n", "abstract": " Increasingly, applications need to dynamically self-reconfigure as new environmental conditions arise at run time. In order to selfreconfigure, an adaptive system must determine which target system configuration will yield the desired behavior based on current execution conditions. However, it may be impractical to evaluate all potential system configurations in a reasonable time frame. This paper presents a model-based approach that leverages evolutionary computation to automatically generate, at run time, target system models that balance tradeoffs between functional and non-functional requirements in response to run-time monitoring of environmental conditions. Specifically, this approach generates graph-based representations of architectural models for potential target system configurations. The current run-time system models serve to constrain the degree of change and novelty in the newly generated models. This approach is applied to the dynamic reconfiguration of a set of remote data mirrors, where operational and reconfiguration costs are minimized, while maximizing data reliability and network performance.", "num_citations": "15\n", "authors": ["539"]}
{"title": "Verifying and analyzing adaptive logic through uml state models\n", "abstract": " It is becoming increasingly important to be able to adapt an application's behavior at run time in response to changing requirements and environmental conditions. Adaptive programs are typically difficult to specify, design, and verify. A variety of conditions may trigger an adaptation, each of which may involve different types of adaptation mechanisms. In many cases, adaptive systems are concurrent, thus further exacerbating the complexity. Furthermore, it is important that adaptations do not put the system into an inconsistent state during or after adaptation. This paper presents an iterative approach to modeling and analyzing UML behavioral design models of adaptive systems, where the UML state diagrams are automatically translated into Promela code for analysis with the Spin model checker. The adaptive models are analyzed for adherence to both system invariants and properties that should hold during\u00a0\u2026", "num_citations": "15\n", "authors": ["539"]}
{"title": "MAPE-K/MAPE-SAC: An interaction framework for adaptive systems with security assurance cases\n", "abstract": " Security certification establishes that a given system satisfies properties and constraints as specified in the system security profile. Mechanisms and techniques have been developed to assess if and how well the system complies with the properties, thereby providing a degree of confidence in the security certification. Generally, certification of security controls defined by NIST SP800-53 is performed at design time to provide confidence in a system\u2019s trustworthiness to achieve the organization\u2019s mission and business requirements. Assuring confidence in a self-adaptive system\u2019s security profile is challenging when both functional and security conditions may change at run time. Static security solutions are insufficient, given that dynamic application of defense mechanisms often needs to dynamically adapt security functionality at run time as part of self-protection. This security adaptation may hinder maintaining\u00a0\u2026", "num_citations": "14\n", "authors": ["539"]}
{"title": "Automotive cybersecurity: Assessing a new platform for cybercrime and malicious hacking\n", "abstract": " The push for technological enhancement and Internet connectivity in all aspects of modern life is radically transforming our use of devices and equipment that was not designed with this functionality. In fact, technological enhancements are transforming the automotive industry by increasing the number of components within the vehicle that are controlled by computers and which provide information to remote systems by various communications methods. These changes create new opportunities for cybercrime, particularly acts of cyber-trespass by computer hackers. This study considers how these technical threats may be limited through the use of criminological theory, specifically a routine activities perspective. The role of various actors in the automotive supply chain, and their potential function to deter and mitigate threats are discussed. The implications of this study for theory and practice are discussed in depth.", "num_citations": "14\n", "authors": ["539"]}
{"title": "Pathfinder 3D: A flow for system-level design space exploration\n", "abstract": " Three dimensional integration technology has the potential to provide enhanced performance and device density gains beyond that available from technology scaling alone. However, it provides plethora of design choices for system designers. The full exploitation of the benefits of 3D integration requires a system-level exploration flow which can facilitate in finding an optimal 3D design by comparing possible early design choices. In this paper we present a flow for fast system-level exploration useful for path finding studies. The flow enables users to explore the tradeoff between different stacking and partitioning schemes in terms of performance, power, and temperature. We also present a free open source design kit compiler, FreePDK3D45 and a tool for fast floorplan evaluation of TSV-based digital architectures, Pathfinder3D. The open source design kit and architecture evaluator can help the community to\u00a0\u2026", "num_citations": "14\n", "authors": ["539"]}
{"title": "Pattern-based modeling and analysis of failsafe fault-tolerance in uml\n", "abstract": " In order to facilitate incremental modeling and analysis of fault-tolerant embedded systems, we introduce an object analysis pattern, called the detector pattern, that provides a reusable strategy for capturing the requirements of failsafe fault-tolerance in an existing conceptual model, where a failsafe system satisfies its safety requirements even when faults occur. We also present a method that (i) uses the detector pattern to help create a behavioral model of a failsafe fault-tolerant system in UML, (ii) generates and model checks formal models of UML state diagrams of the fault-tolerant system, and (Hi) visualizes the model checking results in terms of the UML diagrams to facilitate model refinement. We demonstrate our analysis method in the context of an industrial automotive application.", "num_citations": "14\n", "authors": ["539"]}
{"title": "i2MAP: An Incremental and Iterative Modeling and Analysis Process\n", "abstract": " Detecting errors early within the development process for an embedded system assists a developer in avoiding excessive error correction costs and minimizing catastrophic losses resulting from failures in deployed systems. Towards that end, this paper presents i                         2                         MAP, an iterative and incremental goal-driven process for constructing an analysis-level UML model of an embedded system. The UML model is formally analyzed for adherence to the behavioral properties captured in a companion goal model. The process uses goal modeling to capture the requirements of the system, and uses UML to capture analysis-level structural and behavioral information. Both types of i                         2                         MAP models can be used to drive a rigorous approach to model-driven development of embedded systems. In this paper, we illustrate the i                         2                         MAP process\u00a0\u2026", "num_citations": "14\n", "authors": ["539"]}
{"title": "Towards re-engineering legacy systems for assured dynamic adaptation\n", "abstract": " Increasingly, software must adapt its behavior in response to changes in the supporting computing, communication infrastructure, and in the surrounding physical environment. Since most existing software was not designed to adapt, research on technique to make legacy software dynamically adaptive has gained increasing interest. Assurance is crucial for adaptive software to fulfill its intended purpose. Correctness is even more critical if it is to be applied in high assurance systems. This paper proposes a model-driven approach to introduce dynamic adaptation to non-adaptive legacy systems while maintaining assurance properties. An aspect-oriented technique is applied to achieve separation of concerns in the implementation.", "num_citations": "14\n", "authors": ["539"]}
{"title": "Use case-based modeling and analysis of failsafe fault-tolerance\n", "abstract": " Explicitly addressing fault-tolerance during the requirements analysis phase facilitates the early detection of inconsistencies between functional and fault-tolerance requirements, which could potentially reduce the overall development costs. Most existing approaches use redundancy of services as a means to mask faults, where it is difficult to provide a systematic approach for modeling and analyzing the effect of faults on functional requirements during use case analysis. Moreover, providing masking fault-tolerance could be costly or impractical. This paper overviews a systematic approach for use case-based modeling of faults and failsafe fault-tolerance, where a failsafe fault-tolerant system at least meets its safety requirements when faults occur", "num_citations": "14\n", "authors": ["539"]}
{"title": "Formally specifying and analyzing architectural and functional properties of components for reuse\n", "abstract": " Knowing how a component can be used is as important as knowing what functionality it provides. It is common to consider a component as a collection of functions and data that can be directly invoked or accessed by other components, but there are many other kinds of interactions among components, such as client/server, or a pipeline composed of lters. In these cases, explicitly specifying the ways that a component may interact with other components, that is, the packaging of a component, becomes crucial for reusing the component. We claim that because formal speci cations are amenable to automated reasoning in analyzing component properties, software reuse can be greatly facilitated by formally specifying components. We are exploring the use of formal methods in specifying both functionality and packaging of components.", "num_citations": "14\n", "authors": ["539"]}
{"title": "Automatic detection of incomplete requirements via symbolic analysis\n", "abstract": " The usefulness of a system specification depends in part on the completeness of the requirements. However, enumerating all necessary requirements is difficult, especially when requirements interact with an unpredictable environment. A specification built with an idealized environmental view is incomplete if it does not include requirements to handle non-idealized behavior. Often incomplete requirements are not detected until implementation, testing, or worse, after deployment. Even when performed during requirements analysis, detecting incomplete requirements is typically an error prone, tedious, and manual task. This paper introduces Ares, a design-time approach for detecting incomplete requirements decomposition using symbolic analysis of hierarchical requirements models. We illustrate our approach by applying Ares to a requirements model of an industry-based automotive adaptive cruise control\u00a0\u2026", "num_citations": "13\n", "authors": ["539"]}
{"title": "An ecology-based evolutionary algorithm to evolve solutions to complex problems\n", "abstract": " Evolutionary algorithms have shown great promise in evolving novel solutions to real-world problems, but the complexity of those solutions is limited, unlike the apparently open-ended evolution that occurs in the natural world. In part, nature surmounts these complexity barriers with ecological dynamics that generate a diverse array of raw materials for evolution to build upon. The authors previously introduced Eco-EA, an evolutionary algorithm that integrates these natural ecological dynamics to promote and maintain diversity in the evolving population. Here, we apply the Eco-EA to the real-world software engineering problem of evolving behavioral models for deployed nodes in a remote sensor network for flood monitoring. We show that the Eco-EA evolves good behavioral models faster than a traditional EA, generates a more diverse suite of models than a traditional EA, and creates models that are themselves\u00a0\u2026", "num_citations": "13\n", "authors": ["539"]}
{"title": "Test-driven development of a model transformation with jemtte\n", "abstract": " Jemtte extends the JUnit testing framework with assertions that simplify the testing of model transformations. Jemtte is particularly useful for implementing model transformations in a highly incremental fashion. To demonstrate Jemtte\u2019s capabilities, we walk through the test-driven implementation of a simple model transformation.", "num_citations": "13\n", "authors": ["539"]}
{"title": "A formal automated approach for reverse engineering programs with pointers\n", "abstract": " Given a program S and a precondition Q, the strongest postcondition, denoted sp(S,Q), is defined as the strongest condition that holds after the execution of S, given that S terminates. By defining the formal semantics of each of the constructs of a programming language, a formal specification of the behavior of a program written using the given programming language can be constructed. In this paper we address the formal semantics of pointers in order to handle a realistic model of programming languages that incorporate the use of pointers. In addition, we present a tool for supporting the construction of formal specifications of programs that include the use of pointers.", "num_citations": "13\n", "authors": ["539"]}
{"title": "Enhancing Learning-Enabled Software Systems to Address Environmental Uncertainty\n", "abstract": " An overarching problem with Learning-Enabled Systems (LES) is determining whether training data is sufficient to ensure the LES is resilient to environmental uncertainty and how to obtain better training data to improve the system's performance when it is not. Automated methods can ease the burden for developers by augmenting real-world data with synthetically generated data. We propose an evolution-based method to assist developers with the assessment of learning-enabled systems in environments not covered by available datasets. We have developed Enki, a tool that can generate various conditions of the environment in order to discover properties that lead to diverse and unique system behaviors. These environmental properties are then used to construct synthetic data for two purposes: (1) to assess a system's performance in an uncertain environment and (2) to improve system resilience in the\u00a0\u2026", "num_citations": "12\n", "authors": ["539"]}
{"title": "Towards Model-Driven Sustainability Evaluation\n", "abstract": " Exploring the vision of a model-based framework that may enable broader engagement with and informed decision making about sustainability issues.", "num_citations": "12\n", "authors": ["539"]}
{"title": "Adding formal specifications to requirements patterns\n", "abstract": " Embedded systems usually must achieve a higher level of robustness and reliability because they control real-world physical processes or devices upon which we depend, frequently, in a critical way. Consequently, methods for modeling and developing embedded systems and rigorously verifying behavior before committing to code are increasingly important. In order to use object-oriented development techniques and UML for embedded systems, we previously developed a framework for adding formal semantics to a collection of UML diagrams that enable the automated derivation of formal language specifications for those diagrams. Recently, we also identified a number of requirements patterns for use in the development of requirements and high-level design for embedded systems, and constructed a requirements pattern template. This paper describes how we have augmented the template to include requirements constraints that might be applicable when using a given pattern. With the ability to generate formal specifications from the UML diagrams, these constraints can be analyzed using existing model checkers. We also include a description of how the requirements patterns have been used to model and formally analyze an automotive embedded system.", "num_citations": "12\n", "authors": ["539"]}
{"title": "Generalising the unimodular approach [program code transformation]\n", "abstract": " Most of the available parallelism in source code is contained in loops and is exploited by applying a sequence of loop transformations. Different methods of representing and ordering sequences of transformations have been developed, including the use of unimodular transformations, which unify loop permutation, loop reversal, and loop skewing of perfectly nested loops. This paper presents three extensions to the unimodular approach that make it applicable to a wider range of source code structures. First, the unimodular transformations are extended to represent additional loop transformation techniques, namely loop fission, loop fusion, loop blocking (tiling), strip mining, cycle shrinking, loop coalescing, and loop collapsing. Second, the application of unimodular transformations is generalized to handle both perfectly and imperfectly nested loops. Third, attractive properties of the original unimodular\u00a0\u2026", "num_citations": "12\n", "authors": ["539"]}
{"title": "UML Modeling for Visually-Impaired Persons\n", "abstract": " Software modeling is generally a collaborative activity and typically involves graphical diagrams. The Unified Modeling Language (UML) is the de facto standard for modeling object-oriented software. It provides notations for modeling a system\u2019s structural information (eg databases, sensors, controllers, etc.), and behavior, depicting the functionality of the software. Because UML relies heavily on graphical information, visually impaired persons (VIPs) frequently face challenges conceptualizing the often complex graphical layouts, involving numerous graphical objects. The overall objective of the PRISCA project is to facilitate collaborative modeling between VIPs and other project team members. Towards this end, this paper describes preliminary PRISCA work into developing software that automatically generates a haptic 3D representation of the UML diagrams from the output of an existing UML diagram editor. In addition, textual annotations for the models are converted to Braille and printed in 3D atop the respective graphical objects. Research and human factor challenges are reviewed in the paper in an effort to raise the level of awareness to the MDE community of this important area of work.", "num_citations": "11\n", "authors": ["539"]}
{"title": "Stress analysis of a multilayered composite cylinder with defects\n", "abstract": " The stress analysis of a multilayered composite cylinder with a local delamination is considered. The cylinder comprises an internal thin-walled metal cylinder wrapped in layers formed by winding a unidirectional fiber bundle round it while simultaneously adding epoxy. A realistic analytical model is proposed and a system of differential-difference equations is developed. The problem is reduced to a system of linear ordinary differential equations with constant coefficients by introducing a transformation of super-subscripts. The normal method of solving this kind of system of differential equations is then adopted. The numerical calculations were conducted for a composite cylinder with a local delamination that initiates at the front of a surface notch. The results indicate that the stress distributions are subjected to disturbance due to the delamination in composite cylinder and the stress concentrations occur near the\u00a0\u2026", "num_citations": "11\n", "authors": ["539"]}
{"title": "Formalizing the functional model within object-oriented design\n", "abstract": " The data flow diagram (DFD), originally introduced for structured design purposes, depicts the functions that a system or a module should provide. The objective of a software system is to implement specific functionalities. The function-oriented decomposition strategy of DFDs in the conventional design process for structured design conflicts with the spirit of object-orientation. So far, there is no object-oriented method that has successfully integrated DFDs into the object-oriented development process. In this paper, we demonstrate how DFDs can be modified in order to be integrated into object-oriented development. The Object Modeling Technique (OMT) is used as the context for object-oriented development. In addition, a set of formalization rules are proposed to provide formal semantics for DFDs in order to integrate the functional model with the other two models of OMT, namely, the object and dynamic models, in\u00a0\u2026", "num_citations": "11\n", "authors": ["539"]}
{"title": "Time and/or space sharing in a workstation cluster environment\n", "abstract": " The clustered parallel computer (CPC), based on a workstation cluster, is becoming popular as a choice for high-performance network or parallel computing. However, operating system overheads, network protocols, and higher message-passing latency contribute to a lower overall communication performance in a cluster of workstations, increasing the likelihood that timesharing of parallel jobs can be used to improve system throughput in a workstation cluster. The traditional means by which the CPC minimizes user job turnaround time (JTT) is through space sharing, in which user jobs are given exclusive control over clusters of processors. The objective of this study is to examine methods by which system utilization may be increased by giving timeshared access to parallel jobs without sacrificing the primary goal of minimizing user JTT.< >", "num_citations": "11\n", "authors": ["539"]}
{"title": "A REGIONAL INFORMATION SYSTEM FOR ENVIRONMENTAL DATA ANALYSIS y\n", "abstract": " Many organizations addressing grand challenge problems, such as those de ned by earth sciences, require the integration of both physical and human resource databases in an interactive manner. Such a capability allows reasonably informed policy analysts to query an\\environmental science workstation\" so as to better understand how human uses impact our natural resource base. This paper describes a prototype software tool that supports access to and understanding of diverse environmental information. The tool, Icis (Integrated Contextual Information System), is currently being developed for use in a regional watershed analysis project. Icis consists of two general components: an object-oriented archive of multimedia information objects and a querying facility to search the archive for relevant information. The archive can be populated with a variety of di erent types of information, including documents, satellite imagery, aerial photographs, tabular data, color-coded charts, maps, and illustrative animations. The archive component also supports data integration activities using tools such as a simpli ed geographical information system (GIS) and environmental models.", "num_citations": "11\n", "authors": ["539"]}
{"title": "Automated Optimization of Weighted Non-functional Objectives in Self-adaptive Systems\n", "abstract": " A self-adaptive system (SAS) can reconfigure at run time in response to adverse combinations of system and environmental conditions in order to continuously satisfy its requirements. Moreover, SASs are subject to cross-cutting non-functional requirements (NFRs), such as performance, security, and usability, that collectively characterize how functional requirements (FRs) are to be satisfied. In many cases, the trigger for adapting an SAS may be due to a violation of one or more NFRs. For a given NFR, different combinations of hierarchically-organized FRs may yield varying degrees of satisfaction (i.e., satisficement). This paper presents Providentia, a search-based technique to optimize NFR satisficement when subjected to various sources of uncertainty (e.g., environment, interactions between system elements, etc.). Providentia searches for optimal combinations of FRs that, when considered with\u00a0\u2026", "num_citations": "10\n", "authors": ["539"]}
{"title": "Measure confidence of assurance cases in safety-critical domains\n", "abstract": " Evaluation of assurance cases typically requires certifiers' domain knowledge and experience, and, as such, most software certification has been conducted manually. Given the advancement in uncertainty theories and software traceability, we envision that these technologies can synergistically be combined and leveraged to offer some degree of automation to improve the certifiers' capability to perform software certification. To this end, we present a novel confidence calculation framework that 1) applies the Dempster-Shafer theory as a mathematical model to calculate the confidence between a parent claim and its children claims; and 2) uses the vector space model to evaluate the confidence for the evidence items using traceability information. A fragment of an assurance case (expressed in the goal-structuring notation - GSN) for the coupled tank system is used to illustrate our new framework.", "num_citations": "10\n", "authors": ["539"]}
{"title": "Enabling a roundtrip engineering process for the modeling and analysis of embedded systems\n", "abstract": " Increasingly, object-oriented technology, specifically the Unified Modeling Language (UML), is being used to develop critical embedded systems. There have been several efforts to translate UML models into formal specification languages, thus enabling the models to be analyzed by model checkers. Unfortunately, the complexity and volume of the analysis results often prevents developers from fully taking advantage of the analysis capabilities. This paper introduces a generic visualization framework, Theseus, that provides developers with a model-based, visual interpretation of the analysis results in terms of the original UML diagrams. Within this framework, a playback mechanism displays the execution path that has led to a model checking violation in terms of the original UML state diagram and a newly generated sequence diagram that depicts the problem scenario. A Theseus prototype supporting the Spin and SMV model checkers has been applied to the analysis of UML models for embedded systems from industry.", "num_citations": "10\n", "authors": ["539"]}
{"title": "Modular model checking of dynamically adaptive programs\n", "abstract": " Increasingly, software must dynamically adapt its behavior in response to changes in its runtime environment and user requirements in order to upgrade services, to harden security, or to improve performance. In order for adaptive software to be used in safety critical systems, they must be trusted. In this paper, we introduce a sound approach for modularly verifying whether an adaptive program satisfies its requirements specified in temporal logics (LTL and A-LTL). Compared to existing model checking approaches for adaptive programs, our approach reduces the time/space complexity of verifying an adaptive program by a factor of n, where n is the number of steady-state programs encompassed by the adaptive program. Our approach is orthogonal to many other modular model checking approaches in that it can work in conjunction with other approaches to reduce the overall model checking cost of adaptive programs. We illustrate our technique on the specification and verification of an adaptive mobile computing application.", "num_citations": "10\n", "authors": ["539"]}
{"title": "The object-oriented development of a distributed multimedia environmental information system.\n", "abstract": " Scienti c research addressing global change continues to generate large quantities of information for analysis and understanding. However, the volume, distributed nature, and diversity of this information prohibits convenient access by many potential users. This paper describes the object-oriented analysis and design of a prototype system consisting of an integrated collection of software tools that allows a user to manipulate disparate data sets through a graphical user interface (GUI). The tool, enforms (Environmental Information System), is currently populated with environmental information for use in a regional watershed analysis project. In addition, the bene ts, with respect to extensibility, maintainability, and integration, from using an object-oriented approach in combination with a multi-layered organization are discussed.", "num_citations": "10\n", "authors": ["539"]}
{"title": "Applying formal methods and object-oriented analysis to existing flight software\n", "abstract": " Correctness is paramount for safety-critical software control systems. Critical software failures in medical radiation treatment, communications, and defencse are familiar to the public.", "num_citations": "10\n", "authors": ["539"]}
{"title": "An Integrated Development Environment for Formal Specifications.\n", "abstract": " As software is increasingly used to control critical systems, program correctness becomes paramount. A small change in the implementation of software can have a large and perhaps disastrous impact on its behavior. Formal methods focus a software development e ort on an accurate and precise speci cation of what a software system or component is to achieve. This type of speci cation, when expressed in a precise mathematical notation, is referred to as a formal speci cation. Using formal speci cation languages facilitates the early evaluation of a software design and veri cation of its implementation through the use of formal reasoning techniques. Larch uses a two-tiered approach to formal speci cations. One tier, the Larch Shared Language (LSL), is common to all programming languages. This paper describes a development environment that facilitates the construction of LSL speci cations, including a graphical interface to theorem proving and syntax checking tools.", "num_citations": "10\n", "authors": ["539"]}
{"title": "Data parallel program visualizations from formal specifications\n", "abstract": " As software is used increasingly to control critical systems, program correctness becomes paramount. Correctness is particularly important for parallel and distributed programs since the effects of a single programming error may be magnified greatly due to the parallelism. Using formal specification languages to describe programs minimizes the number of errors that would have been introduced using informal approaches to software development. This paper describes a project that combines formal specifications and visualizations to assist in testing and debugging a parallel program. The Lockheed Integrated Visualization Environment (LIVE) system is a graphical rule-based environment that aids a programmer in the creation of visualizations that depict the behavior of executing programs. The choice of visualization corresponds to the type of programs visualized and the type of errors expected. In order to\u00a0\u2026", "num_citations": "10\n", "authors": ["539"]}
{"title": "Automatic Detection of Feature Interactions Using Symbolic Analysis and Evolutionary Computation\n", "abstract": " Ensuring acceptable and safe behavior is paramount for high-assurance systems. However, independently-developed features often exhibit overlapping, yet conflicting behavior termed feature interactions. This paper introduces Phorcys, a design-time approach for detecting unwanted failures caused by n-way feature interactions at the requirements level using both symbolic analysis and evolutionary computation. Unlike previous n-way feature interaction detection approaches that look for each unique unwanted interactions, Phorcys analyzes each feature for its ability to cause unwanted behavior, including failures. By using a combination of symbolic analysis and evolutionary computation, Phorcys is able to identify multiple counterexamples, thus providing more guidance for mitigation (e.g., revising specifications, adding constraints, etc.). To the best of the authors' knowledge, Phorcys is the only technique to\u00a0\u2026", "num_citations": "9\n", "authors": ["539"]}
{"title": "Run-time monitoring of self-adaptive systems to detect n-way feature interactions and their causes\n", "abstract": " The validity of systems at run time depends on the features included in those systems operating as specified. However, when feature interactions occur, the specifications no longer reflect the state of the run-time system due to the conflict. While methods exist to detect feature interactions at design time, conflicts that cause features to fail may still arise when new detected feature interactions are considered unreachable, new features are added, or an exhaustive design-time detection approach is impractical due to computational costs. This paper introduces Thoosa, an approach for using models at run time to detect features that can fail due to n-way feature interactions at run time and thereby trigger mitigating adaptations and/or updates to the requirements. We illustrate our approach by applying Thoosa to an industry-based automotive braking system comprising multiple subsystems.", "num_citations": "9\n", "authors": ["539"]}
{"title": "Comparison between visual clinical examination and the replica method for assessments of sealant retention over a 2-year period\n", "abstract": " To compare the levels of agreement and the survival rates of sealant retention for different sealing materials over a 2-year period assessed using the visual clinical examination and replica methods, sealant retention data were obtained by visual clinical examination and from replicas of the same sealed tooth at baseline and at 0.5-, 1-and 2-year evaluation points in 407 children and were compared for agreement using kappa coefficients. Survival curves of retained sealants on occlusal surfaces were created using modified categorisation (fully retained sealants and those having all pits and fissures partly covered with the sealant material versus completely lost sealants that included pit and fissure systems that had\u2265 1 pit re-exposed) according to the Kaplan\u2013Meier method. The kappa coefficient for the agreement between both assessment methods over the three evaluation time points combined was 0.38 (95\u00a0\u2026", "num_citations": "9\n", "authors": ["539"]}
{"title": "Goal-oriented patterns for UML-based modeling of embedded systems requirements\n", "abstract": " Embedded systems are used for critical applications that must adhere to safety constraints. Developers of these systems face three key challenges when attempting to apply existing requirements analysis approaches: (1) declaratively specifying functional requirements, non-functional requirements, and constraints; (2) operationally modeling the required behavior; and (3) analyzing the requirements models of the behavior for adherence to the constraints. To address these challenges, this paper introduces Cobra patterns that provide UML and goal model templates to be instantiated in tandem to create models that capture system requirements and their constraints. Structural consistency is established through the construction of the goal and UML models. Behavioral consistency is achieved by analyzing the UML models for adherence to the constraints specified in the goal model.", "num_citations": "9\n", "authors": ["539"]}
{"title": "TA-LTL: Specifying adaptation timing properties in autonomic systems\n", "abstract": " Increasingly, computer software must adapt dynamically to changing conditions. The correctness of adaptation cannot be properly addressed without precisely specifying the requirements for adaptation. In many situation, these requirements involve absolute time, in addition to a logical ordering of events. This paper introduces an approach to formally specifying such timing requirements for adaptive software. We introduce TA-LTL, a timed adaptation-based extension to linear temporal logic, and use this logic to specify three timing properties associated with the adaptation process: safety, liveness, and stability. A dynamic adaptation of interactive audio streaming software is used to illustrate timed temporal logic", "num_citations": "9\n", "authors": ["539"]}
{"title": "Enabling collaborative adaptation across legacy components\n", "abstract": " Software frequently needs to adapt its behavior at run time to respond to changes in its execution environment. Different software components may use different approaches to adaptation. Composing a single adaptive system from existing adaptive components requires an\" adaptation infrastructure\" to integrate and arbitrate adaptive behaviors. This paper proposes a model for such an infrastructure and describes the design and operation ofM2, a prototype implementation.M2 uses a technique called transparent shaping to modify existing components so that they can report events of interest to theM2 core and implement appropriate responses. The architecture and communication infrastructure ofM2 are described, followed by a case study in whichM2 is used to construct an adaptive multimedia conferencing application from otherwise incompatible components.", "num_citations": "9\n", "authors": ["539"]}
{"title": "Facilitating the Maintenance of Safety-Critical Systems\n", "abstract": " As software is increasingly used to control safety-critical systems, correctness becomes paramount. Formal methods in software development provide many benefits in the forward engineering aspect of software development. Reverse engineering is the process of constructing a high-level representation of a system from existing lower level instanti-ations of that system. Reverse engineering of program code into formal specifications facilitates the utilization of the benefits of formal methods in projects where formal methods may not have previously been used, thus facilitating the maintenance of safety-critical systems.", "num_citations": "9\n", "authors": ["539"]}
{"title": "Using analogy and formal methods for software reuse\n", "abstract": " Using formal specifications to represent software components facilitates the determination of reusability because they more precisely characterize the functionality of the software, and the well-defined syntax makes processing amenable to automation. The authors present an approach, based on formal methods, to the modification of reusable software components. From a two-tiered hierarchy of reusable software components, the candidate components that are analogous to the query specification are retrieved from the hierarchy. A retrieved component is compared to the query specification to determine what changes needed to be applied to the corresponding program component in order to make it satisfy the query specification.", "num_citations": "9\n", "authors": ["539"]}
{"title": "Security Patterns for Automotive Systems\n", "abstract": " As automotive systems become increasingly sophisticated with numerous onboard features that support extensive inward and outward facing communication, cybersecurity vulnerabilities are exposed. The relatively recent acknowledgement of automotive cybersecurity challenges has prompted numerous research efforts into developing techniques to handle individual threat vectors, the pathways and threat surfaces by which an attack can be realized. Security design patterns have been developed for many application domains (e.g., enterprise systems, networking systems, and distributed systems), but not much has been explored for automotive systems. This paper introduces a collection of security design patterns targeted for automotive cybersecurity needs. We leverage and extend the de facto standard template used to describe design patterns to include fields specific to the automotive domain and SAE J3061\u00a0\u2026", "num_citations": "8\n", "authors": ["539"]}
{"title": "MAPE-SAC: A Framework to Dynamically Manage Security Assurance Cases\n", "abstract": " Assuring security compliance in self-adaptive systems is challenging, notably as both functional and security conditions may change at run time, where adaptation of functional behavior may violate security requirements or vice versa. In traditional systems, certification is performed at design time on the mechanisms that will be deployed to guarantee the effectiveness of organizationally chosen and instantiated security controls defined by standards bodies (e.g., NIST SP800-53). In contrast, adaptive systems benefit by run-time adaptations for which dynamic certification could be difficult. Confidence in an information system's compliance with security constraints can be expressed using security assurance cases (SACs). Specifically, NIST security controls follow a repeated structure that make them amenable to their specification in terms of SACs. The collection of SACs for the related security controls form a network\u00a0\u2026", "num_citations": "8\n", "authors": ["539"]}
{"title": "Applying Evolution and Novelty Search to Enhance the Resilience of Autonomous Systems\n", "abstract": " We investigate the integration of evolutionary algorithms and novelty search in order to improve the performance and resilience of autonomous systems. We have developed two tools for this purpose: Evo-ROS and Enki. Evo-ROS combines evolutionary search with physics-based simulations of autonomous systems whose software infrastructure is based on the Robot Operating System (ROS). Enki uses novelty search to discover operational scenarios that lead to the most diverse behavior in the target system. Combining these tools yields an automated approach to explore the operational landscape of the target system, identify regions of poor performance, and evolve system parameters that better respond to adverse situations. In this paper, we present results of a case study of the throttle controller on AutoRally, a 1:5-scale autonomous vehicle designed by researchers at Georgia Tech for the study of aggressive\u00a0\u2026", "num_citations": "8\n", "authors": ["539"]}
{"title": "UML formalization is a traceability problem\n", "abstract": " Largely driven by the widespread interest in using UML, significant efforts have investigated how to formalize its semantics in terms of well-defined target languages. Associating target language specifications with the UML models enables automated analysis of its many graphical diagrams. Unfortunately, UML formalizations have proved difficult to completely automate. This paper posits that UML formalization is essentially a traceability problem, which means to rigorously link elements of a given UML diagram to relevant regions of code in a given target model according to the intended formalization semantics. We present a graph-theoretic model for formally defining this link-retrieval problem. We also introduce a framework for assessing whether a UML formalization is amenable to efficient link retrieval techniques without sacrificing precision and/or recall.", "num_citations": "8\n", "authors": ["539"]}
{"title": "Integrating informal and formal approaches to requirements modeling and analysis\n", "abstract": " The Unified Modeling Language (UML) comprises several different notations for object-oriented modeling with no formal semantics attached to the individual diagrams. We have developed a generic framework for formalizing a subset of UML diagrams in terms of various formal languages, with a focus on embedded systems. We have formalized UML in terms of Promela, thus enabling analysis of the UML diagrams by the SPIN model checker and simulator. We have also developed a number of visualizations to assist in the interpretation of the analysis results. This paper presents a case study of the UML design and automated analysis of an industrial automotive embedded system using our formalization techniques, supporting tools and existing analysis.", "num_citations": "8\n", "authors": ["539"]}
{"title": "PACKRAT: a software reengineering case study\n", "abstract": " Reengineering is the process of examination, understanding, and alteration of a system with the intent of implementing the system in a new form. Many approaches for design recovery or reverse engineering have been suggested, most with some type of support tool. Since a project's time constraints may prohibit use of sophisticated techniques and/or tools due to the learning curves associated with the techniques and tools, methods that can be applied in lieu of complex support tools may be required. This paper describes a case study project involving the reengineering of a network application used by Texas Instruments to monitor network traffic in a local area network.", "num_citations": "8\n", "authors": ["539"]}
{"title": "An evolutionary approach to discovering execution mode boundaries for adaptive controllers\n", "abstract": " Adaptive controllers enable cyber-physical systems, such as autonomous robots, to manage uncertain conditions during execution. However, there is a limit to the range of conditions that can be handled by a given controller. When this limit is exceeded, a controller might fail to respond as expected, not only rendering it ineffective but possibly putting the entire system at risk. In this paper, we describe a method based on evolutionary search for automatically enhancing, and discovering the boundaries of, a given adaptive controller. Collectively, these boundaries define an execution mode for that controller. Explicit specification of mode boundaries facilitates the development of decision logic that determines, based on system state and sensed conditions, when to switch to a different execution mode and typically a different controller, such as one for providing fail-safe operation. To evaluate the proposed approach, we\u00a0\u2026", "num_citations": "7\n", "authors": ["539"]}
{"title": "Validating code-level behavior of dynamic adaptive systems in the face of uncertainty\n", "abstract": " A dynamically adaptive system (DAS) self-reconfigures at run time in order to handle adverse combinations of system and environmental conditions. Techniques are needed to make DASs more resilient to system and environmental uncertainty. Furthermore, automated support to validate that a DAS provides acceptable behavior even through reconfigurations are essential to address assurance concerns. This paper introduces Fenrir, an evolutionary computation-based approach to address these challenges. By explicitly searching for diverse and interesting operational contexts and examining the resulting execution traces generated by a DAS as it reconfigures in response to adverse conditions, Fenrir can discover undesirable behaviors triggered by unexpected environmental conditions at design time, which can be used to revise the system appropriately. We illustrate Fenrir by applying it to a dynamically\u00a0\u2026", "num_citations": "7\n", "authors": ["539"]}
{"title": "Building Biologically-Inspired Self-Adapting Systems.\n", "abstract": " Biological systems are far more complex than systems we design and build today. The human body alone has orders of magnitude more complexity than our most-intricate designed systems. Further, biological systems are decentralized in such a way that allows them to benefit from built-in error-correction, fault tolerance, and scalability. It follows that if we can extract certain properties of biological systems and inject them into our software design process, we may be able to build complex self-adaptive software systems. Biological systems\u00c3\u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 complexity makes them not only desirable to guide software design, but also difficult to fully understand. Thus one approach to building software similar to biological systems is by first building models of biology that we can understand. Then these models can guide the high-level design, or architecture of the software systems, resulting in systems that retain the model\u00c3\u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 s fault tolerance, scalability, and other properties. I present a general outline of how one might use biology to create a model to guide the architecture of a software system, and develop one such model and the resulting architectural style, the tile style, for computational systems that can use a large distributed network of computers, such as the internet, to solve computationally-intensive problems in a discreet, fault-tolerant, and scalable manner.", "num_citations": "7\n", "authors": ["539"]}
{"title": "A suite of tools for facilitating reverse engineering using formal methods\n", "abstract": " As a program evolves, it becomes increasingly difficult to understand and reason about changes in source code. Eventually if enough changes are made without a corresponding modification of the software documentation, reverse engineering and design recovery techniques must be used in order to understand the current behavior of a system. In our previous investigations, we described a formal technique for reverse engineering. One of the benefits of formal techniques is that they are amenable to automated processing. In this paper, we describe an integrated suite of tools that we have developed to support reverse engineering and analysis of C programs.", "num_citations": "7\n", "authors": ["539"]}
{"title": "A visualization-based environment for top-down debugging of parallel programs\n", "abstract": " This paper describes a parallel debugging environment that applies visualizations in a top-down, structured approach for debugging. This environment, referred to as GOLD, uses visualization in the traditional way for examining a program state, but it also extends the use of visualizations in two directions. First, a technique is described for using visualizations to guide the operation of setting a causal distributed breakpoint for a set of processes. Second, a strategy is introduced for coordinating the use of different types of visualization when examining a program state.< >", "num_citations": "7\n", "authors": ["539"]}
{"title": "An object-oriented toolkit for constructing specification editors\n", "abstract": " Formal software development techniques facilitate the design and implementation of more reliable computer systems, which is particularly important for the development of safety-critical systems. In particular, formal speci cation languages provide a means for precisely characterizing the behavior of a computer system and its components, and facilitates the determination of correct implementation using automated reasoning techniques. While formal speci cations can be created using a word processor or typesetter, the process is neither easy nor suitable for large scale software speci cation. Tools supporting the application of formal methods are needed to make these activities easier, and thus more practical to use. This paper discusses Spectacle, an object-oriented library of software components designed for constructing formal speci cation editing tools; prototype speci cation editors built from this library are presented.", "num_citations": "7\n", "authors": ["539"]}
{"title": "Automatic detection of incomplete requirements using symbolic analysis and evolutionary computation\n", "abstract": " The usefulness of a system specification depends on the completeness of the requirements specified. Unfortunately it is difficult to ensure a requirements specification includes all necessary requirements, especially when the system interacts with an unpredictable and often idealized environment. Worse yet, a single completeness counterexample may not clearly indicate the extent that incomplete requirements impacts the system or what range of environmental scenarios are affected. This paper introduces Ares-EC, a design-time approach for detecting incomplete requirements decomposition using a combination of evolutionary computation and symbolic analysis of hierarchical requirements models to detect a set of representative incompleteness counterexamples. We illustrate our approach by applying Ares-EC to a requirements model of an industry-based automotive adaptive cruise control system\u00a0\u2026", "num_citations": "6\n", "authors": ["539"]}
{"title": "Goal-oriented specification of adaptation semantics in adaptive systems\n", "abstract": " Goal-Oriented Specification of Adaptation Semantics in Adaptive Systems Page 1 Goal-Oriented Specification of Adaptation Semantics in Adaptive Systems Greg Brown, Betty HC Cheng, Heather Goldsby, Ji Zhang Presented by Ji Zhang This work was supported in part by the US Department of the Navy, Office of Naval Research under Grant No. N00014-01-1-0744, and in part by National Science Foundation grants CCR-9901017, EIA-0000433, EIA-0130724, CCF-0541131, and CNS-0551622, and ITR-0313142, and by Siemens Cooperate Research, and a Michigan State University Quality Fund Concept Grant. Page 2 Need for Dynamic Adaptation Military Applications Handheld/Wearable Computing Sensor Networks \u2022 Pervasive Computing. \u2013 Promises anywhere, anytime access to data and computing. \u2022 Autonomic Computing. \u2013 Promises self-managed and long-running systems that require only limited human \u2026", "num_citations": "6\n", "authors": ["539"]}
{"title": "Object-oriented modeling and automated analysis of a telemedicine application\n", "abstract": " As the impact of and demand for software increases, there is greater need for rigorous software development techniques that can be used by a typical software engineer. We have added formal syntax and semantics definitions to an existing object-oriented modeling notation in order to integrate informal and formal approaches to software development. This formalization enables developers to construct object oriented models of requirements and designs and then automatically generate formal specifications for the diagrams. These formal specifications enable the diagrams to be analyzed by a number of existing automated reasoning utilities, including behavior simulators, model checkers and rewriting systems.", "num_citations": "6\n", "authors": ["539"]}
{"title": "A distributed, multimedia environmental information system\n", "abstract": " Scientific research addressing global change continues to generate large quantities of information for analysis and understanding. However, the volume, distributed nature, and diversity of this information prohibits convenient access by many potential users. This paper describes an object-oriented, distributed system consisting of an integrated collection of software tools that allows a user to query and manipulate distributed, multimedia data sets through a graphical user interface (GUI). The tool, ENFORMS (ENvironmental inFORMation System), is currently populated with environmental information for use in a regional watershed analysis project.", "num_citations": "6\n", "authors": ["539"]}
{"title": "Automated Synthesis of Data Abstractions\n", "abstract": " Research into the development of software tools that support formal methods is aimed at simplifying and providing assistance during the development of correct software. We have developed the Seed system that uses techniques amenable to automation in order to assist a user in the correct development of the building blocks of a large software system from user-supplied formal speci cations. Seed accepts a formal speci cation of a problem written in predicate logic and generates annotated program source code satisfying the speci cation. The rules for choosing which programming language structures to synthesize are contained in a rule base; background knowledge and domainspeci c information are entered into a fact base. During synthesis, Seed uses the fact base to disambiguate rule applications. In addition to primitive programming language constructs, such as assignment, alternative and iterative statements, Seed is capable of synthesizing recursive and non-recursive procedures and functions, as well as abstract data types. This paper describes the details of the synthesis of abstract data types using the Seed system.", "num_citations": "6\n", "authors": ["539"]}
{"title": "Ransomware Targeting Automobiles\n", "abstract": " Ransomware has consistently been the top threat to security in recent years. It seems inevitable that ransomware developers will ultimately target automobiles. As vehicles get smarter and more connected, the threat surface widens and automobiles naturally become more vulnerable to Internet-based threats such as ransomware. In this paper, we identify the constraints on ransomware in the context of automobiles and demonstrate potential ransomware attacks. The demonstrations entail attack vectors targeted at the IVI system and the methodology for implementing a hybrid crypto ransomware on an IVI system. Finally, we clarify the new ransomware strategies that the attackers could leverage in the context of vehicular systems with the intent to promote research to prevent such attacks.", "num_citations": "5\n", "authors": ["539"]}
{"title": "Using Models at Run Time to Detect Incomplete and Inconsistent Requirements.\n", "abstract": " The validity of run-time monitoring of system goals and requirements depends on both the completeness of the requirements, as well as the correctness of the environmental assumptions. Often specifications are built with an idealized view of the environment that leads to incomplete and inconsistent requirements related to non-idealized behavior. Worse yet, requirements may be measured as satisfied at run time despite an incomplete or inconsistent decomposition of requirements due to violated environmental assumptions. While methods exist to detect incomplete requirements at design time, environmental assumptions may be invalidated in unexpected run-time environments causing undetected incomplete decompositions. This paper introduces Lykus, an approach for using models at run time to detect incomplete and inconsistent requirements decompositions at run time. We illustrate our approach by applying Lykus to a requirements model of an adaptive cruise control system from our industrial collaborators. Lykus is able to automatically detect instances of incomplete and inconsistent requirements decompositions at run time.", "num_citations": "5\n", "authors": ["539"]}
{"title": "Digital enzymes: agents of reaction inside robotic controllers for the foraging problem\n", "abstract": " Over billions of years, natural selection has continued to select for a framework based on (1) parallelism and (2) cooperation across various levels of organization within organisms to drive their behaviors and responses. We present a design for a bottom-up, reactive controller where the agent's response emerges from many parallelized, enzymatic interactions (bottom-up) within the biologically-inspired process of signal transduction (reactive). We use enzymes to explore the potential for evolving simulated robot controllers for the central-place foraging problem. The properties of the robot and stimuli present in its environment are encoded in a digital format (\" molecule\") capable of being manipulated and altered through self-contained computational programs (\" enzymes\") executing in parallel inside each controller to produce the robot's foraging behavior. Evaluation of this design in unbounded worlds reveals\u00a0\u2026", "num_citations": "5\n", "authors": ["539"]}
{"title": "A framework for modeling and analyzing fault-tolerance\n", "abstract": " The development of fault-tolerant systems continues to be difficult due to the evolving and crosscutting nature of fault-tolerance requirements. Fault-tolerance research has largely focused on how to design and implement fault-tolerant systems. Regardless of how fault-tolerance is provided, however, it is equally important to determine what constraints should be met both in the absence and in the presence of faults. In order to address this question, this paper describes a systematic method for modeling and analyzing fault-tolerance concerns in UML at the requirements analysis phase. First, we present an approach for use case analysis of fault-tolerance requirements based on two canonical families of constraints, namely detection and correction constraints. Second, we present a method for object analysis of fault-tolerance requirements where we refine our use case analysis model using two object analysis patterns, called detector and corrector patterns. These detector and corrector object analysis patterns are based on the formal definition of detector and corrector components, which have been proven to be necessary and sufficient for the design of fault-tolerance. Finally, we define an Object Computation Model to provide a formal semantics for our fault-tolerance object analysis patterns. The Object Computation Model can be instantiated to different target specification languages using previously developed UML formalization framework, Hydra. As a result, we are able to automatically generate formal specification for the UML diagrams comprising the composition of functional and fault-tolerance requirements, thus enabling the automated\u00a0\u2026", "num_citations": "5\n", "authors": ["539"]}
{"title": "Reusing Analogous Components\n", "abstract": " Using formal speci cations to represent software components facilitates the determination of reusability because they more precisely characterize the functionality of the software, and the well-de ned syntax makes processing amenable to automation. This paper presents an approach, based on formal methods, to the search, retrieval, and modi cation of reusable software components. From a two-tiered hierarchy of reusable software components, the existing components that are analogous to the query speci cation are retrieved from the hierarchy. The speci cation for an analogous retrieved component is compared to the query speci cation to determine what changes need to be applied to the corresponding program component in order to make it satisfy the query speci cation. This paper also describes an approach for assisting the modi cation of analogous components and gives an example to demonstrate its use.", "num_citations": "5\n", "authors": ["539"]}
{"title": "Bridging the gap between informal and formal approaches to software development\n", "abstract": " Attempting to construct a formal description of a system's requirements directly from a requirements document can be a challenging task. Formal descriptions often involve extensive syntactic details whose meanings are determined by subtle semantics. It is important to develop modular descriptions as a strategy for managing the complexity and maximizing the reusability of the speci cations. This paper describes an integrated, tool-based approach to the development of modular formal speci cations. A suite of graphical notations based on an object-oriented modeling strategy known as the Object Modeling Technique (OMT) is used as a framework for modular speci cation development. OMT, like many popular modeling and development methods, uses diagrams to visually present important characteristics of a system's architecture and operational behavior. The paper describes how the graphical OMT notations\u00a0\u2026", "num_citations": "5\n", "authors": ["539"]}
{"title": "AC-ROS: assurance case driven adaptation for the robot operating system\n", "abstract": " Cyber-physical systems that implement self-adaptive behavior, such as autonomous robots, need to ensure that requirements remain satisfied across run-time adaptations. The Robot Operating System (ROS), a middleware infrastructure for robotic systems, is widely used in both research and industrial applications. However, ROS itself does not assure self-adaptive behavior. This paper introduces AC-ROS, which fills this gap by using assurance case models at run time to manage the self-adaptive operation of ROS-based systems. Assurance cases provide structured arguments that a system satisfies requirements and can be specified graphically with Goal Structuring Notation (GSN) models. AC-ROS uses GSN models to instantiate a ROS-based MAPE-K framework, which in turn uses these models at run time to assure system behavior adheres to requirements across adaptations. For this study, AC-ROS is\u00a0\u2026", "num_citations": "4\n", "authors": ["539"]}
{"title": "Evolution in action: past, present and future\n", "abstract": " The BEACON Congress in August 2018 provided an opportunity to celebrate its founding director Professor Erik Goodman\u2019s remarkable achievements on the occasion of his 75th birthday. A number of the presentations at that 2018 BEACON Congress were specifically dedicated to him. This volume Evolution in Action\u2014Past, Present, and Future combines some of these with additionally solicited contributions from colleagues and members of BEACON who could not attend the 2018 Congress.The contributions published here range from refreshingly personal stories of encounters with Dr. Goodman, the history and achievements of the BEACON Center for the Study of Evolution in Action under his leadership, to research topics presented along the lines of the research thrust groups in the BEACON Center. These topics dominate Parts I to V of the book. An important focus of BEACON has always been education\u00a0\u2026", "num_citations": "4\n", "authors": ["539"]}
{"title": "A pattern-based approach for modeling and analyzing error recovery\n", "abstract": " Several approaches exist for modeling recovery of fault- tolerant systems during the requirements analysis phase. Most of these approaches are based on design techniques for recovery. Such design-biased analysis methods unnecessarily constrain an analyst when specifying recovery requirements. To remedy such restrictions, we present an object analysis pattern, called the corrector pattern, that provides a generic reusable strategy for modeling error recovery requirements for embedded systems. In addition to templates for constructing structural and behavioral models of recovery requirements, the corrector pattern also contains templates for specifying properties that can be formally verified to ensure the consistency between recovery and functional requirements. Additional property templates can be instantiated and verified to ensure the fault-tolerance of the system to which the corrector pattern has\u00a0\u2026", "num_citations": "4\n", "authors": ["539"]}
{"title": "Incorporating Large-scale Projects into a Multidisciplinary Approach to Embedded Systems\n", "abstract": " Embedded computer systems play an increasingly important role in today\u2019s society. In order to adequately prepare today\u2019s computer science, computer engineering, and electrical engineering students for their future careers, the special problems with embedded systems development must be adequately addressed in their education. VESL (Visions for Embedded Systems Laboratories) is a project that is designed to address the needs in undergraduate computer science and engineering education. The project develops a multi-pronged approach to bringing embedded systems into undergraduate education. The approach comprised modular course pack development, suitable for alternative teaching models, such as team teaching and development of multi-disciplinary course; team projects to give students hand-on experience with embedded systems; and incorporation of innovative teaching techniques designed to facilitate and enhance the student\u2019s learning experience. The multi-pronged approach has been applied and specifically incorporated embedded systems into a suite of relevant courses: software engineering, operating systems, digital system design, and computer system design. This paper reports the concept and practice of introducing objective-oriented modeling to embedded systems development and the application of digital systems design to embedded systems. Students have enthusiastically embraced the courses, citing both the teaming and design projects as being representative of realword industry experience.", "num_citations": "4\n", "authors": ["539"]}
{"title": "A transparent monitoring tool for shared-memory multiprocessors\n", "abstract": " Monitoring and debugging of parallel programs is complicated by race conditions, which can cause software monitoring to alter program behavior. To avoid these unwanted modifications of program execution, the authors present a flexible scheme for transparently monitoring parallel programs in a shared-memory environment. To achieve transparency, the monitor observes causal relations between events in different threads of execution, and intervenes when an impending event would change the order of occurrence of causally related events, as compared to unmonitored execution of the same program. Constructs used to support this monitoring scheme are developed, including mechanisms to deal with unsynchronized and coarse grained clocks. The monitoring scheme requires the instrumentation of every shared-memory access. To measure the overhead created by this intrusion, a prototype monitor has\u00a0\u2026", "num_citations": "4\n", "authors": ["539"]}
{"title": "Providentia: Using search-based heuristics to optimize satisficement and competing concerns between functional and non-functional objectives in self-adaptive systems\n", "abstract": " In general, a system may be subject to a combination of functional requirements (FRs) that dictate behavior and non-functional requirements (NFRs) that characterize how FRs are to be satisfied. NFRs also introduce cross-cutting concerns that may be difficult to predict, where the degree of satisfaction (i.e., satisficement) of one NFR may be impacted by the satisficement of one or more FRs/NFRs. In particular, self-adaptive systems (SASs) can modify system configurations or behaviors at run time to continuously satisfy FRs and NFRs. This paper presents Providentia, a search-based technique to optimize the satisficement of NFRs in an SAS experiencing various sources of uncertainty. Providentia explores different combinations of weighted FRs to maximize NFR/FR satisficement. Experimental results suggest that Providentia-optimized goal models significantly improve the satisficement of an SAS when compared\u00a0\u2026", "num_citations": "3\n", "authors": ["539"]}
{"title": "Goal-Based Modeling and Analysis of Non-Functional Requirements\n", "abstract": " Non-functional goals specify a quality attribute of the functional goals for the system-to-be (e.g., cost, performance, security, and safety). However, non-functional goals are often cross-cutting and do not naturally fit within the default decomposition expressed by a functional goal model. Further, any functional mitigations that ensure the satisfaction of a non-functional goal, or occur in the event a non-functional goal is violated, are conditionally applicable to the remainder of the system-to-be. Rather than modeling non-functional goals and their associated mitigations as a part of the system-to-be goal model, we introduce a method of modeling and analyzing non-functional goals and their associated mitigation as separate models. We illustrate our approach by applying our method to model non-functional goals related to an industry-based automotive braking system and analyzing for non-functional violations.", "num_citations": "3\n", "authors": ["539"]}
{"title": "An approach to mitigating unwanted interactions between search operators in multi-objective optimization\n", "abstract": " At run time, software systems often face a myriad of adverse environmental conditions and system failures that cannot be anticipated during the system's initial design phase. These uncertainties drive the need for dynamically adaptive systems that are capable of providing self-* properties (eg, self-monitoring, self-adaptive, self-healing, etc.). Prescriptive techniques to manually preload these systems with a limited set of configurations often result in brittle, rigid designs that are unable to cope with environmental uncertainty. An alternative approach is to embed a search technique capable of exploring and generating optimal reconfigurations at run time. Increasingly, DAS applications are defined by multiple competing objectives (eg, cost vs. performance) in which a set of valid solutions with a range of trade-offs are to be considered rather than a single optimal solution. While leveraging a multi-objective optimization\u00a0\u2026", "num_citations": "3\n", "authors": ["539"]}
{"title": "Motivating Use Cases for the Globalization of DSLs\n", "abstract": " The development of complex software-intensive systems involves many stakeholders who contribute their expertise on specific aspects of the system under construction. Domain-specific languages (DSLs) are typically used by stakeholders to express their knowledge of the system using dedicated tools and abstractions. In this chapter, we explore different scenarios that lead to the globalization of DSLs through two motivating case studies \u2013 a command and control wind tunnel and a smart emergency response system \u2013 and outline the concrete engineering challenges they raise. Finally, we list some of the general research challenges related to the globalization of DSMLs and discuss some promising approaches for addressing them.", "num_citations": "3\n", "authors": ["539"]}
{"title": "Exploring the evolution of internal control structure using digital enzymes\n", "abstract": " The Digital Enzyme model of control is based on the bottom-up, reactive process of signal transduction found in cells. An earlier study applied a specific instance of the this model to the foraging problem. Here, we extend the system and use it to explore a fundamental question in both biology and evolutionary computation, namely, whether environmental complexity is a driving factor for an organism''s internal control structure. To address this question, we extended the original system to allow the open-ended evolution of the unique programs, instructions, and threads within each controller. With the extended model, we were able to evolve successful foraging strategies that nearly doubled the performance of strategies found in the earlier work. In response to increasing environmental complexity, we discovered a high degree of variation for the number of programs, threads, and instructions that produced successful\u00a0\u2026", "num_citations": "3\n", "authors": ["539"]}
{"title": "Design patterns for monitoring adaptive ULS systems\n", "abstract": " As applications grow in size and complexity, and computing infrastructure continues to evolve, it is increasingly difficult to build a system that satisfies all requirements and constraints that might arise during its lifetime. As a result, there is increasing need for the software to adapt to new requirements and environmental conditions after the software has been deployed. Autonomic computing refers to a system that monitors itself based on high-level objectives and achieves, with minimal human guidance, self-management, and self-conguration. While progress has been made recently in applying rigorous development techniques to autonomic software, self-monitoring has received little attention. This paper describes a preliminary investigation into identifying design patterns associated with the self-monitoring aspects of autonomic computing systems.", "num_citations": "3\n", "authors": ["539"]}
{"title": "Applying digital evolution to the development of self-adaptive ULS systems\n", "abstract": " A key characteristic for ultra-large scale (ULS) software- intensive systems is the need to adapt at run time in response to changing environmental conditions. Given the scale, complexity, and heterogeneity of ULS elements, innovative, but rigorous software engineering techniques are needed to address the development and the evolution of these systems. The developer of self-adaptive ULS systems must anticipate how and when the software will need to adapt in the future, codify this behavior in decision-making components to govern the adaptation, and ensure that system integrity is not compromised during adaptations. We contend that the full potential of dynamically adaptive software systems cannot be realized without environments that enable the developer to actively explore the \"adaptation space \" of the system during the early stages of design. We propose an approach to this problem that leverages and\u00a0\u2026", "num_citations": "3\n", "authors": ["539"]}
{"title": "Guest Editors' Introduction: Requirements Engineering-Integrating Technology.\n", "abstract": " The Y2K issue generated an enormous flood of activity for organ-izations worldwide. While we survived Y2K with minor glitches, the Y2K \u201cexercise\u201d forced both developers and users of software to appreciate the need for software to function correctly in expected and unexpected situations. 1 None of us is immune to the problems of guest editors\u2019 introduction made only incremental progress. Perhaps this is partly because the engineering of software is generally very difficult. After all, any uncertainty in a system is usually handled in software, since it is \u201ceasier\u201d to change software. To make matters worse, as computing technology advances, greater demands are placed on software: an increasing number of critical systems rely on software, from avionics and air traffic control to banking and financial systems to medical life-support systems. Software is pervasive, and software errors have potential for costly disasters\u00a0\u2026", "num_citations": "3\n", "authors": ["539"]}
{"title": "A formal approach to modeling expected behavior in parallel program visualizations\n", "abstract": " Visualizations of program execution are useful for debugging the complex behavior of parallel programs. However, the effectiveness of the visualizations is limited by how well their representations match the programmer's conceptual model of the expected program behavior. In this paper, we show that the LOTOS specification of a parallel program may be used to model expected behavior in the visualizations of the program's execution. We developed a prototype debugging environment, Panorama, to provide a framework for the modeling of expected behavior, collection of trace data, and the generation of the corresponding visualizations. We illustrate, by example, that debugging of incorrect message-passing communication is facilitated by this visualization strategy.", "num_citations": "3\n", "authors": ["539"]}
{"title": "\u201cKnow What You Know\u201d: Predicting Behavior for Learning-Enabled Systems When Facing Uncertainty\n", "abstract": " Since deep learning systems do not generalize well when training data is incomplete and missing coverage of corner cases, it is difficult to ensure the robustness of safety-critical self-adaptive systems with deep learning components. Stakeholders require a reasonable level of confidence that a safety-critical system will behave as expected in all contexts. However, uncertainty in the behavior of safety-critical Learning-Enabled Systems (LESs) arises when run-time contexts deviate from training and validation data. To this end, this paper proposes an approach to develop a more robust safety-critical LES by predicting its learned behavior when exposed to uncertainty and thereby enabling mitigating countermeasures for predicted failures. By combining evolutionary computation with machine learning, an automated method is introduced to assess and predict the behavior of an LES when faced with previously unseen\u00a0\u2026", "num_citations": "2\n", "authors": ["539"]}
{"title": "Assuring Vehicle Update Integrity Using Asymmetric Public Key Infrastructure (PKI) and Public Key Cryptography (PKC)\n", "abstract": " Over the past forty years, the Electronic Control Unit (ECU) technology has grown in both sophistication and volume in the automotive sector, and modern vehicles may comprise hundreds of ECUs. ECUs typically communicate via a bus-based network architecture to collectively support a broad range of safety-critical capabilities, such as obstacle avoidance, lane management, and adaptive cruise control. However, this technology evolution has also brought about risks: if ECU firmware is compromised, then vehicle safety may be compromised. Recent experiments and demonstrations have shown that ECU firmware is not only poorly protected but also that compromised firmware may pose safety risks to occupants and bystanders. While there have been no known instances of ECU firmware tampering on consumer vehicles outside of controlled academic or security research, and other work has been done to\u00a0\u2026", "num_citations": "2\n", "authors": ["539"]}
{"title": "Towards the Detection of Partial Feature Interactions\n", "abstract": " Discrete feature interactions occur when the presence of overlapping, yet conflicting, features impact the functionality of an entire system such that one or more features are unsatisfied. However, adaptive systems may mitigate uncertainty by composing features from requirements that may be partially satisfied or partially unsatisfied (i.e., satisficed). In contrast to discrete interactions, these satisficed features that are composed of satisficed requirements may be partially unsatisfied due to a feature interaction. Feature interactions, in the case of satisficement, result in a proportional trade-off between conflicting objectives rather than a complete, or discrete, failure of features or the system. In this paper, we propose a new concept, partial feature interactions, to represent the class of feature interactions that allow for satisficement trade-offs between conflicting features. We also describe a method to reduce the\u00a0\u2026", "num_citations": "2\n", "authors": ["539"]}
{"title": "Specifying real-time properties in autonomic systems\n", "abstract": " Increasingly, computer software must adapt dynamically to changing conditions. The correctness of adaptation cannot be rigorously addressed without precisely specifying the requirements for adaptation. In many situations, these requirements involve absolute time, in addition to a logical ordering of events. This paper introduces an approach to formally specifying such timing requirements for adaptive software. We introduce TA-LTL, a timed adaptation-based extension to linear temporal logic, and use this logic to specify three timing properties associated with the adaptation process: safety, liveness, and stability. A dynamic adaptation scenario involving interactive audio streaming software is used to illustrate the timed temporal logic.", "num_citations": "2\n", "authors": ["539"]}
{"title": "A Metamodel-Based Approach to Formalizing UML\n", "abstract": " The {\\it Unified Modeling Language}(UML) comprises several different notations for object-oriented modeling with no formal semantics attached to the individual diagrams. We have developed a general framework for formalizing a subset of UML diagrams in terms of various formal languages, with a focus on embedded systems. We take a homomorphic approach in our formalization framework by constructing mappings from the metamodels of UML diagrams to the metamodel of a given target specification language. Using this approach, we have formalized UML in terms of VHDL and Promela, the specification language for the SPIN model checker. An overarching goal of this project is to provide users with a migration path from existing object-oriented modeling notations to target specification languages that have extensive tool support. The existing tools enable the analysis of the UML diagrams via their\u00a0\u2026", "num_citations": "2\n", "authors": ["539"]}
{"title": "Moving industry-guided multimedia technology into the classroom\n", "abstract": " Given the ubiquity of multimedia technology, it is important that Computer Science students not only learn the basics of multimedia design, but also gain hands-on experience with applications of the technology. This paper describes the integration of multimedia concepts and tools into a Computer Science curriculum. An NSF-sponsored Multimedia Laboratory was established and used to support three senior-level courses: software engineering, computer graphics, and computer networks. Curriculum development, laboratory exercises, and the role of projects are described.", "num_citations": "2\n", "authors": ["539"]}
{"title": "Synthesis of Data Abstractions from Formal Specifications\n", "abstract": " This paper describes the development of the SEED system, which demonstrates that the building blocks of a large software system can be correctly synthe-sized from user-supplied formal specifications using techniques amenable to automation. SEED accepts a formal specification of a problem written in predicate logic and generates annotated program source code sat. isfying the specification. In addition to primitive programming language constructs, SEED is capable of synthesizing recursive and non-recursive procedures and functions, and abstract data types.", "num_citations": "2\n", "authors": ["539"]}
{"title": "A semantically oriented program synthesis system\n", "abstract": " An overview is given of SEED, an automatic program development system that transforms specifications into code using program development methodologies. It is shown that top-down, stepwise program development techniques, originally intended for use by humans, are amenable to automation. When using the Dijkstra/Gries methodology, users refine the predicate logic-based specification of a problem, according to set of heuristics, into code. A major portion of the SEED project involved clarifying their heuristics, intended for human application, to facilitate the development of an executable rule based system. N. Dershowitz's fact introduction scheme (Artif. Intell., vol.25, 323-73, 1985) was used to allow the user to tailor SEED to a particular problem domain by adding to a fact base that is consulted during the rule application process. SEED accepts a specification as input and returns either a program or an error\u00a0\u2026", "num_citations": "2\n", "authors": ["539"]}
{"title": "X-Plore: Combining Model-Driven Engineering, Bio-Inspiration and Formal Analysis To Mitigate Uncertainty in High Assurance Software Systems\n", "abstract": " Increasingly, cyber-physical systems are expected to deliver acceptable and trusted behavior despite highly dynamic and uncertain operating conditions. The X-PLORE project investigated the integration of evolutionary search algorithms with formal analysis methods in order to enhance system robustness and resiliency, while identifying corner cases that might lead to system failure under certain conditions. Evolutionary search algorithms operate in an open-ended manner, unconstrained by human bias and preconceptions. Combining this capability with formal analysis enables discovery of unintuitive solutions to design problems as well as situations that might cause the system to behave in an unintended manner after deployment. This report describes the main capabilities developed in the project along with the results of studies in applying those methods to autonomous vehicles of different scales. A list of publications and presentations resulting from this research is also provided.Descriptors:", "num_citations": "1\n", "authors": ["539"]}
{"title": "A multidisciplinary approach to developing community-based research infrastructure\n", "abstract": " Increasingly, computing-based technology appears to transcend major aspects of our daily lives, from providing conveniences (e.g., in-vehicle navigation services) to life-critical services (e.g., medical diagnostics and treatment). As computing infrastructure moves from supporting specialized computing needs and users, such as an electrical engineer designing a specific electronic circuit versus a policy analyst determining how to prepare costing and resource management models for a smart grid system, the range of supporting expertise broadens and cross-cuts multiple disciplines. This talk will overview personal experiences for three community-based research infrastructure development efforts that span almost three decades of activities, each involving hundreds of participants, multiple organizations and stakeholder communities, and multidisciplinary collaborations. We highlight common qualities that motivated\u00a0\u2026", "num_citations": "1\n", "authors": ["539"]}
{"title": "Reflections on Marvin Minsky\u2019s Definition of \u201cModel\u201d\n", "abstract": " \u201cTo an observer B, an object A* is a model of an object A to the extent that B can use A* to answer questions that interest him about A.\u201d This definition includes concrete, tangible models as well as conceptual models that are described in (usually formal) languages.", "num_citations": "1\n", "authors": ["539"]}
{"title": "An Evolutionary Approach to Network Self-Organization and Resilient Data Diffusion\n", "abstract": " Data diffusion techniques enable a distributed system to replicate and propagate data across a potentially unreliable network in order to provide better data protection and availability. This paper presents a novel evolutionary computation approach to developing network construction algorithms and data diffusion strategies. The proposed approach combines a linear genetic program with a cellular automaton to evolve digital organisms (agents) capable of self-organizing into different types of networks and self-adapting to changes in their surrounding environment, such as link failures and node churn. We assess the effectiveness of the proposed approach by conducting several experiments that explore different network structures under different environmental conditions. The results suggest the combined methods are able to produce self-organizing and self-adaptive agents that construct networks and efficiently\u00a0\u2026", "num_citations": "1\n", "authors": ["539"]}
{"title": "Diagnosis on Pathogenetic Nematode caused Lotus Spot Disease discovered from Guangzhou\n", "abstract": " The paper reported Lotus Spot Disease discovered from Wanqingsha lotus production base in Panyu District of Guangzhou City. Hirschmanniella diversa was diagnosised as pathogens. The Morphologic character, morphometrics and methods used to inspect nematode were given. Disease symptom and Morphology on the closed species were discussed, morphologic character and morphometrics of the samples from different locality were compared.", "num_citations": "1\n", "authors": ["539"]}
{"title": "Meridian: Automating the development of interactive distributed applications\n", "abstract": " Interactive distributed applications (IDAs) are those that involve direct interaction with users and whose processing and data components are distributed across a network. Examples of IDAs include distributed data management systems, on-board driver/pilot navigation assistance systems, computer-supported cooperative work environments, distance education tools, and a variety of public safety systems. The increasing interest in IDAs is fueled by several factors, including the advent of the World Wide Web, the development of new middleware technologies, the introduction of scripting languages for graphical user interfaces, and the availability of new network services and protocols. In order to decrease the time required to develop and maintain these systems, while improving their quality, it is necessary to automate relevant software engineering tasks. The objective of the \u00c5 \u00d6 \u00d2 project is to support end-to-end\u00a0\u2026", "num_citations": "1\n", "authors": ["539"]}
{"title": "Multiple dimensions of integrating development technology\n", "abstract": " Studies have shown that errors are most likely to be introduced in the requirements phase of a development effort. This problem is largely due to prose descriptions that are ambiguous or inconsistent. One potential solution to this problem is to capture requirements information in the form of formal specifications that can be checked for consistency and completeness using automated techniques. However; during the initial phases of a project, it may be difficult to construct formal specifications directly. In contrast, many developers find it more intuitive to create diagram to model their systems. As a means to bridge the gap between formal and informal approaches to software development, we have investigated the formalization of a commonly used object-oriented modeling notation, Object Modeling Technique (OMT). The formalization of OMT enables the automated generation of formal specifications of the diagrams\u00a0\u2026", "num_citations": "1\n", "authors": ["539"]}
{"title": "Correspondence: Response to botting's comments\n", "abstract": " Richard J. Botting indicates some things that need clarifying in the paper cited in the title [l] above.", "num_citations": "1\n", "authors": ["539"]}
{"title": "A Requirements Analysis Report for a Regional Decision Support System EPA Cooperative Agreement: Task 4.6\n", "abstract": " Subtask 4.6 of the EPA Cooperative Agreement involves the design and prototype of an integrated framework of tools that will provide the decision support services as part of the Great Lakes Regional Environmental Information System (Task 4). This decision support system will provide interactive data analysis and visualization services, spatial data display and analysis, distributed data access, statistical analysis and display capabilities, and access to interactive models. This document describes the requirements of the prototype, and includes the results of a user needs analysis.", "num_citations": "1\n", "authors": ["539"]}
{"title": "An integrated approach to developing diagrams as formal specifications\n", "abstract": " Attempting to construct a formal description of a system's requirements directly from a requirements document can be a formidable task. Formal descriptions often involve extensive syntactic details whose meanings are determined by subtle semantics. As a consequence, it is important to develop modular descriptions as a strategy for managing the complexity and maximizing the reusability of the speci cations. In order to obtain modular specications, careful planning and organization are required on the part of the speci er. This paper describes an integrated, tool-based approach to the development of modular formal speci cations. A suite of graphical notations based on an object-oriented modeling strategy known as the Object Modeling Technique (OMT) is used as a framework for modular speci cation development. OMT, like many popular modeling and development methods, uses diagrams to visually present\u00a0\u2026", "num_citations": "1\n", "authors": ["539"]}
{"title": "Applying Formal Methods and Object-Oriented Analysis to Existing Space Shuttle Software\n", "abstract": " This paper describes the application of formal methods and object-oriented modeling to reverse engineering, in which formal specifications are developed for existing, or legacy, code. In this project, several layers of formal specifications were constructed for a portion of the NASA Space Shuttle Digital Auto Pilot (DAP), a software module that is used to control the position of the spacecraft through appropriate jet firings.", "num_citations": "1\n", "authors": ["539"]}
{"title": "Applying formal methods and object-oriented design to existing flight software\n", "abstract": " This paper describes a project appling formal methods to a portion of the shuttle on-orbit digital autopilot (DAP).  Three objectives of the project were to: demonstrate the use of formal methods on a shuttle application, facilitate the incorporation and validation of new requirements for the system, and verify the safety-critical properties to be exhibited by the software.", "num_citations": "1\n", "authors": ["539"]}
{"title": "e IEEE TRANSACTIONS ON\n", "abstract": " The Computer Soclety is an association of people with professional interest in the field of computers. AU members of the IEEE are eligible for membership in the Society and will receive this TRANSACTIONS upon payment of the annual Society membership fee of $28. W plus an annual subscription fee of $30.00. Members of certain professional societies and other computer professionals are also eligible to be members of the Computer Society. For information on joining. write to IEEE Computer Society, 1730 Massachussetts Avenue NW, Washington. DC 20036-1903. Member copies of Trunsuctions ure forpersono1 use only.", "num_citations": "1\n", "authors": ["539"]}