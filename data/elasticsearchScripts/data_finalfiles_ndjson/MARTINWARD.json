{"title": "Language-oriented programming\n", "abstract": " In this chapter, you will begin by taking a look at what I mean by language-oriented programming, a term that has been used by many people to mean different things. I\u2019ll also briefly discuss its advantages and disadvantages. Next, you\u2019ll look at several different approaches to language-oriented programming in F#. These techniques include using F# literals to create little languages and using F# quotations. You\u2019ll spend the bulk of this chapter looking at examples where you create a language, then create an interpreter to execute that language. Finally, you\u2019ll take a more detailed look at how languages are executed, including a performance comparison of interpreted or compiled execution techniques.", "num_citations": "297\n", "authors": ["130"]}
{"title": "The Maintainer's Assistant (software tool)\n", "abstract": " The Maintainer's Assistant is a code analysis tool aimed at helping the maintenance programmer to understand and modify a given program. Program transformation techniques are employed by the Maintainer's Assistant, both to derive a specification from a section of code and to transform a section of code into a logically equivalent form. The general structure of the tool is described and two examples of the application of program transformations are given.< >", "num_citations": "131\n", "authors": ["130"]}
{"title": "Proving program refinements and transformations\n", "abstract": " In this thesis we develop a theory of program refinement and equivalence which can be used to develop practical tools for program development, analysis and modification. The theory is based on the use of general specifications and an imperative kernel language. We use weakest preconditions, expressed as formulae in infinitary logic to prove refinement and equivalence between programs.The kernel language is extended by means of \u201cdefinitional transformations\u201d which define new concepts in terms of those already present. The extensions include practical programming constructs, including recursive procedures, local variables, functions and expressions with sideeffects. This expands the language into a \u201cWide Spectrum Language\u201d which covers the whole range of operations from general specifications to assignments, jumps and labels. We develop theorems for proving the termination of recursive and iterative programs, transforming specifications into recursive programs and transforming recursive procedures into iterative equivalents. We develop a rigorous framework for reasoning about programs with exit statements that terminate nested loops from within; and this forms the basis for many efficiency-improving and restructuring transformations. These are used as a tool for program analysis and to derive algorithms by transforming their specifications. We show that the methods of top-down design and program verification using assertions can be viewed as the application of a small subset of transformations.", "num_citations": "125\n", "authors": ["130"]}
{"title": "Assembler to C migration using the FermaT transformation system\n", "abstract": " The FermaT transformation system, based on research carried out over the last twelve years (1987-99) at Durham University and Software Migrations Ltd., is an industrial-strength formal transformation engine with many applications in program comprehension and language migration. The paper describes one application of the system: the migration of IBM 370 Assembler code to equivalent, maintainable C code. We present an example of using the tool to migrate a small, but complex, assembler module to C with no manual intervention required. We briefly discuss a mass migration exercise where 1925 assembler modules were successfully migrated to C code.", "num_citations": "89\n", "authors": ["130"]}
{"title": "Abstracting a specification from code\n", "abstract": " Much of the work on developing program transformation systems has concentrated on systems to assist in program development. However, the four separate surveys carried out between 1977 and 1990 (Foster and Kiekuth, 1990; Lientz and Swanson, 1980; Morton, 1988; Nosek and Palvia, 1990), summarized in Foster (1991), show that between 40% and 60% of all commercial software effort is devoted to software maintenance rather than the development of new systems. In this paper we describe a joint project between the University of Durham and CSM Ltd to develop a method and tool for reverse\u2010engineering and software maintenance based on program transformation theory. We present an example which illustrates how such a tool can extract a high\u2010level abstract specification from the low\u2010level source code of a program by a process of formal program transformation based on a theory of program\u00a0\u2026", "num_citations": "77\n", "authors": ["130"]}
{"title": "Formal methods for legacy systems\n", "abstract": " A method is described for obtaining useful information from legacy code. The approach uses formal proven program transformations, which preserve or refine the semantics of a construct while changing its form. The applicability of a transformation in a particular syntactic context is checked before application. By using an appropriate sequence of transformations, the extracted representation is guaranteed to be equivalent to the code. In this paper, we focus on the results of using this approach in the reverse\u2010engineering of medium\u2010scale, industrial software, written mostly in languages such as assembler and JOVIAL. Results from both benchmark algorithms and heavily modified, geriatric software are summarized. It is concluded that the approach is viable, for self\u2010contained code, and that useful design information may be extracted from legacy systems at economic cost. We conclude that formal methods have an\u00a0\u2026", "num_citations": "59\n", "authors": ["130"]}
{"title": "Reverse Engineering through Formal Transformation: Knuth's \u2018Polynomial Addition\u2019Algorithm\n", "abstract": " In this paper we will take a detailed look at a larger example of program analysis by transformation. We will be considering Algorithm 2.3.3.A from Knuth's \u2018Fundamental Algorithms\u2019 Knuth (1968) (p. 357) which is an algorithm for the addition of polynomials represented using four-directional links. Knuth (1974) describes this as having \u201ca complicated structure with excessively unrestrained goto statements\u201d and goes on to say \u201cI hope someday to see the algorithm cleaned up without loss of its efficiency\u201d. Our aim is to manipulate the program, using semantics-preserving operations, into an equivalent, high-level specification. The transformations are carried out in the WSL language, a \u201cwide spectrum language\u2019 which includes both low-level program operations and high level specifications, and which has been specifically designed to be easy to transform.", "num_citations": "55\n", "authors": ["130"]}
{"title": "A Multipurpose Backtracking Algorithm\n", "abstract": " A backtracking algorithm with element order selection is presented, and its efficiency discussed in relation both to standard examples and to examples concerning relation-preserving maps which the algorithm was derived to solve.", "num_citations": "54\n", "authors": ["130"]}
{"title": "A practical program transformation system for reverse engineering\n", "abstract": " Program transformation systems provide one means of formally deriving a program from its specification. A tool called ReForm is described. It is designed to address the inverse problem to support the extraction of a specification from existing program code, using transformations. This is an important activity during software maintenance. One of the problems of transformation systems is the scarcity of practical tools which can address industrial scale problems, rather than contrived laboratory problems. An analysis of the important software engineering factors that contribute to a successful transformation based tool is provided. Results from using the tool are also presented.< >", "num_citations": "54\n", "authors": ["130"]}
{"title": "Formal methods to aid the evolution of software\n", "abstract": " There is a vast collection of operational software systems which are vitally important to their users, yet are becoming increasingly difficult to maintain, enhance, and keep up to date with rapidly changing requirements. For many of these so-called legacy systems, the option of throwing the system away and rewriting it from scratch is not economically viable. Methods are therefore urgently required which enable these systems to evolve in a controlled manner. The approach described in this paper uses formal proven program transformations, which preserve or refine the semantics of a program while changing its form. These transformations are applied to restructure and simplify the legacy systems and to extract higher-level representations. By using an appropriate sequence of transformations, the extracted representation is guaranteed to be equivalent to the code. The method is based on a formal wide spectrum\u00a0\u2026", "num_citations": "52\n", "authors": ["130"]}
{"title": "Slicing as a program transformation.\n", "abstract": " The aim of this article is to provide a unified mathematical framework for program slicing which places all slicing work for sequential programs on a sound theoretical foundation. The main advantage to a mathematical approach is that it is not tied to a particular representation. In fact the mathematics provides a sound basis for any particular representation. We use the WSL (wide-spectrum language) program transformation theory as our framework. Within this framework we define a new semantic relation, semirefinement, which lies between semantic equivalence and semantic refinement. Combining this semantic relation, a syntactic relation (called reduction), and WSL's remove statement, we can give mathematical definitions for backwards slicing, conditioned slicing, static and dynamic slicing, and semantic slicing as program transformations in the WSL transformation theory. A novel technique of \u201cencoding\u00a0\u2026", "num_citations": "50\n", "authors": ["130"]}
{"title": "Slicing as a program transformation\n", "abstract": " The aim of this article is to provide a unified mathematical framework for program slicing which places all slicing work for sequential programs on a sound theoretical foundation. The main advantage to a mathematical approach is that it is not tied to a particular representation. In fact the mathematics provides a sound basis for any particular representation. We use the WSL (wide-spectrum language) program transformation theory as our framework. Within this framework we define a new semantic relation, semirefinement, which lies between semantic equivalence and semantic refinement. Combining this semantic relation, a syntactic relation (called reduction), and WSL's remove statement, we can give mathematical definitions for backwards slicing, conditioned slicing, static and dynamic slicing, and semantic slicing as program transformations in the WSL transformation theory. A novel technique of \u201cencoding\u00a0\u2026", "num_citations": "50\n", "authors": ["130"]}
{"title": "Pigs from sausages? Reengineering from assembler to C via FermaT transformations\n", "abstract": " Software reengineering has been described as being \u201cabout as easy as reconstructing a pig from a sausage\u201d(Comput. Canada 18 (1992) 35). But the development of program transformation theory, as embodied in the FermaT transformation system, has made this miraculous feat into a practical possibility. This paper describes the theory behind the FermaT system and describes a recent migration project in which over 544,000 lines of assembler \u201csausage\u201d (part of a large embedded system) were transformed into efficient and maintainable structured C code.", "num_citations": "47\n", "authors": ["130"]}
{"title": "Derivation of data intensive algorithms by formal transformation: the Schnorr-Waite graph marking algorithm\n", "abstract": " Considers a particular class of algorithms which present certain difficulties to formal verification. These are algorithms which use a single data structure for two or more purposes, which combine program control information with other data structures or which are developed as a combination of a basic idea with an implementation technique. Our approach is based on applying proven semantics-preserving transformation rules in a wide spectrum language. Starting with a set theoretical specification of \"reachability\", we are able to derive iterative and recursive graph marking algorithms using the \"pointer switching\" idea of Schorr and Waite (1967). There have been several proofs of correctness of the Schorr-Waite algorithm, and a small number of transformational developments of the algorithm. The great advantage of our approach is that we can derive the algorithm from its specification using only general-purpose\u00a0\u2026", "num_citations": "45\n", "authors": ["130"]}
{"title": "Program slicing via FermaT transformations\n", "abstract": " We describe how the concept of program slicing can be formalised in WSL transformation theory. This formalism naturally tends itself to several generalisations including amorphous slicing and conditioned slicing. One novel generalisation is \"semantic slicing\" which combines slicing and abstraction to a specification. Interprocedural semantic slicing has been implemented in the FermaT transformation system (Ward, 1999): an industrial-strength transformation system designed for forward and reverse engineering, re-engineering and program comprehension.", "num_citations": "41\n", "authors": ["130"]}
{"title": "The formal transformation approach to source code analysis and manipulation\n", "abstract": " The article gives a brief introduction to the foundations of WSL transformation theory and describes some applications to program slicing. We introduce some generalisations of traditional slicing, amorphous slicing and conditioned slicing which are possible in the framework of WSL transformations. One generalisation is \"semantic slicing\" which combines slicing and abstraction to a specification.", "num_citations": "36\n", "authors": ["130"]}
{"title": "Transforming a program into a specification\n", "abstract": " There has been much research in recent years on the problems of program and system development but very little work has been done on the problems of maintaining developed programs. This is despite the fact that for many years it has been well-known that maintenance consumes the largest percentage of the programming budget. We apply the techniques of program transformation to a published program which was written in such a way that the structure and effect of the program are very hard to discern. This will reveal the true structure of the program and enable its effect to be summarised as a specification. The method is language-independent and so can be used with a wide variety of programming languages, the same method can be used to derive a program from a specification, transform a program from one language to another, and (as illustrated here), to transform a program into a specification.", "num_citations": "33\n", "authors": ["130"]}
{"title": "Reverse engineering from assembler to formal specifications via program transformations\n", "abstract": " The FermaT transformation system, based on research carried out over the last sixteen years at Durham University, De Montfort University and Software, Migrations Ltd., is an industrial-strength formal transformation engine with many applications in program comprehension and language migration. This paper is a case study which uses automated plus manually-directed transformations and abstractions to convert an IBM 370 assembler code program into a very high-level abstract specification.", "num_citations": "32\n", "authors": ["130"]}
{"title": "The FermaT assembler re-engineering workbench\n", "abstract": " Research into the working practices of software engineers has shown the need for integrated browsing and searching tools which include graphical visualisations linked back to the source code under investigation. In addition, for assembler maintenance and re-engineering there is an even greater need for sophisticated control flow analysis, data flow analysis, slicing and migration technology. All these technologies are provided by the FermaT Workbench: an industrial-strength assembler re-engineering workbench consisting of a number of integrated tools for program comprehension, migration and re-engineering. The various program analysis and migrations tools are based on research carried out over the last sixteen years at Durham University, De Montfort University and Software Migrations Ltd., and make extensive use of program transformation theory.", "num_citations": "30\n", "authors": ["130"]}
{"title": "Program analysis by formal transformation\n", "abstract": " This paper treats Knuth and Szwarcfiter's topological sorting program as a case study for the analysis of a program by formal transformations. This algorithm was selected for the case study because it is a particularly challenging program for any reverse engineering method. Besides a complex control flow, the program uses arrays to represent various linked lists and sets, which are manipulated in various \u2018ingenious\u2019 ways so as to squeeze the last ounce of performance from the algorithm. Our aim is to manipulate the program, using semantics-preserving operations, to produce an abstract specification. The transformations are carried out in the WSL language, a \u2018wide spectrum language\u2019 which includes both low-level program operations and high level specifications, and which has been specifically designed to be easy to transform.", "num_citations": "30\n", "authors": ["130"]}
{"title": "Derivation of a Sorting Algorithm\n", "abstract": " > nioj S. 2 An Example of an Algorithm Derivation In this section we sketch the derivation of a version of Hoare's Quicksort algorithm [3]. This illustrates the use of the join construct in writing concise abstract specications which can be transformed into ecient algorithms. It also illustrates the application of the theorem on recursive implementation of statements (Theorem 2) and the renement rules. 2.1 Notation We use a:: b to represent the sequence of integers from a to b inclusive. If A is an array then A [a:: b] represents the sequence of array elements A [a] to A [b] inclusive. On the left hand side of an assignment it indicates that A takes on a new value with only those elements changed. If m", "num_citations": "28\n", "authors": ["130"]}
{"title": "Foundations for a practical theory of program refinement and transformation\n", "abstract": " A wide spectrum language is presented, which is designed to facilitate the proof of the correctness of refinements and transformations. Two different proof methods are introduced and used to prove some fundamental transformations, including a general induction rule (Lemma 3.9) which enables transformations of recursive and iterative programs to be proved by induction on their finite truncations. A theorem for proving the correctness of recursive implementations is presented (Theorem 3.21), which provides a method for introducing a loop, without requiring the user to provide a loop invariant. A powerful, general purpose, transformation for removing or introducing recursion is described and used in a case study (Section 5) in which we take a small, but highly complex, program and apply formal transformations in order to uncover an abstract specification of the behaviour of the program. The transformation theory supports a transformation system, called FermaT, in which the applicability conditions of each transformation (and hence the correctness of the result) are mechanically verified. These results together considerably simplify the construction of viable program transformation tools; practical consequences are briefly discussed.", "num_citations": "27\n", "authors": ["130"]}
{"title": "MetaWSL and meta-transformations in the FermaT transformation system\n", "abstract": " A program transformation is an operation which can be applied to any program (satisfying the transformations applicability conditions) and returns a semantically equivalent program. In the FermaT transformation system program transformations are carried out in a wide spectrum language, called WSL, and the transformations themselves are written in an extension of WSL called MetaWSL which was specifically designed to be a domain-specific language for writing program transformations. As a result, FermaT is capable of transforming its own source code via meta-transformations. This paper introduces MetaWSL and describes some applications of meta-transformations in the FermaT system.", "num_citations": "26\n", "authors": ["130"]}
{"title": "A recursion removal theorem\n", "abstract": " In this paper we briefly introduce a Wide Spectrum Language and its transformation theory and describe a recent success of the theory: a general recursion removal theorem. Recursion removal often forms an important step in the systematic development of an algorithm from a formal specification. We use semantic-preserving transformations to carry out such developments and the theorem proves the correctness of many different classes of recursion removal. This theorem includes as special cases the two techniques discussed by Knuth [13] and Bird [7]. We describe some applications of the theorem to cascade recursion, binary cascade recursion, Gray codes, and an inverse engineering problem.", "num_citations": "26\n", "authors": ["130"]}
{"title": "A Knowledge-Based System for Software Maintenance\n", "abstract": " An intelligent, knowledge-based maintenance tool is described. The tool is intended to help reduce the amount of time spent on analyzing code. Code analysis is performed when a programmer is familiarizing himself with a piece of code and when the effects of a proposed modification of the code is being assessed. The research project is described, and its theoretical foundation is examined.<>", "num_citations": "23\n", "authors": ["130"]}
{"title": "Legacy assembler reengineering and migration.\n", "abstract": " In this paper we describe the legacy assembler problem and describe how the FermaT transformation system is used to reengineer assembler systems and migrate from assembler to C and COBOL.", "num_citations": "22\n", "authors": ["130"]}
{"title": "A definition of abstraction\n", "abstract": " What does it mean to say that one program is \u2018more abstract\u2019 than another? What is \u2018abstract\u2019 about an abstract data type? What is the difference between a \u2018high\u2010level\u2019 program and a \u2018low\u2010level\u2019 program? In this paper we attempt to answer these questions by formally defining an abstraction relation between programs which matches our intuitive ideas about abstraction. The relation is based on examining the operational semantics of the programs, expressed as a set of traces (sequences of states) from a given initial state to a possible final state.", "num_citations": "21\n", "authors": ["130"]}
{"title": "Recursion removal/introduction by formal transformation: An aid to program development and program comprehension\n", "abstract": " The transformation of a recursive program to an iterative equivalent is a fundamental operation in computer science. In the reverse direction, the task of reverse engineering (analysing a given program in order to determine its specification) can be greatly ameliorated if the program can be re-expressed in a suitable recursive form. However, the existing recursion removal transformations, such as the techniques discussed by Knuth [1] and Bird [2], can only be applied in the reverse direction if the source program happens to match the structure produced by a particular recursion removal operation. In this paper we describe a much more powerful recursion removal and introduction operation which describes its source and target in the form of an action system (a collection of labels and calls to labels). A simple, mechanical restructuring operation can be applied to a great many iterative programs, which will put them in a\u00a0\u2026", "num_citations": "20\n", "authors": ["130"]}
{"title": "Slicing the SCAM mug: A case study in semantic slicing\n", "abstract": " We describe an improved formalisation of slicing in WSL transformation theory and apply the result to a particularly challenging slicing problem: the SCAM mug (Anon, 2001). We present both syntactic and semantic slices of the mug program and give semantic slices for various generalisations of the program. Although there is no algorithm for constructing a minimal syntactic slice, we show that it is possible, in the WSL language, to derive a minimal semantic slice for any program and any slicing criteria.", "num_citations": "19\n", "authors": ["130"]}
{"title": "Inverse\u2010engineering a simple real\u2010time program\n", "abstract": " Reverse\u2010engineering of interrupt\u2010driven, real\u2010time programs with timing constraints is a particularly challenging research area, because the functional behaviour of a program, and the non\u2010functional timing requirements, are implicit and can be very difficult to discover. However, in this paper we present a significant advance in this area, which is achieved by modelling real\u2010time programs with interrupts in the wide spectrum language, WSL. A small example program is modelled in this way, and formal program transformations are used to derive various timing constraints and to \u2018inverse\u2010engineer\u2019 a formal specification of the program. (We use the term \u2018inverse\u2010engineering\u2019 to mean \u2018reverse\u2010engineering achieved by formal program transformations\u2019.)", "num_citations": "19\n", "authors": ["130"]}
{"title": "Conditioned semantic slicing for abstraction; industrial experiment\n", "abstract": " One of the most challenging tasks a programmer can face is attempting to analyse and understand a legacy assembler system. Many features of assembler make analysis difficult, and these are the same features that make migration from assembler to a high\u2010level language difficult. In this paper, we discuss the application of program transformation technology to assist with analysing and understanding legacy assembler systems. We briefly introduce the fundamentals of our program transformation theory and program slicing, which generalizes to conditional semantic slicing. These transformations are applied to a large commercial assembler system to automatically generate high\u2010level abstract descriptions of the behaviour of each assembler module, with error handling code sliced away. The assembler system was then migrated to C. The result is a dramatic improvement in the understandability of the programs\u00a0\u2026", "num_citations": "17\n", "authors": ["130"]}
{"title": "Combining dynamic and static slicing for analysing assembler\n", "abstract": " One of the most challenging tasks a programmer can face is attempting to analyse and understand a legacy assembler system. Many features of assembler make analysis difficult, and these are the same features which make migration from assembler to a high-level language difficult. In this paper we describe some of the methods used in the FermaT transformation system for analysing and migrating assembler systems. One technique we discuss in detail is to combine a simple dynamic slice, computed with virtually no overhead, and a static slice implemented using program transformation technology, to generate very concise high-level descriptions of the sliced code.", "num_citations": "16\n", "authors": ["130"]}
{"title": "Deriving a slicing algorithm via FermaT transformations\n", "abstract": " In this paper, we present a case study in deriving an algorithm from a formal specification via FermaT transformations. The general method (which is presented in a separate paper) is extended to a method for deriving an implementation of a program transformation from a specification of the program transformation. We use program slicing as an example transformation since this is of interest outside the program transformation community. We develop a formal specification for program slicing in the form of a WSL specification statement which is refined into a simple slicing algorithm by applying a sequence of general purpose program transformations and refinements. Finally, we show how the same methods can be used to derive an algorithm for semantic slicing. The main novel contributions of this paper are: 1) developing a formal specification for slicing, 2) expressing the definition of slicing in terms of a WSL\u00a0\u2026", "num_citations": "16\n", "authors": ["130"]}
{"title": "A Recursion Removal Theorem -- Proof and Applications\n", "abstract": " In this paper we briefly introduce a Wide Spectrum Language and its transformation theory and describe a recent success of the theory: a general recursion removal theorem. This theorem includes as special cases the two techniques discussed by Knuth [12] and Bird [8]. We describe some applications of the theorem to cascade recursion, binary cascade recursion, Gray codes, the Towers of Hanoi problem, and an inverse engineering problem.", "num_citations": "15\n", "authors": ["130"]}
{"title": "A Recursion Removal TheoremProof and Applications\n", "abstract": " In this paper we briefly introduce a Wide Spectrum Language and its transformation theory and describe a recent success of the theory: a general recursion removal theorem. This theorem includes as special cases the two techniques discussed by Knuth [12] and Bird [8]. We describe some applications of the theorem to cascade recursion, binary cascade recursion, Gray codes, the Towers of Hanoi problem, and an inverse engineering problem.", "num_citations": "15\n", "authors": ["130"]}
{"title": "Conditioned semantic slicing via abstraction and refinement in fermat\n", "abstract": " In this paper we describe an improved formalisation of slicing in WSL (wide spectrum language) transformation theory and apply the result to give syntactic and semantic slices for some challenging slicing problems. Although there is no algorithm for constructing a minimal syntactic slice, we show that it is possible, in the WSL language, to derive a minimal semantic slice for any program and any slicing criteria. We describe the representation theorem and show how it is (partially) implemented in the FermaT transformation system. The theorem has applications to semantic (or conditioned) slicing, and we use a combination of abstraction (via the representation theorem), simplification and refinement plus other program transformations to develop a powerful conditioned slicing algorithm.", "num_citations": "14\n", "authors": ["130"]}
{"title": "Properties of slicing definitions\n", "abstract": " Weiser's original papers on slicing defined the concept in an informal way. Since then there have been several attempts to formalise slicing using various formal methods and semantics of programs. In this paper we start by defining some properties that a definition of slicing might reasonably be expected to satisfy and then compare different definitions of slicing to see which properties are satisfied. Properties are classified into \"floor\" requirements: all slices satisfying the property must be considered as valid, and \"ceiling\" requirements: slices which do not satisfy the property must not be considered valid. Any slicing relation which lies above a \"floor\" requirement, or below a \"ceiling\" requirement, satisfies the property in question. The main result of the paper is the proof that, given a certain property of the programming language (informally: it is possible to write an infinite loop in the language), two of the most basic and\u00a0\u2026", "num_citations": "12\n", "authors": ["130"]}
{"title": "Formality, Agility, Security, and Evolution in Software Development.\n", "abstract": " Complex systems have always been problematic with respect to software development. Simplicity is desirable, but the reality of dealing with a customer means that requirements are likely to change, resulting in a corresponding loss of elegance in the solution. A good software engineer will design with the knowledge that the system is likely to evolve over time, even if the exact nature of the changes is unknown. Such expertise only comes with experience and an innate aptitude, especially in the understanding and use of abstraction. Software engineering approaches such as object orientation and modularization\u2014for example, the Z notation schema construct\u2014can help minimize change-related problems if used carefully, following standard patterns of use. Formal methods have been advocated for improving the correctness of software systems, 1 and agile software development has been promoted by the Agile Manifesto (http://agilemanifesto. org) and others for enabling adaptive development in the face of changing requirements, typically introducing additional complexity in the process.", "num_citations": "11\n", "authors": ["130"]}
{"title": "Specifications from source code-alchemists' dream or practical reality?\n", "abstract": " The author describes the application of formal program transformations to uncover specifications from source code. He takes as an example a small report writing program. Due to errors in the original design, this program had several bugs which were gradually uncovered and fixed in the usual way. The resulting program appears to work, but has a complex and messy structure which makes it extremely difficult to maintain. The aim of the case study is to restructure the program and extract its specification (a concise, high-level description of what the program does which ignores the low-level details of how this result is achieved). It should be noted that his aim is emphatically not that of design recovery in the sense of recovering the original design. Instead he aims to transform the base metal of unstructured code into the gold of a high-level specification. The approach is based on a Wide Spectrum Language (called\u00a0\u2026", "num_citations": "11\n", "authors": ["130"]}
{"title": "Assembler restructuring in FermaT\n", "abstract": " The FermaT transformation system has proved to be a very successful tool for migrating from assembler to high level languages, including C and COBOL. One of the more challenging aspects facing automated migration, specifically when the aim is to produce maintainable code from unstructured \u201cspaghetti\u201d code, is to restructure assembler subroutines into semantically equivalent high level language procedures. In this paper we describe some of the many varieties of assembler subroutine structures and the techniques used by the migration engine to transform these into structured code. These transformations require a deep analysis of both control flow and data flow in order to guarantee the correctness of the result. Two separate case studies, involving over 10,000 assembler modules from commercial systems, demonstrate that these techniques are able to restructure over 99% of hand-written assembler, with no\u00a0\u2026", "num_citations": "8\n", "authors": ["130"]}
{"title": "Using formal transformations to construct a component repository\n", "abstract": " Production of software is costly and error prone and the most important means of production (good programmers) are scarce. Therefore, there exists a need to circumvent this costly manual production process. Analogies from classical engineering suggest that by building up a catalogue of standard components and construction techniques whose characteristics are well documented, can greatly reduce the cost of new construction projects. The bridge builder knows under what conditions a \u201csuspension bridge\u201d is the right approach and has a collection of standard girders, cables, nuts, bolts etc. which she can use in the design. This has lead to the notion of a component repository which will reduce the effort involved in constructing new software.", "num_citations": "8\n", "authors": ["130"]}
{"title": "The Use of Transformations in\" The Maintainer's Assistant\"\n", "abstract": " The Maintainer's Assistant is a code analysis tool aimed at helping the maintenance programmer to understand and modify a given program. Program transformation techniques are employed by the Maintainer's Assistant both to derive a specification from a section of code and to transform a section of code into a logically equivalent form. The general structure of the tool is described and two examples of the application of program transformations are given.", "num_citations": "8\n", "authors": ["130"]}
{"title": "Provably correct derivation of algorithms using FermaT\n", "abstract": " The transformational programming method of algorithm derivation starts with a formal specification of the result to be achieved, plus some informal ideas as to what techniques will be used in the implementation. The formal specification is then transformed into an implementation, by means of correctness-preserving refinement and transformation steps, guided by the informal ideas. The transformation process will typically include the following stages: (1) Formal specification (2) Elaboration of the specification, (3) Divide and conquer to handle the general case (4) Recursion introduction, (5) Recursion removal, if an iterative solution is desired, (6) Optimisation, if required. At any stage in the process, sub-specifications can be extracted and transformed separately. The main difference between this approach and the invariant based programming approach (and similar stepwise refinement methods) is that loops\u00a0\u2026", "num_citations": "7\n", "authors": ["130"]}
{"title": "Theory and practice of middle-out programming to support program understanding\n", "abstract": " Theories of top-down and bottom-up program comprehension have existed for several years, but it has been recognised that understanding rarely happens in practice in such a well-ordered way. The paper describes recent work and results at Durham on what is termed middle-out programming. The objective is to avoid the problems of top-down and bottom-up approaches, by designing a very high level language specific to the application domain. Domain knowledge is captured in the design of this language, which retains a strong formal basis. This paper takes the view that software engineering will become strongly application domain based, and that knowledge representation of the domain will be a crucial factor in supporting program comprehension. An example of using this approach in the design of a large software system is presented.< >", "num_citations": "7\n", "authors": ["130"]}
{"title": "Using formal transformations for the reverse engineering of real-time safety critical systems\n", "abstract": " A practical tool is described which enables the user to extract high level specifications from existing source codes, using semantic preserving formal transformations. A brief overview of the theoretical foundation is given. Extensions are then described to support the acquisition of explicit timing information from real-time source codes.           Indications are then given of how the approach may be used to study safety critical properties of existing real time systems used in the process control industry.", "num_citations": "6\n", "authors": ["130"]}
{"title": "Iterative Procedures for Computing Ackerman's Function\n", "abstract": " This paper uses Ackerman's function as a testbed to illustrate the operation of various program transformations which take recursive procedures to equivalent iterative forms. The transformations are taken from the author's DPhil thesis [19]. In this paper we illustrate that they can be successfully applied to even the most convoluted recursion. For many programs a recursive function is the most natural and clear specification while an iterative (or tail-recursive) form is the most efficient implementation. This paper illustrates how an efficient iterative program can be developed and verified by starting with a simple recursive program and using proven transformations to remove the recursion. The resulting iterative program will be correct by construction, so the problem of a direct verification of the iterative algorithm is avoided. This process can also throw light on the nature of the recursive specification. Several interesting properties of Ackermann's function and the iterative algorithms are derived in the course of this development.", "num_citations": "6\n", "authors": ["130"]}
{"title": "Understanding concurrent programs using program transformations\n", "abstract": " Reverse engineering of concurrent real-time programs with timing constraints is a particularly challenging research area, because the functional behaviour of a program, and the non-functional timing requirements, are implicit and can be very difficult to discover. The authors present a significant advance in this area, which is achieved by modelling real-time concurrent programs in the wide spectrum language WSL. They show how a sequential program with interrupts can be modelled in WSL, and the method is then extended to model more general concurrent programs. They show how a program modelled in this way may subsequently be 'inverse engineered' by the use of formal program transformations, to discover a specification for the program.< >", "num_citations": "6\n", "authors": ["130"]}
{"title": "Formality, agility, security, and evolution in software engineering\n", "abstract": " \u201cA complex system that works is invariably found to have evolved from a simple system that worked. The inverse proposition also appears to be true: A complex system designed from scratch never works and cannot be made to work. You have to start over, beginning with a working simple system.\u201d", "num_citations": "4\n", "authors": ["130"]}
{"title": "The formal semantics of program slicing for nonterminating computations\n", "abstract": " Since the original development of program slicing in 1979 there have been many attempts to define a suitable semantics, which will precisely define the meaning of a slice. Particular issues include handling termination and nontermination, slicing nonterminating programs, and slicing nondeterministic programs. In this paper we review and critique the main attempts to construct a semantics for slicing and present a new operational semantics, which correctly handles slicing for nonterminating and nondeterministic programs. We also present a modified denotational semantics, which we prove to be equivalent to the operational semantics. This provides programmers with 2 different methods to prove the correctness of a slice or a slicing algorithm and means that the program transformation theory and FermaT transformation system, developed last 25\u00a0years of research, and which has proved so successful in analyzing\u00a0\u2026", "num_citations": "4\n", "authors": ["130"]}
{"title": "Towards a multilingual semantic folksonomy\n", "abstract": " The content of collaborative tagging systems (so-called folksonomies) is generated, consumed, and annotated by the end users. Users annotate and categorise their data using free-keywords, so-called tags. Consequently, several linguistic problems come to the surface in folksonomies such as; synonyms, polysemy, multilinguality, and others which produce ambiguous and inconsistent classification of data. Therefore, relevant results are not retrieved in the user\u2019s query. In this paper, we suggest a novel approach to enhance the \u201csocial vocabulary\u201d presented in folksonomies with the \u201ccontrolled vocabulary\u201d presented in Semantic Web ontologies. Therefore, our proposed approach uses the online WordNet lexical ontology in addition to the EuroWordNet multilingual lexical resource. Our approach tries to employ the ontological relations presented in WordNet in the folksonomy, it focuses on the problems of synonyms, tag relations, and multilinguality.", "num_citations": "4\n", "authors": ["130"]}
{"title": "A Practical Solution to Reverse Engineering Legacy Systems using Formal Methods\n", "abstract": " A method is described for obtaining useful information from legacy code. The approach uses formal proven program transformations, which preserve or re ne the semantics of a construct while changing its form. The applicability of a transformation in a particular syntactic context is checked before application. By using an appropriate sequence of transformations, the extracted representation is guaranteed to be equivalent to the code. In this paper, we focus on the results of using this approach in the reverse engineering of medium scale, industrial software, written mostly in languages such as assembler and JOVIAL. Results from both benchmark algorithms and heavily modi ed, geriatric software are summarised. It is concluded that the approach is viable, for self contained code, and that useful design information may be extracted from legacy systems at economic cost. We conclude that formal methods have an\u00a0\u2026", "num_citations": "4\n", "authors": ["130"]}
{"title": "Transformational Programming and the Derivation of Algorithms\n", "abstract": " The transformational programming, method of algorithm derivation starts with a formal specification of the result to be achieved (which provides no indication of how the result is to be achieved), plus some informal ideas as to what techniques will be used in the implementation. The formal specification is then transformed into an implementation, by means of correctness-preserving refinement and transformation steps. The informal ideas are used to guide the selection of transformations to apply: since they only guide the selection of valid transformations, the ideas do not themselves have to be formalised.", "num_citations": "3\n", "authors": ["130"]}
{"title": "Using software metrics to evaluate static single assignment form in GCC\n", "abstract": " Over the past 20 years, static single assignment form (SSA) has risen to become the compiler intermediate representation of choice. Compiler developers cite many qualitative reasons for choosing SSA. However in this study, we present clear quantitative benefits of SSA, by applying several standard software metrics to compiler intermediate code in both SSA and non-SSA forms. The average complexity reduction achieved by using SSA in the GCC compiler is between 32% and 60% according to our software metrics, over a set of standard SPEC benchmarks.", "num_citations": "3\n", "authors": ["130"]}
{"title": "(Re) escribiendo la heteronormalidad en tiempos de Pinochet: Una lectura queer de Tengo Miedo Torero de Pedro Lemebel\n", "abstract": " EL Primer Ministro de la India, Jawaharial Nehru, noto\u0301 en 1946 la posicio\u0301n precaria de la Historia y se refirio\u0301 a la idea de que la historia oficial la escriben los vencedores. En su libro sobre la India dice que \u201chistory is almost always written by the victors and conquerors and gives their view\u201d(289). Su idea de lo que significa la historia oficial implica que existen muchos factores, muchas personas y muchas otra historias que no forman parte de esa \u201chistoria\u201d. El historiador Walter Benjamin dice que \u201conce one asks the question, with whom does the historical writer of historicism actually empathize. The answer is irrefutably with the victor\u201d(8), que confirma la nocio\u0301n de Nehru, la historia es subjetiva y hay muchas personas que no existen en la historia oficial. El artista y escritor chileno Pedro Lemebel intenta arrojar luz sobre las historias de las personas que forman parte de la historia oculta. Se enfoca en las personas que ocupan un espacio marginal en el lapso de las u\u0301ltimas de\u0301cadas y las primeras de los siglos XX y XXI de Chile. En sus obras literarias se enfoca en: homosexuales, travestis y otras figuras que se considera gente queer. Las cro\u0301nicas de la coleccio\u0301n La esquina es mi corazo\u0301n (2001) cuentan las dificultades de ser pobre, homosexual y tener que vivir prostituye\u0301ndose en las calles. En otra coleccio\u0301n, Loco afa\u0301n (1996), el autor enfrenta la crisis personal y pu\u0301blica que provoca el SIDA en la sociedad chilena en los an\u0303os ochenta, mientras el gobierno negaba la existencia de tal problema. El mismo Lemebel, en una entrevista del an\u0303o 2004, describe la influencia del pasado sobre su propia escritura que tiene \u201cese cara\u0301cter de letras\u00a0\u2026", "num_citations": "1\n", "authors": ["130"]}
{"title": "The FermaT maintenance environment tool demonstration\n", "abstract": " The FermaT Maintenance Environment (FME) is a platform independent graphical user interface for the FermaT program transformation system. It is able to represent WSL code and apply FermaT transformations on single statements.", "num_citations": "1\n", "authors": ["130"]}
{"title": "Derivation of data intensive algorithms by formal transformation: the Schorr-Waite graph marking algorithm\n", "abstract": " In this paper we consider a particular class of algorithms which present certain difficulties to formal verification. These are algorithms which use a single data structure for two or more purposes, which combine program control information with other data structures or which are developed as a combination of a basic idea with an implementation technique. Our approach is based on applying proven semantics-preserving transformation rules in a wide spectrum language. Starting with a set theoretical specification of \u201creachability\u201d we are able to derive iterative and recursive graph marking algorithms using the \u201cpointer switching\u201d idea of Schorr and Waite. There have been several proofs of correctness of the Schorr-Waite algorithm, and a small number of transformational developments of the algorithm. The great advantage of our approach is that we can derive the algorithm from its specification using only general-purpose transformational rules: without the need for complicated induction arguments. Our approach applies equally well to several more complex algorithms which make use of the pointer switching strategy, including a hybrid algorithm which uses a fixed length stack, switching to the pointer switching strategy when the stack runs out.", "num_citations": "1\n", "authors": ["130"]}
{"title": "The Largest true Square Problem\n", "abstract": " In this paper we give a brief introduction to the model for the semantics of programs in [25] and [26]. We show how the use of weakest preconditions with this model provides a proof rule for program transformations. This proof rule has been used by the author to develop a large catalogue of proven transformations which forms the basis of a method of transformational programming in which algorithms are derived from high-level specifications by means of a sequence of proven transformations. The transformations have also been used as the basis for a software maintenance tool, the \u201cMaintainer\u2019s Assistant\u201d[28] which uses transformations to analyse the code being maintained. As a small example of a rigorous algorithm derivation we take the \u201cLargest true Square\u201d problem sketched in [25]. Starting with a set-theoretical specification of the problem we derive an efficient linear algorithm by applying a sequence of proven transformations (and a little serendipity!)", "num_citations": "1\n", "authors": ["130"]}
{"title": "Parallelizing the construction of static single assignment form\n", "abstract": " Data flow analysis and code optimization are generally implemented using sequential algorithms. Given the commoditization of multi-core platforms, it should be possible to use parallel algorithms instead. This paper examines how the standard sequential algorithm for constructing static single assignment form (SSA) may be parallelized. We demonstrate how this parallel algorithm may be realized in an existing compiler infrastructure, using light-weight threading mechanisms for Java. We provide a quantitative evaluation of our parallel SSA construction pass. The maximum speedups are around 4x when applied to real-world Java programs on a quad-core hyperthreaded Intel Core i7.", "num_citations": "1\n", "authors": ["130"]}