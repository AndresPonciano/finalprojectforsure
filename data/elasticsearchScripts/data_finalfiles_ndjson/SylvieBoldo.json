{"title": "Formal verification of floating-point programs\n", "abstract": " This paper introduces a methodology to perform formal verification of floating-point C programs. It extends an existing tool for the verification of C programs, Caduceus, with new annotations specific to floating-point arithmetic. The Caduceus first-order logic model for C programs is extended accordingly. Then verification conditions expressing the correctness of the programs are obtained in the usual way and can be discharged interactively with the Coq proof assistant, using an existing Coq formalization of floatingpoint arithmetic. This methodology is already implemented and has been successfully applied to several short floatingpoint programs, which are presented in this paper.", "num_citations": "122\n", "authors": ["1765"]}
{"title": "Preuves formelles en arithm\u00e9tiques \u00e0 virgule flottante\n", "abstract": " Cette th\u00e8se est repr\u00e9sentative de mon exp\u00e9rience de rapprochement de l'arithm\u00e9tique \u00e0 virgule flottante, r\u00e9gie par la norme IEEE-754, et de la preuve formelle, ici l'assistant de preuves Coq. La formalisation des nombres flottants utilis\u00e9e a \u00e9t\u00e9 premi\u00e8rement d\u00e9velopp\u00e9e par L. Th\u00e9ry. J'ai tout d'abord test\u00e9 et enrichi la biblioth\u00e8que avec des propri\u00e9t\u00e9s simples \u00e0 exprimer dans le formalisme choisi: le fait qu'une valeur r\u00e9elle soit exactement repr\u00e9sentable par un nombre flottant. J'ai ensuite fait diff\u00e9rentes extensions du mod\u00e8le: rapprochement avec la r\u00e9alit\u00e9 mat\u00e9rielle des processeurs, g\u00e9n\u00e9ralisation \u00e0 la repr\u00e9sentation en compl\u00e9ment \u00e0 2 et \u00e9tude d'un arrondi plus faible. En utilisant les r\u00e9sultats pr\u00e9c\u00e9dents, j'ai \u00e9tudi\u00e9 deux applications r\u00e9elles. La premi\u00e8re est une biblioth\u00e8que de calcul multi-pr\u00e9cision bas\u00e9e sur les expansions. La seconde est l'\u00e9valuation de fonctions \u00e9l\u00e9mentaires (exponentielle, cosinus...): j'ai r\u00e9solu la plupart des probl\u00e8mes de la r\u00e9duction d'argument en garantissant formellement les conditions et algorithmes associ\u00e9s et j'ai \u00e9tudi\u00e9 l'\u00e9valuation polynomiale par l'algorithme de Horner. J'ai montr\u00e9 la faisabilit\u00e9 de preuves formelles dans le domaine complexe de l'arithm\u00e9tique des ordinateurs. J'ai d\u00e9termin\u00e9 les points forts et les limites de cette d\u00e9marche en obtenant un recul suffisant face \u00e0 cette formalisation par diff\u00e9rents moyens: enrichissement de la biblioth\u00e8que, extensions du mod\u00e8le et validation de vraies applications.", "num_citations": "57\n", "authors": ["1765"]}
{"title": "Representable correcting terms for possibly underflowing floating point operations\n", "abstract": " Studying floating point arithmetic, authors have shown that the implemented operations (addition, subtraction, multiplication, division and square root) can compute a result and an exact correcting term using the same format as the inputs. Following a path initiated in 1965, many authors supposed that neither underflow nor overflow occurred in the process. Overflow is not critical as this kind of exception creates persisting nonnumeric quantities. Underflow may be fatal to the process as it returns wrong numeric values with little warning. Our new conditions guarantee that the correcting term is exact when the result is a number. We have validated our proofs against Coq automatic proof checker. Our development has raised many questions, some of them were expected while other ones were surprising.", "num_citations": "44\n", "authors": ["1765"]}
{"title": "Hardware-independent proofs of numerical programs\n", "abstract": " On recent architectures, a numerical program may give different answers depending on the execution hardware and the compilation. Our goal is to formally prove properties about numerical programs that are true for multiple architectures and compilers. We propose an approach that states the rounding error of each floating-point computation whatever the environment. This approach is implemented in the Frama-C platform for static analysis of C code. Small case studies using this approach are entirely and automatically proved.", "num_citations": "38\n", "authors": ["1765"]}
{"title": "Theorems on efficient argument reductions\n", "abstract": " A commonly used argument reduction technique in elementary function computations begins with two positive floating point numbers /spl alpha/ and /spl gamma/ that approximate (usually irrational but not necessarily) numbers 1/C and C, e.g., C = 2/spl pi/ for trigonometric functions and ln 2 for e/sup x/. Given an argument to the function of interest it extracts z as defined by x/spl alpha/ = z + /spl sigmav/ with z = k2/sup -N/ and |sigmav;| /spl les/ 2/sup -N-1/, where k, N are integers and N /spl ges/ 0 is preselected, and then computes u = x - z/spl gamma/. Usually z/spl gamma/ takes more bits than the working precision provides for storing its significant and thus exact x - z/spl gamma/ may not be represented exactly by a floating point number of the same precision. This will cause performance penalty when the working precision is the highest available on the underlying hardware and thus considerable extra work is\u00a0\u2026", "num_citations": "38\n", "authors": ["1765"]}
{"title": "A simple test qualifying the accuracy of Horner's rule for polynomials\n", "abstract": " Polynomials are used in many applications and hidden in libraries such as libm. Whereas the accuracy of functions used by linear algebra have long been studied, little is available to decide on one scheme to evaluate polynomials. Common knowledge solely emphasizes that Horner's rule is a good scheme unless the indeterminate is close to one of the polynomial's roots. We propose here criteria for one step of Horner's scheme to be faithful. A result is defined to be faithful when it was correctly rounded whereas the rounding mode (up, down or to the nearest) cannot be known by users. Our criteria are validated with the IEEE standard for floating point arithmetic using Coq automatic proof checker. We also present three programs in Maple, Java and C that check criteria for a polynomial associated with a domain for the indeterminate and a possible truncation error. Examples are given with approximations to\u00a0\u2026", "num_citations": "35\n", "authors": ["1765"]}
{"title": "Formal verification of numerical programs: from C annotated programs to mechanical proofs\n", "abstract": " Numerical programs may require a high level of guarantee. This can be achieved by applying formal methods, such as machine-checked proofs. But these tools handle mathematical theorems while we are interested in C code, in which numerical computations are performed using floating-point arithmetic, whereas proof tools typically handle exact real arithmetic. To achieve this high level of confidence on C programs, we use a chain of tools: Frama-C, its Jessie plugin, Why and provers among Coq, Gappa, Alt-Ergo, CVC3 and Z3. This approach requires the C program to be annotated: each function must be precisely specified, and we prove the correctness of the program by proving both that it meets its specifications and that no runtime error may occur. The purpose of this paper is to illustrate, on various examples, the features of this approach.", "num_citations": "33\n", "authors": ["1765"]}
{"title": "Formal proof for delayed finite field arithmetic using floating point operators\n", "abstract": " Formal proof checkers such as Coq are capable of validating proofs of correction of algorithms for finite field arithmetics but they require extensive training from potential users. The delayed solution of a triangular system over a finite field mixes operations on integers and operations on floating point numbers. We focus in this report on verifying proof obligations that state that no round off error occurred on any of the floating point operations. We use a tool named Gappa that can be learned in a matter of minutes to generate proofs related to floating point arithmetic and hide technicalities of formal proof checkers. We found that three facilities are missing from existing tools. The first one is the ability to use in Gappa new lemmas that cannot be easily expressed as rewriting rules. We coined the second one ``variable interchange'' as it would be required to validate loop interchanges. The third facility handles massive loop unrolling and argument instantiation by generating traces of execution for a large number of cases. We hope that these facilities may sometime in the future be integrated into mainstream code validation.", "num_citations": "32\n", "authors": ["1765"]}