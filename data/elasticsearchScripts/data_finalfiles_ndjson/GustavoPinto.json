{"title": "Mining questions about software energy consumption\n", "abstract": " A growing number of software solutions have been proposed to address application-level energy consumption problems in the last few years. However, little is known about how much software developers are concerned about energy consumption, what aspects of energy consumption they consider important, and what solutions they have in mind for improving energy efficiency. In this paper we present the first empirical study on understanding the views of application programmers on software energy consumption problems. Using StackOverflow as our primary data source, we analyze a carefully curated sample of more than 300 questions and 550 answers from more than 800 users. With this data, we observed a number of interesting findings. Our study shows that practitioners are aware of the energy consumption problems: the questions they ask are not only diverse--we found 5 main themes of questions--but\u00a0\u2026", "num_citations": "197\n", "authors": ["795"]}
{"title": "Data-oriented characterization of application-level energy optimization\n", "abstract": " Empowering application programmers to make energy-aware decisions is a critical dimension of energy optimization for computer systems. In this paper, we study the energy impact of alternative data management choices by programmers, such as data access patterns, data precision choices, and data organization. Second, we attempt to build a bridge between application-level energy management and hardware-level energy management, by elucidating how various application-level data management features respond to Dynamic Voltage and Frequency Scaling (DVFS). Finally, we apply our findings to real-world applications, demonstrating their potential for guiding application-level energy optimization. The empirical study is particularly relevant in the Big Data era, where data-intensive applications are large energy consumers, and their energy efficiency is strongly correlated to how data are\u00a0\u2026", "num_citations": "99\n", "authors": ["795"]}
{"title": "Understanding energy behaviors of thread management constructs\n", "abstract": " Java programmers are faced with numerous choices in managing concurrent execution on multicore platforms. These choices often have different trade-offs (eg, performance, scalability, and correctness guarantees). This paper analyzes an additional dimension, energy consumption. It presents an empirical study aiming to illuminate the relationship between the choices and settings of thread management constructs and energy consumption. We consider three important thread management constructs in concurrent programming: explicit thread creation, fixed-size thread pooling, and work stealing. We further shed light on the energy/performance trade-off of three``tuning knobs''of these constructs: the number of threads, the task division strategy, and the characteristics of processed data. Through an extensive experimental space exploration over real-world Java programs, we produce a list of findings about the\u00a0\u2026", "num_citations": "96\n", "authors": ["795"]}
{"title": "Energy efficiency: a new concern for application software developers\n", "abstract": " Development of energy-efficient software is hindered by a lack of knowledge and a lack of tools.", "num_citations": "87\n", "authors": ["795"]}
{"title": "What programmers say about refactoring tools?: An empirical investigation of Stack Overflow\n", "abstract": " Programmers often use forums, such as StackOverflow, to easily and quickly solve their issues. Researchers then investigate those questions to better understand the state-of-use of software engineering techniques. Also, due to the quality and the great number questions and answers, the results found using such method might be difficult, or even impossible, to find using common survey techniques. In this study, we conducted a qualitative and quantitative research in order to categorize questions about refactoring tools. As a result, we presented a comprehensive classification of flaws and desirable features in refactoring tools. We also reported that programmers do not often rely on refactoring tools, but, at the same time, they are desiring number of unimplemented features.", "num_citations": "52\n", "authors": ["795"]}
{"title": "A Comprehensive Study on the Energy Efficiency of Java Thread-Safe Collections\n", "abstract": " Java programmers are served with numerous choices of collections, varying from simple sequential ordered lists to sophisticated hashtable implementations. These choices are well-known to have different characteristics in terms of performance, scalability, and thread-safety, and most of them are well studied. This paper analyzes an additional dimension, energy efficiency. We conducted an empirical investigation of 16 collection implementations (13 thread-safe, 3 non-thread-safe) grouped under 3 commonly used forms of collections (lists, sets, and mappings). Using micro-and real world-benchmarks (Tomcat and Xalan), we show that our results are meaningful and impactful. In general, we observed that simple design decisions can greatly impact energy consumption. In particular, we found that using a newer hashtable version can yield a 2.19x energy savings in the micro-benchmarks and up to 17% in the real\u00a0\u2026", "num_citations": "48\n", "authors": ["795"]}
{"title": "Adopting DevOps in the real world: A theory, a model, and a case study\n", "abstract": " DevOps is a set of practices and cultural values that aims to reduce the barriers between development and operations teams. Due to its increasing interest and imprecise definitions, existing research works have tried to characterize DevOps.Nevertheless, little is known about the practitioners\u2019 understandingabout successful paths for DevOps adoption. Therefore, our goal is to detail real scenarios of DevOps adoption, presenting a theory, a model, and a case study.We used classic Grounded Theory to build a theory about 15 scenarios of successful DevOps adoption in companies from different domains and countries. We proposed a model (i.e., a workflow for DevOps adoption) and evaluated it through a case study at a Brazilian Government institution. We used a focus group to collect the company perceptions about DevOps adoption.This paper increments the existing view of DevOps by detailing real scenarios and\u00a0\u2026", "num_citations": "42\n", "authors": ["795"]}
{"title": "A multi-objective genetic algorithm to test data generation\n", "abstract": " Evolutionary testing has successfully applied search based optimization algorithms to the test data generation problem. The existing works use different techniques and fitness functions. However, the used functions consider only one objective, which is, in general, related to the coverage of a testing criterion. But, in practice, there are many factors that can influence the generation of test data, such as memory consumption, execution time, revealed faults, and etc. Considering this fact, this work explores a multiobjective optimization approach for test data generation. A framework that implements a multi-objective genetic algorithm is described. Two different representations for the population are used, which allows the test of procedural and object-oriented code. Combinations of three objectives are experimentally evaluated: coverage of structural test criteria, ability to reveal faults, and execution time.", "num_citations": "42\n", "authors": ["795"]}
{"title": "Are static analysis violations really fixed?: a closer look at realistic usage of SonarQube\n", "abstract": " The use of automatic static analysis tools (ASATs) has gained increasing attention in the last few years. Even though available research have already explored ASATs issues and how they are fixed, these studies rely on revisions of the software, instead of mining real usage of these tools and real issue reports. In this paper we contribute with a comprehensive, multi-method study about the usage of SonarQube (a popular static analysis tool), mining 421,976 issues from 246 projects in four different instance of SonarQube: two hosted in open-source communities (Eclipse and Apache) and two hosted in Brazilian government institutions (Brazilian Court of Account (TCU) and Brazilian Federal Police (PF)). We first surveyed team leaders of the analyzed projects and found that they mostly consider ASATs warning messages as relevant for overall software improvement. Second, we found that both Eclipse and TCU\u00a0\u2026", "num_citations": "31\n", "authors": ["795"]}
{"title": "Are Java programmers transitioning to multicore?: a large scale study of java FLOSS\n", "abstract": " We would like to know if Java developers are retrofitting applications to become concurrent and, to get better performance on multicore machines. Also, we would like to know what concurrent programming constructs they currently use. Evidence of how programmers write concurrent programs can help other programmers to be more efficient when using the available constructs. Moreover, this evidence can assist researchers in devising new mechanisms and improving existing ones. For this purpose, we have conducted a study targeting a large-scale Java open source repository, SourceForge. We have analyzed a number of FLOSS projects along two dimensions: spatial and temporal. For the spatial dimension, we studied the latest versions of more than 2000 projects. Our goal is to understand which constructs developers of concurrent systems employ and how frequently they use them. For the temporal\u00a0\u2026", "num_citations": "28\n", "authors": ["795"]}
{"title": "Training Software Engineers using Open-Source Software: The Students\u2019 Perspective\n", "abstract": " Software Engineering courses often emphasize teaching methodologies and concepts in small and controlled environments over teaching, say, maintenance aspects of full-fledged real software systems. This decision is partly justified due to the difficulty of bringing to the context of a classroom a real software project. The widespread presence of open source projects, however, is contributing to alleviating this problem. Several instructors have already adopted contributions to open source projects as part of their evaluation process, and these instructors reported many benefits, including the improvement on students' technical and social skills. However, little is known about the students' perceptions regarding the need to contribute to an open source project as part of a Software Engineering course. To better understand the students' challenges, benefits, and attitudes, we conducted 21 semi-structured interviews with\u00a0\u2026", "num_citations": "27\n", "authors": ["795"]}
{"title": "Refactoring for energy efficiency: a reflection on the state of the art\n", "abstract": " Recent refactoring research introduced several innovations addressing diverse goals, such code extensibility, reusability, and testability. However, energy consumption, a critical property of any software system, remains unaddressed by refactoring research. In this paper, we provide an accounting of some of the recent and successful state-of-the-art research on software energy consumption. Through an investigation on premiere software engineering venues, we identify and discuss 12 contributions that can be further instantiated in refactoring tools used to improve software energy efficiency -- and the challenges behind this process. These opportunities span a wide range of software characteristics, such as mobile applications and concurrent programming. Mobile applications is the topic with the greatest number of opportunities (6 out of 11). The study serves as a call to action for refactoring researchers interested\u00a0\u2026", "num_citations": "23\n", "authors": ["795"]}
{"title": "Building a Collaborative Culture: A Grounded Theory of Well Succeeded DevOps Adoption in Practice\n", "abstract": " Background. DevOps is a set of practices and cultural values that aims to reduce the barriers between development and operations teams. Due to its increasing interest and imprecise definitions, existing research works have tried to characterize DevOps---mainly using a set of concepts and related practices.Aims. Nevertheless, little is known about the practitioners practitioners' understanding about successful paths for DevOps adoption. The lack of such understanding might hinder institutions to adopt DevOps practices. Therefore, our goal here is to present a theory about DevOps adoption, highlighting the main related concepts that contribute to its adoption in industry.Method. Our work builds upon Classic Grounded Theory. We interviewed practitioners that contributed to DevOps adoption in 15 companies from different domains and across 5 countries. We empirically evaluate our model through a case study\u00a0\u2026", "num_citations": "22\n", "authors": ["795"]}
{"title": "How does contributors' involvement influence the build status of an open-source software project?\n", "abstract": " The recent introduction of the pull-based development model promoted agile development practices such as Code Reviews and Continuous Integration (CI). CI, in particular, is currently a standard development practice in open-source software (OSS) projects. Although it is well-known that OSS contributors have different involvements (e.g., while some developers drive the project, there is a long tail of peripheral developers), little is known about how the contributor's degree of participation can influence the build status of an OSS project. Through TravisTorrent's dataset, we compare the success rates of builds made by casual and non-casual contributors and what factors on their contributions may influence the build result. Our results suggest that there is no representative difference between their build success (they are similar in 85% of the analyzed projects), meaning that being a casual contributor is not a strong\u00a0\u2026", "num_citations": "22\n", "authors": ["795"]}
{"title": "A study on the most popular questions about concurrent programming\n", "abstract": " Concurrent programming is notably known as a hard discipline. Over the last few years, great strides have been made in improving concurrent programming abstractions, techniques, and tools to ease concurrent programming practice. However, little effort has been placed on assessing what are the real-world problems faced by developers when writing concurrent applications. In this paper, we describe an empirical investigation of the top-250 most popular questions about concurrent programming on StackOverflow. We observed that even though some questions (22.94%) are related to practical problems (eg,\u201chow to fix this concurrency bug\u201d), most of them (66.23%) are related to basic concepts (eg,\u201cwhat is a mutex?\u201d), which were created by well-experienced StackOverflow users. Curiously, we did not find any question about how to use concurrent programming techniques to improve application performance.", "num_citations": "21\n", "authors": ["795"]}
{"title": "An Experience Report on the Adoption of Microservices in Three Brazilian Government Institutions\n", "abstract": " Although monolithic applications are still the modus operandi of many software systems, the microservices architecture, which favors small and independent applications, is gaining increasing popularity. This is part due to its claimed benefits, which includes better scalability, productivity, and maintainability. However, little is known about how developers and architects perceive the benefits of migrating from monolithic applications to microservices, and what are the challenges towards achieving them. In this paper we discuss the motivation, benefits, and challenges related to the migration from monolithic enterprise architectures to a microservices based architecture. We report several lessons learned that arose from a two years process faced by three Brazilian Government Institutions. We also cross-validate these findings with a survey conducted with 13 practitioners in the studied companies. The results of our\u00a0\u2026", "num_citations": "20\n", "authors": ["795"]}
{"title": "Understanding and overcoming parallelism bottlenecks in forkjoin applications\n", "abstract": " ForkJoin framework is a widely used parallel programming framework upon which both core concurrency libraries and real-world applications are built. Beneath its simple and user-friendly APIs, ForkJoin is a sophisticated managed parallel runtime unfamiliar to many application programmers: the framework core is a work-stealing scheduler, handles fine-grained tasks, and sustains the pressure from automatic memory management. ForkJoin poses a unique gap in the compute stack between high-level software engineering and low-level system optimization. Understanding and bridging this gap is crucial for the future of parallelism support in JVM-supported applications. This paper describes a comprehensive study on parallelism bottlenecks in ForkJoin applications, with a unique focus on how they interact with underlying system-level features, such as work stealing and memory management. We identify 6\u00a0\u2026", "num_citations": "20\n", "authors": ["795"]}
{"title": "What Attract Newcomers to Onboard on OSS Projects? TL; DR: Popularity\n", "abstract": " Voluntary contributions play an important role in maintaining Open Source Software (OSS) projects active. New volunteers feel motivated to contribute to OSS projects based on a set of motivations. In this study, we aim to understand which factors OSS projects usually maintain that might influence their new contributors\u2019 onboarding. Using a set of 450 repositories, we investigated mixed factors, such as the project age, the number of stars, the programming language used, or the presence of text files that aid contributors (e.g., templates for pull-requests or license files). We used a K-Spectral Centroid (KSC) clustering algorithm to investigated the newcomers\u2019 growth rate for the analyzed projects. We could found three common patterns: a logarithmic, an exponential, and a linear growth pattern. Based on these patterns, we used a Random Forest classifier to understand how each factor could explain the growth\u00a0\u2026", "num_citations": "16\n", "authors": ["795"]}
{"title": "Who gets a patch accepted first?: comparing the contributions of employees and volunteers\n", "abstract": " Although many software companies have recently embraced Open Source Software (OSS) initiatives, volunteers (i.e., developers who contribute to OSS in their spare time) still represent a wealthy workforce that have the potential of driving many non-trivial open source projects. Such volunteers face well-known barriers when attempting to contribute to OSS projects. However, what is still unclear is how the problems that volunteers face transcend to the problems that employees (i.e., developers hired by a software company to work on OSS projects) face. In this paper we aim to investigate the differences on the acceptance of patches submitted by volunteers and employees to company-owned OSS projects. We explore different characteristics of the patches submitted to company-owned OSS project, including: the frequency of acceptance and rejection; the total time to review and process a patch, and; whether the\u00a0\u2026", "num_citations": "16\n", "authors": ["795"]}
{"title": "Characterizing the energy efficiency of java\u2019s thread-safe collections in a multicore environment\n", "abstract": " Java programmers are served with numerous choices of collections, varying from simple sequential ordered lists to more sophisticated, thread-safe, and highly scalable hashtable implementations. These choices are well-known to have different characteristics in terms of performance, scalability, and thread-safety, and most of them are well studied. This paper analyzes an additional dimension, energy efficiency. Through an empirical investigation of 16 collection implementations grouped under 3 commonly used collections (Lists, Sets and Maps), we show that small design decisions can greatly impact energy consumption. The study serves as a first step toward understanding the energy efficiency of Java collections on parallel architectures.", "num_citations": "16\n", "authors": ["795"]}
{"title": "How do scientists develop scientific software? an external replication\n", "abstract": " Although the goal of scientists is to do science, not to develop software, many scientists have extended their roles to include software development to their skills. However, since scientists have different background, it remains unclear how do they perceive software engineering practices or how do they acquire software engineering knowledge. In this paper we conducted an external replication of one influential 10 years paper about how scientists develop and use scientific software. In particular, we employed the same method (an on-line questionnaire) in a different population (R developers). When analyzing the more than 1,574 responses received, enriched with data gathered from their GitHub repositories, we correlated our findings with the original study. We found that the results were consistent in many ways, including: (1) scientists that develop software work mostly alone, (2) they decide themselves what they\u00a0\u2026", "num_citations": "15\n", "authors": ["795"]}
{"title": "Spongebugs: Automatically generating fix suggestions in response to static code analysis warnings\n", "abstract": " Static code analysis tools such as FindBugs and SonarQube are widely used on open-source and industrial projects to detect a variety of issues that may negatively affect the quality of software. Despite these tools\u2019 popularity and high level of automation, several empirical studies report that developers normally fix only a small fraction (typically, less than 10% (Marcilio et\u00a0al., 2019) of the reported issues\u2014so-called \u201cwarnings\u201d. If these analysis tools could also automatically provide suggestions on how to fix the issues that trigger some of the warnings, their feedback would become more actionable and more directly useful to developers.In this work, we investigate whether it is feasible to automatically generate fix suggestions for common warnings issued by static code analysis tools, and to what extent developers are willing to accept such suggestions into the codebases they are maintaining. To this end, we\u00a0\u2026", "num_citations": "14\n", "authors": ["795"]}
{"title": "Work Practices and Challenges in Continuous Integration: A Survey with Travis CI Users\n", "abstract": " Continuous integration (CI) is a software development practice that has been gaining increasing popularity in the last few years. However, we still miss a collection of experiences regarding how software developers perceive the idea of CI, in terms of its fundamental concepts, the reasons that motivate the adoption of this practice, the reasons for build breakage, and the benefits and problems related to CI. To shed light on this direction, we conducted a user survey with 158 CI users. Through a mostly qualitative investigation, we produce a list of findings that are not always obvious. For instance, we observed that (1) developers are not sure whether a job failure represents a failure or not; (2) inadequate testing is the most common technical reason related to build breakage, whereas lack of time plays a role on the social reasons; and (3) although some respondents reported that CI systems increase the confidence\u00a0\u2026", "num_citations": "14\n", "authors": ["795"]}
{"title": "Inadequate testing, time pressure, and (over) confidence: a tale of continuous integration users\n", "abstract": " Continuous Integration (CI) prescribes that changes should be integrated into the main codebase as often as possible and that the system should be built frequently. To support CI, a number of software tools have been developed. However, little is known about the main reasons for build breakage and whether CI delivers its promise of early problem detection and smooth integration. To shed light on this issue, we conducted a survey with 158 CI users. Through a qualitative investigation we found that inadequate testing is the most common technical reason related to build breakage, whereas lack of time plays a role on the social reasons. Still, although some respondents reported that CI usage increases the confidence that the code is in a known state, some respondents also reported that there is a false sense of confidence when blindly trusting tests.", "num_citations": "14\n", "authors": ["795"]}
{"title": "Finding needles in a haystack: Leveraging co-change dependencies to recommend refactorings\n", "abstract": " A fine-grained co-change dependency arises when two fine-grained source-code entities, e.g., a method, change frequently together. This kind of dependency is relevant when considering remodularization efforts (e.g., to keep methods that change together in the same class). However, existing approaches for recommending refactorings that change software decomposition (such as a move method) do not explore the use of fine-grained co-change dependencies. In this paper we present a novel approach for recommending move method and move field refactorings, which removes co-change dependencies and evolutionary smells, a particular type of dependency that arise when fine-grained entities that belong to different classes frequently change together. First we evaluate our approach using 49 open-source Java projects, finding 610 evolutionary smells. Our approach automatically computes 56 refactoring\u00a0\u2026", "num_citations": "13\n", "authors": ["795"]}
{"title": "C-3PR: A Bot for Fixing Static Analysis Violations via Pull Requests\n", "abstract": " Static analysis tools are frequently used to detect common programming mistakes or bad practices. Yet, the existing literature reports that these tools are still underused in the industry, which is partly due to (1) the frequent high number of false positives generated, (2) the lack of automated repairing solutions, and (3) the possible mismatches between tools and workflows of development teams. In this study we explored the question: \u201cHow could a bot-based approach allow seamless integration of static analysis tools into developers' workflows?\u201d To this end we introduce C-3PR, an event-based bot infrastructure that automatically proposes fixes to static analysis violations through pull requests (PRs). We have been using C-3PR in an industrial setting for a period of eight months. To evaluate C-3PR usefulness, we monitored its operation in response to 2179 commits to the code base of the tracked projects. The bot\u00a0\u2026", "num_citations": "12\n", "authors": ["795"]}
{"title": "The census of the brazilian open-source community\n", "abstract": " During a long time, software engineering research has been trying to better understand open-source communities and uncover two fundamental questions: (i) who are the contributors and (i) why they contribute. Most of these researches focus on well-known OSS projects, but little is known about the OSS movement in emerging countries. In this paper, we attempt to fill this gap by presenting a picture of the Brazilian open-source contributor. To achieve this goal, we examined activities from more than 12,400 programmers on Github, during the period of a year. Subsequently, we correlate our findings with a survey that was answered by more than 1,000 active contributors. Our results show that exists an OSS trend in Brazil: most part of the contributors are active, performing around 30 contributions per year, and they contribute to OSS basically by altruism.", "num_citations": "11\n", "authors": ["795"]}
{"title": "REST or GraphQL? A Performance Comparative Study\n", "abstract": " Given the variety of architectural models that can be used, a frequent questioning among software development practitioners is: which architectural model to use? To respond this question regarding performance issues, three target applications have been studied, each written using two models web services architectures: REST and GraphQL. Through research of performance metrics of response time and the average transfer rate between the requests, it was possible to deduce the particularities of each architectural model in terms of performance metrics. It was observed that migrating to GraphQL. resulted in an increase in performance in two-thirds of the tested applications, with respect to average number of requests per second and transfer rate of data. However, it was noticed that services after migration for GraphQL performed below its REST counterpart for workloads above 3000 requests, ranging from 98 to\u00a0\u2026", "num_citations": "10\n", "authors": ["795"]}
{"title": "Automatically Generating Fix Suggestions in Response to Static Code Analysis Warnings\n", "abstract": " Static code analysis tools such as FindBugs and SonarQube are widely used on open-source and industrial projects to detect a variety of issues that may negatively affect the quality of software. Despite these tools' popularity and high level of automation, several empirical studies report that developers normally fix only a small fraction (typically, less than 10% [1]) of the reported issues-so-called \"warnings\". If these analysis tools could also automatically provide suggestions on how to fix the issues that trigger some of the warnings, their feedback would become more actionable and more directly useful to developers. In this work, we investigate whether it is feasible to automatically generate fix suggestions for common warnings issued by static code analysis tools, and to what extent developers are willing to accept such suggestions into the codebases they're maintaining. To this end, we implemented a Java program\u00a0\u2026", "num_citations": "9\n", "authors": ["795"]}
{"title": "Naming the Pain in Developing Scientific Software\n", "abstract": " The scientific software community's lack of computer science background and software engineering training takes a toll on scientists who need to develop software. We built a taxonomy of 2,110 reported problems and grouped them into three major axes: technical-related, socialrelated, and scientific-related problems.", "num_citations": "9\n", "authors": ["795"]}
{"title": "Comprehending Energy Behaviors of Java I/O APIs\n", "abstract": " Background: APIs that implement I/O operations are the building blocks of many well-known, non-trivial software systems. These APIs are used for a great variety of programming tasks, from simple file management operations, to database communications and implementation of network protocols.Aims: Despite their ubiquity, there are few studies that focus on comprehending their energy behaviors in order to aid developers interested in building energy-conscious software systems. The goal of this work is two-fold. We first aim to characterize the landscape of the Java I/O programming APIs. After better comprehending their energy variations, our second goal is to refactor software systems that use energy inefficient I/O APIs to their efficient counterparts.Method: To achieve the first goal, we instrumented 22 Java micro-benchmarks that perform I/O operations. To achieve our second goal, we extensively experimented\u00a0\u2026", "num_citations": "8\n", "authors": ["795"]}
{"title": "Mining Rule Violations in JavaScript Code Snippets\n", "abstract": " Programming code snippets readily available on platforms such as StackOverflow are undoubtedly useful for software engineers. Unfortunately, these code snippets might contain issues such as deprecated, misused, or even buggy code. These issues could pass unattended, if developers do not have adequate knowledge, time, or tool support to catch them. In this work we expand the understanding of such issues (or the so called \"violations\") hidden in code snippets written in JavaScript, the programming language with the highest number of questions on StackOverflow. To characterize the violations, we extracted 336k code snippets from answers to JavaScript questions on StackOverflow and statically analyzed them using ESLinter, a JavaScript linter. We discovered that there is no single JavaScript code snippet without a rule violation. On average, our studied code snippets have 11 violations, but we found\u00a0\u2026", "num_citations": "8\n", "authors": ["795"]}
{"title": "On the implications of language constructs for concurrent execution in the energy efficiency of multicore applications\n", "abstract": " Our study analyzed the performance and energy consumption of multicore applications, using a number of techniques to manage concurrent execution. We concluded that language constructs for concurrent execution can impact energy consumption. Nonetheless, the tradeoff between performance and energy consumption in multicore applications is not as obvious as it seems.", "num_citations": "8\n", "authors": ["795"]}
{"title": "Refactoring multicore applications towards energy efficiency\n", "abstract": " Great strides have been made to increase the energy efficiency of hardware, data center facilities, and network infrastructure. However, in any computer system, it is software that directs much of the activity of the hardware. Moreover, multicore processors have become ubiquitous, mainly because their multiple benefits, especially enhanced performance for multi-threaded and compute-intensive applications. Nonetheless, there are few studies addressing the topic of restructuring multicore applications to consume less energy and even fewer that leverage developer expertise to achieve that goal. In this thesis we present a brief background study for refactoring multicore applications in order to improve both performance and energy consumption. The idea consists in proposing a catalog of refactorings targeting some languages of the JVM platform.", "num_citations": "7\n", "authors": ["795"]}
{"title": "Open source development around the world: A comparative study\n", "abstract": " Open source software has an increasing importance in our modern society, providing basic services to other software systems and also supporting the rapid development of a variety of end-user applications. Recently, world-wide code sharing platforms, like GitHub, are also contributing to open source's growth. However, little is known on how this growth is distributed around the world and about the characteristics of the projects developed in different countries. In this article, we provide a characterization of 2,648 open source projects developed in 20 countries. We reveal the number of projects per country, the popularity and programming language of each country's project and also show how the number of projects in a country correlates to its GDP. Finally, we assess the maintainability and internal code quality of the studied projects, using a tool called BetterCodeHub.", "num_citations": "6\n", "authors": ["795"]}
{"title": "Assisting non-specialist developers to build energy-efficient software\n", "abstract": " In this paper we introduce CECOTOOL, a tool that analyzes the energy behavior of alternative collection implementations and provides potentially useful recommendations about good implementation options. We applied it to two real-world software systems from the DaCapo suite [1], Xalan and Tomcat. With no prior knowledge of the application domains, we were able to reduce the energy consumption up to 4.37%.", "num_citations": "6\n", "authors": ["795"]}
{"title": "Hand resting tremor assessment of healthy and patients with Parkinson\u2019s disease: an exploratory machine learning study\n", "abstract": " The aim of this study is comparing the accuracies of machine learning algorithms to classify data concerning healthy subjects and patients with Parkinson\u2019s Disease (PD), towards different time window lengths and a number of features. Thirty-two healthy subjects and eighteen patients with PD took part on this study. The study obtained inertial recordings by using an accelerometer and a gyroscope assessing both hands of the subjects during hand resting state. We extracted time and temporal frequency domain features to feed seven machine learning algorithms: k-nearest-neighbors (kNN); logistic regression; support vector classifier (SVC); linear discriminant analysis; random forest; decision tree; and, gaussian Na\u00efve Bayes. The accuracy of the classifiers was compared using different numbers of extracted features (i.e. 272, 190, 136, 82, and 27) from different time window lengths (i.e. 1, 5, 10, and 15 seconds). The inertial recordings were characterized by oscillatory waveforms that, especially in patients with PD, peaked in a frequency range between 3\u20138 Hz. Outcomes showed that the most important features were the mean frequency, linear prediction coefficients, power ratio, power density skew, and kurtosis. We observed that accuracies calculated in the testing phase were higher than in the training phase. Comparing the testing accuracies, we found significant interactions among time window length and the type of classifier (p < 0.05). The study found significant effects on estimated accuracies, according to their type of algorithm, time window length, and their interaction. kNN presented the highest accuracy, while SVC showed the worst\u00a0\u2026", "num_citations": "4\n", "authors": ["795"]}
{"title": "How Trans-Inclusive Are Hackathons?\n", "abstract": " Hackathons can be fun! However, for the transgender community and other minorities, hackathons can have an uncomfortable atmosphere. In this article, we surveyed 44 LGBTQIA+ experienced in hackathons and interviewed seven transgender participants. By understanding their needs and challenges, we introduce five recommendations to make hackathons more inclusive.", "num_citations": "3\n", "authors": ["795"]}
{"title": "A refactoring approach to improve energy consumption of parallel software systems\n", "abstract": " Empowering application programmers to make energy-aware decisions is a critical dimension in improving energy efficiency of computer systems. Despite the growing interest in designing software development processes, frameworks, and programming models to facilitate application-level energy management, little is known on how to design application-level energy-efficient solutions for concurrent software running on parallel architectures. This is unfortunate for at least two reasons: (1) thanks to the proliferation of multicore CPUs, concurrent programming is a standard practice in modern software engineering; (2) a CPU with more cores (say 32) often consumes more power than one with fewer cores (say 1 or 2). However, application developers still do not understand how their code modifications impact energy consumption in a parallel system. Analyzing STACKOVERFLOW showed evidence that this is a real problem; Even though the interest in energy consumption issues is increasing over the years, developers still hold misconceptions and assumptions that are not always true. This lack of knowledge is primarily due to a lack of appropriate tools to measure/identify/refactor energy consumption hotspots. This thesis begins to bridge the chasm of the first problem \u2014 the lack of knowledge \u2014 by presenting an extensive experimental space exploration over two concurrent programming building blocks: (1) thread-safe collections and (2) thread management constructs. Through a list of findings that are not always obvious, we illuminate the relationship between the choices and settings of design decisions and energy consumption of parallel\u00a0\u2026", "num_citations": "3\n", "authors": ["795"]}
{"title": "How (Not) to Find Bugs: The Interplay Between Merge Conflicts, Co-Changes, and Bugs\n", "abstract": " Context: In a seminal work, Ball et al. [1] investigate if the information available in version control systems could be used to predict defect density, arguing that practitioners and researchers could better understand errors \"if [our] version control system could talk\". In the meanwhile, several research works have reported that conflict merge resolution is a time consuming and error-prone task, while other contributions diverge about the correlation between co-change dependencies and defect density. Problem: The correlation between conflicting merge scenarios and bugs has not been addressed before, whilst the correlation between co-change dependencies and bug density has been only investigated using a small number of case studies\u2014which can compromise the generalization of the results. Goal: To address this gap in the literature, this paper presents the results of a comprehensive study whose goal is to\u00a0\u2026", "num_citations": "2\n", "authors": ["795"]}
{"title": "Detecting and Reporting Object-Relational Mapping Problems: An Industrial Report\n", "abstract": " Background: Object-Relational Mapping (ORM) frameworks are regarded as key tools in the software engineer arsenal. However, developers often face ORM problems, and the solution to these problems are not always clear. To mitigate these problems, we created a framework that detects and reports a family of ORM problems. Aims: The aim of this work is to assess how practitioners perceive our framework, the problems, they face, and the eventual points for improvements. Method: We first report an observational study in which we curated 12 ORM-related problems, which are implemented in our framework. We then conducted a developer experience (DX) study with 13 developers (10 well-experienced and 3 students) to assess their experience with our framework to implement six ORM-related tasks. Results: All participants agreed that our framework helped them to finish the programming tasks. The participants\u00a0\u2026", "num_citations": "2\n", "authors": ["795"]}
{"title": "From one to hundreds: multi-licensing in the JavaScript ecosystem\n", "abstract": " Open source licenses create a legal framework that plays a crucial role in the widespread adoption of open source projects. Without a license, any source code available on the internet could not be openly (re) distributed. Although recent studies provide evidence that most popular open source projects have a license, developers might lack confidence or expertise when they need to combine software licenses, leading to a mistaken project license unification. This license usage is challenged by the high degree of reuse that occurs in the heart of modern software development practices, in which third-party libraries and frameworks are easily and quickly integrated into a software codebase. This scenario creates what we call \u201cmulti-licensed\u201d projects, which happens when one project has components that are licensed under more than one license. Although these components exist at the file-level, they naturally impact\u00a0\u2026", "num_citations": "1\n", "authors": ["795"]}
{"title": "Exposing bugs in JavaScript engines through test transplantation and differential testing\n", "abstract": " JavaScript is a popular programming language today with several implementations competing for market dominance. Although a specification document and a conformance test suite exist to guide engine development, bugs occur and have important practical consequences. Implementing correct engines is challenging because the spec is intentionally incomplete and evolves frequently. This paper investigates the use of test transplantation and differential testing for revealing functional bugs in JavaScript engines. The former technique runs the regression test suite of a given engine on another engine. The latter technique fuzzes existing inputs and then compares the output produced by different engines with a differential oracle. We conducted experiments with engines from five major players\u2014Apple, Facebook, Google, Microsoft, and Mozilla\u2014to assess the effectiveness of test transplantation and differential\u00a0\u2026", "num_citations": "1\n", "authors": ["795"]}
{"title": "Small Changes, Big Impacts: Leveraging Diversity to Improve Energy Efficiency\n", "abstract": " In the last few years, a growing body of research has proposed methods, techniques, and tools to support developers in the construction of software that consumes less energy. These solutions leverage diverse approaches such as version history mining, analytical models, identifying energy-efficient color schemes, and optimizing the packaging of HTTP requests. In this chapter, we present a complementary approach. We advocate that developers should leverage software diversity to make software systems more energy-efficient. Our main insight is that non-specialists can build software that consumes less energy by alternating at development time between readily available, diversely-designed pieces of software implemented by third-parties. These pieces of software can vary in nature, granularity, and quality attributes. Examples include data structures and constructs for thread management and synchronization.", "num_citations": "1\n", "authors": ["795"]}
{"title": "Do language constructs for concurrent execution have impact on energy efficiency?\n", "abstract": " This study analyzed the performance and energy consumption of multicore applications, using three techniques to manage concurrent execution in a set of benchmarks. We conclude that these constructs can heavily impact on energy consumption. Nonetheless, the trade-off between performance and energy consumption in multicore applications is not so obvious.", "num_citations": "1\n", "authors": ["795"]}