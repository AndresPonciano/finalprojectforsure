{"title": "Mutation testing for aspect-oriented programs\n", "abstract": " Mutation testing has been shown to be one of the strongest testing criteria for the evaluation of both programs and test suites. Comprehensive sets of mutants require strong test sets to achieve acceptable testing coverage. Moreover, mutation operators are valuable for the evaluation of other testing approaches. Although its importance has been highlighted for aspect-oriented (AO) programs, there is still a need for a suitable set of mutation operators for AO languages. The quality of the mutation testing itself relies on the quality of such operators. This paper presents the design of a set of mutation operators for AspectJ-based programs. These operators model instances of fault types identified in an extensive survey. The fault types and respective operators are grouped according to the related language features. We also discuss the generalisation of the fault types to AO approaches other than AspectJ and the\u00a0\u2026", "num_citations": "129\n", "authors": ["2025"]}
{"title": "Assessing the impact of aspects on exception flows: An exploratory study\n", "abstract": " Exception handling mechanisms are intended to support the development of robust software. However, the implementation of such mechanisms with aspect-oriented (AO) programming might lead to error-prone scenarios. As aspects extend or replace existing functionality at specific join points in the code execution, aspects\u2019 behavior may bring new exceptions, which can flow through the program execution in unexpected ways. This paper presents a systematic study that assesses the error proneness of AOP mechanisms on exception flows of evolving programs. The analysis was based on the object-oriented and the aspect-oriented versions of three medium-sized systems from different application domains. Our findings show that exception handling code in AO systems is error-prone, since all versions analyzed presented an increase in the number of uncaught exceptions and exceptions caught by the\u00a0\u2026", "num_citations": "122\n", "authors": ["2025"]}
{"title": "Revis\u00e3o sistem\u00e1tica da literatura em engenharia de software: teoria e pr\u00e1tica\n", "abstract": " Objetivo \u00e9 ensinar revis\u00e3o sistem\u00e1tica (RS) para alunos de gradua\u00e7\u00e3o e p\u00f3s-gradua\u00e7\u00e3o atrav\u00e9s de perguntas e respostas. Cada cap\u00edtulo deste livro est\u00e1 organizado como uma s\u00e9rie de perguntas e respostas referentes \u00e0 realiza\u00e7\u00e3o/condu\u00e7\u00e3o de uma RS. As perguntas foram coletadas durante as palestras e cursos sobre RS, e representam os tipos mais comuns de d\u00favidas sobre o tema. Este livro pode ser lido de duas maneiras. Uma op\u00e7\u00e3o \u00e9 a leitura sequencial, do primeiro ao \u00faltimo cap\u00edtulo. Ao final, o leitor estar\u00e1 apto para conduzir sua pr\u00f3pria RS. A outra maneira \u00e9 ler perguntas/respostas pontuais, em uma ordem definida pelos interesses do pr\u00f3prio leitor. As respostas incluem texto e exemplos de RSs conduzidas na \u00e1rea de Engenharia de Software. Ser\u00e3o usados exemplos para que os leitores possam entender cada fase do processo que comp\u00f5e uma RS com confian\u00e7a. Em resumo, proposta de um livro pr\u00e1tico, que poder\u00e1 ser utilizado como um guia para melhorar a compreens\u00e3o sobre o processo de RS e seus detalhes. Os leitores ser\u00e3o capazes de: Compreender o processo para conduzir uma RS; Realizar uma pesquisa abrangente de literatura; Selecionar estudos relevantes para responder quest\u00f5es de pesquisa; Compreender m\u00e9todos. Objetivo \u00e9 ensinar revis\u00e3o sistem\u00e1tica (RS) para alunos de gradua\u00e7\u00e3o e p\u00f3s-gradua\u00e7\u00e3o por meio de perguntas e respostas. As perguntas foram coletadas durante as palestras e cursos sobre RS, e representam os tipos mais comuns de d\u00favidas sobre o tema. Ser\u00e3o usados exemplos para que os leitores possam entender cada fase do processo que comp\u00f5e uma RS com confian\u00e7a. Em\u00a0\u2026", "num_citations": "94\n", "authors": ["2025"]}
{"title": "An aspect-oriented reference architecture for software engineering environments\n", "abstract": " Reusable and evolvable Software Engineering Environments (SEEs) are essential to software production and have increasingly become a need. In another perspective, software architectures and reference architectures have played a significant role in determining the success of software systems. In this paper we present a reference architecture for SEEs, named RefASSET, which is based on concepts coming from the aspect-oriented approach. This architecture is specialized to the software testing domain and the development of tools for that domain is discussed. This and other case studies have pointed out that the use of aspects in RefASSET provides a better Separation of Concerns, resulting in reusable and evolvable SEEs.", "num_citations": "49\n", "authors": ["2025"]}
{"title": "Towards a Reference Architecture for Software Testing Tools.\n", "abstract": " Producing high quality software systems has been one of the most important software development concerns. Software testing is recognized as a fundamental activity for assuring software quality; however, it is an expensive, errorprone, and time consuming activity. For this reason, a diversity of testing tools has been developed, however, they have been almost always designed without an adequate attention to their evolution, maintenance, and reuse. In this paper, we propose an aspect-based software architecture, named RefTEST (Reference Architecture for Software Testing Tools), that comprises the knowledge to develop testing tools. This architecture is strongly based on separation of concerns and aspects, aiming at evolving, maintaining and reusing efforts to develop these tools. Our experimental results have pointed out that RefTEST can contribute to the development and reengineering of testing tools.", "num_citations": "49\n", "authors": ["2025"]}
{"title": "An empirical evaluation of coupling metrics on aspect-oriented programs\n", "abstract": " Coupling metrics received increased recognition by object-oriented (OO) software developers when they were found to be indicators of important quality attributes, such as fault-proneness. However, there is no consensus on which coupling metrics are effective quality indicators for emerging development paradigms, such as Aspect-Oriented Programming (AOP). AOP aims to improve software quality by providing significantly different decomposition mechanisms, such as pointcut, advice and intertype declarations. Therefore, it is not obvious if quality indicators for AOP can be derived from direct extensions of classical OO metrics. However, empirical studies of AOP do often rely on classical coupling metrics. Despite the recent adoption of AOP in industrial projects, coupling metrics have been rarely evaluated as useful indicators of fault-proneness in this context. This paper analyses the effectiveness of coupling\u00a0\u2026", "num_citations": "48\n", "authors": ["2025"]}
{"title": "Automating the mutation testing of aspect-oriented Java programs\n", "abstract": " Aspect-Oriented Programming has introduced new types of software faults that may be systematically tackled with mutation testing. However, such testing approach requires adequate tooling support in order to be properly performed. This paper addresses this issue, introducing a novel tool named Proteum/AJ. Proteum/AJ realises a set of requirements for mutation-based testing tools and overcomes some limitations identified in previous tools for aspect-oriented programs. Through an example, we show how Proteum/AJ was designed to support the main steps of mutation testing. This preliminary use of the tool in a full test cycle provided evidences of the feasibility of using it in real software development processes and helped us to reason about the current functionalities and to identify future needs.", "num_citations": "48\n", "authors": ["2025"]}
{"title": "Externalising tacit knowledge of the systematic review process\n", "abstract": " Systematic Reviews (SRs) have recently intensified in Software Engineering. However, there is a lack of work that makes explicit how the process to perform SR is in practice. The goal of this paper is externalising the process that reflects how SRs are currently performed, transforming tacit knowledge into explicit knowledge. We describe the phases and activities that compose the process and the relationship among them, and explore the iterative characteristic of this process, focusing on intra- and inter-phase iterations that are necessary to conduct the process appropriately. To achieve the proposed goal, we devised the process based on practical experience acquired for several years by research groups in Software Engineering, which include graduate students and researchers who have applied SR. The process has been applied in several SRs and seems to be effective in keeping the focus of the review at all\u00a0\u2026", "num_citations": "26\n", "authors": ["2025"]}
{"title": "Characterisation of challenges for testing of adaptive systems\n", "abstract": " Context: Exercising the implementation of an adaptive system (AS) effectively, in order to detect faults, is not a trivial task. This is due to characteristics of this type of systems, such as the high number of configurations and runtime adaptations. In this context, the characterisation of challenges for testing ASs may support the definition of suitable testing strategies. However, such characterisation is currently spread over several studies in the literature. Objective: analysing testing-related challenges for ASs which are described in the literature, and establishing a generic classification. Method: we extended a Systematic Literature Review (SLR) of studies that address challenges for AS testing. By analysing the combined results (original and extended), we mapped descriptions found in individual studies, based on their similarities, in order to create a list of generic challenges. Results: a list of 12 generic challenges based\u00a0\u2026", "num_citations": "23\n", "authors": ["2025"]}
{"title": "Towards the practical mutation testing of AspectJ programs\n", "abstract": " Mutation testing is a test selection criterion that relies on the assumption that test cases which can reveal artificial faults in the software are also good to reveal the real ones. It helps to expose faults which would go otherwise unnoticed. This criterion has been shown to be a promising means to deal with testing-related specificities of contemporary programming techniques such as Aspect-Oriented Programming. However, to date the few initiatives for customising mutation testing for aspect-oriented (AO) programs show either limited coverage with respect to the range of simulated faults, or a need for both adequate tool support and proper evaluation in regard to properties like application cost and effectiveness. This article tackles these limitations by describing a comprehensive mutation-based testing approach for programs written in AspectJ, which represents the most investigated AO programming language to date\u00a0\u2026", "num_citations": "22\n", "authors": ["2025"]}
{"title": "Reasoning about faults in aspect-oriented programs: a metrics-based evaluation\n", "abstract": " Aspect-oriented programming (AOP) aims at facilitating program comprehension and maintenance in the presence of crosscutting concerns. Aspect code is often introduced and extended as the software projects evolve. Unfortunately, we still lack a good understanding of how faults are introduced in evolving aspect-oriented programs. More importantly, there is little knowledge whether existing metrics are related to typical fault introduction processes in evolving aspect-oriented code. This paper presents an exploratory study focused on the analysis of how faults are introduced during maintenance tasks involving aspects. The results indicate a recurring set of fault patterns in this context, which can better inform the design of future metrics for AOP. We also pinpoint AOP-specific fault categories which are difficult to detect with popular metrics for fault-proneness, such as coupling and code churn.", "num_citations": "18\n", "authors": ["2025"]}
{"title": "A systematic review of cost reduction techniques for mutation testing: preliminary results\n", "abstract": " This paper reports on results from a systematic review that characterizes the state-of-the-art on cost reduction for mutation testing. It analyzes the evolution of research on this topic and its underlying goals and techniques, and identifies metrics used to measure cost reduction. The mixed search strategy used automatic search, snowballing, and a survey of authors of primary studies. The analysis is based on a set of 165 peer-reviewed studies, from which 146 present either original or updated approaches and results for cost reduction of mutation testing. A list of 6 main goals for cost reduction is presented, and 22 techniques were identified. Historically, 18 metrics have been used to measure the gains and losses observed in experimental studies. In the last decade, substantial growth in the number of published studies was observed, particularly among techniques such as selective mutation, evolutionary algorithms\u00a0\u2026", "num_citations": "17\n", "authors": ["2025"]}
{"title": "Proteum/AJ: a mutation system for AspectJ programs\n", "abstract": " Aspect-Oriented Programming (AOP) has introduced a complementary set of mechanisms which enhance the modularisation of crosscutting concerns. However, such mechanisms represent new potential sources of faults that may be systematically tackled with mutation testing. In this demonstration we present a tool, named Proteum/AJ, which automates the mutation testing of AspectJ programs. Proteum/AJ supports the main steps of this testing approach and realises a set of requirements for mutation-based testing tools like mutant handling, test case handling and mutant analysis. Our experience in using the tool provided us with evidence on the feasibility of performing mutation testing of AO programs. In this demonstration we are going to share some of this experience with the audience.", "num_citations": "15\n", "authors": ["2025"]}
{"title": "Initiatives and challenges of using gamification in software engineering: A Systematic Mapping\n", "abstract": " Context:Gamification is an emerging subject that has been applied in different areas, bringing contributions to different types of activities.Objective:This paper aims to characterize how gamification has been adopted in non-educational contexts of software engineering\u00a0(SE) activities.Methods:We performed a Systematic Mapping of the literature obtained from relevant databases of the area. The searches retrieved 2640 studies (published up to January 2020), of which 548 were duplicates, 82 were selected after applying the inclusion and exclusion criteria, and 21 were included via the backward snowballing technique, thus reaching a total of 103 studies to be analyzed.Results:Gamification provided benefits to activities like requirements specification, development, testing, project management, and support process. There is evidence of gamified support to some CMMI 2.0 Practice Areas. The most commonly used\u00a0\u2026", "num_citations": "14\n", "authors": ["2025"]}
{"title": "Identifying a subset of TMMi practices to establish a streamlined software testing process\n", "abstract": " Context: Testing is one of the most important phases of software development. However, in industry this phase is usually compromised by the lack of planning and resources. Due to it, the adoption of a streamlined testing process can lead to the construction of software products with desirable quality levels. Objective: Presenting the results of a survey conducted to identify a set of key practices to support the definition of a generic, streamlined software testing process, based on the practices described in the TMMi (Test Maturity Model integration). Method: Based on the TMMi, we have performed a survey among software testing professionals who work in both academia and industry. Their responses were analyzed quantitatively and qualitatively in order to identify priority practices to build the intended generic process. Results: The analysis enabled us to identify practices that were ranked as mandatory, those that are\u00a0\u2026", "num_citations": "14\n", "authors": ["2025"]}
{"title": "Gamification in software testing: A characterization study\n", "abstract": " Context: Testing is a fundamental activity in the software development cycle. Revealing software faults is its main objective. Despite that, testing is considered unpleasant, dull and tedious. As a result, there is a lack of expertise among professionals while many projects fail. Gamification is a promising way to address testing issues; it is a new trend being used mostly to increase motivation, engagement and performance with the use of game elements in non-game contexts. Objective: To describe results of a study that aimed to characterize how gamification has been explored to support software testing. Method: The studies that compose our baseline for analysis and discussion were obtained through a systematic mapping carried out following a research protocol. To retrieve relevant literature, we applied automatic search and backward snowballing. At the end, we selected 15 studies that we analyzed and classified\u00a0\u2026", "num_citations": "12\n", "authors": ["2025"]}
{"title": "A systematic mapping of architectures for embedded software\n", "abstract": " Context: representing software architectures for embedded systems, together with an adequate development process, configures a fundamental step to enhance the quality of the derived software products. Objectives: This papers aims at presenting a multifaceted characterisation of different techniques used for representing software architectures for embedded systems. Method: A systematic map was built to help the comprehension of how the research community has been investigating and describing software architectures for embedded systems. The identified primary studies were analysed and classified according to three facets in order to characterise the current research and to identify research gaps that shall be explored in the future. Results: the produced map makes explicit the most investigated topics in architecture representation for embedded systems as well as the research needs. It also helps\u00a0\u2026", "num_citations": "12\n", "authors": ["2025"]}
{"title": "Characterising the state of the practice in software testing through a TMMi-based process\n", "abstract": " The software testing phase, despite its importance, is usually compromised by the lack of planning and resources in industry. This can risk the quality of the derived products. The identification of mandatory testing-related practices may lead to the definition of feasible processes for varied sizes of software companies. In this context, this work aims at identifying a set of key practices to support the definition of a generic, streamlined software testing process, based on practices that are described in the TMMi (Test Maturity Model integration), and verify the alignment of the devised process with the TMMi levels. We have performed a survey amongst Brazilian software testing professionals who work in both academia and industry, in order to identify priority practices to build the intended, streamlined process; additionally, we applied a diagnosis tool in order to measure the level of TMMi which is fulfilled with the devised process. A set of 33 (out of 81) practices were ranked as mandatory by most of participants, which represents 40 % of the TMMi\u2019s full set of practices; on the downside, a testing process that relies on this subset of TMMi practices does not fully fulfil level 2 (Managed) of the maturity model. The identified subset of practices can guide the definition of a lean testing process when compared to a process that includes all TMMi practices; it is expected that such a process encourages a wider adoption of testing activities in software development; even though the streamlined process does not encompass many practices that are spread across TMMi levels, a substantial subset of level 2 practices (Managed) should be accomplished with its adoption.", "num_citations": "11\n", "authors": ["2025"]}
{"title": "Experimenting with a multi-iteration systematic review in software engineering\n", "abstract": " Context: Systematic reviews promise to become a common practice within the Software Engineering (SE) domain, having the replicability as an important requirement that allows for result contrasting and updates. Objectives: To provide background in systematic review updating process by reporting our experience in performing a multi-iteration systematic review within the SE domain. Method: We updated the original review twice based on an adapted three-phase process for systematic reviews. We discuss the main issues and present the lessons learned. Results: Following the adapted process led us to update the original review successfully, even considering the lack of background in review updates and the limited supporting mechanisms. Conclusions: Replicability of systematic reviews is feasible specially thanks to the rigorous planning process.", "num_citations": "11\n", "authors": ["2025"]}
{"title": "Visualiza\u00e7ao e interpreta\u00e7ao de modelos digitais de afloramentos utilizando laser scanner terrestre\n", "abstract": " O sistema LIDAR obt\u00e9m nuvens de pontos georreferenciadas que podem ser convertidas em Modelos Digitais de Afloramentos (MDAs). Os pulsos de laser s\u00e3o gerados e emitidos por um Laser Scanner Terrestre, que atinge a superf\u00edcie do afloramento em diferentes pontos. Estes objetos refletem o pulso incidente, que volta para o equipamento. Com isso, a dist\u00e2ncia entre o sensor e o objeto \u00e9 determinada com base no intervalo de tempo entre a emiss\u00e3o e o retorno do pulso. Para fins de Modelagem Digital de Afloramentos (MDA) o uso dessa t\u00e9cnica \u00e9 recente e necessita do desenvolvimento de pesquisas. Diante disso, o objetivo desse trabalho foi estabelecer uma sequencia de m\u00e9todos envolvendo a aquisi\u00e7\u00e3o e processamento de nuvem de pontos e a visualiza\u00e7\u00e3o e interpreta\u00e7\u00e3o de superf\u00edcies e volumes de um Modelo Digital de Afloramentos (MDA). A Rocha da Pedra Pintada, localizado no Rio Grande do Sul na Cidade de Ca\u00e7apava do Sul, foi imageado a partir de 7 esta\u00e7\u00f5es e a nuvem totalizou 17 milh\u00f5es de pontos, que foi convertida, ap\u03ccs processamento, em um MDA. Para a interpreta\u00e7\u00e3o geol\u03ccgica, utilizouYse a t\u00e9cnica de ortorretifica\u00e7\u00e3o para sobrepor a nuvem de pontos a fotografias de alta resolu\u00e7\u00e3o do afloramento, o que agregou qualidade na visualiza\u00e7\u00e3o e interpreta\u00e7\u00e3o do MDA. Dificuldades nas etapas de tratamento dos dados ocorreram em raz\u00e3o do grande volume de dados, da aus\u00eancia de recursos de otimiza\u00e7\u00e3o de processamento e da limita\u00e7\u00e3o no gerenciamento de banco de dados. Al\u00e9m disso, fazYse necess\u00e1rio desenvolver um aplicativo eficiente de visualiza\u00e7\u00e3o tridimensional com ferramentas especificas de\u00a0\u2026", "num_citations": "8\n", "authors": ["2025"]}
{"title": "Is It Worth Using Gamification on Software Testing Education? An Experience Report\n", "abstract": " Context: Testing is essential to improve the quality of software products. Despite that, it is not a subject that students are motivated to learn. Gamification is a promising way to address issues in software testing education; it is used to insert game elements in educational contexts aiming to increase students' motivation and performance. Objective: Reporting on results of an experimental study designed to assess the impact of gamification on software testing education. Method: We carried out the experimental sessions with undergraduate students from three Brazilian institutions. They have been taught basic testing concepts and functional testing. Moreover, the experimental group used a gamified platform that included 10 game elements to increase students' motivation and performance, attract their attention, and instigate their participation, collaboration, and competitiveness. Results: The experimental group was\u00a0\u2026", "num_citations": "7\n", "authors": ["2025"]}
{"title": "Web application development methods: a comparison.'\n", "abstract": " With the increasing expansion of Web applications, as well as the increase in the complexity of their development, several development methods for this class of application have been proposed. However, the majority of these methods only support the project stage satisfactorily. It is easy to notice that there are some problems related to the form of functional and information aspects are treated in conjunction. Besides, development methods for Web applications give very few attention for the conception, planning, testing and client evaluation stages. This paper highlights such problems, presenting an evaluation of several methods through a comparison of their main features. Considering the fact that most of methods present several problems, we also present a case study that uses a specific Web application to describe advantages and/or disadvantages of some selected methods.", "num_citations": "7\n", "authors": ["2025"]}
{"title": "Teste de software orientado a aspectos: uma revis\u00e3o sistem\u00e1tica.\n", "abstract": " A Programa\u00e7\u00e3o Orientada a Aspectos trouxe benef\u00edcios para o desenvolvimento de software e, como toda nova metodologia de desenvolvimento, novos desafios para a atividade de teste. Neste relat\u00f3rio s\u00e3o apresentados detalhes da condu\u00e7\u00e3o e dos resultados de uma revis\u00e3o sistem\u00e1tica cujo objetivo foi identificar os trabalhos que abordam a aplica\u00e7\u00e3o de t\u00e9cnicas e crit\u00e9rios de teste no contexto de software Orientado a Aspectos. Os resultados mostram que diversos trabalhos t\u00eam enfatizado a defini\u00e7\u00e3o de crit\u00e9rios e a caracteriza\u00e7\u00e3o de tipos de defeitos espec\u00edficos a esse tipo de software. Al\u00e9m disso, pode-se observar que existe pouca valida\u00e7\u00e3o dos trabalhos propostos. Os resultados servir\u00e3o de base para a condu\u00e7\u00e3o de novos trabalhos relacionados, incluindo a defini\u00e7\u00e3o e avalia\u00e7\u00e3o de crit\u00e9rios de teste, ferramentas de apoio automatizado e estudos experimentais.", "num_citations": "7\n", "authors": ["2025"]}
{"title": "Experimenting with a multi-approach testing strategy for adaptive systems\n", "abstract": " Context: Testing adaptive systems (ASs) is particularly challenging due to certain characteristics such as the high number of possible configurations, runtime adaptations and the interactions between the system and its surrounding environment. Therefore, the combination of different testing approaches in order to compose a strategy is expected to improve the quality of the designed test suites. Objective: To devise and experiment with a testing strategy for ASs that relies on particular characteristics of these systems. Method: We ranked testing approaches for ASs and devised a strategy that is composed of the three top-ranked ones. The rankings address the challenges that can be mitigated by the approaches, activities from a typical testing process, and characteristics observed in some AS implementations. The strategy was applied to two adaptive systems for mobile devices. Results: The approach was applied to\u00a0\u2026", "num_citations": "6\n", "authors": ["2025"]}
{"title": "Towards the characterization of monitor smells in adaptive systems\n", "abstract": " Adaptive Systems (ASs) can adapt themselves to achanging environment or new user needs. Monitors are essential in AS, being responsible for collecting and processing data from environment. There exist different kinds of monitors with distinct characteristics. Based on a literature review, we have noticed that Monitors are usually designed and implemented in an inadequate way: i) making them obscure in the source-code, ii) compelling all of them to have the same polling rate and also iii) predetermining the execution order among them. This leads to maintenance, evolution and performance problems. Besides, based on our observations, this erroneous way monitors are implemented follows a pattern and it is a recurrent practice. Therefore, we believe it can be classified as Monitor Smells of Adaptive Systems. In this paper we present two architectural smells we have identified: the Obscure Monitor and the\u00a0\u2026", "num_citations": "6\n", "authors": ["2025"]}
{"title": "Towards the establishment of a sufficient set of mutation operators for AspectJ programs\n", "abstract": " Mutation testing is an effective test selection criterion that has been explored in the context of aspect-oriented (AO) programs written in the AspectJ language. Despite its effectiveness, mutation testing is expensive. To reduce its application cost, some strategies based on mutation operator selection are available in the literature. This paper describes the results of a study that aimed to reduce the costs of applying mutation testing to AspectJ programs by identifying a reduced set of mutation operators known as sufficient operators. To achieve the proposed objective, we applied the Sufficient Procedure, which has resulted in expressive cost reductions when applied to procedural programs. Indeed, the procedure led to a small set of operators and to a cost reduction of 53% in terms of number of mutants to be handled.", "num_citations": "6\n", "authors": ["2025"]}
{"title": "Testing aspectoriented software: Evolution and collaboration through the years\n", "abstract": " Context: Research on testing aspect-oriented (AO) software has resulted in a variety of approaches derived from traditional testing techniques. However, there is neither a clear map of how they have evolved nor how researchers have collaborated so far. Objectives: To draw a general picture of research on testing AO software, focusing on the evolution of approaches and collaborations among researchers. Method: Our results rely on a systematic literature review that has been continually updated during the last years. Results: We identified a few testing approaches that have shown some evolution along the years. They are products of the largest collaboration groups, despite the lack of integration among groups. Conclusions: Although we noticed relative evolution in AO testing research, it still lacks more intensive collaboration in order to produce consolidated approaches that may become a common practice in AO software development.", "num_citations": "6\n", "authors": ["2025"]}
{"title": "Investigating testing approaches for dynamically adaptive systems\n", "abstract": " Software systems that can automatically adapt to changes in their environments\u2013also know as Dynamically Adaptive Systems (DAS)\u2013play increasingly important roles in society\u2019s everyday life. The growing demand for such systems, which range from simple mobile interactive gaming applications to complex crisis management systems, requires specific development methodologies that encompass the full software life cycle.", "num_citations": "5\n", "authors": ["2025"]}
{"title": "An approach for creating kdm2psm transformation engines in adm context: The rute-k2j case\n", "abstract": " Architecture-Driven Modernization (ADM) is a type of software reenginering that employs standard metamodels along the process and deals with the whole system architecture. The main metamodel is the Knowledge-Discovery Metamodel (KDM), which is language, platform independent and it is able to represent several aspects of a software system. Although there is much research effort in the reverse engineering phase of ADM, little have been published around the forward engineering one; mainly on the generation of Platform-Specific Models (PSM) from KDM. This phase is essential as it belongs to the final part of the horseshoe cycle, completing the reengineering process. However, the lack of research and the absence of tooling support hinders the industrial adoption of ADM. Therefore, in this paper we propose an approach to support engineers in creating Transformation Engines (TE) from KDM to any other\u00a0\u2026", "num_citations": "4\n", "authors": ["2025"]}
{"title": "Fault sTypes of Adaptive and Context-Aware Systems and Their Relationship with Fault-based Testing Approaches\n", "abstract": " The following topics are dealt with: program testing; learning (artificial intelligence); educational courses; computer aided instruction; teaching; computer science education; formal specification; security of data; software engineering; and graphical user interfaces.", "num_citations": "3\n", "authors": ["2025"]}
{"title": "Improving project manager decision with gamification: An experience report\n", "abstract": " Context: Gamification is an emerging subject that has been applied in different areas to bring contributions to different types of activities, including project management activities. Objective: Reporting on an experience of introducing gamification in a real software development company in a peripheral, but relevant for management, software development activity: the timesheet fill. Method: We introduced gamification in software process to motivate team members to fill out their timesheets. The Habitica tool was used to support the gamification. Delays for filling out the timesheets by team members were measured before, within and after the insertion of gamification. Results: We observed a beneficial gamification influence on timesheet fill. Based on historical data and on our measurements, the performance was four times better with gamification when compared with the conventional (ie without gamification) approach\u00a0\u2026", "num_citations": "3\n", "authors": ["2025"]}
{"title": "An evaluation of internal program metrics as predictors of mutation operator score\n", "abstract": " Context: Mutation testing is effective in producing high quality test sets. On the downside, it is expensive due to factors like the large number of mutants and the need for manual analysis tasks. Over time, researchers devised several ways of reducing its costs and achieved noticeable results. However, results are little generalizable due to characteristics of the programs and of the applied mutation operators. Objective: This paper reports on an exploratory study that aimed to evaluate internal program characteristics as predictors of mutation testing scores. Method: By applying a clustering algorithm, the core idea consists in identifying a group R of tested programs that can be used as a baseline for testing a new program u using mutation at reduced cost. The same cost reduction results obtained for R is expected to produce relevant results for u. Results: We experimented our approach with 38 programs used in\u00a0\u2026", "num_citations": "3\n", "authors": ["2025"]}
{"title": "A set of metrics for characterizing simulink model comprehension\n", "abstract": " Simulink is a powerful tool for Embedded Systems, playing a key role in dynamic systems modeling. However, far too little attention has been paid to quality of Simulink models. In addition, no research has been found linking the relationship between model complexity and its impact in the comprehension quality of Simulink models. The aim of this paper is to define a set of metrics to support the characterization of Simulink models and to investigate their relationship with the model comprehension property. For this study, we performed a controlled experiment using two versions of a robotic Simulink model\u2014one of them was constructed through the ad hoc development approach and the other one through the re-engineered development approach. The results of the experiment show that the re-engineered model is more comprehensible than the ad hoc model. In summary, the set of metrics collected from each version of the Simulink model suggests an inverse relationship with the model comprehension, ie, the lower the metrics, the greater the model comprehension.", "num_citations": "3\n", "authors": ["2025"]}
{"title": "Avaliacao do impacto do desenvolvimento distribu\u00eddo de software em um projeto adotando o scrum: Um estudo comparativo\n", "abstract": " Devido ao crescente uso de pr\u00e1ticas do Scrum no contexto do Desenvolvimento Distribu\u00eddo de Software (DDS), muitos problemas surgiram e renderam discuss\u00e3o preliminar pela comunidade de pesquisa. Dada a falta de abordagens que tratam de quest\u00f5es espec\u00edficas neste contexto, \u00e9 necess\u00e1rio relatar experi\u00eancias pr\u00e1ticas capazes de fornecer solu\u00e7\u00f5es para adaptar os processos \u00e1geis em DDS. Assim, este trabalho apresenta uma an\u00e1lise do impacto da DDS em um projeto \u00e1gil de software com base em pr\u00e1ticas do Scrum. A experi\u00eancia foi contrastada com observa\u00e7\u00f5es extra\u00eddas de um projeto anterior, desenvolvido em um contexto semelhante com uma configura\u00e7\u00e3o diferente da equipe.", "num_citations": "3\n", "authors": ["2025"]}
{"title": "Inferring test results for dynamic software product lines\n", "abstract": " Due to the very large number of configurations that can typically be derived from a Dynamic Software Product Line (DSPL), efficient and effective testing of such systems have become a major challenge for software developers. In particular, when a configuration needs to be deployed quickly due to rapid contextual changes (eg, in an unfolding crisis), time constraints hinder the proper testing of such a configuration. In this paper, we propose to reduce the testing required of such DSPLs to a relevant subset of configurations. Whenever a need to adapt to an untested configuration is encountered, our approach determines the most similar tested configuration and reuses its test results to either obtain a coverage measure or infer a confidence degree for the new, untested configuration. We focus on providing these techniques for inference of structural testing results for DSPLs, which is supported by an early prototype\u00a0\u2026", "num_citations": "3\n", "authors": ["2025"]}
{"title": "SiMut: exploring program similarity to support the cost reduction of mutation testing\n", "abstract": " Scientists have created many cost reduction techniques for mutation testing, and most of them reduce cost with minor losses of effectiveness. However, many of these techniques are difficult to generalize, difficult to scale, or both. Published results are usually limited to a modest collection of programs. Therefore, an open question is whether the results of a given cost reduction technique on programs studied in the paper will hold true for other programs. This paper introduces a conceptual framework, named SiMut, to support the cost reduction of mutation testing based on historical data and program similarity. Given a new, untested program u, the central idea is applying to u the same cost reduction strategy applied to a group G of programs that are similar to u and have already been tested with mutation, and check for consistency of results in terms of reduced costs and quality of test sets. SiMut includes activities to\u00a0\u2026", "num_citations": "2\n", "authors": ["2025"]}
{"title": "Times de alto desempenho no contexto das metodologias Scrum e Kanban\n", "abstract": " O conceito e ado\u00e7\u00e3o de times de alto desempenho em empresas de desenvolvimento de software est\u00e1 se tornando cada vez mais comum. As maneiras de se formar e evoluir tais times ainda est\u00e3o em constante evolu\u00e7\u00e3o. Em contrapartida, com o advento das metodologias \u00e1geis a preocupa\u00e7\u00e3o com o processo, com a qualidade do produto e com o bem estar dos integrantes do time tendem a tornar a ado\u00e7\u00e3o mais simplificada. Este artigo relaciona times de alto desempenho com as metodologias \u00e1geis Scrum e Kanban e atrav\u00e9s da aplica\u00e7\u00e3o de uma pesquisa realizada em um aempresa da regi\u00e3o de Campinas/SP chegou-se a conclus\u00e3o que as metodologias \u00e1geis propiciam a forma\u00e7\u00e3o de times de alto desempenho e que tal conceito varia de acordo com o cen\u00e1rio em que o time est\u00e1 inserido.", "num_citations": "2\n", "authors": ["2025"]}
{"title": "Integra\u00e7\u00e3o de frameworks front-end para desenvolvimento de interfaces ricas com JavaServer Faces\n", "abstract": " Com a evolu\u00e7\u00e3o das tecnologias utilizadas para o desenvolvimento de aplica\u00e7\u00f5es web atualmente \u00e9 poss\u00edvel disponibilizar aplica\u00e7\u00f5es cada vez mais robustas, funcionais e interativas, melhorando a experi\u00eancia do usu\u00e1rio. Neste artigo ser\u00e1 apresentada a integra\u00e7\u00e3o de dois frameworks front-end: PrimeFaces e Bootstrap, ambos para o desenvolvimento de interfaces ricas, sobre a especifica\u00e7\u00e3o Java ServerFaces. Ser\u00e3o analisados as vantagens e desvantagens obtidos pela integra\u00e7\u00e3o dos frameworks atrav\u00e9s de um estudo piloto simples de cadastro de carros e um caso de uso de uma aplica\u00e7\u00e3o real, com o intuito de ajudar os desenvolvedores a conhecerem as tecnologias e ferramentas que ajudam a implementar interfaces ricas com produtividade e qualidade, melhorando o desempenho da aplica\u00e7\u00e3o.", "num_citations": "2\n", "authors": ["2025"]}
{"title": "A Atividade de Teste sob a Perspectiva de Qualidade de Software\n", "abstract": " Com o crescente uso do software no dia a dia das pessoas, a exig\u00eancia por um produto confi\u00e1vel e de qualidade \u00e9 cada vez maior. Assim, a necessidade de aplicarem-se atividades de garantia de qualidade de software, como a atividade de teste, \u00e9 cada vez mais evidente para as empresas manterem sua competitividade no mercado. Este artigo comenta o fato de que mesmo aplicando-se teste com suporte de t\u00e9cnicas apropriadas, ainda assim n\u00e3o se pode garantir que o software esteja correto. Este artigo ressalta tamb\u00e9m a import\u00e2ncia da defini\u00e7\u00e3o de um processo de teste que trate essa atividade desde o in\u00edcio do desenvolvimento do software. Al\u00e9m disso, s\u00e3o comentados os modelos de qualidade de processo de teste TMMi e MPT. Br, que s\u00e3o modelos de refer\u00eancia para avalia\u00e7\u00e3o e defini\u00e7\u00e3o de processos de teste que propiciem", "num_citations": "2\n", "authors": ["2025"]}
{"title": "Uma revisao sistem\u00e1tica sobre teste de software orientado a aspectos\n", "abstract": " Aspect-Oriented Programming has brought up several benefits to the software development process. However, as well as other development methodologies, it has also brought up new challenges to the testing activity. This paper describes the results of a systematic review performed aiming at identifying works regarding software testing techniques and criteria applied to aspect-oriented software. The results show that a variety of works have proposed the definition of testing criteria based on traditional testing techniques. Moreover, we could also observe that most of these approaches lack validation. The systematic review will serve as a basis for new research related to aspect-oriented software testing, including the definition and evaluation of testing criteria, automated support tools and empirical studies.Resumo. A Programa\u00e7ao Orientada a Aspectos trouxe benef\u0131cios para o desenvolvimento de software e, como toda nova metodologia de desenvolvimento, novos desafios para a atividade de teste. Neste artigo sao apresentados os resultados de uma revisao sistem\u00e1tica cujo objetivo foi identificar os trabalhos que abordam a aplica\u00e7ao de t\u00e9cnicas e crit\u00e9rios de teste no contexto de software orientado a aspectos. Os resultados mostram que diversos trabalhos t\u00eam enfatizado a defini\u00e7ao de crit\u00e9rios para as t\u00e9cnicas tradicionais de teste. Al\u00e9m disso, pode-se observar que existe pouca valida\u00e7ao dos trabalhos propostos. Os resultados servirao de base para a condu\u00e7ao de novos trabalhos relacionados, incluindo a defini\u00e7ao e avalia\u00e7 ao de crit\u00e9rios de teste, ferramentas de apoio e estudos experimentais.", "num_citations": "2\n", "authors": ["2025"]}
{"title": "Micro-controllers: Promoting Structurally Flexible Controllers in Self-Aware Computing Systems\n", "abstract": " To promote structurally flexible controllers in systems such as self-aware computing systems, this paper proposes the use of micro-controllers. Instead of generic monolithic controllers, like Rainbow, we advocate the use of service-specific micro-controllers which can be based on microservices. Although traditional generic controllers can be configured parametrically according to system needs, their use and reuse are nevertheless restrictive because of the wide range of services expected from the different stages of the feedback control loop. The solution being advocated is to have structurally flexible controllers that can be composed from micro-controllers. Controlling the architectural configuration of these micro-controllers is a meta-controller that is able to conFigure the controller according to the services required for controlling the target system. The feasibility of the proposed approach is demonstrated using the\u00a0\u2026", "num_citations": "1\n", "authors": ["2025"]}
{"title": "Characterizing Architectural Drifts of Adaptive Systems\n", "abstract": " An adaptive system (AS) evaluates its own behavior and changes it when the evaluation indicates that the system is not accomplishing what it is intended to do, or when better functionality or performance is possible. MAPE-K is a reference model that prescribes the adaptation mechanism of ASs by means of high-level abstractions such as Monitors, Analyzers, Planners and Executors and the relationships among them. Since the abstractions and the relationships provided by MAPE-K are generic, other reference models were proposed focusing on providing lower level abstractions to support software engineers in a more suitable way. However, after the analysis of seven representative ASs, we realized the abstractions prescribed by the existing reference models are not properly implemented, thus leading to architectural drifts. Therefore, in this paper we characterized three of these drifts by describing them with a\u00a0\u2026", "num_citations": "1\n", "authors": ["2025"]}
{"title": "Is It Worth Using Gamification on Software Testing Education? An Extended Experience Report in the Context of Undergraduate Students\n", "abstract": " Context: Testing is fundamental in the software development process. Nevertheless, testing education faces the key challenge of ensuring that undergraduate students acquire knowledge and skills they need for their future careers by matching what is taught in the classroom to industry standards. In this context, gamification can be used as an alternative educational approach. It uses game elements in real-world contexts in order to increase people\u2019s motivation and engagement in tasks that require external stimuli, especially in educational contexts. Objective: Reporting on results of an experimental study designed to assess the impact of gamification on software testing education, as well as reporting on the experience of building a supporting gamified platform. Method: We performed a systematic literature mapping aiming at characterizing how gamification has been explored in the software testing context. In\u00a0\u2026", "num_citations": "1\n", "authors": ["2025"]}
{"title": "Estudo da aplica\u00e7\u00e3o de Aspectos da Gest\u00e3o do Conhecimento no Desenvolvimento \u00c1gil de Software\n", "abstract": " O presente artigo relata a integra\u00e7\u00e3o entre a metodologia Scrum e a Gest\u00e3o do Conhecimento (GC). Sendo que tempo e produtividade s\u00e3o fatores cr\u00edticos, prop\u00f5e-se pr\u00e1ticas para estabelecer a GC com m\u00ednima interfer\u00eancia no fluxo de trabalho e a baixo custo. Justifica-se a pesquisa pelo fato de as metodologias \u00e1geis n\u00e3o trabalharem adequadamente o saber nos projetos de software. Os procedimentos", "num_citations": "1\n", "authors": ["2025"]}
{"title": "Multi-level mutation testing of Java and AspectJ programs supported by the ProteumAJv2 tool\n", "abstract": " The application of testing techniques and the associated test selection criteria strongly relies on adequate tooling support. This paper describes the evolution of Proteum/AJ, a tool originally conceived to support the mutation testing of aspectoriented (AO) programs. Proteum/AJ automates the application of AspectJ-specific mutation operators. Its evolution, named Proteum/AJv2, also supports the application of unit mutation operators in both Java (object-oriented) and AspectJ programs through a newly graphical user interface (GUI). We show how the tool architecture and the use of design patterns facilitated the addition of mutation operators as well as the GUI development. We also describe results of a preliminary assessment study that comprised the application of both traditional (unit) and AO-specific mutation operators in a complete mutation testing cycle.", "num_citations": "1\n", "authors": ["2025"]}
{"title": "Is it difficult to test aspect-oriented software? Preliminary empirical evidence based on functional tests\n", "abstract": " Several studies have investigated the impact of particular programming paradigms on testing. However, few studies consider a cross-paradigm context, in which the testability of a program when it migrates from one paradigm to another. In this study we analyse the difficulty to adapt tests designed for object-oriented (OO) systems to equivalent aspect-oriented (AO) implementations and vice versa. Initially, we apply functional testing to groups of OO and AO applications. Fixing one paradigm as a baseline, we then adapt the test sets to make them executable in equivalent implementations in the other paradigm. We collect churn-related metrics to evaluate the effort to reuse the existing test sets. The results support the analysis and conclusions that, overall, favour the OO paradigm.", "num_citations": "1\n", "authors": ["2025"]}
{"title": "Proteum/AJv2: A Mutation based Testing tool for Java and AspectJ Programs\n", "abstract": " This paper describes the Proteum/AJv2 tool, which automates the application of AspectJ-specific mutation operators as well as unit mutation operators to both Java and AspectJ programs. This can be done through a newly created graphical user interface. The paper also describes the mutation process supported by Proteum/AJv2 and how the new interface facilitates the tasks required by mutation testing.", "num_citations": "1\n", "authors": ["2025"]}
{"title": "A comparison study of web development methods\n", "abstract": " The increasing expansion and complexity of Web applications poses new challenges for software developers. As a result, several development methods for this class of application have been proposed in the last years. However, the majority of these methods only support the project stage satisfactorily. We can easily notice some problems related to the form of functional and information aspects are handled in conjunction. Besides, development methods for Web applications give very few attention for the conception, planning, testing and client evaluation stages. This paper presents such problems, presenting a comparison study of Web applications methods based on their main features and supporting mechanisms. Considering the fact that most of the methods have limitations, we present a case study based on a Web portal in order to describe advantages and disadvantages of some selected methods.", "num_citations": "1\n", "authors": ["2025"]}
{"title": "CMMI e SCAMPI: uma vis\u00e3o geral dos modelos de qualidade e de um m\u00e9todo formal para sua avalia\u00e7\u00e3o\n", "abstract": " A qualidade dos produtos de software est\u00e1 fortemente relacionada com a qualidade dos processos utilizados. Uma das formas empregadas para obten\u00e7\u00e3o de maior qualidade tem sido a ado\u00e7\u00e3o de modelos, e posteriormente m\u00e9todos para avalia\u00e7\u00e3o de processos para garantir a adequa\u00e7\u00e3o aos modelos adotados. O CMMI Framework, proposto pelo Software Engineering Institute, define um conjunto de modelos de qualidade de processo, al\u00e9m de um m\u00e9todo para avalia\u00e7\u00e3o de adequa\u00e7\u00e3o a esses modelos e produtos de apoio. Este trabalho tem por objetivo apresentar uma vis\u00e3o geral dos modelos CMMI e do m\u00e9todo SCAMPI para avalia\u00e7\u00e3o de melhoria de processo, ambos definidos no CMMI Framework. S\u00e3o tamb\u00e9m apresentados alguns resultados de aplica\u00e7\u00f5es do CMMI que foram avaliadas com o SCAMPI, nos quais podem ser observados os benef\u00edcios obtidos.", "num_citations": "1\n", "authors": ["2025"]}