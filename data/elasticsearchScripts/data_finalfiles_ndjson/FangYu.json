{"title": "Securing web application code by static analysis and runtime protection\n", "abstract": " Security remains a major roadblock to universal acceptance of the Web for many kinds of transactions, especially since the recent sharp increase in remotely exploitable vulnerabilities have been attributed to Web application bugs. Many verification tools are discovering previously unknown vulnerabilities in legacy C programs, raising hopes that the same success can be achieved with Web applications. In this paper, we describe a sound and holistic approach to ensuring Web application security. Viewing Web application vulnerabilities as a secure information flow problem, we created a lattice-based static analysis algorithm derived from type systems and typestate, and addressed its soundness. During the analysis, sections of code considered vulnerable are instrumented with runtime guards, thus securing Web applications in the absence of user intervention. With sufficient annotations, runtime overhead can be\u00a0\u2026", "num_citations": "842\n", "authors": ["688"]}
{"title": "Stranger: An automata-based string analysis tool for PHP\n", "abstract": " Stranger is an automata-based string analysis tool for finding and eliminating string-related security vulnerabilities in PHP applications. Stranger uses symbolic forward and backward reachability analyses to compute the possible values that the string expressions can take during program execution. Stranger can automatically (1) prove that an application is free from specified attacks or (2) generate vulnerability signatures that characterize all malicious inputs that can be used to generate attacks.", "num_citations": "167\n", "authors": ["688"]}
{"title": "System and method for securing web application code and verifying correctness of software\n", "abstract": " Methods, software tools and systems for analyzing software applications, eg, Web applications, are described. A software application to be analyzed is transformed into an abstract representation which preserves its information flow properties. The abstract interpretation is evaluated to identify vulnerabilities using, for example, type qualifiers to associate security levels with variables and/or functions in the application being analyzed and typestate checking. Runtime guards are inserted into the application to secure identified vulnerabilities.", "num_citations": "116\n", "authors": ["688"]}
{"title": "Symbolic string verification: An automata-based approach\n", "abstract": " We present an automata-based approach for the verification of string operations in PHP programs based on symbolic string analysis. String analysis is a static analysis technique that determines the values that a string expression can take during program execution at a given program point. This information can be used to verify that string values are sanitized properly and to detect programming errors and security vulnerabilities. In our string analysis approach, we encode the set of string values that string variables can take as automata. We implement all string functions using a symbolic automata representation (MBDD representation from the MONA automata package) and leverage efficient manipulations on MBDDs, e.g., determinization and minimization. Particularly, we propose a novel algorithm for language-based replacement. Our replacement function takes three DFAs as arguments and outputs a\u00a0\u2026", "num_citations": "105\n", "authors": ["688"]}
{"title": "Verifying web applications using bounded model checking\n", "abstract": " The authors describe the use of bounded model checking (BMC) for verifying Web application code. Vulnerable sections of code are patched automatically with runtime guards, allowing both verification and assurance to occur without user intervention. Model checking techniques are relatively complex compared to the typestate-based polynomial-time algorithm (TS) we adopted in an earlier paper, but they offer three benefits - they provide counterexamples, more precise models, and sound and complete verification. Compared to conventional model checking techniques, BMC offers a more practical approach to verifying programs containing large numbers of variables, but requires fixed program diameters to be complete. Formalizing Web application vulnerabilities as a secure information flow problem with fixed diameter allows for BMC application without drawback. Using BMC-produced counterexamples, errors\u00a0\u2026", "num_citations": "83\n", "authors": ["688"]}
{"title": "Symbolic string verification: Combining string analysis and size analysis\n", "abstract": " We present an automata-based approach for symbolic verification of systems with unbounded string and integer variables. Particularly, we are interested in automatically discovering the relationships among the string and integer variables. The lengths of the strings in a regular language form a semilinear set. We present a novel construction for length automata that accept the unary or binary representations of the lengths of the strings in a regular language. These length automata can be integrated with an arithmetic automaton that recognizes the valuations of the integer variables at a program point. We propose a static analysis technique that uses these automata in a forward fixpoint computation with widening and is able to catch relationships among the lengths of the string variables and the values of the integer variables. This composite string and integer analysis enables us to verify properties that\u00a0\u2026", "num_citations": "74\n", "authors": ["688"]}
{"title": "Topological pattern discovery and feature extraction for fraudulent financial reporting\n", "abstract": " Fraudulent financial reporting (FFR) involves conscious efforts to mislead others regarding the financial condition of a business. It usually consists of deliberate actions to deceive regulators, investors or the general public that also hinder systematic approaches from effective detection. The challenge comes from distinguishing dichotomous samples that have their major attributes falling in the same distribution. This study pioneers a novel dual GHSOM (Growing Hierarchical Self-Organizing Map) approach to discover the topological patterns of FFR, achieving effective FFR detection and feature extraction. Specifically, the proposed approach uses fraudulent samples and non-fraudulent samples to train a pair of dual GHSOMs under the same training parameters and examines the hypotheses for counterpart relationships among their subgroups taking advantage of unsupervised learning nature and growing\u00a0\u2026", "num_citations": "70\n", "authors": ["688"]}
{"title": "Automata-based symbolic string analysis for vulnerability detection\n", "abstract": " Verifying string manipulating programs is a crucial problem in computer security. String operations are used extensively within web applications to manipulate user input, and their erroneous use is the most common cause of security vulnerabilities in web applications. We present an automata-based approach for symbolic analysis of string manipulating programs. We use deterministic finite automata (DFAs) to represent possible values of string variables. Using forward reachability analysis we compute an over-approximation of all possible values that string variables can take at each program point. Intersecting these with a given attack pattern yields the potential attack strings if the program is vulnerable. Based on the presented techniques, we have implemented Stranger, an automata-based string analysis tool for detecting string-related security vulnerabilities in PHP applications. We evaluated Stranger on\u00a0\u2026", "num_citations": "69\n", "authors": ["688"]}
{"title": "Patching vulnerabilities with sanitization synthesis\n", "abstract": " We present automata-based static string analysis techniques that automatically generate sanitization statements for patching vulnerable web applications. Our approach consists of three phases: Given an attack pattern we first conduct a vulnerability analysis to identify if strings that match the attack pattern can reach the security-sensitive functions. Next, we compute vulnerability signatures that characterize all input strings that can exploit the discovered vulnerability. Given the vulnerability signatures, we then construct sanitization statements that 1) check if a given input matches the vulnerability signature and 2) modify the input in a minimal way so that the modified input does not match the vulnerability signature. Our approach is capable of generating relational vulnerability signatures (and corresponding sanitization statements) for vulnerabilities that are due to more than one input.", "num_citations": "68\n", "authors": ["688"]}
{"title": "Relational string verification using multi-track automata\n", "abstract": " Verification of string manipulation operations is a crucial problem in computer security. In this paper, we present a new relational string verification technique based on multi-track automata. Our approach is capable of verifying properties that depend on relations among string variables. This enables us to prove that vulnerabilities that result from improper string manipulation do not exist in a given program. Our main contributions in this paper can be summarized as follows: (1) We formally characterize the string verification problem as the reachability analysis of string systems and show decidability/undecidability results for several string analysis problems. (2) We develop a sound symbolic analysis technique for string verification that over-approximates the reachable states of a given string system using multi-track automata and summarization. (3) We evaluate the presented techniques with respect to several string\u00a0\u2026", "num_citations": "64\n", "authors": ["688"]}
{"title": "Generating vulnerability signatures for string manipulating programs using automata-based forward and backward symbolic analyses\n", "abstract": " Given a program and an attack pattern (specified as a regular expression), we automatically generate string-based vulnerability signatures, i.e., a characterization that includes all malicious inputs that can be used to generate attacks. We use an automata-based string analysis framework. Using forward reachability analysis we compute an over-approximation of all possible values that string variables can take at each program point. Intersecting these with the attack pattern yields the potential attack strings if the program is vulnerable. Using backward analysis we compute an over-approximation of all possible inputs that can generate those attack strings. In addition to identifying existing vulnerabilities and their causes, these vulnerability signatures can be used to filter out malicious inputs. Our approach extends the prior work on automata-based string analysis by providing a backward symbolic analysis that includes\u00a0\u2026", "num_citations": "51\n", "authors": ["688"]}
{"title": "TCTL inevitability analysis of dense-time systems: From theory to engineering\n", "abstract": " Inevitability properties in branching temporal logics are of the syntax foralldiamphi, where phi is an arbitrary (timed) CTL (computation tree logic) formula. Such inevitability properties in dense-time logics can be analyzed with the greatest fixpoint calculation. We present algorithms to model-check inevitability properties. We discuss a technique for early decision on greatest fixpoint calculation which has shown promising performance against several benchmarks. We have experimented with various issues which may affect the performance of TCTL inevitability analysis. Specifically, our algorithms come with a parameter for the measurement of time-progress. We report the performance of our implementation with regard to various parameter values and with or without the non-Zeno computation requirement in the evaluation of greatest fixpoints. We have also experimented with safe abstraction techniques for model\u00a0\u2026", "num_citations": "46\n", "authors": ["688"]}
{"title": "String Analysis via Automata Manipulation with Logic Circuit Representation\n", "abstract": " Many severe security vulnerabilities in web applications can be attributed to string manipulation mistakes, which can often be avoided through formal string analysis. String analysis tools are indispensable and under active development. Prior string analysis methods are primarily automata-based or satisfiability-based. The two approaches exhibit distinct strengths and weaknesses. Specifically, existing automata-based methods have difficulty in generating counterexamples at system inputs to witness vulnerability, whereas satisfiability-based methods are inadequate to produce filters amenable for firmware or hardware implementation for real-time screening of malicious inputs to a system under protection. In this paper, we propose a new string analysis method based on a scalable logic circuit representation for (nondeterministic) finite automata to support various string and automata manipulation\u00a0\u2026", "num_citations": "33\n", "authors": ["688"]}
{"title": "On spiking neural P systems and partially blind counter machines\n", "abstract": " A k-output spiking neural P system (SNP) with output neurons, O                         1, ..., O                                            k                 , generates a tuple (n                         1, ..., n                                            k                 ) of positive integers if, starting from the initial configuration, there is a sequence of steps such that during the computation, each O                                            i                  generates exactly two spikes a\u00a0a (the times the pair a\u00a0a are generated may be different for different output neurons) and the time interval between the first a and the second a is n                                            i                 . After the output neurons generate their pairs of spikes, the system eventually halts. We give characterizations of sets definable by partially blind multicounter machines in terms of k-output SNPs operating in a sequential mode. Slight variations of the models make them universal.", "num_citations": "31\n", "authors": ["688"]}
{"title": "String abstractions for string verification\n", "abstract": " Verifying string manipulating programs is a crucial problem in computer security. String operations are used extensively within web applications to manipulate user input, and their erroneous use is the most common cause of security vulnerabilities in web applications. Unfortunately, verifying string manipulating programs is an undecidable problem in general and any approximate string analysis technique has an inherent tension between efficiency and precision. In this paper we present a set of sound abstractions for strings and string operations that allow for both efficient and precise verification of string manipulating programs. Particularly, we are able to verify properties that involve implicit relations among string variables. We first describe an abstraction called regular abstraction which enables us to perform string analysis using multi-track automata as a symbolic representation. We then introduce two\u00a0\u2026", "num_citations": "30\n", "authors": ["688"]}
{"title": "String Analysis for Software Verification and Security\n", "abstract": " This book discusses automated string-analysis techniques, focusing particularly on automata-based static string analysis. It covers the following topics: automata-bases string analysis, computing pre and post-conditions of basic string operations using automata, symbolic representation of automata, forward and backward string analysis using symbolic automata representation, constraint-based string analysis, string constraint solvers, relational string analysis, vulnerability detection using string analysis, string abstractions, differential string analysis, and automated sanitization synthesis using string analysis. String manipulation is a crucial part of modern software systems; for example, it is used extensively in input validation and sanitization and in dynamic code and query generation. The goal of string-analysis techniques and this book is to determine the set of values that string expressions can take during program execution. String analysis can be used to solve many problems in modern software systems that relate to string manipulation, such as:(1) Identifying security vulnerabilities by checking if a security sensitive function can receive an input string that contains an exploit;(2) Identifying possible behaviors of a program by identifying possible values for dynamically generated code;(3) Identifying html generation errors by computing the html code generated by web applications;(4) Identifying the set of queries that are sent to back-end database by analyzing the code that generates the SQL queries;(5) Patching input validation and sanitization functions by automatically synthesizing repairs illustrated in this book. Like many other program\u00a0\u2026", "num_citations": "25\n", "authors": ["688"]}
{"title": "Securing KVM-based cloud systems via virtualization introspection\n", "abstract": " Linux Kernel Virtual Machine (KVM) is one of the most commonly deployed hypervisor drivers in the IaaS layer of cloud computing ecosystems. The hypervisor provides a full-virtualization environment that intends to virtualize as much hardware and systems as possible, including CPUs, network interfaces and chipsets. With KVM, heterogeneous operating systems can be installed in Virtual Machines (VMs) in an homogeneous environment. However, it has been shown that various breaches due to software defects may cause damages on such a cloud ecosystem. We propose a new Virtualization Introspection System (VIS) to protect the host as well as VMs running on a KVM-based cloud structure from malicious attacks. VIS detects and intercepts attacks from VMs by collecting their static and dynamic status. We then replay the attacks on VMs and leverage artificial intelligence techniques to derive effective decision\u00a0\u2026", "num_citations": "25\n", "authors": ["688"]}
{"title": "Parameterized model counting for string and numeric constraints\n", "abstract": " Recently, symbolic program analysis techniques have been extended to quantitative analyses using model counting constraint solvers. Given a constraint and a bound, a model counting constraint solver computes the number of solutions for the constraint within the bound. We present a parameterized model counting constraint solver for string and numeric constraints. We first construct a multi-track deterministic finite state automaton that accepts all solutions to the given constraint. We limit the numeric constraints to linear integer arithmetic, and for non-regular string constraints we over-approximate the solution set. Counting the number of accepting paths in the generated automaton solves the model counting problem. Our approach is parameterized in the sense that, we do not assume a finite domain size during automata construction, resulting in a potentially infinite set of solutions, and our model counting\u00a0\u2026", "num_citations": "24\n", "authors": ["688"]}
{"title": "A temporal logic for the interaction of strategies\n", "abstract": " We propose an extension to ATL (alternating-time logic), called BSIL (basic strategy-interaction logic), for the specification of interaction among the strategies of agents in a multi-agent system. BSIL allows for the specifications of one system strategy that can cooperate with several strategies of the environment for different requirements. We argue that such properties are important in practice and rigorously show that such properties are not expressible in ATL                 *, GL (game logic), and AMC (alternating \u03bc-calculus). Specifically, we show that BSIL is more expressive than ATL but incomparable with ATL*, GL, and AMC in expressiveness. We show that a memoryful strategy is necessary for fulfilling a specification in BSIL. We also show that the model-checking problem of BSIL is PSPACE-complete and is of lower complexity than those of ATL*, GL, AMC, and the general strategy logics. This may imply that\u00a0\u2026", "num_citations": "23\n", "authors": ["688"]}
{"title": "Optimal sanitization synthesis for web application vulnerability repair\n", "abstract": " We present a code-and input-sensitive sanitization synthesis approach for repairing string vulnerabilities that are common in web applications. The synthesized sanitization patch modifies the user input in an optimal way while guaranteeing that the repaired web application is not vulnerable. Given a web application, an input pattern and an attack pattern, we use automata-based static string analysis techniques to compute a sanitization signature that characterizes safe input values that obey the given input pattern and are safe with respect to the given attack pattern. Using the sanitization signature, we synthesize an optimal sanitization patch that converts malicious user inputs to benign ones with minimal editing. When the generated patch is added to the web application, it is guaranteed that the repaired web application is no longer vulnerable. We present refinements to previous sanitization synthesis algorithms\u00a0\u2026", "num_citations": "20\n", "authors": ["688"]}
{"title": "Automated size analysis for OCL\n", "abstract": " An essential tool in object oriented modeling is the specification of cardinalities of associations between classes. In Object Constraint Language (OCL) such constraints are expressed as conditions on the sizes of the collections that correspond to associations. In this paper we present tools and techniques for automated verification of size properties of collection types in OCL. We automatically verify invariants related to the sizes of the collections of a class with respect to the pre and post-conditions of the methods of that class. Our approach is based on a size abstraction that abstracts away the contents of the collections, but preserves the constraints on their sizes. We implemented a tool which automates this abstraction by converting OCL expressions on collections to arithmetic expressions on their sizes. Following this translation, we employ an infinite state model checker, called Action Language Verifier (ALV), for\u00a0\u2026", "num_citations": "17\n", "authors": ["688"]}
{"title": "TCTL inevitability analysis of dense-time systems\n", "abstract": " Inevitability properties in branching temporal logics are of the syntax \u2200\u25ca\u03c6, where \u03c6 is an arbitrary (timed) CTL formula. Such inevitability properties in dense-time logics can be analyzed with greatest fixpoint calculation. We present algorithms to model-check inevitability properties both with and without non-Zeno computation requirement. We discuss a technique for early decision on greatest fixpoint calculation. Our algorithms come with a d-parameter for the measurement of time-progress. We have experimented with various issues, which may affect the performance of TCTL inevitability analysis. Specifically, we report the performance of our implementation w.r.t. various d-parameter values and with or without the non-Zeno computation requirement in the evaluation of greatest fixpoints. We have also experimented with safe abstration techniques for model-checking TCTL inevitability properties. Analysis of\u00a0\u2026", "num_citations": "17\n", "authors": ["688"]}
{"title": "Numerical coverage estimation for the symbolic simulation of real-time systems\n", "abstract": " Three numerical coverage metrics for the symbolic simulation of dense-time systems and their estimation methods are presented. Special techniques to derive numerical estimations of dense-time state-spaces have also been developed. Properties of the metrics are also discussed with respect to four criteria. Implementation and experiments are then reported.", "num_citations": "15\n", "authors": ["688"]}
{"title": "Control policy for a subclass of Petri nets without reachability analysis\n", "abstract": " Traditional maximally permissive deadlock prevention control for flexible manufacturing systems requires costly reachability analysis. It has been a hot race to synthesise optimal controllers to be maximally permissive with fewest monitors. Previous work shows that among all  n -dependent siphons, only one siphon (whose unmarked state follows some token distribution) needs to be controlled. This greatly simplifies the supervisor synthesis as well as minimises the number of monitors required while making the controlled net maximally permissive (i.e. all live states can be reached.). This study further proposes a maximally permissive control policy for a subclass of systems of simple sequential processes with resources (S 3 PR) based on the above theory of token distribution pattern of unmarked siphons.", "num_citations": "13\n", "authors": ["688"]}
{"title": "Symbolic consistency checking of OpenMp parallel programs\n", "abstract": " We present a symbolic approach for checking consistency of OpenMP parallel programs. A parallel program is consistent if it yields the same result as its sequential version despite the execution order among threads. We find race conditions of an OpenMP parallel program, construct the formal model of its raced segments under relaxed memory models, and perform guided symbolic simulation to search consistency violations. The simulation terminates when (1) a witness has been found (the program is inconsistent), or (2) all reachable states have been explored (the program is consistent). We have developed the tool Pathg by incorporating Omega library to solve race constraints and Red symbolic simulator to perform guided search. We show that Pathg can prove consistency of programs, identify races that modern OpenMP checkers failed to report, and find inconsistency witnesses effectively against benchmarks\u00a0\u2026", "num_citations": "13\n", "authors": ["688"]}
{"title": "Viso: Characterizing malicious behaviors of virtual machines with unsupervised clustering\n", "abstract": " Cloud computing has become one of the most dominant computation platforms in recent years. Security threats could be one of the major stunning blocks on this evolution road. While system vendors and cloud tenants benefit much from sharing resources in the cloud environment, security breaches can cause more significant damages of the cloud ecosystem than personal computers. Virtualization techniques facilitate the movement of intrusion detection system to cloud-host operating systems with virtual machine management by observing behaviors of virtual machines (VMs). However, a VM-based detection system inherits the semantic gap problem: it is needed the ability to reveal (malicious) behaviors of VMs from observed data. We propose an automatic and systematic analysis framework for charactering malware behaviors using unsupervised clustering. This framework consists of three phases: (1\u00a0\u2026", "num_citations": "11\n", "authors": ["688"]}
{"title": "On spiking neural P systems and partially blind counter machines\n", "abstract": " A k-output spiking neural P system (SNP) with output neurons, , generates a tuple  of positive integers if, starting from the initial configuration, there is a sequence of steps such that during the computation, each O                                            i                  generates exactly two spikes aa (the times the pair aa are generated may be different for different output neurons) and the time interval between the first a and the second a is n                                            i                 . After the output neurons generate their pairs of spikes, the system eventually halts. We give characterizations of sets definable by partially blind multicounter machines in terms of k-output SNPs operating in a sequential mode. Slight variations of the models make them universal.", "num_citations": "11\n", "authors": ["688"]}
{"title": "Network-traffic anomaly detection with incremental majority learning\n", "abstract": " Detecting anomaly behavior in large network traffic data has presented a great challenge in designing effective intrusion detection systems. We propose an adaptive model to learn majority patterns under a dynamic changing environment. We first propose unsupervised learning on data abstraction to extract essential features of samples. We then adopt incremental majority learning with iterative evolutions on fitting envelopes to characterize the majority of samples within moving windows. A network traffic sample is considered an anomaly if its abstract feature falls on the outside of the fitting envelope. We justify the effectiveness of the presented approach against 150000+ traffic samples from the NSL-KDD dataset in training and testing, demonstrating positive promise in detecting network attacks by identifying samples that have abnormal features.", "num_citations": "10\n", "authors": ["688"]}
{"title": "Enumeration of reachable and other states of simple version of Systems of Simple Sequential Processes with Resources (S3PR)\n", "abstract": " This paper reports the very first endeavor toward the computation of the number of reachable states for simple version of Systems of Simple Sequential Processes with Resources (S3PR) without the construction of reachability graph that often makes the analysis intractable. This paper also estimates the number of non-reachable, forbidden, and deadlock states.", "num_citations": "10\n", "authors": ["688"]}
{"title": "Patcher: An Online Service for Detecting, Viewing and Patching Web Application Vulnerabilities\n", "abstract": " Web application security becomes a critical issue as more and more web applications appear and serve common life and business routines in recent years. It is known that web applications are vulnerable due to software defects. Open to public users, vulnerable websites may encounter lots of malicious attacks from the Internet. We present a new web service platform where system developers can detect, view and patch potential vulnerabilities of their web applications online. Taking advantage of static string analysis techniques, our analysis ensures that the patched programs are free from vulnerabilities with respect to given attack patterns. Specifically, we integrate the service front end with program visualization techniques, developing a 3D interface/presentation for users to access and view the analysis result under visualization environment with the aim of improving users' comprehension on programs\u00a0\u2026", "num_citations": "9\n", "authors": ["688"]}
{"title": "String analysis\n", "abstract": " String analysis is a static analysis technique that determines the string values that a variable can hold at specific points in a program. This information is often useful to help program understanding, to detect and fix programming errors and security vulnerabilities, and to solve certain program verification problems. We present a novel approach to perform string analysis on real-world programs.", "num_citations": "9\n", "authors": ["688"]}
{"title": "Bounded model checking for region automata\n", "abstract": " For successful software verification, model checkers must be capable of handling a large number of program variables. Traditional, BDD-based model checking is deficient in this regard, but bounded model checking (BMC) shows some promise. However, unlike traditional model checking, for which time systems have been thoroughly researched, BMC is less capable of modeling timing behavior \u2013 an essential task for verifying many types of software. Here we describe a new bounded model checker we have named xBMC, which we believe solves the reachability problem of dense-time systems. In xBMC, regions and transition relations are represented as Boolean formulae using discrete interpretations. In an experiment using well- developed model checkers to verify Fischer\u2019s protocol, xBMC outperformed both traditional (Kronos [8], Uppaal [16], and Red [26]) and bounded (SAL [21]) model checkers by\u00a0\u2026", "num_citations": "9\n", "authors": ["688"]}
{"title": "An effective distributed ghsom algorithm for unsupervised clustering on big data\n", "abstract": " Clustering techniques that group samples based on their attribute similarity have been widely used in many fields such as pattern recognition, feature extraction and malicious behavior characterization. Due to its importance, various clustering techniques have been developed with distributed frameworks such as K-means with Hadoop in Apache Mahout for scalable computation. While K-means requires the number of clusters and self organizing maps (SOM) requires the map size to be given, the technique of GHSOM (growing hierarchical self organizing maps) that clusters samples dynamically to satisfy the requirement on tolerance of variation between samples, poses an attractive unsupervised learning solution for data that have limited information to decide the number of clusters in advance. However it is not scalable with sequential computation, which limits its applications on big data. In this paper, we present\u00a0\u2026", "num_citations": "8\n", "authors": ["688"]}
{"title": "Efficient exact spare allocation via boolean satisfiability\n", "abstract": " Fabricating large memory and processor arrays is subject to physical failures resulting in yield degradation. The strategy of incorporating spare rows and columns to obtain reasonable production yields was first proposed in the 1970s, and continues to play an important role in recent VLSI developments. The spare allocation problem (SAP) in general is known to be intractable, an efficient exact spare allocation algorithm has great value. We propose a new Boolean encoding of SAP and a new SAT-based exact algorithm SATRepair. We used a realistic fault distribution model to compare SATRepair's performances against those of BDDRepair and several algorithms found in the literature. We found that a) our Boolean encoding of SAP facilitates the development of efficient exact SAP algorithms, and b) our SAT-based algorithm outperforms previous algorithms, especially for large problems.", "num_citations": "8\n", "authors": ["688"]}
{"title": "Content-Sensitive Data Compression for IoT Streaming Services\n", "abstract": " The progression of cheaper, faster and more reliable Internet technologies leads Internet of Things (IoT) to be applied in various fields of life nowadays. While tremendous data are generated and delivered from IOT devices, it is essential on the server side having scalable and effective data compression techniques to balance storage usage and data precision. This paper presents an adjustable content-sensitive data compression approach for IOT video streaming services and applications. Specifically, we adopt frame similarity on different aspects including illumination and structure as a matrix for streaming video frame reduction, and we are able to keep sufficient differences among video frames while reducing a significant amount of storage resources. We setup a general iot application platform in practice and show the effectiveness of the presented approach, keeping 96.5% precision with 40% storage reduction\u00a0\u2026", "num_citations": "7\n", "authors": ["688"]}
{"title": "Appreco: Behavior-aware recommendation for ios mobile applications\n", "abstract": " Mobile applications have been widely used in life and become dominant software applications nowadays. However there are lack of systematic recommendation systems that can be leveraged in advance without users' evaluations. We present AppReco, a systematic recommendation system of iOS mobile applications that can evaluate mobile applications without executions. AppReco evaluates apps that have similar interests with static binary analysis, revealing their behaviors according to the embedded functions in the executable. The analysis consists of three stages: (1) unsupervised learning on app descriptions with Latent Dirichlet Allocation for topic discovery and Growing Hierarchical Self-organizing Maps for hierarchical clustering, (2) static binary analysis on executables to discover embedded system calls and (3) ranking common-topic applications from their matched behavior patterns. To find apps that\u00a0\u2026", "num_citations": "7\n", "authors": ["688"]}
{"title": "Clustering iOS executable using self-organizing maps\n", "abstract": " We pioneer the study on applying both SOMs and GHSOMs to cluster mobile apps based on their behaviors, showing that the SOM family works well for clustering samples with more than ten thousands of attributes. The behaviors of apps are characterized by system method calls that are embedded in their executable, but may not be perceived by users. In the data preprocessing stage, we propose a novel static binary analysis to resolve and count implicit system method calls of iOS executable. Since an app can make thousands of system method calls, it is needed a large dimension of attributes to model their behaviors faithfully. On collecting 115 apps directly downloaded from Apple app store, the analysis result shows that each app sample is represented with 18000+ kinds of methods as their attributes. Theoretically, such a sample representation with more than ten thousand attributes raises a challenge to\u00a0\u2026", "num_citations": "7\n", "authors": ["688"]}
{"title": "Quantitative analysis of cloud-based streaming services\n", "abstract": " As the practitioner uses the Internet and the cloud infrastructure to facilitate online media and entertainment streaming services in large scale, it is urgent to have the quantitative analysis for the service design. The purpose of the quantitative analysis is to facilitate a high-standard service quality of such cloud-based streaming services. Naturally the service level is related to the following factors: the processing ability on the server side, the bandwidth allocated for the customer, the traffic condition of the Internet, and the processing ability of the end device on the client side. However, there is a lack of formal quantitative analysis, nor theoretical exploration, of the relationship between the service quality and these four factors. This study addresses this theoretical gap with a proposed service framework. Its queuing models for the cloud-based streaming services lead to closed form expressions for service quality of system\u00a0\u2026", "num_citations": "7\n", "authors": ["688"]}
{"title": "Quantitative quality estimation of cloud-based streaming services\n", "abstract": " Cloud-based streaming services, such as real-time streaming video and gaming services, have emerged as popular online Internet applications in recent years. Providing systematic quality estimation before (or after) launching these services has raised a significant challenge due to dynamic runtime status of servers, clients and the network environment. This paper proposes a queueing model for the cloud-based streaming service in which packet level dynamics are taken into consideration so that customer-affected performance can be estimated by a hybrid simulation approach. The simulation approach is particularly useful for cloud service providers to evaluate the service quality before launching the service. The analytical model has two parts: (1) the virtual-machine-level service queueing model along with the stationary closed-form expressions on the average number of customers, the average waiting time\u00a0\u2026", "num_citations": "6\n", "authors": ["688"]}
{"title": "Space connection: a new 3D tele-immersion platform for web-based gesture-collaborative games and services\n", "abstract": " The 3D tele-immersion technique has brought a revolutionary change to human interaction-physically apart users can interact naturally with each other through body gesture in a shared 3D virtual environment. The scheme of cloud- or Web-based applications on the other hand facilitates global connections among players without the need to equip with additional devices. To realize Web-based 3D immersion techniques, we propose Space Connection that integrates techniques for virtual collaboration and motion sensing techniques with the aim of pushing motion sensing a step forward to seamless collaboration among multiple users. Space Connection provides not only human-computer interaction but also enables instant human- to-human collaboration with body gestures beyond physical space boundary. Technically, to develop gesture-interactive applications, it requires parsing signals of motion sensing\u00a0\u2026", "num_citations": "6\n", "authors": ["688"]}
{"title": "Resistant learning on the envelope bulk for identifying anomalous patterns\n", "abstract": " Anomalous patterns are observations that lie far away from the fitting function deduced from the bulk of the given observations. This work addresses the research issue to effectively identify anomalous patterns in both contexts of resistant learning, where there is no assumption about the fitting function form, and of changing environments. The resistant learning means that the learning procedure is not impacted significantly by the outlying observations. In literature, there is the resistant learning with searching a near-perfect fitting function for identifying the bulk of the majority of observations. However, the learning algorithm with searching a near-perfect fitting function suffers from time inefficiency. To effectively identify anomalous patterns in both contexts of resistant learning and changing environments, this study proposes a new resistant learning algorithm with envelope module that learns to evolve a nonlinear fitting\u00a0\u2026", "num_citations": "6\n", "authors": ["688"]}
{"title": "Symbolic simulation of real-time concurrent systems\n", "abstract": " We introduce the symbolic simulation function implemented in our model-checker/simulator RED 4.0 for dense-time concurrent systems. By representing and manipulating state-spaces as logic predicates, the technique of symbolic simulation can lead to high performance by encompassing many, even densely many, traces in traditional simulation into one symbolic trace. We discuss how we generate traces with various policies, how we manipulate the state-predicate, and how we manage the trace trees. Finally, we report experiment with our simulator in the verification of the Bluetooth baseband protocol.", "num_citations": "6\n", "authors": ["688"]}
{"title": "OVL assertion-checking of embedded software with dense-time semantics\n", "abstract": " OVL (Open Verification Library) is designed to become a standard assertion language of the EDA (Electronic Design Automation) industry and has been adopted by many companies. With OVL, verification process can blended seamlessly into the development cycles of complex systems. We investigate how to use OVL assertions for the verification of dense-time concurrent systems. We have designed a C-like language, called TC (timed C), for the description of real-time system with OVL assertions between code lines. We explain how to translate TC programs into optimized timed automata, how to translate OVL assertions into TCTL (Timed Computation-Tree Logic) formulae, and how to analyze assertions when not satisfied. The idea is realized in our translator RG (RED Generator).               In addition, we have developed several new verification techniques to take advantage of the information coming with\u00a0\u2026", "num_citations": "6\n", "authors": ["688"]}
{"title": "Malware Family Characterization with Recurrent Neural Network and GHSOM Using System Calls\n", "abstract": " Nowadays, a massive amount of sensitive data which are accessible and connected through personal computers and cloud services attract hackers to develop malicious software (malware) to steal them. Owing to the success of deep learning on image and language recognition, researchers direct security systems to analyze and identify malware with deep learning approaches. This paper addresses the problem of analyzing and identifying complex and unstructured malware behaviors by proposing a framework of combining unsupervised and supervised learning algorithms with a novel sequence-aware encoding method. Particularly, a hybrid GHSOM (the Growing Hierarchical Self-Organizing Map) algorithm is proposed to cluster and encode similar malware behavior sequences from system call sequences to clustering feature vectors. Then, a Recurrent Neural Network (RNN) is trained to detect malware and\u00a0\u2026", "num_citations": "5\n", "authors": ["688"]}
{"title": "A symbolic model checking approach to the analysis of string and length constraints\n", "abstract": " Strings with length constraints are prominent in software security analysis. Recent endeavors have made significant progress in developing constraint solvers for strings and integers. Most prior methods are based on deduction with inference rules or analysis using automata. The former may be inefficient when the constraints involve complex string manipulations such as language replacement; the latter may not be easily extended to handle length constraints and may be inadequate for counterexample generation due to approximation. Inspired by recent work on string analysis with logic circuit representation, we propose a new method for solving string with length constraints by an implicit representation of automata with length encoding. The length-encoded automata are of infinite states and can represent languages beyond regular expressions. By converting string and length constraints into a dependency graph\u00a0\u2026", "num_citations": "5\n", "authors": ["688"]}
{"title": "Appbeach: Characterizing app behaviors via static binary analysis\n", "abstract": " We present AppBeach, an automatic static analysis tool to reveal behaviors of mobile applications (apps) that may (or may not) appear to users but embedded in the executable. We characterize app behaviors based on system method calls and their counts. Our analysis consists of two phases. We first propose a distributed static binary analysis for counting system method calls of iOS executable with the Hadoop framework. We then collect the differences of calls of normal and malicious apps as patterns of malicious behaviors, and reveal potential malicious behaviors that are embedded in apps using these patterns. We evaluate AppBeach against hundreds of public online apps and successfully reveal various behaviors that are embedded in their executables.", "num_citations": "5\n", "authors": ["688"]}
{"title": "Number of reachable states for simple classes of Petri nets\n", "abstract": " The problem of computing the number of reachable states of arbitrary Petri nets without building reachability graphs has never been investigated before. This paper deals with a simple class of Petri nets, called marked graphs. We express and find the number of reachable states of a marked graph in an algebraic way, which is the first result of this problem as far as we know.", "num_citations": "5\n", "authors": ["688"]}
{"title": "A novel liveness condition for S3PGR2\n", "abstract": " Systems of simple sequential processes with resources (S3PR), modeled by ordinary Petri nets (OPNs) are live if and only if no siphons (a set of places) can ever become empty of tokens. Systems of simple sequential processes with general resources requirement (S3PGR2), modeled by general Petri nets (GPNs), are a generalization of S3PR. It has been a hot research topic to find the sufficient and necessary condition of liveness for S3PGR2. When an OPN (respectively, GPN) is deadlocked, the set of all unmarked (respectively, non-max-marked) places forms a siphon, which is said to be deadly marked. However, when an S3PGR2 is livelocked but not deadlocked, e.g., both live and dead transitions exist, the set of non-max-marked places, denoted by , may not form a siphon. Thus, it is limited using deadly marked or max-controlled siphons to characterize liveness of S3PGR2. The first author proposed earlier max\u00a0\u2026", "num_citations": "4\n", "authors": ["688"]}
{"title": "Automatic verification of string manipulating programs\n", "abstract": " In this dissertation, we investigate the string verification problem: Given a program that manipulates strings, we want to verify assertions about string variables. We formalize the string verification problem as reachability analysis of string systems and demonstrate that the string analysis problem is undecidable in general. We present sound automata-based symbolic string analysis techniques for automatic verification of string manipulating programs. String analysis is a static analysis technique that determines the values that a string expression can take during program execution at a given program point. This information can be used to detect security vulnerabilities and program errors, and to verify that program inputs are sanitized properly.", "num_citations": "4\n", "authors": ["688"]}
{"title": "Sat-based model checking for region automata\n", "abstract": " We propose a new SAT-based model checking algorithm to solve the reachability problem of real-time systems. In our algorithm, the behavior of region automata is encoded as Boolean formulas, and hence any SAT solver can be used to explore the region graph efficiently. Although our SAT-based algorithm performs better than other algorithms in flaw detection, it is less effective in proving properties. To overcome the problem, we incorporate a complete inductive method in our algorithm to improve the performance when the property is satisfied. We implement both algorithms in a tool called xBMC and report experimental results. The experiments show that the combination of efficient encoding and inductive methods offers an effective and practical method for the analysis of timing behavior.", "num_citations": "4\n", "authors": ["688"]}
{"title": "Toward unbounded model checking for region automata\n", "abstract": " The large number of program variables in a software verification model often makes model checkers ineffective. Since the performance of BDD\u2019s is very sensitive to the number of variables, BDD-based model checking is deficient in this regard. SAT-based model checking shows some promise because the performance of SAT-solvers is less dependent on the number of variables. As a result, SAT-based techniques often outperform BDD-based techniques in discrete systems with a lot of variables. Timed systems, however, have not been as thoroughly investigated as discrete systems. The performance of SAT-based model checking in analyzing timing behavior \u2013 an essential task for verifying real-time systems \u2013 is not so clear. Moreover, although SAT-based model checking may be useful in bug hunting, their capability in proving properties has often been criticized. To address these issues, we propose a\u00a0\u2026", "num_citations": "4\n", "authors": ["688"]}
{"title": "Tracking Supply Chain Process Variability with Unsupervised Cluster Traversal\n", "abstract": " Supply chain processes need stability and predictability for the supply to better match demand at the right time with the right quantity. Reaching stable operations under uncertainty, however, is challenging as fluctuating demand patterns in the downstream are so common and make inventory control at the upstream a daunting task. Working with one of the leading semiconductor distributors in the world, who piles up stock that hampers profitability for the sake of satisfying lumpy/erratic demand in the downstream production plants, we help the distributor track process variability in its operations. Specifically, we integrate unsupervised clustering with the recurrent neural network for tracking supply chain process variability without pre-assumptions on demand patterns. We first apply unsupervised learning techniques to characterize weekly process performance of a wide variety of electronic items, where item-week pairs\u00a0\u2026", "num_citations": "3\n", "authors": ["688"]}
{"title": "Simulating time-varying demand services with queuing models\n", "abstract": " Resource provision for services that have time-varying demands has raised a great concern to service providers aiming at high-standard service quality. We propose a new resource provision approach using service simulation and arrival rate estimation that integrates unsupervised clustering and statistics techniques. We first cluster days that have similar arrival patterns together, where from each cluster we can reveal and separate days having different reasons for time-varying demands of the service. We then adopt the two layer business factor model to estimate multi-interval Poisson arrival distributions on daily bases for simulating stochastic processes. Applying simulation on queuing models with multi-interval Poisson arrival processes, we can observe stochastic changes of customer waiting time, queuing lengths and number of workers under different service strategies. We conduct a case study on an\u00a0\u2026", "num_citations": "3\n", "authors": ["688"]}
{"title": "Modular verification of synchronization with reentrant locks\n", "abstract": " We present a modular approach for verification of synchronization behavior in concurrent programs that use reentrant locks. Our approach decouples the verification of the lock implementation from the verification of the threads that use the lock. This decoupling is achieved using lock interfaces that characterize the allowable execution order for the lock operations. We use a thread modular verification approach to check that each thread obeys the lock interface. We verify the lock implementation assuming that the threads behave according to the lock interface. We demonstrate that this approach can be used to verify synchronization behavior in Java programs that use reentrant lock implementations for synchronization.", "num_citations": "3\n", "authors": ["688"]}
{"title": "AppBeach: A Static Behavior Checker for iOS Mobile Applications\n", "abstract": " AppBeach standing on App Behavior Checker is a new service to reconstruct and report behaviors of iOS mobile applications, using static binary analysis to reveal embedded functions within the executables. AppBeach adopts a distributed algorithm on call sequence counting via the hadoop framework, achieving a scalable static syntax analysis on executables of modern apps. The main idea is syntactically counting call sequences that are embedded in iOS executable. This is done by distributing routines to mappers with the assembly tool that resolves explicit and implicit system method calls that are embedded in the iOS executables. The reducer then collects the counting from mappers to characterize the behaviors of apps. We learn patterns of malicious behaviors from the difference of pairs of normal and malicious apps, and report the probability of potential behaviors of commercial apps by matching these patterns to their call sequence counts.", "num_citations": "2\n", "authors": ["688"]}
{"title": "Symbolic simulation of industrial real-time and embedded systems-experiments with the bluetooth baseband communication protocol\n", "abstract": " We introduce the symbolic simulation function implemented in our model-checker/simulator RED 4.0 for dense-time concurrent systems. By representing and manipulating state-spaces as logic predicates, the technique of symbolic simulation can lead to high performance by encoding even a dense amount of traces in traditional simulation into one symbolic trace. Symbolic simulation adds the dimension of width to a trace of state-spaces. By controlling the width of traces, we have a much better chance to find bugs using fewer traces.", "num_citations": "2\n", "authors": ["688"]}
{"title": "Gnafuy: a framework for ubiquitous mobile computation\n", "abstract": " Along with the clipping evolution of technology, the bud of smartphone has germinated and sprang up in this decade. The increasing popularity and the improving computation and communication power of smart mobile devices facilitates shared economics of ubiquitous mobile computation. We present the design and implementation of Gnafuy, a framework utilizing crowd-smartphones to fulfill ubiquitous distributed computation, offering a novel crowd-based computation service platform and programmable APIs for developers to take leverage of the spare capacity of smartphones among the world. We discuss programming models of parallel computation, detail how tasks can be deployed on massive smartphones via mobile applications, and propose a server side mechanism to increase the probability of successful delivery and detect the corrupt results from the viciously slaves. The demonstration on google\u00a0\u2026", "num_citations": "1\n", "authors": ["688"]}
{"title": "A control policy for \u03b3-nets without reachability analysis and siphon enumeration\n", "abstract": " Synthesizing maximally permissive controllers with fewest monitors has been a popular research topic. Current optimal controllers for large flexible manufacturing systems (FMS) require costly time consuming reachability analysis. Our previous work shows that among all n-dependent siphons, only one siphon (whose unmarked state follows specific token distribution) needs to be controlled. This greatly simplifies the synthesis as well as minimizes the number of monitors required while making the controlled net nearly maximally permissive. However, some live states may get lost. To reach more live states, the controller regions must be refined to be less affected or disturbed by the monitors and their controlled arcs. We observe that the markings of all the resulting controller regions follow a simple pattern. Based on this pattern of unmarked siphons, this paper further proposes a maximally permissive control policy for\u00a0\u2026", "num_citations": "1\n", "authors": ["688"]}
{"title": "Verification of string manipulating programs using multi-track automata\n", "abstract": " Verification of string manipulation operations is a crucial problem in computer security. We present a new symbolic string verification technique that can be used to prove that vulnerabilities that result from improper string manipulation do not exist in a given program. We formally characterize the string verification problem as the reachability analysis of string systems, programs that contain only string variables and allow a limited set of operations on them. We show that string analysis problem is undecidable with even three variables if branch conditions that compare different variables are allowed. We develop a sound symbolic analysis technique for string verification that over-approximates the reachable states of the string system. We represent the set of string values that string variables can take using multi-track deterministic finite automata and implement a forward fixpoint computation using an automata based widening operation. In order to handle branch conditions in string systems, we describe the precise construction of multi-track DFAs for linear word equations, such as c1X1c2= c\u2032 1X2c\u2032 2, as well as Boolean combinations of these equations. We show that non-linear word equations (even the simple one X1= X2X3) cannot be characterized precisely as a multi-track DFA. We propose a regular approximation for non-linear equations, such as X1... Xi= X1'... Xi', as well as Boolean combinations of these equations. We present a summarization technique for inter-procedural analysis that generates a transducer characterizing the relationship between the input parameters and the return values of each procedure. We implemented these\u00a0\u2026", "num_citations": "1\n", "authors": ["688"]}
{"title": "Power Analysis of Interrupt-Driven and Multi-Threaded Programs\n", "abstract": " We aim to combine software verification techniques to achieve static power analysis for interrupt-driven and multi-threaded programs, which are used in many networked embedded systems. The goal is achieved by 1) control flow analysis, 2) instruction-level power estimation/emulation, 3) thread-context model, and 4) counter-example guided refinement.", "num_citations": "1\n", "authors": ["688"]}