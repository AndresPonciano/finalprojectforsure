{"title": "On the synchronization bottleneck of OpenStack Swift-like cloud storage systems\n", "abstract": " As one type of the most popular cloud storage services, OpenStack Swift and its follow-up systems replicate each data object across multiple storage nodes and leverage object sync protocols to achieve high availability and eventual consistency. The performance of object sync protocols heavily relies on two key parameters: r (number of replicas for each object) and \u03b7 (number of objects hosted by each storage node). In existing tutorials and demos, the configurations are usually r = 3 and n <; 1000 by default, and the object sync process seems to perform well. To deep understand object sync protocols, we first make a lab-scale OpenStack Swift deployment and run experiments with various configurations. We discover that in data-intensive scenarios, e.g., when r > 3 and n \u226b 1000, the object sync process is significantly delayed and produces massive network overhead. This phenomenon is referred to as the sync\u00a0\u2026", "num_citations": "29\n", "authors": ["2032"]}
{"title": "On the synchronization bottleneck of OpenStack swift-like cloud storage systems\n", "abstract": " As one type of the most popular cloud storage services, OpenStack Swift and its follow-up systems replicate each object across multiple storage nodes and leverage object sync protocols to achieve high reliability and eventual consistency. The performance of object sync protocols heavily relies on two key parameters: r (number of replicas for each object) and n (number of objects hosted by each storage node). In existing tutorials and demos, the configurations are usually r = 3 and n <; 1;000 by default, and the sync process seems to perform well. However, we discover in data-intensive scenarios, e.g., when r > 3 and n <; 1;000, the sync process is significantly delayed and produces massive network overhead, referred to as the sync bottleneck problem. By reviewing the source code of OpenStack Swift, we find that its object sync protocol utilizes a fairly simple and network-intensive approach to check the\u00a0\u2026", "num_citations": "3\n", "authors": ["2032"]}
{"title": "Automated and Scalable Mutation Testing\n", "abstract": " Symbolic execution and mutation testing have been demonstrated to be effective in revealing program defects. Despite their potential, their application cost, scalability and robust operation are obstacles to their practical use. Symbolic execution has the problem of path explosion, which results from the vast number of program paths, while mutation testing involves a large number of program variants to be analysed and executed. Both these problems result in scalability issues when applied in real world programs. These problems are to by addressed by the present research. The key point to be addressed is the design of few but effective mutations. These will be selected based on symbolic execution. The present research will 1) evaluate the level of con?dence or the guarantees that can be established by mutation testing, 2) design a technique to effectively detect useful mutants, 3) automate the whole mutation\u00a0\u2026", "num_citations": "2\n", "authors": ["2032"]}