{"title": "Execution trace abstraction based on meta patterns usage\n", "abstract": " Visualizing object interactions in an execution trace with a sequence diagram is a promising technique for helping developers to comprehend effectively the behavior of an object-oriented system. However, in most cases, the reverse-engineered sequence diagram, which is automatically generated from an execution trace, contains enormous amounts of information, which causes scalability issues. In this paper, we present a method that abstracts the history of object interactions based on Pree's meta patterns usage. We identify objects that are strongly related to each other by focusing on the relation of template-hook structures which are often used in object-oriented programming. Grouping the strongly correlated objects, we visualize the system's behavior in terms of intergroup interactions with a sequence diagram. The sequence diagram that is generated is helpful for grasping the big picture of the overall behavior\u00a0\u2026", "num_citations": "22\n", "authors": ["2178"]}
{"title": "Sequence diagram slicing\n", "abstract": " Software visualization with sequence diagrams is one of the promising techniques aimed at helping developers comprehend the behavior of object-oriented systems effectively. However, it is still difficult to understand this behavior, because the size of automatically generated sequence diagrams tends to be beyond the developer's capacity. In this paper, we propose a sequence diagram slicing method, which is an extension of our previous method based on a dynamic slicing technique using static information. Our proposed method is capable of accurate slice calculation based on high-precision data dependency and can support various programs, including exceptions and multithreading. In addition, our proposed new tool performs slice calculations on the Eclipse platform and we demonstrate the applicability of this method by applying the tool to two Java programs as case studies. The results confirm the\u00a0\u2026", "num_citations": "17\n", "authors": ["2178"]}
{"title": "Reticella: an execution trace slicing and visualization tool based on a behavior model\n", "abstract": " Program comprehension using dynamic information is one of key tasks of software maintenance. Software visualization with sequence diagrams is a promising technique to help developer comprehend the behavior of object-oriented systems effectively. There are many tools that can support automatic generation of a sequence diagram from execution traces. However it is still difficult to understand the behavior because the size of automatically generated sequence diagrams from the massive amounts of execution traces tends to be beyond developer\u2019s capacity. In this paper, we propose an execution trace slicing and visualization method. Our proposed method is capable of slice calculation based on a behavior model which can treat dependencies based on static and dynamic analysis and supports for various programs including exceptions and multi-threading. We also introduce our tool that perform our proposed slice calculation on the Eclipse platform. We show the applicability of our proposed method by applying the tool to two Java programs as case studies. As a result, we confirm effectiveness of our proposed method for understanding the behavior of object-oriented systems.", "num_citations": "11\n", "authors": ["2178"]}
{"title": "SDExplorer: a generic toolkit for smoothly exploring massive-scale sequence diagram\n", "abstract": " To understand program's behavior, using reverse-engineered sequence diagram is a valuable technique. In practice, researchers usually record execution traces and generate a sequence diagram according to them. However, the diagram can be too large to read while treating real-world software due to the massiveness of execution traces. Several studies on minimizing/compressing sequence diagrams have been proposed; however, the resulting diagram may be either still large or losing important information. Besides, existing tools are highly customized for a certain research purpose. To address these problems, we present a generic toolkit SDExplorer in this paper, which is a flexible and lightweight tool to effectively explore a massive-scale sequence diagram in a highly scalable manner. Additionally, SDExplorer supports popular features of existing tools (i.e. search, filter, grouping, etc.). We believe it is an\u00a0\u2026", "num_citations": "8\n", "authors": ["2178"]}
{"title": "Identifying core objects for trace summarization using reference relations and access analysis\n", "abstract": " Behaviors of an object-oriented system can be visualized as reverse-engineered sequence diagrams from execution traces. This approach is a valuable tool for program comprehension tasks. However, owing to the massiveness of information contained in an execution trace, a reverse-engineered sequence diagram is often afflicted by a scalability issue. To address this issue, we present in this paper a method for identifying core objects for trace summarization by reference relations and access analysis. We detect and eliminate temporary objects that are trivial for a system, and then estimate the importance of non-trivial objects. By grouping objects with a focus on highly important ones (i.e., core objects), we visualize the system's behavior in terms of intergroup interactions. Consequently, we obtain a readable size of a reverse-engineered sequence diagram containing the system's key behavior. We implemented\u00a0\u2026", "num_citations": "8\n", "authors": ["2178"]}
{"title": "Identifying Core Objects for Trace Summarization by Analyzing Reference Relations and Dynamic Properties\n", "abstract": " Behaviors of an object-oriented system can be visualized as reverse-engineered sequence diagrams from execution traces. This approach is a valuable tool for program comprehension tasks. However, owing to the massiveness of information contained in an execution trace, a reverse-engineered sequence diagram is often afflicted by a scalability issue. To address this issue, many trace summarization techniques have been proposed. Most of the previous techniques focused on reducing the vertical size of the diagram. To cope with the scalability issue, decreasing the horizontal size of the diagram is also very important. Nonetheless, few studies have addressed this point; thus, there is a lot of needs for further development of horizontal summarization techniques. We present in this paper a method for identifying core objects for trace summarization by analyzing reference relations and dynamic properties\u00a0\u2026", "num_citations": "4\n", "authors": ["2178"]}
{"title": "Constructing Object Groups Corresponding to Concepts for Recovery of a Summarized Sequence Diagram\n", "abstract": " Comprehending the behavior of an object-oriented system solely from its source code is troublesome owing to its dynamism. To aid comprehension, visualizing program behavior through reverse-engineered sequence diagrams from execution traces is a promising approach. However, because of the massiveness of traces, recovered diagrams tend to become very large causing scalability issues. To address these issues, we propose an object grouping technique that horizontally summarizes a reverse-engineered sequence diagram. Our technique constructs object groups based on Pree\u2019s meta patterns in which each group corresponds to a concept in the domain of a subject system. By visualizing interactions only among important groups, we generate a summarized sequence diagram depicting a behavioral overview of the system. Our experiment showed that our technique outperformed the state-of-the-art trace summarization technique in terms of reducing the horizontal size of reverse-engineered sequence diagrams. Regarding the quality of object grouping, our technique achieved an F-score of 0.670 and a Recall of 0.793 on average under the condition of# lifelines (ie, the horizontal size of a sequence diagram)< 30, whereas those of the state-of-the-art technique were 0.421 and 0.670, respectively. The runtime overhead imposed by our technique was 129.2% on average, which is relatively smaller than other figures found in the reference literature.", "num_citations": "2\n", "authors": ["2178"]}
{"title": "Generating an Interactive View of Dynamic Aspects of API Usage Examples\n", "abstract": " We develop a tool to generate an interactive API document that includes static and dynamic aspects of code examples. Our technique can help developers interactively eliminate redundant information in the sample code on the documents. The developers can then focus on the part of the sample code they are interested in through our generated document.", "num_citations": "2\n", "authors": ["2178"]}
{"title": "\u7b2c 16 \u56de\u30a2\u30b8\u30a2\u592a\u5e73\u6d0b\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u5de5\u5b66\u56fd\u969b\u4f1a\u8b70 (APSEC 2009) \u53c2\u52a0\u5831\u544a\n", "abstract": " \u8ad6\u6587\u6284\u93322009 \u5e74 12 \u6708 1-3 \u65e5\u306b\u30de\u30ec\u30fc\u30b7\u30a2\u30fb\u30da\u30ca\u30f3\u306b\u3066\u958b\u50ac\u3055\u308c\u305f\u7b2c 16 \u56de\u30a2\u30b8\u30a2\u592a\u5e73\u6d0b\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u5de5\u5b66\u56fd\u969b\u4f1a\u8b70 (APSEC 2009) \u306b\u95a2\u3057\u3066, \u6211\u3005\u306e\u898b\u89e3\u3092\u8ff0\u3079\u308b.", "num_citations": "2\n", "authors": ["2178"]}
{"title": "\u30ea\u30d0\u30fc\u30b9\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0\u306b\u3088\u308b\u5b9f\u7528\u7684\u306a\u8a2d\u8a08\u60c5\u5831\u5fa9\u5143\u306b\u5411\u3051\u3066\n", "abstract": " \u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304c\u4e0d\u5341\u5206\u306a\u30ec\u30ac\u30b7\u30fc\u30b7\u30b9\u30c6\u30e0\u306b\u5bfe\u3057, \u30ea\u30d0\u30fc\u30b9\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0\u306b\u3088\u308a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u69cb\u9020\u30fb\u632f\u308b\u821e\u3044\u3092\u5fa9\u5143\u3059\u308b\u624b\u6cd5\u304c\u591a\u304f\u7814\u7a76\u3055\u308c\u3066\u3044\u308b. \u30ec\u30ac\u30b7\u30fc\u30b7\u30b9\u30c6\u30e0\u7406\u89e3\u306b\u5f79\u7acb\u3064\u8fd1\u5e74\u306e\u6709\u529b\u306a\u7814\u7a76\u3092\u7d39\u4ecb\u3057, \u5b9f\u7528\u306b\u969b\u3057\u3066\u306e\u8ab2\u984c\u3092\u63d0\u8d77\u30fb\u8b70\u8ad6\u3059\u308b.", "num_citations": "1\n", "authors": ["2178"]}