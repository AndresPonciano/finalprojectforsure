{"title": "A field experiment on gamification of code quality in agile development\n", "abstract": " Internal quality of software reduces development costs in the long run but is often neglected by developers. CollabReview, a web-based reputation system for improving the quality of collaboratively written source code, was introduced into an agile development team. The goal was to improve the quality of developed source code as evidenced by the amount of code entities furnished with Javadoc comments. A money prize as an extrinsic reward and peer-pressure in form of a published ranking table were tied to reputation scores. We report on the conduction of a field experiment, our observations and experiences, and relate the results to answers from concluding interviews. Although the gamification had less effect than we had hoped, our experiment teaches valuable lessons about social effects and informs the future design of similar systems.", "num_citations": "16\n", "authors": ["961"]}
{"title": "Locating the Meaning of Terms in Source Code Research on Term Introduction\n", "abstract": " Software developers are often facing the challenge of understanding a large code base. Program comprehension is not only achieved by looking at object interactions, but also by considering the meaning of the identifiers and the contained terms. Ideally, the source code should exemplify this meaning. We propose to call the source code locations that define the meaning of a term term introduction. We further derive a heuristic to determine the introduction location with the help of an explorative study. This study was performed on 8000 manually evaluated samples gained from 30 open source projects. To support reproducibility, all samples and classifications are also available online. The achieved results show a precision of 75% for the heuristic.", "num_citations": "11\n", "authors": ["961"]}
{"title": "Identifying Knowledge Divergence by Vocabulary Monitoring in Software Projects\n", "abstract": " During the development of a project, words used in source code add up to a big vocabulary, which may lead to a divergent word-understanding and word-knowledge between developers. Even the drop out of a single developer may lead to a big loss of knowledge about words and their meaning. By keeping track of the active developers vocabulary one is able to identify and react upon such situations, e.g., by applying pair programming to spread the knowledge around the team. In this work we propose a way to identify such situations by analysing the words contained in identifiers obtained through the commit history in a version control system. Initial empirical results are presented and analysed.", "num_citations": "5\n", "authors": ["961"]}
{"title": "Naming Consistency in Source Code Identifiers\n", "abstract": " The purpose of this thesis is to improve program comprehension through naming consistencies. The main idea is to locate descriptions (origins) for terms in the source code itself. This concept is named term introduction. Further this allows to formulate consistency demands on identifiers, eg information hiding for identifiers. Additionally this allows the location of possible homonym usages for a term, which has not been possible before. Thus the focus lies on exploring term introductions, mainly deriving heuristics to approximate the general idea. For this purpose, at first simple heuristics with reasonable rules are proposed and afterwards validated and fine tuned on a big set of collected open source projects. During evaluation improvements in the heuristics were possible and a single heuristic could be derived in the end. Still this heuristic only represents a single developer model, the model gained from the author of this thesis. Different developers have different experience and viewpoints, thus they could also have different introduction heuristics. Therefore further research is required on finding a good approximation of the collective term introduction idea. v", "num_citations": "2\n", "authors": ["961"]}
{"title": "Consistent Consideration of Naming Consistency\n", "abstract": " Naming is essential for code quality and code comprehension. Essentially names are the glue, that helps programmers to associate program elements with the concepts in mind. Program elements, representing real entities, should be named after those (eg FlightSchedule, ParkingTicket, AnnualNetProfit). For program structures, that arise for technical reasons, names are chosen according to corresponding structures in reality (eg Observer, Factory1). Therefore programmers are shaping code and names to fit their concepts. Although the practical relevance of good naming is obvious, it is hard to create a theory of it. We can\u2019t compare the code directly with the concepts, as we don\u2019t have direct access to the developer\u2019s mind. As a substitute we analyse the lexical structure of the names in the code. Based on this, we create hypotheses about the underlying conceptual structure.", "num_citations": "2\n", "authors": ["961"]}
{"title": "Kanban im Universit\u00e4tspraktikum Ein Erfahrungsbericht\n", "abstract": " Agile Softwareentwicklung praxisnah und erlebbar zu lehren ist eine Herausforderung, die einen deutlichen Einsatz von Zeit und Personal erfordert. Wir hatten die M\u00f6glichkeit, viele gute Erfahrungen in unserer Lehre sammeln zu k\u00f6nnen. Allerdings hatten wir immer noch einige Schwierigkeiten den Studenten bestimmte Probleme w\u00e4hrend der Entwicklung bewusst und sichtbar zu machen. In dieser Arbeit berichten wir von unseren Erfahrung mit der Anwendung des Kanban-Entwicklungsprozesses in einem agilen Blockpraktikum an der Universit\u00e4t Bonn. Tats\u00e4chlich hat dieser einige dieser Schwierigkeiten deutlicher sichtbar machen k\u00f6nnen. Basierend auf unseren Erfolgen, bew\u00e4ltigten Herausforderungen und neu beobachteten Schwierigkeiten geben wir abschlie\u00dfend Empfehlungen f\u00fcr andere Lehrende.", "num_citations": "1\n", "authors": ["961"]}
{"title": "Code Museums as Functional Tests for Static Analyses\n", "abstract": " Growing your software guided by tests [2] has the benefit of thoroughly tested implementations of the right functionality. If you are developing static analyses your \u201ctest data\u201d consist of code that has a few lines to a few classes. How can tests based on this \u201cdata\u201d be kept expressive and maintainable? After exploring a variety of different other approaches we decided to embed the expectations into the data instead of embedding the data into test cases. Figure 1 presents an overview of our tool set. The functional tests are within Java code, the tested static analyses are implemented as logic programs. 1", "num_citations": "1\n", "authors": ["961"]}