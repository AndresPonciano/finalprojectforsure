{"title": "An efficient cryptographic protocol verifier based on prolog rules.\n", "abstract": " We present a new automatic cryptographic protocol verifier based on a simple representation of the protocol by Prolog rules, and on a new efficient algorithm that determines whether a fact can be proved from these rules or not. This verifier proves secrecy properties of the protocols. Thanks to its use of unification, it avoids the problem of the state space explosion. Another advantage is that we do not need to limit the number of runs of the protocol to analyze it. We have proved the correctness of our algorithm, and have implemented it. The experimental results show that many examples of protocols of the literature, including Skeme [24], can be analyzed by our tool with very small resources: the analysis takes from less than 0.1 s for simple protocols to 23 s for the main mode of Skeme. It uses less than 2 Mb of memory in our tests.", "num_citations": "1330\n", "authors": ["276"]}
{"title": "A computationally sound mechanized prover for security protocols\n", "abstract": " We present a new mechanized prover for secrecy properties of security protocols. In contrast to most previous provers, our tool does not rely on the Dolev-Yao model, but on the computational model. It produces proofs presented as sequences of games; these games are formalized in a probabilistic polynomial-time process calculus. Our tool provides a generic method for specifying security properties of the cryptographic primitives, which can handle shared-key and public-key encryption, signatures, message authentication codes, and hash functions. Our tool produces proofs valid for a number of sessions polynomial in the security parameter, in the presence of an active adversary. We have implemented our tool and tested it on a number of examples of protocols from the literature.", "num_citations": "434\n", "authors": ["276"]}
{"title": "Escape analysis for object-oriented languages: application to Java\n", "abstract": " Escape analysis [27, 14, 5] is a static analysis that determines whether the lifetime of data exceeds its static scope.The main originality of our escape analysis is that it determines precisely the effect of assignments, which is necessary to apply it to object oriented languages with promising results, whereas previous work [27, 14, 5] applied it to functional languages and were very imprecise on assignments. Our implementation analyses the full Java\u2122 Language.We have applied our analysis to stack allocation and synchronization elimination. We manage to stack allocate 13% to 95% of data, eliminate more than 20% of synchronizations on most programs (94% and 99% on two examples) and get up to 44% speedup (21% on average). Our detailed experimental study on large programs shows that the improvement comes from the decrease of the garbage collection and allocation times than from improvements on\u00a0\u2026", "num_citations": "387\n", "authors": ["276"]}
{"title": "Automatic verification of correspondences for security protocols\n", "abstract": " We present a new technique for verifying correspondences in security protocols. In particular, correspondences can be used to formalize authentication. Our technique is fully automatic, it can handle an unbounded number of sessions of the protocol, and it is efficient in practice. It significantly extends a previous technique for the verification of secrecy. The protocol is represented in an extension of the pi calculus with fairly arbitrary cryptographic primitives. This protocol representation includes the specification of the correspondence to be verified, but no other annotation. This representation is then translated into an abstract representation by Horn clauses, which is used to prove the desired correspondence. Our technique has been proved correct and implemented. We have tested it on various protocols from the literature. The experimental results show that these protocols can be verified by our technique in less\u00a0\u2026", "num_citations": "277\n", "authors": ["276"]}
{"title": "Automatic proof of strong secrecy for security protocols\n", "abstract": " We present a new automatic technique for proving strong secrecy for security protocols. Strong secrecy means that an adversary cannot see any difference when the value of the secret changes. Our technique relies on an automatic translation of the protocol into Horn clauses, and a resolution algorithm on the clauses. It requires important extensions with respect to previous work for the proof of (standard) secrecy and authenticity. This technique can handle a wide range of cryptographic primitives, and yields proofs valid for an unbounded number of sessions and an unbounded message space; it is also flexible and efficient. We have proved its correctness, implemented it, and tested it on several examples of protocols including JFK by W. Aiello et al. (2002).", "num_citations": "234\n", "authors": ["276"]}
{"title": "Analyzing security protocols with secrecy types and logic programs\n", "abstract": " We study and further develop two language-based techniques for analyzing security protocols. One is based on a typed process calculus; the other, on untyped logic programs. Both focus on secrecy properties. We contribute to these two techniques, in particular by extending the former with a flexible, generic treatment of many cryptographic operations. We also establish an equivalence between the two techniques.", "num_citations": "215\n", "authors": ["276"]}
{"title": "ProVerif 2.00: automatic cryptographic protocol verifier, user manual and tutorial\n", "abstract": " This manual describes the ProVerif software package version 2.00. ProVerif is a tool for automatically analyzing the security of cryptographic protocols. Support is provided for, but not limited to, cryptographic primitives including: symmetric and asymmetric encryption; digital signatures; hash functions; bit-commitment; and non-interactive zero-knowledge proofs. ProVerif is capable of proving reachability properties, correspondence assertions, and observational equivalence. These capabilities are particularly useful to the computer security domain since they permit the analysis of secrecy and authentication properties. Moreover, emerging properties such as privacy, traceability, and verifiability can also be considered. Protocol analysis is considered with respect to an unbounded number of sessions and an unbounded message space. Moreover, the tool is capable of attack reconstruction: when a property cannot be proved, ProVerif tries to reconstruct an execution trace that falsifies the desired property.", "num_citations": "205\n", "authors": ["276"]}
{"title": "From secrecy to authenticity in security protocols\n", "abstract": " We present a new technique for verifying authenticity in cryptographic protocols. This technique is fully automatic, it can handle an unbounded number of sessions of the protocol, and it is efficient in practice. It significantly extends a previous technique for the verification of secrecy. The protocol is represented in an extension of the pi calculus with fairly arbitrary cryptographic primitives. This protocol representation includes the authentication specification to be verified, but no other annotation. Our technique has been proved correct, implemented, and tested on various protocols from the literature. The experimental results show that we can verify these protocols in less than 1 s.", "num_citations": "205\n", "authors": ["276"]}
{"title": "Modeling and verifying security protocols with the applied pi calculus and ProVerif\n", "abstract": " ProVerif is an automatic symbolic protocol verifier.  It supports a wide range of cryptographic primitives, defined by rewrite rules or by equations. It can prove various security properties: secrecy, authentication, and process equivalences, for an unbounded message space and an unbounded number of sessions. It takes as input a description of the protocol to verify in a dialect of the applied pi calculus, an extension of the pi calculus with cryptography.  It automatically translates this protocol description into Horn clauses and determines whether the desired security properties hold by resolution on these clauses. This survey presents an overview of the research on ProVerif.", "num_citations": "202\n", "authors": ["276"]}
{"title": "Secrecy types for asymmetric communication\n", "abstract": " We develop a typed process calculus for security protocols in which types convey secrecy properties. We focus on asymmetric communication primitives, especially on public-key encryption. These present special difficulties, partly because they rely on related capabilities (e.g., \u201cpublic\u201d and \u201cprivate\u201d keys) with different levels of secrecy and scopes.", "num_citations": "153\n", "authors": ["276"]}
{"title": "Escape analysis for JavaTM Theory and practice\n", "abstract": " Escape analysis is a static analysis that determines whether the lifetime of data may exceed its static scope.This paper first presents the design and correctness proof of an escape analysis for JavaTM. This analysis is interprocedural, context sensitive, and as flow-sensitive as the static single assignment form. So, assignments to object fields are analyzed in a flow-insensitive manner. Since Java is an imperative language, the effect of assignments must be precisely determined. This goal is achieved thanks to our technique using two interdependent analyses, one forward, one backward. We introduce a new method to prove the correctness of this analysis, using aliases as an intermediate step. We use integers to represent the escaping parts of values, which leads to a fast and precise analysis.Our implementation [Blanchet 1999], which applies to the whole Java language, is then presented. Escape analysis is\u00a0\u2026", "num_citations": "140\n", "authors": ["276"]}
{"title": "Automated security proofs with sequences of games\n", "abstract": " This paper presents the first automatic technique for proving not only protocols but also primitives in the exact security computational model. Automatic proofs of cryptographic protocols were up to now reserved to the Dolev-Yao model, which however makes quite strong assumptions on the primitives. On the other hand, with the proofs by reductions, in the complexity theoretic framework, more subtle security assumptions can be considered, but security analyses are manual. A process calculus is thus defined in order to take into account the probabilistic semantics of the computational model. It is already rich enough to describe all the usual security notions of both symmetric and asymmetric cryptography, as well as the basic computational assumptions. As an example, we illustrate the use of the new tool with the proof of a quite famous asymmetric primitive: unforgeability under chosen-message attacks (UF\u00a0\u2026", "num_citations": "137\n", "authors": ["276"]}
{"title": "Automatic verification of security protocols in the symbolic model: The verifier proverif\n", "abstract": " After giving general context on the verification of security protocols, we focus on the automatic symbolic protocol verifier ProVerif. This verifier can prove secrecy, authentication, and observational equivalence properties of security protocols, for an unbounded number of sessions of the protocol. It supports a wide range of cryptographic primitives defined by rewrite rules or by equations. The tool takes as input a description of the protocol to verify in a process calculus, an extension of the pi calculus with cryptography. It automatically translates this protocol into an abstract representation of the protocol by Horn clauses, and determines whether the desired security properties hold by resolution on these clauses.", "num_citations": "115\n", "authors": ["276"]}
{"title": "Security Protocol Verification: Symbolic and Computational Models\n", "abstract": " Security protocol verification has been a very active research area since the 1990s. This paper surveys various approaches in this area, considering the verification in the symbolic model, as well as the more recent approaches that rely on the computational model or that verify protocol implementations rather than specifications. Additionally, we briefly describe our symbolic security protocol verifier ProVerif and situate it among these approaches.", "num_citations": "113\n", "authors": ["276"]}
{"title": "Escape analysis: Correctness proof, implementation and experimental results\n", "abstract": " We describe an escape analysis [32, 14], used to determine whether the lifetime of data exceeds its static scope. We give a new correctness proof starting directly from a semantics. Contrary to previous proofs, it takes into account all the features of functional languages, including imperative features and polymorphism. The analysis has been designed so that it can be implemented under the small complexity bound of O (n log 2 n) where n is the size of the analyzed program. We have included it in the Caml Special Light compiler (an implementation of ML), and applied it to very large programs. We plan to apply these techniques to the Java programming language. Escape analysis has been applied to stack allocation. We improve the optimization technique by determining minimal lifetime for stack allocated data, and using inlining. We manage to stack allocate 25% of data in the theorem prover Coq. We analyzed\u00a0\u2026", "num_citations": "111\n", "authors": ["276"]}
{"title": "Automated formal analysis of a protocol for secure file sharing on untrusted storage\n", "abstract": " We study formal security properties of a state-of-the-art protocol for secure file sharing on untrusted storage, in the automatic protocol verifier ProVerif. As far as we know, this is the first automated formal analysis of a secure storage protocol. The protocol, designed as the basis for the file system Plutus, features a number of interesting schemes like lazy revocation and key rotation. These schemes improve the protocol's performance, but complicate its security properties. Our analysis clarifies several ambiguities in the design and reveals some unknown attacks on the protocol. We propose corrections, and prove precise security guarantees for the corrected protocol.", "num_citations": "99\n", "authors": ["276"]}
{"title": "Proving more observational equivalences with ProVerif\n", "abstract": " This paper presents an extension of the automatic protocol verifier ProVerif in order to prove more observational equivalences. ProVerif can prove observational equivalence between processes that have the same structure but differ by the messages they contain. In order to extend the class of equivalences that ProVerif handles, we extend the language of terms by defining more functions (destructors) by rewrite rules. In particular, we allow rewrite rules with inequalities as side-conditions, so that we can express tests \u201cif then else\u201d inside terms. Finally, we provide an automatic procedure that translates a process into an equivalent process that performs as many actions as possible inside terms, to allow ProVerif to prove the desired equivalence. These extensions have been implemented in ProVerif and allow us to automatically prove anonymity in the private authentication protocol by Abadi and Fournet.", "num_citations": "87\n", "authors": ["276"]}
{"title": "Computationally sound mechanized proofs of correspondence assertions\n", "abstract": " We present a new mechanized prover for showing correspondence assertions for cryptographic protocols in the computational model. Correspondence assertions are useful in particular for establishing authentication. Our technique produces proofs by sequences of games, as standard in cryptography. These proofs are valid for a number of sessions polynomial in the security parameter, in the presence of an active adversary. Our technique can handle a wide variety of cryptographic primitives, including shared- and public-key encryption, signatures, message authentication codes, and hash functions. It has been implemented in the tool CryptoVerif and successfully tested on examples from the literature.", "num_citations": "80\n", "authors": ["276"]}
{"title": "Computer-assisted verification of a protocol for certified email\n", "abstract": " We present the formalization and verification of a recent cryptographic protocol for certified email. Relying on a tool for automatic protocol analysis, we establish the key security properties of the protocol. This case study explores the use of general correspondence assertions in automatic proofs, and aims to demonstrate the considerable power of the tool and its applicability to non-trivial, interesting protocols.", "num_citations": "78\n", "authors": ["276"]}
{"title": "Computer-assisted verification of a protocol for certified email\n", "abstract": " We present the formalization and verification of a recently developed cryptographic protocol for certified email. Relying on a tool for automatic protocol analysis, we establish the key security properties of the protocol. This case study explores the use of general correspondence assertions in automatic proofs, and aims to demonstrate the considerable power of the tool and its applicability to non-trivial, interesting protocols.", "num_citations": "66\n", "authors": ["276"]}
{"title": "Reconstruction of attacks against cryptographic protocols\n", "abstract": " We study an automatic technique for the verification of cryptographic protocols based on a Horn clause model of the protocol. This technique yields proofs valid for an unbounded number of sessions of the protocol. However, up to now, it gave no definite information when the proof failed. In this paper, we present an algorithm for reconstructing an attack against the protocol when the desired security property does not hold. We have proved soundness, termination, as well as a partial completeness result for our algorithm. We have also implemented it in the automatic protocol verifier ProVerif. As an extreme example, we could reconstruct an attack involving 200 parallel sessions against f/sup 200/g/sup 200/ protocol (Millen, 1999).", "num_citations": "63\n", "authors": ["276"]}
{"title": "Using Horn clauses for analyzing security protocols\n", "abstract": " This chapter presents a method for verifying security protocols based on an abstract representation of protocols by Horn clauses. This method is the foundation of the protocol verifier ProVerif. It is fully automatic, efficient, and can handle an unbounded number of sessions and an unbounded message space. It supports various cryptographic primitives defined by rewrite rules or equations. Even if we focus on secrecy in this chapter, this method can also prove other security properties, including authentication and process equivalences.", "num_citations": "56\n", "authors": ["276"]}
{"title": "CryptoVerif: Computationally sound mechanized prover for cryptographic protocols\n", "abstract": " Two models for security protocols: Computational model: messages are bitstrings cryptographic primitives are functions from bitstrings to bitstrings the adversary is a probabilistic polynomial-time Turing machine Proofs are done manually.", "num_citations": "50\n", "authors": ["276"]}
{"title": "Automated reasoning for equivalences in the applied pi calculus with barriers\n", "abstract": " Observational equivalence allows us to study important security properties such as anonymity. Unfortunately, the difficulty of proving observational equivalence hinders analysis. Blanchet, Abadi & Fournet simplify its proof by introducing a sufficient condition for observational equivalence, called diff-equivalence, which is a reachability condition that can be proved automatically by ProVerif. However, diff-equivalence is a very strong condition, which often does not hold even if observational equivalence does. In particular, when proving equivalence between processes that contain several parallel components, eg, P\u2223 Q and P\u2032\u2223 Q\u2032, diff-equivalence requires that P is equivalent to P\u2032 and Q is equivalent to Q\u2032. To relax this constraint, Delaune, Ryan & Smyth introduced the idea of swapping data between parallel processes P\u2032 and Q\u2032 at synchronisation points, without proving its soundness. We extend their work\u00a0\u2026", "num_citations": "44\n", "authors": ["276"]}
{"title": "Security protocols: from linear to classical logic by abstract interpretation\n", "abstract": " We relate two models of security protocols, namely the linear logic or multiset rewriting model, and the classical logic, Horn clause representation of protocols. More specifically, we show that the latter model is an abstraction of the former, in which the number of repetitions of each fact is forgotten. This result formally characterizes the approximations made by the classical logic model.", "num_citations": "43\n", "authors": ["276"]}
{"title": "V\u00e9rification automatique de protocoles cryptographiques: modele formel et modele calculatoire\n", "abstract": " Je tiens tout d\u2019aborda remercier les membres de mon jury d\u2019habilitation. Jacques Stern m\u2019a fait l\u2019honneur de pr\u00e9sider mon jury. Je l\u2019en remercie tout particulierement. Patrick Cousot a \u00e9t\u00e9 le directeur de mes travaux depuis ma these, apres avoir \u00e9t\u00e9 mon directeur de these. Je le remercie particulierement pour la grande libert\u00e9 scientifique qu\u2019il m\u2019a accord\u00e9e, sans laquelle je n\u2019aurais jamais pu r\u00e9aliser les travaux pr\u00e9sent\u00e9s ici. Andrew Gordon, Jean Goubault-Larrecq et Serge Vaudenay ont \u00e9t\u00e9 les rapporteurs de ce m\u00e9moire. Je tiensa les remercier pour le travail consid\u00e9rable qu\u2019ils ont effectu\u00e9. Ralf K\u00fcsters, Vangelis Paschos et Mark Ryan ont bien voulu faire partie de jury d\u2019habilitation; je les en remercie chaleureusement. Je remercie \u00e9galement Andrew Gordon, Ralf K\u00fcsters, Mark Ryan et Serge Vaudenay d\u2019avoir fait le voyage depuis l\u2019\u00e9tranger pour ma soutenance.", "num_citations": "32\n", "authors": ["276"]}
{"title": "Automatic verification of cryptographic protocols: a logic programming approach\n", "abstract": " We present a technique for cryptographic protocol verification, based on an intermediate representation of the protocol by a set of Horn clauses (a logic program). This technique makes it possible to verify security properties of the protocols, such as secrecy and authenticity, in a fully automatic way. Furthermore, the obtained security proofs are valid for an unbounded number of sessions of the protocol.", "num_citations": "27\n", "authors": ["276"]}
{"title": "Symbolic and computational mechanized verification of the ARINC823 avionic protocols\n", "abstract": " We present the first formal analysis of two avionic protocols that aim to secure air-ground communications, the ARINC823 public-key and shared-key protocols. We verify these protocols both in the symbolic model of cryptography, using ProVerif, and in the computational model, using CryptoVerif. While we confirm many security properties of these protocols, we also find several weaknesses, attacks, and imprecisions in the standard. We propose fixes for these problems. This case study required the specification of new cryptographic primitives in CryptoVerif. It also illustrates the complementarity between symbolic and computational verification.", "num_citations": "26\n", "authors": ["276"]}
{"title": "From Computationally-proved Protocol Specifications to Implementations\n", "abstract": " This paper presents a novel framework for proving specifications of security protocols in the computational model and generating runnable implementations from such proved specifications. We rely on the computationally-sound protocol verifier CryptoVerif for proving the specification, and we have implemented a compiler that translates a CryptoVerif specification into an implementation in OCaml. We have applied this compiler to the SSH Transport Layer protocol: we proved the authentication of the server and the secrecy of the session keys in this protocol and verified that the generated implementation successfully interacts with OpenSSH. The secrecy of messages sent over the SSH tunnel cannot be proved due to known weaknesses in SSH with CBC-mode encryption.", "num_citations": "24\n", "authors": ["276"]}
{"title": "ProVerif 1.96: automatic cryptographic protocol verifier, users manual and tutorial\n", "abstract": " This manual describes the ProVerif software package version 1.98. ProVerif is a tool for automatically analyzing the security of cryptographic protocols. Support is provided for, but not limited to, cryptographic primitives including: symmetric and asymmetric encryption; digital signatures; hash functions; bit-commitment; and non-interactive zero-knowledge proofs. ProVerif is capable of proving reachability properties, correspondence assertions, and observational equivalence. These capabilities are particularly useful to the computer security domain since they permit the analysis of secrecy and authentication properties. Moreover, emerging properties such as privacy, traceability, and verifiability can also be considered. Protocol analysis is considered with respect to an unbounded number of sessions and an unbounded message space. Moreover, the tool is capable of attack reconstruction: when a property cannot be proved, ProVerif tries to reconstruct an execution trace that falsifies the desired property.", "num_citations": "23\n", "authors": ["276"]}
{"title": "Proved generation of implementations from computationally secure protocol specifications1\n", "abstract": " In order to obtain implementations of security protocols proved secure in the computational model, we previously proposed the following approach: we write a specification of the protocol in the input language of the computational protocol verifier CryptoVerif, prove it secure using CryptoVerif, then generate an OCaml implementation of the protocol from the CryptoVerif specification using a specific compiler that we have implemented. However, until now, this compiler was not proved correct, so we did not have real guarantees on the generated implementation. In this paper, we fill this gap. We prove that this compiler preserves the security properties proved by CryptoVerif: if an adversary has probability p of breaking a security property in the generated code, then there exists an adversary that breaks the property with the same probability p in the CryptoVerif specification. Therefore, if the protocol specification is\u00a0\u2026", "num_citations": "20\n", "authors": ["276"]}
{"title": "Abstracting cryptographic protocols by prolog rules\n", "abstract": " Most current cryptographic protocol verifiers meet the state space explosion problem, and have to limit the number of executions of the considered protocol during the verification. To solve these problems, we introduce an abstract representation of cryptographic protocols, based on Prolog rules, and use it to verify secrecy properties of protocols.", "num_citations": "20\n", "authors": ["276"]}
{"title": "From Computationally-Proved Protocol Specifications to Implementations and Application to SSH.\n", "abstract": " This paper presents a novel technique for obtaining implementations of security protocols, proved secure in the computational model. We formally specify the protocol to prove, we prove this specification using the computationally-sound protocol verifier CryptoVerif, and we automatically translate it into an implementation in OCaml using a new compiler that we have implemented. We applied this approach to the SSH Transport Layer protocol: we proved the authentication of the server and the secrecy of the session keys in this protocol and verified that the generated implementation successfully interacts with OpenSSH. We explain these proofs, as well as an extension of CryptoVerif needed for the proof of secrecy of the session keys. The secrecy of messages sent over the SSH tunnel cannot be proved due to known weaknesses in SSH with CBC-mode encryption.", "num_citations": "19\n", "authors": ["276"]}
{"title": "Verification of Security Protocols with Lists: from Length One to Unbounded Length\n", "abstract": " We present a novel, simple technique for proving secrecy properties for security protocols that manipulate lists of unbounded length, for an unbounded number of sessions. More specifically, our technique relies on the Horn clause approach used in the automatic verifier ProVerif: we show that if a protocol is proven secure by our technique with lists of length one, then it is secure for lists of unbounded length. Interestingly, this theorem relies on approximations made by our verification technique: in general, secrecy for lists of length one does not imply secrecy for lists of unbounded length. Our result can be used in particular to prove secrecy properties for group protocols with an unbounded number of participants and for some XML protocols (web services) with ProVerif.", "num_citations": "16\n", "authors": ["276"]}
{"title": "Composition theorems for cryptoverif and application to TLS 1.3\n", "abstract": " We present composition theorems for security protocols, to compose a key exchange protocol and a symmetric-key protocol that uses the exchanged key. Our results rely on the computational model of cryptography and are stated in the framework of the tool CryptoVerif. They support key exchange protocols that guarantee injective or non-injective authentication. They also allow random oracles shared between the composed protocols. To our knowledge, they are the first composition theorems for key exchange stated for a computational protocol verification tool, and also the first to allow such flexibility. As a case study, we apply our composition theorems to a proof of TLS 1.3 Draft-18. This work fills a gap in a previous paper that informally claims a compositional proof of TLS 1.3, without formally justifying it.", "num_citations": "14\n", "authors": ["276"]}
{"title": "Automatically verified mechanized proof of one-encryption key exchange\n", "abstract": " We present a mechanized proof of the password-based protocol One-Encryption Key Exchange (OEKE) using the computationally-sound protocol prover Crypto Verif. OEKE is a non-trivial protocol, and thus mechanizing its proof provides additional confidence that it is correct. This case study was also an opportunity to implement several important extensions of Crypto Verif, useful for proving many other protocols. We have indeed extended Crypto Verif to support the computational Diffie-Hellman assumption. We have also added support for proofs that rely on Shoup's lemma and additional game transformations. In particular, it is now possible to insert case distinctions manually and to merge cases that no longer need to be distinguished. Eventually, some improvements have been added on the computation of the probability bounds for attacks, providing better reductions. In particular, we improve over the standard\u00a0\u2026", "num_citations": "13\n", "authors": ["276"]}
{"title": "A computationally sound automatic prover for cryptographic protocols\n", "abstract": " \u2022 Indirect approach: 1) Make a Dolev-Yao proof. 2) Use a theorem that shows the soundness of the Dolev-Yao approach with respect to the computational model. Pioneered by Abadi and Rogaway; currently attracts much attention.", "num_citations": "12\n", "authors": ["276"]}
{"title": "A calculus for secure mobility\n", "abstract": " In this paper, we introduce the crypto-loc calculus, a calculus for modelling secure mobile computations that combine the concepts of locations, cryptography, and code mobility. All these concepts exist in mobile systems, for example, Java applets run within sandboxes or downloaded under an SSL connection. We use observational equivalence of processes as a powerful means of defining security properties, and characterize observational equivalence in terms of a labelled bisimilarity relation, which makes its proof much easier.", "num_citations": "11\n", "authors": ["276"]}
{"title": "CryptoVerif: A computationally-sound security protocol verifier\n", "abstract": " This document presents the security protocol verifier CryptoVerif. In contrast to most previous provers, CryptoVerif does not rely on the Dolev-Yao model, but on the computational model. It can verify secrecy and correspondence properties (which include authentication). It produces proofs presented as sequences of games, like those manually written by cryptographers; these games are formalized in a probabilistic polynomial-time process calculus. CryptoVerif provides a generic method for specifying security properties of the cryptographic primitives. It produces proofs valid for a any number of sessions of the protocol, and provides an upper bound on the probability of success of an attack against the protocol as a function of the probability of breaking each primitive and of the number of sessions. It can work automatically, or the user can guide it with manual proof indications.", "num_citations": "9\n", "authors": ["276"]}
{"title": "Automatic verification of protocols with lists of unbounded length\n", "abstract": " We present a novel automatic technique for proving secrecy and authentication properties for security protocols that manipulate lists of unbounded length, for an unbounded number of sessions. This result is achieved by extending the Horn clause approach of the automatic protocol verifier ProVerif. We extend the Horn clauses to be able to represent lists of unbounded length. We adapt the resolution algorithm to handle the new class of Horn clauses, and prove the soundness of this new algorithm. We have implemented our algorithm and successfully tested it on several protocol examples, including XML protocols coming from web services.", "num_citations": "7\n", "authors": ["276"]}
{"title": "Mechanizing Game-Based Proofs of Security Protocols.\n", "abstract": " After a short introduction to the field of security protocol verification, we present the automatic protocol verifier CryptoVerif. In contrast to most previous protocol verifiers, CryptoVerif does not rely on the Dolev-Yao model, but on the computational model. It produces proofs presented as sequences of games, like those manually done by cryptographers; these games are formalized in a probabilistic process calculus. CryptoVerif provides a generic method for specifying security properties of the cryptographic primitives. It can prove secrecy and correspondence properties (including authentication). It produces proofs valid for any number of sessions, in the presence of an active adversary. It also provides an explicit formula for the probability of success of an attack against the protocol, as a function of the probability of breaking each primitive and of the number of sessions.", "num_citations": "7\n", "authors": ["276"]}
{"title": "ProScript TLS: Building a TLS 1.3 Implementation with a Verifiable Protocol Model\n", "abstract": " ProScript TLS: Building a TLS 1.3 Implementation with a Verifiable Protocol Model Page 1 ProScript TLS: Building a TLS 1.3 Implementation with a Verifiable Protocol Model Karthikeyan Bhargavan Nadim Kobeissi Bruno Blanchet Page 2 miTLS: reference implementation of TLS 1.0-1.2 flexTLS: specification-based testing for TLS Page 3 Goal: get developers to run light-weight analysis A reference implementation of TLS in JavaScript \u2022 Not a cryptographic proof! Page 4 Current implementation status Current verification status Page 5 Draft 11 specification Complex key schedule Page 6 Client knows S\u2019s semi-static key gs Client auth block 0-RTT data Page 7 Server Auth Block Server Semi-Static 1.5-RTT Data Page 8 Client auth block (again) 1-RTT Data Composite Data Stream Page 9 Handshake messages processed in flights Client Server send_client_hello recv_client_hello recv_server_hello send_server_finished -\u2026", "num_citations": "6\n", "authors": ["276"]}
{"title": "The computational and decisional Diffie-Hellman assumptions in CryptoVerif\n", "abstract": " The computational and decisional Diffie-Hellman assumptions in CryptoVerif Page 1 Basic DDH Basic CDH Need for extension Extended CDH Extended DDH Conclusion The computational and decisional Diffie-Hellman assumptions in CryptoVerif Bruno Blanchet and David Pointcheval CNRS, \u00c9cole Normale Sup\u00e9rieure, INRIA, Paris July 2010 Bruno Blanchet and David Pointcheval Diffie-Hellman in CryptoVerif July 2010 1 / 18 Page 2 Basic DDH Basic CDH Need for extension Extended CDH Extended DDH Conclusion Motivation CryptoVerif is a prover for security protocols that is sound in the computational model produces proofs by sequences of games can give asymptotic or exact security results provides a generic method for specifying assumptions on cryptographic primitives Our goal: extend CryptoVerif to Diffie-Hellman key agreements. an important primitive; difficult for handle in formal protocol provers. -in ,\u2026", "num_citations": "6\n", "authors": ["276"]}
{"title": "Introduction to abstract interpretation\n", "abstract": " We present the basic theory of abstract interpretation, and its application to static program analysis. The goal is not to give an exhaustive view of abstract interpretation, but to give enough background to make papers on abstract interpretation more understandable.", "num_citations": "3\n", "authors": ["276"]}
{"title": "Escape Analysis. Applications to ML and Java (TM)\n", "abstract": " Escape Analysis. Applications to ML and Java Page 1 Escape Analysis. Applications to ML and Java TM Bruno Blanchet INRIA Rocquencourt Bruno.Blanchet@inria.fr December 2000 Page 2 Overview 1. Introduction: escape analysis and applications. 2. Escape analysis 2.a Design: Common point between ML and Java 2.b Design: Differences 2.c Program transformation 2.d Complexity 3. Benchmark results 4. Conclusions B. Blanchet 1 Page 3 Introduction: what is escape analysis ? A value escapes if its lifetime exceeds its static scope. \u2022 ML: static scope of x in \u201clet x = M in N\u201d is N. Determine whether x may be returned or stored in a reference by N \u2022 Java: static scope = the method. Determine whether an object may be returned, stored in a parameter or a static field by a method. B. Blanchet 2 Page 4 What is escape analysis ? (continued) \u2022 Escape analysis is a particular may-alias analysis. It determines whether a be , \u2026", "num_citations": "3\n", "authors": ["276"]}
{"title": "Analysing the HPKE standard\n", "abstract": " The Hybrid Public Key Encryption (HPKE) scheme is an emerging standard currently under consideration by the Crypto Forum Research Group (CFRG) of the IETF as a candidate for formal approval. Of the four modes of HPKE, we analyse the authenticated mode in its single-shot encryption form as it contains what is, arguably, the most novel part of HPKE.", "num_citations": "2\n", "authors": ["276"]}
{"title": "Automatic Verification of Cryptographic Protocols in the Formal Model Automatic Verifier ProVerif\n", "abstract": " Automatic Verification of Cryptographic Protocols in the Formal Model Automatic Verifier ProVerif Page 1 Automatic Verification of Cryptographic Protocols in the Formal Model Automatic Verifier ProVerif Bruno Blanchet INRIA, \u00c9cole Normale Sup\u00e9rieure, CNRS blanchet@di.ens.fr September 2011 Bruno Blanchet (INRIA) ProVerif September 2011 1 / 125 Page 2 Overview of the protocol verifier ProVerif Protocol: Pi calculus + cryptography Properties to prove: Secrecy, authenticity, . . . Horn clauses Derivability queries Resolution with selection The property is true Potential attack Automatic translator Bruno Blanchet (INRIA) ProVerif September 2011 2 / 125 Page 3 Overview 1. A variant of the spi-calculus 2. Intuitive presentation of the Horn clause representation 3. The solving algorithm 4. Experimental results 5. Formal translation from the spi-calculus. 6. Extension to correspondences Bruno Blanchet (INRIA) ProVerif 3 / \u2026", "num_citations": "2\n", "authors": ["276"]}
{"title": "ProVerif 2.02 pl1: Automatic Cryptographic Protocol Verifier, User Manual and Tutorial\n", "abstract": " This manual describes the ProVerif software package version 2.02 pl1. ProVerif is a tool for automatically analyzing the security of cryptographic protocols. Support is provided for, but not limited to, cryptographic primitives including: symmetric and asymmetric encryption; digital signatures; hash functions; bit-commitment; and non-interactive zero-knowledge proofs. ProVerif is capable of proving reachability properties, correspondence assertions, and observational equivalence. These capabilities are particularly useful to the computer security domain since they permit the analysis of secrecy and authentication properties. Moreover, emerging properties such as privacy, traceability, and verifiability can also be considered. Protocol analysis is considered with respect to an unbounded number of sessions and an unbounded message space. Moreover, the tool is capable of attack reconstruction: when a property cannot be proved, ProVerif tries to reconstruct an execution trace that falsifies the desired property.", "num_citations": "1\n", "authors": ["276"]}
{"title": "A second look at shoup\u2019s lemma\n", "abstract": " Improve probability bounds in proofs by sequences of games: Shoup\u2019s lemma introduces constant factors in probabilities of success of attacks.", "num_citations": "1\n", "authors": ["276"]}
{"title": "Reversible versus Irreversible Machines: Experimental Results\n", "abstract": " The Geometry of Interaction semantics introduced by Girard provides a new way of understanding the reduction process in the-calculus where the computation steps are linear and reversible. Moreover, this can be trivially implemented to give a simple compilation technique: the Geometry of Interaction Machine. At the cost of introducing global operations (irreversible copying and discarding) Danos and Regnier have shown a correspondence with Krivine's environment machine. In this paper we report on experimental results for the respective performances of these two implementations to try to judge the relative merits of reversible versus irreversible computations.", "num_citations": "1\n", "authors": ["276"]}
{"title": "Analysis of cryptographic protocols in the computational model\n", "abstract": " CiNii \u8ad6\u6587 - Analysis of cryptographic protocols in the computational model CiNii \u56fd\u7acb\u60c5\u5831\u5b66 \u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb \u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005 \u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u306e\u30b5\u30fc\u30d3\u30b9\u306b\u95a2\u3059\u308b\u30a2\u30f3\u30b1\u30fc\u30c8\u3092\u5b9f\u65bd\u4e2d\u3067\u3059\uff0811/11(\u6c34)-12/23(\u6c34)\uff09 CiNii Research\u30d7\u30ec \u7248\u306e\u516c\u958b\u306b\u3064\u3044\u3066 Analysis of cryptographic protocols in the computational model BLANCHET B. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 BLANCHET B. \u53ce\u9332\u520a\u884c\u7269 http://www.di.ens.fr/\u301cblanchet/cryptoc-eng.html http://www.di.ens.fr/\u301cblanchet/cryptoc-eng.html \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u30b2\u30fc\u30e0\u5217 \u306b\u3088\u308b\u5b89\u5168\u6027\u8a3c\u660e\u306e\u5f62\u5f0f\u5316\u3068\u81ea\u52d5\u5316(<\u7279\u96c6>\u6570\u7406\u7684\u6280\u6cd5\u306b\u3088\u308b\u60c5\u5831\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3) \u771f\u91ce \u5065 , \u6afb\u7530 \u82f1\u6a39 , \u6cb3\u8fba \u7fa9\u4fe1 , \u585a\u7530 \u606d\u7ae0 \u5fdc\u7528\u6570\u7406 17(4), 302-310, 2007 \u53c2\u8003\u6587\u732e13\u4ef6 CiNii\u5229\u7528\u8005Tweet NII\u2026", "num_citations": "1\n", "authors": ["276"]}