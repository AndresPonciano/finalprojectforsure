{"title": "Preliminary design of JML: A behavioral interface specification language for Java\n", "abstract": " JML is a behavioral interface specification language tailored to Java(TM). Besides pre- and postconditions, it also allows assertions to be intermixed with Java code; these aid verification and debugging. JML is designed to be used by working software engineers; to do this it follows Eiffel in using Java expressions in assertions. JML combines this idea from Eiffel with the model-based approach to specifications, typified by VDM and Larch, which results in greater expressiveness. Other expressiveness advantages over Eiffel include quantifiers, specification-only variables, and frame conditions.This paper discusses the goals of JML, the overall approach, and describes the basic features of the language through examples. It is intended for readers who have some familiarity with both Java and behavioral specification using pre- and postconditions.", "num_citations": "1089\n", "authors": ["1599"]}
{"title": "An overview of JML tools and applications\n", "abstract": " The Java Modeling Language (JML) can be used to specify the detailed design of Java classes and interfaces by adding annotations to Java source files. The aim of JML is to provide a specification language that is easy to use for Java programmers and that is supported by a wide range of tools for specification typechecking, runtime debugging, static analysis, and verification.               This paper gives an overview of the main ideas behind JML, details about JML\u2019s wide range of tools, and a glimpse into existing applications of JML.", "num_citations": "857\n", "authors": ["1599"]}
{"title": "JML: A notation for detailed design\n", "abstract": " JML is a behavioral interface specification language tailored to Java. It is designed to be written and read by working software engineers, and should require only modest mathematical training. It uses Eiffel-style syntax combined with model-based semantics, as in VDM and Larch. JML supports quantifiers, specification-only variables, and other enhancements that make it more expressive for specification than Eiffel and easier to use than VDM and Larch.", "num_citations": "573\n", "authors": ["1599"]}
{"title": "MultiJava: Modular open classes and symmetric multiple dispatch for Java\n", "abstract": " We present MultiJava, a backward-compatible extension to Java supporting open classes and symmetric multiple dispatch. Open classes allow one to add to the set of methods that an existing class supports without creating distinct subclasses or editing existing code. Unlike the\" Visitor\" design pattern, open classes do not require advance planning, and open classes preserve the ability to add new subclasses modularly and safely. Multiple dispatch offers several well-known advantages over the single dispatching of conventional object-oriented languages, including a simple solution to some kinds of\" binary method\" problems. MultiJava's multiple dispatch retains Java's existing class-based encapsulation properties. We adapt previous theoretical work to allow compilation units to be statically typechecked modularly and safely, ruling out any link-time or run-time type errors. We also present an compilation scheme\u00a0\u2026", "num_citations": "430\n", "authors": ["1599"]}
{"title": "A simple and practical approach to unit testing: The JML and JUnit way\n", "abstract": " Writing unit test code is labor-intensive, hence it is often not done as an integral part of programming. However, unit testing is a practical approach to increasing the correctness and quality of software; for example, the Extreme Programming approach relies on frequent unit testing.               In this paper we present a new approach that makes writing unit tests easier. It uses a formal specification language\u2019s runtime assertion checker to decide whether methods are working correctly, thus automating the writing of unit test oracles. These oracles can be easily combined with hand-written test data. Instead of writing testing code, the programmer writes formal specifications (e.g., pre-and postconditions). This makes the programmer\u2019s task easier, because specifications are more concise and abstract than the equivalent test code, and hence more readable and maintainable. Furthermore, by using specifications in\u00a0\u2026", "num_citations": "413\n", "authors": ["1599"]}
{"title": "On binary methods\n", "abstract": " Giving types to binary methods causes significant problems for object\u2010oriented language designers and programmers. This paper offers a comprehensive description of the problems arising from typing binary methods and collects and contrasts diverse views and solutions. It summarizes the current debate on the problem of binary methods for a wide audience.", "num_citations": "346\n", "authors": ["1599"]}
{"title": "An overview of JML tools and applications\n", "abstract": " The Java Modeling Language (JML) can be used to specify the detailed design of Java classes and interfaces by adding annotations to Java source files. The aim of JML is to provide a specification language that is easy to use for Java programmers and that is supported by a wide range of tools for specification type-checking, runtime debugging, static analysis, and verification.This paper gives an overview of the main ideas behind JML, the different groups collaborating to provide tools for JML, and the existing applications of JML. Thus far, most applications have focused on code for programming smartcards written in the Java Card dialect of Java.", "num_citations": "333\n", "authors": ["1599"]}
{"title": "Beyond assertions: Advanced specification and verification with JML and ESC/Java2\n", "abstract": " Many state-based specification languages, including the Java Modeling Language (JML), contain at their core specification constructs familiar to most undergraduates: e.g., assertions, pre- and postconditions, and invariants. Unfortunately, these constructs are not sufficiently expressive to permit formal modular verification of programs written in modern object-oriented languages like Java. The necessary extra constructs for specifying an object-oriented module include (perhaps the less familiar) frame properties, datagroups, and ghost and model fields. These constructs help specifiers deal with potential problems related to, for example, unexpected side effects, aliasing, class invariants, inheritance, and lack of information hiding. This tutorial paper focuses on JML\u2019s realization of these constructs, explaining their meaning while illustrating how they can be used to address the stated problems.", "num_citations": "319\n", "authors": ["1599"]}
{"title": "Forcing behavioral subtyping through specification inheritance\n", "abstract": " A common change to object-oriented software is to add a new type of data that is a subtype of some existing type in the program. However, due to message passing, unchanged pearls of the program may now call operations of the new type. To avoid reverification of unchanged code, such operations should have specifications that are related to the specifications of the appropriate operations in their supertypes. This paper presents a specification technique that uses inheritance of specifications to force the appropriate behavior on the subtype objects. This technique is simple, requires little effort by the specifier, and avoids reverification of unchanged code. We present two notions of such behavioral subtyping, one of which is new. We show how to use these techniques to specify examples in C++.", "num_citations": "277\n", "authors": ["1599"]}
{"title": "How the design of JML accommodates both runtime assertion checking and formal verification\n", "abstract": " Specifications that are used in detailed design and in the documentation of existing code are primarily written and read by programmers. However, most formal specification languages either make heavy use of symbolic mathematical operators, which discourages use by programmers, or limit assertions to expressions of the underlying programming language, which makes it difficult to write exact specifications. Moreover, using assertions that are expressions in the underlying programming language can cause problems both in runtime assertion checking and in formal verification, because such expressions can potentially contain side effects. The Java Modeling Language, JML, avoids these problems. It uses a side-effect free subset of Java\u2019s expressions to which are added a few mathematical operators (such as the quantifiers \u29f9forall and \u29f9exists). JML also hides mathematical abstractions, such as sets and\u00a0\u2026", "num_citations": "261\n", "authors": ["1599"]}
{"title": "Design by Contract with JML\n", "abstract": " This document gives a tutorial introduction to the Java Modeling Language (JML), and explains how JML can be used as a powerful design by contract (DBC) tool for Java. JML is a formal behavioral interface specification language for Java that contains the essential notations used in DBC as a subset. The basic concepts of DBC are explained with a particular emphasis on how to use JML notations to specify Java classes and interfaces. JML tools such as JML compiler (jmlc) are also introduced, with examples of their use.", "num_citations": "243\n", "authors": ["1599"]}
{"title": "JML (poster session) notations and tools supporting detailed design in JAVA\n", "abstract": " JML is a notation for specifying the detailed design of Java classes and interfaces. JML's assertions are stated using a slight extension of Java's expression syntax. This should make it easy to use. Tools for JML aid in static analysis, verification, and run-time debugging of Java code.", "num_citations": "240\n", "authors": ["1599"]}
{"title": "A runtime assertion checker for the Java Modeling Language (JML)\n", "abstract": " Debugging is made difficult by the need to precisely describe what each piece of the software is supposed to do, and to write code to defend modules against the errors of other modules; if this is not done it is difficult to assign blame to a small part of the program when things go wrong. Similarly, unit testing also needs precise descriptions of behavior, and is made difficult by the need to write test oracles. However, debugging and testing consume a significant fraction of the cost of software development and maintenance efforts. Inadequate debugging and testing also contribute to quality problems. We describe a runtime assertion checker for the Java Modeling Language (JML) that helps in assigning blame during debugging and in automatic generation of test oracles. It represents a significant advance over the current state of the art, because it can deal with very abstract specifications which hide representation details, and other features such as quantifiers, and inheritance of specifications. Yet JML specifications have a syntax that is easily understood by programmers. Thus, JML's runtime assertion checker has the potential for decreasing the cost of debugging and testing.", "num_citations": "230\n", "authors": ["1599"]}
{"title": "Foundations of component-based systems\n", "abstract": " This collection of top-notch articles by well-known experts brings together, for the first time, key elements of this area that are fast becoming the focus of much current research and practice in computing. About half the articles deal with theoretical frameworks, models, and systems of notation; the rest comprise case studies by architects of prototype systems who present findings on architectures verification. The emphasis is on advances in the technological infrastructure of component-based systems; how to design and specify reusable components; and how to reason about, verify, and validate systems from components. An introduction by Clemens Szyperski gives a snapshot of current research in the field.", "num_citations": "229\n", "authors": ["1599"]}
{"title": "Ptolemy: A language with quantified, typed events\n", "abstract": " Implicit invocation (II) and aspect-oriented (AO) languages provide related but distinct mechanisms for separation of concerns. II languages have explicitly announced events that run registered observer methods. AO languages have implicitly announced events that run method-like but more powerful advice. A limitation of II languages is their inability to refer to a large set of events succinctly. They also lack the expressive power of AO advice. Limitations of AO languages include potentially fragile dependence on syntactic structure that may hurt maintainability, and limits on the available set of implicit events and the reflective contextual information available. Quantified, typed events, as implemented in our language Ptolemy, solve all these problems. This paper describes Ptolemy and explores its advantages relative to both II and AO languages.", "num_citations": "157\n", "authors": ["1599"]}
{"title": "Observers and assistants: A proposal for modular aspect-oriented reasoning\n", "abstract": " In general, aspect-oriented programs require a whole-program analysis to understand the semantics of a single method invocation. This property makes reasoning difficult, impeding maintenance efforts, contrary to a stated goal of aspect-oriented programming. We propose some simple modifications to AspectJ that permit modular reasoning. This eliminates the need for whole-program analysis and makes code easier to understand and maintain.", "num_citations": "154\n", "authors": ["1599"]}
{"title": "Modular specification and verification of object-oriented programs\n", "abstract": " A method for modular specification and verification using the ideas of subtype and normal type is presented. The method corresponds to informal techniques used by object-oriented programmers. The key idea is that objects of a subtype must behave like objects of that type's supertypes. An example program is used to show the reasoning problems that supertype abstraction may cause and how the method resolves them. Subtype polymorphism is addressed, and specification and verification update is discussed. A set of syntactic and semantic constraints on subtype relationships, which formalize the intuition that each object of a subtype must behave like some object of each of its supertypes, is examined. These constraints are the key to the soundness of the method. To state them precisely, a formal model of abstract type specifications is used.< >", "num_citations": "136\n", "authors": ["1599"]}
{"title": "JML: a Java modeling language\n", "abstract": " JML is a behavioral interface speci cation language tailored to Java. It also allows assertions to be intermixed with Java code, as an aid to veri cation and debugging. JML is designed to be used by working software engineers, and requires only modest mathematical training. To achieve this goal, JML uses Ei el-style assertion syntax combined with the model-based approach to speci cations typi ed by VDM and Larch. However, JML supports quanti ers, speci cation-only variables, frame conditions, and other enhancements that make it more expressive for speci cation than Ei el. This paper discusses the goals of JML, the overall approach, and prospects for giving JML a formal semantics through a veri cation logic.", "num_citations": "132\n", "authors": ["1599"]}
{"title": "Typechecking and modules for multimethods\n", "abstract": " Two major obstacles that hinder the wider acceptance of multimethods are (1) concerns over the lack of encapsulation and modularity and (2) the absence of static typechecking in existing multimethod-based languages. This article addresses both of these problems. We present a polynomial-time, static typechecking algorithm that checks the conformance, completeness, and consistency of a group of method implementations with respect to declared message signatures. This algorithm improves on previous algorithms by handling separate type and inheritance hierarchies, abstract classes, and graph-based method lookup semantics. We also present a module system that enables independently developed code to be fully encapsulated and statically typechecked on a per-module basis. To guarantee that potential conflicts between independently developed modules have been resolved, a simple well-formedness\u00a0\u2026", "num_citations": "132\n", "authors": ["1599"]}
{"title": "MultiJava: Design rationale, compiler implementation, and applications\n", "abstract": " MultiJava is a conservative extension of the Java programming language that adds symmetric multiple dispatch and open classes. Among other benefits, multiple dispatch provides a solution to the binary method problem. Open classes provide a solution to the extensibility problem of object-oriented programming languages, allowing the modular addition of both new types and new operations to an existing type hierarchy. This article illustrates and motivates the design of MultiJava and describes its modular static typechecking and modular compilation strategies. Although MultiJava extends Java, the key ideas of the language design are applicable to other object-oriented languages, such as C# and C++, and even, with some modifications, to functional languages such as ML.This article also discusses the variety of application domains in which MultiJava has been successfully used by others, including pervasive\u00a0\u2026", "num_citations": "130\n", "authors": ["1599"]}
{"title": "Reasoning about object-oriented programs that use subtypes\n", "abstract": " Programmers informally reason about object-oriented programs by using subtype relationships to classify the behavior of objects of different types and by letting supertypes stand for all their subtypes. We describe formal specification and verification techniques for such programs that mimic these informal ideas. Our techniques are modular and extend standard techniques for reasoning about programs that use abstract data types. Semantic restrictions on subtype relationships guarantee the soundness of these techniques.", "num_citations": "128\n", "authors": ["1599"]}
{"title": "Specification and verification of object-oriented programs using supertype abstraction\n", "abstract": " We present a formal specification language and a formal verification logic for a simple object-oriented programming language. The language is applicative and statically typed, and supports subtyping and message-passing. The verification logic relies on a behavioral notion of subtyping that captures the intuition that a subtype behaves like its supertypes. We give a formal definition for legal subtype relations, based on the specified behavior of objects, and show that this definition is sufficient to ensure the soundness of the verification logic. The verification logic reflects the way programmers reason informally about object-oriented programs, in that it allows them to use static type information, which avoids the need to consider all possible run-time subtypes.", "num_citations": "109\n", "authors": ["1599"]}
{"title": "Obliviousness, modular reasoning, and the behavioral subtyping analogy\n", "abstract": " The obliviousness property of AspectJ-like languages conflicts with the ability to reason about programs in a modular fashion. This can make debugging and maintenance difficult. In object-oriented programming, the discipline of behavioral subtyping allows one to reason about programs modularly, despite the oblivious nature of dynamic binding; however, it is not clear what discipline would help programmers in AspectJ-like languages obtain modular reasoning. Behavioral subtyping was born out of the stories programmers were telling in their object-oriented programs and how they reasoned about them. Programmers use AspectJ-like languages to tell what we call``superimposition''and``adaptation''stories. Thus, a discipline of modular reasoning for an AspectJ-like language must account for both sorts of stories. We describe the modular reasoning problem for AspectJ-like languages. We do not yet have a solution, but concisely articulate the issues involved.", "num_citations": "95\n", "authors": ["1599"]}
{"title": "An overview of Larch/C++: Behavioral specifications for C++ modules\n", "abstract": " An overview of the behavioral interface specification language Larch/C++ is presented. The features of Larch/C++ used to specify the behavior of C++ functions and classes, including subclasses, are described, with examples. Comparisons are made with other object-oriented specification languages. An innovation in Larch/C++ is the use of examples in function specifications.", "num_citations": "85\n", "authors": ["1599"]}
{"title": "JML\u2019s rich, inherited specifications for behavioral subtypes\n", "abstract": " The Java Modeling Language (JML) is used to specify detailed designs for Java classes and interfaces. It has a particularly rich set of features for specifying methods. This paper describes those features, with particular emphasis on the features related to specification inheritance. It shows how specification inheritance in JML forces behavioral subtyping, through a discussion of semantics and examples. It also describes a notion of modular reasoning based on static type information, supertype abstraction, which is made valid in JML by methodological restrictions on invariants, history constraints, and initially clauses and by behavioral subtyping.", "num_citations": "84\n", "authors": ["1599"]}
{"title": "Typechecking and modules for multi-methods\n", "abstract": " Two major obstacles hindering the wider acceptance of multi-methods are concerns over the lack of encapsulation and modularity and the absence of static typechecking in existing multi-method-based languages. This paper addresses both of these problems. We present a polynomial-time static typechecking algorithm that checks the conformance, completeness, and consistency of a group of method implementations with respect to declared message signatures. This algorithm improves on previous algorithms by handling separate type and inheritance hierarchies, abstract classes, and graph-based method lookup semantics. We also present a module system that enables independently-developed code to be fully encapsulated and statically typechecked on a per-module basis. To guarantee that potential conflicts between independently-developed modules have been resolved, a simple well-formedness\u00a0\u2026", "num_citations": "80\n", "authors": ["1599"]}
{"title": "Enhancing the pre-and postcondition technique for more expressive specifications\n", "abstract": " We describe enhancements to the pre- and postcondition technique that help specifications convey information more effectively. Some enhancements allow one to specify redundant information that can be used in \u201cdebugging\u201d specifications. For instance, adding examples to a specification gives redundant information that may aid some readers, and can also be used to help ensure that the specification says what is intended. Other enhancements allow improvements in frame axioms for object-oriented (OO) procedures, better treatments of exceptions and inheritance, and improved support for incompletely-specified types. Many of these enhancements were invented by other authors, but are not widely known. They have all been integrated into Larch/C+++, a Larchstyle behavioral interface specification language for C++. However, such enhancements could also be used to make other specification\u00a0\u2026", "num_citations": "77\n", "authors": ["1599"]}
{"title": "Desugaring JML method specifications\n", "abstract": " JML, which stands for``Java Modeling Language,''is a behavioral interface specification language (BISL) designed to specify Java modules. JML features a great deal of syntactic sugar that is designed to make method specifications more expressive. This paper presents a desugaring process that boils down all of the syntactic sugars in JML method specifications into a much simpler form. This desugaring will help one understand the meaning of these sugars, for example for use in program verification. It may also help manipulation of JML method specifications by tools.", "num_citations": "66\n", "authors": ["1599"]}
{"title": "Concepts of behavioral subtyping and a sketch of their extension to component-based systems\n", "abstract": " Object-oriented systems are able to treat objects indirectly by message passing. This allows them to manipulate objects without knowing their exact runtime type. Behavioral subtyping helps one reason in a modular fashion about such programs. That is, one can reason based on the static types of expressions in a program, provided that static types are upper bounds of the runtime types in a subtyping preorder, and that subtypes satisfy the conditions of behavioral subtyping. We survey various notions of behavioral subtyping proposed in the literature for objectoriented programming. We also sketch a notion of behavioral subtyping for objects in component-based systems, where reasoning about the events that a component can raise is important.", "num_citations": "65\n", "authors": ["1599"]}
{"title": "Verifying object-oriented programs that use subtypes\n", "abstract": " Object-oriented programming languages like Smalltalk-80 have a generic invocation mechanism that allows code to work on instances of many different types. In this dissertation we show how to write formal specifications of functions that use generic invocation and give a logic for verifying applicative programs that use generic invocation. Our reasoning techniques formalize informal methods based on the use of subtypes. We give a formal definition of subtype relationships among immutable abstract types, including nondeterministic and incompletely specified types. This definition captures the intuition that each instance of a subtype behaves like some instance of that types supertypes. We show how to write specifications of functions that use generic invocation by allowing instances of subtypes as arguments. We also simplify verification by separately checking that each expressions value is an instance of a subtype of the expressions type. Keywords Programming languages, Object-oriented, Smalltalk, Specification, Subtype, Type checking, Abstract type, Generic invocation, Message passing, Inclusion polymorphism.Descriptors:", "num_citations": "65\n", "authors": ["1599"]}
{"title": "Argus Reference Manual.\n", "abstract": " Argus is an experimental languagesystem designed to support the construction and execution of distributed programs. Argus is intended to support only a subset of the applications that could benefit from being implemented by a distributed program. Two properties distinguish these applications they make use of on-line data that must remain consistent in spite of concurrency and hardware failures, and they provide services under real-time constraints that are not severe. Examples of such applications are office automation systems and banking systems. Argus is based on CLU. It is largely an extension of CLU, but there are number of differences. Like CLU, Argus provides procedures for procedural abstraction, iterators for control abstraction, and clusters for data abstraction. In addition, Argus provides guardians that encapsulate and control access to one or more resources. Argus also provides equate modules as a convenient way to refer to constants. As in CLU, modules may be parameterized, so that a single module can define a class of related abstractions. Keywords Fault tolerant computing.Descriptors:", "num_citations": "63\n", "authors": ["1599"]}
{"title": "Safely creating correct subclasses without seeing superclass code\n", "abstract": " A major problem for object-oriented frameworks and class libraries is how to provide enough information about a superclass, so programmers can safely create new subclasses without giving away the superclass's code. Code inherited from the superclass can call down to methods of the subclass, which may cause nontermination or unexpected behavior. We describe a reasoning technique that allows programmers, who have no access to the code of the superclass, to determine both how to safely override the superclass's methods and when it is safe to call them. The technique consists of a set of rules and some new forms of specification. Part of the specification would be generated automatically by a tool, a prototype of which is planned for the formal specification language JML. We give an example to show the kinds of problems caused by method overrides and how our technique can be used to avoid them. We\u00a0\u2026", "num_citations": "62\n", "authors": ["1599"]}
{"title": "The Larch/Smalltalk Interface Specification Language\n", "abstract": " Object-oriented programming languages, such as Smalltalk, help to build reusable program modules. The reuse of program modules requires adequate documentation\u2014formal or informal. Larch/Smalltalk is a formal specification language for specifying such reusable Smalltalk modules. Larch/Smalltalk firmly separates specification from implementation. In Larch/Smalltalk the unit of specification is an abstract data type, which is an abstraction of the behavior produced by one or more Smalltalk classes, A type can be a subtype of other types, which allows types to be organized based on specified behavior, and also allows for inheritance of their specifications. Larch/Smalltalk specifications are developed using specification tools integrated in the Smalltalk programming environment.", "num_citations": "58\n", "authors": ["1599"]}
{"title": "Translucid contracts: Expressive specification and modular verification for aspect-oriented interfaces\n", "abstract": " As aspect-oriented (AO) programming techniques become more widely used, their use in critical systems such as aircraft and telephone networks, will become more widespread. However, careful reasoning about AO code seems difficult because:(1) advice may apply in too many places, and (2) standard specification techniques do not limit the control effects of advice. Commonly used black box specification techniques cannot easily specify control effects, such as advice that does not proceed to the advised code. In this work we avoid the first problem by using Ptolemy, a language with explicit event announcement. To solve the second problem we give a simple and understandable specification technique, translucid contracts, that not only allows programmers to write modular specifications for advice and advised code, but also allows them to reason about the code's control effects. We show that translucid contracts\u00a0\u2026", "num_citations": "53\n", "authors": ["1599"]}
{"title": "MiniMAO1: Investigating the semantics of proceed\n", "abstract": " This paper describes MiniMAO 1, a core aspect-oriented calculus. Unlike previous aspect-oriented calculi, it allows around advice to change the target object of an advised operation before proceeding. MiniMAO 1 accurately models the ways AspectJ allows changing the target object, eg, at call join points. Practical uses for changing the target object using advice include proxies and other wrapper objects.", "num_citations": "53\n", "authors": ["1599"]}
{"title": "Multiple dispatch as dispatch on tuples\n", "abstract": " Many popular object-oriented programming languages, such as C++, Smalltalk-80, Java, and Eiffel, do not support multiple dispatch. Yet without multiple dispatch, programmers find it difficult to express binary methods and design patterns such as the \"visitor\" pattern. We describe a new, simple, and orthogonal way to add multimethods to single-dispatch object-oriented languages, without affecting existing code. The new mechanism also clarifies many differences between single and multiple dispatch.", "num_citations": "51\n", "authors": ["1599"]}
{"title": "Information hiding and visibility in interface specifications\n", "abstract": " Information hiding controls which parts of a class are visible to non-privileged and privileged clients (e.g., subclasses). This affects detailed design specifications in two ways. First, specifications should not expose hidden class members. As noted in previous work, this is important because such hidden members are not meaningful to all clients. But it also allows changes to hidden implementation details without invalidating correctness proofs for client code, which is important for maintaining verified programs. Second, to enable sound modular reasoning, certain specifications must be visible to clients. We present rules for information hiding in specifications for Java-like languages, and demonstrate their application to the specification language JML. These rules restrict proof obligations to only mention visible class members, but retain soundness. This allows maintenance of implementations and their specifications\u00a0\u2026", "num_citations": "48\n", "authors": ["1599"]}
{"title": "MiniMAO1: An imperative core language for studying aspect-oriented reasoning\n", "abstract": " This paper describes MiniMAO1, a core aspect-oriented language. Unlike previous aspect-oriented calculi and core languages, MiniMAO1allows around advice to change the target object of an advised operation before proceeding. MiniMAO1accurately models the ways AspectJ allows changing the target object, e.g., at call join points. Practical uses for changing the target object using advice include proxies and other wrapper objects.MiniMAO1was designed to serve as a core language for studying modular specification and verification in the aspect-oriented paradigm. To this end MiniMAO1\u2022has an imperative, reference-based semantics,\u2022models the control-flow effects of changing target object bindings with advice, and\u2022has a safe static type system. The first two features make MiniMAO1\u00a0suitable for the study of aspect-oriented mechanisms, such as those found in AspectJ. These features are important for studying\u00a0\u2026", "num_citations": "48\n", "authors": ["1599"]}
{"title": "3x+ 1 search programs\n", "abstract": " Algorithms for computing peaks of certain statistics related to the 3x+1 problem are described, along with data on such peaks up to 56 trillion (5.6\u00d71013). The data result from several years of computation. The design of the algorithms used illustrates several techniques for program optimization.", "num_citations": "42\n", "authors": ["1599"]}
{"title": "The design of SafeJML, a specification language for SCJ with support for WCET specification\n", "abstract": " Safety-Critical Java (SCJ) is a dialect of Java that allows programmers to implement safety-critical systems, such as software to control airplanes, medical devices, and nuclear power plants. SafeJML extends the Java Modeling Language (JML) to allow specification and checking of both functional and timing constraints for SCJ programs. When our design of the SafeJML is implemented, it will help check the correctness of detailed designs, including timing for real-time systems written in SCJ.", "num_citations": "34\n", "authors": ["1599"]}
{"title": "Preliminary Design of Larch/C+\n", "abstract": " We describe the problems encountered in the design of Larch/C++, especially its object-oriented features. We discuss a range of possible solutions to these problems, and give the rationale for our particular solutions. We also present examples of Larch/C++ specifications and discuss differences from Larch/C.", "num_citations": "32\n", "authors": ["1599"]}
{"title": "Semantic clone detection using method ioe-behavior\n", "abstract": " This paper presents an algorithm for the detection of semantic clones in Java methods. Semantic clones are defined as functionally-identical code fragments. Our detection process operates on the premise that if two code fragments are semantic clones, then their input-output behavior would be identical. We adopt a wholistic approach to the definition of input-output behavior by including not only the parameters and return values of methods; but also their effects, as reflected in the pre- and post-states of the heap. We refer to this as a method's IOE-behavior (input, output and effects).", "num_citations": "31\n", "authors": ["1599"]}
{"title": "Preliminary design of JML\n", "abstract": " TR# 98-06t June 1998, revised July, November 1998, January, April, June, July, August, December 1999, February, May, July, December 2000 February, April, May, August 2001 June 2002, August, October, December 2002", "num_citations": "30\n", "authors": ["1599"]}
{"title": "BeCecil, A core object-oriented language with block structure and multimethods: Semantics and typing\n", "abstract": " We present and analyze the semantics and static type system for BeCecil, a theoretical (core) language with multimethods. BeCecil is a simple and orthogonal version of object-oriented languages like Cecil, CLOS, and Dylan. BeCecil has a new, simple mechanism for information hiding, which allows subclassing and yet can preserve representation invariants. BeCecil is also block-structured; within a block, one can extend a generic function with new multimethods, which may come from other generic functions. The inheritance relationships of objects may be extended in any block, and are statically scoped. The type system separates classes from types, and inheritance from subtyping. Subtype relationships are also extensible and statically scoped. These features combine to make BeCecil unusually expressive, while still allowing static typechecking.", "num_citations": "30\n", "authors": ["1599"]}
{"title": "The java modeling language (jml)\n", "abstract": " Program verification has been a topic of research interest far into the history of computing science. Today, it is still a key research focus, see eg, Hoare\u2019s Verified Compiler Grand Challenge and the Verified Software Initiative, whose flagship activities are the series of VSTTE workshops (Verified Software: Theory, Tools, and Experiments) and the launch of a series of verification competitions. A main facet in this effort is the ability to formally express properties that must be verified. Building on a long line of work in formal methods for reasoning about behavioral specifications of programs, several recent languages balance the desire for completeness and the pragmatics of checkability. In the context of the object-oriented programming paradigm, the Java Modeling Language (JML) is the most widely-adopted specification language in the Java formal methods research community.The Java Modeling Language (JML) is a formal, behavioral specification language for Java. It describes detailed designs of Java classes and interfaces using pre-and postconditions, invariants, and several more advanced features. JML is used as a common language for many research projects and tools, including a runtime assertion checker (jmlc), tools to help unit testing (jmlunit), an extended static checker (ESC/Java), and several formal verification tools (eg, LOOP, JACK, KRAKATOA, Jive, and KeY). JML is seeing some use in industry, particularly for financial applications on Java smart cards and for verifying some security properties of a computer-based voting system. Since JML is widely understood in the formal methods research community, it provides a shared\u00a0\u2026", "num_citations": "28\n", "authors": ["1599"]}
{"title": "Spectators and assistants: Enabling modular aspect-oriented reasoning\n", "abstract": " In current aspect-oriented languages, separate compilation and modular reasoning are not possible. This detracts from comprehensibility and impedes maintenance efforts. We describe language features that would allow aspect-oriented languages to provide separate compilation and modular reasoning. We demonstrate that existing programs written in AspectJ can be easily rewritten using these features.", "num_citations": "28\n", "authors": ["1599"]}
{"title": "The JML and JUnit way of unit testing and its implementation\n", "abstract": " Writing unit test code is labor-intensive, hence it is often not done as an integral part of programming. However, unit testing is a practical approach to increasing the correctness and quality of software; for example, Extreme Programming relies on frequent unit testing. In this paper we present a new approach that makes writing unit tests easier. It uses a formal specification language\u2019s runtime assertion checker to decide whether methods are working correctly; thus code to decide whether tests pass or fail is automatically produced from specifications. Our tool combines this testing code with hand-written test data to execute tests. Therefore, instead of writing testing code, the programmer writes formal specifications (eg, preand postconditions). This makes the programmer\u2019s task easier, because specifications are more concise and abstract than the equivalent test code, and hence more readable and maintainable. Furthermore, by using specifications in testing, specification errors are quickly discovered, so the specifications are more likely to provide useful documentation and inputs to other tools. In this paper we describe an implementation using the Java Modeling Language (JML) and the JUnit testing framework, but the approach could be easily implemented with other combinations of formal specification languages and unit testing tools.", "num_citations": "27\n", "authors": ["1599"]}
{"title": "Executing formal specifications with concurrent constraint programming\n", "abstract": " We have implemented a technique for execution of formal, model-based specifications. The specifications we can execute are written at a level of abstraction that is close to that used in nonexecutable specifications. The specification abstractions supported by our execution technique include using quantified assertions to directly construct post-state values, and indirect definitions of post-state values (definitions that do not use equality). Our approach is based on translating specifications to the concurrent constraint programming language AKL. While there are, of course, expressible assertions that are not executable, our technique is amenable to any formal specification language based on a finite number of intrinsic types and pre- and postcondition assertions.", "num_citations": "26\n", "authors": ["1599"]}
{"title": "Modular verification of object-oriented programs with subtypes\n", "abstract": " Object-oriented programming languages like Smalltalk-80 have a message passing mechanism that allows code to work on instances of many different types. Techniques for the formal specification of such polymorphic functions and abstract types are described, as well as a logic for verifying programs that use message passing but not object mutation or assignment. The reasoning techniques formalize informal methods based on the use of subtypes. A formal definition of subtype relationships among abstract types whose objects have no time-varying state but may be nondeterministic or incompletely specified is given. This definition captures the intuition that each instance of a subtype behaves like some instance of that type's supertypes. Specifications of polymorphic functions are written by allowing instances of subtypes as arguments. Restrictions on the way that abstract types are specified ensure that such function specifications are meaningful and do not have to be rewritten when new subtypes are specified. Verification consists of showing that the specified relation among types has certain semantic properties, that each expression's value is an instance of a subtype of the expression's type, and a proof of correctness that ignores subtyping.", "num_citations": "24\n", "authors": ["1599"]}
{"title": "Optimizing JML features compilation in ajmlc using aspect-oriented refactorings\n", "abstract": " In previous work we presented a new JML compiler, ajmlc, which generates aspects that enforce preconditions, postconditions, and invariants. Although this compiler provides benefits of source-code modularity and small bytecode size and running time, there is still a need for optimization of bytecode size and running time. To do this optimization while preserving the semantics of the resulting code, we optimize using refactorings based on AspectJ programming laws. To this end we present optimization refactorings and an empirical analysis showing the resulting improvements.", "num_citations": "22\n", "authors": ["1599"]}
{"title": "Tutorial on jml, the java modeling language\n", "abstract": " The Java Modeling Language (JML) is widely used in academic research as a common language for formal methods tools that work with Java. JML is a design by contract language that can be used to specify detailed designs of Java programs, frameworks, and class libraries. Over twenty research groups worldwide have built several tools for checking code and finding bugs (see jmlspecs. org).", "num_citations": "22\n", "authors": ["1599"]}
{"title": "A complete algebraic characterization of behavioral subtyping\n", "abstract": " We present a model-theoretic study of correct behavioral subtyping for first-order, deterministic, abstract data types with immutable objects. For such types, we give a new algebraic criterion for proving correct behavioral subtyping that is both necessary and sufficient. This proof technique handles incomplete specifications by allowing proofs of correct behavioral subtyping to be based on comparison with one of several paradigmatic models. It compares a model to a selected paradigm with a generalization of the usual notion of simulation relations. This generalization is necessary for specifications that are not term-generated and that use multiple dispatch. However, we also show that the usual notion of simulation gives a necessary and sufficient proof technique for the special cases of term-generated specifications and specifications that only use single dispatch.", "num_citations": "22\n", "authors": ["1599"]}
{"title": "Quantified, typed events for improved separation of concerns\n", "abstract": " Implicit invocation and aspect-oriented languages provide related but distinct mechanisms for separation of concerns. Implicit invocation languages have explicitly announced events, which runs registered observer methods. Aspect-oriented languages have implicitly announced events, called``join points,''which run method-like but more powerful advice. A limitation of implicit invocation languages is their inability to refer to a large set of events succinctly. They also lack the expressive power of aspect-oriented advice, and require code to manage event registration and announcement. Aspect-oriented languages also have several limitations, including the potential for fragile dependence on syntactic structure that may hurt maintainability, limits in the set of join points and the reflective contextual information that they make available. Quantified, typed events solve all these problems. They extend implicit invocation languages with a key idea from aspect-oriented languages: the ability to quantify over events (join points). Programmers declare named event types that contain information about the names and types of event arguments (exposed context). An event type declaratively identifies an expression as an event. This event type can then be used to quantify over all such events. Event types reduce the coupling between the observers and the set of events, and similarly between the advising and advised code.", "num_citations": "21\n", "authors": ["1599"]}
{"title": "Parameterized aspect calculus: A core calculus for the direct study of aspect-oriented languages\n", "abstract": " Formal study of aspect-oriented languages is difficult because current theoretical models provide a range of features that is too limited and rely on encodings using lower-level abstractions, which involve a cumbersome level of indirection. We present a calculus, based on Abadi and Cardelli  s object calculus, that explicitly models a base language and a variety of point cut description languages. This explicit modeling makes clear the aspect-oriented features of the calculus by removing the indirection of some existing models. We demonstrate the generality of our calculus by presenting models for AspectJ  s open classes and advice, and HyperJ  s compositions, and sketching a model for DemeterJ  s adaptive methods.", "num_citations": "21\n", "authors": ["1599"]}
{"title": "Typed homomorphic relations extended with subtypes\n", "abstract": " Typed homomorphic relations on heterogeneous algebras are generalized to allow relationships between elements in the carrier sets of different types. Such relations are needed for the model theory of incomplete, hierarchical specifications with subtypes. Typed logical relations are generalized similarly. These tools help give a simple model-theoretic account of subtyping among abstract data types as observed by terms of a simply-typed lambda-calculus with subtypes.", "num_citations": "20\n", "authors": ["1599"]}
{"title": "Jsctracker: A semantic clone detection tool for java code\n", "abstract": " This paper presents a tool and algorithm for the detection of semantic clones in Java methods. For our purpose, semantic clones are defined as functionally identical code fragments. Thus, our detection process operates on the premise that if two code fragments are semantic clones, then their input-output behavior would be identical. We adopt a wholistic approach to the definition of input-output behavior by including not only the return values of methods; but also their effects as reflected in the pre-and post-states of the heap. We refer to this as a method\u2019s IOE (input, output and effects)-behavior. Our tool and algorithm are tested in a small case study using the open source database management software", "num_citations": "19\n", "authors": ["1599"]}
{"title": "A contextual interpretation of undefinedness for runtime assertion checking\n", "abstract": " Runtime assertion checkers and static checking and verification tools must all cope with the well-known undefinedness problem of logic. This problem is particularly severe for runtime assertion checkers, since, in addition to the possibility of exceptions and errors, runtime assertion checkers must cope with non-executable expressions (such as certain quantified expressions). This paper describes how the runtime assertion checker of the Java Modeling Language (JML) copes with undefinedness. JML is interesting because it attempts to satisfy the needs of a wide range of tools; besides runtime assertion checking, these include static checking tools (like ESC/Java) and static verification tools. These other tools use theorem provers that are based on standard (two-valued) logic and hence use the underspecified total functions semantics for assertions. That semantics validates all the rules of standard logic by\u00a0\u2026", "num_citations": "19\n", "authors": ["1599"]}
{"title": "Integrating random testing with constraints for improved efficiency and diversity\n", "abstract": " Random testing can be fully automated, eliminates subjectiveness in constructing test cases, and increases the diversity of test data. However, randomly generated tests may not satisfy program's assumptions (eg, method preconditions). While constraint solving can satisfy such assumptions, it does not necessarily generate diverse tests and is hard to apply to large programs. We blend these techniques by extending random testing with constraint solving, improving the efficiency of generating valid test data while preserving diversity. For domains such as objects, we generate input values randomly; however, for values of finite domains such as integers, we represent test data generation as a constraint satisfaction problem by solving constraints extracted from the precondition of the method under test. We also increased the diversity of constraint-based solutions by incorporating randomness into the solver's enumeration process. In our experimental evaluation we observed an average improvement of 80 times without decreasing test case diversity, measured in terms of the time needed to generate a given number of test cases.", "num_citations": "18\n", "authors": ["1599"]}
{"title": "The behavior-realization adjunction and generalized homomorphic relations\n", "abstract": " A model theory for proving correctness of abstract data types is developed within the framework of the behavior-realization adjunction. To allow for incomplete specifications, proof-of-correctness is based on comparison to one of several paradigmatic models. For making such comparisons, the notions of the behavior and realization relations, and their duals are developed. These relations are used to give the first exact algebraic characterization of behavioral reduction and equivalence for algebras that are not term-generated.", "num_citations": "18\n", "authors": ["1599"]}
{"title": "Subtyping, modular specification, and modular verification for applicative object-oriented programs\n", "abstract": " We present a formal specification language and a formal verification logic for a simple object-oriented programming language. The language is applicative and statically typed, and supports subtyping and message-passing. The verification logic relies on a behavioral notion of subtyping that captures the intuition that a subtype behaves like its supertypes. We give a formal definition for legal subtype relations, based on the specified behavior of objects, and show that this definition is sufficient to ensure the soundness of the verification logic. The verification logic reflects the way programmers reason informally about object-oriented programs, in that it allows them to use static type information, which avoids the need to consider all possible run-time subtypes. We also show that the logic does not require reverification of unchanged code when legal subtypes are added to a program.", "num_citations": "18\n", "authors": ["1599"]}
{"title": "A jml tutorial: Modular specification and verification of functional behavior for java\n", "abstract": " JML, the Java Modeling Language, is the lingua franca of researchers working on specification and verification techniques and tools for Java. There are over 23 research groups worldwide working on various aspects of the JML project. These groups have built a large suite of tools for automated checking and verification (see http://jmlspecs.org).", "num_citations": "17\n", "authors": ["1599"]}
{"title": "Not a Number of Floating Point Problems.\n", "abstract": " Floating-point numbers and floating-point arithmetic contain some surprising pitfalls. In particular, the widely-adopted IEEE 754 standard contains a number that is \u201cnot a number,\u201d and thus has some surprising properties. One has to be extremely careful in writing assertions about floating point numbers, to avoid these pitfalls. This column describes the problems and how a language might eliminate them.", "num_citations": "17\n", "authors": ["1599"]}
{"title": "Formal techniques for Java programs\n", "abstract": " This report explains the motivation for a workshop on formal techniques for Java programs. It gives an overview of the presentations and summarizes the results of the working groups. Furthermore, it contains abstracts of the contributed papers.", "num_citations": "17\n", "authors": ["1599"]}
{"title": "Subtyping for mutable types in object-oriented programming languages\n", "abstract": " Subtype relationships in object-oriented programming languages are studied to aid code reuse and reasoning about programs that use subtype polymorphism. We de ne what it means for one abstract data type to be a subtype of another. This de nition allows for both mutation and aliasing. This work gives intuition for programmers and guidance to language designers.", "num_citations": "16\n", "authors": ["1599"]}
{"title": "Tisa: A language design and modular verification technique for temporal policies in web services\n", "abstract": " Web services are distributed software components, that are decoupled from each other using interfaces with specified functional behaviors. However, such behavioral specifications are insufficient to demonstrate compliance with certain temporal non-functional policies. An example is demonstrating that a patient\u2019s health-related query sent to a health care service is answered only by a doctor (and not by a secretary). Demonstrating compliance with such policies is important for satisfying governmental privacy regulations. It is often necessary to expose the internals of the web service implementation for demonstrating such compliance, which may compromise modularity. In this work, we provide a language design that enables such demonstrations, while hiding majority of the service\u2019s source code. The key idea is to use greybox specifications to allow service providers to selectively hide and expose parts of\u00a0\u2026", "num_citations": "15\n", "authors": ["1599"]}
{"title": "The direct execution of SPECS-C++: A model-based specification language for C++ classes\n", "abstract": " Executable specification languages may be the key to more widespread use of formal methods in software production. However, the expressiveness of executable specification languages is typically much less than that of non-executable specification languages such as VDM or Z. Thus, specifiers are forced to work at a lower level of abstraction to gain the advantage of executability. Additionally, specifications are typically made executable by translating them to a programming language, so errors in the specification can only be detected as errors in the resulting code. This paper presents a technique for directly executing specifications written in SPECS-C++, a model-based specification language for C++ classes. As SPECS-C++ has much in common with the implicit subset of VDM, this technique is equally applicable to implicit VDM specifications. Standard ML code for the interpreter and the example used in the paper appear in the appendices.", "num_citations": "15\n", "authors": ["1599"]}
{"title": "Prettyprinting styles for various languages\n", "abstract": " There are three basic styles of prettyprinting in current usage. I present a simple hypothesis that governs which style is commonly found for any given language, based on the observation of several programming languages.", "num_citations": "15\n", "authors": ["1599"]}
{"title": "Static verification of PtolemyRely programs using OpenJML\n", "abstract": " In the PtolemyRely language event types define events that, when announced, trigger the execution of handlers, passing along the triggering piece of code for its eventual execution.", "num_citations": "14\n", "authors": ["1599"]}
{"title": "Lessons from the JML Project\n", "abstract": " To have impact, a grand challenge should provide a way for diverse research to be integrated in a synergistic fashion. Synergy in the JML project comes from a shared specification language, and thus holds several lessons for the verifying compiler grand challenge. An important lesson is that the project should focus considerable resources on specification language design, which still contains many open research problems. Another important lesson is that, to support such a specification language, the project needs to involve groups doing research on extensible compilers and integrated development environments.", "num_citations": "14\n", "authors": ["1599"]}
{"title": "Preliminary definition of core JML\n", "abstract": " The JML specification language has evolved over a number of years and several variations/subsets have been formalized, mainly in the context of prototype systems for runtime and static verification. This document records the preliminary definition of basic semantic concepts for a core fragment of JML. It is intended to facilitate investigation of new features and improvement in interoperability between tools. The formalization is based on a denotational semantics and has been encoded in the PVS theorem prover.", "num_citations": "14\n", "authors": ["1599"]}
{"title": "Formal semantics for SA style data flow diagram specification languages\n", "abstract": " Using operational semantic techniques, we present a formal semantics for an extended variant of structured analysis style data flow diagrams. This semantics is intended to serve as a semantic foundation for many different specification languages that specify concurrent systems using a graphical notation similar to data flow diagrams. Besides allowing one to specify how information is processed, it allows one to specify the dynamic behavior of a concurrent system. We discuss various semantic issues, including the need for a twostep firing rule and how the semantics supports the notion of refinement.", "num_citations": "14\n", "authors": ["1599"]}
{"title": "ACL--Eliminating Parameter Aliasing with Dynamic Dispatch\n", "abstract": " We have designed and prototyped a new approach for eliminating reference parameter aliases. This approach allows procedure calls with overlapping call-by-reference parameters, but guarantees that procedure bodies are alias-free. It involves writing multiple bodies for a procedure: up to one body for each possible aliasing combination. Procedure calls are dispatched to the appropriate procedure body based on the alias combination that occurs among the actual parameters and imported global variables; errors are generated if there is no corresponding body. This approach makes writing verifiable client code simpler, since clients do not need to write code to determine the aliasing combination among actuals. Furthermore, since procedure bodies are free of aliases, their static analysis and verification is easier. The prototype language we have designed to explore these ideas incorporates some features to limit the number of alternative procedure bodies that a programmer must write.", "num_citations": "14\n", "authors": ["1599"]}
{"title": "Modular contracts with procedures, annotations, pointcuts and advice\n", "abstract": " There are numerous mechanisms for modularizing design by contract at the source code level. Three mechanisms have been the main focus of attention, metadata annotations, pointcuts and advice. The latter two are well-known aspect-oriented programming mechanisms, and according to the literature, fare better in achieving contract modularization. However, previous efforts aimed at supporting contract modularity actually hindered it. In this paper we report an enhanced use of pointcuts and advice, and show how crosscut programming interfaces (XPIs) can significantly improve contract modularity. In addition, we also discuss how these XPIs can be used together with annotations to tackle the pointcut fragility problem and minimize the limited enforcement of XPI interface rules. We compare our approach with the literature\u2019s in terms of code locality, well-defined interfaces, reusability, changeability, fragility, and pluggability.", "num_citations": "13\n", "authors": ["1599"]}
{"title": "Translucid contracts for aspect-oriented interfaces\n", "abstract": " There is some consensus in the aspect-oriented community that a notion of interface between joinpoints and advice may be necessary for improved modularity of aspect-oriented programs, for modular reasoning, and for overcoming pointcut fragility. Different approaches for adding such interfaces, such as aspect-aware interfaces, pointcut interfaces, crosscutting interfaces, explicit joinpoints, quantified typed events, open modules, and joinpoint types decouple aspects and base code, enhancing modularity. However, existing work has not shown how one can write specifications for such interfaces that will actually allow modular reasoning when aspects and base code evolve independently, and that are capable of specifying control effects, such as when advice does not proceed. The main contribution of this work is a specification technique that allows programmers to write modular specification of such interfaces and that allows one to understand such control effects. We show that such specifications allow typical interaction patterns, and interesting control effects to be understood and enforced. We illustrate our techniques via an extension of Ptolemy, but we also show that our ideas can be applied in a straightforward manner to other notions of joinpoint interfaces, eg the crosscutting interfaces.", "num_citations": "13\n", "authors": ["1599"]}
{"title": "Extensions of the theory of observational purity and a practical design for JML\n", "abstract": " To prevent erratic behavior during runtime checking, JML only allows assertions to call pure, ie, side-effect free, methods. However, JML\u2019s notion of purity checking is too conservative. For example, Object\u2019s equals method needs to be used in assertions, but some classes use side effects in their equals method to maintain hidden caches or to trigger lazy evaluation, and so these methods cannot be pure in JML\u2019s sense. To handle such cases JML and similar interface specification languages need a less conservative notion of pure methods. In this paper we apply and slightly extend the existing theory of \u201cobservationally pure\u201d methods to JML, and explain our language design. This design is practical and accommodates common uses. Our extension of current theory provides appropriate encapsulation combined with inheritance, invariants, method specifications, frame conditions, secret helper methods, and multiple sets of secret state locations. We also introduce a semantics for static analysis that preserves correctness without imposing non-interference.", "num_citations": "13\n", "authors": ["1599"]}
{"title": "Extensible dynamic analysis for jml: A case study with loop annotations\n", "abstract": " Modern programming languages, such as Java, are large and complex, as are practically useful behavioral interface specification languages that extend them, such as JML. Their size and complexity make it difficult for researchers to build dynamic analysis tools, such as runtime assertion checkers. Researchers wishing to experiment with a small change to a specification language or a dynamic analysis face a prohibitive amount of work before they can run experiments. Even if a research prototype is built, it is difficult to keep it current with rapidly evolving languages, since the changes to the underlying compiler infrastructure are not easily separated from that infrastructure. However, extensible dynamic analysis tools can be written more easily with modern attribute grammar tools, in particular with JastAdd. We describe a small case study that shows how using JastAdd eases development of a runtime assertion checker for the specification language JML.", "num_citations": "13\n", "authors": ["1599"]}
{"title": "Challenge benchmarks for verification of real-time programs\n", "abstract": " Real-time systems, and in particular safety-critical systems, are a rich source of challenges for the program verification community as software errors can have catastrophic consequences. Unfortunately, it is nearly impossible to find representative safety-critical programs in the public domain. This has been significant impediment to research in the field, as it is very difficult to validate new ideas or techniques experimentally. This paper presents open challenges for verification of real-time systems in the context of the Real-time Specification for Java. But, our main contribution is a family of programs, called CDx, which we present as an open source benchmark for the verification community.", "num_citations": "12\n", "authors": ["1599"]}
{"title": "An Executable Semantics for a Formalized Data Flow Diagram Specification Language\n", "abstract": " While traditional Data Flow Diagrams (DFDs) are popular, they lack the formality needed in a good specification technique. We provide an executable semantics for a subset of RT-SPECS, a formalization of DFDs, using the programming language Standard ML. RT-SPECS is a formal notation for specifying concurrent and real-time software that relies on model-based specification of abstract datatypes. Processes are specified using assertions rather than algorithms. Because our semantics of RT-SPECS is written in SML, it is also an interpreter, yielding a directly executable specification language.", "num_citations": "11\n", "authors": ["1599"]}
{"title": "Automated translation of VDM to JML-annotated Java\n", "abstract": " When a system specified using the Vienna Development Method (VDM) is realised using code-generation, no guarantees are currently made about the correctness of the generated code. In this paper, we improve code-generation of VDM models by taking contract-based elements such as invariants and pre- and postconditions into account during the code-generation process. The contract-based elements of the Vienna Development Method Specification Language (VDM-SL) are translated into corresponding constructs in the Java Modelling Language (JML) and used to validate the generated code against the properties of the VDM model. VDM-SL and JML are both Design-by-Contract (DbC) languages, with the difference that VDM-SL supports abstract modelling and system specification, while JML is used for detailed specification of Java classes and interfaces. We describe the semantic differences\u00a0\u2026", "num_citations": "10\n", "authors": ["1599"]}
{"title": "On the interplay of exception handling and design by contract: an aspect-oriented recovery approach\n", "abstract": " Design by Contract (DbC) is a technique for developing and improving functional software correctness through definition of\" contracts\" between client classes and their suppliers. Such contracts are enforced during runtime and if any of them is violated a runtime error should occur. Runtime assertions checkers (RACs) are a well-known technique that enforces such contracts. Although they are largely used to implement the DbC technique in contemporary languages, like Java, studies have shown that characteristics of contemporary exception handling mechanisms can discard contract violations detected by RACs. As a result, a contract violation may not be reflected in a runtime error, breaking the supporting hypothesis of DbC. This paper presents an error recovery technique for RACs that tackles such limitations. This technique relies on aspect-oriented programming in order to extend the functionalities of existing\u00a0\u2026", "num_citations": "10\n", "authors": ["1599"]}
{"title": "Applying translucid contracts for modular reasoning about aspect and object oriented events\n", "abstract": " The Implicit Invocation (II) architectural style improves modularity and is promoted by aspect-oriented (AO) languages and design patterns like Observer. However, it makes modular reasoning difficult, especially when reasoning about control effects of the advised code (subject). Our language Ptolemy, which was inspired by II languages, uses translucid contracts for modular reasoning about the control effects; however, this reasoning relies on Ptolemy's event model, which has explicit event announcement and declared event types. In this paper we investigate how to apply translucid contracts to reasoning about events in other AO languages and even non-AO languages like C#", "num_citations": "10\n", "authors": ["1599"]}
{"title": "Multiple concerns in aspect-oriented language design: a language engineering approach to balancing benefits, with examples\n", "abstract": " Some in the aspect-oriented community view a programming language as aspect-oriented only if it allows programmers to perfectly eliminate scattering and tangling. That is, languages that do not allow programmers to have maximal quantification and perfect obliviousness are not viewed as aspect-oriented. On the other hand, some detractors of aspect-oriented software development view maximal quantification and perfect obliviousness as causing problems, such as difficulties in reasoning or maintenance.", "num_citations": "10\n", "authors": ["1599"]}
{"title": "An Operational Semantics of Firing Rules for Structured Analysis Style Data Flow Diagrams\n", "abstract": " Using operational semantic techniques, an extended variant of structured analysis style data flow diagrams is given a formal semantics. This semantics allows one to describe both how information is processed and the dynamic behavior of the system. The ability to describe dynamic behavior is an extension to the traditional notion of data flow diagrams. This semantics can serve as a target for giving meaning to specification languages that use a graphical notation similar to data flow diagrams.", "num_citations": "10\n", "authors": ["1599"]}
{"title": "Foundations of object-oriented languages: 2nd workshop report\n", "abstract": " A report on the workshop Foundations of Object-Oriented Languages, Paris, July 1994.", "num_citations": "10\n", "authors": ["1599"]}
{"title": "Optimizing generated aspect-oriented assertion checking code for JML using program transformations: An empirical study\n", "abstract": " The AspectJ JML compiler (ajmlc) explores aspect-oriented programming (AOP) mechanisms to implement JML specifications, such as pre- and postconditions, and enforce them during runtime. This compiler was created to improve source-code modularity. Some experiments were conducted to evaluate the performance of the code generated through ajmlc. Results demonstrated that the strategy of adopting AOP to implement JML specifications is very promising. However, there is still a need for optimization of the generated code\u2019s bytecode size and running time. This paper presents a catalog of transformations which represent the optimizations implemented in the new optimized version of the ajmlc compiler. We employ such transformations to reduce the bytecode size and running time of the code generated through the ajmlc compiler. Aiming at demonstrating the impact of such transformation on the code\u00a0\u2026", "num_citations": "9\n", "authors": ["1599"]}
{"title": "temporaljmlc: A jml runtime assertion checker extension for specification and checking of temporal properties\n", "abstract": " Most mainstream specification languages primarily deal with a program's functional behavior. However, for many common problems, besides the system's functionality, it is necessary to be able to express its temporal properties, such as the necessity of calling methods in a certain order. We have developed temporaljmlc, a tool that performs runtime assertion checking of temporal properties specified in an extension of the Java Modeling Language (JML). The benefit of temporaljmlc is that it allows succinct specification of temporal properties that would otherwise be tedious and difficult to specify.", "num_citations": "9\n", "authors": ["1599"]}
{"title": "Executing formal specifications with constraint programming\n", "abstract": " We have implemented a technique for execution of formal, model-based specifications. The specifications we can execute are written at a level of abstraction that has not previously been supported in executable specification languages. The specification abstractions supported by our execution technique include quantified assertions that reference post-state values, and indirect definitions of post-state values (definitions that do not use equality). Our approach is based on translating specifications to the concurrent constraint programming language AKL. While there are, of course, expressible assertions that are not executable, our technique is amenable to any formal specification language based on a finite number of intrinsic types and pre-and postcondition assertions.", "num_citations": "9\n", "authors": ["1599"]}
{"title": "A Foundation for the Model Theory of Abstract Data Types with Mutation and Aliasing: Preliminary Version\n", "abstract": " To aid in understanding object-oriented programming languages, we present some fundamentals of model theory for languages with mutable abstract data types and aliasing. Our semantics for such languages is parameterized by an algebraic model of all the abstract data types involved in the program, including types with mutable objects. We give an algebraic characterization of simulation between states of such algebraic models. We present a definition of aliasing that is based on the observable behavior of objects.", "num_citations": "9\n", "authors": ["1599"]}
{"title": "Inferring behavioral specifications from large-scale repositories by leveraging collective intelligence\n", "abstract": " Despite their proven benefits, useful, comprehensible, and efficiently checkable specifications are not widely available. This is primarily because writing useful, non-trivial specifications from scratch is too hard, time consuming, and requires expertise that is not broadly available. Furthermore, the lack of specifications for widely-used libraries and frameworks, caused by the high cost of writing specifications, tends to have a snowball effect. Core libraries lack specifications, which makes specifying applications that use them expensive. To contain the skyrocketing development and maintenance costs of high assurance systems, this self-perpetuating cycle must be broken. The labor cost of specifying programs can be significantly decreased via advances in specification inference and synthesis, and this has been attempted several times, but with limited success. We believe that practical specification inference and\u00a0\u2026", "num_citations": "8\n", "authors": ["1599"]}
{"title": "Separating obligations of subjects and handlers for more flexible event type verification\n", "abstract": " Implicit invocation languages, like aspect-oriented languages, automate the Observer pattern, which decouples subjects (base code) from handlers (advice), and then compound them together in the final system. For such languages, event types have been proposed as a way of further decoupling subjects from handlers. In Ptolemy, subjects explicitly announce events at certain program points, and pass the announced piece of code to the handlers for its eventual execution. This implies a mutual dependency between subjects and handlers that should be considered in verification; i.e., verification of subject code should consider the handlers and vice versa.             However, in Ptolemy the event type defines only one obligation that both the handlers and the announced piece of code must satisfy. This limits the flexibility and completeness of verification in Ptolemy. That is, some correct programs cannot be\u00a0\u2026", "num_citations": "8\n", "authors": ["1599"]}
{"title": "A type notation for Scheme\n", "abstract": " This report defines a type notation for Scheme. This notation was used in the undergraduate programming languages class at Iowa State in Spring 2005.", "num_citations": "8\n", "authors": ["1599"]}
{"title": "Multijava: Design rationale, compiler implementation, and user experience\n", "abstract": " MultiJava is a conservative extension of the Java programming language that adds symmetric multiple dispatch and open classes. Among other benefits, multiple dispatch provides a solution to the binary method problem. Open classes provide a solution to the extensibility problem of object-oriented programming languages, allowing the modular addition of both new types and new operations to an existing type hierarchy. This paper illustrates and motivates the design of the MultiJava programming language and describes MultiJava\u2019s modular static typechecking and modular compilation strategies. Although MultiJava extends Java, the key ideas of the language design are applicable to other object-oriented languages, such as C# and C++, and even, with some modifications, to functional languages such as ML. This paper also discusses the experience of MultiJava users in a variety of application domains, including pervasive computing, graphical user interfaces, and compilers. MultiJava allows users to express desired programming idioms in a way that is declarative and supports static typechecking, in contrast to the tedious and type-unsafe workarounds required in Java. MultiJava also provides opportunities for new kinds of extensibility that are not easily available to users in Java.", "num_citations": "8\n", "authors": ["1599"]}
{"title": "JML reference manual\n", "abstract": " JML is a notation for formally specifying the behavior and interfaces of Java [Arnold-Gosling-Holmes00][Gosling-etal00] classes and methods.The goal of this reference manual is to precisely record the design of JML. We include both informal semantics (intentions) and where possible formal semantics (usually in the form of verification conditions). We also discuss the implications for various tools (such as the run-time assertion checker, static checkers such as Daikon or ESC/Java, and documentation generators such as jmldoc).", "num_citations": "8\n", "authors": ["1599"]}
{"title": "Equational reasoning with subtypes\n", "abstract": " Using equational logic as a specification language, we investigate the proof theory of behavioral subtyping for object-oriented abstract data types with immutable objects and deterministic methods that can use multiple dispatch. In particular, we investigate a proof technique for correct behavioral subtyping in which each subtype's specification includes terms that can be used to coerce its objects to objects of each of its supertypes. We show that this technique is sound, using our previous work on the model theory of such abstract data types. We also give an example to show that the technique is not complete, even if the methods do not use multiple dispatch, and even if types specified are term-generated. In preparation for the results on equational subtyping we develop the proof theory of a richer form of equational logic that is suitable for dealing with subtyping and behavioral equivalence. This gives some insight into question of when our proof techniques can be make effectively computable, but in general behavioral consequence is not effectively computable.", "num_citations": "8\n", "authors": ["1599"]}
{"title": "Gentle Introduction to Larch/Smalltalk Specification Browsers\n", "abstract": " This paper provides a tutorial introduction to the Larch/Smalltalk specification browsers. The browsers are specification support tools providing a powerful and sophisticated environment for writing and managing Larch/Smalltalk specifications. They are integrated in the Smalltalk-80 programming system. The reader is assumed to have some familiarity with the Smalltalk system and Larch-style specification.", "num_citations": "8\n", "authors": ["1599"]}
{"title": "Introduction to the literature on object-oriented design, programming, and languages\n", "abstract": " This paper is an introduction to the literature on object-oriented design, object-oriented programming, a few programming languages (especially C++), and some related topics in language design.This bibliography has been prepared for a graduate seminar at Iowa State called \"Fun with C++\". However, it reflects many more aspects of object-oriented programming and design than will be covered in that seminar. In particular, it reflects my own research interests. Please use it as a spring-board into the available literature.Apologies in advance to any whose work is left out.", "num_citations": "8\n", "authors": ["1599"]}
{"title": "Conditional effects in fine-grained region logic\n", "abstract": " Specification languages have long featured ways to describe what does not change when an imperative procedure is executed: the so-called frame problem. Solutions to the frame problem are needed for formal verification in imperative programming, as otherwise a verification would not be able to accumulate information from one statement to the next. Region logic is one of the approaches to solving the frame problem. We present a modified version of region logic with fine granularity and introduce conditional effects that allows one to specify more precise frame conditions.", "num_citations": "7\n", "authors": ["1599"]}
{"title": "Specifying subtypes in SCJ programs\n", "abstract": " Modular reasoning about programs that use subtypes requires that an overriding method in a subtype obeys the specifications of all methods that it overrides. For example, if method m is specified in a supertype T to take at most 42 nanoseconds to execute, then m cannot take more than 42 nanoseconds to execute in any subtype of T. Subtyping is an important aid to maintenance of programs, since it allows one to write polymorphic code (reducing code size and increasing reuse), and allows for convenient extension and enhancement of programs, all of which could be very useful in real-time programming. In this paper we show how to specify timing constraints for subtypes in a way that: permits modular reasoning about timing constraints, supports subtype polymorphism and object-oriented design patterns, and still permits precise reasoning about execution times. This technique supports object-oriented coding\u00a0\u2026", "num_citations": "7\n", "authors": ["1599"]}
{"title": "Formal definition of the parameterized aspect calculus\n", "abstract": " This paper gives the formal definition of the parameterized aspect calculus, or s_asp. The s_asp calculus is a core calculus for the formal study of aspect-oriented programming languages. The calculus consists of a base language, taken from Abadi and Cardelli  s object calculus, and point cut description language. The calculus is parameterized to accept a variety of point cut description languages, simplifying the study of a variety of aspect-oriented language features. The calculus exposes a rich join point model on the base language, granting great flexibility to point cut description languages.", "num_citations": "7\n", "authors": ["1599"]}
{"title": "Reasoning about procedure calls with repeated arguments and the reference-value distinction\n", "abstract": " In a language with clean semantics, the effect of a call to an operation is local; this effect-restrictive property makes it easy for software engineers to understand and reason about their code. However, in order to give clean semantics for procedure calls in the presence of aliasing, it is necessary to view variables that refer to complex objects as mere references into a global store. The reasoning difficulties this indirection introduces do not disappear even when a language designer or a disciplined software engineer avoids explicit assignment of references  the more common source of aliasing. This is because of an independent source of aliasing that arises when procedures are called with repeated arguments and references are copied for parameter passing. This repeated argument problem exists in all well-known imperative languages. We examine the software engineering issues in solving the repeated argument problem, discussing in the process the reasoning problems introduced by aliasing and the benefits of preserving clean semantics. A key design consideration is avoiding value copying, both because it is inefficient and because it cannot, in general, be automated.", "num_citations": "7\n", "authors": ["1599"]}
{"title": "Alias-free parameters in C for better reasoning and optimization\n", "abstract": " Aliasing among formal parameters and among formals and globals causes problems for both reasoning and optimization. Whole-program static analysis could provide some knowledge about such aliasing, but this is not usually done, and in any case would have to be conservative. All aliasing patterns that are not ruled out by an analysis have to be considered possible both by a person reasoning about correctness and by a compiler trying to optimize code. For compilers, the conservative nature of the static analysis leads to missed optimization opportunities. We have designed and implemented a small extension to C that partially solves the reasoning problem and leads to significantly better optimization. The extension guarantees that there will be no direct aliasing among arguments and globals inside procedure bodies, and yet allows aliasing among arguments and globals at the call site. This is done by having multiple bodies for each procedure, up to one for each aliasing pattern. Procedure calls are automatically dispatched to the body that matches the run-time aliasing pattern among the actual parameters and the globals. We present experimental evidence that this approach is practical. It is easy to convert existing C code, because not every procedure in a program has to be converted, and because converted code can call code that has not been converted and vice versa. By following simple guidelines, one can convert a program in a way that usually makes it run faster than before. In our experiments with 6 of the SPEC 2000 integer benchmarks we found an average speedup of about 5%. In one case, we had a speedup of about 29%.", "num_citations": "7\n", "authors": ["1599"]}
{"title": "Class-based and algebraic models of objects\n", "abstract": " We compare different kinds of first-order models of objects and message passing, as found in object-oriented programming languages. We show that generic function models can easily simulate record models for static, class-based languages. We explore type systems for such languages, and show that our simulation preserves typing. Algebraic models emerge as abstractions of the generic function model that suppress details that are irrelevant for client code.Thanks to Todd Millstein for comments on an earlier draft, and for suggesting that we make our comparisons between the record and generic function models constructive, which greatly improved the paper. Thanks to Todd and Craig Chambers for many discussions about multimethod languages and their type systems.", "num_citations": "7\n", "authors": ["1599"]}
{"title": "Aspect-oriented programming reloaded\n", "abstract": " Many programs have crosscutting concerns for which neither procedural nor object-oriented programming adequately modularize, which has led to the idea of aspect-oriented programming (AOP). However, AOP has not found favor with the programming languages community due to a belief that AOP breaks classical modularity and modular reasoning. We propose a new AOP programming model that enables both crosscutting modularity and modular reasoning. This model is implemented by AspectJML, a general-purpose aspect-oriented extension to Java. It supports modular crosscutting concerns using key object-oriented mechanisms, such as hierarchical structure, and allows reasoning that scales to ever-larger programs.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "Client-aware checking and information hiding in interface specifications with jml/ajmlc\n", "abstract": " Information hiding controls which parts of a module are visible to different clients. This aids maintenance because hidden implementation details can be changed without affecting clients. The benefits of information hiding apply not only to code but also to other artifacts, such as specifications. In this demonstration we show how our client-aware checking (CAC) technique, which is implemented by our JML/ajmlc compiler and freely available online, use the privacy information in specifications to promote information hiding. We demonstrate the benefits of CAC over existing runtime assertion checkers (RACs) of contemporary interface specification languages.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "The future of library specification\n", "abstract": " Programming language technology has started to achieve one of the dreams of software engineering--large scale utilization of reusable components. This is due to the standardization of large libraries and frameworks in popular programming languages such as C++, Java, C#, and Python. This standardization and widespread use of libraries will continue to make module specification more and more important. Yet most libraries and frameworks are only specified informally using natural language. This position paper explores research questions related to the specification of such libraries and frameworks.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "A design discipline and language features for formal modular reasoning in aspect-oriented programs\n", "abstract": " Advice in aspect-oriented programming helps programmers modularize crosscutting concerns by allowing additions and changes to a program's execution. However, formal reasoning about the functional behavior of aspect-oriented programs requires a non-modular, whole-program search to find applicable advice. To allow modular reasoning, we describe a discipline that categorizes aspects into two sorts: spectators and assistants.\" Spectators\" are statically checked to not modify the behavior of the code they advise; this restriction lets them remain unseen. Unlike spectators,\" assistants\" are not restricted in their behavior. However, for modular reasoning one must be able to identify all applicable assistants, hence assistants must be explicitly accepted by the code they advise. Besides allowing modular reasoning, this discipline permits the use of existing idioms, and appears to be statically verifiable and practical for software development. Indeed, expert aspect-oriented programmers seem to use such a discipline.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "Executing formal specifications with constraint satisfaction\n", "abstract": " We have implemented an execution technique for formal speci cations, which is based on constraint satisfaction techniques. These techniques allow one to execute model-based speci cations written at a high level of abstraction. Such speci cations are comparable to that of speci cations written without executability in mind, because quanti ed assertions that are bounded are executable.The main technique for executing assertions is an adaptation of constraint solving to the domains of interest in model-based speci cation: sets, unions, sequences, tuples and objects. We describe in detail how to do constraint satisfaction for these domains. We also describe how these techniques are used in executing speci cations written using rst-order predicate calculus assertions over such domains.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "Larch/C++, an interface specification language for C++\n", "abstract": " In Figure 3, again the lines that are not annotations are part of the C++ interface speci cation. In the rst annotation comment, two speci cation variables, x and y, are declared. The abstract model of points thus includes two integer objects. These do not have to be part of a correct implementation, but are here just for the purpose of explaining the behavior of the functions. The rst function speci ed is the constructor. Its job in C++ is to initialize the data members of the class. In this case, it says that the initial values of the", "num_citations": "6\n", "authors": ["1599"]}
{"title": "Polymorphic type-checking in scheme\n", "abstract": " This paper presents a type-inference system for Scheme that is designed to be used by students in an introductory programming course. The major goal of the work is to present a type system that is simple enough to be used by beginner students, yet is powerful enough to express the ideas of polymorphism, abstract data types (ADTs), and higher-order procedures. The system also performs some rudimentary syntax checking. The system uses subtyping, but only in a primitive fashion. It has a type datum which is a supertype of all types, and a type poof which is a subtype of all types. It uses intersection types to control the use of datum and to generate simple but accurate types.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "An exact algebraic characterization of behavioral subtyping\n", "abstract": " A model theory for correct behavioral subtyping for abstract data types (with immutable objects) is developed within the framework of the behavior-realization adjunction. To allow for incomplete speci cations, proofs of correct behavioral subtyping are based on comparison to one of several paradigmatic models. For specications that are not term-generated, these results are the rst complete algebraic characterizations of behavioral subtyping.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "Fields in physics are like curried functions or physics for functional programmers\n", "abstract": " Good motivating examples for teaching the utility of curried functions can be taken from Physics. The curried function perspective can also be used to help functional programmers understand fields in Physics. The correspondence between the curried function view of vector fields and the usual view taken in Physics is also explained.", "num_citations": "6\n", "authors": ["1599"]}
{"title": "Reasoning tradeoffs in languages with enhanced modularity features\n", "abstract": " The continuous need for more ambitious, more complex, and more dependable software systems demands mechanisms to modularize such systems and reason about their correctness. The reasoning process is affected by the programming language\u2019s features, like dynamic dispatching, implicit invocation and oblivious aspect weaving, and by how the programmer uses them. In this paper, by devising a unifying formal setting, we show how reasoning varies with the different language mechanisms, and provide sound rules for reasoning about programs that use these features. While analyzing these mechanisms we explore the main compromises or tradeoffs that led to them and explain the disciplines they impose and the strength of the reasoning conclusions one can derive in each case. Our contributions will benefit both language designers and programmers. Language designers will benefit from learning the\u00a0\u2026", "num_citations": "5\n", "authors": ["1599"]}
{"title": "Modularizing crosscutting concerns with Ptolemy\n", "abstract": " This tutorial will provide an introduction to Ptolemy. Ptolemy is a programming language whose goals are to improve a software engineer's ability to separate conceptual concerns, while preserving encapsulation of object-oriented code and the ability of programmers to modularly reason about their code. In particular, Ptolemy's features are useful towards modularization of cross-cutting concerns. A cross-cutting concern is a requirement whose implementation is spread across and mixed with the code of other requirements. There has been attempts to improve separation of cross-cutting concerns, eg by aspect oriented and implicit-invocation languages, but none give software developers textual separation of concerns and modular reasoning at the same time. Ptolemy has both these properties important for scalable software engineering. Ptolemy's event types provide a well-defined interface between object-oriented\u00a0\u2026", "num_citations": "5\n", "authors": ["1599"]}
{"title": "Use concurrent programming models to motivate teaching of programming languages\n", "abstract": " Undergraduate computer science students typically have only a limited understanding of their favorite languages and no inkling of other programming paradigms. Yet modern programmers typically work with several languages, and the availability of cheap concurrency is exposing fundamental problems in standard concurrent programming techniques (mutable objects and threads). This situation presents a great opportunity: by exploring nonstandard techniques for gaining intellectual control over concurrent programs, one can motivate and teach important semantic concepts (such as scoping) and important programming concepts (such as functional abstraction). Such a curriculum stimulates student interest in exploring new programming paradigms.", "num_citations": "5\n", "authors": ["1599"]}
{"title": "JML Reference Manual DRAFT, \n", "abstract": " Permission is granted for you to make copies of this manual for educational and scholarly purposes, and for commercial use in specifying software, but the copies may not be sold or otherwise used for direct commercial advantage; this permission is granted provided that this copyright and permission notice is preserved on all copies. All other rights reserved. Version Information:@(#) $ Id: jmlrefman. texinfo, v 1.29 2003/04/02 04: 36: 33 leavens Exp $ Chapter 1: Introduction 1", "num_citations": "5\n", "authors": ["1599"]}
{"title": "Translucid contracts for modular reasoning about aspect-oriented programs\n", "abstract": " Several proposals have advocated notion of aspect-oriented (AO) interfaces to solve modular reasoning problems, but have not shown how to specify these interfaces to facilitate modular reasoning. Our work on translucid contracts shows how to specify AO interfaces which allow modular understanding and enforcement of control flow interactions.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "Following the grammar\n", "abstract": " This document explains what it means to``follow the grammar''for several different grammars. It is intended to be used in class that teach functional programming using Scheme, especially those used for teaching principles of programming languages. In such courses traversal is over abstract syntax tree is defined by a grammar are fundamental, since they are the technique used to write compilers and interpreters.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "A thought on specification reflection\n", "abstract": " In programming languages, reflection is the ability to discover and manipulate, at runtime, information about program entities, such as objects. We present our thoughts on extending the concept of reflection to behavioral interface specifications. We explain the benefits of such specification reflection, and discuss implementation approaches, support tools, and research problems and issues in this area.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "Introduction to the literature on programming language design\n", "abstract": " This is an introduction to the literature on programming language design and related topics. It is intended to cite the most important work, and to provide a place for students to start a literature search.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "Programming is writing: Why programs need to be carefully read\n", "abstract": " Teaching a student to write computer programs well is much like teaching a student to write English prose well. That is, although a program must be correct in every last detail, achieving correctness is only half of the task. The other half consists of quality factors such as clarity, organization, conciseness, maintainability, etc. Although these factors cannot be automatically measured, they have a large economic impact, because a major cost of software development is the time spent by other people reading programs to validate, maintain, and enhance them.To teach these quality factors, student programs must be read by a skilled programmer. Furthermore, grades for programs must be partly based on these quality factors. Completely automatic testing and grading of student programs by machine not only ignores these quality factors, it also fosters the attitude that such factors are unimportant. When programs are automatically tested and not read, students come to believe that functional correctness is all that matters. They tend to write programs by making changes in an initial attempt at a program until it \u201cworks.\u201d The result is students who cannot write programs well.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "Specifying and verifying object-oriented programs: an overview of the problems and a solution\n", "abstract": " This paper presents a careful analysis of the problem of reasoning about object-oriented programs. A solution to this problem allows new types to be added to a program without respecifying or reverifying unchanged modules---if the new types are subtypes of existing types. The key idea is that subtype relationships must satisfy certain semantic constraints based on the types' specified behavior. Thus subtyping is not the same as inheritance of implementations (subclassing). Subtyping aids specification and verification of object-oriented programs by allowing supertypes to stand for their subtypes. This reduces the problem of reasoning about both supertypes and their subtypes to the problems of reasoning about just the supertypes and proving that the subtype relationships satisfy the required constraints.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "A distributed search program for the 3x+ 1 problem\n", "abstract": " This report describes the design of a distributed program that searched for peaks in certain measures related to the 3x+ 1 problem. The searches for peaks in the number of steps taken, the maximum value reached, and the number of steps before the values of the iterates fall below the starting value exhibit a great deal of parallelism, but there is also some small amount of synchronization necessary. The design of a reliable and long-lived distributed system that searched for such peaks is discussed from the partitioning of the search to more detailed design issues such as ways to limit the search. The search was implemented in the distributed programming language Argus, and a few observations about Argus programming are included. An appendix includes tables of various results from the three years that the search program was running on six or more computers.", "num_citations": "4\n", "authors": ["1599"]}
{"title": "Unifying separation logic and region logic to allow interoperability\n", "abstract": " Framing is important for specification and verification, especially in programs that mutate data structures with shared data, such as DAGs. Both separation logic and region logic are successful approaches to framing, with separation logic providing a concise way to reason about data structures that are disjoint, and region logic providing the ability to reason about framing for shared mutable data. In order to obtain the benefits of both logics for programs with shared mutable data, this paper unifies them into a single logic, which can encode both of them and allows them to interoperate. The new logic thus provides a way to reason about program modules specified in a mix of styles.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Poster: an algorithm and tool to infer practical postconditions\n", "abstract": " Manually writing pre- and postconditions to document the behavior of a large library is a time-consuming task; what is needed is a way to automatically infer them. Conventional wisdom is that, if one has preconditions, then one can use the strongest postcondition predicate transformer (SP) to infer postconditions. However, we have performed a study using 2,300 methods in 7 popular Java libraries, and found that SP yields postconditions that are exponentially large, which makes them difficult to use, either by humans or by tools. We solve this problem using a novel algorithm and tool for inferring method postconditions, using the SP, and transmuting the inferred postconditions to make them more concise. We applied our technique to infer postconditions for over 2,300 methods in seven popular Java libraries. Our technique was able to infer specifications for 75.7% of these methods. Each of these inferred\u00a0\u2026", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Towards modular reasoning for context-oriented programs\n", "abstract": " Context-oriented programming (COP) is an approach to modularity for applications whose behavior may vary depending on the status of the environment in which they execute and the software's own state. Languages supporting COP provide partial methods to modularly define behavioral variations of methods specific to a context, layers to group the partial methods and layer activation mechanisms to dynamically compose layers. Because the behavior of these partial methods often differs from that of the base methods they override, reasoning about context-oriented programs seems to require a case analysis based on partial methods and context information from the entire program, which is not scalable. In this paper we explain a new language feature, layer interfaces, which allows modular specification and verification of context-oriented programs. We demonstrate these techniques by using examples.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "JML: expressive contracts, specification inheritance, and behavioral subtyping\n", "abstract": " JML, the Java Modeling Language, is a formal specification language tailored to the specification of sequential Java classes and interfaces. It features contracts in the style of design by contract (as in Eiffel), as well as more sophisticated features that allow it to be used with a variety of tools from dynamic assertion checking to static verification. The talk will explain JML using some small examples.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Verily: a web framework for creating more reasonable web applications\n", "abstract": " The complexity of web application construction is increasing at an astounding rate. Developing for the web typically crosses multiple application tiers in a variety of languages, which can result in disjoint code bases. This lack of standardization introduces new challenges for reasoning.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Translating separation logic into dynamic frames using fine-grained region logic\n", "abstract": " Several techniques have been proposed for specification and verification of frame conditions, making it difficult for specification language designers to know which to pick. Ideally there would be a single mechanism that could be used to express specifications written in all techniques. In this paper we provide a single mechanism that can be used to write specifications in the style of both separation logic and dynamic frames. This mechanism shows common characters between the two methodologies.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Modular enforcement of supertype abstraction and information hiding with client-side checking\n", "abstract": " Static reasoning tools for object-oriented (OO) languages use supertype abstraction, by verifying calls to methods using the specification associated with the receiver\u2019s static type. Unfortunately, contemporary runtime assertion checkers for OO are inconsistent with such static reasoning tools, since they check assertions in an overly-dynamic way on the supplier side. For method calls, such supplier-side checking occurs at the exact runtime type of the receiver object, which in general can be a proper subtype of the receiver object\u2019s static type. Since such a subtype can have a refinement of the corresponding supertype\u2019s specification, this specification difference can cause an inconsistency between runtime assertion checking and static verification tools. We explain how our technique of client-side checking allows runtime assertion checkers to use the specifications associated with static types, gaining consistency with static verification tools. Another advantage of such client-side checking is that it provides a way for runtime assertion checkers to use privacy information associated with specifications, which promotes information hiding.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Formal semantics of an algorithm for translating model-based specifications to concurrent constraint programs\n", "abstract": " This paper presen tsa denotational semantics for an algorithm for executing formal specifications. The algorithm executes specifications written at a high level of abstraction by transforming such specifications to concurrent constrain t programs. The semantics presen tsthe algorithm formally and provides the basis for a soundness proof.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Mutation, aliasing, viewpoints, modular reasoning, and weak behavioral subtyping\n", "abstract": " Existing work on behavioral subtyping either ignores aliasing or restricts the behavior of additional methods in a subtype and only allows one to use invariants and history constraints in reasoning. This prevents many useful subtype relationships; for example, a type with immutable objects (eg, immutable sequences), cannot have a behavioral subtype with mutable objects (eg, mutable arrays). Furthermore, the associated reasoning principle is not very useful, since one cannot use the pre-and postconditions of methods. Weak behavioral subtyping permits more behavioral subtype relationships, does not restrict the behavior of additional methods in subtypes, and allows the use of pre-and postconditions in reasoning. The only cost is the need to restrict aliases so that objects cannot be manipulated through the view of more than one type.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Preventing cross-type aliasing for more practical reasoning\n", "abstract": " To reason about the correctness of a method when cross-type aliases are possible, one must not only consider all possible patterns of aliasing among the method's arguments, but all possible ways in which these types' abstract (specification-only) fields may be aliased. Because of the large number of such aliasing possibilities, and because of the complications they cause for reasoning, cross-type aliases make the use of method specifications impractical in reasoning about correctness. Hence, existing work on behavioral subtyping either ignores aliasing or prohibits the use of method specifications in reasoning We present a simple type system that prohibits cross-type aliases, and thus eliminates these problems. The``viewpoint restriction''enforced by this type system supports a less restrictive notion of behavioral subtyping--weak behavioral subtyping. Weak behavioral subtyping allows types with immutable objects (eg, immutable sequences), to have behavioral subtypes with mutable objects (eg, mutable arrays). Thus, besides permitting one to reason with method specifications, the viewpoint restriction also permits a more flexible and useful notion of behavioral subtyping.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Specification Facets for More Precise, Focused Documentation\n", "abstract": " Specification languages could aid reuse to a larger extent if they could document all important facets of software, not just functional behavior. Since a specification language designer cannot know exactly what aspects of a piece of software will be important, users should be able to do``metaspecification''; that is, users should be able to declare new facets, and then use these facets to specify their software. Examples of facets that users might want to specify include time and space usage, safety considerations, aliasing, error checking, the user interface, etc.", "num_citations": "3\n", "authors": ["1599"]}
{"title": "Enforcing information hiding in interface specifications: A client-aware checking approach\n", "abstract": " Information hiding is an established principle that controls which parts of a module are visible to non-privileged and privileged clients (eg, subclasses). This aids maintenance because hidden implementation details can be changed without affecting clients. The benefits of information hiding apply not only to code but also to other artifacts, such as specifications. Unfortunately, contemporary formal interface specification languages and their respective runtime assertion checkers (RACs) are inconsistent with information hiding rules because they check assertions in an overly-dynamic manner on the supplier side. We explain how overly-dynamic RACs compromise information hiding and how our client-aware checking technique allows these RACs to use the privacy information in specifications, which promotes information hiding.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Design, semantics and implementation of the Ptolemy programming language: A language with quantified typed events\n", "abstract": " Implicit invocation (II) and aspect-oriented (AO) languages provide software designers with related but distinct mechanisms and strategies for decomposing programs into modules and composing modules into systems. II languages have explicitly announced events that run registered observer methods. AO languages have implicitly announced events that run method-like but more powerful advice. A limitation of II languages is their inability to refer to a large set of events succinctly. They also lack the expressive power of AO advice. Limitations of AO languages include potentially fragile dependence on syntactic structure that may hurt maintainability, and limits on the available set of implicit events and the reflective contextual information available. Quantified, typed events, as implemented in our language Ptolemy, solve all these problems. This paper describes Ptolemy and explores its advantages relative to both II and AO languages.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Specifying subtypes in safety critical Java programs\n", "abstract": " Real\u2010time and safety\u2010critical code could benefit from the use of design patterns and frameworks that rely on subtyping and dynamic dispatch. However, modular reasoning about programs that use subtypes requires that each overriding method obeys the specifications of all methods that it overrides. For example, if method scale is specified in a supertype Vector2d to take at most 42\u2009ns to execute, then an override of scale cannot take more than 42\u2009ns to execute in any subtype, such as Vector3d. The problem is that subtype objects typically contain more information, such as the z coordinate in Vector3d, and thus their methods often require more time to execute than the methods they override. In this paper, we show how to specify timing constraints for subtypes in a way that both allows overriding subtype methods to have more time to execute and yet permits precise modular verification and checking of timing\u00a0\u2026", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Model programs for preserving composite invariants\n", "abstract": " We describe a solution for the SAVCBS challenge problem: a technique for specifying and verifying invariants for objects designed using the Composite design pattern. The solution presents a greybox specification technique using JML\u2019s model program feature. We show that model program specifications function as exemplars for capturing helper method calls in a way that preserves modularity and encapsulation.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Demonstration of jml tools\n", "abstract": " The Java Modeling language (JML) is a behavioral interface specification language tailored to Java. This demonstration presents some of the basic tools for generating and browsing documentation, runtime assertion checking, and unit testing.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "FOAL 2005 Proceedings: Foundations of Aspect-Oriented Languages Workshop at AOSD 2005\n", "abstract": " Aspect-oriented programming is a paradigm in software engineering and programming languages that promises better support for separation of concerns. The fourth Foundations of Aspect-Oriented Languages (FOAL) workshop was held at the Fourth International Conference on Aspect-Oriented Software Development in Chicago, USA, on March 14, 2005. This workshop was designed to be a forum for research in formal foundations of aspect-oriented programming languages.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "The JML and JUnit way of unit testing and its implementation\n", "abstract": " Writing unit test code is labor-intensive, hence it is often not done as an integral part of programming. However, unit testing is a practical approach to increasing the correctness and quality of software; for example, Extreme Programming relies on frequent unit testing. In this paper we present a new approach that makes writing unit tests easier. It uses a formal specification language's runtime assertion checker to decide whether methods are working correctly; thus code to decide whether tests pass or fail is automatically produced from specifications. Our tool combines this testing code with hand-written test data to execute tests. Therefore, instead of writing testing code, the programmer writes formal specifications (eg, pre-and postconditions). This makes the programmer's task easier, because specifications are more concise and abstract than the equivalent test code, and hence more readable and maintainable. Furthermore, by using specifications in testing, specification errors are quickly discovered, so the specifications are more likely to provide useful documentation and inputs to other tools. In this paper we describe an implementation using the Java Modeling Language (JML) and the JUnit testing framework, but the approach could be easily implemented with other combinations of formal specification languages and unit testing tools.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Preserving Clean Semantics for Calls with Repeated Arguments\n", "abstract": " In a language with clean semantics, the effect of a call to an operation is local; this effectrestrictive property makes it easy for software engineers to understand and reason about their code. However, in order to give clean semantics for procedure calls in the presence of aliasing, it is necessary to view variables that refer to complex objects as mere references into a global store. The reasoning difficulties this indirection introduces do not disappear even when a language designer or a disciplined software engineer avoids explicit assignment of references\u2013the more common source of aliasing. This is because of an independent source of aliasing that arises when procedures are called with repeated arguments and references are copied for parameter passing. This repeated argument problem exists in all well-known imperative languages. We examine the software engineering issues in solving the repeated argument problem, discussing in the process the reasoning problems introduced by aliasing and the benefits of preserving clean semantics. A key design consideration is avoiding value copying, both because it is inefficient and because it cannot, in general, be automated.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "the Behavioral Subtyping Analogy\n", "abstract": " The obliviousness property of AspectJ conflicts with the ability to reason about an AspectJ program in a modular fashion. This makes debugging and maintenance difficult. In object-oriented programming, the discipline of behavioral subtyping allows one to reason about programs modularly, despite the somewhat oblivious nature of dynamic binding; however, it is not clear what discipline would help AspectJ programmers obtain modular reasoning. We describe this problem in detail, and sketch a solution that allows programmers to tell both \u201csuperimposition\u201d and \u201cevolution\u201d stories in their AspectJ programs.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Larch\n", "abstract": " Larch is a family of formal specification languages and tools. It consists of several interface specification languages, the Larch Shared Language (LSL), and the Larch Prover (LP). The interface specification languages can be used to document detailed design decisions about program modules, such as procedures and classes. LSL is used by these interface specification languages to describe the abstract values of objects; it can also be used independently to specify logical theories. LP can be used to verify properties stated in LSL; it can also be used independently as a general\u2010purpose theorem prover. The interface specification languages, LSL, and LP are described in detail.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "SAVCBS 2001 Proceedings: Specification and Verification of Component-Based Systems, Workshop at OOPSLA 2001\n", "abstract": " The goal of this workshop was to explore how formal (ie, mathematical) techniques can be or should be used to establish a suitable foundation for specification and verification of component-based systems. Component-based systems are a growing concern for the object-oriented community. Specification and reasoning techniques are urgently needed to permit composition of systems from components, for which source code is unavailable. This report is the proceedings of the workshop", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Formal semantics and soundness of an algorithm for translating model-based specifications to concurrent constraint programs\n", "abstract": " This paper presents an algorithm for executing formal speci cations, and a proof of the soundness of that algorithm. The algorithm executes speci cations written in the model-based speci cation language SPECS-C++ by transforming such speci cations to concurrent constraint programs. This approach can execute speci cations written at a high level of abstraction. Denotational semantics techniques are used for both explaining the algorithm and for proving its soundness.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Formal semantics and soundness of an algorithm for translating model-based specifications to constraint programs\n", "abstract": " This paper presents an algorithm for executing formal specifications, and a proof of the soundness of that algorithm. The algorithm executes specifications written in the model-based specification language SPECS-C++ by transforming such specifications to constraint programs. The generated programs use constraint satisfaction techniques to execute specifications written at a high level of abstraction. Denotational semantics techniques are used for both explaining the algorithm and for proving its soundness.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "MultiJava: Modular symmetric multiple dispatch and extensible classes for Java\n", "abstract": " Multiple dispatch offers several well-known advantages over the single dispatching of conventional object-oriented languages, including a simple solution to the\" binary method\" problem and cleaner implementations of the\" strategy\" and similar design patterns. Extensible classes allow one to extend the set of methods that an existing class supports without editing that class or client code. This provides, among other idioms, a simple implementation of the\" visitor\" design pattern. We present MultiJava, a backward-compatible extension to Java supporting symmetric multiple dispatch and extensible classes. We adapt previous theoretical work to allow MultiJava classes to be statically typechecked modularly and safely, ruling out any link-time or run-time type errors. We also present a novel compilation scheme that operates modularly and incurs performance overhead only where multiple dispatching or extensible classes are actually used.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "A Physical Example for Teaching Curried Functions\n", "abstract": " Curried functions are an important topic in Computing courses that teach functional programming, including courses that study programming languages. Good motivating examples for teaching curried functions and their utility can be taken from Physics.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "Overview and specification of the built-in types in Little Smalltalk\n", "abstract": " This document informally specifies the behavior of most of the key data types in the Little Smalltalk system.", "num_citations": "2\n", "authors": ["1599"]}
{"title": "A Methodology for Invariants, Framing, and Subtyping in JML\n", "abstract": " The Java Modeling Language (JML) is a specification language for describing the functional behavior of sequential Java program modules. The object-oriented features of Java make specifying invariants and framing difficult in the presence of subtyping. Using regions as a basis for a methodology, we precisely describe a technique for specifying invariants and framing in the presence of subtyping. We also extend JML by adding separating conjunction (from separation logic) for certain kinds of assertions.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Following the grammar with Haskell\n", "abstract": " This document1 explains what it means to \u201cfollow the grammar\u201d when writing recursive programs, for several kinds of different grammars. It is intended to be used in classes that teach functional programming using Haskell, especially those used for teaching principles of programming languages. In such courses traversal over an abstract syntax tree defined by a grammar are fundamental, since they are the technique used to write compilers and interpreters.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Optimizing Generated Aspect-Oriented Assertion Checking Code for JML Using Programming Laws: An Empirical Study\n", "abstract": " Aspect-oriented programming (AOP) enables the effective modularization of well-known crosscutting concerns. To take advantage of AOP, there are many techniques, including AOP laws, for a systematic refactoring of crosscutting concerns to aspects. However, there is also a need for supporting the systematic refactoring of AOP constructs. Existing techniques for aspect-oriented refactoring are too coarse-grained and make it too difficult to assure that the transformations preserve behavior and are indeed refactorings. This paper presents a catalogue of AOP laws towards a systematic refactoring of AOP constructs. As long as these laws are fine-grained, they make it easier to verify that the transformations they provide preserve behavior. Furthermore, as these laws can provide space and time optimization, we conduce an empirical study using four applications in optimized and non-optimized versions generated by ajmlc, a new JML compiler, presented in a previous work, which generates aspects that enforce JML contracts during runtime. We show that the AOP laws provide a significant improvement, regarding bytecode size and running time, in the aspect code generated by an optimized version of the ajmlc compiler.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Reconciling Trust and Modularity Goals in Web Services\n", "abstract": " Web services are distributed software components, that are decoupled from each other using interfaces with specified functional behaviors. However, such behavioral specifications are insufficient to demonstrate compliance with certain temporal non-functional policies. We show an example demonstrating that a patient's health-related query sent to a health care service is answered only by a doctor (and not by a secretary). Demonstrating compliance with such policies is important for satisfying governmental privacy regulations. It is often necessary to expose the internals of the web service implementation for demonstrating such compliance, which may compromise modularity. In this work, we provide a language design that enables such demonstrations, while hiding majority of the service's source code. The key idea is to use greybox specifications to allow service providers to selectively hide and expose parts of their implementation. The overall problem of showing compliance is then reduced to two subproblems: whether the desired properties are satisfied by the service's greybox specification, and whether this greybox specification is satisfied by the service's implementation. We specify policies using LTL and solve the first problem by model checking. We solve the second problem by refinement techniques.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Formal techniques for Java-Like programs\n", "abstract": " This report gives an overview of the 10th Workshop on Formal Techniques for Java-like Programs at ECOOP 2008. It explains the motivation for the workshop, and summarizes the presentations and discussions.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Adapting the Java Modeling Language for Java 5 Annotations\n", "abstract": " The Java Modeling Language (JML) is a formal specification language for Java that allows to express intended behavior through assertions. Currently, users must embed these assertions in Java comments, which complicates parsing and hinders tool support, leading to poor usability. This paper describes a set of proposed Java 5 annotations which reflect current JML assertions and provides for better tool support. We consider three alternative designs for such annotations and explain why the chosen design is preferred. This syntax is designed to support both a design-by-contract subset of JML, and to be extensible to the full language. We demonstrate that by building two tools: Modern Jass, which provides almost-native support for design by contract, and a prototype that works with a much larger set of JML.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "A JML Tutorial\n", "abstract": " ObjectivesYou\u2019ll be able to: Explain JML\u2019s goals. Read and write JML specifications. Use JML tools.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Automatically generating consistent graphical user interfaces using a parser generator\n", "abstract": " Well-designed graphical user interfaces (GUIs) are needed to make programs easier to use. However, these programs are difficult and time-consuming to develop, especially when creating several GUIs for a related set of tools. Automatic generation of a GUI is one solution to this problem. This paper presents a technique to automatically generate GUIs using a parser generator and data files. This technique quickly creates multiple consistent GUIs for tools with similar options. In this way, programmers can quickly create several GUIs at once that look and act the same.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "SAVCBS 2001 Proceedings\n", "abstract": " SAVCBS 2001 Proceedings SAVCBS 2001 Proceedings Specification and Verification of Component-Based Systems Workshop at OOPSLA 2001 Dimitra Giannakopoulou, Gary T. Leavens, and Murali Sitaraman (editors) TR# 01-09 October 14, 2001 Keywords: Specification, verification, component-based systems. 2000 CR Categories: D. 1. m [Programming Techniques] Miscellaneous\u2014component-based programming, reflection; D. 2.1 [Software Engineering] Requirements/Specifications\u2014languages, methodology, theory, tools; D. 2.4 [Software Engineering] Software/Program Verification\u2014assertion checkers, class invariants, correctness proofs, formal methods, model checking, programming by contract, reliabilty, validation; D. 2.5 [Software Engineering] Testing and Debugging\u2014testing tools; D. 2.11 [Software Engineering] Software Architecture\u2014languages; D. 2. m [Software Engineering] Miscellaneous \u2014\u2026", "num_citations": "1\n", "authors": ["1599"]}
{"title": "ACL--Eliminating Parameter Aliasing with Dynamic Dispatch\n", "abstract": " In this article we present a method for eliminating reference parameter aliases. The goal is to allow procedure calls with parameters being aliases, and at the same time guarantees that procedure bodies are alias-free. The method is to automatically dispatch to the correct procedure body based on the particular alias combination among actual parameters. Automating finding the alias combination makes writing verifiable programs verification simpler since code to find the combination is not explicitly present in client programs. The number of necessary procedure bodies is usually small which makes th eapproach practical. Efficiency of the dispatch is estimated to be no worse than in other languages.", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Formal semantics for structured analysis style data flow diagram specification languages\n", "abstract": " Using operational semantic techniques, we present a formal semantics for an extended variant of structured analysis style data flow diagrams. This semantics is intended to serve as a semantic foundation for many different specification languages that specify concurrent systems using a graphical notation similar to data flow diagrams. Besides allowing one to specify how information is processed, it allows one to specify the dynamic behavior of a concurrent system. We discuss various semantic issues, including the need for a two-step firing rule and how the semantics supports the notion of refinement", "num_citations": "1\n", "authors": ["1599"]}
{"title": "Polymorphic Type Inference in Scheme\n", "abstract": " This paper presents a type-inference system for Scheme that is designed to be used by students in an introductory programming course. The major goal of the work is to present a simple type inference system that can be used by beginning students, yet is powerful enough to express the ideas of types, polymorphism, abstract data types, and higher-order procedures. The system also performs some rudimentary syntax checking. The system uses subtyping, but only in a primitive fashion. It has a type datum which is a supertype of all types, and a type poof which is a subtype of all types. It uses and-types (intersection types) to control the use of datum and to generate accurate but simple types.", "num_citations": "1\n", "authors": ["1599"]}