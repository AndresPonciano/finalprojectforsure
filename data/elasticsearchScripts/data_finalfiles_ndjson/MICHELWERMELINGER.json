{"title": "A survey of self-management in dynamic software architecture specifications\n", "abstract": " As dynamic software architecture use becomes more widespread, a variety of formal specification languages have been developed to gain a better understanding of the foundations of this type of software evolutionary change. In this paper we survey 14 formal specification approaches based on graphs, process algebras, logic, and other formalisms. Our survey will evaluate the ability of each approach to specify self-managing systems as well as the ability to address issues regarding expressiveness and scalability. Based on the results of our survey we will provide recommendations on future directions for improving the specification of dynamic software architectures, specifically self-managed architectures.", "num_citations": "384\n", "authors": ["66"]}
{"title": "Assessing the effect of clones on changeability\n", "abstract": " To prioritize software maintenance activities, it is important to identify which programming flaws impact most on an applicationpsilas evolution. Recent empirical studies on such a flaw, code clones, have focused on one of the arguments to consider clones harmful, namely, that related clones are not updated consistently. We believe that a wider notion is needed to assess the effect of cloning on evolution. This paper compares measures of the maintenance effort on methods with clones against those without. Statistical and graphical analysis suggests that having a clone may increase the maintenance effort of changing a method. The effort seems to increase depending on the percentage of the system affected whenever the methods that share the clone are modified. We also found that some methods seem to increase significantly their maintenance effort when a clone was present. However, the characteristics\u00a0\u2026", "num_citations": "215\n", "authors": ["66"]}
{"title": "A graph based architectural (re) configuration language\n", "abstract": " For several different reasons, such as changes in the business or technological environment, the configuration of a system may need to evolve during execution. Support for such evolution can be conceived in terms of a language for specifying the dynamic reconfiguration of systems. In this paper, continuing our work on the development of a formal platform for architectural design, we present a high-level language to describe architectures and for operating changes over a configuration (ie, an architecture instance), such as adding, removing or substituting components or interconnectons. The language follows an imperative style and builds on a semantic domain established in previous work. Therein, we model architectures through categorical diagrams and dynamic reconfiguration through algebraic graph rewriting.", "num_citations": "174\n", "authors": ["66"]}
{"title": "A graph transformation approach to software architecture reconfiguration\n", "abstract": " The ability of reconfiguring software architectures in order to adapt them to new requirements or a changing environment has been of growing interest. We propose a uniform algebraic approach that improves on previous formal work in the area due to the following characteristics. First, components are written in a high-level program design language with the usual notion of state. Second, the approach deals with typical problems such as guaranteeing that new components are introduced in the correct state (possibly transferred from the old components they replace) and that the resulting architecture conforms to certain structural constraints. Third, reconfigurations and computations are explicitly related by keeping them separate. This is because the approach provides a semantics to a given architecture through the algebraic construction of an equivalent program, whose computations can be mirrored at the\u00a0\u2026", "num_citations": "169\n", "authors": ["66"]}
{"title": "A mathematical semantics for architectural connectors\n", "abstract": " A mathematical semantics is proposed for the notion of architectural connector, in the style defined by Allen and Garlan, that builds on Goguen\u2019s categorical approach to General Systems Theory and other algebraic approaches to specification, concurrency, and parallel program design. This semantics is, essentially, ADL-independent, setting up criteria against which formalisms can be evaluated according to the support that they provide for architectural design. In particular, it clarifies the role that the separation between computation and coordination plays in supporting architecture-driven approaches to software construction and evolution. It also leads to useful generalisations of the notion of connector, namely through the use of multiple formalisms in the definition of the glue and the roles, and their instantiations with programs or system components that can be implemented in different languages or\u00a0\u2026", "num_citations": "110\n", "authors": ["66"]}
{"title": "Towards a chemical model for software architecture reconfiguration\n", "abstract": " The chemical abstract machine is a general-purpose, simple, and intuitive programming model. Among other domains, it has been used for the specification and analysis of the computational behaviour of software architectures. In this paper we explore the ability of the formalism to express the dynamics of the architecture itself and to unify approaches to reconfiguration within framework.", "num_citations": "106\n", "authors": ["66"]}
{"title": "Specification of software architecture reconfiguration\n", "abstract": " In the past years, Software Architecture has attracted increased attention by academia and industry as the unifying concept to structure the design of complex systems. One particular research area deals with the possibility of reconfiguring architectures to adapt the systems they describe to new requirements. Reconfiguration amounts to adding and removing components and connections, and may have to occur without stopping the execution of the system being reconfigured. This work contributes to the formal description of such a process.", "num_citations": "93\n", "authors": ["66"]}
{"title": "Tracking clones' imprint\n", "abstract": " Cloning imprint is the lasting effect of cloning on applications. This paper aims to analyze the clone imprint over time, in terms of the extension of cloning, the persistence of clones in methods, and the stability of cloned methods. Such level of detail requires an improvement in the clone tracking algorithms previously proposed, which is also presented.", "num_citations": "89\n", "authors": ["66"]}
{"title": "Algebraic software architecture reconfiguration\n", "abstract": " The ability of reconfiguring software architectures in order to adapt them to new requirements or a changing environment has been of growing interest, but there is still not much formal work in the area. Most existing approaches deal with run-time changes in a deficient way. The language to express computations is often at a very low level of specification, and the integration of two different formalisms for the computations and reconfigurations require sometimes substantial changes. To address these problems, we propose a uniform algebraic approach with the following characteristics.  1.   Components are written in a high-level program design language with the usual notion of state.    2.   The approach combines two existing frameworks\u2014 one to specify architectures, the other to rewrite labelled graphs\u2014just through small additions to either of them.    3.   It deals with certain typical problems such as\u00a0\u2026", "num_citations": "79\n", "authors": ["66"]}
{"title": "Conceptual graphs and first-order logic\n", "abstract": " Conceptual Structures (CS) Theory is a logic-based knowledge representation formalism. To show that conceptual graphs have the power of first-order logic, it is necessary to have a mapping between both formalisms. A proof system, i.e. axioms and inference rules, for conceptual graphs is also useful. It must be sound (no false statement is derived from a true one) and complete (all possible tautologies can be derived from the axioms). This paper shows that Sowa's original definition of the mapping is incomplete, incorrect, inconsistent, and unintuitive, and the proof system is incomplete too. To overcome these problems a new translation algorithm is given and a complete proof system is presented. Furthermore, the framework is extended for higher-order types.", "num_citations": "78\n", "authors": ["66"]}
{"title": "Connectors for mobile programs\n", "abstract": " Software architecture has put forward the concept of connector to express complex relationships between system components, thus facilitating the separation of coordination from computation. This separation is especially important in mobile computing due to the dynamic nature of the interactions among participating processes. We present connector patterns, inspired in Mobile UNITY, that describe three basic kinds of transient interactions: action inhibition, action synchronization, and message passing. The connectors are given in COMMUNITY, a UNITY-like program design language which has a semantics in category theory. We show how the categorical framework can be used for applying the proposed connectors to specific components and how the resulting architecture can be visualized by a diagram showing the components and the connectors.", "num_citations": "77\n", "authors": ["66"]}
{"title": "Higher-order architectural connectors\n", "abstract": " We develop a notion of higher-order connector towards supporting the systematic construction of architectural connectors for software design. A higher-order connector takes connectors as parameters and allows for services such as security protocols and fault-tolerance mechanisms to be superposed over the interactions that are handled by the connectors passed as actual arguments. The notion is first illustrated over CommUnity, a parallel program design language that we have been using for formalizing aspects of architectural design. A formal, algebraic semantics is then presented which is independent of any Architectural Description Language. Finally, we discuss how our results can impact software design methods and tools.", "num_citations": "68\n", "authors": ["66"]}
{"title": "Architectural primitives for distribution and mobility\n", "abstract": " In this paper, we address the integration of a distribution dimension in an architectural approach to system development and evolution based on the separation between coordination and computation. This third dimension allows us to separate key concerns raised by mobility, thus contributing to our ability to handle the complexity that is inherent to systems required to operate in \"Internet time and space\".", "num_citations": "63\n", "authors": ["66"]}
{"title": "A hierarchic architecture model for dynamic reconfiguration\n", "abstract": " Dynamic reconfiguration is the ability to modify a parallel or distributed system while it is running. We adopt the framework developed by Kramer et al. (1985) at the system architecture level: changes must occur in a consistent state, which is brought about by \"freezing\" some system components. The goal is to reduce system disruption, i.e., to minimize: the part of the system to be \"frozen\"; and the time taken by reconfiguration operations. Towards the first goal we take a connection based approach instead of a component based one. To reduce time, we refine the reconfiguration algorithm by executing changes in parallel as much as possible. Our model also handles hierarchic systems.", "num_citations": "51\n", "authors": ["66"]}
{"title": "Mining java class naming conventions\n", "abstract": " Class names represent the concepts implemented in object-oriented source code and are key elements in program comprehension and, thus, software maintenance. Programming conventions often state that class names should be noun-phrases, but there is little further guidance for developers on the composition of class names. Other researchers have observed that the majority of Java class identifier names are composed of one or more nouns preceded, optionally, by one or more adjectives. However, no detailed analysis of class identifier name structure has been undertaken that could be leveraged to support program comprehension activities. We investigate the lexical and syntactic composition of Java class identifier names in two ways. Firstly, as others have done for C function and Java method names, we identify conventional patterns found in the use of parts of speech. Secondly, we identify the origin of\u00a0\u2026", "num_citations": "49\n", "authors": ["66"]}
{"title": "Analyzing the evolution of eclipse plugins\n", "abstract": " Eclipse is a good example of a modern component-based complex system that is designed for long-term evolution, due to its architecture of reusable and extensible components. This paper presents our preliminary results about the evolution of Eclipse's architecture, based on a lightweight and scalable analysis of the metadata in Eclipse's sources. We find that the development of Eclipse follows a systematic process: most architectural changes take place in milestones, and maintenance releases only make exceptional changes to component dependencies. We also found a stable architectural core that remains since the first release.", "num_citations": "44\n", "authors": ["66"]}
{"title": "Maleku: An evolutionary visual software analysis tool for providing insights into software evolution\n", "abstract": " Software maintenance is a complex process that requires the understanding and comprehension of software project details. It involves the understanding of the evolution of the software project, hundreds of software components and the relationships among software items in the form of inheritance, interface implementation, coupling and cohesion. Consequently, the aim of evolutionary visual software analytics is to support software project managers and developers during software maintenance. It takes into account the mining of evolutionary data, the subsequent analysis of the results produced by the mining process for producing evolution facts, the use of visualizations supported by interaction techniques and the active participation of users. Hence, this paper proposes an evolutionary visual software analytics tool for the exploration and comparison of project structural, interface implementation and class hierarchy\u00a0\u2026", "num_citations": "40\n", "authors": ["66"]}
{"title": "Design principles in architectural evolution: a case study\n", "abstract": " We wish to investigate how structural design principles are used in practice, in order to assess the utility and relevance of such principles to the maintenance of large, complex, long-lived, successful systems. In this paper we take Eclipse as the case study and check whether its architecture follows, throughout multiple releases, some principles proposed in the literature.", "num_citations": "38\n", "authors": ["66"]}
{"title": "Patterns for coordination\n", "abstract": " The separation between computation and coordination, as proposed by recent languages and models [7], has opened important new perspectives for supporting extendibility of systems, i.e. the possibility of adapting software systems to changes in requirements in an easy way. The evolutionary model that we have been developing is based on the representation of the more volatile aspects of the application domain like business rules as connectors whose purpose is to coordinate the interaction among core, more stable, components. The idea is that, in this way, evolution can be made to be compositional over the changes that occur in the application domain through the addition, deletion or substitution of connectors, without interfering with the services provided by the core objects of the system.", "num_citations": "37\n", "authors": ["66"]}
{"title": "Using formal concept analysis to construct and visualise hierarchies of socio-technical relations\n", "abstract": " Interest in the human aspects of software engineering has grown in the past years. For example, based on activity logs in software artefact repositories, researchers are recommending who should fix a bug for a certain component. However, existing work largely follows ad-hoc approaches to relate software artefacts to developers and rarely makes those socio-technical relations explicit in a single structure. In this paper we propose a novel application of formal concept analysis, in order to overcome those deficiencies. As a case study, we construct and visualise different views of the developers who fix and discuss bugs in the Eclipse project.", "num_citations": "28\n", "authors": ["66"]}
{"title": "Towards an algebra of architectural connectors: a case study on synchronization for mobility\n", "abstract": " To cope with the flexibility and extensibility needed for the specification of the architecture of evolving software systems, it is useful to have a set of primitive connectors from which new ones can be created in a systematic way as needs arise and to connect components only when they are required to interact. This could be achieved with a connector algebra whose constants are given primitive connectors and whose operations allow the (transient) creation of new connectors. This paper is a step towards that goal. We put forward an application-independent connector for partial action synchronization and three generic operations. Applied to the basic connector they provide application-specific connectors for inhibition and full synchronization of actions. Moreover, we associate to each connector a condition stating when it should be applied to components.", "num_citations": "27\n", "authors": ["66"]}
{"title": "Locating bugs without looking back\n", "abstract": " Bug localisation is a core program comprehension task in software maintenance: given the observation of a bug, e.g. via a bug report, where is it located in the source code? Information retrieval (IR) approaches see the bug report as the query, and the source code files as the documents to be retrieved, ranked by relevance. Such approaches have the advantage of not requiring expensive static or dynamic analysis of the code. However, current state-of-the-art IR approaches rely on project history, in particular previously fixed bugs or previous versions of the source code. We present a novel approach that directly scores each current file against the given report, thus not requiring past code and reports. The scoring method is based on heuristics identified through manual inspection of a small sample of bug reports. We compare our approach to eight others, using their own five metrics on their own six open\u00a0\u2026", "num_citations": "25\n", "authors": ["66"]}
{"title": "Superposing connectors\n", "abstract": " The ability to construct architectural connectors in a systematic and controlled way has been argued to promote reuse and incremental development, e.g., as a way of superposing, a la carte, services like security, over a given communication protocol. Towards this goal, we present a notion of high-order connector, i.e., a connector that takes connectors as parameters, for superposing coordination mechanisms over the interactions that are handled by the connectors that are passed as actual arguments. The notion is developed over the language COMMUNITY that we have been using for formalising aspects of architectural design, and illustrated with examples inspired by the case study.", "num_citations": "22\n", "authors": ["66"]}
{"title": "Exploring design principles for data literacy activities to support children\u2019s inquiries from complex data\n", "abstract": " Data literacy is gaining importance as a general skill that all citizens should possess in an increasingly data-driven society. As such there is interest in how it can be taught in schools. However, the majority of teaching focuses on small, personally collected data which is easier for students to relate to. This does not give the students the breadth of experience they need for dealing with the larger, complex data that is collected at scale and used to drive the intelligent systems that people engage with during work and leisure time. Neither does it prepare them for future jobs, which increasingly require skills for critically querying and deriving insights from data.This paper addresses this gap by trialling a method for teaching from complex data, collected through a smart city project. The main contribution is to show that existing data principles from the literature can be adapted to design data literacy activities that help pupils\u00a0\u2026", "num_citations": "21\n", "authors": ["66"]}
{"title": "Coordination Technologies for Business Strategy Support: acasestudyinStockTrading\n", "abstract": " In today\u2019s global and highly competitive business environments, organizations are replying to the question of whether technology is forming business or vice-versa by integrating their business and IT strategies, thus using technology to do business. As a result, information systems are at the core of the competitive edge of every business organization, which puts an increasing pressure for endowing them with the levels of flexibility and agility that are required to support changes of business strategies and operate in what have become highly volatile business domains. In this paper, we argue in favor of the adoption of \u201csoftware strategic libraries\u201d based on the \u201ccoordination technologies\u201d that we have been developing, in order to support \u201cbusiness reactive\u201d software systems. We support our view by presenting examples from the highly volatile, and extremely competitive, stock-trading business domain.", "num_citations": "21\n", "authors": ["66"]}
{"title": "Coordination for orchestration\n", "abstract": " Based on the identification of some shortcomings of object-oriented methodology and technology to address the challenges of supporting the engineering and deployment ofWeb Services, we suggest that alternative approaches can be found in what we call \u201ccoordination methodology and technologies\u201d\u2014a set of modelling primitives, design principles, design patterns, and analysis techniques that we have been developing for supporting the construction and evolution of complex software systems that need to operate in very volatile and dynamic environments.", "num_citations": "20\n", "authors": ["66"]}
{"title": "Investigating naming convention adherence in Java references\n", "abstract": " Naming conventions can help the readability and comprehension of code, and thus the onboarding of new developers. Conventions also provide cues that help developers and tools extract information from identifier names to support software maintenance. Tools exist to automatically check naming conventions but they are often limited to simple checks, e.g. regarding typography. The adherence to more elaborate conventions, such as the use of noun and verbal phrases in names, is not checked. We present Nominal, a naming convention checking library for Java that allows the declarative specification of conventions regarding typography and the use of abbreviations and phrases. To test Nominal, and to investigate the extent to which developers follow conventions, we extract 3.5 million reference - field, formal argument and local variable - name declarations from 60 FLOSS projects and determine their\u00a0\u2026", "num_citations": "19\n", "authors": ["66"]}
{"title": "A prolog toolkit for formal languages and automata\n", "abstract": " This paper describes the first version of PFLAT (read \"P flat\"), a collection of Prolog predicates that aims to provide a pedagogical implementation of concepts and algorithms taught in Formal Languages and Automata Theory (FLAT) courses. By ``pedagogical implementation'' we mean on the one hand that students should be able to easily map the implementation to the mathematical definitions given in lectures, and on the other hand that the toolkit should provide a library for students to implement further concepts and algorithms. In both cases the goal is to make students more confident in defining and manipulating the various kinds of languages and automata at a level beyond the one provided by visual simulators of automata. As such, PFLAT is not intended to replace but rather complement existing graphical tools. We believe the declarative, non-deterministic, and interactive nature of Prolog helps in building an\u00a0\u2026", "num_citations": "18\n", "authors": ["66"]}
{"title": "Using coordination contracts for flexible adaptation to changing business rules\n", "abstract": " We report on the use of coordination contracts, presented at the previous two IWPSE workshops, in a project for a credit recovery company. We have designed and implemented a framework that allows users to define several business rules according to predefined parameters. However, some rules require changes to the services provided by the system. For these, we use coordination contracts to intercept the calls to the underlying services and superpose whatever behaviour is imposed by the business rules applicable to that service. Such contracts can be added and deleted at run-time. Hence, our framework includes a configurator that, whenever a service is called, checks the applicable rules and configures the service with the given parameters and contracts, before proceeding with the call. Based on our experience, we put forward the position that coordination contracts facilitate the evolution of the system in\u00a0\u2026", "num_citations": "16\n", "authors": ["66"]}
{"title": "Enforcing business policies through automated reconfiguration\n", "abstract": " In this paper, we address dynamic reconfiguration from the point of view of the enforcement of the policies that organisations wish to see imposed through the way information systems support business. We address the process of evolution by proposing a primitive-coordination context-for modelling the circumstances in which reconfiguration can and should take place. The idea is for business policies to emerge as properties of process executions when controlled through the coordination contexts that will have been defined for supporting business activities.", "num_citations": "16\n", "authors": ["66"]}
{"title": "A compositional approach to connector construction\n", "abstract": " We develop a notion of higher-order connector towards supporting the systematic construction of architectural connectors for software design. The idea is that individual properties of connectors, such as security and fault-tolerance, can be designed separately as higher-order connectors. Complex connectors can then be described as suitable combinations of higher-order connectors and basic connectors. We use CommUnity, a Unitylike parallel program design language that we have been using for formalising aspects of architectural design, for illustrating our approach to the compositional construction of connectors and also to motivate the categorical semantics of higher-order connectors that we propose.", "num_citations": "16\n", "authors": ["66"]}
{"title": "Challenges in model-based evolution and merging of access control policies\n", "abstract": " Access Control plays a crucial part in software security, as it is responsible for making sure that users have access to the resources they need while being forbidden from accessing resources they do not need. Access control models such as Role-Based Access Control have been developed to help system administrators deal with the increasing complexity of the rules that determine whether or not a particular user should access a particular resource. These rules, as well as the users and their needs, are likely to evolve over time. In some cases, it may even be necessary to merge several access control configurations into a single one. In this position paper, we review existing research in model-based software evolution and merging, and argue the need for a specific approach for access control in order to take its specific requirements into account.", "num_citations": "15\n", "authors": ["66"]}
{"title": "INVocD: Identifier name vocabulary dataset\n", "abstract": " INVocD is a database of the identifier name declarations and vocabulary found in 60 FLOSS Java projects where the source code structure is recorded and the identifier name vocabulary is made directly available, offering advantages for identifier name research over conventional source code models. The database has been used to support a range of research projects from identifier name analysis to concept location, and provides many opportunities to researchers. INVocD may be downloaded from http://oro.open.ac.uk/36992.", "num_citations": "13\n", "authors": ["66"]}
{"title": "Relating developers' concepts and artefact vocabulary in a financial software module\n", "abstract": " Developers working on unfamiliar systems are challenged to accurately identify where and how high-level concepts are implemented in the source code. Without additional help, concept location can become a tedious, time-consuming and error-prone task. In this paper we study an industrial financial application for which we had access to the user guide, the source code, and some change requests. We compared the relative importance of the domain concepts, as understood by developers, in the user manual and in the source code. We also searched the code for the concepts occurring in change requests, to see if they could point developers to code to be modified. We varied the searches (using exact and stem matching, discarding stop-words, etc.) and present the precision and recall. We discuss the implication of our results for maintenance.", "num_citations": "13\n", "authors": ["66"]}
{"title": "The community workbench\n", "abstract": " CommUnity is a formal approach to Software Architecture with a strict separation of the computation, coordination, and distribution aspects. The approach is based on a parallel design language with state, which facilitates the specification of computations compared to the process calculi used by other formal approaches, and on category theory, which provides an intuitive yet precise graph-based semantics for the configuration of components and connectors. The CommUnity Workbench is being developed as a proof of concept of the CommUnity framework, providing a graphical integrated development environment to write components, draw configurations, and execute the resulting system.", "num_citations": "13\n", "authors": ["66"]}
{"title": "Managing assumptions during agile development\n", "abstract": " The assumptions that underlie software development often go unrecorded and form part of the implicit rationale on which design and implementation decisions are based. These assumptions can fail at any time, with serious consequences. This paper presents a lightweight approach to assumption management (AM) designed to suit agile development. Assumptions were monitored for three months within a small agile team. Two key indicators were proposed for measuring AM success but only one was detected in the research results. A number of strong correlations were found between properties of assumptions. Data collection largely depended on the subjective judgements of the first author, but they were validated with some success by his colleagues. In some ways, assumption management was found to complement agile development. However, AM was not fully integrated into the team's development\u00a0\u2026", "num_citations": "12\n", "authors": ["66"]}
{"title": "The community workbench\n", "abstract": " COMMUNITY is a parallel program design language initially developed by Jos~ Fiadeiro and Tom Maibaum [3] to show how programs fit into Goguen's categorical approach to General Systems Theory. Since then, the language and its framework have been extended to provide a formal platform for architectural design of open, reactive, reconfigurable systems [2, 5, 6]. COMMUNITY programs are in the style of UNITY programs [1], but they also combine elements from Interacting Processes [4]. However, COMMUNITY has a richer coordination model--based on shared action synchronisation and the sharing of input variables of a component with output variables of other components--and, even more important, it requires interaction between components (name bindings) to be made explicit. In this way, the coordination aspects of a system can be separated from the computational aspects and extemalised, making\u00a0\u2026", "num_citations": "11\n", "authors": ["66"]}
{"title": "Coordination patterns for component-based systems\n", "abstract": " The separation between computation and coordination offers the possibility for systems to be evolved through the addition, deletion or substitution of the connectors that coordinate the interaction between their components, without interfering with the computations that are performed locally. Ideally, this form of evolution should be applicable regardless of the languages in which these computations are programmed, thus allowing for the integration of third-party, closed components, like legacy systems. In order to establish universal principles that support this level of generality, we propose a mathematical pattern that clarifies essential mechanisms of coordination that support evolution, and a design pattern that allows for such mechanisms to be implemented in platforms for component-based system development like CORBA, EJB and COM.", "num_citations": "11\n", "authors": ["66"]}
{"title": "Issues in representing domain-specific concerns in model-driven engineering\n", "abstract": " The integration of domain-specific concepts in a model-driven engineering (MDE) approach raises a number of interesting research questions. There are two possibilities to represent these concepts. The first one focuses on models that contain domain-specific concepts only, i.e. domain-specific modelling languages (DSML). The second one advocates the integration of domain-specific concepts in general-purpose models, using what we will refer to in this paper as domain-specific modelling annotation languages (DSMAL). In this position paper, we argue that each approach is particularly suited for specific activities and specific actors, and show how they can be developed and used together. We also highlight the challenges created by the use of two representations, such as the evaluation of models OCL constraints and the synchronisation between the two representations. As an illustration, we present rbacUML\u00a0\u2026", "num_citations": "10\n", "authors": ["66"]}
{"title": "Tool support for UML-based specification and verification of role-based access control properties\n", "abstract": " It has been argued that security perspectives, of which access control is one, should be taken into account as early as possible in the software development process. Towards that goal, we present in this paper a tool supporting our modelling approach to specify and verify access control in accordance to the NIST standard Role-Based Access Control (RBAC). RBAC is centred on mapping users to their roles in an organisation, to make access control permissions easier to set and maintain. Our modelling approach uses only standard UML mechanisms, like metamodels and OCL constraints, and improves on existing approaches in various ways: designers don't have to learn new languages or adopt new tools or methodologies; user-role and role-permission assignments can be specified separately to be reused across models; access control is specified over class and activity diagrams, including'anti-scenarios'\u00a0\u2026", "num_citations": "10\n", "authors": ["66"]}
{"title": "Separation of core concerns: Computation, coordination, and configuration\n", "abstract": " Separating concerns helps developers to get a conceptual grip on large software systems, to reuse parts of the system, and to evolve it. We are interested in separating three generic concerns that are part of any software system: computation, coordination, and configuration. For that purpose we propose a three-layer architecture using two new modeling primitives: coordination contracts to define interactions and coordination contexts to govern system reconfiguration. Each layer is superposed in a transparent way on the layer below, which facilitates the modification of coordination and configuration policies to make the system evolve.", "num_citations": "10\n", "authors": ["66"]}
{"title": "Specification, testing and analysis of (dynamic) software architecture with the chemical abstract machine\n", "abstract": " We feel that the Chemical Abstract Machine (CHAM) is a useful formal description technique for static and dynamic software architectures that facilitates analysis and testing. Our position is based on work done so far and on the potential of rewriting approaches, of which the CHAM is a special case.", "num_citations": "10\n", "authors": ["66"]}
{"title": "Conceptual structures for modeling in CIM\n", "abstract": " The International Standards Organization (ISO) will release in 1993 the first version of the STEP standard, which is dedicated to the exchange of product model data, and is seen as the basis of the next generation of enterprise information modeling tools. Almost in the same time frame ANSI will release the Information Resource Dictionary System (IRDS) Conceptual Schema standard [1], which recommends the conceptual graphs (CGs) or other representation languages based on logic to be used for enterprise information modeling and integration. In this paper we develop the foundations for the utilization of conceptual structures (CS) in combination with EXPRESS and STEP Application Protocols in the field of Computer Integrated Manufacturing (CIM). The most important result described here is a mapping of EXPRESS into CGs. Around it we develop the architecture of a system able to analyze and\u00a0\u2026", "num_citations": "10\n", "authors": ["66"]}
{"title": "A survey of the forms of Java reference names\n", "abstract": " The readability of identifiers is a major factor of program comprehension and an aim of naming convention guidelines. Due to their semantic content, identifiers are also used in feature and bug location, among other software maintenance tasks. Looking at how names are used in practice may lead to insights on potential problems for comprehension and for programming support tools that process identifiers. Class and method names are already well represented in the literature. This paper presents an investigation of Java field, formal argument and local variable names, which we collectively call reference names. These names cannot be ignored because they constitute over half the unique names and almost 70% of the name declarations in the corpus investigated. We analysed the forms of 3.5 million reference name declarations in 60 well known Java projects, examining the phrasal structure of names\u00a0\u2026", "num_citations": "9\n", "authors": ["66"]}
{"title": "Enhancing dependability through flexible adaptation to changing requirements\n", "abstract": " This paper describes an architectural approach that facilitates the dynamic adaptation of systems to changing domain rules. The approach relies on \u201ccoordination contracts\u201d, a modelling and implementation primitive we have developed for run-time reconfiguration. Our framework includes an engine that, whenever a service is called, checks the domain rules that are applicable and configures the response of the service before proceeding with the call.               This approach enhances dependability in two essential ways: on the one hand, it guarantees that system execution is always consistent with the domain logic because service response is configured automatically (i.e., without any need for programmer intervention); on the other hand, it makes it possible for changes to be incorporated into existing domain rules, and from new rules to be created, with little effort, because coordination contracts can be\u00a0\u2026", "num_citations": "8\n", "authors": ["66"]}
{"title": "The coordination development environment\n", "abstract": " Coordination contracts [1][2] are a modelling primitive, based on methodological and mathematical principles [8],[3], that facilitates the evolution of software systems. The use of coordination contracts encourages the separation of computation from coordination aspects, and the analysis of which are the \u201cstable\u201d and \u201cunstable\u201d entities of the system regarding evolution. Coordination contracts encapsulate the coordination aspects, i.e., the way components interact, and as such may capture the business rules [7] or the protocols [6] that govern interactions within the application and between the application and its environment.", "num_citations": "8\n", "authors": ["66"]}
{"title": "A simple description language for dynamic architectures\n", "abstract": " The Chemical Abstract Machine (CHAM) is a very elegant and simple computational model that has been used for the specification of both static and dynamic architectures. However, so far those descriptions are ad-hoc and monolithic, thus making it difficult to perceive the elements and form of an architecture. In this paper we present some syntactic constructs and a methodology to specify an architecture in a principled, explicit, and modular way, thus proposing a very simple and compact Architecture Description Language (ADL) which is especially suited for dynamic architectures.", "num_citations": "8\n", "authors": ["66"]}
{"title": "An X-Windows toolkit for knowledge acquisition and representation based on Conceptual Structures\n", "abstract": " This paper describes GET (Graph Editor and Tools), a tool based on Sowa's conceptual structures, which can be used for generic knowledge acquisition and representation. The system enabled the acquisition of semantic information (restrictions) for a lexicon used by a semantic interpreter for Portuguese sentences featuring some deduction capabilities. GET also enables the graphical representation of conceptual relations by incorporating an X-Windows based editor.", "num_citations": "8\n", "authors": ["66"]}
{"title": "Evolving and using coordinated systems\n", "abstract": " A four-layer architecture is outlined for the design of systems required to accommodate higher levels of evolution and personalization. This architecture is based on the separation of four different aspects that concern change: the computations the system has to perform to ensure basic functionalities, the interactions that can be superposed among those computations to make global properties emerge, the configurations of computations and interactions that respond to current business requirements, and the\" contexts\" in which the system is used according to organizational policies..", "num_citations": "7\n", "authors": ["66"]}
{"title": "Formal specification and analysis of dynamic reconfiguration of software architecture\n", "abstract": " Many of today\u2019s software systems must cope with changing configurations, and my PhD work (among other current research) seeks to provide ways to specify and analyse the dynamics of such architectures. I am looking at work done in Software Architecture, Distributed Systems, Mobile Computing, and Theoretical Computer Science in order to develop a formal framework at a sufficiently abstract level to investigate the fundamental similarities of architectural evolution, dynamic reconfiguration, and mobility and to serve as a high-level Architecture Description Language able to encompass other authors\u2019 proposals. The envisaged approach will use rewriting, logical, and categorical techniques.", "num_citations": "7\n", "authors": ["66"]}
{"title": "Linear-linear notation interface\n", "abstract": " The purpose of the LINEAR subgroup is to coordinate the development of a standard linear form grammar for Conceptual Graphs and to develop related tools. The main aim of this paper is to present a linear form grammar for conceptual graphs which we hope will form the basis for future standardization e orts. We also suggest some possible extensions to this grammar and contrast it with the grammar used by PEIRCE.In the following section we present a linear form grammar based on the work of Esch 2] while section 3 discusses some suggested extensions to the linear form grammar. Section 4 presents the linear form grammar adopted by the current version of PEIRCE (version 0.1) and discusses some of the more signi cant di erences between this grammar and that of section 2. In appendix A we include Sowa's comments on possible future directions with a discussion on integrating the CG linear form grammar with that of KIF 3], the Knowledge Interchange Format developed by the Interlingua Committee of the DARPA-sponsored Knowledge Sharing E ort.", "num_citations": "7\n", "authors": ["66"]}
{"title": "Introduction to the special section on fundamental approaches to software engineering\n", "abstract": " The papers in this special section are revised and extended versions of presentations at FASE\u201904 and FASE\u201905. FASE, the International Conference on Fundamental Approaches to Software Engineering, is part of ETAPS, the European Joint Conferences on Theory and Practice of Software. Its seventh edition was held in Barcelona, Spain, during March/April 2004 and its eighth edition in Edinburgh, UK, during April 2005.FASE addresses a broad range of topics in software engineering, focusing on theories for and foundations of realistic approaches to currently the most challenging problems of system and software development. The combination of theory and its practical application to software engineering problems makes a large part of the papers presented at FASE fall in the area of interest of this journal. The proceedings of FASE\u201904 and FASE\u201905 were published in Springer\u2019s Lecture Notes in Computer Science\u00a0\u2026", "num_citations": "6\n", "authors": ["66"]}
{"title": "Modelling the GSM handover protocol in CommUnity\n", "abstract": " CommUnity is a formal approach to software architecture. It has a precise, yet intuitive mathematical semantics based on category theory. It supports, at the methodological level, a clear separation between computation, coordination, and distribution (including mobility). It provides a simple state-based language for describing component behaviour that is inspired by Unity and Interacting Processes. It also addresses composition as a first class concern and accounts for the emergence of global system properties from interconnections. This paper describes the approach and available tool support by modelling essential aspects of the GSM handover protocol. We also sketch a framework that we are implementing for the distributed execution of such specifications using Klava, a Java library for mobile agent systems based on tuple spaces.", "num_citations": "6\n", "authors": ["66"]}
{"title": "Architecting Dependable Systems II\n", "abstract": " Architecting Dependable Systems II | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksArchitecting Dependable Systems II ABSTRACT No abstract available. Index Terms (auto-classified) 1.Architecting Dependable Systems II 1.Applied computing 1.Enterprise computing Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide books cover image Architecting Dependable Systems II November 2004 ISBN:3540231684 Authors: Rog\u00e9rio de Lemos profile image , \u2026", "num_citations": "6\n", "authors": ["66"]}
{"title": "Semantics of transient connectors in rewriting logic\n", "abstract": " Research in Software Architectures has put forward the concept of connector to express complex relationships between system components, thus facilitating the separation of coordination from computation. A system can then be understood, at a given level of abstraction, in terms of its components and the connectors that establish how they interact. However, for systems in which many interconnections exist between their components, the architectures themselves may become very complex due to the high number of connectors in place. This is especially true in the context of mobile systems in which the interconnections are, by nature, transient in the sense that, at a given instant of time, only a subset of the potential connectors are actually effective. In this paper, we formalise a notion of transient connector that allows, at any given moment, for the architecture to depict only the connectors that are active and, in this way, capture the dynamics of architectures themselves. Our approach is based on the use of Community, a Unity-like program design language that has a semantics in Category Theory, and rewriting logic as a means of capturing the dynamic aspects of connectors", "num_citations": "6\n", "authors": ["66"]}
{"title": "Software architecture evolution and the chemical abstract machine\n", "abstract": " The Chemical Abstract Machine (CHAM) is a general-purpose, simple, intuitive and operational programming model that has been used for the speci cation and analysis of the computational behaviour of software architectures. It therefore seems to be a good candidate to describe also the dynamics of the architecture itself and the coordination between the two processes. We also explore the ability of the CHAM to help establish the principles of software architecture evolution by encoding di erent approaches within the same framework.", "num_citations": "6\n", "authors": ["66"]}
{"title": "Learning to program: from problems to code\n", "abstract": " This paper introduces the approach to teaching problem-solving and text-based programming that has been adopted in a large, post-18, undergraduate, key introductory module (L4 FHEQ) on Computing and Information Technology at the Open University (UK). We describe how students are equipped with programming, but foremost problem-solving skills. Key ingredients of the approach are interleaving of skills, explicit worked examples of decomposition, formulation of algorithms (with the help of patterns for recurring problems) and translation to code. Preliminary results are encouraging: students' average course work scores increase as they progress through the course.", "num_citations": "5\n", "authors": ["66"]}
{"title": "An architectural evolution dataset\n", "abstract": " A good evolution process and a good architecture can greatly support the maintainability of long-lived, large software systems. We present AREVOL, a dataset for the empirical study of architectural evolution. The dataset comprises two popular systems from the same domain and using the same component model, to make comparative studies possible. Besides the original component metadata, AREVOL includes scripts to obtain simplified models that nevertheless support rich studies of architectural evolution, as the authors' previous work has shown.", "num_citations": "5\n", "authors": ["66"]}
{"title": "Teaching software systems thinking at The Open University\n", "abstract": " The Open University is a distance-based higher education institution. Most of our students are in employment and study from home, contacting their tutor and fellow students via e-mail and discussion forums. In this paper, we describe our undergraduate and postgraduate modules in the software systems area, how we teach them at a distance, and our focus on shifting our students' minds into a reflective, critical, holistic socio-technical view of software systems that is relevant to their particular professional contexts.", "num_citations": "5\n", "authors": ["66"]}
{"title": "Developing a domain-specific plug-in for a modelling platform: The good, the bad, the ugly\n", "abstract": " Domain-Specific Modelling Languages (DSML) allow software engineers to use the techniques and tools of Model-Driven Engineering (MDE) to express, represent and analyse a particular domain. By defining DSMLs as UML profiles, i.e. domain-specific extensions of the UML metamodel, development time for DSMLs can be greatly reduced by extending existing UML tools. In this paper, we reflect on our own experience in building rbacUML, a DSML for Role-Based Access Control modelling and analysis, as a plugin for a UML modelling platform. We describe what motivated our choice, and discuss the advantages and drawbacks of using an existing platform to develop a DSML on top of UML and additional analysis tooling.", "num_citations": "5\n", "authors": ["66"]}
{"title": "A classification of formal specifications for dynamic software architectures\n", "abstract": " Architectural change is defined as the addition and removal of components and connectors. Dynamic software architectures are those architectures that modify their architecture and enact the modifications during the system\u2019s execution. This behavior is most commonly known as run-time evolution or dynamism. As dynamic software architecture use becomes more widespread, it is important to gain a better understanding of the foundations of this type of software evolutionary change and be able to classify formalisms, approaches and tools. Current evaluations in the areas of software architecture and evolutionary change have made strides in classification but are not sufficient to evaluate dynamic software architectures. A dedicated comparison of dynamic software architectures and architectural formalisms is necessary in order to gain a deeper understanding of run-time evolution. In this paper we present a set of classification criteria for the comparison of dynamic software architectures based on: change type, change process, and change infrastructure. We demonstrate the use of the criteria by classifying formal specifications of dynamic software architectures based on graphs, process algebras, logic, and other formalisms. Specifically, we survey and classify 14 formal specification approaches.", "num_citations": "5\n", "authors": ["66"]}
{"title": "A different perspective on canonicity\n", "abstract": " One of the most interesting aspects of Conceptual Structures Theory is the notion of canonicity. It is also one of the most neglected: Sowa seems to have abandoned it in the new version of the theory, and most of what has been written on canonicity focuses on the generalization hierarchy of conceptual graphs induced by the canonical formation rules. Although there is a common intuition that a graph is canonical if it is \u201cmeaningful\u201d, the original theory is somewhat unclear about what that actually means, in particular how canonicity is related to logic.             This paper argues that canonicity should be kept a first-class notion of Conceptual Structures Theory, provides a detailed analysis of work done so far, and proposes new definitions of the conformity relation and the canonical formation rules that allow a clear separation between canonicity and truth.", "num_citations": "5\n", "authors": ["66"]}
{"title": "Conceptual structures linear notation: A proposal for PEIRCE\n", "abstract": " This document describes a grammar for the linear notation of Conceptual Structures (CS). It has been carefully designed in order to be simple (and therefore easy to understand and implement), expressive, and easy to modify. The main goal has been to develop a compact yet powerful grammar that could be used for the Peirce workbench.The goal of producing such a workbench is twofold: on one hand to provide ready-to-use, state-of-the-art software for CS users, on the other hand to provide a set of software components that CG researchers may easily extend or change in order to implement and test their theories. The main module of the workbench is the database (DB) module implementing the data structures needed to store types, markers, graphs, canons, etc. It will be used by every other Peirce component. As the syntax has a direct impact on the data structures, whenever the linear notation is expanded or modi ed, the DB module may have to be altered which could lead to code changes in all other components, even if they don't use the new notation.", "num_citations": "5\n", "authors": ["66"]}
{"title": "Searching efficiently in posets\n", "abstract": " In recent years hierarchies have gained new importance in computer science, most notably due to object-oriented programming languages, order-sorted logics, and terminological knowledge representation systems. It is thus necessary to find efficient ways to implement hierarchies and the operations upon them. The mathematical abstraction for hierarchies is the partially ordered set (poset), and the crucial operation is search. Therefore, this paper will survey several algorithms for associative retrieval---the most general form of searching---in arbitrary posets. 1 Introduction Hierarchies appear in most modern programming and knowledge representation languages: the former usually have hierarchies of types [1] or classes, while the latter normally have hierarchies of concepts [3]. Nevertheless, two basic operations are needed in both cases: insertion of a given element of the\" universe\"(the domain of application) into the hierarchy and testing if some given element is already in the hie...", "num_citations": "5\n", "authors": ["66"]}
{"title": "An evaluation of design rule spaces as risk containers\n", "abstract": " It is well understood that software development can be a risky enterprise and industrial projects often overrun budget and schedule. Effective risk management is, therefore, vital for a successful project outcome. Design Rule Spaces (DRSpaces) have been used by other researchers to understand why implemented software is error-prone [1, 2]. This industrial case study evaluates whether such spaces are durable, meaningful, and isolating risk containers. DRSpaces were created from UML class diagrams of architectural design artefacts. In our study, object orientated metrics were calculated from the UML diagrams, and compared to the error-proneness of the DRSpace implementation, to determine whether architectural coupling translated into implementation difficulties. A correlation between architectural coupling and error-proneness of DRSpaces was observed in the case study. Software developers were asked\u00a0\u2026", "num_citations": "4\n", "authors": ["66"]}
{"title": "Coordination technologies for component-based systems\n", "abstract": " The volatility of requirements and the increasing complexity and heterogeneity of systems nowadays, eg those that control critical infrastructures, is putting an increasing emphasis on the ability for systems to accommodate, in run-time, the changes required by new or different needs with a minimum impact on the implemented behaviours and without interruption of service. In this paper, we show how architectural principles can be used for addressing this problem. We propose a discipline for software evolution based on the separation between what in systems are the basic service-providers (components) and the mechanisms (contracts/connectors) through which the behaviour of these components is coordinated to fulfil functional requirements. We show how this discipline can be supported by a semantic primitive\u2013coordination contracts\u2013through which we can enrich object-oriented and component-based\u00a0\u2026", "num_citations": "4\n", "authors": ["66"]}
{"title": "Theory and practice of software architectures\n", "abstract": " ObjectivesTo provide mathematical foundations to the Theory and Practice of Software Architectures\u2014abstracting a mathematical semantics from existing languages and models\u2014using it to generalise these ideas to other contexts\u2014explore useful generalisations of existing concepts capitalizing on research on SA, Reconfigurable Distributed Systems and Coordination Languages and Models", "num_citations": "4\n", "authors": ["66"]}
{"title": "Support for business-driven evolution with coordination technologies\n", "abstract": " Software evolution is, ever more, a critical concern for most business organizations. In spite of many promises, software development techniques, such as Object-Oriented ones, have fallen short of addressing this problem. We show how new technologies based on the notion of\" coordination contract\" can be deployed for managing the levels of change imposed by the evolution of requirements and technological environments, both in terms of semantic modeling and tool support.", "num_citations": "4\n", "authors": ["66"]}
{"title": "Teoria b\u00e1sica das estruturas conceptuais\n", "abstract": " As Estruturas Conceptuais s\u00e3o um formalismo de representa\u00e7\u00e3o de conhecimentos baseado em grafos, os chamados grafos conceptuais. A teoria foi inicialmente desenvolvida por John Sowa h\u00e1 dez anos. Desde ent\u00e3o, uma comunidade cient\u00edfica cada vez mais ampla tem-na utilizado em muitas \u00e1reas de aplica\u00e7\u00e3o e prop\u00f4s v\u00e1rias altera\u00e7\u00f5es \u00e0 teoria original. Tamb\u00e9m est\u00e1 em desenvolvimento uma implementa\u00e7\u00e3o estado-da-arte gratuita e, al\u00e9m disso, os grafos conceptuais foram adoptados num padr\u00e3o ANSI em prepara\u00e7\u00e3o. Apesar desta actividade n\u00e3o existe de facto uma defini\u00e7\u00e3o formal, completa, consistente e revista da Teoria das Estruturas Conceptuais.  Esta disserta\u00e7\u00e3o vem contribuir para essa defini\u00e7\u00e3o ao estender, refinar e clarificar as no\u00e7\u00f5es b\u00e1sicas da teoria. A classifica\u00e7\u00e3o dos grafos conceptuais em grafos sintacticamente correctos, grafos bem tipados, grafos ontologicamente correctos, chamados grafos can\u00f3nicos, e grafos verdadeiros \u00e9 a base da clarifica\u00e7\u00e3o do significado das v\u00e1rias no\u00e7\u00f5es e serve de guia \u00e0s extens\u00f5es e aos refinamentos introduzidos. As principais extens\u00f5es foram feitas no sistema de tipos e no esquema de depend\u00eancias entre v\u00e9rtices de grafos, e o refinamento de quase todos os aspectos da teoria - em particular das regras de forma\u00e7\u00e3o de grafos can\u00f3nicos e das regras de infer\u00eancia para os grafos verdadeiros - inclui o tratamento formal de algumas propostas informais de outros autores.  [Conceptual Structures is a knowledge representation formalism based on graphs, the so called conceptual graphs. The theory was initially developed by John Sowa 10 years ago. Since then, it has been used by a\u00a0\u2026", "num_citations": "4\n", "authors": ["66"]}
{"title": "GET-Some Notes on the Implementation\n", "abstract": " These notes provide a brief overview of the implementation of GET, the Graph Editor and Tools for the conceptual structures defined in [Sow84]. The used data structures will be emphasized, while the interested reader should consult the Prolog source code for a description of the predicates. 1 Introduction This paper can be seen as an extended abstract of what will be the fourth part of [Wer91], namely a detailed account of the implementation. A programmer's guide is also planned, but for the time being the program listing should suffice, as comments make for over one third of it. Therefore, the focus will be on the used data structures, examples of which are given as the formal description is somewhat terse. It is assumed that you have read [Wer91], which in turn assumes some familiarity with the conceptual graph formalism ([Sow84]). Furthermore, a basic knowledge of Prolog is also taken for granted. A part of the Conceptual Graph Tools was implemented in Arity Prolog for MS-DOS...", "num_citations": "4\n", "authors": ["66"]}
{"title": "Some issues in the \u2018archaeology\u2019of software evolution\n", "abstract": " During a software project\u2019s lifetime, the software goes through many changes, as components are added, removed and modified to fix bugs and add new features. This paper is intended as a lightweight introduction to some of the issues arising from an \u2018archaeological\u2019 investigation of software evolution. We use our own work to look at some of the challenges faced, techniques used, findings obtained, and lessons learnt when measuring and visualising the historical changes that happen during the evolution of software.", "num_citations": "3\n", "authors": ["66"]}
{"title": "Graph-centric tools for understanding the evolution and relationships of software structures\n", "abstract": " We present a suite of small tools, implemented as a pipeline of text file manipulating scripts, that, on one hand, measure the evolution of any software structure that can be represented as a directed graph of software elements and relations and, on the other hand, visualise any three attributes of any set of software artefacts that can be related to the elements shown in the graph. We illustrate the applicability of the tool with our work on the evolution of the Eclipse architecture and the relation between bugs and components.", "num_citations": "3\n", "authors": ["66"]}
{"title": "A model-driven approach to extract views from an architecture description language\n", "abstract": " A common approach to defining architectural views is to have independent heterogeneous representations that are tailored to each view's purpose, but this makes reconciling views into an overall architectural description harder. In this paper we put forward a complementary (not alternative) approach in which some views are derived from a given architecture description language (ADL) in a systematic way, by listing the design questions each view should answer. The approach is based on constructing the language's metamodel and extending it with the entities and associations needed to capture and explicitly relate the required views.", "num_citations": "3\n", "authors": ["66"]}
{"title": "Coordination for Distributed Business Systems.\n", "abstract": " We motivate, discuss and present extensions to architecture modelling techniques through which business systems can support services and applications that are location and network aware. These extensions provide a complete separation between three concerns: Computation, which accounts for the way service functionalities are provided in system components, Coordination, which accounts for the interactions that need to be put in place to enforce business rules, and Distribution, which accounts for the need to reconfigure the way services are provided in reaction to changes in the locations where functionalities are computed and the communication infrastructure over which coordination takes place.", "num_citations": "3\n", "authors": ["66"]}
{"title": "GET: An implementation of conceptual graphs\n", "abstract": " This paper describes GET (Graph Editor and Tools), a partial implementation of Sowa's conceptual structures. First, a brief overview of X-Prolog, an X-Windows based Prolog programming environment, is given. A summary of GET's graphical interface and linear notation follows. Finally, an example application using the graphs to represent sentences in Portuguese will be presented.", "num_citations": "3\n", "authors": ["66"]}
{"title": "The Open Networking Lab: Hands-on Vocational Learning in Computer Networking\n", "abstract": " An increasingly connected society demands people who can design, set up, monitor and maintain networks of computers and devices. Traditional classroom instruction cannot keep pace with demand, and networking hardware costs can be too high for widespread classroom use. This paper presents the Open Networking Lab, a new UK initiative for supporting hands-on vocational learning in computer networking. The Open Networking Lab will facilitate the development of introductory practical networking skills without using hardware, through the provision of a web-based network simulation package integrated into learning resources and activities. These learning resources will be evaluated by students and lecturers from a cluster of Further Education colleges in the UK and will subsequently be made available to learners worldwide via free and open courseware.", "num_citations": "2\n", "authors": ["66"]}