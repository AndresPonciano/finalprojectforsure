{"title": "Automatic test case generation for UML activity diagrams\n", "abstract": " The test case generation from design specifications is an important work in testing phase. In this paper, we use UML activity diagrams as design specifications, and present an automatic test case generation approach. The approach first randomly generates abundant test cases for a JAVA program under testing. Then, by running the program with the generated test cases, we can get the corresponding program execution traces. Last, by comparing these traces with the given activity diagram according to the specific coverage criteria, we can get a reduced test case set which meets the test adequacy criteria. The approachcan also be used to check the consistency between the program execution traces and the behavior of UML activity diagrams.", "num_citations": "224\n", "authors": ["1730"]}
{"title": "UML activity diagram-based automatic test case generation for Java programs\n", "abstract": " Test case generation based on design specifications is an important part of testing processes. In this paper, Unified Modeling Language activity diagrams are used as design specifications. By setting up several test adequacy criteria with respect to activity diagrams, an automatic approach is presented to generate test cases for Java programs. Instead of directly deriving test cases from activity diagrams, this approach selects test cases from a set of randomly generated ones according to a given test adequacy criterion. In the approach, we first instrument a Java program under testing according to its activity diagram model, and randomly generate abundant test cases for the program. Then, by running the instrumented program we obtain the corresponding program execution traces. Finally, by matching these traces with the behavior of the activity diagram, a reduced set of test cases are selected according to the\u00a0\u2026", "num_citations": "101\n", "authors": ["1730"]}
{"title": "Natural proofs for structure, data, and separation\n", "abstract": " We propose natural proofs for reasoning with programs that manipulate data-structures against specifications that describe the structure of the heap, the data stored within it, and separation and framing of sub-structures. Natural proofs are a subclass of proofs that are amenable to completely automated reasoning, that provide sound but incomplete procedures, and that capture common reasoning tactics in program verification. We develop a dialect of separation logic over heaps, called Dryad, with recursive definitions that avoids explicit quantification. We develop ways to reason with heaplets using classical logic over the theory of sets, and develop natural proofs for reasoning using proof tactics involving disciplined unfoldings and formula abstractions. Natural proofs are encoded into decidable theories of first-order logic so as to be discharged using SMT solvers. We also implement the technique and show that a\u00a0\u2026", "num_citations": "100\n", "authors": ["1730"]}
{"title": "Natural proofs for data structure manipulation in C using separation logic\n", "abstract": " The natural proof technique for heap verification developed by Qiu et al. [32] provides a platform for powerful sound reasoning for specifications written in a dialect of separation logic called Dryad. Natural proofs are proof tactics that enable automated reasoning exploiting recursion, mimicking common patterns found in human proofs. However, these proofs are known to work only for a simple toy language [32]. In this work, we develop a framework called VCDryad that extends the Vcc framework [9] to provide an automated deductive framework against separation logic specifications for C programs based on natural proofs. We develop several new techniques to build this framework, including (a) a novel tool architecture that allows encoding natural proofs at a higher level in order to use the existing Vcc framework (including its intricate memory model, the underlying type-checker, and the SMT-based verification\u00a0\u2026", "num_citations": "63\n", "authors": ["1730"]}
{"title": "Recursive Proofs for Inductive Tree Data-Structures\n", "abstract": " We develop logical mechanisms and procedures to facilitate the verification of full functional properties of inductive tree data-structures using recursion that are sound, incomplete, but terminating. Our contribution rests in a new extension of first-order logic with recursive definitions called Dryad, a syntactical restriction on pre- and post-conditions of recursive imperative programs using Dryad, and a systematic methodology for accurately unfolding the footprint on the heap uncovered by the program that leads to finding simple recursive proofs using formula abstraction and calls to SMT solvers. We evaluate our methodology empirically and show that several complex tree data-structure algorithms can be checked against full functional specifications automatically, given pre- and post-conditions. This results in the first automatic terminating methodology for proving a wide variety of annotated algorithms on tree data\u00a0\u2026", "num_citations": "60\n", "authors": ["1730"]}
{"title": "Efficient decision procedures for heaps using STRAND\n", "abstract": " The Strand [10] logic allows expressing structural properties of heaps combined with the data stored in the nodes of the heap. A semantic fragment of Strand as well as a syntactically defined subfragment of it are known to be decidable [10]. The known decision procedure works by combining a decision procedure for MSO on trees (implemented by the tool Mona) and a decision procedure for the quantifier-free fragment of the data-theory (say, integers, and implemented using a solver like Z3). The known algorithm for deciding the syntactically defined decidable fragment (which is the same as the one for the semantically defined decidable fragment) involves solving large MSO formulas over trees, whose solution is the main bottleneck in obtaining efficient algorithms. In this paper, we focus on the syntactically defined decidable fragment of Strand, and obtain a new and more efficient algorithm. Using a set of\u00a0\u2026", "num_citations": "37\n", "authors": ["1730"]}
{"title": "Adaptive Concretization for Parallel Program Synthesis\n", "abstract": " Program synthesis tools work by searching for an implementation that satisfies a given specification. Two popular search strategies are symbolic search, which reduces synthesis to a formula passed to a SAT solver, and explicit search, which uses brute force or random search to find a solution. In this paper, we propose adaptive concretization, a novel synthesis algorithm that combines the best of symbolic and explicit search. Our algorithm works by partially concretizing a randomly chosen, but likely highly influential, subset of the unknowns to be synthesized. Adaptive concretization uses an online search process to find the optimal size of the concretized subset using a combination of exponential hill climbing and binary search, employing a statistical test to determine when one degree of concretization is sufficiently better than another. Moreover, our algorithm lends itself to a highly parallel implementation\u00a0\u2026", "num_citations": "30\n", "authors": ["1730"]}
{"title": "Synthesis of recursive ADT transformations from reusable templates\n", "abstract": " Recent work has proposed a promising approach to improving scalability of program synthesis by allowing the user to supply a syntactic template that constrains the space of potential programs. Unfortunately, creating templates often requires nontrivial effort from the user, which impedes the usability of the synthesizer. We present a solution to this problem in the context of recursive transformations on algebraic data-types. Our approach relies on polymorphic synthesis constructs: a small but powerful extension to the language of syntactic templates, which makes it possible to define a program space in a concise and highly reusable manner, while at the same time retains the scalability benefits of conventional templates. This approach enables end-users to reuse predefined templates from a library for a wide variety of problems with little effort. The paper also describes a novel optimization that further\u00a0\u2026", "num_citations": "27\n", "authors": ["1730"]}
{"title": "Reconciling enumerative and deductive program synthesis\n", "abstract": " Syntax-guided synthesis (SyGuS) aims to find a program satisfying semantic specification as well as user-provided structural hypotheses. There are two main synthesis approaches: enumerative synthesis, which repeatedly enumerates possible candidate programs and checks their correctness, and deductive synthesis, which leverages a symbolic procedure to construct implementations from specifications. Neither approach is strictly better than the other: automated deductive synthesis is usually very efficient but only works for special grammars or applications; enumerative synthesis is very generally applicable but limited in scalability.", "num_citations": "18\n", "authors": ["1730"]}
{"title": "Natural synthesis of provably-correct data-structure manipulations\n", "abstract": " This paper presents natural synthesis, which generalizes the proof-theoretic synthesis technique to support very expressive logic theories. This approach leverages the natural proof methodology and reduces an intractable, unbounded-size synthesis problem to a tractable, bounded-size synthesis problem, which is amenable to be handled by modern inductive synthesis engines. The synthesized program admits a natural proof and is a provably-correct solution to the original synthesis problem. We explore the natural synthesis approach in the domain of imperative data-structure manipulations and present a novel syntax-guided synthesizer based on natural synthesis. The input to our system is a program template together with a rich functional specification that the synthesized program must meet. Our system automatically produces a program implementation along with necessary proof artifacts, namely loop\u00a0\u2026", "num_citations": "15\n", "authors": ["1730"]}
{"title": "Path-oriented tool supporting for testing.\n", "abstract": " Software testing is an important method of assuring quality and enhancing reliability and path coverage is an essential criterion for testing adequacy. Since the rigid path-cover testing is infeasible, we select and test some key paths, which outweigh others on affecting the overall quality of the system, to enhance test efficiency and profit. A general statistics-based automated tool aiming at object-oriented software systems was proposed. By static analysis and interpolation on code, this tool offers a diagnosis of statistical data derived from continual executions, which are driven by random test cases, for information of selecting key paths in correctness testing and reliability testing. Primary idea, corresponding algorithms of this tool, and some problems in implementation are exposed.", "num_citations": "11\n", "authors": ["1730"]}
{"title": "UML state machine diagram driven runtime verification of Java programs for message interaction consistency\n", "abstract": " In object-oriented programs, we often need to set some restrictions on the temporal orders of the message receiving for objects, which forms a class of safety requirements. In this paper, we use UML state machine diagrams as design specifications, and present an approach to runtime verification of Java programs, which is focused on the temporal order of message receiving based consistency verification between the behavior of state machine diagrams and the program execution traces. In the approach, we first instrument the program under verification so as to gather the program execution traces related to a given state machine diagram. Then we drive the instrumented program by random test cases so as to generate the program execution traces. Finally we check if the collected program execution traces are consistent with the behavior of the state machine diagram, which means that the temporal orders of the\u00a0\u2026", "num_citations": "10\n", "authors": ["1730"]}
{"title": "Runtime verification of Java programs for scenario-based specifications\n", "abstract": " In this paper, we use UML sequence diagrams as scenario-based specifications, and give the solution to runtime verification of Java programs for the safety consistency and the mandatory consistency. The safety consistency requires that any forbidden scenario described by a given sequence diagram never happens during the execution of a program, and the mandatory consistency requires that if a reference scenario described by the given sequence diagrams occurs during the execution of a program, it must immediately adhere to a scenario described by the other given sequence diagram. In the solution, we first instrument the program under verification so as to gather the program execution traces related to a given scenario-based specification; then we drive the instrumented program by random test cases so as to generate the program execution traces; last we check if the collected program execution\u00a0\u2026", "num_citations": "10\n", "authors": ["1730"]}
{"title": "UML interaction model-driven runtime verification of Java programs\n", "abstract": " The authors use unified modelling language (UML) 2.0 interaction overview diagrams (IODs) and sequence diagrams to construct simple and expressive scenario-based specifications, and present an approach to runtime verification of Java programs for exceptional consistency and mandatory consistency. The exceptional consistency requires that any forbidden scenario described by a given IOD never happens during the execution of a program, and the mandatory consistency requires that if a reference scenario described by a given sequence diagram occurs during the execution of a program, it must immediately adhere to a scenario described by a given IOD. In the approach, the authors first instrument a program under verification so as to gather the program execution traces related to a given scenario-based specification; then they drive the instrumented program to execute for generating the program\u00a0\u2026", "num_citations": "7\n", "authors": ["1730"]}
{"title": "Learning network design objectives using a program synthesis approach\n", "abstract": " While the networking community has extensively tackled network design problems using optimization or other techniques (eg, in areas such as traffic-engineering, and resource allocation), much of this work focuses on efficiently generating designs assuming well-defined objectives. In this paper, we argue that in practice, the objectives of a network design task may not be easy to specify for an architect. We argue for, and present a structured approach where the objectives of a network design task are learnt through iterative interactions with the architect. Our approach is inspired by a programming-by-examples approach that has seen success in the programming languages community. However, conventional program synthesis techniques do not apply because in our context a user can only provide a relative comparison between multiple choices on which one is more desirable, rather than provide an exact output\u00a0\u2026", "num_citations": "3\n", "authors": ["1730"]}
{"title": "Program synthesis with algebraic library specifications\n", "abstract": " A key challenge in program synthesis is synthesizing programs that use libraries, which most real-world software does. The current state of the art is to model libraries with mock library implementations that perform the same function in a simpler way. However, mocks may still be large and complex, and must include many implementation details, both of which could limit synthesis performance. To address this problem, we introduce JLibSketch, a Java program synthesis tool that allows library behavior to be described with algebraic specifications, which are rewrite rules for sequences of method calls, e.g., encryption followed by decryption (with the same key) is the identity. JLibSketch implements rewrite rules by compiling JLibSketch problems into problems for the Sketch program synthesis tool. More specifically, after compilation, library calls are represented by abstract data types (ADTs), and rewrite rules\u00a0\u2026", "num_citations": "2\n", "authors": ["1730"]}
{"title": "A decidable logic for tree data-structures with measurements\n", "abstract": " We present , a decidable logic that allows reasoning about tree data-structures with measurements. This logic supports user-defined recursive measure functions based on Max or Sum, and recursive predicates based on these measure functions, such as AVL trees or red-black trees. We prove that the logic\u2019s satisfiability is decidable. The crux of the decidability proof is a small model property which allows us to reduce the satisfiability of  to quantifier-free linear arithmetic theory which can be solved efficiently using SMT solvers. We also show that  can encode a variety of verification and synthesis problems, including natural proof verification conditions for functional correctness of recursive tree-manipulating programs, legality conditions for fusing tree traversals, synthesis conditions for conditional linear-integer arithmetic functions. We developed the decision procedure and successfully\u00a0\u2026", "num_citations": "2\n", "authors": ["1730"]}
{"title": "UML \u884c\u4e3a\u56fe\u9a71\u52a8\u7684 Java \u7a0b\u5e8f\u8fd0\u884c\u65f6\u9a8c\u8bc1\u5de5\u5177\n", "abstract": " \u6458 \u8981 UML \u662f\u4e00\u79cd\u6807\u51c6\u7684\u53ef\u89c6\u5316\u5efa\u6a21\u5de5\u5177, \u5e7f\u6cdb\u5e94\u7528\u4e8e\u8f6f\u4ef6\u7cfb\u7edf\u7684\u63cf\u8ff0, \u53ef\u89c6\u5316, \u6784\u5efa\u548c\u5efa\u7acb\u6587\u6863. \u672c\u6587\u4ecb\u7ecd\u4e86\u4e00 \u79cd UMI \u884c\u4e3a\u56fe\u9a71\u52a8\u7684 Java \u7a0b\u5e8f\u8fd0\u884c\u65f6\u9a8c\u8bc1\u5de5\u5177. \u8be5\u5de5\u5177\u4ee5\u4e00\u4e2a\u968f\u673a\u7684\u6d4b\u8bd5\u7528\u4f8b\u96c6\u4f5c\u4e3a\u8f93\u5165, \u8fd0\u884c\u7ecf\u8fc7\u63d2\u88c5\u7684\u88ab\u6d4b Java \u7a0b\u5e8f, \u5f97\u5230\u4e00\u7ec4\u7528\u4e8e\u9a8c\u8bc1\u7684\u7a0b\u5e8f\u8fd0\u884c\u8f68\u8ff9. \u901a\u8fc7\u5bf9\u7a0b\u5e8f\u8fd0\u884c\u8f68\u8ff9\u548c UML \u884c\u4e3a\u56fe\u4e2d\u5408\u6cd5\u7684\u4e8b\u4ef6\u5e8f\u5217\u7684\u6bd4\u8f83, \u8be5\u5de5\u5177\u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u7684\u52a8\u6001\u884c\u4e3a\u89c4\u7ea6\u8fdb\u884c\u68c0\u67e5. \u672c\u6587\u63cf\u8ff0\u4e86\u8be5\u5de5\u5177\u7684\u8bbe\u8ba1\u601d\u60f3, \u7b97\u6cd5\u548c\u5b9e\u73b0\u6280\u672f, \u5e76\u901a\u8fc7\u5bf9\u5b9e\u4f8b\u7814\u7a76\u5bf9\u8be5\u5de5\u5177\u7684\u53ef\u7528\u6027\u548c\u6709\u6548\u6027\u8fdb\u884c\u4e86\u8ba8\u8bba.", "num_citations": "2\n", "authors": ["1730"]}
{"title": "Streaming Transformations of Infinite Ordered-Data Words\n", "abstract": " In this paper, we define streaming register transducer (SRT), a one-way, letter-to-letter, transductional machine model for transformations of infinite data words whose data domain forms a linear group. Comparing with existing data word transducers, SRT are able to perform two extra operations on the registers: a linear-order-based comparison and an additive update. We consider the transformations that can be defined by SRT and several subclasses of SRT. We investigate the expressiveness of these languages and several decision problems. Our main results include: 1) SRT are closed under union and intersection, and add-free SRT are also closed under composition; 2) SRT-definable transformations can be defined in monadic second-order (MSO) logic, but are not comparable with first-order (FO) definable transformations; 3) the functionality problem is decidable for add-free SRT, the reactivity problem and inclusion problem are decidable for deterministic add-free SRT, but none of these problems is decidable in general for SRT.", "num_citations": "1\n", "authors": ["1730"]}
{"title": "Automatic techniques for proving correctness of heap-manipulating programs\n", "abstract": " Reliability is critical for system software, such as OS kernels, mobile browsers, embedded systems and cloud systems. The correctness of these programs, especially for security, is highly desirable, as they should provide a trustworthy platform for higher-level applications and the end-users. Unfortunately, due to its inherent complexity, the verification process of these programs is typically manual/semi-automatic, tedious, and painful. Automating the reasoning behind these verification tasks and decreasing the dependence on manual help is one of the greatest challenges in software verification. This dissertation presents two logic-based automatic software verification systems, namely Strand and Dryad, that help in the task of verification of heap-manipulating programs, which is one of the most complex aspects of modern software that eludes automatic verification. Strand is a logic that combines an expressive heap\u00a0\u2026", "num_citations": "1\n", "authors": ["1730"]}