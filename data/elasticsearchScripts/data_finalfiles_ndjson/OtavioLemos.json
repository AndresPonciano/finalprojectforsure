{"title": "Codegenie: using test-cases to search and reuse source code\n", "abstract": " We present CodeGenie, a tool that implements a test-driven approachto search and reuse of code available on large-scale coderepositories. While using CodeGenie developers design test cases fora desired feature first, similar to Test-driven Development (TDD). However, instead of implementing the feature as in TDD, CodeGenieautomatically searches for it based on information available in thetests. To check the suitability of the candidate results in thelocal context, each result is automatically woven into thedeveloper's project and tested using the original tests. Thedeveloper can then reuse the most suitable result. Later, reusedcode can also be unwoven from the project as wished. For the codesearching and wrapping facilities, CodeGenie relies on Sourcerer, anInternet-scale source code infrastructure that we have developed", "num_citations": "100\n", "authors": ["2058"]}
{"title": "Control and data flow structural testing criteria for aspect-oriented programs\n", "abstract": " Although it is claimed that, among other features, aspect-oriented programming (AOP) increases understandability and eases the maintenance burden, this technology cannot provide correctness by itself, and thus it also requires the use of systematic verification, validation and testing (VV&T) approaches. With the purpose of producing high quality software, many approaches to apply structural testing criteria for the unit testing of procedural and object-oriented (OO) programs have been proposed. Nevertheless, until now, few works have addressed the application of such criteria to test aspect-oriented programs. In this paper we define a family of control flow and data flow based testing criteria for aspect-oriented programs inspired by the implementation strategy adopted by AspectJ\u2013an aspect-oriented extension of the Java language\u2013and extending a previous work proposed for Java programs. We propose the\u00a0\u2026", "num_citations": "90\n", "authors": ["2058"]}
{"title": "Codegenie: a tool for test-driven source code search\n", "abstract": " We present CodeGenie, a tool that implements a test-driven approach to search and reuse of code available on largescale code repositories. With CodeGenie, developers designtest cases for a desired feature first, similar to Test-driven Development (TDD). However, instead of implementing the feature from scratch, CodeGenie automatically searches foran existing implementation based on information available in the tests. To check the suitability of the candidate results in the local context, each result is automatically woven into the developer's project and tested using the original tests. The developer can then reuse the most suitable result. Later, reused code can also be unwoven from the project as wished. For the code searching and wrapping facilities, CodeGenie relies on Sourcerer, an Internet-scale source code infrastructure that we have developed.", "num_citations": "67\n", "authors": ["2058"]}
{"title": "Applying test-driven code search to the reuse of auxiliary functionality\n", "abstract": " Software developers spend considerable effort implementing auxiliary functionality used by the main features of a system (eg. compressing/decompressing files, encryption/decription of data, scaling/rotating images). With the increasing amount of open source code available on the Internet, time and effort can be saved by reusing these utilities through informal practices of code search and reuse. However, when this type of reuse is performed in an ad hoc manner, it can be tedious and error-prone: code results have to be manually inspected and extracted into the workspace. In this paper we introduce the use of test cases as an interface for automating code search and reuse and evaluate its applicability and performance in the reuse of auxiliary functionality. We call our approach Test-Driven Code Search (TDCS). Test cases serve two purposes:(1) they define the behavior of the desired functionality to be searched\u00a0\u2026", "num_citations": "55\n", "authors": ["2058"]}
{"title": "A test-driven approach to code search and its application to the reuse of auxiliary functionality\n", "abstract": " ContextSoftware developers spend considerable effort implementing auxiliary functionality used by the main features of a system (e.g., compressing/decompressing files, encryption/decription of data, scaling/rotating images). With the increasing amount of open source code available on the Internet, time and effort can be saved by reusing these utilities through informal practices of code search and reuse. However, when this type of reuse is performed in an ad hoc manner, it can be tedious and error-prone: code results have to be manually inspected and integrated into the workspace.ObjectiveIn this paper we introduce and evaluate the use of test cases as an interface for automating code search and reuse. We call our approach Test-Driven Code Search (TDCS). Test cases serve two purposes: (1) they define the behavior of the desired functionality to be searched; and (2) they test the matching results for suitability\u00a0\u2026", "num_citations": "54\n", "authors": ["2058"]}
{"title": "Thesaurus-based automatic query expansion for interface-driven code search\n", "abstract": " Software engineers often resort to code search practices to support software maintenance and evolution tasks, in particular code reuse. An issue that affects code search is the vocabulary mismatch problem: while searching for a particular function, users have to guess the exact words that were chosen by original developers to name code entities. In this paper we present an automatic query expansion (AQE) approach that uses word relations to increase the chances of finding relevant code. The approach is applied on top of Test-Driven Code Search (TDCS), a promising code retrieval technique that uses test cases as inputs to formulate the search query, but can also be used with other techniques that handle interface definitions to produce queries (interface-driven code search). Since these techniques rely on keywords and types, the vocabulary mismatch problem is also relevant. AQE is carried out by leveraging\u00a0\u2026", "num_citations": "52\n", "authors": ["2058"]}
{"title": "Integration testing of object-oriented and aspect-oriented programs: A structural pairwise approach for java\n", "abstract": " Several testing approaches focus on finding faults in software units of implementation. A problem not addressed by unit testing is the interaction among units, with respect to the correctness of their interfaces. In this paper a structural integration testing approach for Object-Oriented (OO) and Aspect-Oriented (AO) Java programs is presented. To make the activity more feasible, we address the testing of pairs of units (ie, methods and pieces of advice). A model called P W D U (PairWise Def-Use) graph to represent the flow of control and data between pairs of units is proposed. Based on the P W D U, the following family of testing criteria is defined: all-pairwise-integrated-nodes (control-flow based), all-pairwise-integrated-edges (control-flow based), and all-pairwise-integrated-uses (data-flow based). To evaluate the proposed approach, an implementation of the criteria in a testing tool is presented along with an\u00a0\u2026", "num_citations": "48\n", "authors": ["2058"]}
{"title": "A pointcut-based coverage analysis approach for aspect-oriented programs\n", "abstract": " Aspect-oriented programming (AOP) is a promising technology that supports separation of crosscutting concerns (ie, functionality that tends to be tangled with, and scattered through the rest of the system). In AOP, a method-like construct named advice is applied to join points in the system through a special construct named pointcut. This mechanism supports the modularization of crosscutting behavior; however, since the added interactions are not explicit in the source code, it is hard to ensure their correctness. To tackle this problem, this paper presents a rigorous coverage analysis approach to ensure exercising the logic of each advice\u2013statements, branches, and def-use pairs\u2013at each affected join point. To make this analysis possible, a structural model based on Java bytecode\u2013called PointCut-based Def-Use Graph (PCDU)\u2013is proposed, along with three integration testing criteria. Theoretical, empirical, and\u00a0\u2026", "num_citations": "28\n", "authors": ["2058"]}
{"title": "Can the use of types and query expansion help improve large-scale code search?\n", "abstract": " With the open source code movement, code search with the intent of reuse has become increasingly popular. So much so that researchers have been calling it the new facet of software reuse. Although code search differs from general-purpose document search in essential ways, most tools still rely mainly on keywords matched against source code text. Recently, researchers have proposed more sophisticated ways to perform code search, such as including interface definitions in the queries (e.g., return and parameter types of the desired function, along with keywords; called here Interface-Driven Code Search - IDCS). However, to the best of our knowledge, there are few empirical studies that compare traditional keyword-based code search (KBCS) with more advanced approaches such as IDCS. In this paper we describe an experiment that compares the effectiveness of KBCS with IDCS in the task of large-scale\u00a0\u2026", "num_citations": "25\n", "authors": ["2058"]}
{"title": "Minimizing stub creation during integration test of aspect-oriented programs\n", "abstract": " A problem related to the integration test of Object-Oriented programs is the order in which classes are integrated and tested. This problems also appears in Aspect-Oriented programs. The incremental integration strategy, which suggests that classes are tested first and then integrated to the aspects, is often proposed as the more adequate strategy to integrate classes and aspects. This work presents a study about ordering classes and aspects in Aspect-Oriented programming to minimize the number of stubs in integration test. A dependency type model among classes and aspects is defined considering the syntax constructions and the semantics of AspectJ. An algorithm for class ordering is adapted and applied to an AOP program and the result obtained is analyzed and discussed, showing that a more refined strategy than the plain incremental approach is better in several situations.", "num_citations": "18\n", "authors": ["2058"]}
{"title": "Pairwise structural testing of object and aspect-oriented java programs\n", "abstract": " Most structural testing approaches are targeted at units of implementation (ie, unit testing). A problem that is not addressed by unit testing is the interaction among units, with respect to the correctness of their interfaces. We present a structural integration testing approach for object-oriented (OO) and aspect-oriented (AO) Java programs as an extension of a unit testing approach we have developed before. To make the activity feasible, instead of considering arbitrary call depths, we address the testing of pairs of units. We propose a model called PWDU (PairWise Def-Use) graph to represent the control and data-flow of pairs of units. Based on the PWDU, three testing criteria are defined: all-pairwise-integrated-nodes, all-pairwise-integrated-edges (controlflow based criteria), and all-pairwise-integrated-uses (a data-flow based criterion). We also present the implementation of our approach as an extension to the Java Bytecode Understanding and Testing (JaBUTi) family of testing tools along with an example of usage.", "num_citations": "17\n", "authors": ["2058"]}
{"title": "Teste de programas orientados a aspectos: uma abordagem estrutural para AspectJ\n", "abstract": " EM meados dos anos 90, alguns pesquisadores constataram a exist\u00ean-cia de certos interesses que, independente da t\u00e9cnica de programa\u00e7\u00e3o utilizada ou da maneira como o sistema venha a ser decomposto, n\u00e3o se encaixam em m\u00f3dulos individuais, mas ficam espalhados por v\u00e1rias unidades do software (tamb\u00e9m chamados de interesses transversais). A programa\u00e7\u00e3o orientada a aspectos (POA) foi concebida como uma proposta de resolu\u00e7\u00e3o desse problema, a partir do uso de mecanismos que permitem o isolamento dos interesses transversais. Entretanto, por ser uma t\u00e9cnica nova, nesses primeiros anos os pesquisadores preocuparam-se em estabelecer os conceitos e t\u00e9cnicas b\u00e1sicos das linguagens orientadas a aspectos, deixando para uma segunda fase a investiga\u00e7\u00e3o de outras caracter\u00edsticas do desenvolvimento de programas orientados a aspectos, como m\u00e9todos de projeto e abordagens de teste\u00a0\u2026", "num_citations": "17\n", "authors": ["2058"]}
{"title": "Teste de unidade de programas orientados a aspectos\n", "abstract": " Neste artigo \u00e9 apresentada uma abordagem de teste estrutural de unidade para programas orientados a aspectos. Um modelo de fluxo de controle orientado a aspectos \u00e9 definido a partir do bytecode (c\u00f3digo objeto de Java) resultante do processo de compila\u00e7 ao/combina\u00e7 ao de programas escritos na linguagem AspectJ\u2013uma extensao da linguagem Java para a programa\u00e7ao orientada a aspectos\u2013e crit\u00e9rios de teste sao derivados desse modelo. Al\u00e9m dos dois crit\u00e9rios de teste estruturais tradicionais todos-n\u00f3s e todas-arestas, dois outros crit\u00e9rios de teste espec\u0131ficos para programas orientados a aspectos, todosn\u00f3s-de-intercepta\u00e7ao e todas-arestas-de-intercepta\u00e7ao, sao definidos. Um exemplo de aplica\u00e7ao dos crit\u00e9rios \u00e9 apresentado.", "num_citations": "16\n", "authors": ["2058"]}
{"title": "Data flow integration testing criteria for aspect-oriented programs\n", "abstract": " Aspect-Oriented Programming (AOP) is a new technique proposed for improving separation of concerns in software development. Although it is claimed that AOP increases understandability and eases the maintenance burden, the technology cannot provide correctness by itself, and thus it also requires systematic verification, validation and testing (VV&T) approaches to improve software quality. One of the problems that can arise while using the AOP technology are the emergent data dependencies created by the integration of the primary abstractions\u2013that implement the core functions\u2013and aspects. Thus, an approach to exercise data flow interactions among primary abstractions and aspect enhancements is interesting for detecting faults related to these dependencies. For that purpose, a model for representing control and data flow of the integrated modules\u2013along with four data flow testing criteria\u2013is proposed based on the woven artifacts generated for programs implemented with AspectJ 1.2, an aspect-oriented extension of Java.", "num_citations": "14\n", "authors": ["2058"]}
{"title": "Integration testing of aspect-oriented programs: a structural pointcut-based approach\n", "abstract": " Several testing approaches focus on finding faults in software units of implementation (ie, unit testing). A problem not addressed by unit testing is the interaction among units, with respect to the correctness of their interfaces. With the use of Aspect-Oriented Programming this problem is further complicated by pointcut mechanisms that cut new interfaces in the base program. In this paper a structural integration testing approach for AspectJ programs is presented. A model called PCCFG (Pointcut-based Control Flow Graph) to represent the flow of control between base units and pieces of advice is defined. Based on the PCCFG, two control-flow criteria for a crosscutting coverage measure are defined: all-pointcut-based-advice-nodes and all-pointcut-basedadvice-edges. As a preliminary evaluation of the feasibility and effectiveness of the proposed approach, an implementation of the criteria in an AspectJ testing tool (JaBUTi/PC-AJ) is presented along with an application example. The example shows evidence of the effectiveness of the pointcut-based criteria to find AO related faults compared to unit testing criteria.", "num_citations": "12\n", "authors": ["2058"]}
{"title": "An exploratory study of functional redundancy in code repositories\n", "abstract": " In large code repositories, the probability of functions to repeat across projects is high. This type of functional redundancy (FR) is desirable for recent code reuse and repair approaches. Yet, FR is hard to measure because it is closely related to program equivalence, which is an undecidable problem. This is one of the reasons most studies that investigate redundancy focus on syntactic rather than semantic replication (e.g., cloning). In this paper we evaluate the extent of FR in a code repository with 68 Java projects taken randomly from SourceForge. Our technique approximates function similarity by first searching for methods that possess similar interfaces (return type, name, and parameter types). We then execute these methods to verify which candidate pairs have matching outputs for a given sample of inputs. Some recent studies have also focused on this type of semantic replication, but our detection approach is\u00a0\u2026", "num_citations": "9\n", "authors": ["2058"]}
{"title": "Teste estrutural de integracao nivel 1 de programas orientados a objetos ea aspec-tos\n", "abstract": " Este artigo apresenta uma abordagem para o teste estrutural de integra\u00e7\u00e3o n\u00edvel 1 para programas OO e OA escritos em Java e AspectJ. Por meio dessa abordagem \u00e9 poss\u00edvel revelar defeitos que podem ocorrer nas interfaces entre uma determinada unidade (m\u00e9todo ou adendo) e todas as outras que interagem diretamente com ela, bem como revelar defeitos que podem ocorrer na sequ\u00eancia de chamadas dessas unidades.Abstract\u2014This paper presents an approach for integration testing of object-oriented and aspect-oriented programs. The first level of integration is considered and the target languages are Java and AspectJ. The proposed model and criteria support revealing faults that occur at the interfaces between a specific unit of implementation (method or advice) and each unit that interacts with it. Moreover, the presented criteria can also help revealing faults related to call sequences at the target unit.", "num_citations": "7\n", "authors": ["2058"]}
{"title": "Using structural testing to identify unintended join points selected by pointcuts in Aspect-Oriented programs\n", "abstract": " The goal of aspect-oriented programming is to modularize concerns that tend to tangle with and scatter across multiple modules of software systems. For that purpose, crosscutting behavior implemented as advice is applied to several points of the base program (i.e., join points) using pointcut mechanisms. However, if pointcuts are wrongly defined, advice can be applied to unintended join points, injecting faults into the system. In this paper we propose the use of an integration structural testing approach to identify these unintended join points caused by faulty pointcuts. We present an AspectJ example that shows evidence of the effectiveness of our approach in this context.", "num_citations": "7\n", "authors": ["2058"]}
{"title": "An exploratory study of interface redundancy in code repositories\n", "abstract": " An important property of software repositories is their level of cross-project redundancy. For instance, much has been done to assess how much code cloning happens across software corpora. In this paper we study a much less targeted type of replication: Interface Redundancy (IR). IR refers to the level of repetition of whole method interfaces - return type, method name, and parameters types - across a code corpus. Such type of redundancy is important because if two non-trivial methods ever share the same interface it is very likely that they implement analogous functions, even though their code, structure, or vocabulary might be diverse. A certain level of IR is a requirement for approaches that rely on the recurrence of interfaces to fulfill a given task (e.g., interface-driven code search - IDCS). In this paper we report on an experiment to measure IR in a large-scale Java repository. Our target corpus contains more\u00a0\u2026", "num_citations": "4\n", "authors": ["2058"]}
{"title": "Using thesaurus-based tag clouds to improve test-driven code search\n", "abstract": " Test-driven code search (TDCS) is an approach to code search and reuse that uses test cases as inputs to form the search query. Together with the test cases that provide more semantics to the search task, keywords taken from class and method names are still required. Therefore, the effectiveness of the approach also relies on how good these keywords are, i.e., how frequently they are chosen by developers to name the desired functions. To help users choose adequate words in their query test cases, visual aids can be used. In this paper we propose thesaurus-based tag clouds to show developers terms that are more frequently used in the code repository to improve their search. Terms are generated by looking up words similar to the initial keywords on a thesaurus. Tag clouds are then formed based on the frequency in which these terms appear in the code base. Our approach was implemented with an English\u00a0\u2026", "num_citations": "4\n", "authors": ["2058"]}
{"title": "Static analysis of java bytecode for domain-specific software testing\n", "abstract": " Software testing is an important and expensive activity of the software development process. Techniques and tools are essential to improve test quality and productivity. Structural testing is a technique that uses characteristics such as control-flow and data-flow structures to derive testing requirements. By exercising such testing requirements the tester supposedly provides test cases that improve the software quality. Structural testing requires several activities that make use of code analysis, in general performed on the program source code. With the advent of Java it has become usual to perform such analysis directly on the bytecode instead of the source code, with a number of advantages. In this paper we discuss how to use the characteristics of Java bytecode analysis and how to extend it to implement structural criteria for two specific domains: aspect oriented programs and database applications.", "num_citations": "4\n", "authors": ["2058"]}
{"title": "Teste estrutural de integra\u00e7\u00e3o de programas orientados a aspectos: uma abordagem baseada em conjuntos de jun\u00e7\u00e3o para AspectJ\n", "abstract": " A Programa\u00e7\u00e3o Orientada a Aspectos (POA) \u00e9 uma t\u00e9cnica de desenvolvimento que apoia a separa\u00e7\u00e3o de interesses transversais. Na POA, adendos s\u00e3o aplicados a pontos de jun\u00e7\u00e3o do sistema por meio de uma constru\u00e7\u00e3o especial chamada descritor de conjuntos de jun\u00e7\u00e3o (ou simplesmente conjunto de jun\u00e7\u00e3o). Esse mecanismo apoia a modulariza\u00e7\u00e3o de comportamentos transversais, entretanto, como as intera\u00e7\u00f5es adicionadas n\u00e3o ficam expl\u00edcitas no c\u00f3digo-fonte, \u00e9 dif\u00edcil assegurar que est\u00e3o corretas. Para lidar com esse problema, nesta tese \u00e9 proposta uma abordagem rigorosa de teste estrutural de integra\u00e7\u00e3o para programas orientados a aspectos. \u00c9 definido um modelo de fluxo de controle e de dados baseado no bytecode Java chamado Grafo Def-Uso baseado em conjuntos de jun\u00e7\u00e3o (ou PointCut-based Def-Use graph, PCDU) que modela as regi\u00f5es de execu\u00e7\u00e3o de um programa escrito em AspectJ que s\u00e3o afetadas por um conjunto de jun\u00e7\u00e3o. Sobre este modelo s\u00e3o definidos tr\u00eas crit\u00e9rios de teste: todos-n\u00f3s-baseados-em-conjunto-de-jun\u00e7\u00e3o, todas-arestas-baseadas-em-conjunto-de-jun\u00e7\u00e3o e todos-usos-baseados-em-conjunto-de-jun\u00e7\u00e3o, que requerem a cobertura de todos os comandos, condicionais e pares def-uso no contexto de cada ponto de jun\u00e7\u00e3o selecionado. Para automatizar o uso do modelo e crit\u00e9rios propostos, \u00e9 implementada uma ferramenta chamada JaBUTi/PC-AJ. Al\u00e9m disso, para validar a abordagem proposta, s\u00e3o conduzidos estudos te\u00f3ricos e experimentais que procuram avaliar os crit\u00e9rios tanto do ponto de vista do custo de aplica\u00e7\u00e3o quanto do ponto de vista da efic\u00e1cia em encontrar defeitos. Os\u00a0\u2026", "num_citations": "2\n", "authors": ["2058"]}
{"title": "Comparing identifiers and comments in engineered and non-engineered code: a large-scale empirical study\n", "abstract": " Identifiers and comments are important sources of information to understand software. Approximately 70% of the code of a system consists of identifiers [1]. Identifier length and quality, as well as naming conventions overall, influence the difficulty and time required to complete maintenance tasks like code reading or debugging [2--4]. After the code itself, comments are the main source of documentation for software maintainers [5], and experiments show that commented code is easier to understand when compared to uncommented code [6]. Therefore these elements are of paramount importance for software development in general.", "num_citations": "1\n", "authors": ["2058"]}
{"title": "Thesaurus-Based Tag Clouds for Test-Driven Code Search.\n", "abstract": " Test-driven code search (TDCS) is an approach to code search and reuse that uses test cases as inputs to form the search query. Together with the test cases that provide more semantics to the search task, keywords taken from class and method names are still required. Therefore, the effectiveness of the approach also relies on how good these keywords are, ie, how frequently they are chosen by developers to name the desired functions. To help users choose adequate words in their query test cases, visual aids can be used. In this paper we propose thesaurus-based tag clouds to show developers terms that are more frequently used in the code repository to improve their search. Terms are generated by looking up words similar to the initial keywords on a thesaurus. Tag clouds are then formed based on the frequency in which these terms appear in the code base. Our approach was implemented with an English\u00a0\u2026", "num_citations": "1\n", "authors": ["2058"]}