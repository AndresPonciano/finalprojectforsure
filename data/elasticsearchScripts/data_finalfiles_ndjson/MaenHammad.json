{"title": "Recognition of on-line handwritten Arabic digits using structural features and transition network\n", "abstract": " In areas of automatic document analysis and recognition, the correct interpretation of digits is very important. Automatic recognition of on-line handwriting has a variety of applications at the interface between man and machine.", "num_citations": "26\n", "authors": ["2157"]}
{"title": "Severity prediction of software bugs\n", "abstract": " We target the problem of identifying the severity of a bug report. Our main aim is to develop an intelligent system that is capable of predicting the severity of a newly submitted bug report through a bug tracking system. For this purpose, we build a dataset consisting of 59 features characterizing 163 instances that belong to two classes: severe and non-severe. We combine the proposed feature set with strong classification algorithms to assist in predicting the severity of bugs. Moreover, the proposed algorithms are integrated within a boosting algorithm for an enhanced performance. Our results show that the proposed technique has proved successful with a classification performance accuracy of more than 76% with the AdaBoost algorithm and cross validation test. Moreover, boosting has been effective in enhancing the performance of its base classifiers with improvements of up to 4.9%.", "num_citations": "18\n", "authors": ["2157"]}
{"title": "An intelligent system for author attribution based on a hybrid feature set\n", "abstract": " Authorship analysis is a long explored area in the computational research. Recently, there has been growing interest in developing intelligent systems that are capable of authorship identification. Inspired by recent works, we address the problem of author attribution of Arabic text. This area, in specific, has not been targeted in the literature except for few studies. However, it is a challenging problem as there are linguistic complexities associated with the Arabic language including elongation and inflection challenges. For this purpose, we propose a novel hybrid feature set consisting of: lexical, syntactic, structural and content-specific features for 456 instances belonging to seven different Arabic authors. For validation, we run extensive experiments with different intelligent classifiers and show the strength of the proposed feature set. Our results show that the proposed feature set has proved successful with a\u00a0\u2026", "num_citations": "14\n", "authors": ["2157"]}
{"title": "Breast cancer classification: comparative performance analysis of image shape-based features and microarray gene expression data\n", "abstract": " Recently, there has been greater attention to the use of classifier systems in medical diagnosis. Medical diagnostic tools provide automated procedures for objective decisions by making use of quantitative measures and machine learning techniques. These tools are effective and helpful for medical experts to diagnose diseases. One of such diseases is breast cancer which is the second largest cause of cancer deaths among women. To build an intelligent tool, it is very important to have an effective set of features. Two types of feature sets have been commonly implemented for the purpose of breast cancer diagnosis: image shape-based features and microarray gene expression data. Both types of feature sets have been widely implemented; however, there has been no work that directly compared the classification performance of these two feature sets. In this paper, we intensively review related works that used both types of feature sets and we also review the implemented machine learning algorithms. Moreover, we run extensive experiments to compare the classification performance of the aforementioned feature sets. Our results show that the image shape-based features are more discriminative for breast cancer classification when tested with ten-fold cross validation. To check the robustness of the best performing feature set, we further examine it with five-fold cross validation and with a variety of generative classification algorithms.", "num_citations": "11\n", "authors": ["2157"]}
{"title": "A dynamic replication strategy based on categorization for data grid\n", "abstract": " Data Replication is copying the data from a certain location to another location. Replication is used in Data Grid to have two or more copies of the same data at different locations. In this paper, a Category-based dynamic replication strategy (CDRS) is proposed. The strategy takes into account that the replicas exist on a node belong to different categories. Each of these categories is given a value that determines its importance for the node. When the node's storage is full, the node starts to store only the replicas that belong to the category with the highest value. The results of the simulations show that the new proposed strategy achieved better performance than Plain Caching and Fast Spread strategies in terms of total transit time and total bandwidth consumption.", "num_citations": "10\n", "authors": ["2157"]}
{"title": "Automated classification of software bug reports\n", "abstract": " We target the problem of software bug reports classification. Our main aim is to build a classifier that is capable of classifying newly incoming bug reports into two predefined classes: corrective (defect fixing) report and perfective (major maintenance) report. This helps maintainers to quickly understand these bug reports and hence, allocate resources for each category. For this purpose, we propose a distinctive feature set that is based on the occurrences of certain keywords. The proposed feature set is then fed into a number of classification algorithms for building a classification model. The results of the proposed feature set achieved high accuracy in classification with SVM classification algorithm reporting an average accuracy of (93.1%) on three different open source projects.", "num_citations": "9\n", "authors": ["2157"]}
{"title": "An approach to automatically enforce object-oriented constraints\n", "abstract": " This paper presents an approach to automatically enforce object-oriented constraints during incremental C++ code changes. The approach is realised as a tool to keep track on code changes and to notify developers with violations of predefined OO constraints. The OO constraints under consideration are taken from object-oriented design metrics. The object-oriented metrics mainly cover class size, coupling between classes, number of subclasses and inheritance tree. The goal of this work is to help designers to monitor design during incremental code changes. Object-oriented design metrics are automatically extracted from source code. The extracted metrics are used by designers to define the constraints. The tool supports defining and managing these OO constraints. After a code change is committed, design changes are identified and predefined constraints are checked for possible violations. The evaluation of\u00a0\u2026", "num_citations": "9\n", "authors": ["2157"]}
{"title": "Identifying designers and their design knowledge\n", "abstract": " This paper presents an approach to identify designers who participated in shaping the design of software systems. Designers are identified as well as their design knowledge. Identified designers are recommended to handle a high level change request. High level requests require changing the design of software systems. The identified design knowledge of designers is used to find the appropriate designer to handle a change request. Designers are developers who made design changes to the software. Identifying designers and their design knowledge is based on mining software repositories to extract design changes from commits. Developers who committed any design change are considered designers. Type and amount of committed design changes are used to identify the knowledge of designers. A tool has been developed to automatically recommend a set of designers to handle a high level change request. Recommended designers are ranked based on their knowledge that is identified from cumulative design activities for designers. The tool also extracts useful information and statistics about designers and their activities. A case study of two open source projects is presented to show the benefits of the proposed approach and tool. Results showed that most committers are not designers. It also shows that designers can be ranked based on their design knowledge.", "num_citations": "8\n", "authors": ["2157"]}
{"title": "An Efficient Approach for Representing and Sending Data in Wireless Sensor Networks.\n", "abstract": " Wireless Sensor Networks (WSNs) became a major impact in terms of remote surveillance and data collection process. Limited power supply for a sensor node is one of the most significant challenges in WSNs. In WSNs, sensor nodes\u2019 energy plays a vital role in the network lifetime. The total number of bits to be sent over the WSN has a significant impact on the sensor nodes\u2019 power consumption. Therefore, reducing the size of the transmitted data is an important key to use the sensor node\u2019s energy efficiently. In this paper, a new approach is proposed to reduce the energy consumption in sensor nodes. The proposed approach is based on only transmitting the difference between the current sensed reading value and the previous reading value that is represented by the least number of bits instead of the new reading value itself. Since the differences between the consecutive sensed readings (eg temperatures) are expected to be small, the lengths of the differences are expected to have less size than the size of the sensed readings. The proposed approach is evaluated on real sensors data. Results show that the proposed approach reduces the energy consumption of sensor nodes and prolongs the sensor network lifetime.", "num_citations": "5\n", "authors": ["2157"]}
{"title": "Automatic clustering of bug reports\n", "abstract": " It is widely accepted that most development cost is spent for maintenance and most of the maintenance cost is spent on comprehension. Maintainers need to understand the current status of the code before updating it. For this reason, they examine pervious change requests and previous code changes to understand how the current code was evolved. The problem that faces them is how to locate related previous change requests that handled a specific feature or topic in the code. Quickly locating previous related change requests help developers to quickly understand the current status of the code and hence reduce the maintenance cost which is our ultimate goal. This paper proposes an automated technique to identify related previous change requests stored in bug reports. The technique is based on clustering bug reports based on their textual similarities. The result of the clustering is disjoint clusters of related bug reports that have common issues, topic or feature. A set of terms is extracted from each cluster, as tags, to help maintainers to understand the issue, topic or feature handled by the bug reports in the cluster. An experimental study is applied and discussed, followed by manual evaluation of the bug reports in the generated clusters.", "num_citations": "5\n", "authors": ["2157"]}
{"title": "Measuring Developers' Design Contributions in Evolved Software Projects.\n", "abstract": " The work presented in this paper measures the contribution of developers towards evolved structural design of software systems. Measuring the contribution of developers is useful for project managers who manage the development process. Project managers can empirically identify developers who made changes to the structural design and compare among them based on their contributions. The proposed measures help to understand the nature of developers\u2019 code changes activities. The process of calculating the measures is based on the historical code changes committed by developers. Specifically, code changes that affect the corresponding UML class diagram representation of the source code. Both type and amount of previous changes to class elements are used to measure the design contributions. The proposed measures are helpful for open source projects where no detailed information is available about various developers involved in the development process. A tool has been developed to automatically measure the contributions based on archived historical code changes. The measures have been applied on two open source projects. Results showed that only small number of developers have the major design contributions.", "num_citations": "5\n", "authors": ["2157"]}
{"title": "Developers\u2019 social networks\u2013tools analysis based on the 3Cs model\n", "abstract": " Social networks (SNs) have the potential to fundamentally change the nature of our social lives and interactions, both personally and at the community level. They affect the way people interact no matter who they are (students, instructors, lawyers, programmers, or distributed developers), and no matter where they are (co-located or geographically distributed). SNs can be either general purpose social networks (GSNs) that attract diverse audiences or specific purpose social networks (SSNs) dedicated to the interests of a group or a small community. This article focuses on a popular type of the specific purpose SNs which are the developers\u2019 social networks (DSNs). This article defines social networks and developers\u2019 social networks. Also, it outlines social networks\u2019 evolution, and gives examples of existing social media tools and social networks targeted at developers and software development communities. It\u00a0\u2026", "num_citations": "5\n", "authors": ["2157"]}
{"title": "Multiview Visualization of Software Testing Results\n", "abstract": " Software visualization can play a vital role in reducing testing efforts. It can be utilized to help testers in understanding the testing status of the code. This paper proposes a visualization technique to model the results of test cases that applied on object oriented code elements. The proposed visualization help testers to understand and to keep track on test cases and their tested code elements. Five views are proposed to cover different code levels; method, class, package, UML and system. A tool has been developed to automatically manage the software testing process and to generate the data model for the proposed visualizations. The evaluation results showed that the proposed views are useful and helpful in understanding the testing results.", "num_citations": "4\n", "authors": ["2157"]}
{"title": "Success Factors Importance Based on Software Project Organization Structure\n", "abstract": " The main aim of this paper is to identify critical success factors (CSFs) and investigate whether they are the same or not across different project organization structures. The organization structures under the study are: functional, project, and matrix. The study is based on a survey that was conducted on a large number of software projects in Jordan. To rank success factors (SFs) and identify critical ones, we use the importance index of SFs, which is calculated based on the likelihood and impact across different structures. For deeper analysis, we carry out statistical experiments with an ANOVA test and Spearman\u2019s rank correlation test. Analysis results of an ANOVA test partially indicates that the values of the SF importance index are slightly different across the three organization structures. Moreover, the Spearman\u2019s rank correlation test results show a high degree of correlation of the SF importance index between the function and project organization structures and a low degree of correlation between the function and matrix organization structures. View Full-Text", "num_citations": "4\n", "authors": ["2157"]}
{"title": "Stem-based query expansion for arabic corpus\n", "abstract": " This paper provides an improvement to Arabic Information Retrieval Systems. The proposed system relies on the stem-based query expansion method, which adds different morphological variations to each index term used in the query. This method is applied on Arabic corpus. Roots of the query terms are derived, then for each derived root from the query words, all words in the corpus descendant from the same root are collected and classified in a distinct class. Afterward, each class is reformulated by co-occurrence analysis (for each pair of terms) to guarantee a good relationship between terms. In addition, we used the whole word indexing technique to index the corpus.", "num_citations": "4\n", "authors": ["2157"]}
{"title": "Automatic Detection of Bad Smells from Code Changes\n", "abstract": " Code bad smells are indicators of code bad design that affects its quality attributes like understandability and readability. This effect has a direct impact on future maintenance tasks and code changing activities. Badly written code is hard to understand, change and test. The goal of this paper is to present an approach, supported by a tool, to automatically detect bad smells from code changes on the fly during code changing activities. An Eclipse plug-in tool (JFly) is developed to realize the approach. The tool analyzes code changes, detects bad smells and notifies developers about the location and the type of the detected bad smell. Nine bad smells are detected by JFly. A set of bad smells rules is defined, based on software metrics, to determine if code changes have one or more bad smells. JFly has been tested by different scenarios to evaluate its performance, usability and correctness. Results showed that JFly is very fast, easy to use and achieved high recall and precision values. By providing the JFly tool, developers are kept aware about code bad smells as soon as they implemented. As a result, the code is kept clean without the need to go over it periodically to check bad smells which consumes time and effort. Copyright\u00a9", "num_citations": "3\n", "authors": ["2157"]}
{"title": "Visualizing Testing Results for Software Projects\n", "abstract": " The key benefit of software visualization is to help in program understanding and in reducing the complexity of software systems. Test cases are essential artifacts to perform testing activities. There is large number of test cases to cover different aspects of the code. This paper proposes a visualization approach to represent test cases results and their relationship to object oriented software systems. The proposed visualization helps testers and program managers to get a clear and quick understanding about the test case, tested code and the results of testing. The proposed visualization represents test cases and source code at different views; method view, class view, package view and system view. The test cases are colored according to their execution results. We applied the proposed approach on two Java classes to illustrate the benefits and the usefulness of the proposed views.", "num_citations": "3\n", "authors": ["2157"]}
{"title": "An index-based approach for wireless sensor networks\n", "abstract": " Sensor nodes have significant power constraints (battery life). Thus, power-aware approaches must be employed to prolong the network lifetime. However, most of the literature considers only routing-based approaches to prolong it. In this paper, we propose an index-based approach that provides a new way for reducing the energy consumption. The idea behind this new proposed approach is having an index for each possible value for a sensed reading. The index length will have much less length than the reading if the possible values for the sensed reading are limited. In this case, sending the corresponding index for a reading instead of the reading itself will result in decreasing the size of the submitted packet and therefore reducing the consumed energy. The experimental results show that our approach reduces both the total energy consumption and total elapsed time in the case the number of the possible\u00a0\u2026", "num_citations": "3\n", "authors": ["2157"]}
{"title": "Automated labelling and severity prediction of software bug reports\n", "abstract": " Our main aim is to develop an intelligent classifier that is capable of predicting the severity and label (type) of a newly submitted bug report through a bug tracking system. For this purpose, we build two datasets that are based on 350 bug reports from the open-source community (Eclipse, Mozilla, and Gnome). These datasets are characterised with various textual features. Based on this information, we train variety of discriminative models that are used for automated labelling and severity prediction of a newly submitted bug report. A boosting algorithm is also implemented for an enhanced performance. The classification performance is measured using accuracy and a set of other measures. For automated labelling, the accuracy reaches around 91% with the AdaBoost algorithm and cross validation test. On the other hand, for severity prediction, the classification accuracy reaches around 67% with the AdaBoost\u00a0\u2026", "num_citations": "2\n", "authors": ["2157"]}
{"title": "Automatic reverse engineering of classes\u2019 relationships\n", "abstract": " Classes are the core of object oriented systems. Any maintenance activity includes performing a code change to one or more classes. Any code change to one class may affect other classes in the project. So, developers need to be aware and fully understand the structure and the relationships between classes. This paper proposes a technique to automatically extract various types of class\u2019s relationships from source code. The proposed technique extracts relationships among classes and measures their involvements in relationships. Fan-in and Fan-out metrics are used to give developers more comprehensive picture about the current status of coupling for each class.", "num_citations": "2\n", "authors": ["2157"]}
{"title": "Detecting Breaks in Design Patterns from Code Changes.\n", "abstract": " This paper presents an approach to automatically detect and identify breaks in design patterns from a code change during software evolution for C++ programs. The proposed approach aims to determine whether a code change breaks a predefined design pattern or not. The approach analyzes a code change and checks if the change breaks a predefined design pattern that is defined by software designers. Classes and their methods and relationships that are involved in a design pattern are represented in XML format named patternXML with the corresponding design pattern information. After each code change, patternXML file is parsed to determine possible breaks of patterns caused by the committed code change. All identified breaks are saved and archived for future analysis. A simple set of rules are defined to detect and identify breaks in predefined design patterns. The patternXML representation is flexible and can represent different types of design patterns. The approach is realized as a tool and it is evaluated on a set of test cases. Experimental results show that the tool can achieve high accuracy rate in discovering breaks in design patterns from code changes.", "num_citations": "2\n", "authors": ["2157"]}
{"title": "A visualization approach for bug reports in software systems\n", "abstract": " For widely-used and large software systems, there is huge number of daily submitted bug reports. These bug reports are mainly submitted by different developers with different roles during software development process. Therefore, understanding and monitoring the status of all submitted bug reports is not an easy task. Each bug report has various and different statuses over time. Furthermore, the relationship between bug reports and developers is complicated and hard to detect. In this paper, we propose a solution to help software project managers or bug trackers to understand the current and the previous statuses of large number of submitted bug reports. We propose a visualization approach to model the different statuses of bug reports and their relationships with developers who work on them. The visualization is based on extracting information from bug tracking systems and modeling them in comprehensive and meaningful views.", "num_citations": "2\n", "authors": ["2157"]}
{"title": "Visualizing Code Bad Smells\n", "abstract": " Software visualization is an effective way to support human comprehension to large software systems. In software maintenance, most of the time is spent on understanding code in order to change it. This paper presents a visualization approach to help maintainers to locate and understand code bad smells. Software maintainers need to locate and understand these bad smells in order to remove them via code refactoring. Object oriented code elements are visualized as well as their bad smells if they exist. The proposed visualization shows classes as building and bad smell as letter avatars based on the initials of the names of bad smells. These avatars are shown as warning signs on the buildings. A framework is proposed to automatically analyze code to identify bad smells and to generate the proposed visualizations. The evaluation of the proposed visualizations showed they reduce the comprehension time needed to understand bad smells.", "num_citations": "1\n", "authors": ["2157"]}
{"title": "Summarizing services of java packages\n", "abstract": " Program comprehension is essential for code maintenance and evolution activities. It saves time and efforts of developers who want to perform any code changes. It also minimizes the chances of introducing bugs. Textual summaries for source code provide great help to code understanding activities. This paper presents an approach to automatically generate textual summaries for services implemented in java packages. The summary is generated by analyzing the source code of methods defined the package. Each method represents a service provide by the package. Each service is summarized as a natural language textual description. The generated summary for a method mainly includes the used data and the names of invoked methods. Summaries of all methods defined in a package are refined and integrated to be reported as a comprehensive summary for the services provided by the package. The generated summaries are useful in different ways. They can be used by developers in their maintenance activities. They also can be useful for the documentation purposes.", "num_citations": "1\n", "authors": ["2157"]}
{"title": "Supporting code-design consistency during software evolution\n", "abstract": " The dissertation presents a set of approached and automated tools to identify, maintain, and preserve code-to-design traceability links during software evolution. Four main research issues are addressed. The first issue is the automatic identification of breaks in code-to-design traceability from a code change. The second issue is the understanding of how code-to-design traceability change during daily and incremental code changes. The third issue is the identification of critical classes in design based on their involvement in changes to design and lastly is to preserve code-to-design traceability during incremental code changes. The main contributions include a lightweight and efficient automated approach and tool to identify inconsistencies in code-to-design traceability given a code change. The tool and approach are described and evaluated. A detailed empirical study, on three years of four open source projects, was undertaken to understand how code-to-design traceability changes during evolution. The results of this empirical work are used as a basis for an approach to measure class importance based on its involvement in changes to design. Measuring importance for sets of classes that collaborate to realize a feature or concept is also done in the context of change. A visual aid to monitor and aid developers implementing the intended design along with an automated approach to update and maintain design documents during evolution are described.", "num_citations": "1\n", "authors": ["2157"]}