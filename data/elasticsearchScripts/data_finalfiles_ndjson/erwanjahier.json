{"title": "Lutin: A language for specifying and executing reactive scenarios\n", "abstract": " This paper presents the language Lutin and its operational semantics. This language specifically targets the domain of reactive systems, where an execution is a (virtually) infinite sequence of input/output reactions. More precisely, it is dedicated to the description and the execution of constrained random scenarios. Its first use is for test sequence specification and generation. It can also be useful for early simulation of huge systems, where Lutin programs can be used to describe and simulate modules that are not yet fully developed. Basic statements are input/output relations expressing constraints on a single reaction. Those constraints are then combined to describe non deterministic sequences of reactions. The language constructs are inspired by regular expressions and process algebra (sequence, choice, loop, concurrency). Moreover, the set of statements can be enriched with user-defined operators. A\u00a0\u2026", "num_citations": "44\n", "authors": ["1850"]}
{"title": "Case studies with Lurette V2\n", "abstract": " Lurette is an automated testing tool dedicated to reactive programs. The test process is automated at two levels: given a formal description of the System Under Test (SUT) environment, Lurette generates realistic input sequences; and, given a formal description of expected properties, Lurette performs the test results analysis. Lurette has been re-implemented from scratch. In this new version, the main novelty lies in the way the SUT environment is described. This is done by means of a new language called Lucky, dedicated to the programming of probabilistic reactive systems. This article recalls the principles of Lurette, briefly presents the Lucky language, and describes some case studies from the IST project Safeair II. The objective is to illustrate the usefulness of Lurette on real case studies, and the expressiveness of Lucky in accurately describing SUT environments. We show in particular how Lurette can\u00a0\u2026", "num_citations": "40\n", "authors": ["1850"]}
{"title": "Automatic state reaching for debugging reactive programs\n", "abstract": " Reactive systems are made of programs that permanently interact with their environment. Debuggers generally provide support for data and state inspection, given a sequence of inputs. But, because the reactive programs and their environments are interdependent, a very useful feature is to be able to go the other way around; namely, given a state, obtain a sequence of inputs that leads to that state. This problem is equivalent to the general verification of safety properties, which is notoriously undecidable in presence of numeric variables. However, a lot of progress has been done in recent years through the development of model checking and abstract-interpretation-based techniques.In this article, we take advantage of those recent advances to implement a fully automatic state reaching capability inside a debugger of reactive programs. To achieve that, we connect a debugger, a verification tool, and a testing tool. One of the key contributions of our proposal is the proper handling of numeric variables.", "num_citations": "26\n", "authors": ["1850"]}
{"title": "Environment-Model Based Testing of Control Systems: Case Studies\n", "abstract": " A reactive system reacts to an environment it tries to control. Lurette is a black-box testing tool for such closed-loop systems. It focuses on environment modeling using Lutin, a language designed to perform guided random exploration of the System Under Test (SUT) environment, taking into account the feedback. The test decision is automated using Lustre oracles resulting from the formalisation of functional requirements.               In this article, we report on experimentations conducted with Lurette on two industrial case studies. One deals with a dynamic system which simulates the behavior of the temperature and the pressure of a fluid in a pipe. The other one reports on how Lurette can be used to automate the processing of an existing test booklet of a Supervisory Control and Data Acquisition (SCADA) library module.", "num_citations": "19\n", "authors": ["1850"]}
{"title": "The lucky language reference manual\n", "abstract": " The main challenge to automate a testing or a simulation process is to be able to automate the generation of realistic input sequences to feed the program. In other words, we need an executable model of the program environment which inputs are the program outputs, and which outputs are the program inputs.In the first Lurette prototype\u2013an automated testing tool of reactive programs designed at Verimag\u2013, the System Under Test (SUT) environment behaviour was described by Lustre observers which were specifying what realistic SUT inputs should be. In other words, the environment was modelled by a set of (linear) constraints over Boolean and numeric variables. The work of Lurette was to solve those constraints, and to draw a value among the solutions to produce one SUT input vector.", "num_citations": "18\n", "authors": ["1850"]}
{"title": "Specifying and executing reactive scenarios with Lutin\n", "abstract": " This paper presents the language Lutin and its operational semantics. This language specifically targets the domain of reactive systems, where an execution is a (virtually) infinite sequence of input/output reactions. More precisely, it is dedicated to the description and the execution of constrained random scenarios. Its first use is for test sequence specification and generation. It can also be useful for early simulation of huge systems, where Lutin programs can be used to describe and simulate modules that are not yet fully developed.The programming style mixes relational and imperative features. Basic statements are input/output relations, expressing constraints on a single reaction. Those constraints are then combined to describe non deterministic sequences of reactions. The language constructs are inspired by regular expressions, and process algebra (sequence, choice, loop, concurrency). Moreover, the set of\u00a0\u2026", "num_citations": "15\n", "authors": ["1850"]}
{"title": "Describing and executing random reactive systems\n", "abstract": " We present an operational model for describing random reactive systems. Some models have already been proposed for this purpose, but they generally aim at performing global reasoning on systems, such as stochastic analysis, or formal proofs. Our goal is somehow less ambitious, since we are rather interested in executing such models, for testing or prototyping. But on the other hand, the proposed model is not restricted by decidability issues. Therefore it can be more expressive: in particular, our model is not restricted to finite-state descriptions. The proposed model is rather general: systems are described as implicit state/transition machines, possibly infinite, where probabilities are expressed by means of relative weights. The model itself is more an abstract machine than a programming language. The idea is then to propose high level, user-friendly languages that can be compiled into the model. We present\u00a0\u2026", "num_citations": "14\n", "authors": ["1850"]}
{"title": "On the importance of modeling the environment when analyzing sensor networks\n", "abstract": " A sensor network may be considered as a large and complex computer system embedded in the physical environment that has some influence on the sensors. The environment is the source of (almost) all activity that occurs in the network. With a simple example modeled in our tool GLONEMO, we show the influence of an environment model that allows to describe correlated stimuli on the set of sensors at a given instant, and also correlations between successive instants", "num_citations": "12\n", "authors": ["1850"]}
{"title": "Collecting graphical abstract views of Mercury program executions\n", "abstract": " A program execution monitor is a program that collects and abstracts information about program executions. The \"collect\" operator is a high level, general purpose primitive which lets users implement their own monitors. \"Collect\" is built on top of the Mercury trace. In previous work, we have demonstrated how this operator can be used to efficiently collect various kinds of statistics about Mercury program executions. In this article we further demonstrate the expressive power and effectiveness of \"collect\" by providing more monitor examples. In particular, we show how to implement monitors that generate graphical abstractions of program executions such as proof trees, control flow graphs and dynamic call graphs. We show how those abstractions can be easily modified and adapted, since those monitors only require several dozens of lines of code. Those abstractions are intended to serve as front-ends of software visualization tools. Although \"collect\" is currently implemented on top of the Mercury trace, none of its underlying concepts depend of Mercury and it can be implemented on top of any tracer for any programming language.", "num_citations": "10\n", "authors": ["1850"]}
{"title": "Generating random values using Binary decision diagrams and convex polyhedra\n", "abstract": " This article describes algorithms to solve Boolean and numerical constraints, and to randomly select values among the set of solutions. Those algorithms were first designed to generate inputs for testing and simulating reactive real-time programs. As a consequence, the chose a solving technology that allow a fine control in the way solutions are elected. Indeed, a fair selection is sometimes required, while favoring limit cases is often interesting for testing. Moreover, simulating a single reactive execution means generating several hundreds or even several thousands of atomic steps, and thus as many solving steps. Hence, the emphasis is put on efficiency, sometimes sacrificing precision or fairness.", "num_citations": "9\n", "authors": ["1850"]}
{"title": "The lurette v2 user guide\n", "abstract": " The functional testing of reactive systems raises specific problems. We adopt the usual point of view of synchronous programming, considering that the behavior of such a system is a sequence of atomic reactions\u2014which can be either time-triggered or event-triggered, or both\u2014. Each reaction consists in reading inputs, computing outputs, and updating the internal state of the system. As a consequence, a tester has to provide test sequences, ie, sequences of input vectors. Moreover, since a reactive system is generally designed to control its environment, the input vector at a given reaction may depend on the previous outputs. As a consequence, input sequences cannot be produced off-line, and their elaboration must be intertwined with the execution of the system under test (SUT). Finally, in order to decide whether a given test succeeds or fails, the sequence of pairs (input-vector, output-vector) can be provided to an observer [3] which acts as an oracle at each reaction. Let us illustrate this process with a very simple example: consider a device whose role is to regulate the water temperature of a tank, by opening or closing a gate that controls the arrival of hot water. A reaction consists in sampling the water temperature, comparing it to the target temperature, and sending an order to the gate. In a realistic input sequence, the temperature is assumed to increase at some rate when the gate in open, and to decrease when it is closed. Hence the input at a given reaction depends on the output sent at the previous reaction. The property to be checked could be that, if the target temperature did not change during a given delay, the temperature should\u00a0\u2026", "num_citations": "8\n", "authors": ["1850"]}
{"title": "sasa: A SimulAtor of Self-stabilizing Algorithms\n", "abstract": " In this paper, we present sasa, an open-source SimulAtor of Self-stabilizing Algorithms. Self-stabilization defines the ability of a distributed algorithm to recover after transient failures. sasa is implemented as a faithful representation of the atomic-state model. This model is the most commonly used in the self-stabilizing area to prove both the correct operation and complexity bounds of self-stabilizing algorithms. sasa encompasses all features necessary to debug, test, and analyze self-stabilizing algorithms. All these facilities are programmable to enable users to accommodate to their particular needs. For example, asynchrony is modeled by programmable stochastic daemons playing the role of input sequence generators. Algorithm\u2019s properties can be checked using formal test oracles. The design of sasa relies as much as possible on existing tools: ocaml, dot, and tools developed in the Synchrone Group of the\u00a0\u2026", "num_citations": "3\n", "authors": ["1850"]}
{"title": "RDBG: a reactive programs extensible debugger\n", "abstract": " Debugging reactive programs requires to provide a lot of inputs--at each reaction step. Moreover, because a reactive system reacts to an environment it tries to control, providing realistic inputs can be hard. The same considerations apply for automatic testing. This work take advantage on previous work on automated testing of reactive programs that close this feedback loop.", "num_citations": "2\n", "authors": ["1850"]}
{"title": "Environment-model based testing with differential evolution in an industrial setting\n", "abstract": " Reactive systems interact continuously with their environments. In order to test such systems, one needs to design executable environment models. Such models are intrinsically stochastic, because environment may vary a lot, and also because they are not perfectly known. We propose an environment-model based testing framework optimized for reactive systems, where Differential Evolution\u00a0(de ) is used to fine-tune the environment model and to optimize test input generation. In order to evaluate the proposed method, we present a case study involving a real-world scade system from the domain of railway automation. The problem specification was proposed by our industrial partner, Siemens. Our experimental data shows that de can be used efficiently to increase the structural coverage of the System Under Test.", "num_citations": "2\n", "authors": ["1850"]}