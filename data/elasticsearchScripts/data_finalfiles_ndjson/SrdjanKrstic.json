{"title": "Towards the formalization of properties of cloud-based elastic systems\n", "abstract": " Cloud-based elastic systems run on a cloud infrastructure and have the capability of dynamically adjusting the allocation of their resources in response to changes in the workload, in a way that balances the trade-off between the desired quality-of-service and the operational costs. The actual elastic behavior of these systems is determined by a combination of factors, including the input workload, the logic of the elastic controller determining the type of resource adjustment, and the underlying technological platform implementing the cloud infrastructure. All these factors have to be taken into account to express the desired elastic behavior of a system, as well as to verify whether the system manifests or not such a behavior.", "num_citations": "43\n", "authors": ["1668"]}
{"title": "Trace checking of metric temporal logic with aggregating modalities using MapReduce\n", "abstract": " Modern complex software systems produce a large amount of execution data, often stored in logs. These logs can be analyzed using trace checking techniques to check whether the system complies with its requirements specifications. Often these specifications express quantitative properties of the system, which include timing constraints as well as higher-level constraints on the occurrences of significant events, expressed using aggregate operators.               In this paper we present an algorithm that exploits the MapReduce programming model to check specifications expressed in a metric temporal logic with aggregating modalities, over large execution traces. The algorithm exploits the structure of the formula to parallelize the evaluation, with a significant gain in time. We report on the assesment of the implementation\u2014based on the Hadoop framework\u2014of the proposed algorithm and comment on its\u00a0\u2026", "num_citations": "26\n", "authors": ["1668"]}
{"title": "SMT-based checking of SOLOIST over sparse traces\n", "abstract": " SMT solvers have been recently applied to bounded model checking and satisfiability checking of metric temporal logic. In this paper we consider SOLOIST, an extension of metric temporal logic with aggregate temporal modalities; it has been defined based on a field study on the use of specification patterns in the context of the provisioning of service-based applications. We apply bounded satisfiability checking to perform trace checking of service execution traces against requirements expressed in SOLOIST. In particular, we focus on sparse traces, i.e., traces in which the number of time instants when events occur is very low with respect to the length of the trace.               The main contribution of this paper is an encoding of SOLOIST formulae into formulae of the theory of quantifier-free integer difference logic with uninterpreted function and predicate symbols. This encoding paves the way for efficient\u00a0\u2026", "num_citations": "20\n", "authors": ["1668"]}
{"title": "Efficient large-scale trace checking using MapReduce\n", "abstract": " The problem of checking a logged event trace against a temporal logic specification arises in many practical cases. Unfortunately, known algorithms for an expressive logic like MTL (Metric Temporal Logic) do not scale with respect to two crucial dimensions: the length of the trace and the size of the time interval of the formula to be checked. The former issue can be addressed by distributed and parallel trace checking algorithms that can take advantage of modern cloud computing and programming frameworks like MapReduce. Still, the latter issue remains open with current state-of-the-art approaches. In this paper we address this memory scalability issue by proposing a new semantics for MTL, called lazy semantics. This semantics can evaluate temporal formulae and boolean combinations of temporal-only formulae at any arbitrary time instant. We prove that lazy semantics is more expressive than point-based\u00a0\u2026", "num_citations": "18\n", "authors": ["1668"]}
{"title": "Offline trace checking of quantitative properties of service-based applications\n", "abstract": " Service-based applications are often developed as compositions of partner services. A service integrator needs precise methods to specify the quality attributes expected by each partner service, as well as effective techniques to verify these attributes. In previous work, we identified the most common specification patterns related to provisioning service-based applications and developed an expressive specification language (SOLOIST) that supports them. SOLOIST is an extension of metric temporal logic with aggregate temporal modalities that can be used to write quantitative temporal properties. In this paper we address the problem of performing offline checking of service execution traces against quantitative requirements specifications written in SOLOIST. We present a translation of SOLOIST into CLTLB (D), a variant of linear temporal logic, and reduce the trace checking of SOLOIST to bounded satisfiability\u00a0\u2026", "num_citations": "11\n", "authors": ["1668"]}
{"title": "Verification of quantitative properties of service based applications\n", "abstract": " Abstract in italiano Le applicazioni basate sui servizi rappresentano un nuovo tipo di software, che si basa sui principi delle architetture orientate ai servizi. Questo tipo di applicazioni pu\u00f2 realizzare composizioni di servizi pi\u00f9 complessi, componendo servizi indipendenti e di terze parti. Il fatto che queste applicazioni dipendano da terze parti e possano evolvere continuamente rende il processo di garanzia della qualit\u00e0 del software molto importante. Questo \u00e8 particolarmente vero per i requisiti non-funzionali, perch\u00e9 la qualit\u00e0 di servizio fornita da un servizio composito dipende dalla qualit\u00e0 dei servizi esterni coinvolti nella composizione. In termini di garanzia della qualit\u00e0 delle applicazioni basate su servizi, \u00e8 molto importante sia specificare in modo formale le interazioni tra applicazioni e anche eseguire la loro verifica in modo automatico. Questa tesi tratta della verifica di propriet\u00e0 quantitative di applicazioni basate su servizi; le propriet\u00e0 corrispondono a quelle esprimibili da una schema di specifiche sviluppato espressamente per il contesto delle applicazioni basate su servizi. Le specifiche sono scritte nel linguaggio di specifica SOLOIST e la verifica \u00e8 eseguita con il model checker Zot. La tesi descrive due modi di tradurre delle specifiche scritte in SOLOIST in una forma che pu\u00f2 essere analizzata da Zot. Parte integrante della tesi \u00e8 stato anche lo sviluppo di uno strumento che effettua la verifica di propriet\u00e0 scritte in SOLOIST rispetto a delle storie su tracce di esecuzione che corrispondono a interazioni di applicazioni basate su servizi. Nella tesi sono inclusi i valori della valutazione sperimentale che \u00e8 stata condotta per valutare l'efficienza\u00a0\u2026", "num_citations": "2\n", "authors": ["1668"]}
{"title": "On the Risk of Tool Over-tuning in Runtime Verification Competitions\n", "abstract": " In this position paper we discuss the risk of tool over-tuning in runtime verification competitions. We believe that the risk is inherently enabled by the format of the competitions and we discuss it in the context of the \u201cFirst International Competition on Software for Runtime Verification (CSRV 2014)\u201d, in which we participated.", "num_citations": "1\n", "authors": ["1668"]}
{"title": "Quantitative Properties of Software Systems: Specification, Verification, and Synthesis\n", "abstract": " Functional and non-functional requirements are becoming more and more complex, introducing ambiguities in the natural language specifications. A very broad class of such requirements are the ones that define quantitative properties of software systems. Properties of this kind are of key relevance to express quality of service. For example, they are used to specify bounds on the timing information between specific events, or on their number of occurrences. Sometimes, they are also used to express higher level properties such as aggregate values over the multiplicity of certain events in a specific time window. These are practical specification patterns that can be frequently found in system documentation. The goal of this thesis is to develop an approach for specifying and verifying quantitative properties of complex software systems that execute in a changing environment. In addition, it will also explore synthesis\u00a0\u2026", "num_citations": "1\n", "authors": ["1668"]}