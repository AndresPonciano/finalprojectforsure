{"title": "Optimistic recovery in distributed systems\n", "abstract": " Optimistic Recovery is a new technique supporting application-independent transparent recovery from processor failures in distributed systems. In optimistic recovery communication, computation and checkpointing proceed asynchronously. Synchronization is replaced by causal dependency tracking, which enables a posteriori reconstruction of a consistent distributed system state following a failure using process rollback and message replay. Because there is no synchronization among computation, communication, and checkpointing, optimistic recovery can tolerate the failure of an arbitrary number of processors and yields better throughput and response time than other general recovery techniques whenever failures are infrequent.", "num_citations": "1029\n", "authors": ["506"]}
{"title": "Matching events in a content-based subscription system\n", "abstract": " Content-based subscription systems are an emerging alternative to traditional publish-subscribe systems, because they permit more flexible subscriptions along multiple dimensions. In these systems, each subscription is a predicate which may test arbitrary attributes within an event. However, the matching problem for content-based systems-determining for each event the subset of all subscriptions whose predicates match the event-is still an open problem. We present an efficient, scalable solution to the matching problem. Our solution has an expected time complexity that is sub-linear in the number of subscriptions, and it has a spacecomplexity that is linear. Specifically, we prove that for predicates reducible to conjunctions of elementary tests, the expected time to match a random event is no greater than O (N\u2019-\u2018) where N is the number of subscriptions, and X is a closed-form expression that depends on the\u00a0\u2026", "num_citations": "926\n", "authors": ["506"]}
{"title": "Protocol specifications and component adaptors\n", "abstract": " In this article we examine the augmentation of application interfaces with enhanced specifications that include sequencing constraints called protocols. Protocols make explicit the relationship between messages (methods) supported by the application. These relationships are usually only given implicitly, either in the code or in textual comments. We define notions of interface compatibility based upon protocols and show how compatibility can be checked, discovering a class of errors that cannot be discovered via the type system alone. We then define software adaptors that can be used to bridge the difference between applications that have functionally compatible but type-and protocol-incompatible interfaces. We discuss what it means for an adaptor to be well formed. Leveraging the information provided by protocols, we show how adaptors can be automatically generated from a high-level description, called an\u00a0\u2026", "num_citations": "854\n", "authors": ["506"]}
{"title": "An efficient multicast protocol for content-based publish-subscribe systems\n", "abstract": " The publish/subscribe (or pub/sub) paradigm is an increasingly popular model for interconnecting applications in a distributed environment. Many existing pub/sub systems are based on pre-defined subjects, and hence are able to exploit multicast technologies to provide scalability and availability. An emerging alternative to subject-based systems, known as content-based systems, allow information consumers to request events based on the content of published events. This model is considerably more flexible than subject-based pub/sub. However, it was previously not known how to efficiently multicast published events to interested content-based subscribers within a large and geographically distributed network of broker (or router) machines. We develop and evaluate a novel and efficient distributed algorithm for this purpose, called -link matching\". Link matching performs just enough computation at each node to\u00a0\u2026", "num_citations": "789\n", "authors": ["506"]}
{"title": "Typestate: A programming language concept for enhancing software reliability\n", "abstract": " The authors introduce a new programming language concept, called typestate, which is a refinement of the concept of type. Whereas the type of a data object determines the set of operations over permitted on the object, typestate determines the subset of these operations which is permitted in a particular context. Typestate tracking is a program analysis technique which enhances program reliability by detecting at compile-time syntactically legal but semantically undefined execution sequences. These include reading a variable before it has been initialized and dereferencing a pointer after the dynamic object has been deallocated. The authors define typestate, give examples of its application, and show how typestate checking may be embedded into a compiler. They discuss the consequences of typestate checking for software reliability and software structure, and summarize their experience in using a high-level\u00a0\u2026", "num_citations": "688\n", "authors": ["506"]}
{"title": "Routing messages within a network using the data content of the message\n", "abstract": " A router within a network uses the data of a message received at the router to determine on which links out of the router the message needs to be forwarded. The router does not need any destination information from the message, and thus, the message need not include any destination information. Instead, the router uses an annotated search data structure to determine which links correspond to consumers interested in receiving the message. The message is sent only over those links.", "num_citations": "333\n", "authors": ["506"]}
{"title": "Exploiting IP multicast in content-based publish-subscribe systems\n", "abstract": " Publish-subscribe systems are evolving toward using content-based subscription rather than subject-based subscription. A key problem in implementing such systems is that a straightforward mapping from matching sets to multicast groups produces a number of groups that rapidly grows beyond practical limits. This paper proposes a set of alternative algorithms for solving this problem, by: (1) using a smaller set of overbroad multicast groups, judiciously chosen to minimize imprecision; (2) issuing multiple multicasts to appropriately chosen clusters; or (3) sending an event over multiple hops each involving a multicast to a set of neighbors. We evaluate these algorithms on a simulated wide-area network. We find that (1) a simple flooding algorithm is viable over an extensive range of conditions; and (2) under conditions of high selectivity and high regionalism of subscriptions, the other approaches mentioned\u00a0\u2026", "num_citations": "247\n", "authors": ["506"]}
{"title": "A case for message oriented middleware\n", "abstract": " With the emergence of the internet, independent applica- tions are starting to be integrated with each other. This has created a need for technology for glueing together applications both within and across organizations, without having to re-engineer individual compo- nents. We propose an approach for developing this glue technology based on message flows and discuss the open research problems in realizing this approach.", "num_citations": "245\n", "authors": ["506"]}
{"title": "Gryphon: An information flow based approach to message brokering\n", "abstract": " Gryphon is a distributed computing paradigm for message brokering, which is the transferring of information in the form of streams of events from information providers to information consumers. This extended abstract outlines the major problems in message brokering and Gryphon's approach to solving them.", "num_citations": "205\n", "authors": ["506"]}
{"title": "Exactly-once delivery in a content-based publish-subscribe system\n", "abstract": " This paper presents a general knowledge model for propagating information in a content-based publish-subscribe system. The model is used to derive an efficient and scalable Protocol for exactly-once delivery to large numbers (tens of thousands per broker) of content-based subscribers in either publisher order or uniform total order Our protocol allows intermediate content filtering at each hop, but requires persistent storage only at the publishing site. It is tolerant of message drops, message reorderings, node failures, and link failures, and maintains only \"soft\" state at intermediate nodes. We evaluate the performance of our implementation both under failure-free conditions and with fault injection.", "num_citations": "201\n", "authors": ["506"]}
{"title": "Volatile logging in n-fault-tolerant distributed systems\n", "abstract": " We in troduce two er hancernents to Optimistic Recovery which allow messages to be \u201clogged\u201d without performing any I/O to stable storage. The first permits messages to be instantaneously logged in volatile storage, as in the the Sender-Based Message Logging technique of Johnson and Zwaenepoel, but without their restriction of single-fault-tolerance. The second permits message data and/or message arrival orders not to be logged in circustances where this information can be reconstructed in other ways. We show that the combination of these two optimizations yields a transparent n-fault-tolerant system which logs to stable storage only those messages received from the outside world and a very small number of additional messages.", "num_citations": "201\n", "authors": ["506"]}
{"title": "Guava: A dialect of Java without data races\n", "abstract": " We introduce Guava, a dialect of Java whose rules statically guarantee that parallel threads access shared data only through synchronized methods. Our dialect distinguishes three categories of classes: (1) monitors, which may be referenced from multiple threads, but whose methods are accessed serially; (2) values, which cannot be referenced and therefore are never shared; and (3) objects, which can have multiple references but only from within one thread, and therefore do not need to be synchronized. Guava circumvents the problems associated with today's Java memory model, which must define behavior when concurrent threads access shared memory without synchronization.We present an overview of the syntax and the semantic rules of Guava. We discuss how implementations of Guava can exploit these rules to re-enable compiler optimizations inhibited by standard Java. We discuss how compilers for\u00a0\u2026", "num_citations": "155\n", "authors": ["506"]}
{"title": "Hermes: A language for distributed computing\n", "abstract": " Hermes is a language developed by the authors for distributed computing. The features that distinguish Hermes include typestate checking, exception handling clauses, runtime binding of all names, and dynamic definition of processes and message channels. This tutorial and reference manual for Hermes includes numerous well-developed programming examples to convey the meaning of the language to readers. The authors feel that the book is well suited to a broad spectrum of computer scientists, including teachers and system designers and developers. A clear strength backing this book is the existence of a Hermes compiler for several Sun and IBM systems, which can be acquired from the authors. The tutorial section of this book (the first 90 pages) gives a smooth introduction to the Hermes language through a combination of examples and discussion of the guiding principles used in its design. The authors\u00a0\u2026", "num_citations": "148\n", "authors": ["506"]}
{"title": "Interfaces, protocols, and the semi-automatic construction of software adaptors\n", "abstract": " In this paper we show how to augment object-oriented application interfaces with enhanced specifications that include sequencing constraints called protocols. Protocols make explicit the relationship between messages (methods) supported by the application. These relationships are usually only given implicitly, either in the code or in textual comments. We define notions of interface compatibility based upon protocols and show how compatibility can be checked, discovering a class of errors that cannot be discovered via the type system alone. We then define software adaptors that can be used to bridge the difference between object-oriented applications that have functionally compatible but type incompatible interfaces. We discuss what it means for an adaptor to be well-formed. Leveraging the information provided by protocols, we show how adaptors can be automatically generated from a high-level description\u00a0\u2026", "num_citations": "146\n", "authors": ["506"]}
{"title": "Optimistic recovery in a distributed processing system\n", "abstract": " In a distributed system whose state space is partitioned into recovery units, wherein recovery units communicate by the exchange of messages and wherein a message received by a recovery unit may causally depend on other recovery units having received prior messages, a method of recovering from failure of any number of recovery units in the system comprising the steps of:(a) tracking the dependency of each message received by a recovery unit in terms of the causative messages received by other recovery units in the system; and (b) restoring all recovery units to a consistent system-wide state after recovery unit failure by means of the tracked message dependencies.", "num_citations": "141\n", "authors": ["506"]}
{"title": "Placement strategies for internet-scale data stream systems\n", "abstract": " Optimally assigning streaming tasks to network machines is a key factor that influences a large data-stream-processing system's performance. Although researchers have prototyped and investigated various algorithms for task placement in data stream management systems, taxonomies and surveys of such algorithms are currently unavailable. To tackle this knowledge gap, the authors identify a set of core placement design characteristics and use them to compare eight placement algorithms. They also present a heuristic decision tree that can help designers judge how suitable a given placement solution might be to specific problems.", "num_citations": "122\n", "authors": ["506"]}
{"title": "System and method for providing collaborative replicated objects for synchronous distributed groupware applications\n", "abstract": " A system and method featuring a collection of model objects which hold data to be shared, and supporting interfaces to read and write the data, to create and destroy collaboration relationships and to attach \u201cview objects\u201d containing application code which will be automatically notified of value changes. Each user environment is provided with a model object control entity, referred to herein as a Collaboration Manager, which creates model objects, executes transactions, and creates association objects related to the collaboration. A concurrency control mechanism records the reads and updates of the data and of collaboration relationships within a single transaction site and guarantees that they are applied atomically and consistently to both the local and to all remote replica objects of the collaboration.", "num_citations": "117\n", "authors": ["506"]}
{"title": "Efficient atomic broadcast using deterministic merge\n", "abstract": " We present an approach for merging message streams from producers distributed over a network, using a deterministic algorithm that is independent of any nondeterminism of the system, such as the amount of time the messages are delayed by the network, or their arrival order. Thus, if this algorithm is replicated at multiple \u201cmergers\u201d, then each merger will merge the message streams in exactly the same way. The technique is therefore a solution to atomic broadcast and global atomic multicast [12]. We assume that each producer has access to (approximately) synchronized clocks and can estimate the expected message rates of all producers. We propose an algorithm, called the Bias Algorithm. To measure the performance of the Bias Algorithm, we assume that messages are generated by memoryless processes operating at known message rates, and we measure the expected total merge delay at a given time L\u00a0\u2026", "num_citations": "103\n", "authors": ["506"]}
{"title": "Information flow based event distribution middleware\n", "abstract": " Event distribution middleware supports the integration of distributed applications by accepting events from information producers and disseminating applicable events to interested consumers. We present a flexible new model, the Information Flow Graph (IFG), for specifying the flow of information in such a system. We illustrate the use of the IFG for: content-based publish/subscribe; stateless event transformations that consolidate events from diverse sources; and stateful event interpretation functions for deriving trends, summaries, and alarms from published events and for defining equivalent event sequences. We introduce two techniques for efficient implementation of such systems: a flow graph rewriting optimization which allows stateless IFGs to be converted to a form which can exploit efficient multicast technology developed for content-based publish/subscribe system; and an algorithm for converting a\u00a0\u2026", "num_citations": "95\n", "authors": ["506"]}
{"title": "Extending typestate checking using conditional liveness analysis\n", "abstract": " The authors present a practical extension to typestate checking, which is capable of proving programs free of uninitialized variable errors even when these programs contain conditionally initialized variables where the initialization of a variable depends upon the equality of one or more tag variables to a constant. The user need not predeclare the relationship between a conditionally initialized variable and its tags, and this relationship may change from one point in the program to another. The technique generalizes liveness analysis to conditional liveness analysis. Like typestate checking, this technique incorporates a dataflow analysis algorithm in which each point in a program is labeled with a lattice point describing statically tracked information, including the initialization of variables. The labeling is then used to check for programming errors such as referencing a variable which may be uninitialized.< >", "num_citations": "93\n", "authors": ["506"]}
{"title": "INC: A language for incremental computations\n", "abstract": " An incremental computation is one that is performed repeatedly on nearly identical inputs. Incremental computations occur naturally in many environments, such as compilers, language-based editors, spreadsheets, and formatters. This article describes a proposed tool for making it easy to write incremental programs. The tool consists of a programming language, INC, and a set of compile-time transformations for the primitive elements of INC. A programmer defines an algorithm in INC without regard to efficient incremental execution. The transformations automatically convert this algorithm into an efficient incremental algorithm. INC is a functional language. The implementation of an INC program is a network of processes. Each INC function is transformed into a process that receives and transmits messages describing changes to its inputs and outputs. We give an overview to the language and illustrate the\u00a0\u2026", "num_citations": "90\n", "authors": ["506"]}
{"title": "NIL: An integrated language and system for distributed programming\n", "abstract": " This paper presents features of the NIL programming language which support the construction of distributed software systems:(1) a process model in which no pointers or shared data are visible,(2) interprocess communication via synchronous and asynchronous message passing,(3) compile-time typestate checking, guaranteeing module isolation and correct finalization of data,(4) dynamic binding of statically typed ports under the control of capabilities.", "num_citations": "89\n", "authors": ["506"]}
{"title": "Concurrency control and view notification algorithms for collaborative replicated objects\n", "abstract": " This paper describes algorithms for implementing a high-level programming model for synchronous distributed groupware applications. In this model, several application data objects may be atomically updated, and these objects automatically maintain consistency with their replicas using an optimistic algorithm. Changes to these objects may be optimistically or pessimistically observed by view objects by taking consistent snapshots. The algorithms for both update propagation and view notification are based upon optimistic guess propagation principles adapted for fast commit by using primary copy replication techniques. The main contribution of the paper is the synthesis of these two algorithmic techniques-guess propagation and primary copy replication-for implementing a framework that is easy to program to and is well suited for the needs of groupware applications.", "num_citations": "88\n", "authors": ["506"]}
{"title": "Method for predicting performance of distributed stream processing systems\n", "abstract": " A method comprises estimating a performance of a processing system using queuing theory wherein the processing system comprises a network that accepts at least one input message stream from a plurality of publishing clients, transforms the at least one input message stream into at least one output message stream utilizing the plurality of transforms distributed in a first assignment among the plurality of brokers, and delivers the at least one output message stream to at least one of the plurality of subscribing clients, performing optimization upon the assignment of the plurality of transforms using the estimated performance to produce a second assignment, and reassigning the plurality of transforms in accordance with the second assignment.", "num_citations": "71\n", "authors": ["506"]}
{"title": "Quiescent reconfiguration of a routing network\n", "abstract": " Reconfiguration of a continuously available routing network of a publish/subscribe system is achieved by quiescing data messages and control messages within the routing network to preserve first-in first-out ordering thereof, and then, reconfiguring the quiesced routing network. This reconfiguration technique is particularly applicable to a routing network having at least one special node comprising one of a logger node or a sequencer node, wherein the logger node is used to store a message to persistent storage within the routing network prior to delivery of the message to one or more clients, and the sequencer sequences a message with other messages received by the network prior to delivery thereof for ordered delivery of the messages to one or more clients of the network.", "num_citations": "71\n", "authors": ["506"]}
{"title": "Method and system for matching consumers to events\n", "abstract": " A generalized search data structure is used to match consumers to events in event computing systems. The search data structure includes one or more paths from a root of the structure to one or more leaves of the structure. Each path has at least one level and each level corresponds to a filter attribute. The value of at least one filter attribute in at least one path is a don't care value indicating traversal of that path is guaranteed to proceed. In addition to following the path with the don't care value, one or more additional paths may also be followed. Thus, traversal of the search data structure may yield zero or more results, indicating that zero or more consumers match the specified event. Various optimizations of the search data structure are possible.", "num_citations": "65\n", "authors": ["506"]}
{"title": "Restoring consistent global states of distributed computations\n", "abstract": " We present a mechanism for restoring any consistent global state of a distributed computation. This capability can form the baais of support for rollback and replay of computations, an activity we view aa essential in a comprehensive environment for debugging distributed programs. Our mechanism records occasional state checkpoints and logs all messages communicated between processes.Our mechanism offers flexibility in the following ways: any consistent global state of the computation can be restored; execution can be replayed either exactly as it occurred initially or with user-controlled variations; there is no need to know a prioti what states might be of interest. In addition, if checkpoints and logs are written to stable storage, our mechanism can be used to restore states of computations that cause the system to crash.", "num_citations": "65\n", "authors": ["506"]}
{"title": "Method and apparatus for integrating relational and hierarchical data\n", "abstract": " Methods and apparatus for integrating relational and hierarchical data, schema definitions, and queries in a data processing system are provided. It is determined if one or more schema definitions or one or more query expressions are provided as input to the data processing system. The one or more schema definitions are converted into an intermediate schema language component of an intermediate data language when one or more schema definitions are provided. The one or more query expressions are converted into an intermediate query language component of the intermediate data language when one or more query expressions are provided. The intermediate schema language component or the intermediate query language component is compiled in an intermediate data language processing engine into a run-time representation in accordance with a relational-hierarchical analysis.", "num_citations": "63\n", "authors": ["506"]}
{"title": "Transparent recovery of Mach applications\n", "abstract": " We have built a software layer on top of Mach 2.5 that recovers multitask Mach applications from fail-stop failures. The layer implements Optimistic Recovery (OR), a mechanism for transparent recovery from failing tasks and processors, based on asynchronous checkpointing and logging of inter {task messages. OR recovers from failure by restoring a checkpoint and replaying the logged messages. The current prototype supports message communication via sends and receives, simple port operations, and task interactions through the environment manager.", "num_citations": "61\n", "authors": ["506"]}
{"title": "Method and system for matching consumers to events employing content-based multicast routing using approximate groups\n", "abstract": " A facility is provided for distributing events to consumers in a content-based publish-subscribe system, wherein the consumers each have at least one subscription. The facility includes deriving a set of g approximate multicast groups from a larger set of G possible multicast groups in the publish-subscribe system. The deriving includes exploiting knowledge of subscription predicates of the consumers of the publish-subscribe system. The set of G possible multicast groups is collapsed to the smaller set of g approximate multicast groups, while minimizing the expected performance penalty in using the approximate multicast groups. The set of g approximate multicast groups is then used to forward events to consumers within the publish-subscribe system.", "num_citations": "55\n", "authors": ["506"]}
{"title": "Relational subscription middleware for internet-scale publish-subscribe\n", "abstract": " We present a design of a distributed publish-subscribe system that extends the functionality of messaging middleware with\" relational subscriptions\", to support timely updates to state derived from published messages while preserving high throughput, scalability, and reliability. Critical to our design is our service guarantee of\" eventual correctness\". Eventual correctness is a weaker guarantee than the ACID properties of conventional databases, yet is useful enough to deliver state that is\" just consistent enough\". A key component of our design is a monotonic type system. All states delivered to clients represent facts that are permanently true, that may be refined by future updates, but will never become false. The monotonic type system is used both to formalize eventual correctness, and as a basis for our implementation, which generalizes the\" Guaranteed Delivery\" protocol previously implemented in the Gryphon\u00a0\u2026", "num_citations": "55\n", "authors": ["506"]}
{"title": "A comparison of the object-oriented and process paradigms\n", "abstract": " The object-oriented and process-oriented paradigms are very similar approaches to programming-in-the-large. Both have computational models based upon message passing; both provide a clear separation between external interfaces and internal algorithms with their local data. On the other hand, the two paradigms differ in many details. For example, the type systems of the two approaches differ in that in the process paradigm,(a) ports rather than processes carry the interface type information,(b) there is no inheritance mechanism, and (c) the code body implementing an abstract operation is associated with the value of a port and not with its type.This paper compares the two paradigms with particular emphasis on their usefulness for the development of large systems. First, the two paradigms are defined independently of particular instances of the paradigm. Then a number of programming issues important to\u00a0\u2026", "num_citations": "51\n", "authors": ["506"]}
{"title": "Exploitng event stream interpretation in publish-subscribe systems\n", "abstract": " Publish-subscribe messaging middleware typically offers limited and low-level options for quality of service, such as best-effort delivery versus reliable delivery, or ordered versus unordered. We propose a new, high-level approach to specifying quality of service, in which the consumer specifies an event stream interpretation function that maps an event stream into a state that represents the consumer's semantics of the stream. Under this approach, the system may deliver either the subscribed event stream, or any alternative stream whose image under the interpretation function yields the same state. Event stream interpretation gives consumers the ability to more accurately specify the tolerable distortions of perfect message delivery, and gives middleware implementations the flexibility to use more efficient protocols for message delivery and failure recovery while preserving application safety.", "num_citations": "49\n", "authors": ["506"]}
{"title": "The NIL distributed systems programming language: a status report\n", "abstract": " This paper is a summary of ongoing research activities related to the programming language NIL, a high level language for concurrent and distributed systems developed at IBM Yorktown.We first present a short summary of the major features of NIL. These include the NIL system model, which is a dynamically evolving network of loosely coupled processes, communicating by message passing; the abstract NIL computation model; and typestate, which is a refinement of type systems allowing a compiler to assume an important subset of program validation.We then discuss issues related to providing a semantic theory for NIL, and list some general requirements a semantic model should satisfy to be applicable to practical concurrent and distributed systems. We discuss the fit between CCS, which we are studying as a possible candidate for such a semantic theory, and these requirements.Finally we describe some\u00a0\u2026", "num_citations": "48\n", "authors": ["506"]}
{"title": "Mechanisms for compile-time enforcement of security\n", "abstract": " This paper discusses features of a secure systems programming language designed and implemented at IBM's Watson Research Lab. Two features of the language design were instrumental in permitting security to be enforced with minimum run-time cost:(1) Language constructs (eg pointer variables) which could result in aliasing were removed from the programmer's direct control and replaced by higher level primitive types; and (2) traditional strong type checking was enhanced with typestate checking, a new mechanism in which the compiler guarantees that for all execution paths, the sequence of operations on each variable obeys a finite state grammar associated with that variable's type. Examples are given to illustrate the application of these mechanisms.", "num_citations": "48\n", "authors": ["506"]}
{"title": "Message logging for reliable multicasting across a routing network\n", "abstract": " A technique for reliably multicasting a message within a router network is provided. At least one special router in the network has associated persistent storage for logging a message being routed to one or more clients. When a message is received at this logger node, the logger places the message in persistent storage and sends a logging acknowledgment back to those routers to which the message was originally routed, as well as back towards the source of the message. The logger acknowledgment includes the message id, the logger id, and a logging number. When the logger acknowledgment is received by a router, it looks up the routing information from the original message, and sends the acknowledgment to those neighboring routers to which the original message was sent, excluding the link from which the logger acknowledgment was received. If the original message corresponding to the logger\u00a0\u2026", "num_citations": "43\n", "authors": ["506"]}
{"title": "Transactional quality of service in event stream processing middleware\n", "abstract": " Computer implemented method, system and computer usable program code for achieving transactional quality of service in a transactional object store system. A transaction is received from a client and is executed, wherein the transaction comprises reading a read-only derived object, or reading or writing another object, and ends with a decision to request committing the transaction or a decision to request aborting the transaction. Responsive to a decision to request committing the transaction, wherein the transaction comprises writing a publishing object, events are delivered to event stream processing queries, and are executed in parallel with executing of the transaction. Responsive to a decision to request committing a transaction that comprises reading a read-only derived object, a validation is performed to determine whether the transaction can proceed to be committed, whether the transaction should abort\u00a0\u2026", "num_citations": "42\n", "authors": ["506"]}
{"title": "System and method for maintaining checkpoints of a keyed data structure using a sequential log\n", "abstract": " A system and method for maintaining checkpoints of a keyed data structure using a sequential log are provided. The system and method are built upon the idea of writing all updates to a keyed data structure in a physically sequential location. The system and method make use of a two-stage operation. In a first stage, various values of the same key are combined such that only the latest value in a given checkpoint interval is maintained for writing to persistent storage. In a second stage of the operation, a periodic write operation is performed to actually store the latest values for the key-value pairs to a persistent storage. All such updates to key-value pairs are written to the end of a sequential log. This minimizes the physical storage input/output (I/O) overhead for the write operations. Data structures are provided for identifying the most current entries in the sequential log for each key-value pair.", "num_citations": "41\n", "authors": ["506"]}
{"title": "Gapless delivery and durable subscriptions in a content-based publish/subscribe system\n", "abstract": " A content-based publish/subscribe system for providing gapless message delivery from a publishing client to a subscribing client, the system includes a plurality of brokers operatively coupled to one another via a network. Each of the brokers include at least one processor and are configured as a publisher-hosting broker, a subscriber-hosting broker or an intermediate broker. The subscriber-hosting broker is operatively coupled to the publisher-hosting broker via the network through the intermediate broker. At least a portion of the plurality of brokers are configured so as to eliminate a need for persistent storage of messages at the intermediate broker and to substantially guarantee a gapless delivery of one or more messages transmitted by the publishing client to the subscribing client, even in the presence of a failure in the publish/subscribe system.", "num_citations": "38\n", "authors": ["506"]}
{"title": "Utility-driven proactive management of availability in enterprise-scale information flows\n", "abstract": " Enterprises rely critically on the timely and sustained delivery of information. To support this need, we augment information flow middleware with new functionality that provides high levels of availability to distributed applications while at the same time maximizing the utility end users derive from such information. Specifically, the paper presents utility-driven \u2018proactive availability-management\u2019 techniques to offer (1)\u00a0information flows that dynamically self-determine their availability requirement based on high-level utility specifications, (2)\u00a0flows that can trade recovery time for performance based on the \u2018perceived\u2019 stability of and failure predictions (early alarm) for the underlying system, and (3)\u00a0methods, based on real-world case studies, to deal with both transient and non-transient failures. Utility-driven \u2018proactive availability-management\u2019 is integrated into information flow middleware and used with\u00a0\u2026", "num_citations": "38\n", "authors": ["506"]}
{"title": "Method and apparatus for linking data in a distributed data processing system\n", "abstract": " An apparatus for implementing \u201clinks\u201d between objects or content items in applications or documents in a distributed system such that changes to the source objects or items are reflected in changes to the target objects or content items. The apparatus includes mechanisms for allowing users to establish links, to break individual links, to copy documents or content including links, and to determine locations and/or descriptions of the source of a given target or any or all of the multiple targets of a given source.", "num_citations": "37\n", "authors": ["506"]}
{"title": "Distributed, fault-tolerant and highly available computing system\n", "abstract": " A method and system for achieving highly available, fault-tolerant execution of components in a distributed computing system, without requiring the writer of these components to explicitly write code (such as entity beans or database transactions) to make component state persistent. It is achieved by converting the intrinsically non-deterministic behavior of the distributed system to a deterministic behavior, thus enabling state recovery to be achieved by advantageously efficient checkpoint-replay techniques. The method comprises: adapting the execution environment for enabling message communication amongst and between the components; automatically associating a deterministic timestamp in conjunction with a message to be communicated from a sender component to a receiver component during program execution, the timestamp representative of estimated time of arrival of the message at a receiver\u00a0\u2026", "num_citations": "35\n", "authors": ["506"]}
{"title": "Method and system for mediating published message streams for selective distribution\n", "abstract": " A computer implemented method for delivering published messages to at least one subscriber in a publish-subscribe messaging system. The method for delivering published messages to a subscriber includes receiving a plurality of message streams and analyzing at least one message from each of the plurality of message streams in accordance with criteria established by the subscriber specifying a message content and a message content quality. At least one message that satisfies the criteria is delivered to the subscriber.", "num_citations": "34\n", "authors": ["506"]}
{"title": "Optimistic parallelization of communicating sequential processes\n", "abstract": " We present a transparent program transformation which converts a sequential execution of S1; SZ by a procesl; in a multiprocess environment into an optimistic parallel execution of SI and S2.Such a transformation is valuable in the case where S1 and SZcannot be para. llelized by static analysis either because S2 reads a value from S1 or because S1 and S2 each interact with an external process. The optimistic transformation works under a weaker set of conditions:(1) if the value Sz reads from S1 can usually, but not always, be correctly guessed ahead of time, and (2) if S1 and S2 interact with an external process, conflicts which violate the ordering of S1 and% are possible but rare. Practical applications of this approach include executing the likely outcome of a test in pwdlel with making the test, and converting sequences of calls into streams of asynchronous sends.", "num_citations": "34\n", "authors": ["506"]}
{"title": "Recovery in a distributed stateful publish-subscribe system\n", "abstract": " Method, apparatus and computer program product for fault recovery in a distributed stateful publish-subscribe system. The system includes the capability of recovering from failures that may occur when a stateful publish-subscribe service is implemented on an overlay network. Such failures may include, for example, temporary crashes of broker machines, and network errors causing messages to possibly be lost, duplicated or delivered out of order. The system requires stable storage logging only when a published event enters the system, and requires that logged messages be retrieved from stable storage only in the event all brokers between a failed link or broker and the publishing sites have failed. The publish-subscribe system of the present invention does not require that broker-to-broker connections use reliable FIFO protocols, such as TCP/IP, but may advantageously use faster, less reliable protocols.", "num_citations": "32\n", "authors": ["506"]}
{"title": "System and method for providing collaborative replicated objects for synchronous distributed groupware application\n", "abstract": " A system and method featuring a collection of model objects which hold data to be shared, and supporting interfaces to read and write the data, to create and destroy collaboration relationships and to attach \u201cview objects\u201d containing application code which will be automatically notified of value changes. Each user environment is provided with a model object control entity, referred to herein as a Collaboration Manager, which creates model objects, executes transactions, and creates association objects related to the collaboration. A concurrency control mechanism records the reads and updates of the data and of collaboration relationships within a single transaction site and guarantees that they are applied atomically and consistently to both the local and to all remote replica objects of the collaboration.", "num_citations": "32\n", "authors": ["506"]}
{"title": "High-level language support for programming distributed systems.\n", "abstract": " This paper presents a strategy to simplify the programming of heterogeneous distributed systems. Our approach is based on integrating a high-level distributed programming model, called the process model, directly into programming languages. Distributed applications written in such languages are portable across di erent environments, are shorter, and are simpler to develop than similar applications developed using conventional approaches. In this paper, we discuss the process model, and present overviews of Hermes and Concert/C, two languages that implement this model. Hermes is a secure, representation-independent language designed explicitly around the process model. Concert/C is the C language augmented with a small set of extensions to support the process model while allowing reuse of existing C code. Hermes has been prototyped; an implementation of Concert/C is in development.", "num_citations": "31\n", "authors": ["506"]}
{"title": "A new programming methodology for long-lived software systems\n", "abstract": " A new software development methodology based on the language NIL is presented. The methodology emphasizes (1) the separation of program development into functional specification and tuning phases, (2) the use of a fully compilable and executable design, (3) an interface definition and verification mechanism. This approach reduces life-cycle costs and improves software quality because (a) errors are detected earlier, and (b) a single functional design can be re-used to produce many implementations.", "num_citations": "29\n", "authors": ["506"]}
{"title": "Non-disruptive reconfiguration of a publish/subscribe system\n", "abstract": " A publish/subscribe system is non-disruptively reconfigured, such that messages are not lost during the reconfiguration. After reconfiguration is initiated, messages that are to be delivered within the publish/subscribe system are forwarded using either an old path or a new path. That is, until the reconfigured system is stabilized, some messages may be delivered using the old path, while other messages are delivered using a new path. After the system is stabilized, the new path is used for delivery of all the messages, until another reconfiguration is initiated.", "num_citations": "28\n", "authors": ["506"]}
{"title": "Continuous feedback-controlled deployment of message transforms in a distributed messaging system\n", "abstract": " The present invention solves the disadvantages of the prior art and provides a distributed messaging system supporting stateful subscriptions. A stateful publish-subscribe system extends the functionality of the content-based approach to include more general state-valued expressions. A plurality of broker machines is provided to deliver messages sent by publishing clients toward subscribing clients based upon the contents of the messages and stateful transformations requested by the subscribing clients. Subscription specifications are analyzed by a compiler and converted into a collection of message transforms and views. A deployment service component deploys tasks to optimize system performance. A monitoring services component detects a possible need to reconfigure. A performance optimization service component computes new assignment of transforms. A continuous deployment service implements a\u00a0\u2026", "num_citations": "28\n", "authors": ["506"]}
{"title": "Biologically-inspired distributed middleware management for stream processing systems\n", "abstract": " We present a decentralized and dynamic biologically-inspired algorithm for placing dataflow graphs composed of stream processing tasks onto a distributed network of machines, while minimizing the end-to-end latency. Our algorithm responds on-the-fly to placement requests of new flow graphs or to modifications of an already running stream processing flow graph, and dynamically adapts to changes in performance characteristics such as message rates or service times as well as to changes in processor availability or link performance during runtime. Our algorithm is derived by analogy to pheromone-based cooperation between ants to fulfill goals such as food discovery. We have conducted extensive simulation experiments to show the scalability and adaptability of our algorithm.", "num_citations": "27\n", "authors": ["506"]}
{"title": "A recoverable object store\n", "abstract": " In this paper we introduce optimizations which allow the checkpointing required by Optimistic Recovery to be performed as efficiently as maintaining undo records in database transaction systems. We believe that the application-independence, transparency, and time efficiency of Optimistic Recovery, coupled with such efficient checkpointing techniques, make self-recovering operating systems truly practical.", "num_citations": "26\n", "authors": ["506"]}
{"title": "Synthesizing distributed and parallel programs through optimistic transformations\n", "abstract": " We propose a programming methodology for distributed systems, based upon writing programs in a high-level, implementation-independent programming language in which distribution and physical parallelism are hidden, and where the programmer sees only a\" single systems image\". A distributed implementation of the program is then obtained by translating the program into a lower level language, in which distribution and parallelism, as well as other implementation-dependent and performancerelated details are exposed. The translation is further optimized by applying correctness-preserving program transformations. We introduce one particular family of such program transformations called optimistic transformations. Optimistic transformations allow a logically serial sequence of computations Cl; C2 to be executed in parallel whenever Cl's effect on C2 can be guessed in advance with high probability. If the guess is wrong, C2 will have to be undone, but if the probability of a correct guess is sufficiently high, the losses due to undoing computations will be compensated by performance gains due to increased parallelism. We give three examples of\" guesses\" which lead to optimistic transformations of practical value:(a) the guess that multiple iterations of a loop will not conflict,(b) the guess that exceptional program conditions will not occur, and (c) the guess that machine failures will not occur. We demonstrate our approach by applying transformations to a particular serial program-a database\" transaction-processing\" program. The original program has only local data (the data of the database), no communication, and is completely serial, while\u00a0\u2026", "num_citations": "26\n", "authors": ["506"]}
{"title": "NIL: A high-level language for distributed systems programming\n", "abstract": " Network Implementation Language (NIL) is a high-level programming language currently being used for the implementation of prototype communication systems. NIL is designed for writing executable architecture which can be compiled into efficient code for the different machines and run-time environments of a family of communicating products. NIL's distinctive features include (1) high-level primitive type families supporting constructs needed for concurrent systems, (2) facilities for decomposition of a system into modules which can be dynamically in-stalled and interconnected, (3) compile-time pestate checking\u2014a mechanism for enhancing language security without incurring large execution-time overhead.", "num_citations": "25\n", "authors": ["506"]}
{"title": "Optimizing migration policy during live virtual memory migration\n", "abstract": " Controlling live migration of a running application between a source machine and a target machine is provided. At least one application characteristic and at least one network characteristic are obtained. An objective function that defines a cost to migrate from the source machine to the target machine as a function such as a weighted combination of at least one cost property is obtained. The objective function is optimized using the at least one application characteristic and the at least one network characteristic to determine a policy specifying when to switch execution of the running application from the source machine to the target machine. Live migration of the application from the source machine is controlled to send pages from the source machine to the target machine in accordance with the policy, and to switch the execution of the application from the source machine to the target machine at a state specified by\u00a0\u2026", "num_citations": "24\n", "authors": ["506"]}
{"title": "Message sequencing for ordered multicasting of a message across a routing network\n", "abstract": " A technique for reliably multicasting a message within a router network in a sequenced order with other messages is provided. At least one special router in the network has associated persistent storage for sequencing a message being routed to one or more clients. When a message is received at this sequencer node, the sequencer places a sequence number for the message in persistent storage and sends a sequencing acknowledgment back to those routers to which the message was originally routed, as well as back towards the source of the message. The sequencer acknowledgment includes the message id, and the sequencing number. When the sequencer acknowledgment is received by a router, it looks up the routing information from the original message, and sends the acknowledgment to those neighboring routers to which the original message was sent, excluding the link from which the sequencer\u00a0\u2026", "num_citations": "19\n", "authors": ["506"]}
{"title": "An automatic messaging middleware with stateful stream transformation\n", "abstract": " We report on the design and prototype implementation of the SMILE system. SMILE (Smart Middleware Light Ends) extends the Gryphon publish-subscribe system with stateful subscriptions and computing capabilities, with the goal of raising the abstraction level of messaging middleware programming closer to that of database programming. It allows subscriptions to relational views (which can involve aggregation, joins, and other transforms) derived from published event streams. The SMILE system has dual autonomic properties: it can be used to augment other system with monitoring capabilities and make them more autonomic; and the system itself has sophisticated capabilities for self-optimization, deployment and automated fault-tolerance.", "num_citations": "19\n", "authors": ["506"]}
{"title": "System and method for time-aware run-time to guarantee time\n", "abstract": " A method and system for achieving time-awareness in the highly available, fault-tolerant execution of components in a distributed computing system, without requiring the writer of these components to explicitly write code (such as entity beans or database transactions) to make component state persistent. It is achieved by converting the intrinsically non-deterministic behavior of the distributed system to a deterministic behavior, thus enabling state recovery to be achieved by advantageously efficient checkpoint-replay techniques. The system is deterministic by repeating the execution of the receiving component by processing the messages in the same order as their associated timestamps and time-aware by allowing adjustment of message execution based on time.", "num_citations": "16\n", "authors": ["506"]}
{"title": "Placement of replicated tasks for distributed stream processing systems\n", "abstract": " We propose an algorithm for placing tasks of data flows for streaming systems onto servers within a message-oriented middleware where certain tasks can be replicated. Our work is centered on the idea that certain transformations are stateless and can therefore be replicated. Replication in this case can cause workloads to be partitioned among multiple machines, thus enabling message processing to be parallelized and lead to improvements in performance. We propose a guided replication approach for this purpose that iteratively computes the optimal placement of replicas where each subsequent iteration of the algorithm takes as input optimal solutions computed in the previous run. As a result, the system performance is consistently improved, which eventually converges as shown in simulation results. We demonstrate, through simulation experiments with both simple and complex task flow graphs and\u00a0\u2026", "num_citations": "16\n", "authors": ["506"]}
{"title": "Reflection in the gryphon message broking system\n", "abstract": " CiNii \u8ad6\u6587 - Reflection in the Gryphon Message Broking System CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853 \u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f \u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e \u518d\u958b\u306b\u3064\u3044\u3066 Reflection in the Gryphon Message Broking System STURMAN D. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 STURMAN D. \u53ce\u9332\u520a\u884c\u7269 Proc. Reflection Workshop at Object-Oriented Programming Languages and Applications Proc. Reflection Workshop at Object-Oriented Programming Languages and Applications, 1998 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u30db\u30fc\u30e0\u30e6\u30d3\u30ad\u30bf\u30b9 \u30b3\u30f3\u30d4\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u306e\u305f\u3081\u306e\u8131\u7740\u578b\u30b5\u30fc\u30d3\u30b9\u9593\u901a\u4fe1\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306e\u5b9f\u73fe \u4e2d\u6fa4 \u4ec1 , \u5fb3\u7530 \u82f1\u5e78 \u60c5\u5831\u51e6\u7406 \u5b66\u4f1a\u8ad6\u6587\u8a8c\u30b3\u30f3\u30d4\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u30b7\u30b9\u30c6\u30e0\uff08ACS\uff09 44(SIG10(ACS2)), 119-130, 2003-07-15 \u53c2\u8003\u2026", "num_citations": "16\n", "authors": ["506"]}
{"title": "Distributed messaging system supporting stateful\n", "abstract": " A distributed messaging system supporting stateful subscriptions is provided. A stateful publish-subscribe system extends the functionality of the content-based approach to include more general state-valued expressions. Stateful subscriptions may refer to one or more message histories and may include more complex expressions. Therefore, subscribers may receive different information than that provided in the published messages. A plurality of broker machines is provided to deliver messages sent by publishing clients toward subscribing clients based upon the contents of the messages and stateful transformations requested by the subscribing clients. Subscription specifications are analyzed by a compiler and converted into a collection of transform objects and view objects. The messaging system builds a structure containing all transform objects and view objects needed for all intermediate and subscribed\u00a0\u2026", "num_citations": "15\n", "authors": ["506"]}
{"title": "Towards Self-Recovering Operating Systems\n", "abstract": " Programming in the presence of failures is much more complex than programming to a fault-free interface because of the need to incorporate recovery code within each program. It is thus desirable to incorporate recovery transparently within an operating system, allowing the system to automatically recover a consistent state following a crash while presenting a fault-free interface to programs running on it. In such a self-recovering system, all storage appears to be persistent. The end user no longer needs to issue\" save\" s to make data recoverable in the cvent of a system crash. The application programmer need no longer be concerned with the difference between persistent storage and volatile storage.", "num_citations": "15\n", "authors": ["506"]}
{"title": "Method for predicting performance of distributed stream processing systems\n", "abstract": " A method comprises estimating a performance of a processing system using queueing theory wherein the processing system comprises a network that accepts at least one input message stream from a plurality of publishing clients, transforms the at least one input message stream into at least one output message stream utilizing the plurality of transforms distributed in a first assignment among the plurality of brokers, and delivers the at least one output message stream to at least one of the plurality of subscribing clients, performing optimization upon the assignment of the plurality of transforms using the estimated performance to produce a second assignment, and reassigning the plurality of transforms in accordance with the second assignment.", "num_citations": "13\n", "authors": ["506"]}
{"title": "Systems, methods and computer program products for improving placement performance of message transforms by exploiting aggressive replication\n", "abstract": " Systems, methods and computer program products for improving overall end-to-end runtime latency of flow graphs of message transformations which are placed onto an overlay network of broker machines by aggressively replicating stateless transformations. Exemplary embodiments include a method including defining a message transformation graph, receiving information about measured and estimated properties of a message flow, receiving information about physical brokers and links in the overlay network onto which the message transformation graph is deployed, labeling each of a plurality of stateless transformations associated with the flow graph as replicable, heuristically determining a number of replicas and a corresponding load partitioning ratios among the number of replicas for each stateless transformation, converting the message transformation graph into an enhanced flow graph, running a\u00a0\u2026", "num_citations": "13\n", "authors": ["506"]}
{"title": "Hermes: An integrated language and system for distributed programming\n", "abstract": " Abstract by necessity: they ran one user\u2019s program at a time. Although batch systems and timeshared systems introduced multiprogramming and a scheduler, they still provided the illusion of the standalone environment by executing environments serially or vide a simulated standalone environment in each winstandalone virtual machine. lkmes is an experimental language for implementing corn-plex systems and distributed applications. It conceals lowtribution, communications protocols, and operating system calls, while retaining expressiveness, checkability, and effiresearch community. level Pr \u201cgra\u201d ing details, such data representation, dis-interleaved. Similarly, most personal workstations prociency. Hermes is being distributed free of to the doW. services appear as to One\u2019\u2019Hermes supports multiple interacting applications and services within a single environment. Applications and services interact by making calls and passing typed parametersexactly the same way modules interact within an application. The syntax and semantics of interaction is uniform, whether the interacting components are local or remote, and whether they belong to the same user or to different users.", "num_citations": "13\n", "authors": ["506"]}
{"title": "Method for applying stochastic control optimization for messaging systems\n", "abstract": " A computer implemented method, apparatus, and computer usable program code for controlling when to send messages in a stream processing system. A policy is determined by utilizing probability statistics and a cost function prior to stream processing. The policy specifies under which conditions a message is sent eagerly and under which other conditions the message is delayed. A filter is operated during stream processing that selects which of the messages to send from a sending transform based upon a threshold. A controller is operated during stream processing that observes a current state of a receiving transform and that applies the policy based on the current state to determine whether to change the threshold.", "num_citations": "12\n", "authors": ["506"]}
{"title": "Method and apparatus for summarizing missing events using event stream interpretation\n", "abstract": " A technique for optimizing published event message sequences destined for information subscribers in an information processing system. Subscribers specify event interpretation rules which map event message streams into states. The event interpretation rules are maintained elsewhere in the system in preparation for providing optimized, possibly shorter, event message streams to subscribers, sufficient to correctly update the states. If a subscriber temporarily loses access to its event message stream, the optimized event message stream is determined using a shortest path graph search technique between the states defined by the start and end of the missing portion of the stream. Optimizations to the shortest path graph search technique are disclosed for use when the event interpretation rule is in replacement form, in which estimator functions based on extended rules are employed.", "num_citations": "11\n", "authors": ["506"]}
{"title": "Fault-tolerance in the SMILE stateful publish-subscribe system\n", "abstract": " We present the algorithms for achieving service guarantees in the SMILE distributed relational publish-subscribe system in the presence of lost or reordered messages due to broker and/or link failures. SMILE extends the content-based publish-subscribe paradigm by allowing subscribers to request continually updated derived views, specified as relational algebraic (SQL-like) expressions over published event histories. The SMILE system performs compile-time analysis of subscriptions, and generates tailored code for computing incremental state updates, and for detecting and recovering from lost or permuted messages. We exploit: (1) the languages monotonic type system; and (2) a refined service guarantee of eventual correctness. We first present an abstract protocol capturing the common features of all fault detection and recovery protocols implemented in the SMILE prototype. We then describe the\u00a0\u2026", "num_citations": "10\n", "authors": ["506"]}
{"title": "Distributed messaging system supporting stateful subscriptions\n", "abstract": " A distributed messaging system supporting stateful subscriptions is provided. A stateful publish-subscribe system extends the functionality of the content-based approach to include more general state-valued expressions. Stateful subscriptions may refer to one or more message histories and may include more complex expressions. Therefore, subscribers may receive different information than that provided in the published messages. A plurality of broker machines is provided to deliver messages sent by publishing clients toward subscribing clients based upon the contents of the messages and stateful transformations requested by the subscribing clients. Subscription specifications are analyzed by a compiler and converted into a collection of transform objects and view objects. The messaging system builds a structure containing all transform objects and view objects needed for all intermediate and subscribed\u00a0\u2026", "num_citations": "9\n", "authors": ["506"]}
{"title": "Dynamic and evolutionary placement in an event-driven component-oriented network data processing system\n", "abstract": " Method, system and computer readable program code for dynamic and evolutionary component placement in an event processing system having producers, consumers, a plurality of nodes between the producers and the consumers, and a flow graph representing operator components to be executed between the producers and the consumers. A description of a change to the system is received. At each node, next-hop neighbor nodes for each consumer are identified. A routing value is assigned to each next-hop neighbor node for each consumer and the routing values are updated according to an update rule that represents a chromosome in a routing probe. The update rule in a routing probe is selectively updated from a plurality of update rules at the consumer. The probability of selecting a particular update rule is reinforced or decayed based on the success of an update rule in allowing routing probes to create\u00a0\u2026", "num_citations": "9\n", "authors": ["506"]}
{"title": "Systems, methods and computer program products for improving placement performance of message transforms by exploiting aggressive replication\n", "abstract": " Systems, methods and computer program products for improving overall end-to-end runtime latency of flow graphs of message transformations which are placed onto an overlay network of broker machines by aggressively replicating stateless transformations. Exemplary embodiments include a system having a process including defining a message transformation graph, receiving information about measured and estimated properties of a message flow, receiving information about physical brokers and links in the overlay network onto which the message transformation graph is deployed, labeling each of a plurality of stateless transformations associated with the flow graph as replicable, heuristically determining a number of replicas and a corresponding load partitioning ratios among the number of replicas for each stateless transformation, converting the message transformation graph into an enhanced flow graph\u00a0\u2026", "num_citations": "9\n", "authors": ["506"]}
{"title": "Achieving scalability and throughput in a publish/subscribe system\n", "abstract": " We describe the Gryphon content-based publish/subscribe messaging system. The objective of Gryphon is to provide the capabilities of message oriented middleware systems in widely distributed and highvolume environments, ie distributed across countries or continents, with tens of thousands of messaging clients and with tens of thousands of messages being delivered across the system each second. We introduce the essential design concepts of Gryphon, with particular emphasis on the decisions that led to high throughput and scalability. We present performance benchmarks that demonstrate the effectiveness of these decisions.", "num_citations": "9\n", "authors": ["506"]}
{"title": "A checkable interface language for pointer-based structures\n", "abstract": " We present a technique for analysing structural constraints on data aggregates in high-level languages. Our technique includes a formal constraint language and a dataflow algorithm for automatically checking equality constraints. The constraint language is used to augment the type information on program interfaces. For example, one can specify that a procedure must return aggregates A and B where each element in aggregate A points to some element in aggregate B, and that parameter C will have the properties of a rooted tree both on input and output. Our dataflow algorithm tracks the constraints which must apply at each statement in order for the procedure to satisfy its interface, and detects invalid programs which fail to satisfy the constraints on their interfaces. We apply our technique to several examples. Our work is motivated by the requirements for expressive interface definition languages for distributed\u00a0\u2026", "num_citations": "8\n", "authors": ["506"]}
{"title": "Viewing Ada from a process model perspective\n", "abstract": " This paper compares two programming language paradigms for large software systems. The first is based upon nested block structure and static binding, augmented with abstract data types and concurrency, as exemplified by Ada. The second is based upon processes with disjoint data spaces which communicate by passing messages over dynamically bound ports as exemplified by the process model of NIL. We argue that the process model paradigm is simpler, has better support for modularity and programming-in-the-large, and results in more reliable and maintainable programs. We suggest usage restrictions and language extensions which allow Ada to support a process model with minimal change to the language. We show that our suggested modification of Ada yields a considerably simpler language.", "num_citations": "8\n", "authors": ["506"]}
{"title": "Method and apparatus for integrating relational and hierarchical data\n", "abstract": " Methods and apparatus for integrating relational and hierarchical data, schema definitions, and queries in a data processing system are provided. One or more schema definitions are converted into an intermediate schema language component of an intermediate data language when one or more schema definitions are provided. One or more query expressions are converted into an intermediate query language component of the intermediate data language when one or more query expressions are provided. The intermediate schema language component or the intermediate query language component is compiled in an intermediate data language processing engine into a run-time representation in accordance with a relational-hierarchical analysis.", "num_citations": "7\n", "authors": ["506"]}
{"title": "Stochastic control optimization for sender-based flow control in a distributed stateful messaging system\n", "abstract": " A method and system for controlling message flow in distributed stream processing. State transition probabilities in a Markov model having one state per staleness value of data are determined for sending or withholding updates of data to subscribers using expected message rates from an information provider. A cost function annotates each state transition in the model with a state transition cost for each decision to \u201csend\u201d or \u201cwithhold\u201d. A propagation policy specifying whether to send or withhold the message is determined for each state. The propagation policy is then deployed. If a new message comprising an update of data is received during a lapsed time unit, a staleness value of the data held by subscribers is increased. The propagation policy is used to determine whether to send or withhold the message. If the message should be sent, the message is propagated and the staleness value of the data is reset.", "num_citations": "7\n", "authors": ["506"]}
{"title": "Gapless delivery and durable subscriptions in a content-based publish/subscribe system\n", "abstract": " A content-based publish/subscribe system for providing gapless message delivery from a publishing client to a subscribing client is disclosed. The system includes a plurality of brokers operatively coupled to one another via a network. Each of the brokers include at least one processor and are configured as a publisher-hosting broker, a subscriber-hosting broker or an intermediate broker. The subscriber-hosting broker may be operatively coupled to the publisher-hosting broker via the network through the intermediate broker. At least a portion of the plurality of brokers are configured so as to eliminate a need for persistent storage of messages at the intermediate broker and to substantially guarantee a gapless delivery of one or more messages transmitted by the publishing client to the subscribing client, even in the presence of a failure in the publish/subscribe system.", "num_citations": "7\n", "authors": ["506"]}
{"title": "Gapless delivery and durable subscriptions in a content-based publish/subscribe system\n", "abstract": " A content-based publish/subscribe system for providing gapless message delivery from a publishing client to a subscribing client is disclosed. The system includes a plurality of brokers operatively coupled to one another via a network. Each of the brokers include at least one processor and are configured as a publisher-hosting broker, a subscriber-hosting broker or an intermediate broker. The subscriber-hosting broker may be operatively coupled to the publisher-hosting broker via the network through the intermediate broker. At least a portion of the plurality of brokers are configured so as to eliminate a need for persistent storage of messages at the intermediate broker and to substantially guarantee a gapless delivery of one or more messages transmitted by the publishing client to the subscribing client, even in the presence of a failure in the publish/subscribe system.", "num_citations": "7\n", "authors": ["506"]}
{"title": "SMILE: distributed middleware for event stream processing\n", "abstract": " In this paper, we describe the SMILE (Smart MIddleware, Light Ends) system which is one of the earliest systems built in the area of distributed event stream processing. SMILE unites the\" publish-subscribe\" model of messaging middleware with the\" continuous query\" model of database systems. In SMILE, information producers, which may be sensors, applications, or databases, generate streams of events, such as RFID data, news items or stock trades; consumers specify stateful subscriptions to derived views, such as\" individuals trading top 5 total volume of stock Y within x minutes before a major news story about the same company Y\"; the SMILE system constructs and deploys a dataflow network of computations which process events from producers, compute derived views and deliver continuous and timely updates of subscribed views to consumers. Research challenges addressed by SMILE include\u00a0\u2026", "num_citations": "7\n", "authors": ["506"]}
{"title": "Method and system for mediating published message streams for selective distribution\n", "abstract": " A computer implemented method, system and computer program product for delivering published messages to at least one subscriber in a publish-subscribe messaging system. A computer implemented method for delivering published messages to a subscriber includes receiving a plurality of message streams, and analyzing at least one message from each of the plurality of message streams in accordance with criteria established by the subscriber specifying a message content and a message content quality. At least one message that satisfies the criteria is delivered to the subscriber.", "num_citations": "6\n", "authors": ["506"]}
{"title": "Proc. of IFIP WG 6.1 4th Int'l Workshop on Protocol specification, testing, and verification, IV\n", "abstract": " Proc. of IFIP WG 6.1 4th Int'l Workshop on Protocol specification, testing, and verification, IV | Guide Proceedings ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsProc. of IFIP WG 6.1 4th Int'l Workshop on Protocol specification, testing, and verification, IV ABSTRACT No abstract available. Index Terms 1.Proc. of IFIP WG 6.1 4th Int'l Workshop on Protocol specification, testing, and verification, IV 1.Networks 1.Network protocols 1.Network protocol design 2.Protocol correctness 1.Protocol testing and verification 2.Social and professional topics 1.Professional topics 1.Management of computing and information systems 1.\u2026", "num_citations": "6\n", "authors": ["506"]}
{"title": "Dynamic component placement in an event-driven component-oriented network data processing system\n", "abstract": " Method, system and computer usable program code for dynamic component placement in an event processing system having producers, consumers, a plurality of nodes between the producers and the consumers, and a flow graph representing computational components to be executed between the producers and the consumers. A description of a change to the system is received. At each node, next-hop neighbor nodes for each consumer are identified. A routing value is assigned to each next-hop neighbor node for each consumer. Using the routing values in a context of the change, a performance cost of the system is estimated based on hypothetical changed placements of the computational components at nodes along paths from a producer to a consumer through the next-hop neighbor nodes for each consumer, and a changed placement of the computational components that minimizes performance cost of\u00a0\u2026", "num_citations": "4\n", "authors": ["506"]}
{"title": "Deterministic replay for transparent recovery in component-oriented middleware\n", "abstract": " We present and evaluate a low-overhead approach for achieving high-availability in distributed event-processing middleware systems consisting of networks of stateful software components that communicate by either one-way (send) or two-way (call) messages. The approach is based on transparently augmenting each component to produce a deterministic component whose state can be recovered by checkpoint and replay. Determinism is achieved by augmenting messages with virtual times, and by scheduling message handling in virtual time order. Scheduling delays are reduced by computing virtual times with estimators: deterministic functions that approximate the expected real times of arrival. We describe our algorithms, show how Java components can be transparently augmented with checkpointing code and with good estimators, discuss how our deterministic runtime can be tuned to reduce overhead\u00a0\u2026", "num_citations": "4\n", "authors": ["506"]}
{"title": "Performance modeling and placement of transforms for stateful mediations\n", "abstract": " In this paper we propose a new technique for placing large delivey plans for streaming systems on a network of machines to optimize efficiency measures such as latency. In the model we consider, there is a large network of machines and the different fixed end-points of the network act as publishers and subscribers of information. Information demanded by subscribers is a transformed view of the information published by the publishers. The transformed view is the outcome of an acyclic network of simple transformations operating on the publishers\u2019 information or some intermediate transformed view of it. We propose algorithms for the optimal placement of the acyclic transform network on the network of machines. As an example scenario to evaluate the efficacy of our algorithms we consider SQL queries on streaming relational tables. The transform network in this case is the SQL operator tree for the query. We first show how to model the performance of individual operators acting on distributed streams and then develop the optimal placement strategy for different optimization measures. We present our work on a distributed message-oriented middleware and a programming platform for large-scale publish-subscribe applications called SMILE. In our system, we use incremental implementation each of the relational operator for streaming data. We demonstrate that our technique performs significantly better than straightforward approaches like greedy, and random placement.", "num_citations": "4\n", "authors": ["506"]}
{"title": "The optimistic readers transformation\n", "abstract": " Monitors, such as Java classes with synchronized methods, are a convenient and safe abstraction for designing and reasoning about multithreaded object-oriented programs. However, the straightforward implementation of monitors can be inefficient, particularly in programs in which the majority of calls are to read-only methods. We introduce the optimistic readers program transformation, which may be implemented either as a compiler optimization, or as a \u201cdesign pattern.\u201d This transformation produces an implementation whose observable behavior is equivalent to that of a monitor, but in which read-only methods do not acquire locks or perform any shared writes. As a result, programmers can reason about their programs as if each shared object were implemented using mutual exclusion, while achieving the performance benefits of unsynchronized reads. We present the program transformation using the\u00a0\u2026", "num_citations": "4\n", "authors": ["506"]}
{"title": "Placement of replicated message mediation components\n", "abstract": " In this paper, we propose a technique for placing components of mediation flows within a Message-Oriented Middleware where components can be replicated. A mediation flow is a directed acyclic graph of message transformations (also known as mediations) connecting sources and sinks of messages. The source nodes correspond to producers, who enter messages into the middleware; the sink nodes correspond to consumers, who receive results derived from the input messages. All other nodes in the graph represent transformations of messages in the middleware. A placement is an assignment of nodes of the mediation flow graph to physical machines (brokers) in a distributed network.", "num_citations": "3\n", "authors": ["506"]}
{"title": "The global desktop: A graphical composition environment for local and distributed applications\n", "abstract": " This Research Report is available. This report has been submitted for publication outside of IBM and will probably be copyrighted if accepted for publication. It has been issued as a Research Report for early dissemination of its contents. In view of the transfer of copyright to the outside publisher, its distribution outside of IBM prior to publication should be limited to peer communications and specific requests. After outside publication, requests should be filled only by reprints or legally obtained copies of the article (eg, payment of royalties). I have read and understand this notice and am a member of the scientific community outside or inside of IBM seeking a single copy only.", "num_citations": "3\n", "authors": ["506"]}
{"title": "Point: do programmers need seatbelts?\n", "abstract": " Seat belts save lives. Mandating them has led to debate over the conflict between their benefits versus their constraints on individual freedom. An analogous debate is manifest in the programming languages community over\" safe\" language features, typically type declarations and compile-time and/or run-time checking of type violations. Do the benefits in safety justify the costs of possible loss of flexibility, increased declarative information, and possible loss of efficiency? Of course, no one is proposing Federal legislation requiring the use of typesafe languages, so the real question is: should programmers be encouraged to develop in type-safe languages and should language designers and implementers incorporate type safety into new languages, extensions to existing languages, and new implementations? I will take the position that in today's environments, for the vast majority of new applications, the value of\u00a0\u2026", "num_citations": "2\n", "authors": ["506"]}
{"title": "Hermes: Unix User's Guide\n", "abstract": " This user's guide describes how to use Hermes on Unix and overviews the software tools distributed with the Hermes system. Section 1 contains summaries of changes from prior releases of the system. Section 2 explains how you can run the sample programs appearing in the Hermes Tutorial. Sections 3 and 4 describes the mapping between Unix les and Hermes modules, and explains how to use the Hermes compiler. Section 5 presents a convenient environment for running Hermes programs| the Hermes shell. Section 6 outlines capabilities provided to every root Hermes process. These capabilities enable a Hermes program to do I/O, invoke Unix commands and system calls, and use other Hermes library programs. Section 7 presents programming tools provided with Hermes, including a make facility, a windows package, and a resource manager. Section 8 describes a set of services for executing distributed\u00a0\u2026", "num_citations": "2\n", "authors": ["506"]}
{"title": "Systems, methods and computer program products for improving placement performance of message transforms by exploiting guided replication\n", "abstract": " Systems, methods and computer program products for optimizing an objective function (eg the overall end-to-end runtime latency) of a flow graph of message transformations which are placed onto an overlay network of broker machines by replicating stateless transformations in a guided manner. Exemplary embodiments include a guided replication method, including given an initial transformation graph and a network topology, running a placement algorithm to obtain top N best task-to-broker assignments, identifying the R-task which forms the performance bottleneck, checking if the objective function improvement drops below a designated threshold, if yes, then selecting the optimal task-to-broker assignment and the program terminates; otherwise, replicating the R-task, optimally distributing the data load among R-task's replicas, deriving a set of starting points from the above obtained top N task-to-broker\u00a0\u2026", "num_citations": "1\n", "authors": ["506"]}
{"title": "Information Flow Based Messaging Middleware for Building Loosely Coupled Distributed Applications\n", "abstract": " Messaging middleware supports the integration of distributed components of an application by collecting messages from information producers and disseminating applicable messages to interested information consumers. In this paper, we present a flexible new model, the Information Flow Graph (IFG), for specifying and implementing the flow of information in a messaging application. We show that IFGs can be implemented efficiently by reducing them to a form that can exploit efficient multicast technology that has been developed for content-based publish/subscribe systems. Furthermore, we describe techniques for using stateful operations in IFGs to derive trends, summaries, and alarms from published events and to automatically generate equivalent sequences of events.", "num_citations": "1\n", "authors": ["506"]}
{"title": "Concurrency Control and View Notification Algorithms for Collaborative Replicated Objects\n", "abstract": " This paper describes algorithms for implementing a high-level programming model for synchronous distributed groupware applications. In this model, several application data objects may be atomically updated, and these objects automatically maintain consistency with their replicas using an optimistic algorithm. Changes to these objects may be optimistically or pessimistically observed by view objects by taking consistent snapshots. The algorithms for both update propagation and view notification are based upon optimistic guess propagation principles, adapted for fast commit by using primary copy replication techniques. The main contribution of the paper is the synthesis of these two algorithmic techniques-guess propagation and primary copy replication for implementing a framework that is easy to program to and is well suited for the needs of groupware applications.In this paper, we assume that replicated architectures are used because they generally have the potential to provide better interactive responsiveness and fault-tolerance, as users join and leave collaborative sessions. However, the domain of synchronous collaborative applications is broader than those supported by a fully replicated application architecture. For example,", "num_citations": "1\n", "authors": ["506"]}
{"title": "Process semantics: universal axioms compositional rules, and applications\n", "abstract": " We present a set of global axioms and compositional rules for describing the semantics of concurrent processes. In our semantic model, a process is defined by a set of partially-ordered traces on ports. The global axioms serve to rule out pathological processes. The compositional rules are used to derive semantics of composite processes from the semantics of their component processes. We prove that the global axioms are preserved by the compositional rules. A sound and complete proof system for our semantics is given. Finally, we apply the semantic model to give a formal definition of a concurrent language with dynamic process creation and dynamic port bindings.", "num_citations": "1\n", "authors": ["506"]}
{"title": "Nil\n", "abstract": " This paper is a summary of ongoing research activities related to the programming language NIL, a very high level language for large, long-lived software systems developed at IBM Yorktown.             We first present a short summary of the major features of NIL. These include the NIL system model, which is a dynamically evolving network of loosely coupled processes, communicating by message passing; the very high level NIL computation model; and typestate, which is a refinement of type systems which enables a compiler to assume an important part of program validation.             We then describe our current research directions which include 1) developing transformations which map NIL programs to efficient distributed and parallel implementations; 2) including programs as first-class typed NIL objects; and 3) research toward a semantic definition of NIL.", "num_citations": "1\n", "authors": ["506"]}
{"title": "Design, Implementation, and Validation of Secure Communications Systems.\n", "abstract": " We discuss those features of the NIL language which make NIL valuable during the design, implementation, val-idation, and testing phases of communication systems.These features include:(1) a process model in which shared or global data does not exist, thereby supporting concurrency and modularity in a single construct;(2) queued communication, which elininates the need to assume\" global time\" in an otherwise distributed system; this results in a high degree of uncoupling between modules, and permits truly modular verification of NIL systems;(3) run-time operations for loading processes and binding communications channels;(4) full specification of inter-module interfaces, and complete compile-time checking of the consistency between code and interfaces;(5) typestate checking, a subset of program verification performed automatically by a NIL compiler, which limits the extent to which unvalidated pro-grams can corrupt validated ones through dangerous side-effects.", "num_citations": "1\n", "authors": ["506"]}
{"title": "Syntactic Analysis of the Russian Sentence\n", "abstract": " The report describes results of a two year research effort in the field of automatic syntactic analysis of Russian within the framework of Russian-English machine translation R and D. The primary object of study and investigation consisted in design and development of the combinatorial syntactic analysis system, accompanied by an extensive linguistic research on Russian grammar. A concomitant small scale research on multiple path predictive syntactic analysis of Russian was conducted in parallel as an extension of the research effort initiated at Harvard University with the NSF support. Performance of the predictive analyzer on the test corpus of 160 Russian sentences is described.Descriptors:", "num_citations": "1\n", "authors": ["506"]}