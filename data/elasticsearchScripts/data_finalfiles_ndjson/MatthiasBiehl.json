{"title": "Search-based improvement of subsystem decompositions\n", "abstract": " The subsystem decomposition of a software system degrades gradually during its lifetime and therefore it gets harder and harder to maintain. As a result this decomposition needs to be reconditioned from time to time. The problem is to determine a suitable subsystem decomposition that can be used as a basis for future maintenance tasks. This paper describes a new methodology that computes such a subsystem decomposition by optimizing metrics and heuristics of good subsystem design. The main idea is to treat this task as a search problem and to solve it using a genetic algorithm.", "num_citations": "116\n", "authors": ["606"]}
{"title": "Literature study on model transformations\n", "abstract": " Model transformation is a central concept in model-driven development approaches, as it provides a mechanism for automating the manipulation of models. In this document we survey and classify existing model transformation technology. The classification differentiates between the problem space, ie characteristics of the problem to be solved by model transformation technology, and the mechanism, ie characteristics of the model transformation language. We show typical usage scenarios for model transformations and identify characteristics of the problems that can be solved with the help of model transformations. We synthesize a unifying classification scheme for model transformation languages based on several existing classification schemes. We introduce a selection of model transformation tools available today and compare them using our classification scheme.", "num_citations": "110\n", "authors": ["606"]}
{"title": "Integrating safety analysis into the model-based development toolchain of automotive embedded systems\n", "abstract": " The automotive industry has a growing demand for the seamless integration of safety analysis tools into the model-based development toolchain for embedded systems. This requires translating concepts of the automotive domain to the safety domain. We automate such a translation between the automotive architecture description language EAST-ADL2 and the safety analysis tool HiP-HOPS by using model transformations and by leveraging the advantages of different model transformation techniques. Through this integration, the analysis can be conducted early in the development process, when the system can be redesigned to fulfill safety goals with relatively low effort and cost.", "num_citations": "68\n", "authors": ["606"]}
{"title": "Integrating viewpoints in the development of mechatronic products\n", "abstract": " The development of mechatronic products involves multiple stakeholders which have different viewpoints and therefore use different concepts, models and tools to deal with their concerns of interest. This paper argues that an increased emphasis needs to be placed on the relations between viewpoints to be able to deal with the evolving scope and requirements on mechatronic products. We study relations between viewpoints at the levels of people, models and tools, and present solutions that are used to formally and explicitly capture such relations. Viewpoint contracts are used to define the vocabulary, assumptions and constraints required for ensuring smooth communication between stakeholders (people level). Dependency models capture relations between product properties belonging to different viewpoints, and how such dependencies relate to predictions and decisions (model level). Tool integration\u00a0\u2026", "num_citations": "66\n", "authors": ["606"]}
{"title": "A characterization of integrated multi-view modeling in the context of embedded and cyber-physical systems\n", "abstract": " Embedded systems, with their tight technology integration, and multiple requirements and stakeholders, are characterized by tightly interrelated processes, information and tools. Embedded systems will as a consequence be described by multiple, heterogeneous and interrelated descriptions such as for example requirements documents, design and analysis models, software and hardware descriptions. We refer to a system designed this way as a multi-view (MV) system. The main contribution of this paper is a characterization of model-based approaches to MV systems. The characterization takes three main perspectives for the relations between viewpoints: semantic relations (content), relations over time (process), and manipulation of views (operations). We complement these perspectives by investigating MV system challenges and by a survey of related approaches. The characterization aims to provide a basis\u00a0\u2026", "num_citations": "49\n", "authors": ["606"]}
{"title": "On the modeling and generation of service-oriented tool chains\n", "abstract": " Tool chains have grown from ad-hoc solutions to complex software systems, which often have a service-oriented architecture. With service-oriented tool integration, development tools are made available as services, which can be orchestrated to form tool chains. Due to the increasing sophistication and size of tool chains, there is a need for a systematic development approach for service-oriented tool chains. We propose a domain-specific modeling language (DSML) that allows us to describe the tool chain on an appropriate level of abstraction. We present how this language supports three activities when developing service-oriented tool chains: communication, design and realization. A generative approach supports the realization of the tool chain using the service component architecture. We present experiences from an industrial case study, which applies the DSML to support the creation of a service\u00a0\u2026", "num_citations": "45\n", "authors": ["606"]}
{"title": "A modular tool integration approach: experiences from two case studies\n", "abstract": " In the model-driven development process of automotive embedded systems a number of specialized tools are used to support various development tasks. Each tool needs to work seamlessly with artifacts created by other tools to increase the efficiency of development. We identify desirable properties for integrating the data of different tools. We then propose an approach for decomposing the data integration into modular steps that fulfill these properties. We report our experiences from applying this approach to integrate simulation capabilities and functionality for safety analysis into a model-based development environment.", "num_citations": "31\n", "authors": ["606"]}
{"title": "High-level specification and code generation for service-oriented tool adapters\n", "abstract": " The development of complex systems requires tool support for the different phases of the system life cycle. To allow for an efficient development process, the involved tools need to be integrated, e.g. by exchanging tool data or providing trace ability between the data. Despite the availability of tool integration platforms and frameworks, it is labor-intensive and costly to build tool integration solutions. Industrial tool integration initiatives such as OSLC (Open Services for Lifecycle Collaboration) demand complex configurations and the adherence to integration standards. This further complicates building an integration solution. We propose an approach that uses formalized specifications to systematize tool integration and specialized code generators to automate the process of building tool adapters. We evaluate our approach with the implementation of a code generator that creates service-oriented tool adapters\u00a0\u2026", "num_citations": "28\n", "authors": ["606"]}
{"title": "Model-based toolchain for the efficient development of safety-relevant automotive embedded systems\n", "abstract": " Advanced functionalities unthinkable a few decades ago are now being introduced into automotive vehicles through embedded systems for reasons like emission control, vehicle connectivity, safety and cooperative behaviors. As the development often involves stakeholders from different engineering disciplines and organizations, the complexity due to shared requirements, interdependencies of data, functions, and resources, as well as tight constraints in regards to timing, safety, and resource efficiency makes the system integration, quality control and assurance, reuse and change management increasingly more difficult. This calls for a more rigorous approach to the development of automotive embedded systems and components. This paper describes the CESAR reference technology platform (RTP) that supports the formalization of various engineering concerns in the development of safety-relevant embedded systems and thereby a model-based integration of various tools and methods to form seamless environments or toolchains for the development of such systems.", "num_citations": "26\n", "authors": ["606"]}
{"title": "Integrated tool-chain for improving traceability during the development of automotive systems\n", "abstract": " Tool integration is a key factor for improving development efficiency and product quality during the development of safety-relevant embedded systems. We present in this work a demonstrator based on the most recent outcomes of the CESAR project. The proposed integrated tool-chain aims at better linking development activities together, thus improving traceability during requirements engineering, system design, safety analysis and V&V activities using a model-based development approach. We analyze the proposed tool-chain from three different points of view:(1) tool integrator,(2) technology provider, and (3) end-user. These different points of view enable the description of the different technologies used at the different levels and the analysis of the benefits for the end-user.", "num_citations": "23\n", "authors": ["606"]}
{"title": "PLM for Mechatronics integration\n", "abstract": " Mechatronics is a synergistic integration of mechanical, electronic, and control engineering, with computer science. The mechatronics development, which is offering new features and business opportunities at an increasing pace, is driven by technology, increasing competition and legislation. Mechatronics engineering develops new types of components, with tight relations and dependencies between mechanics, electronics, and software domains. New technology implies new types of errors, faults, and error modes, as well as completely new and unforeseen types of emergent behavior. This paper addresses these challenges by proposing a SOA-based collaboration hub that is based on a PLM strategy and model-based systems engineering methods.", "num_citations": "20\n", "authors": ["606"]}
{"title": "Tool integration beyond Wasserman\n", "abstract": " The typical development environment today consists of many specialized development tools, which are partially integrated, forming a complex tool landscape with partial integration. Traditional approaches for reasoning about tool integration are insufficient to measure the degree of integration and integration optimality in today\u2019s complex tool landscape. This paper presents a reference model that introduces dependencies between, and metrics for, integration aspects to overcome this problem. This model is used to conceive a method for reasoning about tool integration and identify improvements in an industrial case study. Based on this we are able to conclude that our reference model does not detract value from the principles that it is based on, instead it highlights improvements that were not well visible earlier. We conclude the paper by discussing open issues for our reference model, namely if it is\u00a0\u2026", "num_citations": "18\n", "authors": ["606"]}
{"title": "Automated architecture consistency checking for model driven software development\n", "abstract": " When software projects evolve their actual implementation and their intended architecture may drift apart resulting in problems for further maintenance. As a countermeasure it is good software engineering practice to check the implementation against the architectural description for consistency. In this work we check software developed by a Model Driven Software Development (MDSD) process. This allows us to completely automate consistency checking by deducing information from implementation, design documents, and model transformations. We have applied our approach on a Java project and found several inconsistencies hinting at design problems. With our approach we can find inconsistencies early, keep the artifacts of an MDSD process consistent, and, thus, improve the maintainability and understandability of the software.", "num_citations": "18\n", "authors": ["606"]}
{"title": "A modeling language for the description and development of tool chains for embedded systems\n", "abstract": " The development of embedded systems is typically supported by a number of diverse development tools. To achieve seamless tool support throughout the embedded systems development process, tool chains are constructed as software solutions that integrate the development tools. Tool chains have grown from ad-hoc solutions to complex software systems, since they need to support distributed engineering, integration conventions, a specific set of tools and the complete product development process used in a company. In practice, the development of tool chains that fulfill these needs is difficult and time-consuming, since it is a largely unsupported, manual engineering task. In addition, tool chains are typically described using general purpose modeling languages or languages borrowed from other domains, which contributes to the accidental complexity of tool chain development. Due to the increasing sophistication and size of tool chains, there is a need for a systematic, targeted description and development approach for tool chains. This thesis contributes with a language for the systematic description of tool chains and semi-automated techniques to support their development.\u2022 The Tool Integration Language (TIL) is a domain-specific modeling language (DSML) for tool chains that allows describing tool chains explicitly, systematically and at an appropriate level of abstraction. TIL concepts are from the domain of tool integration and express the essential design decisions of tool chains at an architectural level of abstraction. A TIL model serves as a basis for the development of a tailored tool chain.", "num_citations": "14\n", "authors": ["606"]}
{"title": "RESTful Api Design\n", "abstract": " Looking for Best Practices for RESTful APIs? This book is for you! Why? Because this book is packed with practical experience on what works best for RESTful API Design. You want to design APIs like a Pro? Use API description languages to both design APIs and develop APIs efficiently. The book introduces the two most common API description languages RAML, OpenAPI, and Swagger. Your company cares about its customers? Learn API product management with a customer-centric design and development approach for APIs. Learn how to manage APIs as a product and how to follow an API-first approach. Build APIs your customers love! You want to manage the complete API lifecycle? An API development methodology is proposed to guide you through the lifecycle: API inception, API design, API development, API publication, API evolution, and maintenance. You want to build APIs right? This book shows best practices for REST design, such as the correct use of resources, URIs, representations, content types, data formats, parameters, HTTP status codes, and HTTP methods. Your APIs connect to legacy systems? The book shows best practices for connecting APIs to existing backend systems. Your APIs connect to a mesh of microservices? The book shows the principles for designing APIs for scalable, autonomous microservices. You expect lots of traffic on your API? The book shows you how to achieve high performance, availability and maintainability. You want to build APIs that last for decades? We study API versioning, API evolution, backward-and forward-compatibility and show API design patterns for versioning. The API-University\u00a0\u2026", "num_citations": "13\n", "authors": ["606"]}
{"title": "System dependability modelling and analysis using AADL and HiP-HOPS\n", "abstract": " The Architecture Analysis and Design Language (AADL) is gaining widespread acceptance in aerospace, automobile and avionics industries for designing dependability-critical systems. The design process of dependable systems must address both cost and dependability (safety, reliability, availability, maintainability) concerns. This requires translating concepts of the design domain to the dependability analysis domain. We automate such a translation between AADL and the dependability analysis tool HiP-HOPS by using model transformation techniques. A generic primary-standby example system is used to show the mechanics of the transformation and the potential for highlighting problems and assisting design work using this technology.", "num_citations": "13\n", "authors": ["606"]}
{"title": "Model-based service discovery and orchestration for OSLC services in tool chains\n", "abstract": " Globally distributed development of complex systems relies on the use of sophisticated development tools but today the tools provide only limited possibilities for integration into seamless tool chains. If development tools could be integrated, development data could be exchanged and tracing across remotely located tools would be possible and would increase the efficiency of globally distributed development. We use a domain specific modeling language to describe tool chains as models on a high level of abstraction. We use model-driven technology to synthesize the implementation of a service-oriented wrapper for each development tool based on OSLC (Open Services for Lifecyle Collaboration) and the orchestration of the services exposed by development tools. The wrapper exposes both tool data and functionality as web services, enabling platform independent tool integration. The orchestration\u00a0\u2026", "num_citations": "12\n", "authors": ["606"]}
{"title": "A domain specific language for generating tool integration solutions\n", "abstract": " Model-based development of complex systems requires toolsupport for the dierent phases of the system life cycle. To allow for anecient development process, the involved tools need to be integrated. Despite the availability of modern tool integration platforms and frameworks, it is complex, labor-intensive and costly to build tool integrationsolutions. For managing the growing complexity of tool integration solutions, a need for systematic engineering arises. A missing piece is thehigh-level architectural description of tool integration solutions. We proposethe domain specic language TIL for describing tool integrationsolutions at a high level of abstraction. We propose an approach thattakes advantage of modeling technologies to systematize and automatethe process of building tool integration solutions. By automatically generatingintegration solutions from a TIL model, we can reduce the manualimplementation eort.", "num_citations": "12\n", "authors": ["606"]}
{"title": "A light-weight tool integration approach: From a tool integration model to oslc integration services\n", "abstract": " Existing tool integration approaches integrate various tools directly through tool proprietary APIs. This kind of integration lacks standardization and are different case by case. Integration based upon common tool metamodels also turns to be too complicated and hard to maintain. In this paper we provide an approach which integrates tools based on a combination of tool metamodels and an integration model. Tool element representatives (Artifacts) are defined to make integrations more standardized and flexible compared to direct tool APIs. The approach links the tool integration model to the various tool metamodels, and provides mechanism by which the common integration properties and the various tool metamodels are related. An industrial case study has been performed to validate the approach with both scenarios of traceability and exchange of data based upon common data definitions.", "num_citations": "11\n", "authors": ["606"]}
{"title": "Constructing tool chains based on SPEM process models\n", "abstract": " The development of embedded systems requires a number of tools and it is widely believed that integrating the tools into an automated tool chain can improve the productivity of development. However, tool chains are not accepted by practitioners if they are not aligned with the established development culture, processes and standards. Process models exist for a variety of reasons, ie, for documenting, planning or tracking progress in a development project and SPEM is the standardized formalism by the OMG for this purpose. We explore in how far a SPEM process models can be used for creating the skeleton of a tool chain, which is aligned with the process. We identify a number of relationship patterns between the development process and its supporting tool chain and show how the patterns can be used for constructing a tool chain. In two case studies, we examine the practical applicability of the patterns, when tailoring the design of a tool chain to a development process.", "num_citations": "9\n", "authors": ["606"]}
{"title": "An executable design decision representation using model transformations\n", "abstract": " Design decisions are often tacit knowledge of an architecture and consequently they are easily lost during software evolution, a phenomenon known as knowledge vaporization. As a countermeasure design decisions can be documented explicitly. However, documenting design decision is expensive because they need to be captured in addition to the changes in the architecture. We propose an executable representation for design decisions using model transformations which is independent of a particular component model or architectural description language. As a result we get all the advantages of explicitly captured design decisions such as the potential to reduce knowledge vaporization while preventing the high capturing cost since the corresponding architectural change can be computed automatically. The approach is illustrated by a case study in the context of embedded software architectures.", "num_citations": "9\n", "authors": ["606"]}
{"title": "Supporting model evolution in model-driven development of automotive embedded system\n", "abstract": " Innovative functions in cars, such as active safety systems and advanced driver assistance systems, are realized as embedded systems. The development of such automotive embedded systems is challenging in several respects: the product typically has several crosscutting system properties, experts of diverse disciplines need to cooperate and appropriate processes and tools are required to improve the efficiency and the complexity management of development. Model-driven development captures the architecture of the embedded system in the form of models with well-defined metamodels. Model-driven development provides a partial solution to some of the challenges of embedded systems development, but it also introduces new challenges. Models do not remain static, but they change over time and evolve. Evolution can change models in two ways:(1) by making design decisions and adding, deleting or changing model elements, or (2) by reusing models in different tools. We propose support for both aspects of model evolution.(1) When models are changed, the design decisions and the justification for the change are usually neither captured nor documented in a systematic way. As a result, important information about the model is lost, making the model more difficult to understand, which hampers model evolution and maintenance. To support model evolution, design decisions need to be captured explicitly using an appropriate representation. This representation reduces the overhead of capturing design decisions, keeps the model and the design decision documentation consistent and links the design decision documentation to the\u00a0\u2026", "num_citations": "8\n", "authors": ["606"]}
{"title": "Webhooks\u2013Events for RESTful APIs\n", "abstract": " Got RESTful APIs? Great. API consumers love them. But today, such RESTful APIs are not enough for the evolving expectations of API consumers. Their apps need to be responsive, event-based and react to changes in near real-time. This results in a new set of requirements for the APIs, which power the apps. APIs now need to provide concepts such as events, notifications, triggers, and subscriptions. These concepts are not natively supported by the REST architectural style. In thios book we show how to engineer RESTful APIs that support events with a webhook infrastructure. What are the alternatives to webhooks? We study several approaches for realizing events, such as Polling, Long Polling, Webhooks, HTTP Streaming, Server-Sent Events, WebSockets, WebSub and GraphQL Subscriptions. All of these approaches have their advantages and disadvantages. Can webhooks communicate in real-time? We study the non-functional requirements of a webhooks infrastructure, in areas such as security, reliability and developer experience. How do well-known API providers design webhooks? We examine the webhook infrastructure provided by GitHub, BitBucket, Stripe, Slack, and Intercom. With the best practices, case studies, and design templates provided in this book, we want to help you extend your API portfolio with a modern webhook infrastructure. So you can offer both APIs and events that developers love to use.", "num_citations": "7\n", "authors": ["606"]}
{"title": "A roadmap towards integrated CPS development environments\n", "abstract": " Cyber Physical System (CPS) development is highly heterogeneous, involving many stakeholders, each of which interacts with its development artifacts through a variety of tools, and within several engineering processes. Successful CPS development requires these tools to be well-integrated into a Development Environment (DE) in order to support its many stakeholders and processes. In this paper we identify the main challenges facing DE development for CPSs, and presents a roadmap to meet these challenges. We here take the position that focus should be redirected from trying to achieve a single, one-size-fits-all solution to such a heterogeneous problem. Instead, focus should be placed on supporting the development of highly-customized DEs, which readily can be applied to industrial development. Such a highly-customized DE should fit the needs of a particular development organization, while at the same time taking advantage of relevant standardization efforts.", "num_citations": "7\n", "authors": ["606"]}
{"title": "GraphQL API Design\n", "abstract": " Want to build APIs like Facebook? Since Facebook's framework for building APIs, GraphQL, has become publicly available, this ambition seems to be within reach for many companies. And that is great. But first, let's learn what GraphQL really is and-maybe even more importantly-let's figure out how to apply GraphQL to build APIs that consumers love. Do you like to learn hands-on? In this book, we take a hands-on approach to learning GraphQL. We first explore the concepts of the two GraphQL languages using examples. Then we start writing some code for our first GraphQL API. We develop this API step by step, from creating a schema and resolving queries, over mocking data and connecting data sources all the way to developing mutations and setting up event subscriptions. Are your API consumers important to you? This book shows you how to apply a consumer-oriented design process for GraphQL APIs, so you can deliver what your consumers really want: an API that solves their problems and offers a great developer experience. Do you want to enable the API consumers so they can build great apps? This book explains the GraphQL query language, which allows the API consumers to retrieve data, write data and get notified when data changes. More importantly, you let them decide, which data they really need from the API. Do you want to make your API easy and intuitive to use? This book shows you how to use the GraphQL schema language to define a type system for your API, which serves as a reference documentation and helps your API consumers write queries that are syntactically correct. Do you want to profit from what has\u00a0\u2026", "num_citations": "5\n", "authors": ["606"]}
{"title": "Towards the automated qualification of tool chain design\n", "abstract": " The development of safety-critical embedded systems is supported by a number of development tools, which are increasingly integrated into automated tool chains. Safety standards require these tool chains to be qualified, which is costly and requires a large effort. To reduce cost and effort tool chains can be composed of pre-qualified tools and then themselves pre-qualified by identifying the parts of tool chain software that have an impact on safety more exactly. In this paper we propose the use of a modeling language to describe this tool chain composition. This allows us to reduce effort even further by automatically analyzing the tool chain model for safety issues. It also promises to reduce the effort and cost of later steps in the deployment of the tool chain by formalizing the communication of safety issues and automating the generation of code for tool chain software.", "num_citations": "5\n", "authors": ["606"]}
{"title": "A cost-efficiency model for tool chains\n", "abstract": " The seamless integration of development tools can help to improve the productivity of software development and reduce development costs. When tool chains are used in the context of global software engineering, they are deployed as globally distributed systems. Tool chains have the potential to bring productivity gains but they are also expensive to realize. The decision to introduce a tool chain is often made based only on a qualitative analysis of the situation. More precise analysis of the trade-offs would be possible if a quantitative model describing the cost-efficiency of tool chains would be available. We apply the COCOMO model for cost analysis in combination with the TIL model for tool chain design to create a generic quantitative estimation model for predicting the cost-efficiency of tool chains. We validate the cost-efficiency model with a case study of an industrial tool chain.", "num_citations": "5\n", "authors": ["606"]}
{"title": "Tool integration, from tool to tool chain with ISO 26262\n", "abstract": " The use of innovative power sources in future cars has long-ranging implications on vehicle safety. We studied these implications in the context of the guidance on software tool qualification in the then current ISO 26262 draft, when building an urban concept vehicle to participate in the 2011 Shell Eco-Marathon. While the guidance on tool qualification is detailed, the guidance in regard to tools integrated into tool chains is limited. It only points out that the environment that tools execute in needs to be taken into consideration. In this paper we clarify the implications of tool chains on tool qualification in the context of ISO 26262 by focusing on answering two questions; first, are there parts of the development environment related to tool integration that are likely to fall outside of tool qualification efforts as currently defined by ISO 26262; secondly, can we define if, and-if so-how, tool integration is affected by ensuring\u00a0\u2026", "num_citations": "5\n", "authors": ["606"]}
{"title": "A characterization of integrated multi-view modeling for embedded systems\n", "abstract": " Embedded systems, with their tight technology integration, andmultiple requirements andstakeholders, are characterized by tightly interrelated processes, information and tools. Embedded systems will as a consequence be described by multiple, heterogeneous andinterrelated descriptions such as for example requirements documents, design and analysismodels, software and hardware descriptions. We refer to a system designed this way as amulti-view (MV) system.The main contribution of this paper is a characterization of model-based approachesto MV systems. The characterization takes three main perspectives: semantic relationsbetween views (content), relations over time (process), and manipulation of views (operations). We complement these perspectives by investigating MV system challenges and bya survey of related approaches. The characterization aims to provide a basis for a betterunderstanding, design and implementation of MV systems, and thereby to overcome thecurrent fragmented points of view on integrated multi-view modeling (MVM).", "num_citations": "4\n", "authors": ["606"]}
{"title": "Early automated verification of tool chain design\n", "abstract": " Tool chains are expected to increase the productivity of product development by providing automation and integration. If, however, the tool chain does not have the features required to support the product development process, it falls short of this expectation. Tool chains could reach their full potential if it could be ensured that the features of a tool chain are aligned with the product development process. As part of a systematic development approach for tool chains, we propose a verification method that measures the extent to which a tool chain design conforms to the product development process and identifies misalignments. The verification method can be used early in tool chain development, when it is relatively easy and cheap to perform the necessary corrections. Our verification method is automated, which allows for quick feedback and enables iterative design. We apply the proposed method on an\u00a0\u2026", "num_citations": "4\n", "authors": ["606"]}
{"title": "Automated construction of data integration solutions for tool chains\n", "abstract": " Modern software development relies increasingly on the orchestrated use of development tools in the form of seamless, automated tool chains. Tool chains are becoming complex software systems themselves, however, the efficient development of tool chains is a largely unsupported, manual engineering task. We propose both a domain specific modeling language for systematically specifying tool chains and generators for efficiently realizing the tool chain as software. Tool chain software consists of diverse components, such as service-oriented applications, models and model transformations, which we produce by different generative techniques. We study both the separate generative techniques and the dependencies between the generated artifacts to ensure that they can be integrated. We evaluate the approach both quantitatively and qualitatively, and show in a case study that the approach is practically applicable when building a tool chain for industrially relevant tools.", "num_citations": "4\n", "authors": ["606"]}
{"title": "Literature study on design rationale and design decision documentation for architecture descriptions\n", "abstract": " In this document we provide an overview of the state of the art in documentation of design rationale and design decisions for architecture descriptions. We define the terminology of the area and compare the concept of rationale to similar concepts. We provide an overview of areas of contemporary research in design rationale. For each of the identified areas, we describe both the challenge and proposed solutions. Based on the findings from the literature we present evaluations of rationale and design decision documentation. The findings from this survey are promising and many open research questions with respect to rationale and design decision documentation need to be addressed. In the literature reviewed in this document it is for example not addressed how design decisions and design rationale should be represented, captured and used in model-based and model-driven development approaches. A need for further research in this area exists.", "num_citations": "4\n", "authors": ["606"]}
{"title": "APL\u2013a language for automated anti-pattern analysis of OO-software\n", "abstract": " The structure of existing, object-oriented software systems decays due to continuous maintenance and extension of functionality. Therefore the eroding software structure has to be improved from time to time, using automated problem detection and correction to be feasible for large software systems. However, when different languages and technologies are used, existing detection strategies need to be rewritten from scratch.This project explores a generative approach for creating programs that perform automated problem detection. It introduces the domain-specific language APL to describe problem detection on an abstract level and thus in a platform independent way. Generators transform the high-level APL specification to problem detection programs for different languages and technologies.", "num_citations": "4\n", "authors": ["606"]}
{"title": "Documenting stepwise model refinement using executable design decisions\n", "abstract": " During model refinement a wealth of knowledge about the model under development is accumulated that is only partly represented by the model itself. Design decisions and the considered modeling alternatives are neither represented by the model nor are they documented. During later lifecycle stages this information is often not available any more, which reduces the understandability of the model and potentially leads to inconsistencies and erosion of the model. We propose an approach to capture and store the design decisions in model-driven development. We represent design decisions as model transformations and propose tool support that applies this representation to capture design decision with low effort. The captured design decisions provide a record of the model evolution and the rationale of the evolution.", "num_citations": "3\n", "authors": ["606"]}
{"title": "Making Money with Alexa Skills\n", "abstract": " Voice assistants-such as Alexa-have one of the highest adoption rates in history: more than 30 million devices have been sold. This large and growing number of devices creates a massive demand for a new type of app: the voice app or Skill. Just as in the early days of mobile, when fortunes were made with mobile apps on the app store, it is now the perfect time to catch the opportunities offered by voice apps. Amazon Alexa, the voice platform with the broadest adoption, helps developers like you and me, to develop, distribute, market and monetize their Alexa Skills on the Amazon Alexa Store. In this book, you learn step-by-step how to create your first Alexa Skill with the Alexa Developer Console, AWS Lambda, the Alexa CLI, and node. js with the Alexa SDK. You get a deep-dive into the various ways of making money with Alexa. You learn about the business models for Alexa Skills, marketing and monetizing your\u00a0\u2026", "num_citations": "2\n", "authors": ["606"]}
{"title": "API Architecture\n", "abstract": " Looking for the big picture of building APIs? This book is for you! Building APIs that consumers love should certainly be the goal of any API initiative. However, it is easier said than done. It requires getting the architecture for your APIs right. This book equips you with both foundations and best practices for API architecture. This book is for you if you want to understand the big picture of API design and development, you want to define an API architecture, establish a platform for APIs or simply want to build APIs your consumers love. This book is NOT for you, if you are looking for a step-by step guide for building APIs, focusing on every detail of the correct application of REST principles. In this case I recommend the book\" API Design\" of the API-University Series. What is API architecture? Architecture spans the bigger picture of APIs and can be seen from several perspectives: API architecture may refer to the architecture of the complete solution consisting not only of the API itself, but also of an API client such as a mobile app and several other components. API solution architecture explains the components and their relations within the software solution. API architecture may refer to the technical architecture of the API platform. When building, running and exposing not only one, but several APIs, it becomes clear that certain building blocks of the API, runtime functionality and management functionality for the API need to be used over and over again. An API platform provides an infrastructure for developing, running and managing APIs. API architecture may refer to the architecture of the API portfolio. The API portfolio contains all APIs of the enterprise\u00a0\u2026", "num_citations": "2\n", "authors": ["606"]}
{"title": "OAuth: Getting Started in Web-API Security\n", "abstract": " This book offers an introduction to web-API security with OAuth 2.0 and OpenID Connect. In less than 50 pages you will gain an overview of the capabilities of OAuth. You will learn the core concepts of OAuth. You will get to know all four OAuth flows that are used in cloud solutions and mobile apps. If you have tried to read the official OAuth specification, you may get the impression that OAuth is complex. This book explains OAuth in simple terms. The different OAuth flows are visualized graphically using sequence diagrams. The diagrams allow you to see the big picture of the various OAuth interactions. This high-level overview is complemented with rich set of example requests and responses and an explanation of the technical details. In the book the challenges and benefits of OAuth are presented, followed by an explanation of the technical concepts of OAuth. The technical concepts include the actors, endpoints, tokens and the four OAuth flows. Each flow is described in detail, including the use cases for each flow. Extensions of OAuth are presented, such as OpenID Connect and the SAML2 Bearer Profile. Who should read this book? You do not have the time to read long books? This book provides an overview, the core concepts, without getting lost in the small-small details. This book provides all the necessary information to get started with OAuth in less than 50 pages. You believe OAuth is complicated? OAuth may seem complex with flows and redirects going back and forth. This book will give you clarity by introducing the seemingly complicated material by many illustrations. These illustrations clearly show all the involved interaction parties\u00a0\u2026", "num_citations": "2\n", "authors": ["606"]}
{"title": "An Estimation Model for the Savings Achievable by Tool Chains\n", "abstract": " Tool chains are sought after by industry due to their promise to improve the productivity of software development by reducing costs. Despite these promises, there are few attempts to quantify costs and productivity improvements achievable with a tool chain. The decision for or against realizing a tool chain design requires a quantitative analysis of the economic benefits achievable with a tool chain. We apply the COCOMO model for cost estimation to create a quantitative model for predicting the cost-savings of tool chains. The cost-savings model can provide support for practitioners and decision makers when facing the decision to create a new tool chain.", "num_citations": "2\n", "authors": ["606"]}
{"title": "Automated Tailoring of Application Lifecycle Management Systems to Existing Development Processes\n", "abstract": " Application lifecycle management approaches are used to tame the increasing complexity, size and number of development artifacts. Throughout the application lifecycle, a number of tools are used to create a diversity of development artifacts. It is widely believed that the efficiency of development can be improved by the integration of these tools. However, such integrated solutions are not accepted by practitioners if the solutions are not aligned with the established development culture, processes and standards. Thus, application lifecycle management needs to be tailored to the specific corporate needs. The tailoring, however, is typically performed manually and is thus resource intensive. We propose a cost efficient tailoring approach for application lifecycle management, which is based on reuse and automation. We explore to what extent existing process models can be reused for automatically configuring the application lifecycle management system, so it is aligned with the development process. We identify a number of relationship patterns between the development process and its supporting tool chain and show how the patterns can be used for constructing a tool chain. In three case studies, we examine the practical applicability of the approach.", "num_citations": "1\n", "authors": ["606"]}
{"title": "Architecture exploration\n", "abstract": " In this chapter, we will explain and concretise the concept of architecture exploration as an approach to architecture design of distributed embedded safety-critical systems. Architecture design involves the mapping of behaviour to structure, or functions to components. Alternative behaviours, structures and mappings are possible, and it is the subject of the architecture design to make a well-informed choice about which alternative(s) are preferable. Architecture design can be seen as an iterative process, as illustrated by Fig. 4.1", "num_citations": "1\n", "authors": ["606"]}
{"title": "Literature study on the state of the art in model transformation technology\n", "abstract": " Model transformation is a central concept in model-driven development approaches, as it provides a mechanism for automating the manipulation of models. In this document we survey and classify existing model transformation technology. The classification differentiates between the problem space, ie characteristics of the problem to be solved by model transformation technology, and the mechanism, ie characteristics of the model transformation language. We show typical usage scenarios for model transformations and identify characteristics of the problems that can be solved with the help of model transformations. We synthesize a unifying classification scheme for model transformation languages based on several existing classification schemes. We introduce a selection of model transformation tools available today and compare them using our classification scheme.", "num_citations": "1\n", "authors": ["606"]}