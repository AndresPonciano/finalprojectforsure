{"title": "Using SAT for combinational equivalence checking\n", "abstract": " This paper addresses the problem of combinational equivalence checking (CEC) which forms one of the key components of the current verification methodology for digital systems. A number of recently proposed BDD based approaches have met with considerable success in this area. However, the growing gap between the capability of current solvers and the complexity of verification instances necessitates the exploration of alternative, better solutions. This paper revisits the application of Satisfiability (SAT) algorithms to the combinational equivalence checking (CEC) problem. We argue that SAT is a more robust and flexible engine of Boolean reasoning for the CEC application than BDDs, which have traditionally been the method of choice. Preliminary results on a simple framework for SAT based CEC show a speedup of up to two orders of magnitude compared to state-of-the-art SAT based methods for CEC and\u00a0\u2026", "num_citations": "225\n", "authors": ["71"]}
{"title": "X-PERT: Accurate identification of cross-browser issues in web applications\n", "abstract": " Due to the increasing popularity of web applications, and the number of browsers and platforms on which such applications can be executed, cross-browser incompatibilities (XBIs) are becoming a serious concern for organizations that develop web-based software. Most of the techniques for XBI detection developed to date are either manual, and thus costly and error-prone, or partial and imprecise, and thus prone to generating both false positives and false negatives. To address these limitations of existing techniques, we developed X-PERT, a new automated, precise, and comprehensive approach for XBI detection. X-PERT combines several new and existing differencing techniques and is based on our findings from an extensive study of XBIs in real-world web applications. The key strength of our approach is that it handles each aspects of a web application using the differencing technique that is best suited to\u00a0\u2026", "num_citations": "131\n", "authors": ["71"]}
{"title": "Elixir: Effective object-oriented program repair\n", "abstract": " This work is motivated by the pervasive use of method invocations in object-oriented (OO) programs, and indeed their prevalence in patches of OO-program bugs. We propose a generate-and-validate repair technique, called ELIXIR designed to be able to generate such patches. ELIXIR aggressively uses method calls, on par with local variables, fields, or constants, to construct more expressive repair-expressions, that go into synthesizing patches. The ensuing enlargement of the repair space, on account of the wider use of method calls, is effectively tackled by using a machine-learnt model to rank concrete repairs. The machine-learnt model relies on four features derived from the program context, i.e., the code surrounding the potential repair location, and the bug report. We implement ELIXIR and evaluate it on two datasets, the popular Defects4J dataset and a new dataset Bugs.jar created by us, and against 2\u00a0\u2026", "num_citations": "128\n", "authors": ["71"]}
{"title": "CrossCheck: Combining Crawling and Differencing to Better Detect Cross-browser Incompatibilities in Web Applications.\n", "abstract": " One of the consequences of the continuous and rapid evolution of web technologies is the amount of inconsistencies between web browsers implementations. Such inconsistencies can result in cross-browser incompatibilities (XBIs)\u2014situations in which the same web application can behave differently when run on different browsers. In some cases, XBIs consist of tolerable cosmetic differences. In other cases, however, they may completely prevent users from accessing part of a web application\u2019s functionality. Despite the prevalence of XBIs, there are hardly any tools that can help web developers detect and correct such issues. In fact, most existing approaches against XBIs involve a considerable amount of manual effort and are consequently extremely time consuming and error prone. In recent work, we have presented two complementary approaches, WEBDIFF and CROSST, for automatically detecting and reporting XBIs. In this paper, we present CROSSCHECK, a more powerful and comprehensive technique and tool for XBI detection that combines and adapts these two approaches in a way that leverages their respective strengths. The paper also presents an empirical evaluation of CROSSCHECK on a set of real-world web applications. The results of our experiments show that CROSSCHECK is both effective and efficient in detecting XBIs, and that it can outperform existing techniques.", "num_citations": "100\n", "authors": ["71"]}
{"title": "Why is ATPG easy?\n", "abstract": " Empirical observation shows that practically encountered instances of ATPG are efficiently solvable. However, it has been known for more than two decades that ATPG is an NP-complete problem. This work is one of the first attempts to reconcile these seemingly disparate results. We introduce the concept of circuit cut-width and characterize the complexity of ATPG in terms of this property. We provide theoretical and empirical results to argue that an interestingly large class of practical circuits have cut-width characteristics which ensure a provably efficient solution of ATPG on them.", "num_citations": "96\n", "authors": ["71"]}
{"title": "Bugs. jar: a large-scale, diverse dataset of real-world java bugs\n", "abstract": " We present Bugs. jar, a large-scale dataset for research in automated debugging, patching, and testing of Java programs. Bugs. jar is comprised of 1,158 bugs and patches, drawn from 8 large, popular open-source Java projects, spanning 8 diverse and prominent application categories. It is an order of magnitude larger than Defects4J, the only other dataset in its class. We discuss the methodology used for constructing Bugs. jar, the representation of the dataset, several use-cases, and an illustration of three of the use-cases through the application of 3 specific tools on Bugs. jar, namely our own tool, Elixir, and two third-party tools, Ekstazi and JaCoCo.", "num_citations": "84\n", "authors": ["71"]}
{"title": "Delta-net: Real-time network verification using atoms\n", "abstract": " Real-time network verification promises to automatically detect violations of network-wide reachability invariants on the data plane. To be useful in practice, these violations need to be detected in the order of milliseconds, without raising false alarms. To date, most real-time data plane checkers address this problem by exploiting at least one of the following two observations:(i) only small parts of the network tend to be affected by typical changes to the data plane, and (ii) many different packets tend to share the same forwarding behaviour in the entire network. This paper shows how to effectively exploit a third characteristic of the problem, namely: similarity among forwarding behaviour of packets through parts of the network, rather than its entirety. We propose the first provably amortized quasi-linear algorithm to do so. We implement our algorithm in a new real-time data plane checker, Delta-net. Our experiments with SDN-IP, a globally deployed ONOS software-defined networking application, and several hundred million IP prefix rules generated using topologies and BGP updates from real-world deployed networks, show that Delta-net checks a rule insertion or removal in approximately 40 microseconds on average, a more than 10x improvement over the state-of-the-art. We also show that Delta-net eliminates an inherent bottleneck in the state-of-the-art that restricts its use in answering Datalog-style \u201cwhat if\u201d queries.", "num_citations": "65\n", "authors": ["71"]}
{"title": "Domino logic synthesis and technology mapping\n", "abstract": " 2 \u96fb\u6e90\u7cfb\u7d71\u30c0\u30a4\u30ca\u30df\u30c3\u30af CMOS \u30bb\u30eb\u306e\u56de\u8def\u3068\u30ec\u30a4\u30a2\u30a6\u30c8\u306e\u6700\u9069\u5316 I: \u30c9\u30df\u30ce CMOS \u300c\u6e96\u30b9\u30bf\u30f3\u30c0\u30fc\u30c9\u30fb\u30bb\u30eb\u300d \u30ec\u30a4\u30a2\u30a6\u30c8", "num_citations": "64\n", "authors": ["71"]}
{"title": "Technique for efficient parallelization of software analysis in a distributed computing environment through intelligent dynamic load balancing\n", "abstract": " A method for verifying software includes monitoring a resource queue and a job queue, determining whether the resource queue and the job queue contain entries, and if both the resource queue and the job queue contain entries, then applying a scheduling policy to select a job, selecting a worker node as a best match for the characteristics of the job among the resource queue entries, assigning the job to the worker node, assigning parameters to the worker node for a job creation policy for creating new jobs in the job queue while executing the job, and assigning parameters to the worker node for a termination policy for halting execution of the job. The resource queue indicates worker nodes available to verify a portion of code. The job queue indicates one or more jobs to be executed by a worker node. A job includes a portion of code to be verified.", "num_citations": "39\n", "authors": ["71"]}
{"title": "Using symbolic execution to check global temporal requirements in an application\n", "abstract": " In one embodiment, a method include accessing one or more global temporal requirements of an application specified using one or more requirement templates from a library of requirement templates, accessing a model of the application, generating one or more symbolic expressions of one or more of the global temporal requirements of the application, searching a state space of the application model with a model checker, monitoring the search of the state space for events in the state space encompassed by the symbolic expressions and modifying construction of a graph of the state space in response to occurrence of one or more events encompassed by the symbolic expressions, evaluating the symbolic expressions based on the graph of the state space to determine whether one or more of the global temporal requirements are valid, and communicating one or more results of the evaluation of the symbolic\u00a0\u2026", "num_citations": "39\n", "authors": ["71"]}
{"title": "Facilitating automated validation of a web application\n", "abstract": " In one embodiment, a method includes accessing one or more document object model (DOM) representations of one or more pages of a Web application that comprises one or more instances of a web-application artifact. For each of one or more of the instances, the method also includes identifying a first set of one or more DOM elements in one of the DOM representations of one of the pages that collectively correspond to the instance. The method additionally includes identifying a second set of one or more particular values of one or more particular attributes of one or more particular ones of the DOM elements in the first sets. The second set may then be mapped to the web-application artifact to provide a DOM definition of the web-application artifact.", "num_citations": "38\n", "authors": ["71"]}
{"title": "X-PERT: a web application testing tool for cross-browser inconsistency detection\n", "abstract": " Web applications are popular among developers because of the ease of development and deployment through the ubiquitous web browsing platform. However, differences in a web application's execution across different web browsers manifest as Cross-browser Inconsistencies (XBIs), which are a serious concern for web developers. Testing for XBIs manually is a laborious and error-prone process. In this demo we present X-PERT, which is a tool to identify XBIs in web applications automatically, without requiring any effort from the developer. X-PERT implements a comprehensive technique to identify XBIs and has been found to be effective in detecting real-world XBIs in our empirical evaluation. The source code of X-PERT and XBI reports from our evaluation are available at http://gatech. github. io/xpert.", "num_citations": "33\n", "authors": ["71"]}
{"title": "Phoenix: Automated data-driven synthesis of repairs for static analysis violations\n", "abstract": " Traditional automatic program repair (APR) tools rely on a test-suite as a repair specification. But test suites even when available are not of specification quality, limiting the performance and hence viability of test-suite based repair. On the other hand, static analysis-based bug finding tools are seeing increasing adoption in industry but still face challenges since the reported violations are viewed as not easily actionable. We propose a novel solution that solves both these challenges through a technique for automatically generating high-quality patches for static analysis violations by learning from examples. Our approach uses the static analyzer as an oracle and does not require a test suite. We realize our solution in a system, Phoenix, that implements a fully-automated pipeline that mines and cleans patches for static analysis violations from the wild, learns generalized executable repair strategies as programs in a\u00a0\u2026", "num_citations": "31\n", "authors": ["71"]}
{"title": "Verification techniques for system-level design\n", "abstract": " This book will explain how to verify SoC (Systems on Chip) logic designs using \u201cformal and \u201csemiformal verification techniques. The critical issue to be addressed is whether the functionality of the design is the one that the designers intended. Simulation has been used for checking the correctness of SoC designs (as in \u201cfunctional verification), but many subtle design errors cannot be caught by simulation. Recently, formal verification, giving mathematical proof of the correctness of designs, has been gaining popularity. For higher design productivity, it is essential to debug designs as early as possible, which this book facilitates. This book covers all aspects of high-level formal and semiformal verification techniques for system level designs.\u2022 First book that covers all aspects of formal and semiformal, high-level (higher than RTL) design verification targeting SoC designs.\u2022 Formal verification of high-level designs (RTL or higher).\u2022 Verification techniques are discussed with associated system-level design methodology.", "num_citations": "31\n", "authors": ["71"]}
{"title": "Client-tier validation of dynamic web applications\n", "abstract": " In one embodiment, a method includes accessing and crawling a dynamic web application that comprises a client tier. In one embodiment, the crawling includes one or more instances of guided crawling that each initiate when a preceding instance of automatic crawling reaches a state in the dynamic web application that meets one or more predetermined criteria for the instance of guided crawling and, when initiated, perform one or more predetermined actions with respect to the dynamic web application. The method further includes generating, based on the crawling, a screen transition model of the dynamic web application. In a particular embodiment, the screen transition model includes a hierarchical finite state machine (FSM). In one embodiment, after the generation of the screen transition model has completed, the method further includes performing model checking on the screen transition model to validate\u00a0\u2026", "num_citations": "30\n", "authors": ["71"]}
{"title": "Validating one or more circuits using one of more grids\n", "abstract": " In one embodiment, a method for validating one or more circuits using one or more grids includes accessing a circuit and generating one or more seeds for executing one or more instances of validation on the circuit. Each instance of validation comprising one or more tasks. The method also includes distributing the tasks and the seeds across a grid including multiple nodes and, using the seeds, executing the instances of validation at the nodes in the grid according to the tasks.", "num_citations": "29\n", "authors": ["71"]}
{"title": "Web service for automated cross-browser compatibility checking of web applications\n", "abstract": " One embodiment presents a user interface to a first user, the user interface being configured to enable the first user to provide user input that: specifies a first web application, and a behavior exploration specification, a plurality of web browsers, and a set of comparison rules for the first web application; requests a plurality of models to be constructed with respect to the web browsers for the first web application based on the behavior exploration specification; requests the models of the first web application to be compared with each other based on the set of comparison rules; and requests one or more results of the comparison performed on the models of the first web application to be presented; and in response to each user input received from the first user, performs one or more operations for the first user.", "num_citations": "28\n", "authors": ["71"]}
{"title": "System and Method for Providing Symbolic Execution Engine for Validating Web Applications\n", "abstract": " In accordance with a particular embodiment of the present invention, a method is offered that includes generating a symbolic string manipulation class library for one or more web applications. The manipulations are generalized into a string manipulation symbolic algebra. The method also includes performing symbolic execution for one or more web applications. Typically, a Java model checker is augmented to check for certain types of requirements or properties in performing the symbolic execution. If an error scenario exists, a solution to a set of symbolic constraints is obtained, and the solution is mapped back to a source code to obtain an error trace and a test case. In still other specific embodiments, requirements or properties are encoded through templates and checked using public domain decision procedures. The properties or requirements can relate to security validation. The symbolic execution can be\u00a0\u2026", "num_citations": "27\n", "authors": ["71"]}
{"title": "System and method for verifying a digital design using dynamic abstraction\n", "abstract": " A method for verifying a digital system design is provided. A first abstraction of a digital system design is performed to obtain an abstract model of the digital system design. One or more first steps of a multiple-step model checking process are performed using the abstract model, the multiple-step model checking process being operable to verify the digital system design. During the multiple-step model checking process, a second abstraction is performed to refine the abstract model. One or more second steps of the multiple-step model checking process are then performed using the refined abstract model.", "num_citations": "27\n", "authors": ["71"]}
{"title": "Cross-platform feature matching for web applications\n", "abstract": " With the emergence of new computing platforms, software written for traditional platforms is being re-targeted to reach the users on these new platforms. In particular, due to the proliferation of mobile computing devices, it is common practice for companies to build mobile-specific versions of their existing web applications to provide mobile users with a better experience. Because the differences between desktop and mobile versions of a web application are not only cosmetic, but can also include substantial rewrites of key components, it is not uncommon for these different versions to provide different sets of features. Whereas some of these differences are intentional, such as the addition of location-based features on mobile devices, others are not and can negatively affect the user experience, as confirmed by numerous user reports and complaints. Unfortunately, checking and maintaining the consistency of different\u00a0\u2026", "num_citations": "24\n", "authors": ["71"]}
{"title": "Methods and systems for test automation of forms in web applications\n", "abstract": " A method includes accessing a page of Web application that includes an interactive form having at least one field for entry of data, the interactive form rendered by the Web application based on code for the interactive form. The method also includes extracting input validation code from the code, the input validation code including at least one constraint on data entered into the at least one field. The method additionally includes extracting the at least one constraint based on an analysis of the input validation code and solving, for the at least one field, for a string value based at least on the at least one constraint for the at least one field. The also includes automatically entering, into the at least one field, the string value. The method additionally includes automatically submitting the interactive form, including the string value entered into the at least one field.", "num_citations": "21\n", "authors": ["71"]}
{"title": "Estimating the difficulty level of a formal verification problem\n", "abstract": " Estimating the difficulty level of a verification problem includes receiving input comprising a design and properties that may be verified on the design. Verification processes are performed for each property on the design. A property verifiability metric value is established for each property in accordance with the verification processes, where a property verifiability metric value represents a difficulty level of verifying the property on the design. A design verifiability metric value is determined from the property verifiability metric values, where the design verifiability metric value represents a difficulty level of verifying the design.", "num_citations": "18\n", "authors": ["71"]}
{"title": "Using problem symmetry in search based satisfiability algorithms\n", "abstract": " We introduce the notion of problem symmetry in search-based SAT algorithms. We develop a theory of essential points to formally characterize the potential search-space pruning that can be realized by exploiting problem symmetry. We unify several search-pruning techniques used in modern SAT solvers under a single framework, by showing them to be special cases of the general theory of essential points. We also propose a new pruning rule exploiting problem symmetry. Preliminary experimental results validate the efficacy of this rule in providing additional search-space pruning beyond the pruning realized by techniques implemented in leading-edge SAT solvers.", "num_citations": "17\n", "authors": ["71"]}
{"title": "FSX: fine-grained incremental unit test generation for C/C++ programs\n", "abstract": " Automated unit test generation bears the promise of significantly reducing test cost and hence improving software quality. However, the maintenance cost of the automatically generated tests presents a significant barrier to adoption of this technology. To address this challenge, we propose a novel technique for automated and fine-grained incremental generation of unit tests through minimal augmentation of an existing test suite. The technique uses iterative, incremental refinement of test-drivers and symbolic execution, guided by a diagnostics engine. The diagnostics engine works off a novel precise and efficient byte-level dynamic dependence analysis built using Reduced Ordered Binary Decision Diagrams (ROBDDs). We present a tool FSX implementing this technique and evaluate it under two practical use-cases of incremental unit test generation, on five revisions of the open-source software iPerf, as well as\u00a0\u2026", "num_citations": "16\n", "authors": ["71"]}
{"title": "Incremental visual comparison of web browser screens\n", "abstract": " A method, media, and systems for performing incremental visual comparison of web browser screens are provided. Structured representations of a current state of an event-driven application are accessed, one with respect to a plurality of client-tier environments. Where the current state is not an initial state of the event-driven application, structured representations of a prior state of the event-driven application are accessed, with respect to each client-tier environment. A set of one or more pairwise equivalences between the current state and the prior state of the event-driven application are determined with respect to each client-tier environment. A set of one or more matched portions between the first and second sets of pairwise equivalences is determined. Finally, one or more differences in a first end-user experience in the first client-tier environment are determined with respect to a second end-user experience in\u00a0\u2026", "num_citations": "16\n", "authors": ["71"]}
{"title": "Weave: Web applications validation environment\n", "abstract": " Ensuring software quality in the presence of multiple software development methodologies such as agile and waterfall models is a challenging task. Web applications are released to customers in ldquoBetardquo mode due to tremendous pressure on ldquotime-to-marketrdquo. In order to check end-to-end functional behavior of web applications, conventional testing tools have not matched short release cycles and have not kept up with agile software methodologies. In this paper we present a tool framework called WEb Applications Validation Environment (WEAVE) for checking functional behavior such as business logic and security of web applications. We have used WEAVE for finding defects in large Javacentric commercial-strength Web applications. As part of WEAVE, we have developed (1) a semi-automatic method for environment generation to constrain the behavior of the application for scalability, (2) an\u00a0\u2026", "num_citations": "16\n", "authors": ["71"]}
{"title": "Solving the latch mapping problem in an industrial setting\n", "abstract": " We describe a complete method for the latch mapping problem that is based on the efficient integration of previously proposed techniques for latch mapping as well as novel optimizations for further improvement. The highlights of the proposed approach include a new method of integrating complete methods and incomplete methods for latch mapping, the use of incremental reasoning to optimize the overall algorithm and the use of a conventional combinational equivalence checking tool as the core engine. Experiments confirm that the proposed method retains much of the efficiency and capacity of incomplete methods while providing the completeness of complete methods and derives significant performance improvements from the proposed optimizations.", "num_citations": "16\n", "authors": ["71"]}
{"title": "Layout-driven logic optimization\n", "abstract": " With the advent of deep sub-micron technologies interconnect loads and delays are becoming dominant. Conse\u00d5uently the currently used design flow of iteratively performing logic synthesis with statistical wire-load models doing placement & routing extracting parasitics and using them back in the synthesis tool runs into serious timing convergence problems. In this paper we propose a new paradigm for solving the timing convergence problem. It includes a modified design flow in which logic optimization is interleaved with placement/partitioning refinement and hierarchical global routing. The optimization incorporates a comprehensive set of layout-friendly logic-level transforms for improving the delay and area of a mapped block-placed and globally routed circuit under design and technology constraints. We have implemented this methodology in an industrial-strength design tool and provide empirical evidence of its efficacy on large industrial designs.", "num_citations": "16\n", "authors": ["71"]}
{"title": "Technique for stateless distributed parallel crawling of interactive client-server applications\n", "abstract": " A distributed computing system includes worker nodes and a master node including a processor coupled to a memory. Each worker node crawls a portion of an interactive client-server application. The memory includes a master state graph, including the results of crawling. The master node is configured to examine the master state graph to determine a number of reconverging traces, receive a result from a job from a worker node if the number of reconverging traces is below a threshold, and add the result to the master state graph without attempting to remove duplicate states or transitions. A trace includes states and transitions representing valid. A reconvergent trace includes a trace including a reconvergent state, which is a state that can be reached through two or more distinct traces. The result containing states and transitions is associated with crawling a first portion of the interactive client-server application.", "num_citations": "15\n", "authors": ["71"]}
{"title": "Generating software application user-input data through analysis of client-tier source code\n", "abstract": " In one embodiment, analyze client-tier source code of a client-server software application to extract one or more software modules that handle user-input data of the software application. For each one of the software modules, extract from the software module one or more user-input constraints placed on the user-input data, comprising: analyze source code of the software module to determine one or more failure points in the source code; perform symbolic execution on the software module to extract one or more first expressions that cause the software module to reach the failure points, respectively; obtain a second expression as the disjunction of all the first expressions; obtain a third expression as the negation of the second expression; and extract the user-input constraints from the third expression. Determine one or more user-input data that satisfy all the user-input constraints.", "num_citations": "15\n", "authors": ["71"]}
{"title": "Verifying one or more properties of a design using SAT-based BMC\n", "abstract": " In one embodiment, a method for satisfiability (SAT)-based bounded model checking (BMC) includes isolating information learned from a first iteration of an SAT-based BMC process and applying the isolated information from the first iteration of the SAT-based BMC process to a second iteration of the SAT-based BMC process subsequent to the first iteration.", "num_citations": "15\n", "authors": ["71"]}
{"title": "Using machine learning to improve detection of visual pairwise differences between browsers\n", "abstract": " In some embodiments, information associated with a first plurality of image pairs is received. Each image pair is assessed to detect visual pairwise differences that qualify as an error. A visual pairwise difference may be a difference with respect to at least one of position, size, color, or style. A prediction engine is trained based upon the assessed visual pairwise differences. Information associated with a second plurality of image pairs is received. Each of these image pairs comprises at least a portion of a visual end-user experience screen of an event-driven application executed in a client-tier environment. Each of these image pairs is assessed, using the prediction engine, to detect visual pairwise differences that qualify as an error. User feedback is received, indicating that at least one assessed pairwise difference should not have qualified as an error. The prediction engine is then re-trained based on the user\u00a0\u2026", "num_citations": "14\n", "authors": ["71"]}
{"title": "Scheduling events in a boolean satisfiability (SAT) solver\n", "abstract": " In one embodiment, a method for scheduling events in a Boolean satisfiability (SAT) solver includes collecting one or more first-order statistics on a search for a valid solution to an SAT problem, deriving one or more second-order statistics on the search from the one or more first-order statistics, and scheduling events in the search according to one or more of the second-order statistics.", "num_citations": "13\n", "authors": ["71"]}
{"title": "System and method for detecting software defects\n", "abstract": " A method for detecting software defects includes selecting from a target program comprising a plurality of modules a first module for evaluation and isolating the first module. The method also includes iteratively performing the following steps until the first module has been reduced such that a validation program is able to determine whether the first module contains a defect: generating an environment surrounding the first module, the generated environment preserving at least one external constraint on the first module; reducing the size of the first module; and reducing the number of program states associated with the first module.", "num_citations": "12\n", "authors": ["71"]}
{"title": "Performing latch mapping of sequential circuits\n", "abstract": " Performing latch mapping includes receiving an initial circuit model representing a first circuit and a second circuit and generating an initial latch mapping for the initial circuit model. The following is repeated until a next latch mapping is at least similar to a current latch mapping to yield a final latch mapping. A current circuit model is constructed according to a previous circuit model. Current potentially equivalent node sets associated with the current circuit model are established in accordance with previous potentially equivalent node sets, where each potentially equivalent node set includes potentially equivalent nodes. Equivalence of the current potentially equivalent node sets is validated, and a current latch mapping is verified in accordance with the validated current potentially equivalent node sets to generate a next latch mapping. The final latch mapping is reported.", "num_citations": "12\n", "authors": ["71"]}
{"title": "A new voting based hardware data prefetch scheme\n", "abstract": " The dramatic increase in the processor memory gap in recent years has led to the development of techniques like data prefetching that hide the latency of cache misses. Two such hardware techniques are the stream buffer and the stride predictor. They have dissimilar architectures, are effective for different kinds of memory access patterns and require different amounts of extra memory bandwidth. We compare the performance of these two techniques and propose a scheme that unifies them. Simulation studies on six benchmark programs confirm that the combined scheme is more effective in reducing the average memory access time (AMAT) than either of the two individually.", "num_citations": "12\n", "authors": ["71"]}
{"title": "Technique for compression of state information in the crawling of interactive client-server applications\n", "abstract": " An electronic device includes a memory including a state graph, and a processor coupled to the memory. The state graph includes a plurality of states of an interactive client-server application to be crawled. Te plurality of states and transitions result from the crawling of the client-server application. The plurality of states includes an initial state and a second state. The initial state includes one or more initial state nodes. The second state includes one or more second state nodes. The processor is configured to determine the differences between the initial state and the second state and compress the second state with respect to the initial state using the differences, resulting in a compressed state.", "num_citations": "11\n", "authors": ["71"]}
{"title": "Automated system testing of dynamic web applications\n", "abstract": " Web applications pervade all aspects of human activity today. Rapid growth in the scope, penetration and user-base of web applications, over the past decade, has meant that web applications are substantially bigger, more complex and sophisticated than ever before. This places even more demands on the validation process for web applications. This paper presents an automated approach for the system testing of modern, industrial strength dynamic web applications, where a combination of dynamic crawling-based model generation and back-end model checking is used to comprehensively validate the navigation behavior of the web application. We present several case studies to validate the proposed approach on real-world web applications. Our evaluation demonstrates that the proposed approach is not only practical in the context of applications of such size and complexity but can provide greater\u00a0\u2026", "num_citations": "11\n", "authors": ["71"]}
{"title": "Software program repair\n", "abstract": " According to an aspect of an embodiment, one or more systems or methods may be configured to locate a fault in a software program using a test suite. The systems or methods may be further configured to modify, using a repair template, the software program in response to locating the fault. In addition, the systems or methods may be configured to determine whether the modification satisfies an anti-pattern condition. The anti-pattern condition may indicate whether the modification is improper. The systems or methods may also be configured to disallow the modification in response to the modification satisfying the anti-pattern condition or perform further testing on the software program, as modified, in response to the modification not satisfying the anti-pattern condition.", "num_citations": "10\n", "authors": ["71"]}
{"title": "Software regression testing using symbolic execution\n", "abstract": " A method of testing software may include accessing first software that includes multiple execution paths and concretely executing the first software using a test case associated with second software to traverse at least a first execution path of the execution paths. The method may also include capturing concrete execution results produced from concretely executing the first software to record the first execution path and symbolically executing the first software using a symbolic input based on the recorded first execution path.", "num_citations": "10\n", "authors": ["71"]}
{"title": "Propositional Satisfiability Algorithms in EDA Applications\n", "abstract": " Recent years have seen a dramatic growth in the application of SAT solvers to problems in electronic design automation. This trend is due in part to recent developments in SAT algorithms which have revolutionized the field of satisfiability testing. SAT has grown from a problem of academic interest to a core computational resource of immense value.", "num_citations": "10\n", "authors": ["71"]}
{"title": "Detection of cross-platform differences of web applications\n", "abstract": " A method for detecting a cross-platform difference of a web application may include generating a first relative layout model based on a first relationship between multiple elements of a screen of a web application when the web application is executed on a first platform. The method may further include generating a second relative layout model based on a second relationship between the multiple elements of the screen of the web application when the web application is executed on a second platform. The method may also include determining a difference between the first relationship and the second relationship based on a comparison of the first relative layout model with respect to the second relative layout model.", "num_citations": "9\n", "authors": ["71"]}
{"title": "Architecture for distributed, parallel crawling of interactive client-server applications\n", "abstract": " In one embodiment, a distributed computing system includes a first worker node configured to execute a first job, a second worker node configured to execute a second job, and a master node including a processor coupled to a memory. The first job indicates a first portion of an interactive client-server application to be crawled. The second job indicates a second portion of an interactive client-server application to be crawled. The second worker node and the first worker node are configured to execute their respective jobs in parallel. The second job indicates a second portion of an interactive client-server application to be crawled. The master node is configured to assign the first job to the first worker node, assign the second job to the second worker node, and integrate the results from the first worker node and the second worker node into a record of operation of the application.", "num_citations": "9\n", "authors": ["71"]}
{"title": "Scheduling policy for efficient parallelization of software analysis in a distributed computing environment\n", "abstract": " A method for verifying software includes accessing a job queue, accessing a resource queue, and assigning a job from the job queue to a resource from the resource queue if an addition is made to the a job queue or to a resource queue. The job queue includes an indication of one or more jobs to be executed by a worker node, each job indicating a portion of a code to be verified. The resource queue includes an indication of a one or more worker nodes available to verify a portion of software. The resource is selected by determining the best match for the characteristics of the selected job among the resources in the resource queue.", "num_citations": "9\n", "authors": ["71"]}
{"title": "Node computation initialization technique for efficient parallelization of software analysis in a distributed computing environment\n", "abstract": " A method for verifying software includes determining an initialization path condition of a received software verification job, determining a termination path condition of a computing node, and initializing the execution of the received software verification job on the computing node based on the initialization path condition and the termination path condition. The initialization path condition includes a sequence of program predicates for reaching a starting state of software to be verified. The received software verification job includes an indication of a portion of the software to be verified. The termination path condition includes an indication of the last state reached during the execution of a previous software verification job on the computing node. The computing node is assigned to execute the received software verification job.", "num_citations": "9\n", "authors": ["71"]}
{"title": "Providing software validation as a service\n", "abstract": " In one embodiment, a method includes accessing an event-driven application input by a user, the event-driven application comprising source code, one or more use cases input by the user for the event-driven application, and one or more functional requirements input by the user for the event-driven application; parsing the use cases and the functional requirements according to the predefined syntax to construct one or more validation modules for validating the event-driven application without any modification to the source code of the event-driven application for validation purposes; formally validating the event-driven application using the validation modules without relying on assertions inserted into the source code of the event-driven application for validation purposes; and if the formal validation finds one or more defects in the event-driven application, generating output for communication to the user identifying\u00a0\u2026", "num_citations": "9\n", "authors": ["71"]}
{"title": "Error detection using BMC in a parallel environment\n", "abstract": " In this paper, we explore a parallelization of BMC based on state space partitioning. The parallelization is accomplished by executing multiple instances of BMC independently from di.erent seed states. These seed states are deep states, selected from the reachable states in different partitions. In this scheme, all processors work independently of each other, thus it is suitable for scaling verification to a grid-like network. Our experimental results demonstrate improvement over existing approaches, and show that the method can scale to a large network.", "num_citations": "9\n", "authors": ["71"]}
{"title": "Automatically extracting a model for the behavior of a mobile application\n", "abstract": " A method of modeling behavior of a mobile application includes determining an action associated with the mobile application based on source code of the mobile application. The method further includes dynamically crawling through the mobile application based on the action and generating a graphical user interface (GUI) behavioral model based on dynamically crawling through the mobile application.", "num_citations": "8\n", "authors": ["71"]}
{"title": "Machine learning based software program repair\n", "abstract": " According to an aspect of an embodiment, a method may include identifying a fault location in a software program using a test suite. The method may further include determining, using machine learning, a repair effectiveness indication that indicates a potential effectiveness of performing a potential repair operation at the fault location. In addition, the method may include prioritizing implementing a repair at the fault location based on the repair effectiveness indication. The method may further include performing repair operations with respect to the software program based on the prioritization of the fault location.", "num_citations": "8\n", "authors": ["71"]}
{"title": "A precise and expressive lattice-theoretical framework for efficient network verification\n", "abstract": " Network verification promises to detect errors, such as black holes and forwarding loops, by logically analyzing the control or data plane. To do so efficiently, the state-of-the-art (e.g., Veriflow) partitions packet headers with identical forwarding behavior into the same packet equivalence class (PEC).Recently, Yang and Lam showed how to construct the minimal set of PECs, called atomic predicates. Their construction uses Binary Decision Diagrams (BDDs). However, BDDs have been shown to incur significant overhead per packet header bit, performing poorly when analyzing large-scale data centers. The overhead of atomic predicates prompted ddNF to devise a specialized data structure of Ternary Bit Vectors (TBV) instead.However, TBVs are strictly less expressive than BDDs. Moreover, unlike atomic predicates, ddNF's set of PECs is not minimal. We show that ddNF's non-minimality is due to empty PECs. In\u00a0\u2026", "num_citations": "7\n", "authors": ["71"]}
{"title": "Textual similarity based software program repair\n", "abstract": " According to an aspect of an embodiment, a method may include identifying a fault at a fault location in a software program using a test suite. The method may also include determining multiple textual similarity scores by determining a textual similarity score with respect to each of multiple repair candidates for the fault. In addition, the method may include sorting the repair candidates based on the textual similarity scores. The method may also include selecting a particular repair candidate from the repair candidates based on the sorting. Moreover, the method may include implementing the particular repair candidate at the fault location based on the selection of the particular repair candidate.", "num_citations": "7\n", "authors": ["71"]}
{"title": "Detection of dead widgets in software applications\n", "abstract": " In one embodiment, a user interface includes at least one instance of each of at least one widget. Recording a plurality of widget interaction instances (WIIs) for the user interface, each WII resulting from a user interaction applied to a particular instance of a particular widget. Clustering the plurality of WIIs based on a text value and a path value of each WII, such that each cluster of WIIs is associated with a particular widget. Determining, for each of at least one cluster of WIIs, whether the particular widget associated with the cluster of WIIs is erroneous based on whether user interactions corresponding to the WIIs in the cluster have produced responses from a software application that includes the user interface.", "num_citations": "7\n", "authors": ["71"]}
{"title": "Technique for coordinating the distributed, parallel crawling of interactive client-server applications\n", "abstract": " An electronic device includes a memory and a processor coupled to the memory. The memory contains a master state graph. The master state graph includes information regarding the operation of interactive client-server application. The processor is configured to send a first job to a first worker node, send a second job to a second worker node, receive results of crawling the interactive client-server application, and integrate results of crawling the interactive client-server application into the master state graph. The first job includes crawling instructions for crawling a first portion of an interactive client-server application. The second job includes crawling instructions for crawling a second portion of the interactive client-server application. The first worker node and second worker node crawl the interactive client-server application in parallel.", "num_citations": "7\n", "authors": ["71"]}
{"title": "System and method for providing middleware for capture of global requirements and validation for web applications\n", "abstract": " In accordance with a particular embodiment of the present invention, a method is offered that includes supporting requirement validation middleware and capturing global requirements or properties for one or more web applications. A template-based formalism is employed to capture the requirements or properties. A small set of relevant temporal patterns are provided from which to choose in capturing the global requirements or properties. In specific embodiments, the method uses a set of pre-coded semi-configurable checkers. A Java-like syntax is used to specify expressions. A library of atomic entities or events (to compose expressions) is automatically generated. In still other embodiments, a small set of light-weight automatically-customizable checkers are employed in capturing the global requirements or properties. The method can be used with both formal and semi-formal techniques.", "num_citations": "7\n", "authors": ["71"]}
{"title": "Virtual optical network provisioning based on mapping choices and patterns\n", "abstract": " Virtual optical network (VON) provisioning using implicit encoding of mapping constraints may include evaluating mapping choices to exclude certain mapping patterns before evaluating the mapping patterns. For each virtual node in a VON request, candidate physical nodes may be assigned and evaluated for compliance with constraints associated with the VON request. The constraints may be expanded to allow for various selection criteria for the VON request. Multiple VON requests may be simultaneously evaluated to find optimal solutions for the physical network.", "num_citations": "6\n", "authors": ["71"]}
{"title": "Dynamic and intelligent partial computation management for efficient parallelization of software analysis in a distributed computing environment\n", "abstract": " A method for verifying software includes determining the result of a bounding function, and using the result of the bounding function to apply one or more policies to the execution of the received job. The bounding function evaluates the execution of a received job, the received job indicating a portion of software to be verified. The result of the bounding function is based upon the present execution of the received job, one or more historical parameters, and an evaluation of the number of idle nodes available to process other jobs.", "num_citations": "6\n", "authors": ["71"]}
{"title": "Efficient partial execution for the parallelization of software analysis in a distributed computing environment\n", "abstract": " An electronic device includes a memory, a processor coupled to the memory, and one or more policies stored in the memory. The policies include a resource availability policy determining whether the processor should continue evaluating the software, and a job availability policy determining whether new jobs will be created for unexplored branches. The processor is configured to receive a job to be executed, evaluate the software, select a branch to explore and store an initialization sequence of one or more unexplored branches if a branch in the software is encountered, evaluate the job availability policy, decide whether to create a job for each of the unexplored branches based on the job availability policy, evaluate the resource availability policy, and decide whether to continue evaluating the software at the branch selected to explore based on the resource availability policy. The job indicates of a portion of\u00a0\u2026", "num_citations": "6\n", "authors": ["71"]}
{"title": "Extracting training scenarios from test cases for user-interface component recognition\n", "abstract": " In one embodiment, a method includes accessing a set of use cases of a software application and selecting, from the set of use cases, a subset of use cases that has a goodness-to-cost ratio that satisfies a predetermined requirement. Computing the goodness-to-cost ratio for the subset of use cases includes: for each use case from the subset of use cases, computing a second cost as a sum of the first costs associated with the user actions of the use case; computing a third cost as a sum of the second costs; for each user-interface component that is acted upon by at least one of the user actions of at least one of the use cases from the subset of use cases, computing a first goodness measure that indicates a level of user-action coverage that the subset of use cases provides on the user-interface component; computing a second goodness measure as a sum of the first goodness measures; and computing the goodness\u00a0\u2026", "num_citations": "6\n", "authors": ["71"]}
{"title": "Configurable Web Services System and a Method to Detect Defects in Software Applications\n", "abstract": " In accordance with a particular embodiment of the present invention, a method is offered that includes detecting one or more defects in a software application composed of heterogeneous languages using a configurable web services architecture. The detecting step further includes: capturing use cases associated with the software application and checking their validity; providing an automatic invocation of property monitors for model checking; and visualizing one or more defects in the software application for diagnosis. The detecting can further include transforming a heterogeneous software application into a homogeneous application. In more specific embodiments, the detecting further includes providing an automatic test generation for a presentation layer associated with the software application. The configuration associated with the software application can be a simple properties file. The detecting further\u00a0\u2026", "num_citations": "6\n", "authors": ["71"]}
{"title": "Network verification\n", "abstract": " A network verification method may include identifying a data plane including one or more forwarding tables for each switch of a plurality of switches in the data plane. The method may also include generating a forwarding behavior representation of the data plane to represent Boolean combinations of forwarding rules of the one or more forwarding tables of the data plane. Further, the method may include comparing the forwarding behavior representation of the data plane to one or more network properties to detect one or more errors in the data plane.", "num_citations": "5\n", "authors": ["71"]}
{"title": "Constructing event sequences in event-driven programs\n", "abstract": " A method of constructing a target event handler sequence from an end target in an event-driven program may include determining a variable to be read in a first event handler of multiple event handlers in the event-driven program. Each of the event handlers may include portions of code within the event-driven program. The method may also include determining a condition in the first event handler that is associated with the variable and determining multiple second event handlers of the event handlers that are configured to write to the variable. The method may also include pruning the second event handlers based on which of the second event handlers are configured to write a value to the variable that satisfies the condition.", "num_citations": "5\n", "authors": ["71"]}
{"title": "Synchronization scheme for distributed, parallel crawling of interactive client-server applications\n", "abstract": " A method for synchronizing a state graph includes generating a partial state graph by executing a crawling task to crawl an interactive client-server application, transmitting the partial state graph from a first electronic device to a second electronic device, and transmitting the partial state graph on a periodic basis. The partial state graph includes one or more new states of the interactive client-server application identified while crawling the interactive client-server application since a previous transmission.", "num_citations": "5\n", "authors": ["71"]}
{"title": "Recommending stack overflow posts for fixing runtime exceptions using failure scenario matching\n", "abstract": " Using online Q&A forums, such as Stack Overflow (SO), for guidance to resolve program bugs, among other development issues, is commonplace in modern software development practice. Runtime exceptions (RE) is one such important class of bugs that is actively discussed on SO. In this work we present a technique and prototype tool called MAESTRO that can automatically recommend an SO post that is most relevant to a given Java RE in a developer's code. MAESTRO compares the exception-generating program scenario in the developer's code with that discussed in an SO post and returns the post with the closest match. To extract and compare the exception scenario effectively, MAESTRO first uses the answer code snippets in a post to implicate a subset of lines in the post's question code snippet as responsible for the exception and then compares these lines with the developer's code in terms of their\u00a0\u2026", "num_citations": "4\n", "authors": ["71"]}
{"title": "Automated software program repair candidate selection\n", "abstract": " According to an aspect of an embodiment, a method may identifying a fault location of a fault in a tested software program using a test suite and obtaining a repair candidate for the fault. In addition, the method may include obtaining a repair code pattern of the repair candidate and determining a number of occurrences of the repair code pattern in existing code of multiple existing software programs. Moreover, the method may include prioritizing the repair candidate as a repair of the tested software program based on the number of occurrences of the repair code pattern. The method may also include performing repair operations on the tested software program according to the prioritizing of the repair candidate.", "num_citations": "4\n", "authors": ["71"]}
{"title": "Elixir: An automated repair tool for java programs\n", "abstract": " Object-oriented (OO) languages, by design, make heavy use of method invocations (MI). Unsurprisingly, a large fraction of OO-program bug patches also involve method invocations. However, current program repair techniques incorporate MIs in very limited ways, ostensibly to avoid searching the huge repair space that method invocations afford. To address this challenge, in previous work, we proposed a generate-and-validate repair technique which can effectively synthesize patches from a repair space rich in method invocation expressions, by using a machine-learned model to rank the space of concrete repairs. In this paper we describe the tool Elixir that instantiates this technique for the repair of Java programs. We describe the architecture, user-interface, and salient features of Elixir, and specific use-cases it can be applied in. We also report on our efforts towards practical deployment of Elixir within our\u00a0\u2026", "num_citations": "4\n", "authors": ["71"]}
{"title": "Extracting a deterministic finite-state machine model of a GUI based application\n", "abstract": " A method of modeling a graphical user interface (GUI) based application as a deterministic finite-state machine may include generating dummy error state and a dummy error output in a finite-state machine. The method may further include modeling a response to an action that is unavailable on a screen of a graphical user interface (GUI) based application as a transition to the dummy error state in the finite-state machine while producing the dummy error output in the finite-state machine.", "num_citations": "4\n", "authors": ["71"]}
{"title": "Crawling for extracting a model of a GUI-based application\n", "abstract": " A method of crawling a graphical user interface (GUI) based application may include performing a first-time crawl of a first sequence of actions of the GUI-based application. The first-time crawl may be a first time that the first sequence of actions is crawled. Further, the first sequence of actions may be a prefix of a second sequence of actions that includes one or more additional actions than the first sequence of actions. The method may also include extending the first-time crawl by the one or more additional actions such that the second sequence of actions is crawled during the first-time crawl. Further, the method may include determining a first input/output sequence associated with the first sequence of actions based on the first-time crawl. Additionally, the method may include determining a second input/output sequence associated with the second sequence of actions based on the first-time crawl.", "num_citations": "4\n", "authors": ["71"]}
{"title": "Technique for efficient partial crawling of interactive client-server applications in a parallel, distributed environment\n", "abstract": " An electronic device includes a memory including a crawling application and a processor coupled to the memory. The processor is configured to execute the crawling application, which causes the processor to receive a job, crawl the interactive client-server application based on the initialization information until a boundary condition is reached, and report the results of crawling. The job contains initialization information indicating a portion of an interactive client-server application to be crawled. Crawling it includes programmatically determining possible actions available on a first state of the interactive client-server application, recording the first state, selecting an action, recording the actions not taken, taking the action, reaching a second state, recording the second state, and recording the action taken as a transition between the first state and the second state. Reporting the results of the interactive client-server\u00a0\u2026", "num_citations": "4\n", "authors": ["71"]}
{"title": "Why is combinational ATPG efficiently solvable for practical VLSI circuits?\n", "abstract": " Empirical observation shows that practically encountered instances of combinational ATPG are efficiently solvable. However, it has been known for more than two decades that ATPG is an NP-complete problem (Ibarra and Sahni, IEEE Transactions on Computers, Vol. C-24, No. 3, pp. 242\u2013249, March 1975). This work is one of the first attempts to reconcile these seemingly disparate results. We introduce the concept of cut-width of a circuit and characterize the complexity of ATPG in terms of this property. We introduce the class of log-bounded width circuits and prove that combinational ATPG is efficiently solvable on members of this class. The class of of log-bounded width circuits is shown to strictly subsume the class of k-bounded circuits introduced by Fujiwara (International Symposium on Fault-Tolerant Computing, June 1988, pp. 64\u201369). We provide empirical evidence which indicates that an interestingly\u00a0\u2026", "num_citations": "4\n", "authors": ["71"]}
{"title": "Representing software with an abstract code graph\n", "abstract": " According to an aspect of an embodiment, a method may include generating an abstract code graph (ACG). The method may include obtaining an abstract syntax tree (AST). The AST may include a first AST node that may represent a first construct at a first level of abstraction and a second AST node that may represent a second construct. The method may further include generating an ACG, based on the AST. The generating of ACG may include generating a first ACG node based on the first AST node and a second ACG node based on the second AST node. The generating of ACG may also include generating, based on the first ACG node, a third ACG node that represents the first construct at a second level of abstraction. The third ACG node may be connected between the first ACG node and the second ACG node based on the AST.", "num_citations": "3\n", "authors": ["71"]}
{"title": "Automated software program repair\n", "abstract": " According to an aspect of an embodiment, a method may include identifying a fault location of a fault in a software program using a test suite. The method may further include implementing, in the software program, a repair candidate for the fault. In addition, the method may include augmenting the test suite with a plurality of test oracles that are based on observed behavior of the software program and that correspond to the fault location. Moreover, the method may include running the augmented test suite with respect to the software program with the implemented repair candidate. The method may also include prioritizing the repair candidate as a repair of the software program based on a failure rate of the plurality of test oracles with respect to running the augmented test suite.", "num_citations": "3\n", "authors": ["71"]}
{"title": "Software program fault localization\n", "abstract": " According to an aspect of an embodiment, a method may include executing multiple tests with respect to code under test of a software program to perform multiple test executions. The method may further include identifying one or more passing tests and one or more failing tests of the test executions. In addition, the method may include determining an aggregated score for each statement based on two or more of: the passing tests and the failing tests; a semantic similarity between one or more statement tokens included in the respective statement and one or more report tokens included in an error report; and an amount of time that has passed from when the respective statement received a change. Moreover, the method may include identifying a particular statement of the plurality of statements as a fault location in the code under test based on the aggregated scores of the plurality of statements.", "num_citations": "2\n", "authors": ["71"]}
{"title": "FSX: a tool for fine-grained incremental unit test generation for C/C++ programs\n", "abstract": " Automated unit test generation bears the promise of significantly reducing test cost and hence improving software quality. However, the maintenance cost of the automatically generated tests presents a significant barrier to adoption of this technology. To address this challenge, in previous work, we proposed a novel technique for automated and fine-grained incremental generation of unit tests through minimal augmentation of an existing test suite. In this paper we describe a tool FSX, implementing this technique. We describe the architecture, user-interface, and salient features of FSX, and specific practical use-cases of its technology. We also report on a real, large-scale deployment of FSX, as a practical validation of the underlying research contribution and of automated test generation research in general.", "num_citations": "2\n", "authors": ["71"]}
{"title": "Scalable Virtual Optical Network Mapping over Software-Defined Flexible Grid Optical Networks\n", "abstract": " Software-defined flexible grid optical networks enable new revenue opportunities through delivery of virtual optical network (VON) services. This paper presents a scalable VON mapper for mapping large number of VON demands with different service attributes.", "num_citations": "2\n", "authors": ["71"]}
{"title": "Symbolic testing of software using concrete software execution\n", "abstract": " A method of testing software may include accessing software that includes multiple execution paths that each include one or more branching points. The method may also include concretely executing the software using multiple concrete inputs to traverse at least two of the execution paths of the software. The method may also include capturing concrete execution results produced from executing the software using the concrete inputs. The method may also include symbolically executing the software using one or more symbolic inputs based on the concrete execution results.", "num_citations": "2\n", "authors": ["71"]}
{"title": "Validating one or more circuits using one or more grids\n", "abstract": " In one embodiment, a method includes simulating by one or more computer systems a larger circuit to assign one or more values to one or more latch variables associated with the larger circuit, generating by the one or more computer systems one or more reduced circuits from the larger circuit according to the values assigned to the latch variables, generating by the one or more computer systems a transition relation (TR) for each reduced circuit, and generating by the one or more computer systems an initial state set for one or more instances of validation on the reduced circuits according to the TRs.", "num_citations": "2\n", "authors": ["71"]}
{"title": "High level design validation: current practices and future directions\n", "abstract": " This paper describes about the increasing complexity of VLSI design, time to market pressures. The two major paradigms to address the difficulties currently being faced by industry are: (1) the use of higher levels of design abstraction and (2) efficient and seamless design reuse. Current industrial practices and academic research in design verification and validation are also discussed.", "num_citations": "2\n", "authors": ["71"]}
{"title": "Satisfiability for ATPG: Is it easy?\n", "abstract": " It has been observed that SAT formulae derived from ATPG problems are e ciently solvable in practise. This seems counter-intuitive since SAT is known to be NP? Complete. This work seeks to explain this paradox. We identify a certain property of circuits which facilitates e cient solution of ATPG-SAT instances arising from them. In addition, we provide both theoretical proofs and empirical evidence to argue that a large fraction of practical VLSI circuits could be expected to have the said property.", "num_citations": "2\n", "authors": ["71"]}
{"title": "Dynamics of contamination of pork with Salmonella in a pork processing plant.\n", "abstract": " Nearly 2.43% of the pork examined was contaminated with Salmonella . A detailed longitudinal study which followed pigs from lairage through slaughter to production of pork was carried out. This comprised 217 samples taken from various sites and items in lairage, slaughter hall, pigs and carcasses. S. london was isolated from all except gall-bladder, bile and eviscerating knife. Salmonella was brought to lairage with contaminated feed and excretor pigs, and was spread in the slaughter hall contaminating equipment, workers' hands and also pork.", "num_citations": "2\n", "authors": ["71"]}
{"title": "Automated candidate repair patch generation\n", "abstract": " A method of automated candidate repair patch generation may include synthesizing repair expressions based on project code. Concise repair expressions may be mined from a code database. A set of repair expressions may be generated based on the synthesized repair expressions and the mined repair expressions. The set of repair expressions may include further repair expressions further synthesized from the synthesized repair expressions and the mined repair expressions. Candidate patches may be generated based on a repair schema and the set of repair expressions.", "num_citations": "1\n", "authors": ["71"]}
{"title": "Automated software program repair\n", "abstract": " According to an aspect of an embodiment, operations may include generating a first abstract syntax tree with respect to a first iteration of first source code of a first software program and generating a second abstract syntax tree with respect to a second iteration of the first source code. The operations may also include identifying a first sub-tree of the first abstract syntax tree and identifying a plurality of second sub-trees of the second abstract syntax tree. In addition the operations may include generating a first textual representation of the first sub-tree and generating a plurality of second textual representations with respect to the second sub-trees. Moreover, the operations may include modifying the second abstract syntax tree based on the second sub-trees and obtaining a third iteration of the first source code by regenerating the first source code based on the modified second abstract syntax tree.", "num_citations": "1\n", "authors": ["71"]}