{"title": "Foundations of genetic programming\n", "abstract": " Genetic programming (GP), one of the most advanced forms of evolutionary computation, has been highly successful as a technique for getting computers to automatically solve problems without having to tell them explicitly how. Since its inceptions more than ten years ago, GP has been used to solve practical problems in a variety of application fields. Along with this ad-hoc engineering approaches interest increased in how and why GP works. This book provides a coherent consolidation of recent work on the theoretical foundations of GP. A concise introduction to GP and genetic algorithms (GA) is followed by a discussion of fitness landscapes and other theoretical approaches to natural and artificial evolution. Having surveyed early approaches to GP theory it presents new exact schema analysis, showing that it applies to GP as well as to the simpler GAs. New results on the potentially infinite number of possible programs are followed by two chapters applying these new techniques.", "num_citations": "1184\n", "authors": ["541"]}
{"title": "Advances in genetic programming\n", "abstract": " Genetic programming, a form of genetic algorithm that evolves programs and program-like executable structures, is a new paradigm for developing reliable, time-and cost-effective applications. The second volume of Advances in Genetic Programming highlights many of the most recent technical advances in this increasingly popular field. The twenty-three contributions are divided into four parts: Variations on the Genetic Programming Theme; Hierarchical, Recursive, and Pruning Genetic Programs; Analysis and Implementation Issues; and New Environments for Genetic Programming. The first part extends the core concepts of genetic programming through the addition of new evolutionary techniques--adaptive and self-adaptive crossover methods, hill climbing operators, and the inclusion of introns into the representation. Creating more concise executable structures is a long-term research topic in genetic programming. The second part describes the field's most recent efforts, including the dynamic manipulation of automatically defined functions, evolving logic programs that generate recursive structures, and using minimum description length heuristics to determine when and how to prune evolving structures. The third part takes up the many implementation and analysis issues associated with evolving programs. Advanced applications of genetic programming to nontrivial real-world problems are described in the final part: remote sensing of pressure ridges in Arctic sea ice formations from satellite imagery, economic prediction through model evolution, the evolutionary development of stress and loading models for novel materials, and data\u00a0\u2026", "num_citations": "503\n", "authors": ["541"]}
{"title": "Genetic Programming with One-Point Crossover\n", "abstract": " In recent theoretical and experimental work on schemata in genetic programming we have proposed a new simpler form of crossover in which the same crossover point is selected in both parent programs. We call this operator one-point crossover because of its similarity with the corresponding operator in genetic algorithms. One-point crossover presents very interesting properties from the theory point of view. In this paper we describe this form of crossover as well as a new variant called strict one-point crossover highlighting their useful theoretical and practical features. We also present experimental evidence which shows that one-point crossover compares favourably with standard crossover.", "num_citations": "419\n", "authors": ["541"]}
{"title": "Fitness Causes Bloat\n", "abstract": " The problem of evolving an artificial ant to follow the Santa Fe trail is used to study the well known genetic programming feature of growth in solution length. Known variously as \u201cbloat\u201d, \u201cfluff\u201d and increasing \u201cstructural complexity\u201d, this is often described in terms of increasing \u201credundancy\u201d in the code caused by \u201cintrons\u201d.             Comparison between runs with and without fitness selection pressure, backed by Price\u2019s Theorem, shows the tendency for solutions to grow in size is caused by fitness based selection. We argue that such growth is inherent in using a fixed evaluation function with a discrete but variable length representation. With simple static evaluation search converges to mainly finding trial solutions with the same fitness as existing trial solutions. In general variable length allows many more long representations of a given solution than short ones. Thus in search (without a length bias) we expect\u00a0\u2026", "num_citations": "393\n", "authors": ["541"]}
{"title": "BioRAT: extracting biological information from full-length papers\n", "abstract": " Motivation: Converting the vast quantity of free-format text found in journals into a concise, structured format makes the researcher's quest for information easier. Recently, several information extraction systems have been developed that attempt to simplify the retrieval and analysis of biological and medical data. Most of this work has used the abstract alone, owing to the convenience of access and the quality of data. Abstracts are generally available through central collections with easy direct access (e.g. PubMed). The full-text papers contain more information, but are distributed across many locations (e.g. publishers' web sites, journal web sites and local repositories), making access more difficult.         In this paper, we present BioRAT, a new information extraction (IE) tool, specifically designed to perform biomedical IE, and which is able to locate and analyse both abstracts and full-length papers. BioRAT\u00a0\u2026", "num_citations": "234\n", "authors": ["541"]}
{"title": "Size fair and homologous tree genetic programming crossovers\n", "abstract": " Size fair and homologous crossover genetic operators for tree based genetic programming are described and tested. Both produce considerably reduced increases in program size and no detrimental e ect on GP performance. GP search spaces are partitioned by the ridge in the number of program v. their size and depth. A ramped uniform random initialisation is described which straddles the ridge. With subtree crossover trees increase about one level per generation leading to sub-quadratic bloat in length.", "num_citations": "234\n", "authors": ["541"]}
{"title": "The Evolution of Size and Shape\n", "abstract": " The phenomenon of growth in program size in genetic programming populations has been widely reported. In a variety of experiments and static analysis we test the standard protective code explanation and find it to be incomplete. We suggest bloat is primarily due to distribution of fitness in the space of possible programs and because of this, in the absence of bias, it is in general inherent in any search technique using a variable length representation. We investigate the fitness landscape produced by program tree-based genetic operators when acting upon points in the search space. We show bloat in common operators is primarily due to the exponential shape of the underlying search space. Nevertheless we demonstrate new operators with considerably reduced bloating characteristics. We also describe mechanisms whereby bloat arises and relate these back to the shape of the search space. Finally we show our simple random walk entropy increasing model is able to predict the shape of evolved programs.", "num_citations": "227\n", "authors": ["541"]}
{"title": "Why Ants are Hard\n", "abstract": " The problem of programming an arti cial ant to follow the Santa Fe trail is used as an example program search space. Analysis of shorter solutions shows they have many of the characteristics often ascribed to manually coded programs. Enumeration of a small fraction of the total search space and random sampling characterise it as rugged with many multiple plateaus split by deep valleys and many local and global optima. This suggests it is di cult for hill climbing algorithms. Analysis of the program search space in terms of xed length schema suggests it is highly deceptive and that for the simplest solutions large building blocks must be assembled before they have above average tness. In some cases we show solutions cannot be assembled using a xed representation from small building blocks of above average tness. These suggest the Ant problem is di cult for Genetic Algorithms.", "num_citations": "208\n", "authors": ["541"]}
{"title": "Schema theory for genetic programming with one-point crossover and point mutation\n", "abstract": " We review the main results obtained in the theory of schemata in genetic programming (GP), emphasizing their strengths and weaknesses. Then we propose a new, simpler definition of the concept of schema for GP, which is closer to the original concept of schema in genetic algorithms (GAs). Along with a new form of crossover, one-point crossover, and point mutation, this concept of schema has been used to derive an improved schema theorem for GP that describes the propagation of schemata from one generation to the next. We discuss this result and show that our schema theorem is the natural counterpart for GP of the schema theorem for GAs, to which it asymptotically converges.", "num_citations": "207\n", "authors": ["541"]}
{"title": "Performance of genetic programming optimised Bowtie2 on genome comparison and analytic testing (GCAT) benchmarks\n", "abstract": " Genetic studies are increasingly based on short noisy next generation scanners. Typically complete DNA sequences are assembled by matching short NextGen sequences against reference genomes. Despite considerable algorithmic gains since the turn of the millennium, matching both single ended and paired end strings to a reference remains computationally demanding. Further tailoring Bioinformatics tools to each new task or scanner remains highly skilled and labour intensive. With this in mind, we recently demonstrated a genetic programming based automated technique which generated a version of the state-of-the-art alignment tool Bowtie2 which was considerably faster on short sequences produced by a scanner at the Broad Institute and released as part of The Thousand Genome Project. Bowtie2                      G                     P                    and the original Bowtie2 release were compared on bioplanet\u2019s GCAT synthetic benchmarks. Bowtie2                      G                     P                    enhancements were also applied to the latest Bowtie2 release (2.2.3, 29 May 2014) and retained both the GP and the manually introduced improvements. On both singled ended and paired-end synthetic next generation DNA sequence GCAT benchmarks Bowtie2GP runs up to 45% faster than Bowtie2. The lost in accuracy can be as little as 0.2\u20130.5% but up to 2.5% for longer sequences.", "num_citations": "200\n", "authors": ["541"]}
{"title": "On the search properties of different crossover operators in genetic programming\n", "abstract": " In this paper we study and compare the search properties of different crossover operators in genetic programming (GP) using probabilistic models and experiments to assess the amount of genetic material exchanged between the parents to generate the offspring. These operators are: standard crossover, onepoint crossover and a new operator, uniform crossover. Our analysis suggests that standard crossover is a local and biased search operator not ideal to explore the search space of programs effectively. One-point crossover is better in some cases as it is able to perform a global search at the beginning of a run, but it suffers from the same problems as standard crossover later on. Uniform crossover largely overcomes these limitations as it is global and less biased.", "num_citations": "169\n", "authors": ["541"]}
{"title": "A SIMD interpreter for genetic programming on GPU graphics cards\n", "abstract": " Mackey-Glass chaotic time series prediction and nuclear protein classification show the feasibility of evaluating genetic programming populations directly on parallel consumer gaming graphics processing units. Using a Linux KDE computer equipped with an nVidia GeForce 8800 GTX graphics processing unit card the C++ SPMD interpretter evolves programs at Giga GP operations per second (895 million GPops). We use the RapidMind general processing on GPU (GPGPU) framework to evaluate an entire population of a quarter of a million individual programs on a non-trivial problem in 4 seconds. An efficient reverse polish notation (RPN) tree based GP is given.", "num_citations": "165\n", "authors": ["541"]}
{"title": "A new schema theorem for genetic programming with one-point crossover and point mutation\n", "abstract": " We review the main results obtained in the theory of schemata in Genetic Programming (GP) emphasising their strengths and weaknesses. Then we propose a new, simpler de nition of the concept of schema for GP which is closer to the original concept of schema in genetic algorithms (GAs). Along with a new form of crossover, one-point crossover, and point mutation this concept of schema has been used to derive an improved schema theorem for GP which describes the propagation of schemata from one generation to the next. We discuss this result and show that our schema theorem is the natural counterpart for GP of the schema theorem for GAs, to which it asymptotically converges.", "num_citations": "151\n", "authors": ["541"]}
{"title": "Some considerations on the reason for bloat\n", "abstract": " A representation-less model for genetic programming is presented. The model is intended to examine the mechanisms that lead to bloat in genetic programming (GP). We discuss two hypotheses (\u201cfitness causes bloat\u201d and \u201cneutral code is protective\u201d) and perform simulations to examine the predictions deduced from these hypotheses. Our observation is that predictions from both hypotheses are realized in the simulated model.", "num_citations": "146\n", "authors": ["541"]}
{"title": "Evolving problems to learn about particle swarm optimizers and other search algorithms\n", "abstract": " We use evolutionary computation (EC) to automatically find problems which demonstrate the strength and weaknesses of modern search heuristics. In particular, we analyze particle swarm optimization (PSO), differential evolution (DE), and covariance matrix adaptation-evolution strategy (CMA-ES). Each evolutionary algorithm is contrasted with the others and with a robust nonstochastic gradient follower (i.e., a hill climber) based on Newton-Raphson. The evolved benchmark problems yield insights into the operation of PSOs, illustrate benefits and drawbacks of different population sizes, velocity limits, and constriction (friction) coefficients. The fitness landscapes made by genetic programming reveal new swarm phenomena, such as deception, thereby explaining how they work and allowing us to devise better extended particle swarm systems. The method could be applied to any type of optimizer.", "num_citations": "139\n", "authors": ["541"]}
{"title": "Quadratic bloat in genetic programming\n", "abstract": " In earlier work we predicted program size would grow in the limit at a quadratic rate and up to fifty generations we measured bloat O (generations1. 2; 1.5). On two simple benchmarks we test the prediction of bloat O (generations2. 0) up to generation 600. In continuous problems the limit of quadratic growth is reached but convergence in the discrete case limits growth in size. Measurements indicate subtree crossover ceases to be disruptive with large programs (1,000,000) and the population effectively converges (even though variety is near unity). Depending upon implementation, we predict run time O (no. generations2. 0; 3.0) and memory O (no. generations1. 0; 2.0).", "num_citations": "126\n", "authors": ["541"]}
{"title": "Application of genetic programming to induction of linear classification trees\n", "abstract": " A common problem in datamining is to find accurate classifiers for a dataset. For this purpose, genetic programming (GP) is applied to a set of benchmark classification problems. Using GP we are able to induce decision trees with a linear combination of variables in each function node. A new representation of decision trees using strong typing in GP is introduced. With this representation it is possible to let the GP classify into any number of classes. Results indicate that GP can be applied successfully to classification problems. Comparisons with current state-of-the-art algorithms in machine learning are presented and areas of future research are identified.", "num_citations": "116\n", "authors": ["541"]}
{"title": "The evolution of size in variable length representations\n", "abstract": " In many cases, a program's length increases during artificial evolution. This is known as \"bloat\", \"fluff\" or \"increasing structural complexity\". We show that bloat is not specific to genetic programming and suggest it is inherent in search techniques with discrete variable-length representations using simple static evaluation functions. We investigate the bloating characteristics of three non-population-based and one population-based search technique using a novel mutation operator. An artificial ant following the Santa Fe trail problem is solved by simulated annealing, hill climbing, strict hill climbing and population-based searching using two variants of the the new subtree-based mutation operator. As predicted, bloat is observed when using unbiased mutation and is absent in simulated annealing and in both hill climbers when using the length-neutral mutation; however, bloat occurs with both mutations when using a\u00a0\u2026", "num_citations": "116\n", "authors": ["541"]}
{"title": "An analysis of the MAX problem in genetic programming\n", "abstract": " We present a detailed analysis of the evolution of genetic programming (GP) populations using the problem of finding a program which returns the maximum possible value for a given terminal and function set and a depth limit on the program tree (known as the MAX problem). We confirm the basic message of [Gathercole and Ross, 1996] that crossover together with program size restrictions can be responsible for premature convergence to a suboptimal solution. We show that this can happen even when the population retains a high level of variety and show that in many cases evolution from the sub-optimal solution to the solution is possible if sufficient time is allowed. In both cases theoretical models are presented and compared with actual runs.", "num_citations": "104\n", "authors": ["541"]}
{"title": "Genetic programming: An introductory tutorial and a survey of techniques and applications\n", "abstract": " This paper introduces genetic programming (GP)\u2013a set of evolutionary computation techniques for getting computers to automatically solve problems without having to tell them explicitly how to do it. Since its inception, GP has been used to solve many practical problems, producing a number of human competitive results and even patentable new inventions. We start with a gentle introduction to the basic representation, initialisation and operators used in GP, complemented by a step by step description of their use for the solution of an illustrative problem. We then progress to discuss a variety of alternative representations for programs and more advance specialisations of GP. A multiplicity of real-world applications of GP are then presented to illustrate the scope of the technique. For the benefits of more advanced readers, this is followed by a series of recommendations and suggestions to obtain the most from a GP system. Although the paper has been written with beginners and practitioners in mind, for completeness we also provide an overview of the theoretical results and models available to date for GP. The paper is concluded by an appendix which provides a plethora of pointers to resources and further reading.", "num_citations": "103\n", "authors": ["541"]}
{"title": "Extending particle swarm optimisation via genetic programming\n", "abstract": " Particle Swarm Optimisers (PSOs) search using a set of interacting particles flying over the fitness landscape. These are typically controlled by forces that encourage each particle to fly back both towards the best point sampled by it and towards the swarm\u2019s best. Here we explore the possibility of evolving optimal force generating equations to control the particles in a PSO using genetic programming.", "num_citations": "103\n", "authors": ["541"]}
{"title": "Size fair and homologous tree crossovers for tree genetic programming\n", "abstract": " Size fair and homologous crossover genetic operators for tree based genetic programming are described and tested. Both produce considerably reduced increases in program size (i.e., less bloat) and no detrimental effect on GP performance.               GP search spaces are partitioned by the ridge in the number of program v. their size and depth. While search efficiency is little effected by initial conditions, these do strongly influence which half of the search space is searched. However a ramped uniform random initialization is described which straddles the ridge.               With subtree crossover trees increase about one level per generation leading to subquadratic bloat in program length.", "num_citations": "99\n", "authors": ["541"]}
{"title": "Data Structures and Genetic Programming\n", "abstract": " In real world applications, software engineers recognise the use of memory must be organised via data structures and that software using the data must be independant of the data structures\u2019 implementation details. They achieve this by using abstract data structures, such as records, files and buffers. We demonstrate that genetic programming can automatically implement simple abstract data structures, considering in detail the task of evolving a list. We show general and reasonably efficient implementations can be automatically generated from simple primitives. A model for maintaining evolved code is demonstrated using the list problem.", "num_citations": "96\n", "authors": ["541"]}
{"title": "Genetic programming: An introduction and tutorial, with a survey of techniques and applications\n", "abstract": " The goal of having computers automatically solve problems is central to artificial intelligence, machine learning, and the broad area encompassed by what Turing called \u2018machine intelligence\u2019 [384]. Machine learning pioneer Arthur Samuel, in his 1983 talk entitled \u2018AI: Where It Has Been and Where It Is Going\u2019 [337], stated that the main goal of the fields of machine learning and artificial intelligence is:                                                   \u201cto get machines to exhibit behavior, which if done by humans, would be assumed to involve the use of intelligence.\u201d", "num_citations": "90\n", "authors": ["541"]}
{"title": "Evolving Data Structures with Genetic Programming.\n", "abstract": " Genetic programming (GP) is a subclass of genetic algorithms (GAs), in which evolving programs are directly represented in the chromosome as trees. Recently it has been shown that programs which explicitly use directly addressable memory can be generated using GP.It is established good software engineering practice to ensure that programs use memory via abstract data structures such as stacks, queues and lists. These provide an interface between the program and memory, freeing the program of memory management details which are left to the data structures to implement. The main result presented herein is that GP can automatically generate stacks and queues.", "num_citations": "90\n", "authors": ["541"]}
{"title": "Exploring extended particle swarms: a genetic programming approach\n", "abstract": " Particle Swarm Optimisation (PSO) uses a population of particles that fly over the fitness landscape in search of an optimal solution. The particles are controlled by forces that encourage each particle to fly back both towards the best point sampled by it and towards the swarm's best point, while its momentum tries to keep it moving in its current direction. Previous research started exploring the possibility of evolving the force generating equations which control the particles through the use of genetic programming (GP). We independently verify the findings of the previous research and then extend it by considering additional meaningful ingredients for the PSO force-generating equations, such as global measures of dispersion and position of the swarm. We show that, on a range of problems, GP can automatically generate new PSO algorithms that outperform standard human-generated as well as some previously\u00a0\u2026", "num_citations": "84\n", "authors": ["541"]}
{"title": "GP on SPMD parallel graphics hardware for mega bioinformatics data mining\n", "abstract": " We demonstrate a SIMD C++ genetic programming system on a single 128 node parallel nVidia GeForce 8800 GTX GPU under RapidMind\u2019s GPGPU Linux software by predicting ten year+ outcome of breast cancer from a dataset containing a million inputs. NCBI GEO GSE3494 contains hundreds of Affymetrix HG-U133A and HG-U133B GeneChip biopsies. Multiple GP runs each with a population of 5 million programs winnow useful variables from the chaff at more than 500 million GPops per second. Sources available via FTP.", "num_citations": "79\n", "authors": ["541"]}
{"title": "Theoretical results in genetic programming: the next ten years?\n", "abstract": " We consider the theoretical results in GP so far and prospective areas for the future. We begin by reviewing the state of the art in genetic programming (GP) theory including: schema theories, Markov chain models, the distribution of functionality in program search spaces, the problem of bloat, the applicability of the no-free-lunch theory to GP, and how we can estimate the difficulty of problems before actually running the system. We then look at how each of these areas might develop in the next decade, considering also new possible avenues for theory, the challenges ahead and the open issues.", "num_citations": "78\n", "authors": ["541"]}
{"title": "Combining decision trees and neural networks for drug discovery\n", "abstract": " Genetic programming (GP) offers a generic method of automatically fusing together classifiers using their receiver operating characteristics (ROC) to yield superior ensembles. We combine decision trees (C4.5) and artificial neural networks (ANN) on a difficult pharmaceutical data mining (KDD) drug discovery application. Specifically predicting inhibition of a P450 enzyme. Training data came from high throughput screening (HTS) runs. The evolved model may be used to predict behaviour of virtual (i.e. yet to be manufactured) chemicals. Measures to reduce over fitting are also described.", "num_citations": "78\n", "authors": ["541"]}
{"title": "Genetic programming for mining DNA chip data from cancer patients\n", "abstract": " In machine learning terms DNA (gene) chip data is unusual in having thousands of attributes (the gene expression values) but few (<100) records (the patients). A GP based method for both feature selection and generating simple models based on a few genes is demonstrated on cancer data.", "num_citations": "75\n", "authors": ["541"]}
{"title": "A fast high quality pseudo random number generator for nVidia CUDA\n", "abstract": " Previously either due to hardware GPU limits or older versions of software, careful implementation of PRNGs was required to make good use of the limited numerical precision available on graphics cards. Newer nVidia G80 and Tesla hardware support double precision. This is available to high level programmers via CUDA. This allows a much simpler C++ implementation of Park-Miller random numbers, which provides a four fold speed up compared to an earlier GPU implementation. Code is available via http://www. cs. ucl. ac. uk/staff/W. Langdon/ftp/gp-code/random-numbers/cuda_park-miller. tar. gz", "num_citations": "74\n", "authors": ["541"]}
{"title": "A many threaded CUDA interpreter for genetic programming\n", "abstract": " A Single Instruction Multiple Thread CUDA interpreter provides SIMD like parallel evaluation of the whole GP population of \u00a0million reverse polish notation (RPN) expressions on graphics cards and nVidia Tesla. Using sub-machine code tree GP a sustain peak performance of 665 billion GP operations per second (10,000 speed up) and an average of 22 peta GP ops per day is reported for a single GPU card on a Boolean induction benchmark never attempted before, let alone solved.", "num_citations": "71\n", "authors": ["541"]}
{"title": "On the limiting distribution of program sizes in tree-based genetic programming\n", "abstract": " We provide strong theoretical and experimental evidence that standard sub-tree crossover with uniform selection of crossover points pushes a population of a-ary GP trees towards a distribution of tree sizes of the form:                                $$ \\Pr\\{n\\}= (1-ap_a) {a n+1 \\choose n} \\, (1-p_a)^{(a-1)n+1}\\, p_a^{n} $$                              where n is the number of internal nodes in a tree and p                                            a                  is a constant. This result generalises the result previously reported for the case a\u2009=\u20091.", "num_citations": "71\n", "authors": ["541"]}
{"title": "Evolving problems to learn about particle swarm and other optimisers\n", "abstract": " We use evolutionary computation (EC) to automatically find problems which demonstrate the strength and weaknesses of modern search heuristics. In particular we analyse particle swarm optimization (PSO) and differential evolution (DE). Both evolutionary algorithms are contrasted with a robust deterministic gradient based searcher (based on Newton-Raphson). The fitness landscapes made by genetic programming (GP) are used to illustrate difficulties in GAs and PSOs thereby explaining how they work and allowing us to devise better extended particle swarm systems (XPS)", "num_citations": "71\n", "authors": ["541"]}
{"title": "Graphics processing units and genetic programming: an overview\n", "abstract": " A top end graphics card (GPU) plus a suitable SIMD interpreter can deliver a several hundred fold speed up, yet cost less than the computer holding it. We give highlights of AI and computational intelligence applications in the new field of general purpose computing on graphics hardware (GPGPU). In particular, we surveyed genetic programming (GP) use with GPU. We gave several applications from Bioinformatics and showed that how the fastest GP is based on an interpreter rather than compilation. Finally using GP to generate GPU CUDA kernel C++ code is sketched.", "num_citations": "69\n", "authors": ["541"]}
{"title": "Scheduling maintenance of electrical power transmission networks using genetic programming\n", "abstract": " The National Grid Company Plc. is responsible for the maintenance of the high voltage electricity transmission network in England and Wales. It must plan maintenance so as to minimise costs taking into account:\u2022 location and size of demand,\u2022 generator capacities and availability\u2019s,\u2022 electricity carrying capacity of the remainder of the network, ie that part not undergoing maintenance.Previous work showed the combination of a Genetic Algorithm using an order or permutation chromosome combined with hand coded \u2018Greedy\u2019Optimisers can readily produce an optimal schedule for a four node test problem [10]. Following this the same GA has been used to find low cost schedules for the South Wales region of the UK high voltage power network.", "num_citations": "69\n", "authors": ["541"]}
{"title": "Genetic programming for combining classifiers\n", "abstract": " Genetic programming (GP) can automatically fuse given classi ers to produce a combined classi er whose Receiver Operating Characteristics (ROC) are better than Scott et al., 1998b]'s\\Maximum Realisable Receiver Operating Characteristics\"(MRROC). Ie better than their convex hull. This is demonstrated on arti cial, medical and satellite image processing bench marks.", "num_citations": "67\n", "authors": ["541"]}
{"title": "Mutation in genetic programming: a preliminary study\n", "abstract": " In this paper we examine the behaviour of the uniform crossover and point mutation GP operators [12] on the even-\u03b7-parity problem for \u03b7 = 3;4; 6 and present a novel representation of function nodes, designed to allow the search operators to make smaller movements around the solution space. Using this representation, performance on the even-6-parity problem is improved by three orders of magnitude relative to the estimate given for standard GP in [5].", "num_citations": "63\n", "authors": ["541"]}
{"title": "Genetic programming\u2014computers using \u201cNatural Selection\u201d to generate programs\n", "abstract": " Computers that \u201cprogram themselves\u201d; science fact or fiction? Genetic Programming uses novel optimisation techniques to \u201cevolve\u201d simple programs; mimicking the way humans construct programs by progressively re-writing them. Trial programs are repeatedly modified in the search for \u201cbetter/fitter\u201d solutions. The underlying basis is Genetic Algorithms (GAs).", "num_citations": "61\n", "authors": ["541"]}
{"title": "Accelerating Genetic Programming through Graphics Processing Units.\n", "abstract": " Abstract Graphics Processing Units (GPUs) are in the process of becoming a major source of computational power for numerical applications. Originally designed for application of time-consuming graphics operations, GPUs are stream processors that implement the SIMD paradigm. The true degree of parallelism of GPUs is often hidden from the user, making programming even more flexible and convenient. In this chapter we survey Genetic Programming methods currently ported to GPUs.", "num_citations": "60\n", "authors": ["541"]}
{"title": "Seeding Genetic Programming Populations\n", "abstract": " We show genetic programming (GP) populations can evolve under the influence of a Pareto multi-objective fitness and program size selection scheme, from \u201cperfect\u201d programs which match the training material to general solutions. The technique is demonstrated with programmatic image compression, two machine learning benchmark problems (Pima Diabetes and Wisconsin Breast Cancer) and an insurance customer profiling task (Benelearn99 data mining).", "num_citations": "60\n", "authors": ["541"]}
{"title": "Repeated sequences in linear genetic programming genomes\n", "abstract": " Biological chromosomes are replete with repetitive sequences, micro satellites, SSR tracts, ALU, etc. in their DNA base sequences. We started looking for similar phenomena in evolutionary computation. First studies find copious repeated sequences, which can be hierarchically decomposed into shorter sequences, in programs evolved using both homologous and two point crossover but not with headless chicken crossover or other mutations. In bloated programs the small number of effective or expressed instructions appear in both repeated and nonrepeated code. Hinting that building-blocks or code reuse may evolve in unplanned ways. Mackey-Glass chaotic time series prediction and eukaryotic protein localisation (both previously used as artificial intelligence machine learning benchmarks) demonstrate evolution of Shannon information (entropy) and lead to models capable of lossy Kolmogorov compression. Our findings with diverse benchmarks and GP systems suggest this emergent phenomenon may be widespread in genetic systems.", "num_citations": "56\n", "authors": ["541"]}
{"title": "Advances in the application of machine learning techniques in drug discovery, design and development\n", "abstract": " Machine learning tools, in particular support vector machines (SVM), Particle Swarm Optimisation (PSO) and Genetic Programming (GP), are increasingly used in pharmaceuticals research and development. They are inherently suitable for use with \u2018noisy\u2019, high dimensional (many variables) data, as is commonly used in cheminformatic (i.e. In silico screening), bioinformatic (i.e. bio-marker studies, using DNA chip data) and other types of drug research studies. These aspects are demonstrated via review of their current usage and future prospects in context with drug discovery activities.", "num_citations": "54\n", "authors": ["541"]}
{"title": "Genetic programming in data mining for drug discovery\n", "abstract": " Genetic programming (GP) is used to extract from rat oral bioavailability (OB) measurements simple, interpretable and predictive QSAR models which both generalize to rats and to marketed drugs in humans. Receiver Operating Characteristics (ROC) curves for the binary classifier produced by machine learning show no statistical difference between rats (albeit without known clearance differences) and man. Thus evolutionary computing offers the prospect of in silico ADME screening, e.g. for \u201cvirtual\u201d chemicals, for pharmaceutical drug discovery.", "num_citations": "53\n", "authors": ["541"]}
{"title": "Genetic Programming Bloat with Dynamic Fitness\n", "abstract": " In artificial evolution individuals which perform as their parents are usually rewarded identically to their parents. We note that Nature is more dynamic and there may be a penalty to pay for doing the same thing as your parents. We report two sets of experiments where static fitness functions are firstly augmented by a penalty for unchanged offspring and secondly the static fitness case is replaced by randomly generated dynamic test cases. We conclude genetic programming, when evolving artificial ant control programs, is surprisingly little effected by large penalties and program growth is observed in all our experiments.", "num_citations": "53\n", "authors": ["541"]}
{"title": "Java based distributed genetic programming on the internet\n", "abstract": " A distributed approach for parallelising Genetic Programming (GP) on the Internet is proposed and its feasibility demonstrated with a distributed GP system termed DGP developed in Java. DGP uses Java Servlets to handle communication between distributed machines and a population pool to facilitate migrations. It also has an interactive user interface for controlling a run and graphical displays of the evolution process. DGP is run successfully across the world over the Internet on heterogeneous platforms without any central co-ordination. The run results and the outcome of an experiment to determine DGP's performance are reported together with a description of DGP.", "num_citations": "52\n", "authors": ["541"]}
{"title": "An overview of image-processing methods for Affymetrix GeneChips\n", "abstract": " We present an overview of image-processing methods for Affymetrix GeneChips. All GeneChips are affected to some extent by spatially coherent defects and image processing has a number of potential impacts on the downstream analysis of GeneChip data. Fortunately, there are now a number of robust and accurate algorithms, which identify the most disabling defects. One group of algorithms concentrate on the transformation from the original hybridisation DAT image to the representative CEL file. Another set uses dedicated pattern recognition routines to detect different types of hybridisation defect in replicates. A third type exploits the information provided by public repositories of GeneChips (such as GEO). The use of these algorithms improves the sensitivity of GeneChips, and should be a prerequisite for studies in which there are only few probes per relevant biological signal, such as exon arrays and\u00a0\u2026", "num_citations": "51\n", "authors": ["541"]}
{"title": "Backward-chaining evolutionary algorithms\n", "abstract": " Starting from some simple observations on a popular selection method in Evolutionary Algorithms (EAs)\u2014tournament selection\u2014we highlight a previously-unknown source of inefficiency. This leads us to rethink the order in which operations are performed within EAs, and to suggest an algorithm\u2014the EA with efficient macro-selection\u2014that avoids the inefficiencies associated with tournament selection. This algorithm has the same expected behaviour as the standard EA but yields considerable savings in terms of fitness evaluations. Since fitness evaluation typically dominates the resources needed to solve any non-trivial problem, these savings translate into a reduction in computer time. Noting the connection between the algorithm and rule-based systems, we then further modify the order of operations in the EA, effectively turning the evolutionary search into an inference process operating in backward-chaining\u00a0\u2026", "num_citations": "48\n", "authors": ["541"]}
{"title": "An experimental analysis of schema creation, propagation and disruption in genetic programming\n", "abstract": " In this paper we rst review the main results in the theory of schemata in Genetic Programming (GP) and summarise a new GP schema theory which is based on a new de nition of schema. Then we study the creation, propagation and disruption of this new form of schemata in real runs, for standard crossover, one-point crossover and selection only. Finally, we discuss these results in the light our GP schema theorem.", "num_citations": "48\n", "authors": ["541"]}
{"title": "G-spots cause incorrect expression measurement in Affymetrix microarrays\n", "abstract": " High Density Oligonucleotide arrays (HDONAs), such as the Affymetrix HG-U133A GeneChip, use sets of probes chosen to match specified genes, with the expectation that if a particular gene is highly expressed then all the probes in that gene's probe set will provide a consistent message signifying the gene's presence. However, probes that contain a G-spot (a sequence of four or more guanines) behave abnormally and it has been suggested that these probes are responding to some biochemical effect such as the formation of G-quadruplexes. We have tested this expectation by examining the correlation coefficients between pairs of probes using the data on thousands of arrays that are available in the NCBI Gene Expression Omnibus (GEO) repository. We confirm the finding that G-spot probes are poorly correlated with others in their probesets and reveal that, by contrast, they are highly correlated with one\u00a0\u2026", "num_citations": "45\n", "authors": ["541"]}
{"title": "Genetically improved software\n", "abstract": " Genetic programming (GP) can dramatically increase computer programs\u2019 performance. It can automatically port or refactor legacy code written by domain experts and specialist software engineers. After reviewing SBSE research on evolving software we describe an open source parallel StereoCamera image processing application in which GI optimisation gave a seven fold speedup on nVidia Tesla GPU hardware not even imagined when the original state-of-the-art CUDA GPGPU C++ code was written.", "num_citations": "44\n", "authors": ["541"]}
{"title": "Genetically improved CUDA C++ software\n", "abstract": " Genetic Programming (GP) may dramatically increase the performance of software written by domain experts. GP and autotuning are used to optimise and refactor legacy GPGPU C\u00a0code for modern parallel graphics hardware and software. Speed ups of more than six times on recent nVidia GPU cards are reported compared to the original kernel on the same hardware.", "num_citations": "43\n", "authors": ["541"]}
{"title": "Scaling of program fitness spaces\n", "abstract": " We investigate the distribution of fitness of programs concentrating on those represented as parse trees and, particularly, how such distributions scale with respect to changes in the size of the programs. By using a combination of enumeration and Monte Carlo sampling on a large number of problems from three very different areas, we suggest that, in general, once some minimum size threshold has been exceeded, the distribution of performance is approximately independent of program length. We proof this for both linear programs and simple side effect free parse trees. We give the density of solutions to the parity problems in program trees which are composed of XOR building blocks. Limited experiments with programs including side effects and iteration suggest a similar result may also hold for this wider class of programs.", "num_citations": "43\n", "authors": ["541"]}
{"title": "Analysis of schema variance and short term extinction likelihoods\n", "abstract": " This paper first analyses the impact of variance on schema transmission. Working from an exact derivation of the expected variance in schema transmission, it derives and analyses the signal-to-noise ratio for schemata. The paper then presents short term schema transmission probability results that focus on newly created schemata in the population. The analysis reveals the relative dependencies between schema transmission, population size, schema measured fitness, schema fragility and schema creation.", "num_citations": "43\n", "authors": ["541"]}
{"title": "The structure of the genetic programming collaboration network\n", "abstract": " The genetic programming bibliography aims to be the most complete reference of papers on genetic programming. In addition to locating publications, it contains coauthor and coeditor relationships which have not previously been studied. These reveal some similarities and differences between our field and collaborative social networks in other scientific fields.", "num_citations": "42\n", "authors": ["541"]}
{"title": "A fast high quality pseudo random number generator for graphics processing units\n", "abstract": " Limited numerical precision of nVidia GeForce 8800 GTX and other GPUs requires careful implementation of PRNGs. The Park-Miller PRNG is programmed using G80's native Value4f floating point in RapidMind C++. Speed up is more than 40. Code is available via ftp cs.ucl.ac.uk genetic/gp- code/random-numbers/gpu_park-miller.tar.gz.", "num_citations": "41\n", "authors": ["541"]}
{"title": "Exact schema theory for GP and variable-length GAs with homologous crossover\n", "abstract": " In this paper we present a new exact schema theory for genetic programming and variablelength genetic algorithms which is applicable to the general class of homologous crossovers. These are a group of operators, including GP one-point crossover and GP uniform crossover, where the offspring are created preserving the position of the genetic material taken from the parents. The theory is based on the concepts of GP crossover masks and GP recombination distributions both introduced here for the first time, as well as the notions of hyperschema and node reference systems introduced in other recent research. This theory generalises and refines previous work in GP and GA theory.", "num_citations": "41\n", "authors": ["541"]}
{"title": "Genetic programming and evolvable machines: ten years of reviews\n", "abstract": " The journal and in particular the resource reviews have been running for 10\u00a0years. There are a number of activities being planned to celebrate. However it is a good time to revisit our original and updated goals again [(Langdon, Genet Progrm Evolvable Mach 1(1/2):165\u2013169 (2000); Langdon and  Gustafson, Genet Program Evolvable Mach 6(2):221\u2013228 (2005)], compare them with what the journal has achieved and make new plans. \"Books\" section onwards gives up to date statistics on the genetic programming and evolvable hardware literature and electronic resources.", "num_citations": "37\n", "authors": ["541"]}
{"title": "Mycoplasma contamination in the 1000 Genomes Project\n", "abstract": " In silco Biology is increasingly important and is often based on public data. While the problem of contamination is well recognised in microbiology labs the corresponding problem of database corruption has received less attention. Mapping 50 billion next generation DNA sequences from The Thousand Genome Project against published genomes reveals many that match one or more Mycoplasma but are not included in the reference human genome GRCh37.p5. Many of these are of low quality but NCBI BLAST searches confirm some high quality, high entropy sequences match Mycoplasma but no human sequences. It appears at least 7% of 1000G samples are contaminated.", "num_citations": "36\n", "authors": ["541"]}
{"title": "Large-scale bioinformatics data mining with parallel genetic programming on graphics processing units\n", "abstract": " The NCBI GEO GSE3494 breast cancer dataset contains hundreds of Affymetrix HG-U133A and HG-U133B GeneChip biopsies each with a million variables. Multiple genetic programming (GP) runs on a graphics processing unit (GPU) hardware, each with a population of five million programs both winnows (selects) useful variables from the chaff and evolves small (three inputs) data models. The SPMD CUDA interpreter exploits the GPU\u2019s single instruction multiple data (SIMD) mode of parallel computing, even though the GP populations contain different programs. A 448 node nVidia Fermi C2050 Tesla graphics card delivers 8.5 giga GPops per second. In addition to describing our implementation, we survey current GPGPU work in bioinformatics and genetic programming.", "num_citations": "36\n", "authors": ["541"]}
{"title": "How many Good Programs are there? How Long are they?\n", "abstract": " We model the distribution of functions implemented by non-recursive programs, similar to linear genetic programming (GP). Most functions are constants, the remainder are mostly parsimonious. The effect of ad-hoc rules on GP are described and new heuristics are proposed. Bounds on how long programs need to be before the distribution of their functionality is close to its limiting distribution are provided in general and for average computers. Results for average computers and a model like genetic programming are experimentally tested.", "num_citations": "35\n", "authors": ["541"]}
{"title": "A survey of spatial defects in Homo Sapiens Affymetrix GeneChips\n", "abstract": " Modern biology has moved from a science of individual measurements to a science where data are collected on an industrial scale. Foremost, among the new tools for biochemistry are chip arrays which, in one operation, measure hundreds of thousands or even millions of DNA sequences or RNA transcripts. While this is impressive, increasingly sophisticated analysis tools have been required to convert gene array data into gene expression levels. Despite the assumption that noise levels are low, since the number of measurements for an individual gene is small, identifying which signals are affected by noise is a priority. High-density oligonucleotide array (HDONAs) from NCBI GEO shows that, even in the best Human GeneChips 1/4 percent of data are affected by spatial noise. Earlier designs are noisier and spatial defects may affect more than 25 percent of probes. BioConductor R code is available as\u00a0\u2026", "num_citations": "34\n", "authors": ["541"]}
{"title": "Data fusion by intelligent classifier combination\n", "abstract": " It is a common complaint that, at the beginning of the twenty-first century, we are\" drowning in data, but starved of information\". The computer-based systems deployed in science, engineering, industry, business, commerce and many other aspects of life such as healthcare, now often produce such a variety of data at such a rate that it precludes human analysis. Prime examples include traditional'big'sciences and engineering such as particle physics and astronomy, new sciences such as cheminformatics and bioinformatics, high-tech systems in space and defence, industrial systems, commercial and business systems in marketing, retail and finance. When it is clear how the data should be analysed, automation of the analysis by computer is reasonably straightforward, but this is increasingly the exception, even in the traditional areas of science and engineering. Often, in particular in industry, commerce and finance\u00a0\u2026", "num_citations": "34\n", "authors": ["541"]}
{"title": "Genetic programming bloat without semantics\n", "abstract": " To investigate the fundamental causes of bloat, six artificial random binary tree search spaces are presented. Fitness is given by program syntax (the genetic programming genotype). GP populations are evolved on both random problems and problems with \u201cbuilding blocks\u201d. These are compared to problems with explicit ineffective code (introns, junk code, inviable code). Our results suggest the entropy random walk explanation of bloat remains viable. The hard building block problem might be used in further studies, e.g. of standard subtree crossover.", "num_citations": "33\n", "authors": ["541"]}
{"title": "Scheduling planned maintenance of the national grid\n", "abstract": " The maintenance of the high voltage electricity transmission network in England and Wales (the National Grid) is planned so as to minimise costs taking into account:                                    location and size of demand for electricity,                                                     generator capacities and availabilities,                                                     electricity carrying capacity of the remainder of the network, i.e. that part not undergoing maintenance.                                              This complex optimization and scheduling problem is currently performed manually (computerised viability checks can be performed after the schedule has been produced). This paper reports work aiming to automatically generate low cost schedules using genetic algorithms (GA). So far:                                    A small demonstration problem has been identified,                                                     A fitness function has been devised,                                                     To date\u00a0\u2026", "num_citations": "33\n", "authors": ["541"]}
{"title": "Probes containing runs of guanines provide insights into the biophysics and bioinformatics of Affymetrix GeneChips\n", "abstract": " The reliable interpretation of Affymetrix GeneChip data is a multi-faceted problem. The interplay between biophysics, bioinformatics and mining of GeneChip surveys is leading to new insights into how best to analyse the data. Many of the molecular processes occurring on the surfaces of GeneChips result from the high surface density of probes. Interactions between neighbouring adjacent probes affect their rate and strength of hybridization to targets. Competing targets may hybridize to the same probe, and targets may partially bind to more than one probe. The formation of these partial hybrids results in a number of probes not reaching thermodynamic equilibrium during hybridization. Moreover, some targets fold up, or cross-hybridize to other targets. Furthermore, probes may fold and can undergo chemical saturation. There are also sequence-dependent differences in the rates of target desorption during the\u00a0\u2026", "num_citations": "32\n", "authors": ["541"]}
{"title": "Smooth uniform crossover, sub-machine code GP and demes: A recipe for solving high-order boolean parity problems\n", "abstract": " We describe a recipe to solve very large parity problems using GP. The recipe includes: smooth uniform crossover (a crossover operator inspired by our theoretical research), sub-machine-code GP (a technique to speed up fitness evaluation in Boolean classification problems), and interacting demes (sub-populations) running on separate workstations. We tested this recipe on parity problems with up to 22 input variables, solving them with a very high success probability.", "num_citations": "32\n", "authors": ["541"]}
{"title": "Repeated patterns in genetic programming\n", "abstract": " Evolved genetic programming trees contain many repeated code fragments. Size fair crossover limits bloat in automatic programming, preventing the evolution of recurring motifs. We examine these complex properties in detail using depth vs. size Catalan binary tree shape plots, subgraph and subtree matching, information entropy, sensitivity analysis, syntactic and semantic fitness correlations. Programs evolve in a self-similar fashion, akin to fractal random trees, with diffuse introns. Data mining frequent patterns reveals that as software is progressively improved a large proportion of it is exactly repeated subtrees as well as exactly repeated subgraphs. We relate this emergent phenomenon to building blocks in GP and suggest GP works by jumbling subtrees which already have high fitness on the whole problem to give incremental improvements and create complete solutions with multiple identical\u00a0\u2026", "num_citations": "31\n", "authors": ["541"]}
{"title": "Evolving hand-eye coordination for a humanoid robot with machine code genetic programming\n", "abstract": " We evolve, using AIMGP machine code genetic programming, Discipulus, an approximation of the inverse kinematics of a real robotics arm with many degrees of freedom. Elvis is a bipedal robot with human-like geometry and motion capabilities a humanoid, primarily controlled by evolutionary adaptive methods. The GP system produces a useful inverse kinematic mapping, from target 3-D points (via pairs of stereo video images) to a vector of arm controller actuator set points.", "num_citations": "31\n", "authors": ["541"]}
{"title": "Specialising software for different downstream applications using genetic improvement and code transplantation\n", "abstract": " Genetic improvement uses automated search to find improved versions of existing software. Genetic improvement has previously been concerned with improving a system with respect to all possible usage scenarios. In this paper, we show how genetic improvement can also be used to achieve specialisation to a specific set of usage scenarios. We use genetic improvement to evolve faster versions of a C++ program, a Boolean satisfiability solver called MiniSAT, specialising it for three different applications, each with their own characteristics. Our specialised solvers achieve between 4 and 36 percent execution time improvement, which is commensurate with efficiency gains achievable using human expert optimisation for the general solver. We also use genetic improvement to evolve faster versions of an image processing tool called ImageMagick, utilising code from GraphicsMagick, another image processing tool\u00a0\u2026", "num_citations": "30\n", "authors": ["541"]}
{"title": "Software is not fragile\n", "abstract": " Trying all simple changes (first order mutations) to executed C, C++ and CUDA source code shows software engineering artefacts are more robust than is often assumed. Of those that compile, up to 89\u2009% run without error. Indeed a few mutants are improvements. Program fitness landscapes are smoother. Analysis of these programs, a parallel nVidia GPGPU kernel, all CUDA samples and the GNU C library shows many lines of code and integer values are repeated and may follow Zipf\u2019s law.", "num_citations": "30\n", "authors": ["541"]}
{"title": "Why'building blocks' don't work on parity problems\n", "abstract": " We investigate the distribution of performance of the parity and always-on Boolean functions given only the appropriate building block. These problems have\\needle in a haystack\" tness landscape and so are unsuitable for genetic programming or other progressive search techniques. Theoretical analysis shows in the limit as program size grows the density of solutions is independent of size but falls exponentially with number of inputs.", "num_citations": "30\n", "authors": ["541"]}
{"title": "Genetic programming for improved receiver operating characteristics\n", "abstract": " Genetic programming (GP) can automatically fuse given classifiers of diverse types to produce a combined classifier whose Receiver Operating Characteristics (ROC) are better than [Scott et al.1998b]\u2019s \u201cMaximum Realisable Receiver Operating Characteristics\u201d (MRROC). I.e. better than their convex hull. This is demonstrated on a satellite image processing bench mark using Naive Bayes, Decision Trees (C4.5) and Clementine artificial neural networks.", "num_citations": "29\n", "authors": ["541"]}
{"title": "Genetic improvement of software for multiple objectives\n", "abstract": " Genetic programming (GP) can increase computer program\u2019s functional and non-functional performance. It can automatically port or refactor legacy code written by domain experts. Working with programmers it can grow and graft (GGGP) new functionality into legacy systems and parallel Bioinformatics GPGPU code. We review Genetic Improvement (GI) and SBSE research on evolving software.", "num_citations": "28\n", "authors": ["541"]}
{"title": "Markov chain models of bare-bones particle swarm optimizers\n", "abstract": " We apply a novel theoretical approach to better understand the behaviour of different types of bare-bones PSOs. It avoids many common but unrealistic assumptions often used in analyses of PSOs. Using finite element grid techniques, it builds a discrete Markov chain model of the BB-PSO which can approximate it on arbitrary continuous problems to any precision. Iterating the chain's transition matrix gives precise information about the behaviour of the BB-PSO at each generation, including the probability of it finding the global optimum or being deceived. The predictions of the model are remarkably accurate and explain the features of Cauchy, Gaussian and other sampling distributions.", "num_citations": "28\n", "authors": ["541"]}
{"title": "Evolving better RNAfold structure prediction\n", "abstract": " Grow and graft genetic programming (GGGP) evolves more than 50000 parameters in a state-of-the-art C program to make functional source code changes which give more accurate predictions of how RNA molecules fold up. Genetic improvement updates 29% of the dynamic programming free energy model parameters. In most cases (50.3%) GI gives better results on 4655 known secondary structures from RNA_STRAND (29.0% are worse and 20.7% are unchanged). Indeed it also does better than parameters recommended by Andronescu, M., et\u00a0al.: Bioinformatics 23(13) (2007) i19\u2013i28.", "num_citations": "26\n", "authors": ["541"]}
{"title": "Pfeiffer\u2013A distributed open-ended evolutionary system\n", "abstract": " Pfeiffer contains a population of fractals which has been evolving continuously for more than three years. The animations are developed from embryos using a Lindenmayer grammar (L-System). These open generative representations potentially allow gene duplication and the evolution of higher order genetic operators and might be a step towards the emergence of social intelligence in swarms of artificial life (alife) agents. The fitness function is simply do the snowflake patterns appeal to the users: interactive evolution (IEC). To this end, images are placed in animated snow globes (computerised snowstorms) by world wide web (www) browsers (Netscape, Mozilla, Internet Explorer, Firefox, etc.) anywhere on the planet. More than 600 people have used http://www. cs. ucl. ac. uk/staff/W. Langdon/pfeiffer. html.", "num_citations": "26\n", "authors": ["541"]}
{"title": "The distribution of reversible functions is Normal\n", "abstract": " The distribution of reversible programs tends to a limit as their size increases. For problems with a Hamming distance fitness function the limiting distribution is binomial with an exponentially small chance (but non-zero) chance of perfect solution. Sufficiently good reversible circuits are more common. Expected RMS error is also calculated. Random unitary matrices may suggest possible extension to quantum computing. Using the genetic programming (GP) bench-mark, the six multiplexor, circuits of Toffoli gates are shown to give a fitness landscape amenable to evolutionary search. Minimal CCNOT solutions to the six multiplexer are found but larger circuits are more evolvable.", "num_citations": "26\n", "authors": ["541"]}
{"title": "Convergence rates for the distribution of program outputs\n", "abstract": " Fitness distributions (landscapes) of programs tend to a limit as they get bigger. Markov chain convergence theorems give general upper bounds on the linear program sizes needed for convergence. Tight bounds (exponential in N, N log N and smaller) are given for five computer models (any, average, cyclic, bit flip and Boolean). Mutation randomizes a genetic algorithm population in", "num_citations": "26\n", "authors": ["541"]}
{"title": "Evolving receiver operating characteristics for data fusion\n", "abstract": " It has been suggested that the \u201cMaximum Realisable Receiver Operating Characteristics\u201d for a combination of classifiers is the convex hull of their individual ROCs [Scott et al., 1998]. As expected in at least some cases better ROCs can be produced. We show genetic programming (GP) can automatically produce a combination of classifiers whose ROC is better than the convex hull of the supplied classifier\u2019s ROCs.", "num_citations": "26\n", "authors": ["541"]}
{"title": "Better trained ants for genetic programming\n", "abstract": " The problem of programming an arti cial ant to follow the Santa Fe trail has been repeatedly used as a benchmark problem in GP. Recently we have shown performance of several techniques is not much better than the best performance obtainable using uniform random search. We suggested that this could be because the program tness landscape is di cult for hill climbers and the problem is also di cult for Genetic Algorithms as it contains multiple levels of deception. Here we rede ne the problem so the ant is (1) obliged to traverse the trail in approximately the correct order,(2) to nd food quickly. We also investigate (3) including the ant's speed in the tness function, either as a linear addition or as a second objective in a multi-objective tness function, and (4) GP one point crossover.", "num_citations": "26\n", "authors": ["541"]}
{"title": "On the ability to search the space of programs of standard, one-point and uniform crossover in genetic programming\n", "abstract": " In this paper we study and compare the search properties of di erent crossover operators in genetic programming (GP) using probabilistic models and experiments to assess the amount of genetic material exchanged between the parents to generate the o spring. These operators are: standard crossover, one-point crossover and a new operator, uniform crossover. Our analysis suggests that standard crossover is a local and biased search operator not ideal to explore the search space of programs e ectively. One-point crossover is better in some cases as it is able to perform a global search at the beginning of a run, but it su ers from the same problems as standard crossover later on. Uniform crossover largely overcomes these limitations as it is global and less biased.", "num_citations": "26\n", "authors": ["541"]}
{"title": "Continuous optimisation theory made easy? Finite-element models of evolutionary strategies, genetic algorithms and particle swarm optimizers\n", "abstract": " We propose a method to build discrete Markov chain models of continuous stochastic optimisers that can approximate them on arbitrary continuous problems to any precision. We discretise the objective function using a finite element method grid which produces corresponding distinct states in the search algorithm. Iterating the transition matrix gives precise information about the behaviour of the optimiser at each generation, including the probability of it finding the global optima or being deceived. The approach is tested on a (1\u2009+\u20091)-ES, a bare bones PSO and a real-valued GA . The predictions are remarkably accurate.", "num_citations": "25\n", "authors": ["541"]}
{"title": "Genetic programming and data structures\n", "abstract": " This thesis investigates the evolution and use of abstract data types within Genetic Programming (GP). In genetic programming the principles of natural evolution (fitness based selection and recombination) acts on program code to automatically generate computer programs. The research in this thesis is motivated by the observation from software engineering that data abstraction (eg via abstract data types) is essential in programs created by human programmers. We investigate whether abstract data types can be similarly beneficial to the automatic production of programs using GP. GP can automatically\" evolve\" programs which solve non-trivial problems but few experiments have been reported where the evolved programs explicitly manipulate memory and yet memory is an essential component of most computer programs. So far work on evolving programs that explicitly use memory has principally used either\u00a0\u2026", "num_citations": "25\n", "authors": ["541"]}
{"title": "A review of theoretical and experimental results on schemata in genetic programming\n", "abstract": " Schemata and the schema theorem, although criticised, are often used to explain why genetic algorithms (GAs) work. A considerable research effort has been produced recently to extend the GA schema theory to Genetic Programming (GP). In this paper we review the main results available to date in the theory of schemata for GP and some recent experimental work on schemata.", "num_citations": "24\n", "authors": ["541"]}
{"title": "Fitness causes bloat in variable size representations\n", "abstract": " We argue based upon the numbers of representations of given length, that increase in representation length is inherent in using a xed evaluation function with a discrete but variable length representation. Two examples of this are analysed, including the use of Price's Theorem. Both examples con rm the tendency for solutions to grow in size is caused by tness based selection.", "num_citations": "24\n", "authors": ["541"]}
{"title": "Genetic improvement of programs\n", "abstract": " Genetic programming can optimise software, including: evolving test benchmarks, generating hyper-heuristics by searching meta-heuristics, generating communication protocols, composing telephony systems and web services, generating improved hashing and C++ heap managers, redundant programming and even automatic bug fixing. Particularly in embedded real-time or mobile systems, there may be many ways to trade off expenses (such as time, memory, energy, power consumption) vs. Functionality. Human programmers cannot try them all. Also the best multi-objective Pareto trade off may change with time, underlying hardware and network connection or user behaviour. It may be GP can automatically suggest different trade offs for each new market. Recent results include substantial speed up by evolving a new version of a program customised for a special case.", "num_citations": "22\n", "authors": ["541"]}
{"title": "The halting probability in von Neumann architectures\n", "abstract": " Theoretical models of Turing complete linear genetic programming (GP) programs suggest the fraction of halting programs is vanishingly small. Convergence results proved for an idealised machine, are tested on a small T7 computer with (finite) memory, conditional branches and jumps. Simulations confirm Turing complete fitness landscapes of this type hold at most a vanishingly small fraction of usable solutions.", "num_citations": "22\n", "authors": ["541"]}
{"title": "An estimation of distribution algorithm based on maximum entropy\n", "abstract": " Estimation of distribution algorithms (EDA) are similar to genetic algorithms except that they replace crossover and mutation with sampling from an estimated probability distribution. We develop a framework for estimation of distribution algorithms based on the principle of maximum entropy and the conservation of schema frequencies. An algorithm of this type gives better performance than a standard genetic algorithm (GA) on a number of standard test problems involving deception and epistasis (i.e.\u00a0Trap and NK).", "num_citations": "22\n", "authors": ["541"]}
{"title": "Convergence of program fitness landscapes\n", "abstract": " Point mutation has no effect on almost all linear programs. In two genetic programming (GP) computers (cyclic and bit flip) we calculate the fitness evaluations needed using steepest ascent and first ascent hill climbers and evolutionary search. We describe how the average fitness landscape scales with program length and give general bounds.", "num_citations": "22\n", "authors": ["541"]}
{"title": "Genetic programming for combining neural networks for drug discovery\n", "abstract": " We have previously shown [Langdon and Buxton, 2001b] on a range of benchmarks genetic programming (GP) can automatically fuse given classifiers of diverse types to produce a combined classifier whose Receiver Operating Characteristics (ROC) are better than [Scott et al., 1998]\u2019s \u201cMaximum Realisable Receiver Operating Characteristics\u201d (MRROC). i.e. better than their convex hull. Here our technique is used in a blind trial where artificial neural networks are trained by Clementine on P450 pharmaceutical data. Using just the networks, GP automatically evolves a composite classifier.", "num_citations": "22\n", "authors": ["541"]}
{"title": "Using data structures within genetic programming\n", "abstract": " Provision of appropriately structured memory is shown, in some cases, to be advantageous to genetic programming (GP) in comparison with directly addressable indexed memory.Three\\classic\" problems are solved. The rst two require the GP to distinguish between sentences that are in a context free language and those that are not given positive and negative training examples of the language. The two languages are, correctly nested brackets and a Dyck language (correctly nested brackets of di erent types). The third problem is to evaluate integer Reverse Polish (post x) expressions. Comparisons are made between GP attempting to solve these problems when provided with indexed memory or with stack data structures.", "num_citations": "22\n", "authors": ["541"]}
{"title": "Visualising the search landscape of the triangle program\n", "abstract": " High order mutation analysis of a software engineering benchmark, including schema and local optima networks, suggests program improvements may not be as hard to find as is often assumed. (1) Bit-wise genetic building blocks are not deceptive and can lead to all global optima. (2) There are many neutral networks, plateaux and local optima, nevertheless in most cases near the human written C source code there are hill climbing routes including neutral moves to solutions.", "num_citations": "21\n", "authors": ["541"]}
{"title": "Evolving regular expressions for GeneChip probe performance prediction\n", "abstract": " Affymetrix High Density Oligonuclotide Arrays (HDONA) simultaneously measure expression of thousands of genes using millions of probes. We use correlations between measurements for the same gene across 6685 human tissue samples from NCBI\u2019s GEO database to indicated the quality of individual HG-U133A probes. Low concordance indicates a poor probe. Regular expressions can be data mined by a Backus-Naur form (BNF) context-free grammar using strongly typed genetic programming written in gawk and using egrep. The automatically produced motif is better at predicting poor DNA sequences than an existing human generated RE, suggesting runs of Cytosine and Guanine and mixtures should all be avoided.", "num_citations": "20\n", "authors": ["541"]}
{"title": "Global distributed evolution of L-systems fractals\n", "abstract": " Internet based parallel genetic programming (GP) creates fractal patterns like Koch\u2019s snow flake. Pfeiffer, http://www.cs.ucl.ac.uk/staff/W.Langdon/pfeiffer.html, by analogy with seed/embryo development, uses Lindenmayer grammars and LOGO style turtle graphics written in Javascript and Perl. 298 novel pictures were produced. Images are placed in animated snow globes (computerised snowstorms) by www web browsers anywhere on the planet. We discuss artificial life (Alife) evolving autonomous agents and virtual creatures in higher dimensions from a free format representation in the context of neutral networks, gene duplication and the evolution of higher order genetic operators.", "num_citations": "20\n", "authors": ["541"]}
{"title": "Fitness causes bloat: Simulated annealing, hill climbing and populations\n", "abstract": " In many cases programs length's increase (known as\" bloat\",\" fluff\" and increasing\" structural complexity\") during artificial evolution. We show bloat is not specific to genetic programming and suggest it is inherent in search techniques with discrete variable length representations using simple static evaluation functions. We investigate the bloating characteristics of three nonpopulation and one population based search techniques using a novel mutation operator. An artificial ant following the Santa Fe trail problem is solved by simulated annealing, hill climbing, strict hill climbing and population based search using two variants of the the new subtree based mutation operator. As predicted bloat is observed when using unbiased mutation and is absent in simulated annealing and both hill climbers when using the length neutral mutation however bloat occurs with both mutations when using a population. We conclude that there are two causes of bloat. 1 Introduction In earlier work [Lan...", "num_citations": "20\n", "authors": ["541"]}
{"title": "Genetic programming\n", "abstract": " Welcome to genetic programming, where the forces of nature are used to automatically evolve computer programs. We give a flavour of where GP has been successfully applied (it is far too wide an area to cover everything) and interesting current and future research but start with a tutorial of how to get started and finish with common pitfalls to avoid.", "num_citations": "19\n", "authors": ["541"]}
{"title": "Unexpected presence of mycoplasma probes on human microarrays\n", "abstract": " Mycoplasma and Microarray Mycoplasma contamination of cultured cells alters gene expression by adversely affecting cellular physiology. Because the presence of mycoplasma in cultures can be difficult to detect, contaminated cell lines may unintentionally be used in microarray evaluation, leading to confounded data analysis and erroneous conclusions regarding the patterns of gene expression. In a letter to the editor, M. Arno and colleagues at King's College London describe their identification of a probeset on the Affymetrix HG-U133 Plus 2.0 human microarray (1570561_at) that unexpectedly mapped to the 16S\u201323S intergenic transcribed spacer (ITS) region of multiple mycoplasma species. This sequence was originally submitted as an unknown Homo sapiens expressed sequence tag acquired during a full-length cDNA sequencing project, which the authors suspect might explain its inclusion on the human\u00a0\u2026", "num_citations": "19\n", "authors": ["541"]}
{"title": "Emergent behaviour, population-based search and low-pass filtering\n", "abstract": " In recent work we have formulated a model of emergent coordinated behaviour for a population of interacting entities. The model is a modified spring mass model where masses can perceive the environment and generate external forces. As a result of the interactions the population behaves like a single organism moving under the effect the vector sum of the external forces generated by each entity. When such forces are proportional to the gradient of a resource distribution f(x), the resultant force controlling the single emergent organism is proportional to the gradient of a modified food distribution. This is the result of applying a filtering kernel to f(x). The kernel is typically a low-pass filter. This model can be applied to genetic algorithms (GAs) and other population-based search algorithms. For example, in previous research, we have found kernels (via genetic programming) that allow the single organism model to\u00a0\u2026", "num_citations": "18\n", "authors": ["541"]}
{"title": "Repeated patterns in tree genetic programming\n", "abstract": " We extend our analysis of repetitive patterns found in genetic programming genomes to tree based GP.               As in linear GP, repetitive patterns are present in large numbers. Size fair crossover limits bloat in automatic programming, preventing the evolution of recurring motifs. We examine these complex properties in detail: e.g. using depth v.\u00a0size Catalan binary tree shape plots, subgraph and subtree matching, information entropy, syntactic and semantic fitness correlations and diffuse introns. We relate this emergent phenomenon to considerations about building blocks in GP and how GP works.", "num_citations": "17\n", "authors": ["541"]}
{"title": "GECCO-2002: Proceedings of the Genetic and Evolutionary Computation Conference: a Joint Meeting of the Seventh Annual Genetic Programming Conference (GP-2002) and the Eleventh\u00a0\u2026\n", "abstract": " These proceedings contain the papers presented at the fourth annual Genetic and Evolutionary Computation conference (GECCO-2002). The conference was held in New York City, July 9\u201313, 2002. own proceedings). ECI was specifically designed to deal with both learning and disseminating widely within commerce and manufacturing the numerous benefits of using all manner of evolutionary approaches to solve practical problems. Third, the introduction of best at GECCO prizes.", "num_citations": "16\n", "authors": ["541"]}
{"title": "Measuring facial emotional expressions using genetic programming\n", "abstract": " Genetic Programming techniques can be used to produce regression equations that quantify emotional expressions on a facial model. The formulae give emotional scores based on the position of 25 automatically generated \u00eclandmarks\u00ee on the face. The method shown here is an integrated part of a system that maps multidimensional data sets to naturalistic visual structures such as a face.", "num_citations": "16\n", "authors": ["541"]}
{"title": "Evolving GeneChip correlation predictors on parallel graphics hardware\n", "abstract": " A GPU is used to datamine five million correlations between probes within Affymetrix HG-U133A probesets across 6685 human tissue samples from NCBIpsilas GEO database. These concordances are used as machine learning training data for genetic programming running on a Linux PC with a RapidMind OpenGL GLSL backend. GPGPU is used to identify technological factors influencing high density oligonuclotide arrays (HDONA) performance. GP suggests mismatch (PM/MM) and adenosine/guanine ratio influence microarray quality. Initial results hint that Watson-Crick probe self hybridisation or folding is not important. Under GPGPGPU an nVidia GeForce 8800 GTX interprets 300 million GP primitives/second (300 MGPops, approx 8 GFLOPS).", "num_citations": "15\n", "authors": ["541"]}
{"title": "GECCO-2001: Proceedings of the Genetic and Evolutionary Computation Conference: a Joint Meeting of the Sixth Annual Genetic Programming Conference (GP-2001) and the Tenth\u00a0\u2026\n", "abstract": " These proceedings contain the papers presented at the third annual Genetic and Evolutionary Computation conference (GECCO-2001). The conference was held in San Francisco, California, on July 7-11, 2001.", "num_citations": "15\n", "authors": ["541"]}
{"title": "Directed crossover within genetic programming\n", "abstract": " This paper describes in detail a mechanism used to bias the choice of crossover locations when evolving a list data structure using genetic programming. The data structure and it evolution will be described by RN/95/70.", "num_citations": "15\n", "authors": ["541"]}
{"title": "Pareto, population partitioning, price and genetic programming\n", "abstract": " A description of a use of Pareto optimality in genetic programming is given and an analogy with Genetic Algorithm tness niches is drawn. Techniques to either spread the population across many pareto optimal tness values or to reduce the spread are described. It is speculated that a wide spread may not aid Genetic Programming. It is suggested that this might give useful insight into many GPs whose tness is composed of several sub-objectives. The successful use of demic populations in GP leads to speculation that smaller evolutionary steps might aid GP in the long run. An example is given where Price's covariance theorem helped when designing a GP tness function.", "num_citations": "15\n", "authors": ["541"]}
{"title": "Genetically improved barraCUDA\n", "abstract": " BarraCUDA is an open source C program which uses the BWA algorithm in parallel with nVidia CUDA to align short next generation DNA sequences against a reference genome. Recently its source code was optimised using \u201cGenetic Improvement\u201d. The genetically improved (GI) code is up to three times faster on short paired end reads from The 1000 Genomes Project and 60% more accurate on a short BioPlanet.com GCAT alignment benchmark. GPGPU BarraCUDA running on a single K80 Tesla GPU can align short paired end nextGen sequences up to ten times faster than bwa on a 12 core server. The speed up was such that the GI version was adopted and has been regularly downloaded from SourceForge for more than 12 months.", "num_citations": "14\n", "authors": ["541"]}
{"title": "Widespread existence of uncorrelated probe intensities from within the same probeset on Affymetrix GeneChips\n", "abstract": " We have developed a computational pipeline to analyse large surveys of A ymetrix GeneChips, for example NCBI\u2019s Gene Expression Omnibus. GEO samples data for many organisms, tissues and phenotypes. Because of this experimental diversity, any observed correlations between probe intensities can be associated either with biology that is robust, such as common co-expression, or with systematic biases associated with the GeneChip technology. Our bioinformatics pipeline integrates the mapping of probes to exons, quality control checks on each GeneChip which identifies flaws in hybridization quality, and the mining of correlations in intensities between groups of probes. The output from our pipeline has enabled us to identify systematic biases in GeneChip data. We are also able to use the pipeline as a discovery tool for biology. We have discovered that in the majority of cases, A ymetrix probesets on\u00a0\u2026", "num_citations": "14\n", "authors": ["541"]}
{"title": "Evolutionary solo pong players\n", "abstract": " An Internet Java Applet http://www.cs.essex.ac.uk/staff/poli/SoloPong/ allows users anywhere to play the Solo Pong game. We compare people's performance to a hand coded \"optimal\" player and programs automatically produced by computational intelligence. The computational intelligence techniques are: genetic programming, including a hybrid of GP and a human designed algorithm, and a particle swarm optimiser. The computational intelligence approaches are not fine tuned. GP and PSO find good players. Evolutionary computation (EC) is able to beat both human designed code and human players.", "num_citations": "14\n", "authors": ["541"]}
{"title": "Evolution of genetic programming populations\n", "abstract": " WB Langdon Genetic Programming Group, Dept. of Computer Science, University College, London, Gower Street, London WC1E 6BT, UK Email: W. Langdon@ cs. ucl. ac. uk www: http://www. cs. ucl. ac. uk/sta/W. Langdon/Tel:+ 44 (0) 171 380 7214, Fax:+ 44 (0) 171 387 1397", "num_citations": "14\n", "authors": ["541"]}
{"title": "Improving SSE parallel code with grow and graft genetic programming\n", "abstract": " RNAfold predicts the secondary structure of RNA molecules from their base sequence. We apply a mixture of manual and automated genetic improvements to its C source. GI gives a 1.6% improvement to parallel SSE4. 1 code. The automatic programming evolutionary system has access to Intel library code and previous revisions. On 4 666 curated structures from RNA_STRAND, GGGP gives a combined speed up of 31.9%, with no loss of accuracy (GI code run 1.4 10 11 times).", "num_citations": "13\n", "authors": ["541"]}
{"title": "Long-term evolution of genetic programming populations\n", "abstract": " Evolving binary mux-6 trees for up to 100 000 generations, during which some programs grow to more than a hundred million nodes, suggests the landscape which GP explores contains some very smooth regions. Although the GP population evolves under crossover, our unbounded GP appears not to evolve building blocks. We do see periods of tens even hundreds of generations where even although each member of the population occupies a different point in the genotypic search space, they are lie at exactly the same point in the phenotypic landscape. Phenotypic convergence whilst retaining genotypic diversity is typical of GP and, we suggest inherent in highly redundant variable length representations.", "num_citations": "12\n", "authors": ["541"]}
{"title": "Backward-chaining genetic programming\n", "abstract": " This paper presents a backward-chaining version of GP.", "num_citations": "12\n", "authors": ["541"]}
{"title": "Understanding particle swarm optimisation by evolving problem landscapes\n", "abstract": " Genetic programming (GP) is used to create fitness landscapes, which highlight strengths, and weaknesses of different types of PSO and to contrast population-based swarm approaches with non stochastic gradient followers (i.e. hill climbers). These automatically generated benchmark problems yield insights into the operation of PSOs, illustrate benefits and drawbacks of different population sizes and constriction (friction) coefficients, and reveal new swarm phenomena such as deception and the exploration/exploitation tradeoff. The method could be applied to any type of optimizer.", "num_citations": "12\n", "authors": ["541"]}
{"title": "Predicting biochemical interactions-human p450 2d6 enzyme inhibition\n", "abstract": " In silico screening of chemical libraries or virtual chemicals may reduce drug discovery and medicine optimisation lead times and increase the probability of success by directing search through chemical space. About a dozen intelligent pharmaceutical QSAR modelling techniques were used to predict IC50 concentration (three classes) of drug interaction with a cell wall enzyme (P450 CYC2D6). Genetic programming gave comprehensible cheminformatics models which generalised best. This was shown by a blind test on Glaxo Welcome molecules of machine learning knowledge nuggets mined from SmithKline Beecham compounds. Performance on similar chemicals (interpolation) and diverse chemicals (extrapolation) suggest generalisation is more difficult than avoiding over fitting. Two GP approaches, classification via regression using a multiobjective fitness measure and a direct winner takes all (WTA) or one\u00a0\u2026", "num_citations": "12\n", "authors": ["541"]}
{"title": "Better trained ants\n", "abstract": " The problem of programming an artificial ant to follow the Santa Fe trail has been repeatedly used as a benchmark problem. Recently we have shown performance of several techniques is not much better than the best performance obtainable using uniform random search. We suggested that this could be because the program fitness landscape is difficult for hill climbers and the problem is also difficult for Genetic Algorithms as it contains multiple levels of deception.", "num_citations": "12\n", "authors": ["541"]}
{"title": "Evolving DNA motifs to predict GeneChip probe performance\n", "abstract": " Affymetrix High Density Oligonuclotide Arrays (HDONA) simultaneously measure expression of thousands of genes using millions of probes. We use correlations between measurements for the same gene across 6685 human tissue samples from NCBI's GEO database to indicated the quality of individual HG-U133A probes. Low correlation indicates a poor probe. Regular expressions can be automatically created from a Backus-Naur form (BNF) context-free grammar using strongly typed genetic programming. The automatically produced motif is better at predicting poor DNA sequences than an existing human generated RE, suggesting runs of Cytosine and Guanine and mixtures should all be avoided.", "num_citations": "11\n", "authors": ["541"]}
{"title": "The Genetic Programming Collaboration Network and its Communities\n", "abstract": " Useful information about scientific collaboration structures and patterns can be inferred from computer databases of published papers. The genetic programming bibliography is the most complete reference of papers on GP. In addition to locating publications, it contains coauthor and coeditor relationships from which a more complete picture of the field emerges. We treat these relationships as undirected small world graphs whose study reveals the community structure of the GP collaborative social network. Automatic analysis discovers new communities and highlights new facets of them. The investigation reveals many similarities between GP and coauthorship networks in other scientific fields but also some subtle differences such as a smaller central network component and a high clustering.", "num_citations": "11\n", "authors": ["541"]}
{"title": "On Turing complete T7 and MISC F--4 program fitnes landscapes\n", "abstract": " We use the minimal instruction set F-4 computer to define a minimal Turing complete T7 computer suitable for genetic programming (GP) and amenable to theoretical analysis. Experimental runs and mathematical analysis of the T7, show the fraction of halting programs is drops to zero as bigger programs are run.", "num_citations": "11\n", "authors": ["541"]}
{"title": "GECCO-2002\n", "abstract": " These proceedings contain the papers presented at the fourth annual Genetic and Evolutionary Computation conference (GECCO-2002). The conference was held in New York City, July 9\u201313, 2002.The GECCO series of international conferences are a unique series of events, drawing together in one time and place (and proceedings) the increasing diversity of evolutionary computational techniques. The conference is a truly global event, which this year attracted submissions from more than 27 countries across all continents. Although GECCO-2002 was the union of the Seventh Annual Genetic Programming Conference and the Eleventh International Conference on Genetic Algorithms, it included leading edge scientific work on many strands of research (from artificial life to software engineering from ant systems to scheduling, from evolutionary programming to philosophy), as well as real world applications and industrial computing. It is sponsored by the International Society for Genetic and Evolutionary Computation (ISGEC), and presented in cooperation with the American Association for Artificial Intelligence (AAAI).", "num_citations": "11\n", "authors": ["541"]}
{"title": "Evolving better software parameters\n", "abstract": " Genetic improvement might be widely used to adapt existing numerical values within programs. Applying GI to embedded parameters in computer code can create new functionality. For example, CMA-ES can evolve 1024 real numbers in a GNU C library square root to implement a cube root routine for\u00a0C.", "num_citations": "10\n", "authors": ["541"]}
{"title": "Optimising quantisation noise in energy measurement\n", "abstract": " We give a model of parallel distributed genetic improvement. With modern low cost power monitors; high speed Ethernet LAN latency and network jitter have little effect. The model calculates a minimum usable mutation effect based on the analogue to digital converter (ADC)\u2019s resolution and shows the optimal test duration is inversely proportional to smallest impact we wish to detect. Using the example of a 1\u00a0kHz 12\u00a0bit 0.4095 Amp ADC optimising software energy consumption we find: it will be difficult to detect mutations which an average effect less than 58\u00a0A, and typically experiments should last well under a second.", "num_citations": "10\n", "authors": ["541"]}
{"title": "Performing with CUDA\n", "abstract": " Recently a GPGPU application had to be redesigned to overcome performance problems. A number of software engineering lessons were learnt from this and other projects. We describe those about obtaining high performance from nVidia GPUs and practical aspects of CUDA C software development.", "num_citations": "10\n", "authors": ["541"]}
{"title": "The distribution of amorphous computer outputs\n", "abstract": " Fitness distributions (landscapes) of programs tend to a limit as they get bigger. Markov minorization gives upper bounds ((15.3 + 2.30m)/ log I) on the length of program run on random or average computing devices. I is the size of the instruction set and m size of output register. Almost all programs are constants. Convergence is exponential with 90% of programs of length 1.6 n2N yielding constants (n = size input register and size of memory = N). This is supported by experiment.", "num_citations": "10\n", "authors": ["541"]}
{"title": "Continuous long-term evolution of genetic programming\n", "abstract": " We evolve floating point Sextic polynomial populations of genetic programming binary trees for up to a million generations. Programs with almost 400 000 000 instructions are created by crossover. To support unbounded Long-Term Evolution Experiment LTEE GP we use both SIMD parallel AVX 512 bit instructions and 48 threads to yield performance of up to 149 billion GP operations per second, 149 giga GPops, on a single Intel Xeon Gold 6126 2.60 GHz server.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Genetic improvement: A key challenge for evolutionary computation\n", "abstract": " Automatic Programming has long been a sub-goal of Artificial Intelligence (AI). It is feasible in limited domains. Genetic Improvement (GI) has expanded these dramatically to more than 100 000 lines of code by building on human written applications. Further scaling may need key advances in both Search Based Software Engineering (SBSE) and Evolutionary Computation (EC) research, particularly on representations, genetic operations, fitness landscapes, fitness surrogates, multi objective search and co-evolution.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Debugging cuda\n", "abstract": " During six months of intensive nVidia CUDA C programming many bugs were created. We pass on the software engineering lessons learnt, particularly those relevant to parallel general-purpose computation on graphics hardware GPGPU.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Minimising testing in genetic programming\n", "abstract": " The cost of optimisation can be reduced by evaluating candidate designs on only a fraction of all possible use cases. We show how genetic programming (GP) can avoid overfitting and evolve general solutions from fitness test suites as small as just one dynamic training case. Search effort can be greatly reduced.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Running genetic programming backwards\n", "abstract": " Backward chaining evolutionary algorithms (BC-EA) offer the prospect of run-time efficiency savings by reducing the number of fitness evaluations without significantly changing the course of genetic algorithm or genetic programming runs. \u201cTournament selection, iterated coupon-collection problem, and backward-chaining evolutionary algorithm,\u201d Poli, FOGA, 2005 describes how BC-EA does this by avoiding the generation and evaluation of individuals which never appear in selection tournaments. It suggests the largest savings occur in very large populations, short runs, small tournament sizes and shows actual savings in fixed-length binary GAS. Here, we provide a generational GP implementation, including mutation and two offspring crossover of BC-EA and empirically investigate its efficiency in terms of both fitness evaluations and effectiveness.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Repeated sequences in linear GP genomes\n", "abstract": " Biological chromosomes are replete with repetitive sequences, microsatellites, SSR tracts, ALU, etc. in their DNA base sequences. We discover hierarchical repeating sequences (building blocks?) are evolved by genetic programming in linear time series prediction programs.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Comparison of adaboost and genetic programming for combining neural networks for drug discovery\n", "abstract": " Genetic programming (GP) based data fusion and AdaBoost can both improve in vitro prediction of Cytochrome P450 activity by combining artificial neural networks (ANN). Pharmaceutical drug design data provided by high throughput screening (HTS) is used to train many base ANN classifiers. In data mining (KDD) we must avoid over fitting. The ensembles do extrapolate from the training data to other unseen molecules. I.e. they predict inhibition of a P450 enzyme by compounds unlike the chemicals used to train them. Thus the models might provide in silico screens of virtual chemicals as well as physical ones from Glaxo SmithKline (GSK)\u2019s cheminformatics database. The receiver operating characteristics (ROC) of boosted and evolved ensemble are given.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Natural language text classification and filtering with trigrams and evolutionary nearest neighbour classifiers\n", "abstract": " N grams o er fast language independent multi-class text categorization. Text is reduced in a single pass to ngram vectors. These are assigned to one of several classes by a) nearest neighbor (KNN) and b) genetic algorithm operating on weights in a nearest neighbour classi er. 91% accuracy is found on binary classi cation on short multi-author technical English documents. This falls if more categories are used but 69% is obtained with 8 classes.", "num_citations": "9\n", "authors": ["541"]}
{"title": "Genetic programming and databases\n", "abstract": " Genetic Programming (GP) is a means of automatically creating programs using a genetic algorithm (GA). Briefly a number of candidate programs are used starting points for a search through the space of possible programs looking for an acceptable program. New programs are created by random change to existing programs (known as mutation) or by combining elements", "num_citations": "9\n", "authors": ["541"]}
{"title": "Creating regular expressions as mRNA motifs with GP to predict human exon splitting\n", "abstract": " RNAnet [3] http://bioinformatics. essex. ac. uk/users/wlangdon/rnanet/allows the user to calculate correlations of gene expression, both between genes and between components within genes. We investigate all of Ensembl http://www. ensembl. org and find all the Homo Sapiens exons for which there are sufficient robust Affymetrix HG-U133 Plus 2 GeneChip probes. Calculating correlation between mRNA probe measurements for the same exon shows many exons whose components are consistently up regulated and down regulated. However we identify other Ensembl exons where sub-regions within them are self consistent but these transcript blocks are not well correlated with other blocks in the same exon. We suggest many current Ensembl exon definitions are incomplete. Secondly, having identified exon with substructure we use machine learning to try and identify patterns in the DNA sequence lying\u00a0\u2026", "num_citations": "8\n", "authors": ["541"]}
{"title": "Efficient markov chain model of machine code program execution and halting\n", "abstract": " This paper focuses on the halting probability and the number of instructions executed by programs that halt for Turing-complete assembly-like languages and register based machines. The halting probability represents the fraction of programs which provide useful results in a machine code genetic programming system. The number of instructions executed by halting programs determines run time and whether or not the distribution of program functionality has reached a fixed-point. We describe a sophisticated, but efficient, Markov chain model of program execution and halting which accurately fits and explains the empirical data allowing us to estimate the halting probability and the numbers of instructions executed for programs including millions of instructions in a few minutes. We also discuss how this model can be applied to improve GP practice.", "num_citations": "8\n", "authors": ["541"]}
{"title": "Genetic programming and evolvable machines at 20\n", "abstract": " The journal and in particular the resource reviews have been running for 20 years. We summarise the GP literature, including top papers and authors, as seen by users of the genetic programming bibliography. Then revisit our original goals for GPEM book reviews and compare them with what has achieved.", "num_citations": "7\n", "authors": ["541"]}
{"title": "Parallel GPQUICK\n", "abstract": " We modified GPQuick to use SIMD parallel floating point AVX 512 bit instructions and 48 threads to give up to 139 billion GP operations per second, 139 giga GPops, on a single Intel Xeon Gold 6126 2.60 GHz server. The multi-threaded single instruction multiple data genetic programming GP interpreter has evolved binary trees of more than 396 million instructions using subtree crossover and run populations for a million generations.", "num_citations": "7\n", "authors": ["541"]}
{"title": " In Silico Infection of the Human Genome\n", "abstract": " The human genetic sequence database contains DNA sequences very like those of mycoplasma bacteria. It appears such bacteria infect not only molecular Biology laboratories but their genes were picked up from contaminated samples and inserted into GenBank as if they were homo sapiens. At least one mouldy EST (Expressed Sequence Tag) has transferred from online public databases on the Internet to commercial tools (Affymetrix HG-U133 plus 2.0 microarrays). We report a second example (DA466599) and suggest there is a need to clean up genomic databases but fear current tools will be inadequate to catch genes which have jumped the silicon barrier.", "num_citations": "7\n", "authors": ["541"]}
{"title": "Mapping non-conventional extensions of genetic programming\n", "abstract": " Conventional genetic programming research excludes memory and iteration. We have begun an extensive analysis of the space through which GP or other unconventional AI approaches search and extend it to consider explicit program stop instructions (T8), including Markov analysis and any time models (T7). We report halting probability, run time and functionality (including entropy of binary functions) of both halting and anytime programs. Irreversible Turing complete program fitness landscapes, even with halt, scale poorly however loops lock-in variation allowing more interesting functions.", "num_citations": "7\n", "authors": ["541"]}
{"title": "Kernel methods for PSOs\n", "abstract": " We report initial experiments on evolving kernel functions which describe the average behaviour of a swarm of particles as if it was responding as a single point moving on a landscape transformed by the kernel. Such kernels may help explain swarm and population approaches leading to extended population systems, XPS. The swarm of particles are from a simple particle swarm optimiser solving one dimensional multi-modal 3 peaks and Rastrigin problems. The standard Java genetic programming implementation TinyGP is used.", "num_citations": "7\n", "authors": ["541"]}
{"title": "Long random linear programs do not generalize\n", "abstract": " The chance of solving a problem by random search of long linear programs tends to a limit as their size increases. When all outputs are equally used this limit is no more than 2\u2212|test set|. The chance of randomly finding a long linear general solution is exponentially small.", "num_citations": "7\n", "authors": ["541"]}
{"title": "Size fair tree crossovers\n", "abstract": " Size fair crossover genetic operator for tree based genetic programming is described and tested. It produces considerably reduced increases in program size and no detrimental effect on GP performance. GP search spaces are partitioned by the ridge in the number of program v. their size and depth. A ramped uniform random initialisation is described which straddles the ridge. With subtree crossover trees increase about one level per generation leading to sub-quadratic bloat in length.", "num_citations": "7\n", "authors": ["541"]}
{"title": "Faster genetic programming GPquick via multicore and advanced vector extensions\n", "abstract": " We evolve floating point Sextic polynomial populations of genetic programming binary trees for up to a million generations. Programs with almost four hundred million instructions are created by crossover. To support unbounded Long-Term Evolution Experiment LTEE GP we use both SIMD parallel AVX 512 bit instructions and 48 threads to yield performance of up to 139 billion GP operations per second, 139 giga GPops, on a single Intel Xeon Gold 6126 2.60GHz server.", "num_citations": "6\n", "authors": ["541"]}
{"title": "Which is faster: bowtie2GP bowtie > bowtie2 > BWA\n", "abstract": " We have recently used genetic programming to automatically generate an improved version of Langmead's DNA read alignment tool Bowtie2 [RN/12/09, Sect. 5.3]. We find it runs more than four times faster than the Bioinformatics sequencing tool (BWA) currently used with short next generation paired end DNA sequences by the Cancer Institute, takes less memory and yet finds similar matches in the human genome.", "num_citations": "6\n", "authors": ["541"]}
{"title": "Spatial defects in 5896 HG-U133A GeneChips\n", "abstract": " Motivation: Modern biology has moved from a science of individual measurements to a science where data are collected on an industrial scale. Foremost amongst the new tools for biochemistry are chip arrays which, in one operation, measure hundreds of thousands or even millions of DNA sequences or RNA transcripts. Whilst this is impressive, increasingly sophisticated analysis tools have been required to convert gene array data into gene expression levels. Despite the assumption that noise levels are low, since the number of measurements for an individual gene is small, identifying which signals are affected by noise is a priority.Results: 5896 raw data (Affymetrix CEL) files were obtained from ftp://ftp. ebi. ac. uk/pub/databases/microarray/data/experiment/TABM/E-TABM-185/Each CEL file was checked for spatial errors. In HG-U133A high-density oligonucleotide array (HDONAs) the mean error rate is only 1.6% which is amongst the best for human GeneChips. However some locations are much more error prone than others, with up to 28% of probes being affected. Removal of erroneous data improves breast cancer survival prediction.", "num_citations": "6\n", "authors": ["541"]}
{"title": "Dissipative polynomials\n", "abstract": " Limited precision floating point computer implementations of large polynomial arithmetic expressions are nonlinear and dissipative. They are not reversible (irreversible, lack conservation), lose information, and so are robust to perturbations (anti-fragile) and resilient to fluctuations. This gives a largely stable locally flat evolutionary neutral fitness search landscape. Thus even with a large number of test cases, both large and small changes deep within software typically have no effect and are invisible externally. Shallow mutations are easier to detect but their RMS error need not be simple.", "num_citations": "5\n", "authors": ["541"]}
{"title": "Incremental Evaluation in Genetic Programming.\n", "abstract": " Often GP evolves side effect free trees. These pure functional expressions can be evaluated in any order. In particular they can be interpreted from the genetic modification point outwards. Incremental evaluation exploits the fact that: in highly evolved children the semantic difference between child and parent falls with distance from the syntactic disruption (eg crossover point) and can reach zero before the whole child has been interpreted. If so, its fitness is identical to its parent (mum). Considerable savings in bloated binary tree GP runs are given by exploiting population convergence with existing GPquick data structures, leading to near linear O (gens) runtime. With multi-threading and SIMD AVX parallel computing a 16 core desktop can deliver the equivalent of 571 billion GP operations per second, 571 giga GPop/s. GP convergence is viewed via information theory as evolving a smooth landscape and software plasticity. Which gives rise to functional resilience to source code changes. On average a mixture of 100+,-,\u00d7 and (protected)\u00f7 tree nodes remove test case effectiveness at exposing changes and so fail to propagate crossover infected errors.", "num_citations": "5\n", "authors": ["541"]}
{"title": "Evolving square root into binary logarithm\n", "abstract": " Genetic improvement can adapt numbers to create new functionality. Expanding prior work in which Covariance Matrix Adaptation Evolution Strategy algorithm (CMA-ES) converted a GNU C library sqrt into cbrt, we show (with suitable objective function) the same GGGP framework can find a double precision binary logarithm log2 for C by adjusting 512 floats", "num_citations": "5\n", "authors": ["541"]}
{"title": "Evolving better RNAfold C source code\n", "abstract": " Grow and graft genetic programming (GGGP) can automatically evolve an existing state-of-the art program to give more accurate predictions of the secondary structures adapted by RNA molecules using their base sequence alone. That is, genetic improvement (GI) can make functional as well as non-functional source code changes.", "num_citations": "5\n", "authors": ["541"]}
{"title": "Initial experiences of the emerald: e-infrastructure south GPU supercomputer\n", "abstract": " The Emerald supercomputer contains more than a thousand CPU cores and several hundred nVidia Tesla. A genetic programming GeneChip datamining application which searches for non-linear gene based prediction of long term survival following breast cancer surgery was transferred without change and run on part of the Emerald cluster. At 7 giga GPopS\u2212 1 it is the fastest ever genetic programming application of this type.", "num_citations": "5\n", "authors": ["541"]}
{"title": "Generalisation in genetic programming\n", "abstract": " Genetic programming can evolve large general solutions using a tiny fraction of possible fitness test sets. Just one test may be enough.", "num_citations": "5\n", "authors": ["541"]}
{"title": "RNAnet a map of human gene expression\n", "abstract": " RNAnet provides a bridge between two widely used Human gene databases. Ensembl describes DNA sequences and transcripts but not experimental gene expression. Whilst NCBI's GEO contains actual expression levels from Human samples. RNAnet provides immediate access to thousands of Affymetrix HG-U133 2plus GeneChip measurements Homo sapiens genes in most medically interesting tissues. Without RNAnet comparison across experiments in GEO is very labour intensive requiring man months of effort to down load and clean data. With RNAnet anyone can access cleaned quantile normalised data in seconds. It can be used to data mine patterns of co-expression. The network of strongly correlated genes is huge but sparse. Thousands of genes interact strongly with thousands of others. Conversely there are tens of thousands of genes which interact strongly with less than 100 others. I.e. RNAnet gives new views for RNA Systems Biology.", "num_citations": "5\n", "authors": ["541"]}
{"title": "A CUDA SIMT interpreter for genetic programming\n", "abstract": " A Single Instruction Multiple Thread CUDA interpreter provides SIMD like parallel evaluation of the whole GP population of quarter of a million RPN expressions on graphics cards and nVidia Tesla T10P. Using sub-machine code GP a sustain peak performance of 212 billion GP operations per second (3300 speed up) and an average of 4.5 peta GP ops per day is reported for a single card on a Boolean induction benchmark never attempted before, let alone solved.", "num_citations": "5\n", "authors": ["541"]}
{"title": "An eigen analysis of the GP community\n", "abstract": " The coauthorship and coeditorship relations as recorded in the genetic programming bibliography provide a quantitative view of the GP community. Eigen analysis is used to find the principle components of the community. It shows the major eigenvalues and eigenvectors are responsible for 70% of the connection graph. Top eigen authors are given.", "num_citations": "5\n", "authors": ["541"]}
{"title": "The use of Affymetrix GeneChips as a tool for studying alternative forms of RNA\n", "abstract": " We are developing a computational pipeline to use surveys of Affymetrix GeneChips as a discovery tool for unravelling some of the biology associated with post-transcriptional processing of RNA. This work involves the integration of a number of bioinformatics resources, from comparing annotations to processing images to determining the structure of transcripts. The rapidly growing datasets of GeneChips available to the community puts us in a strong position to discover novel biology about post-transcriptional processing, and should enable us to determine the mechanisms by which some groups of genes make co-ordinated changes in their production of isoforms.", "num_citations": "5\n", "authors": ["541"]}
{"title": "Mapping non-conventional extensions of genetic programming\n", "abstract": " Conventional genetic programming research excludes memory and iteration. We have begun an extensive analysis of the space through which GP or other unconventional AI approaches search and extend it to consider explicit program stop instructions (T8) and any time models (T7). We report halting probability, run time and functionality (including entropy of binary functions) of both halting and anytime programs. Turing complete program fitness landscapes, even with halt, scale poorly.", "num_citations": "5\n", "authors": ["541"]}
{"title": "Solving even-12,-13,-15,-17,-20 and-22 boolean parity problems using sub-machine code GP with smooth uniform crossover, smooth point mutation and demes\n", "abstract": " In this paper we describe a recipe to solve very large parity problems, using GP without automatically defined functions. The recipe includes three main ingredients: smooth uniform crossover (a crossover operator inspired by theoretical research), sub-machine-code GP (a technique which allows speeding up fitness evaluation in Boolean classification problems by nearly 2 orders of magnitude), and distributed demes (weakly interacting sub-populations running on separate workstations). We tested this recipe on parity problems with up to 22 input variables (ie where the fitness function includes 2 22= 4; 194; 304 fitness cases), solving them with a very high success probability. 1 Introduction The even-n-parity functions have long been recognised as difficult problems for induction algorithms such as genetic programming (GP) to solve, and for this reason have been widely used as benchmark tests ([6],[7],[4],[21],[5],[1],[18],[19]). For an even-parity function of order n (tha...", "num_citations": "5\n", "authors": ["541"]}
{"title": "Fitness first\n", "abstract": " Subtree to be inserted (black) is evaluated on all test cases and values are transferred to evaluation of mum. Use incremental evaluation, so differences between original code (white subtree) and new (unborn) are propagated up 1st parent (mum) until either all differences are zero or we reach the root node.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Genetic improvement of genetic programming\n", "abstract": " GISMOE BNF grammar based GI is applied to optimise run time of the tree interpreter in the fastest single computer floating point genetic programming system, GPavx. Up to two fold speed up is obtained. Performance varies with tree size. The GI version of Singleton's C++ GPquick is demonstrated on random trees of up to 79 million opcodes on Intel AVX512 SIMD parallel compute servers.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Automatically Evolving Lookup Tables for Function Approximation.\n", "abstract": " Many functions, such as square root, are approximated and sped up with lookup tables containing pre-calculated values. We introduce an approach using genetic algorithms to evolve such lookup tables for any smooth function. It provides double precision and calculates most values to the closest bit, and outperforms reference implementations in most cases with competitive run-time performance.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Fast generation of big random binary trees\n", "abstract": " random_tree() is a linear time and space C++ implementation able to create trees of up to a billion nodes for genetic programming and genetic improvement experiments. A 3.60GHz CPU can generate more than 18 million random nodes for GP program trees per second.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Genetic improvement of data gives binary logarithm from sqrt\n", "abstract": " Automated search in the form of the Covariance Matrix Adaptation Evolution Strategy (CMA-ES), plus manual code changes, transforms 512 Newton-Raphson floating point start numbers from an open source GNU C library, glibc, table driven square root function to create a new bespoke custom mathematical implementation of double precision binary logarithm log2 for C in seconds.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Genetic improvement\n", "abstract": " Genetic Improvement Page 1 Lancaster University, School of Computing and Communications, 2nd March 2020 Genetic Improvement GGGP WB Langdon Computer Science, University College London 27.2.2020 Humies http://www.human-competitive.org/ Human-Competitive results $10,000 prizes GECCO-2020 in Cancun, Mexico Email 29 May goodman@msu.edu EP/M025853/1 GI: A Comprehensive Survey Page 2 Genetic Improvement GGGP WB Langdon Computer Science, University College London Humies http://www.human-competitive.org/ Human-Competitive results $10,000 prizes GECCO-2020 in Cancun, Mexico Email 29 May goodman@msu.edu EP/M025853/1 GI: A Comprehensive Survey Page 3 Genetic Improvement of Software \u2022 What is Genetic Improvement \u2013 Optimisation, eg. Genetic Programming (GP), on existing code \u2022 What has Genetic Improvement done \u2013 Technology behind automatic \u2026", "num_citations": "4\n", "authors": ["541"]}
{"title": "How computers are learning to make human software work more efficiently\n", "abstract": " Computer scientists have a history of borrowing ideas from nature, such as evolution. When it comes to optimising computer programs, a very interesting evolutionary-based approach has emerged over the past five or six years that could bring incalculable benefits to industry and eventually consumers. We call it genetic improvement.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Correlation of microarray probes give evidence for mycoplasma contamination in human studies\n", "abstract": " At least 473 Affymetrix HG-U133+ 2 Homosapiens probes match one or more species of mycoplasma. Analysis of published data from thousands of human GeneChips finds correlations in homo sapiens studies between different microbiology laboratories in different countries which suggests contamination with mycoplasma is the common factor. This high lights the problem of experts in evolutionary computation needing to apply due diligence before relying on public medical datasets. Caveat emptor even if the data are free!", "num_citations": "4\n", "authors": ["541"]}
{"title": "Creating and debugging performance CUDA C\n", "abstract": " Various practical ways of testing, locating and removing bugs in parallel general-purpose computation on graphics hardware GPGPU applications are described. Some of these are generic whilst other relate directly to stochastic bioinspired techniques, such as genetic programming. We pass on software engineering lessons learnt during CUDA C programming and ways to obtain high performance from nVidia GPU and Tesla cards including examples of both successful and less successful recent applications.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Evolving gzip matches kernel from an nVidia CUDA template\n", "abstract": " Rather than attempting to evolve a complete program from scratch we demonstrate genetic interface programming by automatically generating a parallel CUDA kernel with identical functionality to existing highly optimised ancient sequential C code. Generic GPGPU nVidia kernel C++ code is converted into a BNF grammar. Strongly typed genetic programming uses the BNF to generate compilable and executable graphics card kernels. Their fitness is given by running the population on a GPU with randomised subsets of training data itself given by running the original code\u2019s test suite.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Scaling of program functionality\n", "abstract": " The distribution of fitness values (landscapes) of programs tends to a limit as the programs get bigger. We use Markov chain convergence theorems to give general upper bounds on the length of programs needed for convergence. How big programs need to be to approach the limit depends on the type of the computer they run on. We give bounds (exponential in N, N\u00a0log\u00a0N and smaller) for five computer models: any, average or amorphous or random, cyclic, bit flip and four functions (AND, NAND, OR and NOR). Programs can be treated as lookup tables which map between their inputs and their outputs. Using this we prove similar convergence results for the distribution of functions implemented by linear computer programs. We show most functions are constants and the remainder are mostly parsimonious. The effect of ad-hoc rules on genetic programming (GP) are described and new heuristics are proposed\u00a0\u2026", "num_citations": "4\n", "authors": ["541"]}
{"title": "Finding social landscapes for PSOs via kernels\n", "abstract": " Particle swarm optimiser and genetic algorithm populations are macro-organisms, which perceive their environment as if filtered via a kernel. The kernel assimilates each individual's sensory abilities so that the collective moves using a greedy hill-climbing strategy. This model is fitted to data collected in real PSO and GA runs by using genetic programming to evolve the kernel. In nature animals tend to live within groups. The social interactions effectively transform the fitness selection landscape seen by an isolated individual. In some cases a group behaves (or even can be said to think) like a single organism. Kernels provide a lens which coarse-grains or averages individual senses and so may help explain joint actions and social responses. The original multi-modal problem is smoothed by convolving it with a problem specific filter designed by GP. Because populations see the transformed social fitness\u00a0\u2026", "num_citations": "4\n", "authors": ["541"]}
{"title": "Evolution of force-generating equations for PSO using GP\n", "abstract": " We extend our previous research on evolving the physical forces which control particle swarms by considering additional ingredients, such as the velocity of the neighbourhood best and time, and different neighbourhood topologies, namely the global and local ones. We test the evolved extended PSOs (XPS) on various classes of benchmark problems.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Genetic programming\n", "abstract": " In this volume we present the contributions for the 18th European Conference on Genetic Programming (EuroGP 2005). The conference took place from 30 March to 1 April in Lausanne, Switzerland. EuroGP is a well-established conference and the only one exclusively devoted to genetic programming. All previous proceedings were published by Springer in the LNCS series. From the outset, EuroGP has been co-located with the EvoWorkshops focusing on applications of evolutionary computation. Since 2004, EvoCOP, the conference on evolutionary combinatorial optimization, has also been co-located with EuroGP, making this year\u2019s combined events one of the largest dedicated to evolutionary computation in Europe.Genetic programming (GP) is evolutionary computation that solves complex problems or tasks by evolving and adapting a population of computer programs, using Darwinian evolution and\u00a0\u2026", "num_citations": "4\n", "authors": ["541"]}
{"title": "Random Search is Parsimonious.\n", "abstract": " We model in detail the distribution of Boolean functions implemented by random non-recursive programs, similar to linear genetic programming. Most functions are constants, the remainder are mostly simple.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Genetic programming in europe\n", "abstract": " Genetic Programming (GP) is becoming a leading area of computer science in which Europe has a number of very active researchers which are now all gathered in the EvoGP working group. In this report we describe the state of the art in GP technology, the role Europe has in advancing it and the activities of the EvoGP working group. We indicate the likely bene ts of this technology now and in the near future and we make recommendations for future European research.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Quick Intro to simple-gp. c\n", "abstract": " Wouldn't it be great if computers could actually write the programs? This is the promise of genetic programming. This document gives an introduction to the program simple-gp. c which demonstrates the principles of genetic programming in the C language. This program was designed to show the ideas behind GP, ie to be tinkered with rather than to be a de nitive implementation.", "num_citations": "4\n", "authors": ["541"]}
{"title": "Software robustness: a survey, a theory, and prospects\n", "abstract": " If a software execution is disrupted, witnessing the execution at a later point may see evidence of the disruption or not. If not, we say the disruption failed to propagate. One name for this phenomenon is software robustness but it appears in different contexts in software engineering with different names. Contexts include testing, security, reliability, and automated code improvement or repair. Names include coincidental correctness, correctness attraction, transient error reliability. As witnessed, it is a dynamic phenomenon but any explanation with predictive power must necessarily take a static view. As a dynamic/static phenomenon it is convenient to take a statistical view of it which we do by way of information theory. We theorise that for failed disruption propagation to occur, a necessary condition is that the code region where the disruption occurs is composed with or succeeded by a subsequent code region that\u00a0\u2026", "num_citations": "3\n", "authors": ["541"]}
{"title": "Multi-threaded memory efficient crossover in C++ for generational genetic programming\n", "abstract": " C++ code snippets from a multi-core parallel memory-efficient crossover for genetic programming are given here . They may be adapted for separate generation evolutionary algorithms where large chromosomes or small RAM require no more than M + 2 x nthreads simultaneously active individuals.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Genetic Improvement of Data gives double precision invsqrt\n", "abstract": " CMA-ES plus manual code changes rapidly transforms 512 Newton-Raphson start points from a GNU C library table driven version of sqrt into a double precision reciprocal square root function. The GI x-1/2 is far more accurate than Quake's InvSqrt, Quare root.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Evolving AVX512 parallel C code using GP\n", "abstract": " Using 512\u00a0bit Advanced Vector Extensions, previous development history and Intel documentation, BNF grammar based genetic improvement automatically ports RNAfold to AVX, giving up\u00a0to a 1.77 fold speed up. The evolved code pull request is an accepted GI software maintenance update to bioinformatics package                      ViennaRNA                                        .", "num_citations": "3\n", "authors": ["541"]}
{"title": "Genetic improvement GISMOE blue software tool demo\n", "abstract": " The GISMO Backus-Naur Form BNF grammar based Genetic Improvement (GI) system demonstration shows artificial evolutionary computation reducing run time of blue. cpp, a noddy C program to count how many blue pixels there are in an image. http://www. cs. ucl. ac. uk/staff/W. Langdon/ftp/gp-code/opencv gp. tar. gz", "num_citations": "3\n", "authors": ["541"]}
{"title": "Distilling genechips with GP on the emerald GPU supercomputer\n", "abstract": " The Emerald supercomputer contains 1008 x86 CPU cores and 372 nVidia M2090 Tesla. A CUDA GPGPU genetic programming GeneChip datamining application which searches for non-linear gene expression based prediction of long term survival following breast cancer surgery was transferred without change and run on part of the Emerald cluster. An average of 33 giga GPopS-1 was achieved.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Elementary bit string mutation landscapes\n", "abstract": " Genetic Programming parity with only XOR is not elementary. GP parity can be represented as the sum of k/2+ 1 elementary landscapes. Statistics, including fitness distance correlation (FDC), of Parity's fitness landscape are calculated. Using Walsh analysis the eigen values and eigenvectors of the Laplacian of the two bit, three bit, n-bit and mutation only Genetic Algorithm fitness landscapes are given. Indeed all elementary bit string landscapes are related to the discrete Fourier functions. However most are rough (\u03bb/d\u2248 1). Also in many cases fitness autocorrelation falls rapidly with distance. GA runs support eigenvalue/graph degree (\u03bb/d) as a measure of the ruggedness of elementary landscapes for predicting problem difficulty. The elementary needle in a haystack (NIH) landscape is described.", "num_citations": "3\n", "authors": ["541"]}
{"title": "A map of human gene expression\n", "abstract": " We have calculated the correlation between most human genes, using thousands of public Affymetrix HG-U133 +2 high-density oligonucleotide array (HDONAs). The correspondences show highly structured interactions between EBI Ensembl exons across a wide range of tissues and disease states taken from NCBI GEO. Eigen values are used to find and display the principle components of the gene expression mRNA data. The PCA analysis suggests almost all genes interact in a connected graph. There are thousands of strongly interacting genes but the whole network is sparse, with many genes not correlating strongly. So far, few power laws typical of \u201csmall world\u201d networks and anticipated in gene regulatory networks have been found. The approx 300 million correlations are organised by gene/exon and are available via a web interface.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Communication, leadership, publicity and group formation in particle swarms\n", "abstract": " We look at how the structure of social networks and the nature of social interactions affect the behaviour of Particle Swarms Optimisers. To this end, we propose a general model of communication and consensus which focuses on the effects of social interactions putting the details of the dynamics and the optimum seeking behaviour of PSOs into the background.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Natural language text classification with trigrams and evolutionary nearest neighbour classifiers\n", "abstract": " N grams offer fast language independent multi-class text categorization. Text is reduced in a single pass to ngram vectors. These are assigned to one of several classes by a) nearest neighbor (KNN) and b) genetic algorithm operating on weights in a nearest neighbour classifier. 91% accuracy is found on binary classification on short multi-author technical English documents. This falls if more categories are used but 69% is obtained with 8 classes. Zipf law is found not to apply to trigrams.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Short term extinction probability of newly created schemata, and schema variance and signal-to-noise-ratio theorems in the presence of schema creation\n", "abstract": " This paper rst analyses the impact of variance on schema transmission. Working from an exact derivation of the expected variance in schema transmission, it derives and analyses the signal-to-noise ratio for schemata. The paper then presents short term schema transmission probability results that focus on newly created schemata in the population. The analysis reveals the relative dependencies between schema transmission, population size, schema measured tness, schema fragility and schema creation.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Scheduling planned maintenance of electrical power transmission networks using genetic algorithms\n", "abstract": " The maintenance of the electrical power transmission networks must be planned in advance so as to minimise costs taking into account: location and size of demand for electricity, generator capacities and availabilities, electricity carrying capacity of the remainder of the network, ie that part not undergoing maintenance, resilience of the network to faults (contingencies).", "num_citations": "3\n", "authors": ["541"]}
{"title": "Price's Theorem and the MAX Problem\n", "abstract": " We present a detailed analysis of the evolution of GP populations using the problem of nding a program which returns the maximum possible value for a given terminal and function set and a depth limit on the program tree (known as the MAX problem). We con rm the basic message of Gathercole and Ross, 1996] that crossover together with program size restrictions can be responsible for premature convergence to a sub-optimal solution. We show that this can happen even when the population retains a high level of variety and show that in many cases evolution from the sub-optimal solution to the solution is possible if su cient time is allowed. In both cases theoretical models are presented and compared with actual runs.Experimental evidence is presented that Price's Covariance and Selection Theorem can be applied to GP populations and the practical e ect of program size restrictions are noted. Finally we show that covariance between gene frequency and tness in the rst few generations can be used to predict the course of GP runs.", "num_citations": "3\n", "authors": ["541"]}
{"title": "Evolving sqrt into 1/x via software data maintenance\n", "abstract": " While most software automation research concentrates on programs' code, we have started investigating if Genetic Improvement (GI) of data can assist developers by automating aspects of the maintenance of parameters embedded in source code. We extend recent GI work on optimising compile time constants to give new functionality and describe the transformation of a GNU C library square root function into the double precision reciprocal function, drcp. Multiplying by 1/x (drcp) allows division free division without requiring the hardware to support division. The evolution (6 seconds) and indeed the GI dp division (7.14\u00b10.012 nS) are both surprisingly fast.", "num_citations": "2\n", "authors": ["541"]}
{"title": "Improved CUDA 3D medical image registration\n", "abstract": " A combination of manual and genetic improvement (GI) can optimise a critical component of NiftyReg healthcare industry software across a diverse range of six nVidia graphics processing units (GPUs). The improved K20c kernel gives a speed up> 2000 fold compared to released code on a 3GHz CPU.", "num_citations": "2\n", "authors": ["541"]}
{"title": "2-bit flip mutation elementary fitness landscapes\n", "abstract": " Genetic Programming parity is not elementary. GP parity cannot be represented as the sum of a small number of elementary landscapes. Statistics, including fitness distance correlation, of Parity's fitness landscape are calculated. Using Walsh analysis the eigen values and eigenvectors of the Laplacian of the two bit flip fitness landscape are given and a ruggedness measure for elementary landscapes is proposed. An elementary needle in a haystack (NIH) landscape is given.", "num_citations": "2\n", "authors": ["541"]}
{"title": "Evo_indent interactive evolution of GNU indent options\n", "abstract": " Evo_Indent http://www. dcs. kcl. ac. uk/staff/W. Langdon/evo_indent/is a PHP web server based user driven genetic algorithm which finds good C code layouts generated by GNU indent. Either the refactored source can be used or the user's preferred indent command options can be saved and re-used to pretty print other program text files.", "num_citations": "2\n", "authors": ["541"]}
{"title": "Row quantile normalisation of microarrays\n", "abstract": " Variation in tissue sample preparation leads to variation across the Transcriptome not just between experiments but to between individual microarrays. Normalisation is essential before data from different arrays can be compared. Quantile normalisation can be used to force data from a single GeneChip to take a given distribution. However quantile normalisation can be blind to the consistent spatial variation we note in thousands of Affymetrix\u2019High-density oligonucleotide array (HDONAs) from NCBI GEO. We propose a simple computationally efficient normalisation technique which takes into account the spatial aspect. BioConductor R code is included.", "num_citations": "2\n", "authors": ["541"]}
{"title": "Bibliography on genetic programming\n", "abstract": " @Bibtex-file{Ai/genetic.programming.bib, title = \"Bibliography on Genetic Programming\", author-1 = \"Steven M. Gustafson\", email-1 = \"smg@cs.nott.ac.uk\", author-2 = \"William Langdon\", email-2 = \"WBLangdon@cs.bham.ac.uk\", author-3 = \"John Koza\", email-3 = \"koza@smi.stanford.edu\", supported = \"yes\", abstract = \"A nearly complete bibliography of papers published on Genetic Programming\", readme = \"Compiled by W. Langdon and John Koza with lots of help from the GP mailing list. The bibliography also contains some pre-1990 papers on using GAs to produce programs. It is actively being extended, please send any new references to WBLangdon@cs.bham.ac.uk or \\htmladdnormallink{add entries using an HTML form} {http://www.cs.ucl.ac.uk/cgi-bin/external/W.Langdon/WBT.cgi}. Any comments on either the bibliography or the way it is set up would also be most welcome. I would like to have on line \u2026", "num_citations": "2\n", "authors": ["541"]}
{"title": "Web usage of the GP bibliography\n", "abstract": " A recent upgrade to the Genetic Programming bibliography enables monitoring of its www usage. Downloads are dominated by automated software robotic agents (web bots), particularly Yahoo and other search engine spiders. These are very variable and cast doubt that some world wide web hits statistics relate to people. Some 62% of GP papers are on line. PDF is twice as common as postscript. On average papers in the cache can be downloaded in two seconds.", "num_citations": "2\n", "authors": ["541"]}
{"title": "Information loss leads to robustness\n", "abstract": " Figure 2 shows a large nested function composed of floating point arithmetic operations (+,-,\u00d7 and\u00f7). Each function acts as a two input information funnel and loses information. The red subtree at the base of Figure 2 is a bug and the coloured chain shows the execution of nested functions which call the bug. The whole function is executed on 48 test cases and the size of the coloured nodes represents the number of tests when the error and the correct code are not identical at that point in the execution. The colour of these nodes represents the average difference. In this example, the error is visible on all the tests at the function immediately after it. However the number of test cases where the evaluation is not identical relentlessly falls as we move up the chain of coloured nodes towards the outer most function. Indeed, in this example, it falls to zero before we reach the end of the expression. Meaning none of the test cases are able to detect the error.Obviously the loss of information and details of error hiding will depend on the details of the expression and test suite. Nonetheless in functional parts of the code, the monotonic fall in the effectiveness of testing with distance from the error is always true and holds regardless of whether the error is caused by a bug in the source code or a runtime induced fault. Preliminary results hint that the effectiveness of test suites increases only slowly with the number of tests (in proportion to log of the number of tests) and suggests that independent tests are more effective at uncovering faults.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Genetic programming convergence\n", "abstract": " We study both genotypic and phenotypic convergence in GP floating point continuous domain symbolic regression over thousands of generations. Subtree fitness variation across the population is measured and shown in many cases to fall. In an expanding region about the root node, both genetic opcodes and function evaluation values are identical or nearly identical. Bottom up (leaf to root) analysis shows both syntactic and semantic (including entropy) similarity expand from the outermost node. Despite large regions of zero variation, fitness continues to evolve and near zero crossover disruption suggests improved GP systems within existing memory use.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Fitness first and fatherless crossover\n", "abstract": " When programs are very large and fitness evaluation is fast (eg due to evaluating only a tiny fraction of the program) it can be efficient to evaluate fitness before creating the program, as only individuals with children need be created. The saving can be> 50% and even in highly converged populations, it saves e\u2212 2= 13.5%. In GP crossover one child is created from two parents but the root donating parent (mum) contributes far more than the other (dad). The subtree from the father is usually small and can be extracted from each dad and saved before crossover. This gives single parent crossover, which when combined with fitness first, further reduces the number of crossovers. Even in the worst case the reduction is exp (-1)= 37 percent.With large trees, even in populations of similar fitness, eliminating bachelors and spinsters is feasible and can reduce both runtime and memory consumption. Storage in a (N) multi-threaded implementation for a population M is about 0.63 M+ N, compared to the usual M+ 2N, in practice saving\u2265 17%. We achieve 692 billion GP operations per second, 692 giga GPops, on an Intel i7-9800X 16 thread 3.8 GHz desktop (CPU bandwidth 85 GByte/second).", "num_citations": "1\n", "authors": ["541"]}
{"title": "Big data driven genetic improvement for maintenance of legacy software systems\n", "abstract": " Software is vital to modern life, yet much of it is old and suffers from bit-rot. There are not and never will be enough software experts to keep it all up to date by hand. Instead we suggest combining data driven learning with evolutionary search to maintain computer systems. @RE: <1>N. Alshahwan. Industrial experience of genetic improvement in Facebook. In J. Petke, S. H. Tan, W. B. Langdon, and W. Weimer, editors, GI-2019, ICSE workshops proceedings, page 1, Montreal, 28 May 2019. IEEE. Invited Keynote. <2>W. Banzhaf, P. Nordin, R. E. Keller, and F. D. Francone. Genetic Programming - An Introduction; On the Automatic Evolution of Computer Programs and its Applications. Morgan Kaufmann, San Francisco, CA, USA, Jan. 1998. <3>N. Hansen and A. Ostermeier. Completely derandomized self-adaptation in evolution strategies. Evolutionary Computation, 9(2):159--195, Summer 2001. <4>S. Haraldsson, A\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "CUDA RNAfold\n", "abstract": " We add CUDA GPU C program code to RNAfold to enable both it to be run on nVidia gaming graphics hardware and so that many thousands of RNA secondary structures can be computed in parallel. RNAfold predicts the folding pattern for RNA molecules by using O(n3) dynamic programming matrices to minimise the free energy of treating them as a sequence of bases. We benchmark RNAfold on RNA STRAND and artificial sequences of upto 30 000 bases on two GPUs and a GPGPU Tesla. The speed up is variable but up to 14 times.", "num_citations": "1\n", "authors": ["541"]}
{"title": "BarraCUDA in the Cloud\n", "abstract": " What is this, flying fishes? Well no. BarraCUDA is the name of a Bioinformatics program and the cloud in question is Microsoft\u2019s Azure, which is in the process of being upgraded with copious nVidia K80 tesla GPUs which support CUDA in instances of virtual machines. BarraCUDA has been around for a few years [1]. It is a port of BWA [2] which takes advantage of the massive parallelism available on graphics hardware (GPUs) to greatly speed up approximate matching of millions of short DNA strings against a reference genome. For example, the human reference genome [3]. Approximate matching is necessary, because of noise but primarily because the medical purpose of many DNA scans is to reveal differences between them and \u201cnormal\u201d(ie reference) DNA. A typical difference is to substitute one character for another, but tools like BarraCUDA also find matches where a character is inserted and where one is deleted. Although there are many sources of DNA data, BarraCUDA and similar programs are targeted at strings generated by \u201cNext Generation Sequencing\u201d(NGS) machines. These are amazing devices. A top end NGS machine is now capable of generating more than a billion DNA strings, sequences of A, C, G or T letters. Part of the trade-off for this speed is the strings are short (typically a hundred letters long) and noisy. The first step is to find where the short fragments of DNA came from by aligning the strings against a reference genome. To account for the various sources of noise, NGS is usually run with three fold redundancy and sometimes a particularly important part of a person\u2019s genome may be scanned ten or more times\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "Benchmarking BarraCUDA on Epigenetic DNA and nVidia Pascal GPUs\n", "abstract": " Typically BarraCUDA uses CUDA graphics cards to map DNA reads to the human genome. Previously its software source code was genetically miproved for short paired end next generation sequences. On longer, 150 base paired end noisy Cambridge Epigsnetix\u2019s data, a Pascal GTX 1080 proc esses about 10000 strings per second, comparable with twin nVidia Tesla K40.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Mycoplasma contamination in the 1000 genomes project\n", "abstract": " Mapping next generation DNA sequences from the thousand genome project against published genomes reveals many that match one or more Mycoplasma but are not included in the reference human genome GRCh37. p5. Many of these are of low quality but NCBI BLAST searches confirm some high quality, high entropy sequences match Mycoplasma but no human sequences. Suggesting at least 7% of 1000G samples are contaminated.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Uncovering the expression patterns of chimeric transcripts using surveys of Affymetrix GeneChips\n", "abstract": " Background: A chimeric transcript is a single RNA sequence which results from the transcription of two adjacent genes. Recent studies estimate that at least 4% of tandem human gene pairs may form chimeric transcripts. Affymetrix GeneChip data are used to study the expression patterns of tens of thousands of genes and the probe sequences used in these microarrays can potentially map to exotic RNA sequences such as chimeras.Results: We have studied human chimeras and investigated their expression patterns using large surveys of Affymetrix microarray data obtained from the Gene Expression Omnibus. We show that for six probe sets, a unique probe mapping to a transcript produced by one of the adjacent genes can be used to identify the expression patterns of readthrough transcripts. Furthermore, unique probes mapping to an intergenic exon present only in the MASK-BP3 chimera can be used directly\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "Genetic programming theory I & II\n", "abstract": " We start by describing and characterising the search space explored by genetic programming (GP). We show how to compute the size of the search space. Then, we introduce some work on the distribution of functionality of the programs in the search space and indicate its scientific and practical consequences. In particular, we explain why GP can work despite the immensity of the search space it explores. Then, we show recent theory on halting probability that extends these results to forms of Turing complete GP. This indicates that Turing complete GP has a hard time solving problems unless certain measures are put in place. Having characterised the search space, in the second part of the tutorial, we characterise GP as a search algorithm by using the schema theory. In the tutorial we introduce the basics of schema theory, explaining how one can derive an exact probabilistic description of GAs and GP based on\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "Genetic Programming for Drug Discovery\n", "abstract": " Genetic programming \\citekoza:book \\citebanzhaf:1997:book \\citelangdon:fogp is an established artificial intelligence technique which is used in many areas. Essentially it applies the older genetic algorithm technique \\citeholland:book \\citegoldberg:book to automatically generate programs. (See Figure 1.) The next section will introduce genetic programming, including a very short over view of the many areas where GP has been applied, before Section 4 concentrates on uses of genetic programming in the Pharmaceutical industry. We finish with a worked example (Section 5) which describes an evaluation of machine learning for predicting potential drugs\u2019 activity with an pharmaceutically important enzyme (Human cytochrome P450 2D6) made by GlaxoSmithKline chemists \\citelangdon:2001:wsc6, \\citelangdon:2002:EuroGP, \\citelangdon:2002:kdmdd, \\citelangdon:2002:iberamia, \\citehis02Plenary:Langdon, \\citelangdon:2003:CEC. Appendix A gives pointers to further information.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Efficient Markov chain model of machine code program execution and halting\n", "abstract": " We focus on the halting probability and the number of instructions executed by programs that halt for Turing-complete register based machines. The former represents the fraction of programs which provide useful results in a machine code genetic programming system. The latter determines run time and whether or not the distribution of program functionality has reached a fixed-point. We describe a Markov chain model of program execution and halting which accurately fits empirical data allowing us to efficiently estimate the halting probability and the numbers of instructions executed for programs including millions of instructions. We also discuss how this model can be applied to improve GP practice.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Predicting ten thousand bits from ten thousand inputs\n", "abstract": " Submachine code genetic programming and multiple classification GP runs are used to winow the predictive inputs and then evolve an entry to the WCCI-2007 binary time series prediction task held at the Congress on Evolutionary Computation (CEC-2006) held in Vancouver.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Evolving Benchmarks\n", "abstract": " Genetic programming (GP) is used to evolve global optimisation test problems. These automatically generated performance metrics are used to show strengths and weaknesses of Particle Swarm Optimization (PSO) and Differential Evolution (DE). Knowledge gained will help when choosing maximisers (and their tuning parameters) and in research into new search tools (which might include hyperheuristics).", "num_citations": "1\n", "authors": ["541"]}
{"title": "Lindenmayer systems fractals evolved by Pfeiffer 10 September\u20139 November 2003\n", "abstract": " Pfeiffer http://www.cs.ucl.ac.uk/staff/W.Langdon/pfeiffer.html is an interactive JavaScript based system for evolving fractal patterns similar to Koch\u2019s snow flake. All patterns evolved during a two month trial period during the Autumn of 2003 are given. This research note should be viewed as an appendix to: \\citelangdon:2004:EuroGP and \\citelangdon:2005:metas. %\\citelangdon:2004:full", "num_citations": "1\n", "authors": ["541"]}
{"title": "Genetic Algorithms\u2014Principles and Perspectives, A Guide to GA Theory by Colin R. Reeves and Jonathan E. Rowe, Kluwer Academic Publishers, 332 pp., $120.00, ISBN 1-4020-7240-6\n", "abstract": " //static.cambridge.org/content/id/urn%3Acambridge.org%3Aid%3Aarticle%3AS026988890423020X/resource/name/firstPage-S0269888904000207a.jpg", "num_citations": "1\n", "authors": ["541"]}
{"title": "Predicting cancer\n", "abstract": " Computers are being used to evolve predictors based on DNA gene chips. Recently we have evolved programs that use mRNA extracted from cancerous cells to try to forecast patient outcomes.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Combining machine learning techniques to predict compounds\u2019 cytochrome P450 high throughput screening inhibition\n", "abstract": " Combining Machine Learning techniques to Predict Compounds\u2019 Cytochrome P450 High Throughput Screening Inhibition WB Langdon Page 1 Combining Machine Learning techniques to Predict Compounds\u2019 Cytochrome P450 High Throughput Screening Inhibition WB Langdon, BF Buxton and SJ Barrett University College, London W.Langdon@cs.ucl.ac.uk GlaxoSmithKline Steven.J.Barrett@gsk.com 0 Page 2 Model of P450 showing membrane attachment 1 Page 3 Compute Electro/Chemical/Structural Features Example Compound (vitamin B1) The primary chemical structure is used to calculate 699 features for use in predicting activity of compounds. Individually none of these features are able to predict activity with P450. 2 Page 4 Combined Classifier via 2 Stages: Clementine. Genetic Programming or Boosting Data mining tool Clementine used to train Neural Networks 699 features split into 15 related groups (\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "Fitness Landscapes\n", "abstract": " The idea of fitness landscapes, firstly proposed in genetics by Sewall Wright [Wright, 1932], is well established in artificial evolution. They are a metaphor used to help visualise problems. In the metaphor landscapes are viewed as being like an area of countryside. Looking vertically down from a great height the countryside appears like a map. This corresponds to the area to be searched. That is, the plan view is the search space.", "num_citations": "1\n", "authors": ["541"]}
{"title": "The genetic programming search space\n", "abstract": " We shall investigate how the space of all possible programs, i e the space which genetic programming searches, scales. Particularly how it changes with respect to the size of programs We will show, in general, that above some problem dependent threshold, considering all programs, their fitness shows little variation with their size. The distribution of fitness levels, particularly the distribution of solutions, gives us directly the performance of random search. We can use this as a benchmark against which to compare GP and other techniques. These results are demonstrated in this chapter using a combination of enumeration and Monte Carlo sampling. For the interested reader, formal proofs are given in Chapter 8. Informal; arguments are presented in Section 7.5 to extend our results to modular GP, memory and Turing complete GP. Section 7.6 considers the relationship between tree size and depth for various\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "Problems with ROC convex hulls\n", "abstract": " \\URLhttp://www. cs. ucl. ac. uk/staff/W. Langdon/roc. ps. gz email: W. Langdon@ cs. ucl. ac. uk keywords: convex hull, ROC, Receiver Operating Characteristics file:/papers/faraday/eurogp2001/roc. tex r1. 15 and roc. bbl r1. 9 size: 3 pages notes: Scott BMVC 1998", "num_citations": "1\n", "authors": ["541"]}
{"title": "Genetic Programming Approach to Benelearn 99: II\n", "abstract": " We briefly describe our first genetic programming technique used to automatically evolve profiles of potential insurance customers the task is part of the Benelearn 99 competition. The information about customers consists of 86 variables and includes product usage data and socio-demographic data derived from zip codes. The data was supplied by the Dutch data mining company Sentient Machine Research, and is based on real world business data. Profiles which correctly identified more than 50% of customers were automatically evolved using genetic programming.", "num_citations": "1\n", "authors": ["541"]}
{"title": "Evolution of GP Populations\n", "abstract": " In this chapter we investigate in detail what happens as GP populations evolve. We start in Section 8.1 by showing Price\u2019s covariance and selection theorem can be applied to artificial evolution. Following the proof of the theorem with experimental justification using the GP runs on the stack problem described in Chapter 4. Section 8.2 briefly describes Fisher\u2019s fundamental theorem of natural selection and shows in its normal interpretation it does not apply to genetic algorithms. The failure of most GP runs on the stack problem to find programs which pass the whole fitness test is explained in Section 8.3 by the presence of \u201cdeceptive\u201d high scoring partial solutions in the population. These cause a negative correlation between necessary primitives and fitness. As Price\u2019s theorem predicts, their frequency falls, eventually leading to their extinction and so to the impossibility of finding solutions like those that are\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}
{"title": "Genetic Programming\n", "abstract": " In this volume are the proceedings of the fourth European conference on Genetic Programming (EuroGP 2001) which took place at Lake Como in Italy on April, 18\u201320 2001. EuroGP has become firmly established as the premier European event devoted to Genetic Programming. EuroGP began life in 1998 as an international workshop and was held in Paris (14\u201315 April, LNCS 1391). After that it was held in G\u00f6teborg, Sweden (26\u201327 May 1999, LNCS 1598). Its first appearance as a conference was last year in Edinburgh in Scotland (15\u201316 April, LNCS 1802). Each year EuroGP has been co-located with a series of specialist workshops (LNCS 1468, 1596, 1803). This year was no exception and EvoWorkshops 2001 were also held at Lake Como (18-19 April, LNCS 2037). Genetic Programming (GP) refers to a branch of Evolutionary Computation in which computer programs are automatically generated over a period of time using a process that mimics Darwinian evolution. The 30 papers in these proceedings more than amply demonstrate the wide and varied applicability of GP. There are papers that apply GP to robotics, artificial retina, character recognition, financial prediction, digital filter and electronic circuit design, image processing, data fusion, and biosequencing. In addition there are many papers that address foundational and theoretical issues. A rigorous double-blind refereeing system was applied to the 42 submitted papers. This resulted in 17 plenary talks (40% of those submitted) and 13 research posters. Every submitted paper was reviewed by a minimum of two members of the International Program Committee, and if there was\u00a0\u2026", "num_citations": "1\n", "authors": ["541"]}