{"title": "Quality analysis of source code comments\n", "abstract": " A significant amount of source code in software systems consists of comments, i. e., parts of the code which are ignored by the compiler. Comments in code represent a main source for system documentation and are hence key for source code understanding with respect to development and maintenance. Although many software developers consider comments to be crucial for program understanding, existing approaches for software quality analysis ignore system commenting or make only quantitative claims. Hence, current quality analyzes do not take a significant part of the software into account. In this work, we present a first detailed approach for quality analysis and assessment of code comments. The approach provides a model for comment quality which is based on different comment categories. To categorize comments, we use machine learning on Java and C/C++ programs. The model comprises different\u00a0\u2026", "num_citations": "148\n", "authors": ["80"]}
{"title": "Semantic clone detection for model-based development of embedded systems\n", "abstract": " With model-based development becoming an increasingly common development methodology in embedded systems engineering, models have become an important asset of the the software development process. Therefore, techniques for the automatic detection of clones in those models have been developed to improve their maintainability. As these approaches currently only consider syntactic clones, the detection of clones is limited to syntactically equivalent copies. Using the concept of normal forms, these approaches can be extended to also cover semantic clones with identical behavior but different structure. The submission presents a generalized concept of clones for Simulink models, describes a pattern-based normal-form approach, and discusses results of the application of an implementation of this approach.", "num_citations": "55\n", "authors": ["80"]}
{"title": "Index-based model clone detection\n", "abstract": " Existing algorithms for model clone detection operate in batch mode. Consequently, if a small part of a large model changes during maintenance, the entire detection needs to be recomputed to produce updated cloning information. Since this can take several hours, the lack of incremental detection algorithms hinders clone management, which requires up-to-date cloning information. In this paper we present an index-based algorithm for model clone detection that is incremental and distributable. We present a case study that demonstrates its capabilities, outline its current limitations and present directions for future work.", "num_citations": "45\n", "authors": ["80"]}
{"title": "Using network analysis for recommendation of central software classes\n", "abstract": " As a new developer, getting to know a large unknown software system is a challenging task. If experienced developers are available, they can suggest which classes to read first, helping new developers to quickly grasp the system's most fundamental concepts. In practice, however, experienced developers often are no longer available. In these cases, the set of most important classes must be reverse engineered. This paper presents a thorough analysis of using different network analysis metrics on dependency graphs to retrieve central classes. An empirical study on four open source projects evaluates the results based on a survey among the systems' core developers. It demonstrates that the algorithmic results can compete with the suggestions of experienced developers.", "num_citations": "42\n", "authors": ["80"]}
{"title": "Acyclic type-of-relationship problems on the internet: an experimental analysis\n", "abstract": " An experimental study of the feasibility and accuracy of the acyclicity approach introduced in [14] for the inference of business relationships among autonomous systems (ASes) is provided. We investigate the maximum acyclic type-of-relationship problem: on a given set of AS paths, find a maximum-cardinality subset which allows an acyclic and valley-free orientation. Inapproximability and NP-hardness results for this problem are presented and a heuristic is designed. The heuristic is experimentally compared to most of the state-of-the-art algorithms on a reliable data set. It turns out that the proposed heuristic produces the least number of misclassified customer-to-provider relationships among the tested algorithms. Moreover, it is flexible in handling pre-knowledge in the sense that already a small amount of correct relationships is enough to produce a high-quality relationship classification. Furthermore, the reliable\u00a0\u2026", "num_citations": "23\n", "authors": ["80"]}
{"title": "Incremental origin analysis of source code files\n", "abstract": " The history of software systems tracked by version control systems is often incomplete because many file movements are not recorded. However, static code analyses that mine the file history, such as change frequency or code churn, produce precise results only if the complete history of a source code file is available. In this paper, we show that up to 38.9% of the files in open source systems have an incomplete history, and we propose an incremental, commit-based approach to reconstruct the history based on clone information and name similarity. With this approach, the history of a file can be reconstructed across repository boundaries and thus provides accurate information for any source code analysis. We evaluate the approach in terms of correctness, completeness, performance, and relevance with a case study among seven open source systems and a developer survey.", "num_citations": "19\n", "authors": ["80"]}
{"title": "Library concepts for model reuse\n", "abstract": " Reuse and the composition of libraries of partial system descriptions is a fundamental and well-understood practice in software engineering, as long as we talk about source code. For models and modeling languages, the concepts of reuse often are limited to copy & paste, especially when it comes to domain-specific modeling languages (DSLs). This paper attempts to give an overview of techniques for including support for reuse and library concepts both in the meta-model and the modeling tool, and presents a novel generative approach for this task. The technical consequences for each of the approaches presented are discussed and compared to each other.", "num_citations": "16\n", "authors": ["80"]}
{"title": "A generalized Wedelin heuristic for integer programming\n", "abstract": " A very important ingredient for solving hard general integer programs are heuristics that try to quickly find good feasible solutions. One of these heuristics is Wedelin's algorithm, which works for the limited class of 0-1 integer programs. A big advantage of Wedelin's approach is that it does not depend on a solution of the linear programming (LP) relaxation as many other heuristics do. This makes it extremely fast in practice and makes it easy to use the parallelism of the upcoming multicore CPUs, as in an integer programming (IP) solver it could be applied in parallel to the traditional branch-and-bound algorithm. In this paper, we present several extensions and generalizations to Wedelin's algorithm (most can be handled in an implicit manner without much performance cost) and investigate different ways of improving it. We give all necessary details and parameters. We strive for an algorithm that is faster than other\u00a0\u2026", "num_citations": "15\n", "authors": ["80"]}
{"title": "Integrated behavior models for factory automation systems\n", "abstract": " Despite the large amount of models for different aspects of factory automation systems, many of these models target at individual and in most cases static aspects of the system, such as the geometry or its electric parts. There is a lack of suitable description methods, which integrate these individual models to a behavior model including spatial aspects and the handling of material. Furthermore, it is important that this model keeps the link to the more detailed individual models and is sufficiently formal in order to allow an automated analysis. This paper provides a solution to this problem by introducing a model which addresses both spatial structure and behavior and is based on a thorough mathematical theory. Complementary, we report on a tool realization of the modelling theory and explain how the model supports the development of mechatronic systems.", "num_citations": "15\n", "authors": ["80"]}
{"title": "Behavioral specification of reactive systems using stream-based I/O tables\n", "abstract": " A core problem in formal methods is the transition from informal requirements to formal specifications. Especially when specifying the behavior of reactive systems, many formalisms require the user to either understand a complex mathematical theory and notation or to derive details not given in the requirements, such as the state space of the problem. For many approaches also a consistent set of requirements is needed, which enforces to resolve requirements conflicts prior to formalization. This paper describes a specification technique, where not states but signal patterns are the main elements. The notation is based on tables of regular expressions and supports a piece-wise formalization of potentially inconsistent requirements. Many properties, such as input completeness and consistency, can be checked automatically for these specifications. The detection and resolution of conflicts can be performed\u00a0\u2026", "num_citations": "12\n", "authors": ["80"]}
{"title": "Integrated behavior modeling of space-intensive mechatronic systems\n", "abstract": " Mechatronic systems combine mechanic and electric effects with programmable controllers to realize their functionality. For a large class of such systems spatial properties are essential. Examples can be found in the domain of factory automation, where material is transported and processed. Today, there are no models with formal semantics to support an integrated description of the behavior of these systems. This hampers the development of complex mechatronic systems. In this thesis, we introduc...\u00bb", "num_citations": "12\n", "authors": ["80"]}
{"title": "Interdisziplin\u00e4re Funktionsmodellierung im Anlagenbau\n", "abstract": " Moderne mechatronische Produktionssysteme sind durch ein Zusammenspiel der Disziplinen Mechanik, Elektrotechnik und Software gekennzeichnet. Vor allem in der Entwicklungsphase stellt die Integration der unterschiedlichen Fachbereiche eine Herausforderung f\u00fcr die Maschinenhersteller dar. Sequenziell aufgebaute Entwicklungsprozesse f\u00fchren zu langen Entwicklungszeiten. Zus\u00e4tzlich erschweren die mangelnde Dokumentation und Kommunikation die interdisziplin\u00e4re Zusammenarbeit zwischen den Fachabteilungen. Im Rahmen des Forschungsvorhabens AutoVIBN wurde diese Problemstellung aufgegriffen und eine Beschreibungstechnik entwickelt, die eine disziplinenunabh\u00e4ngige, funktionale Modellierung einer Anlage erlaubt. Erg\u00e4nzende Softwarewerkzeuge unterst\u00fctzen die Erstellung und fr\u00fchzeitige Simulation dieser Modelle sowie die Nutzung der gesammelten Informationen f\u00fcr die\u00a0\u2026", "num_citations": "11\n", "authors": ["80"]}
{"title": "Towards an integrated system model for testing and verification of automation machines\n", "abstract": " Models and documents created during the development of automation machines typically can be categorized into mechanics, electronics, and software. The functionality of an automation machine is, however, realized by the interaction of all three of these domains. So no single model covering only one development category will be able to describe the behavior of the machine thoroughly. For early planning of machine design, virtual prototypes, and especially for the formal verification of requirements an integrated functional model of the machine is required. This paper introduces a technique which can be used to model automation machines on an abstract level, including coarse-grained descriptions of mechanics, electronics and software aspects with special focus on modeling domain-specific issues such as material flow and collision response. The resulting models are detailed enough to be simulated or\u00a0\u2026", "num_citations": "11\n", "authors": ["80"]}
{"title": "Specifying the worst case: orthogonal modeling of hardware errors\n", "abstract": " During testing, the execution of valid cases is only one part of the task. Checking the behavior in boundary situations and in the presence of errors is an equally important subject. This is especially true in embedded systems where parts of a system's function are realized by sensors and actuators, which are subject to wear and defects. As testing with the real hardware is costly and hardware defects are hard to stimulate, such tests are often performed using behavior models of the system which allow to execute the controller software against simulated hardware and environment. However, these models seldom contain possible hardware errors, as this makes the models more complex and, thus, harder to create and maintain. This paper presents a modeling technique for the description of system errors without modifying the original model. Error specifications for individual system components are modeled separately\u00a0\u2026", "num_citations": "10\n", "authors": ["80"]}
{"title": "A semantic model for computer-based spatio-temporal systems\n", "abstract": " Over the last decades lots of techniques have been developed for modeling, analyzing, and verifying software. For embedded or computer-based systems, however, the software is only one part of the entire system, which often has little or no meaning when examined in isolation without considering the remaining parts of the system. This makes it hard, if not impossible, to judge the correctness of software without a thorough understanding of its environment. A natural solution to this problem is to not only capture the software part but the entire system by suitable design models. However, to be useful such a model has to be supported by semantics which unambiguously define its meaning. In this paper we present such a semantic model which captures temporal and spatial aspects of a system, which are important if the system deals with the manipulation of rigid objects, as typically found in the domain of industrial\u00a0\u2026", "num_citations": "10\n", "authors": ["80"]}
{"title": "Deriving extract method refactoring suggestions for long methods\n", "abstract": " The extract method is a common way to shorten long methods in software development. Before developers can use tools that support the extract method, they need to invest time in identifying a suitable refactoring candidate. This paper addresses the problem of finding the most appropriate refactoring candidate for long methods written in Java. The approach determines valid refactoring candidates and ranks them using a scoring function that aims to improve readability and reduce code complexity. We use length and nesting reduction as complexity indicators. The number of parameters needed by the candidate influences the score. To suggest candidates that are consistent with the structure of the code, information such as comments and blank lines are also considered by the scoring function. We evaluate our approach to three open source systems using a user study with ten experienced developers\u00a0\u2026", "num_citations": "8\n", "authors": ["80"]}
{"title": "Behavioral specification of reactive systems using stream-based I/O tables\n", "abstract": " A core problem in formal methods is the transition from informal requirements to formal specifications. Especially when specifying reactive systems, many formalisms require the user to either understand a complex mathematical theory and notation or to derive details not given in the requirements, such as the state space of the problem. While formalizing a real-world requirements document, we developed a technique where not states but signal patterns are the main elements. We argue that it supports a formalization that is often closer to the informal requirements and thus provides a smoother transition to formal methods. As only tables of regular expressions are used for notation, the technique can easily be understood by non-mathematicians. Many properties, such as consistency, can be checked automatically on these specifications. Besides the formal foundation of our approach, this paper presents prototypical\u00a0\u2026", "num_citations": "8\n", "authors": ["80"]}
{"title": "Learning to rank extract method refactoring suggestions for long methods\n", "abstract": " Extract method refactoring is a common way to shorten long methods in software development. It improves code readability, reduces complexity, and is one of the most frequently used refactorings. Nevertheless, sometimes developers refrain from applying it because identifying an appropriate set of statements that can be extracted into a new method is error-prone and time-consuming.               In a previous work, we presented a method that could be used to automatically derive extract method refactoring suggestions for long Java methods, that generated useful suggestions for developers. The approach relies on a scoring function that ranks all valid refactoring possibilities (that is, all candidates) to identify suitable candidates for an extract method refactoring that could be suggested to developers. Even though the evaluation has shown that the suggestions are useful for developers, there is a lack of\u00a0\u2026", "num_citations": "4\n", "authors": ["80"]}
{"title": "What clone coverage can tell\n", "abstract": " In research and practice there is a desire to express the amount of cloning in a system in a compact form and compare different systems with each other. A popular choice for doing so is to use the clone coverage - the percentage of source code being part of at least one clone. However, the clone coverage is strongly influenced by the parameters used for clone detection and the peculiarities of each system. In this paper, we summarize certain pitfalls and argue that clone coverage values should be interpreted with care.", "num_citations": "4\n", "authors": ["80"]}
{"title": "AutoVIBN--Abschlussbericht: Automatische Generierung von Verhaltensmodellen aus CAD-Daten f\u00fcr die qualit\u00e4ttsorientierte virtuelle Inbetriebnahme\n", "abstract": " Die zwei nachfolgend beschriebenen Entwicklungen im Bereich des Maschinen-und Anlagenbaus dienten als Motivation f\u00fcr das Forschungsvorhaben AutoVIBN:(1) Die Funktionalit\u00e4t moderner Produktionssysteme wird zunehmend durch die Steuerungssoftware realisiert. Zudem steigt durch neue technische M\u00f6glichkeiten und Kundenw\u00fcnsche der Funktionsumfang der Maschinen. Bedingt durch die starke Kopplung der Steuerung an das Produktionssystem ist allerdings ein isolierter Test der Steuerungssoftware nur sehr...\u00bb", "num_citations": "4\n", "authors": ["80"]}
{"title": "Automata-based IP packet classification\n", "abstract": " In this thesis we discuss algorithms and data structures used for classifying IP packets. More specifically we will deal with the longest prefix matching problem which is used in many Internet applications, such as routing, packet filtering, content delivery networks, or deciding quality of service. Contrary to advanced approaches proposed in the literature which are often based on ad-hoc heuristics motivated by observations of practical instances, we base our studies on the fundamentals of language theory, namely finite automata. Therefore several classes of automata useful for representing forwarding tables are studied and minimization algorithms for these are presented. In Chapter 1 we give a general overview on the IP protocol as well as IP addressing and routing. Based on this we introduce the longest prefix matching problem occurring with IP packet classification. After discussing applications and constraints for this problem we browse the approaches recommended in the literature.", "num_citations": "3\n", "authors": ["80"]}
{"title": "Incremental Software Quality Analysis for Embedded Systems\n", "abstract": " Analysis tools play an important role in the development of high-quality software systems. For all aspects of software quality, including safety, security, maintainability or portability, there are tools that can automatically detect a large number of quality defects. While such tools are not sufficient to fully check a system\u2019s quality, tool support does help to reduce the number of defects found late in the development process and relieves developers and reviewers from performing repetitive and schematic checks manually. Existing analysis tools typically run in batch mode and analyze the entire system at once. Depending on the system\u2019s size, this can easily take hours, even when integrated in a continuous build process. While this is no problem during release preparation or at quality gates, the single developer usually needs a shorter feedback cycle to benefit from analysis results and react to the defects found. As a solution to this problem, we propose incremental quality analysis, which allows updating known quality data of a system based on the changes applied to the system\u2019s code files. As a developer typically changes only a couple of files at once, this allows processing the changes within seconds and providing the developer with immediate feedback on every change. This paper explains the technology behind incremental quality analysis, provides benchmarks that document the performance gain of several orders of magnitude, and presents promising results from the practical application of this approach.", "num_citations": "2\n", "authors": ["80"]}
{"title": "Simulationsmodelle f\u00fcr die virtuelle Inbetriebnahme\n", "abstract": " Der steigende Anteil an Steuerungssoftware im Maschinen- und Anlagenbau stellt Hersteller und auch Endanwender vor neue Herausforderungen. Mit Hilfe virtueller Maschinenmodelle kann die Qualit\u00e4t der Software vor der Inbetriebnahme und dem Produktionsanlauf gesichert werden. Der Aufbau solcher Simulationsmodelle ist sehr zeitintensiv. Wissenschaftler der TU M\u00fcnchen beschreiben eine Methode, die eine Teilautomatisierung des Prozesses zur Modellerstellung erlaubt.", "num_citations": "2\n", "authors": ["80"]}
{"title": "Material flow abstraction of manufacturing systems\n", "abstract": " Manufacturing systems integrate electro-mechanical components with software to fulfill certain production tasks. Due to this combination of computer science and traditional engineering, formal models of embedded systems are often inappropriate for the description and analysis of manufacturing systems. This is especially prominent on an abstract level, where computation and communication are not of primary concern, but rather the material the system is processing. In this paper, we introduce an abstract formal model of manufacturing systems based on the material flow, i.e. the relation between incoming and outgoing material over time. The formalization supports compositional reasoning and the comparison of specifications with more concrete models (implementations). This provides a foundation for the formally founded conceptual modeling of manufacturing systems and the reasoning about the\u00a0\u2026", "num_citations": "1\n", "authors": ["80"]}
{"title": "Towards an integrated system model for testing and verification of automation machines\n", "abstract": " The models and documents created during the development of automation machines typically can be categorized into mechanics, electronics, and software/controller. The functionality of an automation machine is, however, usually realized by the interaction of all three of these domains. So no single model covering only one development category will be able to describe the behavior of the machine thoroughly. For early planning of the machine design, virtual prototypes, and especially for the formal...\u00bb", "num_citations": "1\n", "authors": ["80"]}