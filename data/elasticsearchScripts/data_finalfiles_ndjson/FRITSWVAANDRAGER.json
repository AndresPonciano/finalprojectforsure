{"title": "Forward and backward simulations Part I: Untimed systems\n", "abstract": " A unified, comprehensive presentation of simulation techniques for verification of concurrent systems is given, in terms of a simple untimed automaton model. In particular, (1) refinements, (2) forward and backward simulations, (3) hybrid forward-backward and backward-forward simulations, and (4) history and prophecy relations are defined. History and prophecy relations are abstract versions of the history and prophecy variables of Abadi and Lamport, as well as the auxiliary variables of Owicki and Gries, Relationships between the different types of simulations, as well as soundness and completeness results, are stated and proved. Finally, it is shown how invariants can be incorporated into all the simulations. Even though many results are presented here for the first time, this paper can also be read as a survey (in a simple setting) of the research literature on simulation techniques. The development for untimed\u00a0\u2026", "num_citations": "589\n", "authors": ["1601"]}
{"title": "Hybrid i/o automata\n", "abstract": " Hybrid systems are systems that exhibit a combination of discrete and continuous behavior. Typical hybrid systems include computer components, which operate in discrete program steps, and real-world components, whose behavior over time intervals evolves according to physical constraints. Important examples of hybrid systems include automated transportation systems, robotics systems, process control systems, systems of embedded devices, and mobile computing systems. Such systems can be very complex, and very difficult to describe and analyze. This paper presents the Hybrid Input/Output Automaton (HIOA) modeling framework, a basic mathematical framework to support description and analysis of hybrid systems. An important feature of this model is its support for decomposing hybrid system descriptions. In particular, the framework includes a notion of external behavior for a hybrid I/O automaton\u00a0\u2026", "num_citations": "548\n", "authors": ["1601"]}
{"title": "Structured operational semantics and bisimulation as a congruence\n", "abstract": " In this paper we are interested in general properties of classes of transition system specifications in Plotkin style. The discussion takes place in a setting of labelled transition systems. The states of the transition systems are terms generated by a single sorted signature and the transitions between states are defined by conditional rules over the syntax. It is argued that in this setting it is natural to require that strong bisimulation equivalence be a congruence on the states of the transition systems. A general format, called the tyft/tyxt format, is presented for the rules in a transition system specification, such that bisimulation is always a congruence when all the rules fit this format. With a series of examples it is demonstrated that the tyft/tyxt format cannot be generalized in any obvious way. Another series of examples illustrates the usefulness of our congruence theorem. Briefly we touch upon the issue of modularity of\u00a0\u2026", "num_citations": "428\n", "authors": ["1601"]}
{"title": "Testing timed automata\n", "abstract": " We present a generalization of the classical theory of testing for Mealy machines to a setting of dense real-time systems. A model of timed I/O automata is introduced, inspired by the timed automaton model of Alur and Dill, together with a notion of test sequence for this model. Our main contributions is a test suite derivation algorithm for black-box conformance testing of timed I/O automata. Black-box testing amounts to checking whether an implementation conforms to a specification of its external behavior, by means of a set of tests derived solely from specification. The main problem is to derive a finite set of tests from a possibly infinite, dense time transition system representing the specification. The solution is to reduce the dense time transition system to an appropriate finite discrete subautomaton, the grid automaton, which contains enough information to completely represent the specification from a test perspective\u00a0\u2026", "num_citations": "369\n", "authors": ["1601"]}
{"title": "Hybrid i/o automata\n", "abstract": " We propose a new hybrid I/O automaton model that is capable of describing both continuous and discrete behavior. The model, which extends the timed I/O automaton model of [12, 7] and the phase transition system models of [15, 2], allows communication among components using both shared variables and shared actions. The main contributions of this paper are: (1) the definition of hybrid I/O automata and of an implementation relation based on hybrid traces, (2) the definition of a simulation between hybrid I/O automata and a proof that existence of a simulation implies the implementation relation, (3) a definition of composition of hybrid I/O automata and a proof that it respects the implementation relation, and (4) a definition of receptiveness for hybrid I/O automata and a proof that, assuming certain compatibility conditions, receptiveness is preserved by composition.", "num_citations": "327\n", "authors": ["1601"]}
{"title": "The theory of timed I/O automata\n", "abstract": " This monograph presents the Timed Input/Output Automaton (TIOA) modeling framework, a basic mathematical framework to support description and analysis of timed (computing) systems. Timed systems are systems in which desirable correctness or performance properties of the system depend on the timing of events, not just on the order of their occurrence.  Timed systems are employed in a wide range of domains including communications, embedded systems, real-time operating systems, and automated control. Many applications involving timed systems have strong safety, reliability, and predictability requirements, which make it important to have methods for systematic design of systems and rigorous analysis of timing-dependent behavior. The TIOA framework also supports description and analysis of timed distributed algorithms -- distributed algorithms whose correctness and performance depend on the\u00a0\u2026", "num_citations": "295\n", "authors": ["1601"]}
{"title": "An efficient algorithm for branching bisimulation and stuttering equivalence\n", "abstract": " This paper presents an efficient algorithm for the Relational Coarsest Partition with Stuttering problem (RCPS). The RCPS problem is closely related to the problem of deciding stuttering equivalence on finite state Kripke structures (see Browne, Clarke & Grumberg [3]), and to the problem of deciding branching bisimulation equivalence on finite state labelled transition systems (see Van Glabbeek & Weijland [12]). If n is the number of states and m the number of transitions, then our algorithm has time complexity O(n\u00b7(n+m)) and space complexity O(n+m). The algorithm induces algorithms for branching bisimulation and stuttering equivalence which have the same complexity. Since for Kripke structures m\u2a7dn 2, this confirms a conjecture of Browne, Clarke & Grumberg [3], that their O(n 5)-time algorithm for stuttering equivalence is not optimal.", "num_citations": "294\n", "authors": ["1601"]}
{"title": "Forward and backward simulations: II. timing-based systems\n", "abstract": " A general automaton model for timing-based systems is presented and is used as the context for developing a variety of simulation proof techniques for such systems. These techniques include (1) refinements, (2) forward and backward simulations, (3) hybrid forward\u2013backward and backward\u2013forward simulations, and (4) history and prophecy relations. Relationships between the different types of simulations, as well as soundness and completeness results, are stated and proved. These results are (with one exception) analogous to the results for untimed systems in Part I of this paper. In fact, many of the results for the timed case are obtained as consequences of the analogous results for the untimed case.", "num_citations": "221\n", "authors": ["1601"]}
{"title": "Forward and backward simulations for timing-based systems\n", "abstract": " A general automaton model for timing-based systems is presented and is used as the context for developing a variety of simulation proof techniques for such systems. As a first step, a comprehensive overview of simulation techniques for simple untimed automata is given. In particular, soundness and completeness results for (1) refinements, (2) forward and backward simulations, (3) forward-backward and backward-forward simulations, and (4) history and prophecy relations are given. History and prophecy relations are new and are abstractions of the history variables of Owicki and Gries and the prophecy variables of Abadi and Lamport, respectively. As a subsequent step, it is shown how most of the results for untimed automata can be carried over to the setting of timed automata. In fact, many of the results for the timed case are obtained as consequences of the analogous results for the untimed case.", "num_citations": "202\n", "authors": ["1601"]}
{"title": "Proof-checking a data link protocol\n", "abstract": " A data link protocol developed and used by Philips Electronics is modeled and verified using I/O automata theory. Correctness is computer-checked with the Coq proof development system.", "num_citations": "197\n", "authors": ["1601"]}
{"title": "Linear parametric model checking of timed automata\n", "abstract": " We present an extension of the model checker Uppaal, capable of synthesizing linear parameter constraints for the correctness of parametric timed automata. A symbolic representation of the (parametric) state space in terms of parametric difference bound matrices is shown to be correct. A second contribution of this paper is the identification of a subclass of parametric timed automata (L/U automata), for which the emptiness problem is decidable, contrary to the full class where it is known to be undecidable. Also, we present a number of results that reduce the verification effort for L/U automata in certain cases. We illustrate our approach by deriving linear parameter constraints for a number of well-known case studies from the literature (exhibiting a flaw in a published paper).", "num_citations": "174\n", "authors": ["1601"]}
{"title": "Model learning\n", "abstract": " Model learning emerges as an effective method for black-box state machine models of hardware and software components.", "num_citations": "168\n", "authors": ["1601"]}
{"title": "Timed I/O automata: A mathematical framework for modeling and analyzing real-time systems\n", "abstract": " We describe the timed input/output automata (TIOA) framework, a general mathematical framework for modeling and analyzing real-time systems. It is based on timed I/O automata, which engage in both discrete transitions and continuous trajectories. The framework includes a notion of external behavior, and notions of composition and abstraction. We define safety and liveness properties for timed I/O automata, and a notion of receptiveness, and prove basic results about all of these notions. The TIOA framework is defined as a special case of the new hybrid I/O automata (HIOA) modeling framework for hybrid systems. Specifically, a TIOA is an HIOA with no external variables; thus, TIOAs communicate via shared discrete actions only, and do not interact continuously. This restriction is consistent with previous real-time system models, and gives rise to some simplifications in the theory (compared to HIOA). The\u00a0\u2026", "num_citations": "162\n", "authors": ["1601"]}
{"title": "Generating models of infinite-state communication protocols using regular inference with abstraction\n", "abstract": " In order to facilitate model-based verification and validation, effort is underway to develop techniques for generating models of communication system components from observations of their external behavior. Most previous such work has employed regular inference techniques which generate modest-size finite-state models. They typically suppress parameters of messages, although these have a significant impact on control flow in many communication protocols. We present a framework, which adapts regular inference to include data parameters in messages and states for generating components with large or infinite message alphabets. A main idea is to adapt the framework of predicate abstraction, successfully used in formal verification. Since we are in a black-box setting, the abstraction must be supplied externally, using information about how the component manages data parameters. We have\u00a0\u2026", "num_citations": "145\n", "authors": ["1601"]}
{"title": "Verification of an audio control protocol\n", "abstract": " We analyze a simple version of a protocol developed by Philips for the physical layer of an interface bus that connects the various devices of some stereo equipment (tuner, CD player,...). The protocol, which uses Manchester encoding, has to deal with a significant uncertainty in the timing of events, due to both hardware and software constraints. We present a formal specification of the protocol, and a proof of correctness for the case where the tolerance of the clocks used within the system is less than 1/17. A counterexample shows that the protocol fails for tolerances greater than or equal to this value. The verification is carried out using a model of linear hybrid systems, which is similar to the phase transition system model of Manna and Pnueli, and the model of linear hybrid automata of Alur, Henzinger and Ho. The semantics of linear hybrid systems is defined via a translation to the timed I/O automata model\u00a0\u2026", "num_citations": "143\n", "authors": ["1601"]}
{"title": "Distributing timed model checking\u2014how the search order matters\n", "abstract": " In this paper we address the problem of distributing model checking of timed automata. We demonstrate through four real life examples that the combined processing and memory resources of multi-processor computers can be effectively utilized. The approach assumes a distributed memory model and is applied to both a network of workstations and a symmetric multiprocessor machine. However, certain unexpected phenomena have to be taken into account. We show how in the timed case the search order of the state space is crucial for the effectiveness and scalability of the exploration. An effective heuristic to counter the effect of the search order is provided. Some of the results open up for improvements in the single processor case.", "num_citations": "136\n", "authors": ["1601"]}
{"title": "Hybrid I/O automata revisited\n", "abstract": " In earlier work, we developed a mathematical hybrid I/O automaton (HIOA) modeling framework, capable of describing both discrete and continuous behavior. This framework has been used to analyze examples of automated transportation systems, intelligent vehicle high-way systems, air traffic control systems, and consumer electronics applications. Here, we reconsider the basic definitions of the HIOA framework, in particular, the dual use of external variables for discrete and continuous communication. We present a new HIOA model that is simpler than the earlier model, due to a clearer separation between discrete and continuous activity.", "num_citations": "134\n", "authors": ["1601"]}
{"title": "On the relationship between process algebra and input/output automata\n", "abstract": " The relation between process algebra and I/O automata models is investigated in a general setting of structured operational semantics (SOS). For a series of (approximations of) key properties of I/O automata, syntactic constraints on inference rules are proposed which guarantee these properties. A rst result is that, in a setting without assumptions about actions, the well-known trace and failure preorders are substitutive for any set of rules in a format due to De Simone. Next additional constraints are imposed which capture the notion of internal actions and guarantee substitutivity of the testing preorders of De Nicola and Hennessy, and also of a preorder related to the failure semantics with fair abstraction of unstable divergence of Bergstra, Klop and Olderog. Subsequent constraints guarantee that input actions are always enabled and output actions cannot be blocked, two key features of input/output automata. The main result is that for any I/O calculus, ie a De Simone calculus which combines the constraints for internal, input and output actions, the quiescent trace preorder and the fair trace preorder are substitutive. A simple I/O calculus is presented which is su ciently expressive to specify all nitely branching I/O automata over a given, nite action signature.", "num_citations": "132\n", "authors": ["1601"]}
{"title": "Hybrid Systems: Computation and Control: Second International Workshop, HSCC'99, Berg en Dal, The Netherlands, March 29-31, 1999 Proceedings\n", "abstract": " This volume contains the proceedings of the Second International Workshop on Hybrid Systems: Computation and Control (HSCC\u201999) to be held March 29-31, 1999, in the village Berg en Dal near Nijmegen, The Netherlands. The rst workshop of this series was held in April 1998 at the University of California at Berkeley. The series follows meetings that were initiated by Anil Nerode at Cornell University. The proceedings of those meetings were published in the Springer-Verlag LNCS Series, Volumes 736, 999, 1066, 1201, and 1273. The p-ceedings of the rst workshop of the new series was published in LNCS 1386. The focus of the workshop is on modeling, control, synthesis, design, and ve-cation of hybrid systems. A hybrid system is a theoretical model for a computer controlled engineering system, with a dynamics that evolves both in a discrete state set and in a family of continuous state spaces. Research is motivated by, for example, control of electro-mechanical systems (robots), air tra c control, control of automated freeways, and chemical process control. The emerging-search area of hybrid systems overlaps both with computer science and with control theory. The interaction between researchers from these elds is expected to be fruitfull for the development of the area of hybrid systems.", "num_citations": "120\n", "authors": ["1601"]}
{"title": "Learning I/O Automata\n", "abstract": " Links are established between three widely used modeling frameworks for reactive systems: the ioco theory of Tretmans, the interface automata of De Alfaro and Henzinger, and Mealy machines. It is shown that, by exploiting these links, any tool for active learning of Mealy machines can be used for learning I/O automata that are deterministic and output determined. The main idea is to place a transducer in between the I/O automata teacher and the Mealy machine learner, which translates concepts from the world of I/O automata to the world of Mealy machines, and vice versa. The transducer comes equipped with an interface automaton that allows us to focus the learning process on those parts of the behavior that can effectively be tested and/or are of particular interest. The approach has been implemented on top of the LearnLib tool and has been applied successfully to three case studies.", "num_citations": "119\n", "authors": ["1601"]}
{"title": "Adding symmetry reduction to uppaal\n", "abstract": " We describe a\u00a0prototype extension of the real-time model checking tool Uppaal\u00a0 with symmetry reduction. The symmetric data type scalarset, which is also used in the Mur\u03d5\u00a0model checker, was added to Uppaal\u2019s system description language to support the easy static detection of symmetries. Our prototype tool uses state swaps, described and proven sound earlier by Hendriks, to reduce the space and memory consumption of Uppaal. Moreover, the reduction strategy is canonical, which means that the symmetries are optimally used. For all examples that we experimented with (both academic toy examples and industrial cases), we obtained a\u00a0drastic reduction of both computation time and memory usage, exponential in the size of the scalar sets used.", "num_citations": "118\n", "authors": ["1601"]}
{"title": "Structured operational semantics and bisimulation as a congruence\n", "abstract": " In this paper the question is considered in which cases a transition system specification in Plotkin style has \u2018good\u2019 properties and deserves the predicate \u2018structured\u2019. The discussion takes place in a setting of labelled transition systems. The states of the transition systems are terms generated by a single sorted signature and the transitions between states are defined by conditional rules. We argue that in this setting it is natural to require that strong bisimulation equivalence is a congruence on the states of the transition systems. A general format, called the tyft/tyxt format, is presented for the conditional rules in a transition system specification, such that bisimulation is always a congruence when all the rules fit into this format. With a series of examples it is demonstrated that the tyft/tyxt format cannot be generalized in any obvious way. Briefly we touch upon the issue of modularity of transition system specifications\u00a0\u2026", "num_citations": "116\n", "authors": ["1601"]}
{"title": "Combining model learning and model checking to analyze TCP implementations\n", "abstract": " We combine model learning and model checking in a challenging case study involving Linux, Windows and FreeBSD implementations of TCP. We use model learning to infer models of different software components and then apply model checking to fully explore what may happen when these components (e.g. a Linux client and a Windows server) interact. Our analysis reveals several instances in which TCP implementations do not conform to their RFC specifications.", "num_citations": "108\n", "authors": ["1601"]}
{"title": "Verification of a leader election protocol: Formal methods applied to IEEE 1394\n", "abstract": " The IEEE 1394 high performance serial multimedia bus protocol allows several components to communicate with each other at high speed. In this paper we present a formal model and verification of a leader election algorithm that forms the core of the tree identify phase of the physical layer of the 1394 protocol.               We describe the algorithm formally in the I/O automata model of Lynch and Tuttle, and verify that for an arbitrary tree topology exactly one leader is elected. A large part of our verification has been checked mechanically with PVS, a verification system for higher-order logic.", "num_citations": "100\n", "authors": ["1601"]}
{"title": "A testing scenario for probabilistic processes\n", "abstract": " We introduce a notion of finite testing, based on statistical hypothesis tests, via a variant of the well-known trace machine. Under this scenario, two processes are deemed observationally equivalent if they cannot be distinguished by any finite test. We consider processes modeled as image finite probabilistic automata and prove that our notion of observational equivalence coincides with the trace distribution equivalence proposed by Segala. Along the way, we give an explicit characterization of the set of probabilistic generalize the Approximation Induction Principle by defining an also prove limit and convex closure properties of trace distributions in an appropriate metric space.", "num_citations": "99\n", "authors": ["1601"]}
{"title": "Inference and abstraction of the biometric passport\n", "abstract": " Model-based testing is a promising software testing technique for the automation of test generation and test execution. One obstacle to its adoption is the difficulty of developing models. Learning techniques provide tools to automatically derive automata-based models. Automation is obtained at the cost of time and unreadability of the models. We propose an abstraction technique to reduce the alphabet and large data sets. Our idea is to extract a priori knowledge about the teacher and use this knowledge to define equivalence classes. The latter are then used to define a new and reduced alphabet. The a priori knowledge can be obtained from informal documentation or requirements. We formally prove soundness of our approach. We demonstrate the practical feasibility of our technique by learning a model of the new biometric passport. Our automatically learned model is of comparable size and complexity\u00a0\u2026", "num_citations": "98\n", "authors": ["1601"]}
{"title": "Action transducers and timed automata\n", "abstract": " Thetimed automaton model of [LyV92, LyV93] is a general model for timing-based systems. A notion oftimed action transducer is here defined as an automata-theoretic way of representing operations on timed automata. It is shown that two timed trace inclusion relations are substitutive with respect to operations that can be described by timed action transducers. Examples are given of operations that can be described in this way, and a preliminary proposal is given for an appropriate language of operators for describing timing-based systems.", "num_citations": "98\n", "authors": ["1601"]}
{"title": "Root contention in IEEE 1394\n", "abstract": " The model of probabilistic I/O automata of Segala and Lynch is used for the formal specification and analysis of the root contention protocol from the physical layer of the IEEE 1394 (\u201cFireWire\u201d) standard. In our model of the protocol both randomization and real-time play an essential role. In order to make our verification easier to understand we introduce several intermediate automata in between the implementation and the specification automaton. This allows us to use very simple notions of refinement rather than the more general but also very complex simulation relations which have been proposed by Segala and Lynch.", "num_citations": "95\n", "authors": ["1601"]}
{"title": "Linear parametric model checking of timed automata\n", "abstract": " We present an extension of the model checker Uppaal capable of synthesize linear parameter constraints for the correctness of parametric timed automata. The symbolic representation of the (parametric) state-space is shown to be correct. A second contribution of this paper is the identification of a subclass of parametric timed automata (L/U automata), for which the emptiness problem is decidable, contrary to the full class where it is know to be undecidable. Also we present a number of lemmas enabling the verification effort to be reduced for L/U automata in some cases. We illustrate our approach by deriving linear parameter constraints for a number of well-known case studies from the literature (exhibiting a flaw in a published paper).", "num_citations": "90\n", "authors": ["1601"]}
{"title": "Encoding information into polymers\n", "abstract": " Defined-sequence polymers have great potential as durable and high-density data-storage media. DNA already fulfils this role in nature, using the sequence of its four nucleobases to store genetic information. Synthetic DNA can be used to store binary codes, and it is both more durable and can store information at a much higher density than conventional silicon-based storage systems. Other defined-sequence synthetic polymers have properties that make them even more suitable for data storage, at least in principle, assuming that complete control over their composition, that is, their monomer sequence, can be achieved. This Review addresses the current status of data storage in DNA, proteins and synthetic polymers, with the objective to overcome the problems of current data storage technology.", "num_citations": "89\n", "authors": ["1601"]}
{"title": "Expressiveness results for process algebras\n", "abstract": " The expressive power of process algebras is investigated in a general setting of structural operational semantics. The notion of an effective operational semantics is introduced and it is observed that no effective operational semantics for an enumerable language can specify all effective process graphs up to trace equivalence. A natural class of Plotkin style SOS specifications is identified, containing the guarded versions of calculi like CCS, SCCS, Meije and ACP, and it is proved that any specification in this class induces an effective operational semantics. Using techniques introduced by Bloom, it is shown that for the guarded versions of CCS-like calculi, there is a double exponential bound on the speed with which the number of outgoing transitions in a state can grow. As a corollary of this result it follows that two expressiveness results of De Simone for Meije and SCCS depend in a fundamental way on the\u00a0\u2026", "num_citations": "81\n", "authors": ["1601"]}
{"title": "Automata learning through counterexample guided abstraction refinement\n", "abstract": " Abstraction is the key when learning behavioral models of realistic systems. Hence, in most practical applications where automata learning is used to construct models of software components, researchers manually define abstractions which, depending on the history, map a large set of concrete events to a small set of abstract events that can be handled by automata learning tools. In this article, we show how such abstractions can be constructed fully automatically for a restricted class of extended finite state machines in which one can test for equality of data parameters, but no operations on data are allowed. Our approach uses counterexample-guided abstraction refinement: whenever the current abstraction is too coarse and induces nondeterministic behavior, the abstraction is refined automatically. Using Tomte, a prototype tool implementing our algorithm, we have succeeded to learn \u2013 fully automatically\u00a0\u2026", "num_citations": "73\n", "authors": ["1601"]}
{"title": "Analysis of a clock synchronization protocol for wireless sensor networks\n", "abstract": " The Dutch company Chess develops a wireless sensor network (WSN) platform using an epidemic communication model. One of the greatest challenges in the design is to find suitable mechanisms for clock synchronization. In this paper, we study a proposed clock synchronization protocol for the Chess platform. First, we model the protocol as a network of timed automata and verify various instances using the Uppaal model checker. Next, we present a full parametric analysis of the protocol for the special case of cliques (networks with full connectivity), that is, we give constraints on the parameters that are both necessary and sufficient for correctness. These results have been checked using the proof assistant Isabelle. We report on the exhaustive analysis of the protocol for networks with four nodes, and we present a negative result for the special case of line topologies: for any instantiation of the parameters, the\u00a0\u2026", "num_citations": "73\n", "authors": ["1601"]}
{"title": "Compositionality for probabilistic automata\n", "abstract": " We establish that on the domain of probabilistic automata, the trace distribution preorder coincides with the simulation preorder.", "num_citations": "71\n", "authors": ["1601"]}
{"title": "Verification of two communication protocols by means of process algebra\n", "abstract": " A Positive Acknowledgement with Retransmission protocol, and a One Bit Sliding Window protocol are verified in the framework of the algebra of communicating processes with silent steps, augmented with additional axioms. The Cluster Fair Abstraction Rule (CFAR) a generalization of Koomen's Fair Abstraction Rule (KFAR) is presented and it is shown that CFAR can be derived from KFAR. The notion of redundancy in a context, which makes it possible to use trace theoretic arguments in process algebra calculations is introduced. For the verification of the second protocol, the technique of local replacement is used. In this technique, a concurrent system is simplified by repeated replacement of components, replacements which leave the behavior of the system invariant.", "num_citations": "68\n", "authors": ["1601"]}
{"title": "Observing branching structure through probabilistic contexts\n", "abstract": " Probabilistic automata (PAs) constitute a general framework for modeling and analyzing discrete event systems that exhibit both nondeterministic and probabilistic behavior, such as distributed algorithms and network protocols. The behavior of PAs is commonly defined using schedulers (also called adversaries or strategies), which resolve all nondeterministic choices based on past history. From the resulting purely probabilistic structures, trace distributions can be extracted, whose intent is to capture the observable behavior of a PA. However, when PAs are composed via an (asynchronous) parallel composition operator, a global scheduler may establish strong correlations between the behavior of system components and, for example, resolve nondeterministic choices in one PA based on the outcome of probabilistic choices in the other. It is well known that, as a result of this, the (linear-time) trace distribution precongruence is not\u00a0\u2026", "num_citations": "67\n", "authors": ["1601"]}
{"title": "Switched PIOA: Parallel composition via distributed scheduling\n", "abstract": " This paper presents the framework of switched probabilistic input/output automata (or switched PIOA), augmenting the original PIOA framework with an explicit control exchange mechanism. Using this mechanism, we model a network of processes passing a single token among them, so that the location of this token determines which process is scheduled to make the next move. This token structure therefore implements a distributed scheduling scheme: scheduling decisions are always made by the (unique) active component.Distributed scheduling allows us to draw a clear line between local and global nondeterministic choices. We then require that local nondeterministic choices are resolved using strictly local information. This eliminates unrealistic schedules that arise under the more common centralized scheduling scheme. As a result, we are able to prove that our trace-style semantics is compositional.", "num_citations": "65\n", "authors": ["1601"]}
{"title": "The Difference between Splitting in n and n+1\n", "abstract": " It is established that durational and structural aspects of actions can in general not be modeled in standard interleaving semantics, even when a time-consuming action is represented by a pair of instantaneous actions denoting its start and finish. By means of a series of counterexamples it is shown that, for anyn, it makes a difference whether actions are split innor inn+1 parts.", "num_citations": "63\n", "authors": ["1601"]}
{"title": "Applying automata learning to embedded control software\n", "abstract": " Using an adaptation of state-of-the-art algorithms for black-box automata learning, as implemented in the LearnLib tool, we succeeded to learn a model of the Engine Status Manager (ESM), a software component that is used in printers and copiers of Oc\u00e9. The main challenge that we encountered was that LearnLib, although effective in constructing hypothesis models, was unable to find counterexamples for some hypotheses. In fact, none of the existing FSM-based conformance testing methods that we tried worked for this case study. We therefore implemented an extension of the algorithm of Lee and Yannakakis for computing an adaptive distinguishing sequence. Even when an adaptive distinguishing sequence does not exist, Lee and Yannakakis\u2019 algorithm produces an adaptive sequence that \u2018almost\u2019 identifies states. In combination with a standard algorithm for computing separating sequences for\u00a0\u2026", "num_citations": "59\n", "authors": ["1601"]}
{"title": "Analysis of a biphase mark protocol with Uppaal and PVS\n", "abstract": " The biphase mark protocol is a convention for representing both a string of bits and clock edges in a square wave. The protocol is frequently used for communication at the physical level of the ISO/OSI hierarchy, and is implemented on microcontrollers such as the Intel 82530 Serial Communications Controller. An important property of the protocol is that bit strings of arbitrary length can be transmitted reliably, despite differences in the clock rates of sender and receiver (drift), variations of the clock rates (jitter), and distortion of the signal after generation of an edge. In this article, we show how the protocol can be modelled naturally in terms of timed automata. We use the model checker Uppaal to derive the maximal tolerances on the clock rates, for different instances of the protocol, and to support the general parametric verification that we formalized using the proof assistant PVS. Based on the derived\u00a0\u2026", "num_citations": "59\n", "authors": ["1601"]}
{"title": "Formal Specification and Analysis of Zeroconf Using Uppaal\n", "abstract": " The model checker Uppaal is used to formally model and analyze parts of Zeroconf, a protocol for dynamic configuration of IPv4 link-local addresses that has been defined in RFC 3927 of the IETF. Our goal has been to construct a model that (a) is easy to understand by engineers, (b) comes as close as possible to the informal text (for each transition in the model there should be a corresponding piece of text in the RFC), and (c) may serve as a basis for formal verification. Our modeling efforts revealed several errors (or at least ambiguities) in the RFC that no one else spotted before. We present two proofs of the mutual exclusion property for Zeroconf (for an arbitrary number of hosts and IP addresses): a manual, operational proof, and a proof that combines model checking with the application of a new abstraction relation that is compositional with respect to committed locations. The model checking problem has been\u00a0\u2026", "num_citations": "56\n", "authors": ["1601"]}
{"title": "Deadlock Prevention in the \u00c6thereal Protocol\n", "abstract": " The \u00c6thereal protocol enables both guaranteed and best effort communication in an on-chip packet switching network. We discuss a formal specification of \u00c6thereal and its underlying network in terms of the PVS specification language. Using PVS we prove absence of deadlock for an abstract version of our model.", "num_citations": "53\n", "authors": ["1601"]}
{"title": "Model learning and model checking of SSH implementations\n", "abstract": " We apply model learning on three SSH implementations to infer state machine models, and then use model checking to verify that these models satisfy basic security properties and conform to the RFCs. Our analysis showed that all tested SSH server models satisfy the stated security properties, but uncovered several violations of the standard.", "num_citations": "50\n", "authors": ["1601"]}
{"title": "An algebra for process creation\n", "abstract": " In this paper, we study the issue of process creation from an algebraic perspective. The key to our approach, which is inspired by work of America and De Bakker, consists of giving a new interpretation to the operator symbol \u00b7 (sequential composition) in the axiom system BPA of Bergstra and Klop. We present a number of other models for BPA and show how the new interpretation of \u00b7 naturally generalises the usual interpretation in ACP. We give an operational semantics based on Plotkin style inductive rules for a simple language with process creation and communication, and give a complete finite axiomatisation of the associated bisimulation model.", "num_citations": "48\n", "authors": ["1601"]}
{"title": "Refactoring of legacy software using model learning and equivalence checking: an industrial experience report\n", "abstract": " Many companies struggle with large amounts of legacy software that is difficult to maintain and to extend. Refactoring legacy code typically requires large efforts and introduces serious risks because often crucial business assets are hidden in legacy components. We investigate the support of formal techniques for the rejuvenation of legacy embedded software, concentrating on control components. Model learning and equivalence checking are used to improve a new implementation of a legacy control component. Model learning is applied to both the old and the new implementation. The resulting models are compared using an equivalence check of a model checker. We report about our experiences with this approach at Philips. By gradually increasing the set of input stimuli, we obtained implementations of a power control service for which the learned behaviour is equivalent.", "num_citations": "45\n", "authors": ["1601"]}
{"title": "A simple definition for parallel composition of prime event structures\n", "abstract": " A simple definition for parallel composition of prime event structures (1989) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication A simple definition for parallel composition of prime event structures (1989) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title A simple definition for parallel composition of prime event structures Series Department of Computer Science [CS] Author FW Vaandrager (Frits) Date issued 1989-01-01 Access Closed Access Language English Type Other Publisher CWI Publication https://ir.cwi.nl/pub/5897 Persistent Identifier urn:NBN:nl:ui:18-5897 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer >>> DANS is an \u2026", "num_citations": "45\n", "authors": ["1601"]}
{"title": "Minimizable timed automata\n", "abstract": " State minimization plays a fundamental role in both classical automata theory and in the theory of reactive systems. Many algorithms and results are based on the fact that for each finite automaton there exists an equivalent minimum state automaton that can be effectively computed and that is unique up to isomorphism.             Timed safety automata (TSA's) [5], finite automata with clocks, have been used extensively for the specification and verification of real-time systems. However, there does not always exist a unique minimum state TSA that is equivalent to a given TSA. This problem occurs irrespective of the selected notions of state (including or excluding clock values) and equivalence on states (language equivalence, bisimulation equivalence, etc.).             Henzinger, Kopke and Wong-Toi [4] convincingly showed that if states do not include clock values, state minimization for timed automata is neither\u00a0\u2026", "num_citations": "42\n", "authors": ["1601"]}
{"title": "Learning register automata with fresh value generation\n", "abstract": " We present a new algorithm for active learning of register automata. Our algorithm uses counterexample-guided abstraction refinement to automatically construct a component which maps (in a history dependent manner) the large set of actions of an implementation into a small set of actions that can be handled by a Mealy machine learner. The class of register automata that is handled by our algorithm extends previous definitions since it allows for the generation of fresh output values. This feature is crucial in many real-world systems (e.g. servers that generate identifiers, passwords or sequence numbers). We have implemented our new algorithm in a tool called Tomte.", "num_citations": "40\n", "authors": ["1601"]}
{"title": "Learning fragments of the TCP network protocol\n", "abstract": " We apply automata learning techniques to learn fragments of the TCP network protocol by observing its external behaviour. We show that different implementations of TCP in Windows 8 and Ubuntu induce different automata models, thus allowing for fingerprinting of these implementations. In order to infer our models we use the notion of a mapper component introduced by Aarts, Jonsson and Uijen, which abstracts the large number of possible TCP packets into a limited number of abstract actions that can be handled by the regular inference tool LearnLib. Inspection of the learned models reveals that both Windows 8 and Ubuntu 13.10 violate RFC 793.", "num_citations": "39\n", "authors": ["1601"]}
{"title": "Operational and logical semantics for polling real-time systems\n", "abstract": " PLC-Automata are a class of real-time automata suitable to describe the behavior of polling real-time systems. PLC-Automata can be compiled to source code for PLCs, a hardware widely used in industry to control processes. Also, PLC-Automata have been equipped with a logical and operational semantics, using Duration Calculus (DC) and Timed Automata (TA), respectively.             The three main results of this paper are: (1) A simplified operational semantics. (2) A minor extension of the logical semantics, and a proof that this semantics is complete relative to our operational semantics. This means that if an observable satisfies all formulas of the DC semantics, then it can also be generated by the TA semantics. (3) A proof that the logical semantics is sound relative to our operational semantics. This means that each observable that is accepted by the TA semantics constitutes a model for all formulas of the\u00a0\u2026", "num_citations": "38\n", "authors": ["1601"]}
{"title": "Modular specification of process algebras\n", "abstract": " This paper proposes a modular approach to the algebraic specification of process algebras. This is done by means of the notion of a module. The simplest modules are building blocks of operators and axioms, each block describing a feature of concurrency in a certain semantical setting. These modules can then be combined by means of a union operator +, an export operator \u25a1, allowing to forget some operators in a module, an operator H, changing semantics by taking homomorphic images, and an operator S which takes subalgebras. These operators enable us to combine modules in a subtle way, when the direct combination would be inconsistent.We give a presentation of equational logic, infinitary conditional equational logic \u2014 of which we also prove the completeness \u2014 and first-order logic and show how the notion of a formal proof of a formula from a theory can be generalized to that of a proof of a formula\u00a0\u2026", "num_citations": "38\n", "authors": ["1601"]}
{"title": "Compositional abstraction in real-time model checking\n", "abstract": " The idea to use simulations (or refinements) as a compositional abstraction device is well-known, both in untimed and timed settings, and has already been studied theoretically and practically in many papers during the last three decades. Nevertheless, existing approaches do not handle two fundamental modeling concepts which, for instance, are frequently used in the popular Uppaal model checker: (1) a parallel composition operator that supports communication via shared variables as well as synchronization of actions, and (2) committed locations. We describe a framework for compositional abstraction based on simulation relations that does support both concepts, and that is suitable for Uppaal. Our approach is very general and the only essential restriction is that the guards of input transitions do not depend on external variables. We have applied our compositional framework to verify the Zeroconf\u00a0\u2026", "num_citations": "35\n", "authors": ["1601"]}
{"title": "A theory of normed simulations\n", "abstract": " In existing simulation proof techniques, a single step in a lower-level specification may be simulated by an extended execution fragment in a higher-level one. As a result, it is cumbersome to mechanize these techniques using general-purpose theorem provers. Moreover, it is undecidable whether a given relation is a simulation, even if tautology checking is decidable for the underlying specification logic. This article studies various types of normed simulations. In a normed simulation, each step in a lower-level specification can be simulated by at most one step in the higher-level one, for any related pair of states. In earlier work we demonstrated that normed simulations are quite useful as a vehicle for the formalization of refinement proofs via theorem provers. Here we show that normed simulations also have pleasant theoretical properties: (1) under some reasonable assumptions, it is decidable whether a given\u00a0\u2026", "num_citations": "35\n", "authors": ["1601"]}
{"title": "Two simple protocols\n", "abstract": " In the ACP formalism we can define (specify) networks of processes which cooperate in an asynchronous way. We can do this by looking at the communication channels in the network as processes which communicate in a synchronous way with the processors to which they are connected. Almost always, this synchronous communication will take place according to the handshaking paradigm: exactly two processes participate in every communication. When we specify communications of this type we will employ a read! send communication function: Let [) be a finite set of data which can be communicated between processes, and let IJl> be a finite set of locations (or ports) where synchronous communication can take place. The alphabet of atomic actions now consists of read actions rp (d), send actions sp (d) and communication actions cp (d) for pEIJl> and dED. As the only communications we have: y (rp (d), sp (d))= cp (d).", "num_citations": "35\n", "authors": ["1601"]}
{"title": "Modelling clock synchronization in the Chess gMAC WSN protocol\n", "abstract": " We present a detailled timed automata model of the clock synchronization algorithm that is currently being used in a wireless sensor network (WSN) that has been developed by the Dutch company Chess. Using the Uppaal model checker, we establish that in certain cases a static, fully synchronized network may eventually become unsynchronized if the current algorithm is used, even in a setting with infinitesimal clock drifts.", "num_citations": "33\n", "authors": ["1601"]}
{"title": "Specifying urgency in timed I/O automata\n", "abstract": " Tools and techniques based on timed automata (such as Uppaal and the timed I/O automata framework) have proven to be extremely useful for the analysis of protocols and control software for real-time systems. However, a significant limitation of these approaches is that, due to the expressiveness of the modeling languages, timelocks - degenerate states in which time is unable to pass - can freely arise and cannot, in the general case, be detected. As a remedy to this problem, Sifakis et al. advocate the use of deadline predicates for the specification of progress properties of Alur-Dill style timed automata. In this article, we extend these ideas to a more general setting, which may serve as a basis for deductive verification techniques. More specifically, we extend the TIOA framework of Lynch et al with urgency predicates. We identify a suitable language to describe the resulting timed I/O automata with urgency and\u00a0\u2026", "num_citations": "33\n", "authors": ["1601"]}
{"title": "Bundle event structures and CCSP\n", "abstract": " We investigate which event structures can be denoted by means of closed CCS \u222a CSP expressions.", "num_citations": "30\n", "authors": ["1601"]}
{"title": "A First Introduction to uppaal\n", "abstract": " This chapter provides a first introduction to the use of the model checking tool Uppaal. Uppaal is an integrated tool environment that allows users to model the behavior of systems in terms of states and transitions between states, and to simulate and analyze the resulting models. Uppaal can also handle real-time issues, that is, the timing of transitions. Using an example of a jobshop, we explain in a step by step manner how one can make a simple Uppaal model, simulate its behavior and analyze properties.", "num_citations": "29\n", "authors": ["1601"]}
{"title": "Fortuna: Model checking priced probabilistic timed automata\n", "abstract": " Fortuna is the first tool for model checking priced probabilistic timed automata (PPTAs). PPTAs are an important model that can handle the combination of real-time, probabilistic and cost features. Only model checkers that incorporate all these features can address the key design trade-offs that arise in many practical applications such as: the Zeroconf, Bluetooth, IEEE802.11 and Firewire protocols, protocols for sensor networks, and scheduling problems with failures. PPTAs are an extension of probabilistic timed automata (PTAs), by having cost-rates and discrete cost increments on states. Fortuna is able to compute the maximal probability by which a class of states can be reached under a certain cost-bound (and time bound.) Although the problem is undecidable in general, there exists a semi-algorithm that produces a non-decreasing sequence of maximal probabilities. This paper enhances that algorithm. We\u00a0\u2026", "num_citations": "29\n", "authors": ["1601"]}
{"title": "Model checker aided design of a controller for a wafer scanner\n", "abstract": " For a case-study of a wafer scanner from the semiconductor industry it is shown how model checking techniques can be used to compute (1) a simple yet optimal deadlock avoidance policy, and (2) an infinite schedule that optimizes throughput. in the absence of errors. Deadlock avoidance is studied based on a simple finite state model using Smv, and for throughput analysis a more detailed timed automaton model has been constructed and analyzed using the Uppaal tool. The Smv and Uppaal models are formally related through the notion of a stuttering bisimulation. The results were obtained within 2 weeks, which confirms once more that model checking techniques may help to improve the design process of realistic, industrial systems. Methodologically, the case study is interesting since two models were used to obtain results that could not have been obtained using only a single model.", "num_citations": "29\n", "authors": ["1601"]}
{"title": "Algebraic techniques for concurrency and their application\n", "abstract": " Algebraic techniques for concurrency and their application (1990) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication Algebraic techniques for concurrency and their application (1990) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Algebraic techniques for concurrency and their application Author FW Vaandrager (Frits) Date issued 1990-02-02 Access Closed Access Language English Type Doctoral Thesis Publication https://ir.cwi.nl/pub/29063 OpenURL Search this publication in (your) library Persistent Identifier urn:NBN:nl:ui:18-29063 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer >>> DANS is an institute of KNAW and NWO \u2026", "num_citations": "29\n", "authors": ["1601"]}
{"title": "A comparison of additivity axioms in timed transition systems\n", "abstract": " This paper discusses some axioms from the literature which have been used to define properties of timed transition systems. The additivity axiom proposed by (amongst others) Wang, and Nicollin and Sifakis is compared with the trajectory axiom of Lynch and Vaandrager. Some conditions for an additive transition system to be trajectoried are discussed. These are proved sufficient by using some simple terminology from category theory to show how this problem about timed transition systems can be turned into an equivalent problem about monotone functions on partially ordered sets. We also discuss trajectory (bi) simulation, which is a variant of Ho-Stuart\u2019s path bisimulation, and use similar techniques to discuss when (bi) simulation is equivalent to trajectory (bi) simulation.", "num_citations": "26\n", "authors": ["1601"]}
{"title": "Combining black-box and white-box techniques for learning register automata\n", "abstract": " Model learning is a black-box technique for constructing state machine models of software and hardware components, which has been successfully used in areas such as telecommunication, banking cards, network protocols, and control software. The underlying theoretic framework (active automata learning) was first introduced in a landmark paper by Dana Angluin in 1987 for finite state machines. In order to make model learning more widely applicable, it must be further developed to scale better to large models and to generate richer classes of models. Recently, various techniques have been employed to extend automata learning to extended automata models, which combine control flow with guards and assignments to data variables. Such techniques infer guards over data parameters and assignments from observations of test output. In the black-box model of active automata learning this can be\u00a0\u2026", "num_citations": "25\n", "authors": ["1601"]}
{"title": "Analysis of a clock synchronization protocol for wireless sensor networks\n", "abstract": " We study a clock synchronization protocol for the Chess WSN. First, we model the protocol as a network of timed automata and verify various instances using the Uppaal model checker. Next, we present a full parametric analysis of the protocol for the special case of cliques (networks with full connectivity), that is, we give constraints on the parameters that are both necessary and sufficient for correctness. These results have been checked using the proof assistant Isabelle. Finally, we present a negative result for the special case of line topologies: for any instantiation of the parameters, the protocol will eventually fail if the network grows. This result suggests a variation of the fundamental result of Fan and Lynch on gradient clock synchronization, where the synchronization eventually fails as the network diameter grows, for a setting with logical clocks whose value may also decrease.", "num_citations": "25\n", "authors": ["1601"]}
{"title": "Switched probabilistic I/O automata\n", "abstract": " A switched probabilistic I/O automaton is a special kind of probabilistic I/O automaton (PIOA), enriched with an explicit mechanism to exchange control with its environment. Every closed system of switched automata satisfies the key property that, in any reachable state, at most one component automaton is active. We define a trace-based semantics for switched PIOAs and prove it is compositional. We also propose switch extensions of an arbitrary PIOA and use these extensions to define a new trace-based semantics for PIOAs.", "num_citations": "25\n", "authors": ["1601"]}
{"title": "Normed simulations\n", "abstract": " In existing simulation proof techniques, a single step in a low-level system may be simulated by an extended execution fragment in a high-level system. As a result, it is undecidable whether a given relation is a simulation, even if tautology checking is decidable for the underlying specification logic. This paper introduces various types of . In a normed simulation, each step in a low-level system can be simulated by at most one step in the high level system, for any related pair of states. We show that it is decidable whether a given relation is a normed simulation relation, given that tautology checking is decidable. We also prove that, at the semantic level, normed simulations form a complete proof method for establishing behavior inclusion, provided that the high-level system has finite invisible nondeterminism. As an illustration of our method we discuss the verification in PVS of a leader election algorithm that is\u00a0\u2026", "num_citations": "25\n", "authors": ["1601"]}
{"title": "Extending UPPAAL for the modeling and verification of dynamic real-time systems\n", "abstract": " Dynamic real-time systems, where the number of processes is not constant and new processes can be created on the fly like in object-based systems and ad-hoc networks, are still lacking a formal framework enabling their verification. Different toolboxes like Uppaal [21], Tina [10], Red [28] and Kronos [29] have been designed to deal with the modeling and analysis of real-time systems. Nevertheless, a shortcoming of these tools is that they can only describe static topologies. Other tools like Spin [18] allow the dynamic creation of processes, but do not consider time aspects. This paper presents a formal framework for modeling and verifying dynamic real-time systems. We introduce callable timed automata as a simple but powerful extension of standard timed automata in which processes may call each other. We show that the semantics of each call event can be interpreted either as an activation of the\u00a0\u2026", "num_citations": "22\n", "authors": ["1601"]}
{"title": "Determinism\u2192(event structure isomorphism= step sequence equivalence)\n", "abstract": " A concurrent system S is called determinism if for all states s of S we have that whenever S can evolve from state s into states s\u2032 and s\u2033 by doing an action a, it must be the case that s\u2032 equals s\u2033. It is well known that for deterministic concurrent systems, most of the interleaved equivalences (bisimulation-, failure-, trace-equivalence) coincide. In this paper we prove in the setting of event structures that also most of the non-interleaved equivalences coincide (with each other) on this domain. In the last section of the paper we show that, as a consequence of our result, the causal structure of a deterministic concurrent system can be unravelled by observers who are capable of observing the beginning and termination of events.", "num_citations": "22\n", "authors": ["1601"]}
{"title": "Benchmarks for automata learning and conformance testing\n", "abstract": " We describe a large collection of benchmarks, publicly available through the wiki automata.cs.ru.nl, of different types of state machine models: DFAs, Moore machines, Mealy machines, interface automata and register automata. Our repository includes both randomly generated state machines and models of real protocols and embedded software/hardware systems. These benchmarks will allow researchers to evaluate the performance of new algorithms and tools for active automata learning and conformance testing.", "num_citations": "21\n", "authors": ["1601"]}
{"title": "Algorithms for inferring register automata\n", "abstract": " In recent years, two different approaches for learning register automata have been developed: as part of the LearnLib tool algorithms have been implemented that are based on the Nerode congruence for register automata, whereas the Tomte tool implements algorithms that use counterexample-guided abstraction refinement to automatically construct appropriate mappers. In this paper, we compare the LearnLib and Tomte approaches on a newly defined set of benchmarks and highlight their differences and respective strengths.", "num_citations": "19\n", "authors": ["1601"]}
{"title": "The axiomatization of override and update\n", "abstract": " There are only very few natural ways in which arbitrary functions can be combined. One composition operator is override: for arbitrary functions f and g, f\u25b7 g is the function with domain dom (f)\u222a dom (g) that behaves like f on dom (f) and like g on dom (g)\u2216 dom (f). Another operator is update: f [g] has the same domain as f, behaves like f on dom (f)\u2216 dom (g), and like g on dom (f)\u2229 dom (g). These operators are widely used, especially within computer science, where for instance f [g] may denote the new state that results when in state f the updates given as g are applied. It is therefore surprising that thus far no axiomatization of these operators has been proposed in the literature. As an auxiliary operator we consider the minus operator: f\u2212 g is the restriction of f to the domain dom (f)\u2216 dom (g). The update operator can be defined in terms of override and minus. We present five equations that together constitute a sound\u00a0\u2026", "num_citations": "18\n", "authors": ["1601"]}
{"title": "Modeling and verifying a Lego car using hybrid I/O automata\n", "abstract": " We illustrate the application of the hybrid I/O automata framework of Lynch, Segala & Vaandrager by using it to model and analyze the behavior of a simple Lego car with caterpillar treads. We derive constraints on the values of the parameters that occur in our hybrid model that guarantee that the car always moves forward along a black tape, and never gets off the tape or move backward. In order to simplify the correctness proof, we introduce a transition system that abstracts from the hybrid automaton in a rather drastic manner, but still preserves validity of the correctness properties in which we are interested. Even though our original model does not involve any disturbances, the general parametric analysis of the system allows us to extend our results in a trivial manner to a hybrid model in which several disturbances are allowed (mistakes in measurements of lengths, drift and jitter of the hardware clock, velocity\u00a0\u2026", "num_citations": "18\n", "authors": ["1601"]}
{"title": "A note on fairness in I/O automata\n", "abstract": " Notions of weak and strong fairness are studied in the setting of the I/O automaton model of Lynch and Tuttle. The concept of a fair I/O automaton is introduced and it is shown that a fair I/O automaton paired with the set of its fair executions is a live I/O automaton provided that 1.(1) in each reachable state at most countably many fairness sets are enabled, and2.(2) input actions cannot disable strong fairness sets.  This result, which generalizes previous results known from the literature, was needed to solve a problem posed by Broy and Lamport for the Dagstuhl Workshop on Reactive Systems.", "num_citations": "16\n", "authors": ["1601"]}
{"title": "Verification of a distributed summation algorithm\n", "abstract": " A correctness proof of a variant of Segall's Propagation of Information with Feedback protocol is outlined. The proof, which is carried out within the I/O automata model of Lynch and Tuttle, is standard except for the use of a prophecy variable. The aim of this paper is to show that, unlike what has been suggested in the literature, assertional methods based on invariant reasoning support an intuitive way to think about and understand this algorithm.", "num_citations": "16\n", "authors": ["1601"]}
{"title": "Model learning as a satisfiability modulo theories problem\n", "abstract": " We explore an approach to model learning that is based on using satisfiability modulo theories (SMT) solvers. To that end, we explain how DFAs, Mealy machines and register automata, and observations of their behavior can be encoded as logic formulas. An SMT solver is then tasked with finding an assignment for such a formula, from which we can extract an automaton of minimal size. We provide an implementation of this approach which we use to conduct experiments on a series of benchmarks. These experiments address both the scalability of the approach and its performance relative to existing active learning tools.", "num_citations": "14\n", "authors": ["1601"]}
{"title": "Adaptive scheduling of data paths using Uppaal Tiga\n", "abstract": " We apply Uppaal Tiga to automatically compute adaptive scheduling strategies for an industrial case study dealing with a state-of-the-art image processing pipeline of a printer. As far as we know, this is the first application of timed automata technology to an industrial scheduling problem with uncertainty in job arrivals.", "num_citations": "14\n", "authors": ["1601"]}
{"title": "Does it Pay Off? Model-Based Verification and Validation of Embedded Systems!\n", "abstract": " An overview is presented of the state-of-the-art in modelbased verification and validation of embedded systems, directed towards an industrial audience. Verification and validation consists in exploring the current design against properties expressed as part of the requirements. It includes testing, model checking, runtime verification and faultdiagnosis, and more exploratory techniques such as the use of theorem proving. During recent years, much progress has been made in theory, methods and tools for model-based verification and validation. In this paper, I will try to indicate for what type of practical problems it pays off to apply one of these modern techniques. Special attention will be paid to the results of six PROGRESS projects in this area.", "num_citations": "14\n", "authors": ["1601"]}
{"title": "Some observations on redundancy in a context\n", "abstract": " Let x be a process which can perform an action a when it is in state s. In this article we consider the situation where x is placed in a context which blocks a whenever x is in s. The option of doing a in state s is redundant in such a context and x can be replaced by a process x'which is identical to x, except for the fact that x'cannot do a when it is in s (irrespective of the context). A simple, compositional proof technique is presented, which uses information about the traces of processes to detect redundancies in a process specification. As an illustration of the technique, a modular verification of a workcell architecture is presented.", "num_citations": "14\n", "authors": ["1601"]}
{"title": "Control synthesis for a smart card personalization system using symbolic model checking\n", "abstract": " Using the Cadence SMV symbolic model checker we synthesize, under certain error assumptions, a\u00a0scheduler for the smart card personalization system, a\u00a0case study that has been proposed by Cybernetix Recherche in the context of the EU IST project AMETIST. The scheduler that we synthesize, and of which we prove optimality, has been previously patented. Due to the large number of states (which is beyond 1013), this synthesis problem appears to be out of the scope of existing tools for controller synthesis, which typically use some form of explicit state enumeration. Our result provides new evidence that model checkers can be useful to tackle industrial sized problems in the area of scheduling and control synthesis.", "num_citations": "12\n", "authors": ["1601"]}
{"title": "Reconstructing critical paths from execution traces\n", "abstract": " We consider the problem of constructing critical paths from incomplete information. In general, a directed acyclic graph of tasks with their execution times (i.e., a task graph) is necessary to extract critical paths. We assume, however, that only the set of tasks, and their start and end times are known, e.g., an execution trace in the form of a Gantt chart. This information can be extracted from real machines or from the output of analysis tools, whereas extraction of the exact task graph often is problematic due to imperative modeling formalisms and complicated platform semantics (resource allocation, varying execution speeds). We show that, based on start and end times only, an over- approximation of the critical paths of an unknown task graph can be extracted nevertheless. Furthermore, this approach is generalized to deal with \"noisy\" execution traces of real machines in which control overhead is present. Finally, we\u00a0\u2026", "num_citations": "11\n", "authors": ["1601"]}
{"title": "A theory of history dependent abstractions for learning interface automata\n", "abstract": " History dependent abstraction operators are the key for scaling existing methods for active learning of automata to realistic applications. Recently, Aarts, Jonsson & Uijen have proposed a framework for history dependent abstraction operators. Using this framework they succeeded to automatically infer models of several realistic software components with large state spaces, including fragments of the TCP and SIP protocols. Despite this success, the approach of Aarts et al. suffers from limitations that seriously hinder its applicability in practice. In this article, we get rid of some of these limitations and present four important generalizations/improvements of the theory of history dependent abstraction operators. Our abstraction framework supports: (a) interface automata instead of the more restricted Mealy machines, (b) the concept of a learning purpose, which allows one to restrict the learning process to\u00a0\u2026", "num_citations": "11\n", "authors": ["1601"]}
{"title": "Lectures on Embedded Systems: European Educational Forum School on Embedded Systems, Veldhoven, The Netherlands, November 25-29, 1996\n", "abstract": " This volume originates from the School on Embedded Systems held in Veldhoven, The Netherlands, in November 1996 as the first event organized by the European Educational Forum. Besides thoroughly reviewed and revised chapters based on lectures given during the school, additional papers have been solicited for inclusion in the present book in order to complete coverage of the relevant topics. The authors adress professionals involved in the design and management of embedded systems in industry as well as researchers and students interested in a competent survey. The book will convince the reader that many architectural and algorithmic problems in the area of embedded systems have well documented optimal or correct solutions, notably in the fields of real-time computing, distributed computing, and fault-tolerant computing.", "num_citations": "11\n", "authors": ["1601"]}
{"title": "Grey-box learning of register automata\n", "abstract": " Model learning (a.k.a. active automata learning) is a highly effective technique for obtaining black-box finite state models of software components. We show how one can boost the performance of model learning techniques for register automata by extracting the constraints on input and output parameters from a run, and making this grey-box information available to the learner. More specifically, we provide new implementations of the tree oracle and equivalence oracle from the RALib tool, which use the derived constraints. We extract the constraints from runs of Python programs using an existing tainting library for Python, and compare our grey-box version of RALib with the existing black-box version on several benchmarks, including some data structures from Python\u2019s standard library. Our proof-of-principle implementation results in almost two orders of magnitude improvement in terms of numbers of inputs sent to\u00a0\u2026", "num_citations": "10\n", "authors": ["1601"]}
{"title": "Verification of printer datapaths using timed automata\n", "abstract": " In multiprocessor systems with many data-intensive tasks, a bus may be among the most critical resources. Typically, allocation of bandwidth to one (high-priority) task may lead to a reduction of the bandwidth of other tasks, and thereby effectively slow down these tasks. WCET analysis for these types of systems is a major research challenge. In this paper, we show how the dynamic behavior of a memory bus and a USB in a realistic printer application can be faithfully modeled using timed automata. We analyze, using Uppaal, the worst case latency of scan jobs with uncertain arrival times in a setting where the printer is concurrently processing an infinite stream of print jobs.", "num_citations": "10\n", "authors": ["1601"]}
{"title": "Bigger is not always better: on the quality of hypotheses in active automata learning\n", "abstract": " In Angluin\u2019s L^\u2217 algorithm a learner constructs a sequence of hypotheses in order to learn a regular language. Each hypothesis is consistent with a larger set of observations and is described by a bigger model. From a behavioral perspective, however, a hypothesis is not always better than the previous one, in the sense that the minimal length of a counterexample that distinguishes a hypothesis from the target language may decrease. We present a simple modification of the L^\u2217 algorithm that ensures that for subsequent hypotheses the minimal length of a counterexample never decreases, which implies that the distance to the target language never increases in a corresponding ultrametric. Preliminary experimental evidence suggests that our algorithm speeds up learning in practical applications by reducing the number of equivalence queries.", "num_citations": "9\n", "authors": ["1601"]}
{"title": "Using model checkers in an introductory course on operating systems\n", "abstract": " During the last three years, we have been experimenting with the use of the Uppaal model checker in an introductory course on operating systems for first-year Computer Science students at the Radboud University Nijmegen. The course uses model checkers as a tool to explain, visualize and solve concurrency problems. Our experience is that students enjoy to play with model checkers because it makes concurrency issues tangible. Even though it is hard to measure objectively, we think that model checkers really help students to obtain a deeper insight into concurrency. In this article, we report on our experiences in the classroom, explain how mutual exclusion algorithms, semaphores and monitors can conveniently be modeled in Uppaal, and present some results on properties of small, concurrent patterns.", "num_citations": "9\n", "authors": ["1601"]}
{"title": "Recognizing finite repetitive scheduling patterns in manufacturing systems\n", "abstract": " Optimization of timing behaviour of manufacturing systems can be regarded as a scheduling problem in which tasks model the various production processes. Typical for many manufacturing systems is that tasks or collections of tasks can be associated with manufacturing entities, which can be structured hierarchically. Execution of production processes for several instances of these entities results in nested finite repetitions, which blows up the size of the task graph that is needed for the specification of the scheduling problem, and, in an even worse way, the number of possible schedules. We present a subclass of UML activity diagrams which is generic for the number of repetitions, and therefore suitable for the compact specification of task graphs for these manufacturing systems. The approach to reduce the complexity of the scheduling problem exploits the repetitive patterns extracted from the activity diagrams. It reduces the original problem to a problem containing some minimal number of identical repetitions, and after scheduling of this much smaller problem the schedule is expanded to the original size. We demonstrate our technique on a real-life example from the semiconductor industry.", "num_citations": "8\n", "authors": ["1601"]}
{"title": "SOS rule formats for parameterized and state-bearing processes\n", "abstract": " We propose a general format of Structural Operational Semantics rules that can deal with parameterized and state-bearing processes. Plotkin's original SOS denitions of imperative programs and of CSP, as well as the operational semantics of value passing process calculi like LOTOS, CRL and real-time ACP are covered by this format. We prove that the format provides a well-dened operational semantics with respect to an appropriate notion of bisimulation, and identify sub-formats with desirable niteness and decidability properties. 1 Introduction Plotkin's [19, 20] method of Structural Operational Semantics (SOS) is widely used to dene the operational meaning of programming languages and process calculi. In recent years it has become more and more clear that many of the key theorems in operational semantics are to a large extent language independent: many important properties of SOS style denitions follow from the syntactic form of the inference rules, and can be established f...", "num_citations": "8\n", "authors": ["1601"]}
{"title": "Active learning of extended finite state machines\n", "abstract": " Once they have high-level models of the behavior of software components, engineers can construct better software in less time. A key problem in practice, however, is the construction of models for existing software components, for which no or only limited documentation is available. In this talk, I will present an overview of recent work by my group \u2014 done in close collaboration with the Universities of Dortmund and Uppsala \u2014 in which we use machine learning to infer state diagram models of embedded controllers and network protocols fully automatically through observation and test, that is, through black box reverse engineering.", "num_citations": "7\n", "authors": ["1601"]}
{"title": "Enhancing automata learning by log-based metrics\n", "abstract": " We study a general class of distance metrics for deterministic Mealy machines. The metrics are induced by weight functions that specify the relative importance of input sequences. By choosing an appropriate weight function we may fine-tune a metric so that it captures some intuitive notion of quality. In particular, we present a metric that is based on the minimal number of inputs that must be provided to obtain a counterexample, starting from states that can be reached by a given set of logs. For any weight function, we may boost the performance of existing model learning algorithms by introducing an extra component, which we call the Comparator. Preliminary experiments show that use of the Comparator yields a significant reduction of the number of inputs required to learn correct models, compared to current state-of-the-art algorithms. In existing automata learning algorithms, the quality of subsequent\u00a0\u2026", "num_citations": "6\n", "authors": ["1601"]}
{"title": "Formal Modeling and Analysis of Timed Systems\n", "abstract": " Formal Modeling and Analysis of Timed Systems - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Formal Modeling and Analysis of Timed Systems Ouaknine, Jo\u00ebl ; Vaandrager, Frits W. Abstract Publication: Lecture Notes in Computer Science Pub Date: 2009 DOI: 10.1007/978-3-642-04368-0 Bibcode: 2009LNCS.5215.....O Keywords: Computer Science; Logics and Meanings of Programs; Theory of Computation; Models and Principles; Symbolic and Algebraic Manipulation; Programming Languages; Compilers; Interpreters; Software Engineering full text sources Publisher | \u00a9 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo Resources About ADS ADS Help What's New Careers@ADS Social @adsabs ADS Blog \u2026", "num_citations": "6\n", "authors": ["1601"]}
{"title": "MapReduce framework performance comparison\n", "abstract": " This paper describes my effort to verify the speedup results of the Phoenix 2 framework. This framework is an implementation of MapReduce, which is a programming model for distributed computing without having the programmer to write parallel code. Reproducing the speedup results fails partly, due to performance issues in the Phoenix 2 implementation. In addition the achieved speedups for Phoenix are compared to those of Hadoop, another large MapReduce framework, which is very popular amongst large companies. Hadoop seems to scale better compared to Phoenix, but an explanation for these results might be the performance issues of Phoenix. In addition, the number of tests that is used for comparison is too low to draw a solid conclusion.", "num_citations": "5\n", "authors": ["1601"]}
{"title": "Hybrid systems\n", "abstract": " In this contribution, we will brie y sketch the development of this eld. Also, we will discuss recent work on hybrid systems in the group Concurrency and Real-time Systems at CWI.2 Motivation With the decrease in the size and price of computing elements, more and more computers are used within real-world technical applications such as in avionics, process control, robotics, telecommunications and consumer products. In all these\\embedded\" applications it is software that determines to a large extent the functionality of the products and that o ers the required dynamics and exibility. This makes the construction of large real-time embedded computer systems one of the most challenging tasks facing the computer science community, if not the engineering community as a whole. Characteristic of embedded computers systems is that they are reactive: they accept stimuli from the outside world and react to those stimuli. This means that one can only design and reason about the correctness of these systems if one takes the behavior of the outside world into account. As an example, consider a computer controlling a chemical plant. Regularly, the control program reads sensor data, such as temperature and pressure, of the plant. Based on these data, the computer may decide to turn on a heating system, switch oa pump, etc. When a dangerous situation arises, for instance the pressure in a tank gets too high, the computer has to initiate appropriate action, like opening a", "num_citations": "5\n", "authors": ["1601"]}
{"title": "Learning mealy machines with one timer\n", "abstract": " We present Mealy machines with a single timer (MM1Ts), a class of models that is both sufficiently expressive to describe the real-time behavior of many realistic applications, and can be learned efficiently. We show how learning algorithms for MM1Ts can be obtained via a reduction to the problem of learning Mealy machines. We describe an implementation of an MM1T learner on top of LearnLib, and compare its performance with recent algorithms proposed by Aichernig et al. and An et al. on several realistic benchmarks.", "num_citations": "4\n", "authors": ["1601"]}
{"title": "Learning Mealy machines with timers\n", "abstract": " We introduce a new model of Mealy machines with timers (MMTs), which is able to describe the timing behavior of a broad class of practical systems, and sufficiently restricted for active learning algorithms. We present a natural extension of Angluin\u2019s active learning algorithm, which employs sequences of inputs with precise timing. Our algorithm is based on three key results:(i) an untimed semantics for MMTs, which is equivalent to the natural timed one (ii) a Nerode congruence based on the untimed semantics, and (iii) an active automata learning algorithm which is based on approximating this Nerode congruence. This algorithm allows to learn MMTs using a number of membership and equivalence queries, which is polynomial in the number of states of the resulting MMT, and doubly exponential in the maximal number of simultaneously active timers.", "num_citations": "4\n", "authors": ["1601"]}
{"title": "Modeling task systems using parameterized partial orders\n", "abstract": " Inspired by work on model-based design of printers, the notion of a parametrized partial order (PPO) has recently been introduced. PPOs are a simple extension of partial orders, expressive enough to compactly represent large task graphs with finite repetitive behavior. We present a translation of a subclass of PPOs to timed automata and prove that the transition system induced by the Uppaal models is isomorphic to the configuration structure of the original PPO. Moreover, we introduce real-time task systems (RTTSs), a general model for real-time embedded systems that we have used to describe the data paths of realistic printer designs. In an RTTS, tasks are represented as PPOs and the pace of a task instance may vary, depending on the resources that are allocated to it. We describe a translation of a subclass of RTTSs to Uppaal, and establish, for an even smaller subclass, bisimulation equivalence\u00a0\u2026", "num_citations": "4\n", "authors": ["1601"]}
{"title": "Parallel Composition in a Paper by Jensen, Larsen & Skou is not Associative\n", "abstract": " In [JLS00] Jensen, Larsen & Skou: 1) claim to have constructed a framework that captures an important part of the semantics for networks of timed automata as used in the Uppaal model checker. 2) show a simulation relation within the framework such that making an abstraction of a single parallel component leads to an abstraction of the whole system. We will show that their claim (1) contains a essential flaw, because parallel composition in their framework is not associative.We use all definitions, lemma\u2019s, and theorems from [JLS00]. Consider in total only one variable u that can have only the value 0 or 1. The set of variables becomes V={u}. Assume we are working with semantics of timed automata that do not use clocks. We can simply draw timed transition systems, without having to worry about denseness of time. Assume three timed transition systems TA, TB, and TC. TTS TA is able to write variable u, and WA={u}. The drawing for TA is:", "num_citations": "4\n", "authors": ["1601"]}
{"title": "A Myhill-Nerode theorem for register automata and symbolic trace languages\n", "abstract": " We propose a new symbolic trace semantics for register automata (extended finite state machines) which records both the sequence of input symbols that occur during a run as well as the constraints on input parameters that are imposed by this run. Our main result is a generalization of the classical Myhill-Nerode theorem to this symbolic setting. Our generalization requires the use of three relations to capture the additional structure of register automata. Location equivalence\u2261 l captures that symbolic traces end in the same location, transition equivalence\u2261 t captures that they share the same final transition, and a partial equivalence relation\u2261 r captures that symbolic values v and v\u2032 are stored in the same register after symbolic traces w and w\u2032, respectively. A symbolic language is defined to be regular if relations\u2261 l,\u2261 t and\u2261 r exist that satisfy certain conditions, in particular, they all have finite index. We show\u00a0\u2026", "num_citations": "3\n", "authors": ["1601"]}
{"title": "A new approach for active automata learning based on apartness\n", "abstract": " We present , a new and simple approach to active automata learning. Instead of focusing on equivalence of observations, like the  algorithm and its descendants,  takes a different perspective: it tries to establish apartness, a constructive form of inequality.  does not require auxiliary notions such as observation tables or discrimination trees, but operates directly on tree-shaped automata.  has the same asymptotic query and symbol complexities as the best existing learning algorithms, but we show that adaptive distinguishing sequences can be naturally integrated to boost the performance of  in practice. Experiments with a prototype implementation, written in Rust, suggest that  is competitive with existing algorithms.", "num_citations": "3\n", "authors": ["1601"]}
{"title": "Learning Unions of k-Testable Languages\n", "abstract": " A classical problem in grammatical inference is to identify a language from a set of examples. In this paper, we address the problem of identifying a union of languages from examples that belong to several different unknown languages. Indeed, decomposing a language into smaller pieces that are easier to represent should make learning easier than aiming for a too generalized language. In particular, we consider k-testable languages in the strict sense (k-TSS). These are defined by a set of allowed prefixes, infixes (sub-strings) and suffixes that words in the language may contain. We establish a Galois connection between the lattice of all languages over alphabet , and the lattice of k-TSS languages over . We also define a simple metric on k-TSS languages. The Galois connection and the metric allow us to derive an efficient algorithm to learn the union of k-TSS languages. We evaluate our algorithm\u00a0\u2026", "num_citations": "3\n", "authors": ["1601"]}
{"title": "Learning pairwise disjoint simple languages from positive examples\n", "abstract": " A classical problem in grammatical inference is to identify a deterministic finite automaton (DFA) from a set of positive and negative examples. In this paper, we address the related - yet seemingly novel - problem of identifying a set of DFAs from examples that belong to different unknown simple regular languages. We propose two methods based on compression for clustering the observed positive examples. We apply our methods to a set of print jobs submitted to large industrial printers.", "num_citations": "3\n", "authors": ["1601"]}
{"title": "Parallel composition in a paper by De Alfaro ea is not associative\n", "abstract": " Interface formalisms are used to model both input and output requirements of system components. In [dAdSF+ 05] de Alfaro ea present Sociable Interfaces in which interfaces can communicate via action synchronization as well as via shared variables. They show how interfaces can be composed via a product operator, and how bad states in the product can be pruned such that a parallel composition can be obtained. Moreover they show a refinement relation for sociable interfaces. The theory is implemented into the tool Ticc, which is available from the website", "num_citations": "3\n", "authors": ["1601"]}
{"title": "Specification and verification of a circuit in ACP\n", "abstract": " Baeten, JCM & Vaandrager, FW 1988, Specification and verification of a circuit in ACP. Reports of the programming research group, University of Amsterdam= Rapporten van de vakgroep programmatuur, Universiteit van Amsterdam, vol. P8803, Universiteit van Amsterdam, Amsterdam.", "num_citations": "3\n", "authors": ["1601"]}
{"title": "Recreational formal methods: designing vacuum cleaning trajectories\n", "abstract": " We study an example due to Wooldridge of a small robotic agent that will vacuum clean a room. The room is an n\u00d7 n grid and at any point the robot can move forward one step or turn right 90 degrees. The problem is to find a deterministic strategy for the robot in which (1) its next action only depends on its current square and orientation (one of north, west, south, east), and (2) all squares are visited infinitely often. We use a model checker and a SAT solver to find such strategies, and a proof assistant to exhibit certain symmetries in the problem.", "num_citations": "2\n", "authors": ["1601"]}
{"title": "State identification for labeled transition systems with inputs and outputs\n", "abstract": " For Finite State Machines (FSMs) a rich testing theory has been developed to discover aspects of their behavior and ensure their correct functioning. Although this theory has been frequently used, e.g. to check conformance of protocol implementations, its applicability is limited by restrictions of FSMs, in which inputs and outputs alternate, and outputs are determined by the previous input and state. Labeled Transition Systems with inputs and outputs (LTSs), as studied in ioco testing theory, provide a richer framework for testing component oriented systems, but lack the algorithms for test generation from FSM theory.In this article, we propose an algorithm for the fundamental problem of state identification during testing of LTSs. Our algorithm is a direct generalization of the well-known algorithm for computing adaptive distinguishing sequences for FSMs proposed by Lee and Yannakakis. Our algorithm has to deal with\u00a0\u2026", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Learning nondeterministic register automata using mappers\n", "abstract": " Angluin\u2019s algorithm has been extended to Mealy machines by Niese and implemented in the LearnLib tool. Membership queries are replaced by output queries: which output is generated in response to a sequence of inputs? Equivalence queries are approximated by test sequences generated using algorithms for model based testing", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Generating a google go framework from an uppaal model\n", "abstract": " Dealing with concurrency and parallelism is hard. Using scientific tools, models can be created giving insight into the nature of concurrent structures. Using these models one can sometimes even prove that various conditions hold within the model. To prevent human error when implementing a given model, one might consider a scheme where the source code for the concurrent behavior is generated from the model.We will demonstrate the possibility of such a scheme, specifically to generate a Google Go code framework from Uppaal models, which allows for the quick testing and correct implementation of the process described in by the model. Furthermore we will show the use of such a scheme using a example. Finally we will informally argue the validity of the algorithm.", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Uppaal voor Beginners\n", "abstract": " Uppaal is een zogenaamde model checker, een programma waarmee je modellen kunt maken van systemen met toestanden en overgangen tussen die toestanden, en waarmee je aan deze modellen kunt rekenen. Dit artikel is een handleiding in het gebruik van Uppaal, bedoeld voor absolute beginners. Gebruikmakend van een voorbeeld van een werkplaats, wordt stapsgewijs uitgelegd hoe je een eenvoudig Uppaal model kunt maken, simuleren en analyseren.", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Een Module over Model Checking voor het VWO\n", "abstract": " We beschrijven achtergrond, leerdoelen en opzet van een lesmodule over model checking voor klas 5 vwo, die dit jaar voor de derde keer verzorgd wordt in een samenwerking tussen de Radboud Universiteit Nijmegen en het Olympus College te Arnhem. Tevens doen we verslag van onze ervaringen bij het geven van deze module.", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Wat is Model Checking?\n", "abstract": " AchtergrondComputers zijn beslist de meest complexe dingen die de mens ooit geconstrueerd heeft. De complexiteit van computertechnologie wordt door veel mensen schromelijk onderschat en bijna dagelijks staan er dan ook berichten in de krant over problemen die veroorzaakt zijn door fouten met computers. Zo hoorden we de laatste weken over gekraakte toegangspasjes en OV-dagkaarten, storingen in de nieuwe Roertunnel, 730.000 verloren belastingaangiften en een storing bij het internetbankieren van de Rabobank.", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Modelgebaseerde verificatie en validatie loont\n", "abstract": " naar geautomatiseerd redeneren. Pas vrij recent zijn de barri\u00e8res richting praktische toepasbaarheid echt geslecht. In mijn overzicht van formele methodes ga ik uit van een diagram van John Rushby van het Stanford Research Institute (Figuur 1). Daarin staat de inspanning die vereist is om een techniek toe te passen, uitgezet tegen het extra vertrouwen in correctheid die het gebruik ervan oplevert. Het diagram laat zien dat onzichtbare formele methodes voor relatief weinig inspanning al veel resultaat opleveren. Met model-checking, automatische abstractie en theorem-proving is het vertrouwen in de correctheid van een systeem nog verder te vergroten, maar daarvoor moeten we wel veel investeren.", "num_citations": "1\n", "authors": ["1601"]}
{"title": "A theory of testing for timed automata\n", "abstract": " A Theory of Testing for Timed Automata (Abstract) | Proceedings of the 7th International Joint Conference CAAP/FASE on Theory and Practice of Software Development ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsTAPSOFT '97A Theory of Testing for Timed Automata (Abstract) ARTICLE A Theory of Testing for Timed Automata (Abstract) Share on Author: Frits W Vaandrager profile image Frits W. Vaandrager View Profile Authors Info & Affiliations Publication: TAPSOFT '97: Proceedings of the 7th International Joint Conference CAAP/FASE on Theory and Practice of Software DevelopmentApril 1997 0citation 0 Downloads \u2026", "num_citations": "1\n", "authors": ["1601"]}
{"title": "De ingebouwde informatica\n", "abstract": " Veel van mijn voorouders waren werkzaam als landbouwer in plaatsen als Barendrecht en Charlois. Zo passeerde iemand die omstreeks 1920 de Charloisse Lagendijk van de Dordtsestraatweg af insloeg drie boerderijen en een ruime woning zonder schuren, alle bewoond door Vaandragers 1]. In die tijd werd het graan nog gemaaid met de sikkel en het hooi met een zeis. Alle vervoer ging per wagen. De brik bracht de Vaandragers, die zeer kerks waren, op zondag naar de hervormde kerk van Charlois, per verenwagen ging men melken en de\\kromme dissel\", de boerenwagen met zware paarden voor vervoer van hooi en graan in de oogsttijd, was het meest imponerende vervoermiddel. Het is onvoorstelbaar hoe snel en hoe ingrijpend het leven sindsdien veranderd is. De Charloisse boerderijen lagen onder de rook van het zich steeds uitbreidende Rotterdam-Zuid. Binnen enkele jaren werden de eigenerfde boerengronden onteigend en de Vaandragers werden pachters van Rotterdam. Veel tekenen van de op handen zijnde grote veranderingen moeten toen al zichtbaar zijn geweest. Toch zou ik de gezichten van mijn voorouders wel eens hebben willen zien wanneer iemand ze verteld had over de frequente reizen van hun achterkleinkinderen in y-by-wire vliegtuigen, hoge snelheidstreinen en met airbags toegeruste personenwagens, over hoe Kurt Cobains gedigitaliseerde stemgeluid zal klinken uit hun stereotorens, over het internet waarover hun nakroost zal surfen en emails versturen, over de chipkaarten waarmee ze intelligente magnetrons zullen afrekenen, en| last-but-not-least| over e en van hun achterkleinkinderen die notabene\u00a0\u2026", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Specification and verification of a circuit in ACP (revised version)\n", "abstract": " Specification and verification of a circuit in ACP (revised version) (1988) | www.narcis.nl KNAW KNAW Narcis Back to search results Eindhoven University of Technology Publication Specification and verification of a circuit in ACP (revised version) (1988) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Specification and verification of a circuit in ACP (revised version) Series Reports of the programming research group, University of Amsterdam = Rapporten van de vakgroep programmatuur, Universiteit van Amsterdam, P8821 Author Baeten, JCM; Vaandrager, FW Date issued 1988 Access Open Access Language English Type Report Publisher Universiteit van Amsterdam Publication https://research.tue.nl/nl/publications/e1ce0bf8-4ad0-4aee-a... Persistent Identifier urn:nbn:nl:ui:25-e1ce0bf8-4ad0-4aee-ac0b-2229c4a50f10 \u2026", "num_citations": "1\n", "authors": ["1601"]}
{"title": "Exploring Adaptive Experiments\n", "abstract": " Adaptive Distinguishing Sequences (ADSs) have been used for state identification of Finite State Machines (FSMs). However, for some FSMs, no ADS exists. In this work, we formalize adaptive experiments, which can be constructed for any FSM. Additionally, we propose a way to measure the effectiveness of adaptive experiments, as well as a method to derive an adaptive experiment from an observation tree as described by [Vaandrager et al., 2021]. The lower and upper bound for our effectiveness measure are derived and it is demonstrated that adaptive experiments become more effective as the observation tree they are applied to is extended.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Active Automata Learning: from L* to L#\n", "abstract": " In this tutorial on active automata learning algorithms, I will start with the famous L *  algorithm proposed by Dana Angluin in 1987, and explain how this algorithm approximates the Nerode congruence by means of refinement. Next, I will present a brief overview of the various improvements of the L *  algorithm that have been proposed over the years. Finally, I will introduce L # , a new and simple approach to active automata learning. Instead of focusing on equivalence of observations, like the L *  algorithm and its descendants, L #  takes a different perspective: it tries to establish apartness, a constructive form of inequality.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Fingerprinting TLS Implementations Using Model Learning\n", "abstract": " We developed a new approach for generating and matching fingerprints for network protocol implementations and applied this to TLS server implementations. For generating the fingerprints we used model learning (aka active automata learning) to infer the state machine models of more than 200 different versions of two major TLS implementations. To perform the identification, we applied and compared two different methods. One method uses the adaptive distinguishing graph (ADG) algorithm, a direct generalization of Lee & Yannakakis algorithm for adaptive distinguishing sequences. The ADG pre-computes a decision tree with fixed inputs, and each model is identified through a unique input-output sequence. The other method is the heuristic decision tree (HDT), a new method that we present here. The HDT compares all models simultaneously during the identification and dynamically chooses which input to send based on heuristics. It is highly configurable and extendable, allowing multiple (and custom) input selection algorithms. We benchmarked and compared both methods using the models we learned. The performance of the two methods were comparable in our tests and we concluded that both the ADG and the HDT are capable of finding efficient input sequences to perform fingerprint matching.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Artifact for (A New Approach for Active Automata Learning Based on Apartness)@ TACAS 2022\n", "abstract": " This is the artifact submitted for the paper \u201cA New Approach for Active Automata Learning Based on Apartness.\u201d The artifact contains an implementation (called \u201cautomata-lib\u201d) of the L# learning algorithm introduced in the paper, alongside the benchmark models", "num_citations": "0\n", "authors": ["1601"]}
{"title": "BlueSpec: Development of an LMP state machine and a stateful black-box BR/EDR LMP fuzzer\n", "abstract": " We take a look at how to fuzz Bluetooth Basic Rate and Extended Data Rate (BR/EDR), also known as Bluetooth classic. Bluetooth LE is an alternative low energy communication technology similar to, but not compatible with Bluetooth BR/EDR. We review the parts of the Bluetooth Core Specification detailing Link Manager Protocol packets and find 3 ambiguities to exemplify complexity and ambiguity in the specification. We analyse and experiment with existing Bluetooth fuzzing frameworks or tools SweynTooth, InternalBlue, Frankenstein for finding both Bluetooth LE and Bluetooth BR/EDR implementation flaws. We find that there is a solution for fuzzing Bluetooth LE to be found in the SweynTooth framework, but that there is no satisfactory solution to fuzz the full stack of arbitrary Bluetooth BR/EDR implementations. There are tools and frameworks, namely Bluetooth Stack Smasher and BluePAss, to fuzz the upper host layers of a Bluetooth BR/EDR implementation namely the protocols L2CAP, ATT and SDP, but there are no solutions to fuzzing the lower controller stack protocols such as Baseband communication and the Link Manager Protocol (LMP). Internalblue is a promising new tool that offers the possibility of sending and observing LMP packets in existing connections. We build on the work of InternalBlue and develop a stateful black-box LMP fuzzer BlueSpec for low level Bluetooth BR/EDR fuzzing with the goal of finding Bluetooth implementation flaws. During the development of BlueSpec we find a potential DOS opportunity with Bluetooth BR/EDR legacy pairing packets and find two devices being vulnerable to the KNOB vulnerability\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Simulating Parallel Internal Column Contextual Array Grammars Using Two-Dimensional Parallel Restarting Automata with Multiple Windows\n", "abstract": " The connection between picture languages and restarting automata has been established in Otto (2014). An interesting class of picture languages generated by parallel contextual array grammars was studied with application in image generation and analysis in Subramanian et al. (2008). In this paper, we introduce a variant of two dimensional restarting automata that accepts a subclass of parallel internal contextual array languages. We show that these automata can simulate parallel internal column contextual array grammars in reverse order.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Model Learning and Testing (and some observations on formal methods research in the Netherlands)\n", "abstract": " Formal methods is often defined as the applied mathematics of computer system engineering. The Netherlands has a strong tradition in this area. This started with scientific giants such as Van Wijngaarden and Dijkstra, continued with eg, De Bakker, De Roever, Rozenberg, Rem, Barendregt, Bergstra and Klop, and led to the strong formal methods groups that we see at Dutch universities today. In addition, some highly visible Dutch formal methods researchers are active abroad, eg, Katoen, Holzmann, Van Glabbeek and Bloem. Still, my impression is that Dutch formal methods research is not as influential and authoritative as it used to be. A number of factors may have contributed to this:1. The field has matured and changed considerably over the years. Whereas, for instance, Bergstra & Klop could create major impact with papers on complete axiomatizations of process algebras, nowadays a nice theoretical idea is not enough. You also must show (or at least make it plausible) that an idea can be implemented and be effectively used to advance the state-of-the-art of computer system engineering. This is a different game, where rather than one or two brilliant theoreticians, you need a whole team/network of researchers, with different people focusing on theory, tools and applications. Despite notable exceptions, the Dutch formal methods community as a whole has not adapted fast enough to this new reality. Too often, I see formal methods papers in which the introduction refers to the importance of correct software, but the proposed methods have not been applied to real software yet, and there is not even a plausible scenario of how the results\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Automata Learning and Galois Connections (Invited Talk)\n", "abstract": " Automata learning is emerging as an effective technique for obtaining state machine models of software and hardware systems. I will present an overview of recent work in which we used active automata learning to find standard violations and security vulnerabilities in implementations of network protocols such as TCP and SSH. Also, I will discuss applications of automata learning to support refactoring of legacy control software and identifying job patterns in manufacturing systems. As a guiding theme in my presentation, I will show how Galois connections (adjunctions) help us to scale the application of learning algorithms to practical problems.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Source code and data relevant for the paper'Model Learning and Model Checking of SSH Implementations'\n", "abstract": " The dataset contains source code and data relevant for the paper \"Model Learning and Model Checking of SSH Implementations\". Paper url:  https://dl.acm.org/citation.cfm?id=3092289 PDF url: https://www.cs.ru.nl/E.Poll/papers/learning_ssh.pdf In this work, we use automata learning with abstraction to infer models of 3 SSH server implementations (BitVise, DropBear, OpenSSH). We then verify properties on these models using the NuSMV model checker. The dataset comprises the software components of our experimental setup apart from the actual implementations, some useful scripts and the learned models and associated experimental logs.   In more concrete terms, the dataset contains: - the learner (setup) implementation - Java code for the setup built around LearnLib to perform learning over sockets - the mapper implementation - Python code for the altered Paramiko SSH implementation  - experimental results - learned Mealy Machine models for 3 SSH server implementations (BitVise, OpenSSH, DropBear)  - experimental data - contain additional information not included in experimental results  - various Python scripts  - .dot to .smv converter - Java program for converting Mealy Machine .dot models to .smv model - .dot beautifying utility - Python program for making models more readable by merging edges between the same nodes  What can be re-used: - the learner setup (connect to the learner to a different system over sockets) - Mealy Machine .dot file to NuSMV conversion (convert any .dot to a .smv file suitable for NuSMV, which can be used in model checking) - Mealy Machine .dot models for 3 SSH implementations (if one wants to\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Explicit Model Checking\n", "abstract": " Explicit Model Checking Page 1 Introduction Main idea Algorithm Further results Explicit Model Checking Frits Vaandrager Institute for Computing and Information Sciences Radboud University Nijmegen The Netherlands fvaan@cs.ru.nl March 7, 2017 Frits Vaandrager Explicit Model Checking Page 2 Introduction Main idea Algorithm Further results 1 Introduction 2 Main idea 3 Algorithm Check basic formulae Check EU Check EG 4 Further results Frits Vaandrager Explicit Model Checking Page 3 Introduction Main idea Algorithm Further results Model Checking Problem M state-transition graph representing some computing system S specification expressed as formulae in some temporal logic Problem: Does M satisfy S ? Yes ! No ! And here is a counter-example ... Solutions based on traversal of state-space Explicit Symbolic Frits Vaandrager Explicit Model Checking Page 4 Introduction Main idea Algorithm Further \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Journal Papers\n", "abstract": " 8. J. Berendsen, B. Gebremichael, FW Vaandrager, and Miaomiao Zhang. Formal Specification and Analysis of Zeroconf using Uppaal. In ACM Transactions on Embedded Computing Systems 10 (3), 2011.(CORE: A)(Scholar: 41)(Using Uppaal we found 6 errors/ambiguities in the RFC for an internet protocol; our paper triggered further research on eg compositional verification and probabilistic model checking)", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Source code and data relevant for the paper'Combining Model Learning and Model Checking to Analyze TCP Implementations'\n", "abstract": " The dataset contains source code and data relevant for the paper \"Combining Model Learning and Model Checking to Analyze TCP Implementations\". Paper url:  https://link.springer.com/chapter/10.1007/978-3-319-41540-6_25 PDF url: http://www.sws.cs.ru.nl/publications/papers/fvaan/FJV16/main.pdf Ramon Janssen's Master's thesis url: http://www.ru.nl/publish/pages/769526/z_thesis_ramon_janssen.pdf  In this work, we use automata learning with abstraction to infer models of 3 TCP client and server implementations (Windows, Linux, FreeBSD). We then verify properties on these models using the NuSMV model checker. The dataset comprises the software components of our experimental setup apart from the actual implementations, some useful scripts and the learned models and associated experimental logs.   In more concrete terms, the dataset contains: - the learner (setup) implementation - Java code for the setup built around LearnLib to perform learning with abstraction over sockets. Abstraction is provided by a mapper, described in a mapper language described in the Master's thesis. - the mapper library - Java code for loading mappers written in the mapper language and executing them in both directions (from abstract to concrete and from concrete to abstract) - the network adapter - crafts packets from strings or messages (\"SYN(0,10)\") and sends them to a TCP entity, receives packets and turns them back to strings  - mappers - the mappers defined for the three operating systems learned - experimental data - Mealy Machine models for 6 TCP client/server implementations (BitVise, OpenSSH, DropBear) accompanied by other\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Source code and data relevant for the paper'Model Learning as a Satisfiability Modulo Theories Problem'\n", "abstract": " This datasets belongs to the following paper: Model Learning as a Satisfiability Modulo Theories Problem.  URL = http://www.sws.cs.ru.nl/publications/papers/fvaan/SMT/main.pdf  The dataset contains the source code of the tool implementing the SMT-based approach described in the paper, the setups/scripts used to run experiments and experimental logs.   Paper Abstract: We explore an approach to model learning that is based on using satisfiability modulo theories (SMT) solvers. To that end, we explain how DFAs, Mealy machines and register automata, and observations of their behavior can be encoded as logic formulas. An SMT solver is then tasked with finding an assignment for such a formula, from which we can extract an automaton of minimal size. We provide an implementation of this approach which we use to conduct experiments on a series of benchmarks. These experiments address both the scalability of the approach and its performance relative to existing active learning tools.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Model-checkers als slimme schroevendraaiers\n", "abstract": " Model-checkers als slimme schroevendraaiers (2012) | www.narcis.nl KNAW KNAW Narcis Back to search results Radboud University Nijmegen Publication Model-checkers als slimme schroevendraaiers (2012) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Model-checkers als slimme schroevendraaiers Published in Bits & Chips (Nijmegen), 8, 56 - 57. ISSN 1879-6443. Author Vaandrager, F. Date issued 2012 Access Closed Access Type Article Publication http://hdl.handle.net/2066/103537 OpenURL Search this publication in (your) library Persistent Identifiers NBN urn:nbn:nl:ui:22-2066/103537 Handle 2066/103537 Url http://hdl.handle.net/2066/103537 Metadata XML Source Radboud University Nijmegen Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Deliverable no.: D1. 4 Title of Deliverable: Modeling Tools\n", "abstract": " This deliverable presents the research on modeling tools that has been carried out within Task 1.3 of the QUASIMODO project.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Deliverable no.: D2. 4 Title of Deliverable: Abstraction and Refinement\n", "abstract": " This deliverable presents an overview of the work on abstraction and refinement that has been carried out within Task 2.2 during Year 3 of the QUASIMODO project.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "An Industrial Application of Uppaal: The Chess gMAC WSN Protocol\n", "abstract": " We report on an industrial application of the timed automaton model checking tool UPPAAL in the area of wireless sensor networks (WSN). We constructed a detailled UPPAAL model of the gMAC clock synchronization algorithm for a WSN architecture that has been developed by the Dutch company Chess. Using the UPPAAL model checker, we established that in certain cases a static, fully synchronized network may eventually become unsynchronized if the current algorithm is used, even in a setting with infinitesimal clock drifts.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Deliverable no.: D5. 7 Title of Deliverable: Case Studies: Validation\n", "abstract": " This deliverable summarises the Quasimodo activities on the modelling verification, analysis, and testing of the Quasimodo case studies in year 1 and 2.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Deliverable no.: D1. 3 Title of Deliverable: Model Process Improvement\n", "abstract": " This deliverable describes the view of the QUASIMODO project on model process improvement, and the lessons we learned concerning the modelling process by doing the QUASIMODO case studies.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Deliverable no.: D1. 1 Title of Deliverable: Modelling Quantitative System Aspects\n", "abstract": " This deliverable describes the results of the QUASIMODO project on modelling quantitative system aspects.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Nancy Lynch Celebration: Sixty and Beyond\n", "abstract": " Session details: Nancy Lynch celebration Page 1 In celebration of Nancy Lynch\u2019s sixtieth birthday, PODC and CONCUR feature a series of invited lectures illustrating and celebrating the impact of Nancy and her work. It is difficult to overstate this impact: Nancy has made fundamental contributions to the foundations of distributed computing by exploring the limits on computability and complexity in distributed systems, and by inventing ingenious algorithms to solve important problems. For these contributions, Nancy won the 2007 Knuth Prize, which described them as follows: In a career spanning more than 30 years, Professor Lynch developed new distributed algorithms, created precise models for analyzing distributed processes, and discovered limitations on what distributed algorithms can accomplish. In 1982, her research with MJ Fischer and MS Paterson produced a fundamental result, commonly known as the \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Informatica in Nijmegen\n", "abstract": " Informatica in Nijmegen Page 1 Academisch: wat is dat? Informaticaonderzoek in Nijmegen Informatica in Nijmegen Frits Vaandrager Radboud Universiteit Nijmegen 26 januari 2007 Frits Vaandrager Informatica in Nijmegen Page 2 Academisch: wat is dat? Informaticaonderzoek in Nijmegen Universiteit versus HBO \u25ba Het draait om inzicht \u25ba Docenten weten \u201cweinig\u201d, hebben vooral begeleidende rol \u25ba Open vragen komen veel voor \u25ba Wijze waarop je met probleem omgaat vaak belangrijker dan oplossing \u25ba Meer aandacht voor fundamentele vragen Frits Vaandrager Informatica in Nijmegen Page 3 Academisch: wat is dat? Informaticaonderzoek in Nijmegen Cursus Design of Embedded Systems Frits Vaandrager Informatica in Nijmegen Page 4 Academisch: wat is dat? Informaticaonderzoek in Nijmegen Kenmerken academische opleiding \u25ba Disciplinaire bagage \u25ba Onderzoeken \u25ba Ontwerpen \u25ba Wetenschap \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Formalizing SHIM6, a Proposed Internet Standard in UPPAAL\n", "abstract": " PDF hosted at the Radboud Repository of the Radboud University Nijmegen Page 1 PDF hosted at the Radboud Repository of the Radboud University Nijmegen The following full text is a publisher's version. For additional information about this publication click this link. http://hdl.handle.net/2066/34748 Please be advised that this information was generated on 2021-04-20 and may be subject to change. Page 2 Results \u2022Revealed incorrectness upon receiving payload in I2-SENT or I2BIS-SENT. \u2022Revealed possible deadlock with optional retransmitting I2 / I2bis messages. \u2022Clarified confusion about responder nonce. Revealed several other ambiguities, omissions and inconsistencies. Acknowledged by SHIM6 draft authors. Will be incorporated in new IETF proposal. Future Work UPPAAL: Improve model to verify on scale. Add failure detection and exploration. Extend UPPAAL verifier language. Indicate model state \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Compositionality in Real-Time Model Checking\n", "abstract": " Compositionality in Real-Time Model Checking Page 1 Compositionality in Real-Time Model Checking Jasper Berendsen & Frits Vaandrager Radboud University Nijmegen Foundations of Interface Technology (FIT) Workshop April 5, 2008 Berendsen & Vaandrager (Nijmegen) Compositionality in Real-Time Model Checking April 5, 2008 1 / 24 Page 2 A Dichotomy Modeling languages for reactive systems typically either support communication via shared variables or communication via synchronization of actions: \u25ba TLA, Reactive Modules, etc, \u25ba CCS, I/O automata, ACP, mCRL2, etc Berendsen & Vaandrager (Nijmegen) Compositionality in Real-Time Model Checking April 5, 2008 2 / 24 Page 3 A Non-Issue? Both types of communication can be defined in terms of each other: \u25ba A shared variable can be modeled as a separate process/automaton that communicates with its environment via read/write \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Analysis of the Zeroconf Protocol Using UPPAAL\n", "abstract": " We report on a case study in which the model checker UP-PAAL is used to formally model parts of Zeroconf, a protocol for dynamic configuration of IPv4 link-local addresses that has been defined in RFC 3927 of the IETF. Our goal has been to construct a model that (a) is easy to understand by engineers,(b) comes as close as possible to the informal text (for each transition in the model there should be a corresponding piece of text in the RFC), and (c) may serve as a basis for formal verification. Our conclusion is that UP-PAAL, which combines extended finite state machines, C-like syntax and concepts from timed automata theory, is able to model Zeroconf in a faithful and intuitive manner, using notations that are familiar to protocol engineers. Our modeling efforts revealed several errors (or at least ambiguities) in the RFC that no one else spotted before. We also identify a number of points where UPPAAL still can be improved. After applying a number of abstractions, UPPAAL is able to fully explore the state space of an instance of our model with three hosts.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "PROGRESS white papers 2006: embedded systems design, networks and connected systems, verification and validation, networks on chip\n", "abstract": " PROGRESS white papers 2006 : embedded systems design, networks... (2006) | www.narcis.nl KNAW KNAW Narcis Back to search results Eindhoven University of Technology Publication PROGRESS white papers 2006 : embedded systems design, networks... (2006) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title PROGRESS white papers 2006 : embedded systems design, networks and connected systems, verification and validation, networks on chip Author Corporaal, H.; Niemegeers, IGMM; Vaandrager, FW Publisher Electronic Systems Date issued 2006 Access Open Access Language English Type Book Publisher STW Technology Foundation Publication https://research.tue.nl/nl/publications/47e7ae39-1c33-48fe-9... ISBN 978-90-73461-00-0 Persistent Identifier urn:nbn:nl:ui:25-47e7ae39-1c33-48fe-917e-f51e0e67d0be \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "AMETIST DELIVERABLE 0.1. 4\n", "abstract": " Ametist intends to contribute to solutions for the growing industrial need to design reliable and efficient time dependent systems. In particular, it intends to provide theory and tools for errordetection, control and optimization of real-time distributed systems. Its approach will be based on translating state-of-the-art academic research into methods and tools that can be a basis for an industrial design practice of such systems.In addition to its technological contributions, Ametist invests actively in knowledge transfer to the European industry of computer-aided timing analysis and design. Moreover, it is expected that the academic dissemination of the Ametist research results will influence and advance the field of timed systems research, and (indirectly) contribute to the education of future generations of system engineers.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Specifying Urgency in Timed I/O Automata\n", "abstract": " Sifakis et al advocate the use of deadline predicates for the specification of progress properties of Alur-Dill style timed automata. In this article, we extend these ideas to a more general setting, which may serve as a basis for deductive verification techniques. More specifically, we extend the TIOA framework of Lynch et al with urgency predicates. We identify a suitable language to describe the resulting timed I/O automata with urgency and show that for this language time reactivity holds by construction. We also establish that the class of timed I/O automata with urgency is closed under composition. The use of urgency predicates is compared with three alternative approaches to specifying progress properties that have been advocated in the literature: invariants, stopping conditions and deadlines predicates. We argue that in practice the use of urgency predicates leads to shorter and more natural specifications than any of the other approaches. Some preliminary results on proving invariant properties of timed (I/O) automata with urgency are presented.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Onderzoeksagenda remt innovatief onderzoek\n", "abstract": " De Nationale Onderzoeksagenda's Informatica (NOAG-i), gepubliceerd in 1997 en 2001, hebben een politieke en een inhoudelijk-sturende rol. Vooral het politieke aspect is zeer succesvol geweest. De eerste NOAG-i maakte op ondubbelzinnige wijze duidelijk dat informaticaonderzoekers begrepen dat er een beroep op hen werd gedaan om de informatiemaatschappij mede vorm te geven. De onderzoeksvisitatiecommissie onder leiding van Cor Baayen constateerde in 1997 dat alhoewel de kracht en kwaliteit van de theoretische informatica indrukwekkend was, er te weinig toepassingsgericht onderzoek plaatsvond. Door een goede keuze van wetenschappelijk uitdagende en maatschappelijk geinspireerde thema's, en doordat Nw O hiervoor omstreeks de helft van het informaticabudget reserveerde, hebben de onderzoeksagend's in belangrijke mate bijgedragen aan de toegenomen aandacht voor toepassingsgericht onderzoek.Een andere belangrijke verdienste van de NOAG-i is dat de maatschappelijk geinspireerde thema's het mogelijk maakten om ook andere partijen (EZ, STW, NWO algemeen, de industrie) over te halen om geld te steken in programma's als Progress en Jacquard. Mede hierdoor is het totale volume van informaticaonderzoek in Nederland de afgelopen jaren fors gegroeid.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Control Automata\n", "abstract": " Here we define probabilistic i/o automata and some related notions. This is a straightforward combination of the Input/Output Automata model of Lynch and Tuttle [LT89] and the Simple Probabilistic Automata model of Segala [Seg95]. A probabilistic i/o automaton (PIOA) P consists of:\u2013a set States (P) of states;\u2013a start state s0\u2208 States (P);\u2013A set Act of action symbols, partitioned into: I (input actions), O (output actions) and H (hidden actions);\u2013a transition relation\u2192\u2286 States (P)\u00d7 Act\u00d7 Disc (States (P)).", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Linear Parametric Model Checking\n", "abstract": " We present an extension of the model checker UPPAAL capable of synthesize linear parameter constraints for the correctness of parametric timed automata. The symbolic representation of the (parametric) state-space is shown to be correct. A second contribution of this paper is the identification of a subclass of parametric timed automata (L/U automata), for which the emptiness problem is decidable, contrary to the full class where it is know to be undecidable. Also we present a number of lemmas enabling the verification effort to be reduced for L/U automata in some cases. We illustrate our approach by deriving linear parameter constraints for a number of well-known case studies from the literature (exhibiting a flaw in a published paper).", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Cooperative Multi-robot synchronization via estimated state feedback\n", "abstract": " Optimization of timing behaviour of manufacturing systems can be regardedas a scheduling problem in which tasks model the various productionprocesses. Typical for many manufacturing systems is that (collectionsof) tasks can be associated with manufacturing entities, which canbe structured hierarchically. Execution of production processes for severalinstances of these entities results in nested finite repetitions, whichblows up the size of the task graph that is needed for the specification ofthe scheduling problem, and, in an even worse way, the number of possibleschedules. We present a subclass of UML activity diagrams whichis generic for the number of repetitions, and therefore suitable for thecompact specification of task graphs for these manufacturing systems. The approach to reduce the complexity of the scheduling problem exploitsthe repetitive patterns. It reduces the original problem to a problemcontaining the minimum amount of identical repetitions, and afterscheduling of this much smaller problem the schedule is expanded tothe original size. We demonstrate our technique on a real-life examplefrom the semiconductor industry.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Distributing Timed Model Checking\n", "abstract": " In this paper we address the problem of distributing model checking of timed automata. We demonstrate through four real life examples that the combined processing and memory resources of multi-processor computers can be effectively utilized. The approach assumes a distributed memory model and is applied to both a network of worksta-tions and a symmetric multiprocessor machine. However, certain unex-pected phenomena have to be taken into account. We show how in the timed case the search order of the state space is crucial for the effectiveness and scalability of the exploration. An effective heuristic to counter the effect of the search order is provided. Some of the results open up for improvements in the single processor case.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Verification of hybrid Systems\n", "abstract": " The next stage of the computer revolution consists in the proliferation of sophisticated and cheap digital controllers into almost every aspect of man-made systems. Informatics is expected to shift its focus of attention from computers performing internal computations, or communicating with human users and with other computers, toward computers interacting in real-time with physical processes. In such settings, the proper functioning of the whole system depends critically on the interaction between the discrete dynamics of the digital controller and the continuous dynamics of the environment in which it is embedded. Models of hybrid systems suggest a framework for modelling, simulation, verification, synthesis and implementation of such systems.               The main activity of the Esprit LTR project VHS \u2014 Verification of Hybrid Systems \u2014 consists of analysing academic and industrial case studies, taken from\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Operational and logical semantics for polling real-time systems\n", "abstract": " PLC-Automata are a class of real-time automata suitable to describe the behavior of polling real-time systems. PLC-Automata can be compiled to source code for PLCs, a hardware widely used in industry to control processes. Also, PLC-Automata have been equipped with a logical and operational semantics, using Duration Calculus (DC) and Timed Automata (TA), respectively. The three main results of this paper are: (1) A simplified operational semantics. (2) A minor extension of the logical semantics, and a proof that this semantics is complete relative to our operational semantics. This means that if an observable satisfies all formulas of the DC semantics, then it can also be generated by the TA semantics. (3) A proof that the logical semantics is sound relative to our operational semantics. This means that each observable that is accepted by the TA semantics constitutes a model for all formulas of the DC semantics.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Ingebouwde systemen nog verre van feilloos\n", "abstract": " Ingebouwde systemen nog verre van feilloos (1996) | www.narcis.nl KNAW KNAW Narcis Back to search results Eindhoven University of Technology Publication Ingebouwde systemen nog verre van feilloos (1996) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Ingebouwde systemen nog verre van feilloos Published in De Automatisering Gids, 26(17). ISSN 0165-4683. Author Hammer, DK; Vaandrager, FW Publisher Algorithms, Geometry and Applications; Distributed Real-Time Systems - IPA Date issued 1996 Access Restricted Access Language English Type Article Publication https://research.tue.nl/nl/publications/8d635c93-59d2-4a31-9... OpenURL Search this publication in (your) library Persistent Identifier urn:nbn:nl:ui:25-8d635c93-59d2-4a31-9fe1-ef90efaa37dc Metadata XML Source Eindhoven University of Technology Go to Website \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Verification of a Distributed Summation\n", "abstract": " A correctness proof of a variant of Segall's Propagation of Infor-mation with Feedback protocol is outlined. The proof, which is carried out within the I/O automata model of Lynch and Tuttle, is standard except for the use of a prophecy variable. The aim of this paper is to show that, unlike what has been suggested in the literature, assertional methods based on invariant reasoning support an intuitive way to think about and understand this algorithm..", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Turning SOS Rules into Equations\n", "abstract": " Many process algebras are de\ufb01ned by structural operational semantics (SOS). Indeed, most such de\ufb01nitions are nicely structured and \ufb01t the GSOS format of Bloom et al.(J. Assoc. Compur. Mach., to appear). We give a procedure for convert-ing any GSOS ianguage de\ufb01nition to a finite complete equational axiom system (possibly with one in\ufb01nitary induction principle) which precisely characterizes strong bisimulation of processes.(Ct 1994 Academic Press, Inc.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Redundancy in a Context\n", "abstract": " We are interested in the verification of distributed systems by means of alge-braic manipulations. In process algebra, verifications often consist of a proof that the behaviour of an implementation IMPL equals the behaviour of a specification SPEC, after abstraction from internal activity: T/(IMPL)= SPEC. The simplest strategy to prove such a statement is to derive first the transi-tion system (process graph) for the process IMPL with the expansion theorem, apply an abstraction operator to this transition system, and then simplify the resulting system to the system for SPEC using the laws of (for instance) bisimulation semantics. This \u2018global strategy however, is often not very practical due to combinatorial state explosion: the number of states of IMPL can be of the same order as the product of the number of states of its components. Another serious problem with this strategy is that it provides almost no \u2018insight in the structure of the system being verified. It is impossible to use the approach for the design of distributed systems, ie the stepwise construc-tion of an implementation starting from a specification. This makes that there is a strong need for proof methods with a more modular/compositional charac-ter.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "An Algebra for Process Creation\n", "abstract": " Department of Software Technology, Centre for Mathematics and Computer Science, PO Box 4079, 1009 AB Amsterdam, The Netherlands. ln this paper, we study the issue of process creation from an algebraic perspective. The key to our approach, which is inspired by the work of AMERICA & DE BAKKER [AB], consists of giving a new interpretation to the operator symbol-(sequential composition) in the axiom system BPA of BERGSTRA 8. KLOP [BK1, 2, 3]. We present a number of other models for BPA and show how the new interpretation of-naturally generalises the usual interpretation in BPA or ACP. We give an operational semantics based on Plotkin style inductive rules, and give a complete finite axiomatisation of the associated bisimulation model.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Determinism $ ightarrow $(Event structure isomorphism= Step sequence equivalence)\n", "abstract": " Determinism $ ightarrow $ (Event structure isomorphism = Step sequence equivalence) (1988) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication Determinism $ ightarrow $ (Event structure isomorphism = Step sequence equivalence) (1988) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Determinism $ ightarrow $ (Event structure isomorphism = Step sequence equivalence) Series Department of Computer Science [CS] Author FW Vaandrager (Frits) Date issued 1988-01-01 Access Closed Access Language English Type Other Publisher CWI Publication https://ir.cwi.nl/pub/5934 Persistent Identifier urn:NBN:nl:ui:18-5934 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Verification of two communication protocols by means of process algebra(M. S. Thesis- Leiden Univ.)\n", "abstract": " A Positive Acknowledgement with Retransmission protocol, and a One Bit Sliding Window protocol are verified in the framework of the algebra of communicating processes with silent steps, augmented with additional axioms. The Cluster Fair Abstraction Rule (CFAR) a generalization of Koomen's Fair Abstraction Rule (KFAR) is presented and it is shown that CFAR can be derived from KFAR. The notion of redundancy in a context, which makes it possible to use trace theoretic arguments in process algebra calculations is introduced. For the verification of the second protocol, the technique of local replacement is used. In this technique, a concurrent system is simplified by repeated replacement of components, replacements which leave the behavior of the system invariant. (ESA)", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Neta Bar Kama and Roope Kaivola Scaling Up Hardware Accelerator Verification using A-QED with Functional Decomposition....... 42 Saranyu Chattopadhyay, Florian Lonsing, Luca\u00a0\u2026\n", "abstract": " Table of Contents Page 1 Table of Contents Tutorials Reactive Synthesis Beyond Realizability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Rayna Dimitrova Stainless Verification System Tutorial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Viktor Kuncak and Jad Hamza Formal Methods for the Security Analysis of Smart Contracts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Matteo Maffei Active Automata Learning: from L* to L# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Frits Vaandrager Invited Talks From Viewstamped Replication to Blockchains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Barbara Liskov Algorithms for the People . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 Seny Kamara Engineering with Full-scale Formal Architecture: Morello, CHERI, Armv8-A, and RISC-V . . . . . . . . 12 Peter Sewell Student \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "programador clic\n", "abstract": " El objetivo del aprendizaje de modelos es construir un modelo de diagrama de estado de caja negra de sistemas de software y hardware proporcionando entradas y observando salidas. Una pregunta de investigaci\u00f3n b\u00e1sica para dise\u00f1adores de algoritmos de aprendizaje modelo.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Report CS-R931'4 March 1 993\n", "abstract": " A general automaton model for timing-based systems is presented and is used as the context for developing a variety of simulation proof techniques for such systems. These techniques include (1) refinements,(2) forward and backward simulations,(3) forward-backward and backwardforward simulations, and (4) history and prophecy relations. Soundness and completeness results are given for these simulations. These results are largely analogous to the results in Part I of this paper for untimed systems. In fact, many of the results for the timed case are obtained as consequences of the analogous results for the untimed case.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Centrum voor Wiskunde en lnformatica Centre for Mathematics and Computer Science\n", "abstract": " In recent years a large number of (concurrent) languages have been provided with an operational semantics using Plotkin's structural approach (SOS). In this paper the question is considered in which cases a transition system specification in Plotkin style has' good'properties and deserves the predicate'structured'. The discussion takes place in a setting of labelled transition systems. The states of the transition systems are terms generated by a single sorted signature and the transitions between states are defined by structural induction on abstract syntax. It is argued that in this setting it is natural to require that strong bisimulation equivalence is a congruence on the states of the transition systems. A general format, called the tyftltyxt format, is presented for the inductive rules in a transition system specification, such that bisimulation is always a congruence when all the rules fit into this format. With a series of examples it is demonstrated that the tyft/tyxt format cannot be generalized in any obvious way. Another series of examples illustrates the usefulness of our congruence theorem. Briefly we touch upon the issue of modularity of transition system specifications. It is argued that certain pathological tyftl tyxt rules (the ones which are not pure) can be disqualified because they behave badly with respect to modularisation. Next we address the issue of full abstraction. We characterize the completed trace congruence induced by the operators in pure tyftltyxt format as 2-nested simulation equivalence. The pure tyft! tyxt format includes the format given by DE SIMONE [29, 30] but is incomparable to the GSOS format of BLOOM, ISTRAIL & MEYER [1 O\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Computer Science/Department of Software Technology\n", "abstract": " This paper presents an efficient algorithm for the Relational Coarsest Partition with Stuttering problem (RCPS). The RCPS problem is closely related to the problem of deciding stuttering equivalence on finite state Kripke structures (see BROWNE, CLARKE & GRUMBERG [3)), and to the problem of deciding branching bisimulation equivalence on finite state labelled transition systems (see VAN GLABBEEK & WEIJLAND [12]). If n is the number of states and m the number of transitions, then our algorithm has time complexity O (n\u00b7(n+ m)) and space complexity O (n+ m). The algorithm induces algorithms for branching bisimulation and stuttering equivalence which have the same complexity. Since for Kripke structures m.;;;, n2, this confirms a conjecture of BROWNE, CLARKE & GRUMBERG [3], that their O (n5)-time algorithm for stuttering equivalence is not optimal.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Centrum voor Wiskunde en lnformatica\n", "abstract": " One of the main applications of event structures is that they can be used to give semantics to CCS-li. ke languages. As it turns out prime event structures with binary conflict (also called conflict event structures (CES's) by DEGANO, DE NICOLA & MONTANARI [2]), are appropriate for this purpose in principle. All CCS-like operations are easily definable on CES's except for parallel composition. If someone wants to compute the parallel composition of two CES's in the way proposed by WINSKEL,(s) he has to determine the families of configurations associated to these event structures, next turn the configurations into stable event structures, next compute the parallel composition of these stable event structures, then translate the result back to a\u00b7 family of configurations, and as a last step turn the configurations into a prime event structure again. A number of authors have looked for more direct definitions of parallel composition. LoooEN & GoLTZ [3] present a very complicated definition in the setting of TCSP. In [2], DEGANO, DE NICOLA & MONTANARI actually work out the inductive definition which WINSKEL did not give to'avoid a messy inductive nammg of events'([5], p. 564). Presumably the definition in [2] is less messy than", "num_citations": "0\n", "authors": ["1601"]}
{"title": "EPTCS 13\n", "abstract": " EPTCS 13: Quantitative Formal Methods: Theory and Applications Page 1 Proceedings First Workshop on Quantitative Formal Methods : theory and applications (QFM'09, Eindhoven, The Netherlands, November 3, 2009) Citation for published version (APA): Andova, S., McIver, A., D'Argenio, PR, Cuijpers, PJL, Markovski, J., Morgan, C., & N\u00fa\u00f1ez, M. (Eds.) (2009). Proceedings First Workshop on Quantitative Formal Methods : theory and applications (QFM'09, Eindhoven, The Netherlands, November 3, 2009). (Electronic Proceedings in Theoretical Computer Science; Vol. 13). sn. https://doi.org/10.4204/EPTCS.13 DOI: 10.4204/EPTCS.13 Document status and date: Published: 01/01/2009 Document Version: Publisher\u2019s PDF, also known as Version of Record (includes final page, issue and volume numbers) Please check the document version of this publication: \u2022 A submitted manuscript is the version of the article upon \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Finding Security Vulnerabilities in Protocol Implementations Using Active Automata Learning\n", "abstract": " Register automata may be parametrized by a (relational) structure: a pair\u2329 D, R\u232a where D is an unbounded domain of data values, and R is a collection of relations on D. Examples of simple structures include:\u2329 N,{=}\u232a, the natural numbers with equality;\u2329 R,{<}\u232a, the real numbers with inequality: this structure also allows one to express equality between elements. Transition guards are conjunctions of negated and unnegated relations from R.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Operational and Logical Semantics for Polling Real-Time Systems?\n", "abstract": " PLC-Automata are a class of real-time automata suitable to describe the behaviour of polling real-time systems. PLC-Automata can be compiled to source code for PLCs, a hardware widely used in industry to control processes. Also, PLC-Automata have been equipped with a logical and operational semantics, using Duration Calculus (DC) and Timed Automata (TA), respectively. The three main results of this paper are:(1) A simpli ed operational semantics.(2) A minor extension of the logical semantics, and a proof that this semantics is complete relative to our operational semantics. This means that if an observable satis es all formulas of the DC semantics, then it can also be generated by the TA semantics.(3) A proof that the logical semantics is sound relative to our operational semantics. This means that each observable that is accepted by the TA semantics constitutes a model for all formulas of the DC semantics.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Model Learning and Model Checking of SSH Implementations\n", "abstract": " Introduction\u2022 protocols: SSH, TLS, SMTP, FTP, TCP, UDP\u2026\u2022 many implementations per protocol\u27a2 implementations MUST/SHOULD/MAY adhere to the specifications\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "NIII-R0312 May 2003\n", "abstract": " Using the Berkeley SMV symbolic model checker we synthesize, under certain error assumptions, a controller for the smart card personalization system, a case study that has been proposed by Cybernetix Recherche in the context of the EU IST project AMETIST. The controller that we synthesize, and of which we prove optimality, has been previously patented. Due to the large number of states (which is beyond 1011), this control synthesis problem appears to be out of the scope of existing tools for controller synthesis, which typically use some form of explicit state enumeration. Our result provides new evidence that model checkers can be useful to tackle industrial sized problems in the area of scheduling and control synthesis.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R9904 March 1999\n", "abstract": " This report presents a formal verification of root contention in IEEE 1394. Root contention is a simple yet realistic protocol that solves leader election for two processes, using coin flips.The verification has been carried out in the probabilistic automaton model of [Seg95]. Correctness of an implementation automaton wrt a specification automaton is defined as so-called fair trace distribution inclusion. Similarly to the non-probabilistic setting, probabilistic simulation relations provide a technique for proving trace distribution inclusion. Then additional reasoning proves fair trace distribution inclusion. Our verification follows this strategy. We introduce two simulation relations, viz. probabilistic step refinements and probabilistic hyperstep refinements. These notions are not very complicated and are sufficient in our verification. They are special cases of the simulation relations from [Seg95]. The verification also involves non-probabilistic techniques. For instance, the invariants have been checked with the model checker SMV.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Enformatica'\n", "abstract": " A first attempt to deal more directly with process creation in an algebraic setting is described in BERGSTRA [B], where the axiomatic system ACP is extended with a mechanism for process creation. The key axiom here isE\u00a2(cr (d)-x)= c_r (d)-E\u00a2(\u00a2(d) II x). The operator Eq, denotes an environment in which process creation can take place. If an action cr (d) is performed in this environment, a process (])(d) is created and placed in parallel with the remaining process.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "2 Session 1A: Automata Theory and Logics 28 2.1 Reasoning about co\u2013B\u00fcchi Tree Automata Salvatore La Torre and Aniello Murano....................... 29 2.2 Switched\u00a0\u2026\n", "abstract": " 1 1 Invited Talks 2 1.1 Software Services: Scientific Challenge or Industrial Hype? Jos\u00e9 Luiz Fiadeiro . . . . . . . . . . . . Page 1 1 1 Invited Talks 2 1.1 Software Services: Scientific Challenge or Industrial Hype? Jos\u00e9 Luiz Fiadeiro . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.2 Integrating Variants of DC He Jifeng . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.3 A Predicate Spatial Logic and Model Checking for Mobile Processes Huimin Lin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 1.4 Challenges in increasing tool support for programming K. Rustan M. Leino . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 2 Session 1A: Automata Theory and Logics 28 2.1 Reasoning about co\u2013B\u00fcchi Tree Automata Salvatore La Torre and Aniello Murano . . . . . . . . . . . . . . . . . . . . . . . 29 2.2 Switched Probabilistic I/O Automata Ling Cheung, Nancy Lynch, Roberto Segala and Frits Vaandrager . . . . . . . . . 44 2.3 Foundations for the Run-time \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Perceptual Interfaces\n", "abstract": " The Raw Processor: A Composeable 32-Bit Fabric for Embedded and General Purpose Computing................................. 3", "num_citations": "0\n", "authors": ["1601"]}
{"title": "\u2018$3! i _, Universify of Amsterdam\n", "abstract": " 1. INTRODUCTION. ACP, the Algebra of Communicating Processes of BERGS'IRA & KLOP [BKL BK2, BKS], is an algebraic framework designed both for the speci\ufb01cation and for the veri\ufb01cation of concurrent systems. The ACP framework is closely related to MILNER's CCS [MI] and HOARE\u2019s CSP [H]. In his seminal work [MI],\u00bb Milner already mentioned hardware description as a possible application area of his calculus-Yet most applications of theories like CCS, CSP and ACP are in \ufb01elds as protocol veri\ufb01cation, semantics of programming languages and distributed algorithms. Only a group around REM [R] has been working actively onVLSI circuits in the setting of trace theory, which is inspired by an early variant of CSP. The subject of this paper is the speci\ufb01cation and veri\ufb01cation of a simple circuit in the ACP framework. The description of the circuit we consider here is derived from KALDEWAH [K]. In-the example\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Slogan, almost [Vardi]\n", "abstract": " Generic Forward and Backward Simulations Page 1 Generic Forward and Backward Simulations Ichiro Hasuo Radboud Universiteit Nijmegen The Netherlands Page 2 Slogan, almost [Vardi] Everything you can do I can do \u201cbetter\u201d with coalgebras \u2022 More genericity \u2022 More abstraction \u2022 More fun (for me) \u25cf This work aims at a generic, coalgebraic version of N. Lynch & F. Vaandrager. Forward and Backward Simulations I. Untimed Systems. Information and Computation, 1995 Page 3 Contents 1. Theory of traces and simulations, conventionally 2. Generic theory \u25cf Forward simulation as \u25cf Uniformly for non-determinism and probability \u25cf Main result: general soundness theorem 3. Illustration of generic theory 4. New application field of coalgebras Page 4 Page 5 \u25cf Let\u2019s focus on labelled transition systems (LTS) \u25cf Trace = \u25cf Traces, conventionally set of possible linear-time behavior better captured by our coalgebraic \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Specification and Verification of\n", "abstract": " 1.\u2018INTRODUCTION. ACP, the Algebra of Communicating Processes of BERGSTRA & KLOP [BK], is an algebraic framework designed both for the speci\ufb01cation and for the veri\ufb01cation of concurrent systems. The ACP framework is closely related to MILNER's CCS [MI] and HOARE's CSP [H]. In his seminal work [MI], Milner already mentioned hardware description as a possible application area of his calculus. Yet most applications of theories like CCS, CSP and ACP are in \ufb01elds as protocol veri\ufb01cation, semantics of programming languages and distributed algorithms. Only a group around REM [R] has been working actively on VLSI circuits in the setting of trace theory, which is inspired by an early variant of CSP. The subject of this paper is the speci\ufb01cation and verification of a simple circuit in the ACP framework. The description of the circuit we consider here is derived from KALDEWAU [K]. In the example we will\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "The Axiomatization of Overriding and Update 6 Online Appendix: Human-Readable Proofs\n", "abstract": " This document contains human-readable proofs for the derived laws in Figure 3 of the article published under the same title in the Journal of Applied Logic. The proofs are mostly based on the ones provided by I\uf773\uf761\uf762\uf765\uf76c\uf76c\uf765.In the following, we provide equational proofs for all laws in Figure 3. Lemmas are tagged with the number of the law and with a letter to indicate the order of proofs: in each proof, only laws with an earlier letter may be used. If a rule is only applied to a part of the formula, the part that is going to be replaced is red and underlined, and the part that has just been replaced is blue and overlined. The proofs are mostly based on the ones provided by I\uf773\uf761\uf762\uf765\uf76c\uf76c\uf765; they differ mainly if the automatic proof for one law contains (most of) the proof for another. We assume left-associativity and the usual priorities:@ binds strongest and\u22b2 binds weakest. The axioms are:", "num_citations": "0\n", "authors": ["1601"]}
{"title": "The Axiomatization of Overriding and Update 6\n", "abstract": " There are only very few natural ways in which arbitrary functions can be combined. One composition operator is override: for arbitrary functions f and g, f> g is the function with domain dom (f)\u222a dom (g) that behaves like f on dom (f) and like g on dom (g)\\dom (f). Another operator is update: f [g] has the same domain as f, behaves like f on dom (f)\\dom (g), and like g on dom (f)\u2229 dom (g). These operators are widely used, especially within computer science, where for instance f [g] may denote the new state that results when in state f the updates given as g are applied. It is therefore surprising that thus far no axiomatization of these operators has been proposed in the literature. As an auxiliary operator we consider the minus operator: f\u2212 g is the restriction of f to the domain dom (f)\\dom (g). The update operator can be defined in terms of override and minus. We present five equations that together constitute a sound and complete axiomatization of override and minus. As part of our completeness proof, we infer a large number of useful derived laws using the proof assistant I\uf773\uf761\uf762\uf765\uf76c\uf76c\uf765. With the help of the SMT solver Y\uf769\uf763\uf765\uf773, we establish independence of the axioms. Thus, our axiomatization is also minimal. Finally, we establish that override and minus are functionally complete in the sense that any operation on general functions that corresponds to a valid coloring of a Venn diagram can be described using just these two operations.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "1a Project Title\n", "abstract": " This is an updated and completely rewritten version of a proposal that was previously submitted to the NWO VC in the rounds 2010-2 (600.065. 120.10 N221) and 2011-1 (600.065. 120.11 N135). Although both earlier versions were judged to be excellent (++), they were not funded. In fact, the proposal from round 2011-1 was the highest ranked computer science proposal that did not receive funding. This new version takes into account recent research developments, and positions the proposal relative to the STW ITALIA project, which meanwhile has been granted. The focus of the project is now entirely on active learning of reactive systems that apply simple or known operations on data, and on the application of our algorithms to security protocols.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "UPPAAL-TIGA\n", "abstract": " Results\u220e[Maler & al.\u201995, De Alfaro & al.\u201901] There is a symbolic iterative algorithm to compute the set W* of winning states for timed games", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Uitwerking Take-home Tentamen Protocolveri catie 27 Maart 1994\n", "abstract": " Het algoritme dat in dit tentamen aan de orde komt wordt door Lamport beschreven in 2]. Lamport claimt in dit artikel dat zijn algoritme de opmerkelijke eigenschap heeft dat wanneer een lees-en een schrijfopdracht voor een gedeelde geheugencel tegelijkertijd plaatsvinden, alleen de schrijfopdracht correct hoeft te worden uitgevoerd. De leesopdracht mag een willekeurige waarde opleveren. Naar deze eigenschap van het algoritme wordt in dit tentamen verder niet gekeken: zoals reeds gesteld in de opgaven nemen we aan dat de gedeelde registers atomair zijn.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R9728 December 1997\n", "abstract": " The IEEE 1394 high performance serial multimedia bus protocol allows several components to communicate with each other at high speed. In this paper we present a formal model and veri cation of a leader election algorithm that forms the core of the tree identify phase of the physical layer of the 1394 protocol. We describe the algorithm formally in the I/O automata model of Lynch and Tuttle, and verify that for an arbitrary tree topology exactly one leader is elected. A large part of our veri cation has been checked mechanically with PVS, a veri cation system for higher-order logic.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Timed, Hybrid, and Probabilistic I/O Automata\n", "abstract": " Currently, it is not even clear what mathematical underpinnings one should use to carry out this kind of modeling/analysis work. My graduate course in Spring, 2001, on \u201cModeling and Analyzing Really Complex Systems, Using State Machines\u201d, showed the need for a comprehensive, usable mathematical framework for carrying out such work.Approach: Lynch, Segala, and Vaandrager have already developed a mathematical framework for modeling and analyzing hybrid (continuous/discrete) systems (see report). This is based on Hybrid I/O Automata (HIOAs), nondeterministic state machines whose states can change as a result of both discrete transitions and continuous trajectories. The HIOA framework supports composition and abstraction.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "NIII-R0308 March 2003\n", "abstract": " We illustrate the application of the hybrid I/O automata framework of Lynch, Segala & Vaandrager by using it to model and analyze the behavior of a simple Lego car with caterpillar treads. We derive constraints on the values of the parameters that occur in our hybrid model that guarantee that the car will always move forward along a black tape, and will never get off the tape or move backward. In order to simplify the correctness proof, we introduce a transition systems that abstracts from the hybrid automaton in a rather drastic manner, but still preserves validity of the correctness properties in which we are interested. Even though our original model does not involve any disturbances, the general parametric analysis of the system allows us to exend our results in a trivial manner to a hybrid model in which several disturbances are allowed (mistakes in measurements of lengths, drift and jitter of the hardware clock, velocity, and distance between the two caterpillar treads).", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Analyzing Zeroconf with Timed Automata\n", "abstract": " Our society increasingly depends on correct functioning of (implementations of) communication protocols. Standards that define these protocol are written in informal language, with frequent ambiguities, omissions and inconsistencies. We can blame the engineers (for not using formal methods), the companies (for playing political games), but also ourselves, ie, the formal methods researchers.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Linear Parametric Model Checking of Timed Automata Thomas S. Hune Judi Romijn Mari\u00eblle Stoelinga\n", "abstract": " We present an extension of the model checker UPPAAL capable of synthesize linear parameter constraints for the correctness of parametric timed automata. The symbolic representation of the (parametric) state-space is shown to be correct. A second contribution of this paper is the identification of a subclass of parametric timed automata (L/U automata), for which the emptiness problem is decidable, contrary to the full class where it is know to be undecidable. Also we present a number of lemmas enabling the verification effort to be reduced for L/U automata in some cases. We illustrate our approach by deriving linear parameter constraints for a number of well-known case studies from the literature (exhibiting a flaw in a published paper)", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R0102 January 2001\n", "abstract": " \u041d \u042a\u0421 \u042b \u0418 \u042d\u0432 \u043a \u0436\u0437 \u0438\u043d \u0433 \u0436 \u0439\u0437\u0418 \u0432\u0431 \u0436 \u0436 \u0437 \u0436 \u0437\u041a \u041e \u0433\u0431\u0434\u0439\u0438 \u0432 \u042b \u0432 \u0421\u0432\u0437\u0438 \u0438\u0439\u0438 \u0418 \u042d\u0432 \u043a \u0436\u0437 \u0438\u043d \u0433 \u0426 \u0431 \u0432\u0418 \u042c \u0426 \u0438 \u0436\u0430 \u0432 \u0437 \u0439 \u0418\u0431 \u0436 \u0430\u0430 \u0418 \u043a \u0432\u2104 \u0437\u041a \u0439\u0432\u041a\u0432\u0430 \u0437\u0438\u0436 \u0438\u041a \u042f \u0434\u0436 \u0437 \u0432\u0438 \u0432 \u043c\u0438 \u0432\u0437 \u0433\u0432 \u0433 \u0438 \u0431\u0433 \u0430 \u0436 \u042d\u0434\u0434 \u0430\u0418 \u0434 \u0430 \u0433 \u0437\u043d\u0432\u0438 \u0437 \u043e \u0432 \u0430 \u0432 \u0436 \u0434 \u0436 \u0431 \u0438 \u0436 \u0433\u0432\u0437\u0438\u0436 \u0432\u0438\u0437 \u0433\u0436 \u0438 \u0433\u0436\u0436 \u0438\u0432 \u0437\u0437 \u0433 \u0434 \u0436 \u0431 \u0438\u0436 \u0438 \u0431 \u0439\u0438\u0433\u0431 \u0438 \u041a \u042c \u0437\u043d\u0431 \u0433\u0430 \u0436 \u0434\u0436 \u0437 \u0432\u0438 \u0438 \u0433\u0432 \u0433 \u0438 \u0414\u0434 \u0436 \u0431 \u0438\u0436 \u0415 \u0437\u0438 \u0438 \u0419\u0437\u0434 \u0437 \u0437 \u0433\u043b\u0432 \u0438\u0433 \u0433\u0436\u0436 \u0438\u041a \u0437 \u0433\u0432 \u0433\u0432\u0438\u0436 \u0439\u0438 \u0433\u0432 \u0433 \u0438 \u0437 \u0434 \u0434 \u0436 \u0437 \u0438 \u0432\u0438 \u040c \u0438 \u0433\u0432 \u0433 \u0437\u0439 \u0430 \u0437\u0437 \u0433 \u0434 \u0436 \u0431 \u0438\u0436 \u0438 \u0431 \u0439\u0438\u0433\u0431 \u0438 \u0414\u0424\u041b\u042d \u0439\u0438\u0433\u0431 \u0438 \u0415\u0418 \u0433\u0436 \u043b \u0438 \u0431\u0434\u0438 \u0432 \u0437\u0437 \u0434\u0436\u0433 \u0430 \u0431 \u0437 \u0430 \u0418 \u0433\u0432\u0438\u0436 \u0436\u043d \u0438\u0433 \u0438 \u0439\u0430\u0430 \u0430 \u0437\u0437 \u043b \u0436 \u0438 \u0437 \u0432\u0433\u043b \u0438\u0433 \u0439\u0432 \u0430 \u041a \u0430\u0437\u0433\u0418 \u043b \u0434\u0436 \u0437 \u0432\u0438 \u0432\u0439\u0431 \u0436 \u0433 \u0430 \u0431\u0431 \u0437 \u0432 \u0430 \u0432 \u0438 \u043a \u0436 \u040c \u0438 \u0433\u0432 \u040b\u0433\u0436\u0438 \u0438\u0433 \u0436 \u0439 \u0433\u0436 \u0424\u041b\u042d \u0439\u0438\u0433\u0431 \u0438 \u0432 \u0437\u0433\u0431 \u0437 \u0437\u041a \u042f \u0430\u0430\u0439\u0437\u0438\u0436 \u0438 \u0433\u0439\u0436 \u0434\u0434\u0436\u0433 \u043d \u0436 \u043a \u0432 \u0430 \u0432 \u0436 \u0434 \u0436 \u0431 \u0438 \u0436 \u0433\u0432\u0437\u0438\u0436 \u0432\u0438\u0437 \u0433\u0436 \u0432\u0439\u0431 \u0436 \u0433 \u043b \u0430\u0430\u0419 \u0432\u0433\u043b\u0432 \u0437 \u0437\u0438\u0439 \u0437 \u0436\u0433\u0431 \u0438 \u0430 \u0438 \u0436 \u0438\u0439\u0436 \u0414 \u043c \u0438 \u0432 \u043b \u0432 \u0434\u0439 \u0430 \u0437 \u0434 \u0434 \u0436\u0415\u041a", "num_citations": "0\n", "authors": ["1601"]}
{"title": "NIII-R0201 February 2002\n", "abstract": " \u0421\u0432 \u0434 \u0436\u0438 \u0439\u0430 \u0436\u0418 \u0438 \u0436 \u0431 \u043b\u0433\u0436 \u0432 \u0430\u0439 \u0437 \u0432\u0433\u0438 \u0433\u0432 \u0433 \u043c\u0438 \u0436\u0432 \u0430 \u043a \u0433\u0436 \u0433\u0436 \u043d \u0436 \u0421\u041b\u0427 \u0439\u0419 \u0438\u0433\u0431 \u0438\u0433\u0432\u0418 \u043b \u0434\u0438\u0439\u0436 \u0437 \u0438\u0437 \u0437 \u0436 \u0438 \u0432 \u0433\u0432\u0438 \u0432\u0439\u0433\u0439\u0437 \u0432\u0438 \u0436 \u0438 \u0433\u0432\u0437 \u043b \u0438 \u0438\u0437 \u0432\u043a \u0436\u0433\u0432\u0431 \u0432\u0438\u041a \u042c \u0436 \u0431 \u043b\u0433\u0436 \u0430\u0437\u0433 \u040c\u0432 \u0437 \u043b \u0438 \u0438 \u0431 \u0432\u0437 \u0433\u0436 \u0433\u0432 \u0420\u0421\u0427 \u0438\u0433 \u0431\u0434\u0430 \u0431 \u0432\u0438 \u0432\u0433\u0438 \u0436\u0418 \u0437 \u0433\u0432 \u0432 \u0432 \u0430\u0439\u0437 \u0433\u0432 \u0436 \u0430 \u0438 \u0433\u0432\u0437 \u0434 \u0438\u043b \u0432 \u0438 \u0436 \u043c\u0438 \u0436\u0432 \u0430 \u043a \u0433\u0436 \u0437 \u0438\u0437\u0418 \u0432 \u040c\u0432 \u0437 \u0432\u0433\u0438 \u0433\u0432 \u0433 \u0437 \u0431\u0439\u0430 \u0419 \u0438 \u0433\u0432\u0418 \u043b \u0434\u0436\u0433\u043a \u0437 \u0437\u0439\u0426 \u0432\u0438 \u0433\u0432 \u0438 \u0433\u0432 \u0433\u0436 \u0431\u0433\u0432\u0437\u0438\u0436 \u0438 \u0432 \u0431\u0434\u0430 \u0431 \u0432\u0438 \u0438 \u0433\u0432 \u0436 \u0430 \u0438 \u0433\u0432\u0437 \u0434\u0437\u041a \u042c \u0436 \u0431 \u043b\u0433\u0436 \u0430\u0437\u0433 \u0432 \u0430\u0439 \u0437 \u0433\u0431\u0434\u0433\u0437 \u0438 \u0433\u0432 \u0433\u0434 \u0436 \u0438 \u0433\u0432 \u0433\u0436 \u0420\u0421\u0427 \u0437\u0418 \u043b \u0436 \u0437\u0434 \u0438\u0437 \u043c\u0438 \u0436\u0419 \u0432 \u0430 \u043a \u0433\u0436\u0418 \u0432 \u0432\u0433\u0438 \u0433\u0432 \u0433 \u0436 \u0434\u0438 \u043a \u0432 \u0437\u0437\u0418 \u043b \u0431\u0434\u0430 \u0437 \u0438 \u0438 \u0432 \u0420\u0421\u0427 \u0433 \u0437 \u0432\u0433\u0438 \u0430\u0433 \u0438 \u0434 \u0437\u0437 \u0433 \u0438 \u0431 \u041a \u042c \u0436 \u0431 \u043b\u0433\u0436 \u0437 \u0432\u0438 \u0432 \u0438\u0433 \u0437\u0439\u0434\u0434\u0433\u0436\u0438 \u0432 \u0430\u043d\u0437 \u0437 \u0431 \u0438 \u0433 \u0437 \u0436\u0433\u0431 \u0433\u0438 \u0433\u0431\u0434\u0439\u0438 \u0436 \u0437 \u0432 \u0432 \u0433\u0432\u0438\u0436\u0433\u0430 \u0438 \u0433\u0436\u043d\u041a\u042c \u0437 \u043b\u0433\u0436 \u0437 \u0437 \u0431\u0434\u0430 \u040c \u0438 \u0433\u0432 \u0433 \u0432 \u0436\u0430 \u0436 \u043a \u0436\u0437 \u0433\u0432 \u0433 \u0438 \u0420\u0421\u0427 \u0431\u0433 \u0430 \u041c\u0418 \u041d\u2104 \u041a \u042c \u0431 \u0432 \u0437 \u0431\u0434\u0430 \u040c \u0438 \u0433\u0432 \u0432 \u0438 \u0432 \u043b \u0431\u0433 \u0430 \u0437 \u0430 \u0436 \u0436 \u0437 \u0434 \u0436 \u0438 \u0433\u0432 \u0438\u043b \u0432 \u0438 \u0431 \u0432 \u0437\u0431\u0437 \u0439\u0437 \u0438\u0433 \u0431\u0433 \u0430 \u0437 \u0436 \u0438 \u0432 \u0433\u0432\u0438 \u0432\u0439\u0433\u0439\u0437 \u0432\u0438 \u0436 \u0438 \u0433\u0432 \u0438\u043b \u0432 \u0433\u0431\u0434\u0433\u0432 \u0432\u0438\u0437\u041a \u0421\u0432 \u0434 \u0436\u0438 \u0439\u0430 \u0436\u0418 \u0438 \u0432 \u043b \u0431\u0433 \u0430 \u0436 \u0431\u0433\u043a \u0437 \u0438 \u0439 \u0430 \u0439\u0437 \u0433 \u043c\u0438 \u0436\u0432 \u0430 \u043a \u0436 \u0430 \u0437 \u0433\u0436 \u0437 \u0436 \u0438 \u0432 \u0433\u0432\u0438 \u0432\u0439\u0433\u0439\u0437 \u0432\u0438 \u0436 \u0438 \u0433\u0432\u041a \u0423 \u043d\u043b\u0433\u0436 \u0437 \u0412 \u0434 \u0436 \u0437 \u0437 \u0420\u043d \u0436 \u0437\u043d\u0437\u0438 \u0431\u0418 \u0421\u041b\u0427 \u0439\u0438\u0433\u0431 \u0438\u0433\u0432\u0418 \u043d \u0436 \u0439\u0438\u0433\u0431 \u0438\u0433\u0432\u0418 \u043d \u0436 \u0421\u041b\u0427", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CS-R9505 1995\n", "abstract": " A correctness proof of a variant of Segall's Propagation of Information with Feedback protocol is presented.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Luca Aceto COGS, University of Sussex, Brighton, United Kingdom\n", "abstract": " Many process algebras are de ned by structural operational semantics (SOS). Indeed, most such de nitions are nicely structured and t the GSOS format of 19]. We give a procedure for converting any GSOS language de nition to a nite complete equational axiom system (possibly with one in nitary induction principle) which precisely characterizes strong bisimulation of processes.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Three Logics for Branching Bisirauiation\n", "abstract": " Three temporal logics are introduced which induce on labelled transition systems the same identifications as branching bisimulation. The first is an extension of Hennessy-Milner Logic with a kind of\" until\" operator. The second is another extension of Hennessy-Milner Logic which exploits the power of backward modalities. The third is CTL without the next-time operator interpreted over all paths, not just over maximal ones. A relevant side-effect of the last characterization is that it sets a bridge between the state-and event-based approaches to the semantics of concurrent systems.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Testing Timed Automata\n", "abstract": " We present a generalization of the classical theory of testing for Mealy machines to a setting of dense real-time systems. A model of timed I/O automata is introduced, inspired by the timed automaton model of Alur and Dill, together with a notion of test sequence for this model. Our main contribution is a test generation algorithm for black-box conformance testing of timed I/O automata. Although it is highly exponential and cannot be claimed to be of practical value, it is the rst algorithm that yields a nite and complete set of tests for dense real-time systems.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Constructing Formal Models through Automata Learning\n", "abstract": " Model-based system development is becoming an increasingly important driving force in the software and hardware industry. The construction of models typically requires specialized expertise, is time consuming and involves significant manual effort, implying that in practice often models are not available, or become outdated as the system evolves. In practice, 80% of software development involves legacy code, for which only poor documentation is available. Manual construction of models of legacy components is typically very labor intensive and often not cost effective. The solution is to infer models automatically through observations and test, that is, through black-box reverse engineering.The problem to build a state machine model of a system by providing inputs to it and observing the resulting outputs, often referred to as black-box system identification, is both fundamental and of clear practical interest. A major challenge is to let computers perform this task in a rigorous manner for systems with large numbers of states.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Timed, Hybrid, and Probabilistic I/O Automata (AKA: The Grand Theory of Everything)\n", "abstract": " Currently, it is not even clear what mathematical underpinnings one should use to carry out this kind of modeling/analysis work. My graduate course in Spring, 2001, on \u201cModeling and Analyzing Really Complex Systems, Using State Machines\u201d, showed the need for a comprehensive, usable mathematical framework for carrying out such work.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Waarom Informatica?!\n", "abstract": " Mensen vinden het leuk om dingen te maken: een kok is blij met een nieuw recept, een bouwvakker met een muur die hij heeft gemetseld, en kinderen bouwen zandkastelen. Een informaticus maakt computersystemen en vindt dat leuk. Software heeft geen last van wrijving, slijtage of andere onaangenaamheden uit de fysieke wereld. Computerprogramma\u2019s beschrijven perfecte apparaten die werken in een perfecte, virtuele wereld, en die je precies zo in elkaar kunt zetten als je wilt.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Centre for Mathematics and Computer Science\n", "abstract": " In recent years a large number ol (concurrent) languages have been provided with an operational semantics using Plotkin's structural approach (SOS). In this paper the question is considered in which cases a transition system specification in Plotkin style has' good'properties and deserves the predicate'structured'. The discussion takes place in a setting of labelled transition systems. The states of the transition systems are terms generated by a single sorted signature and the transitions between states are defined by structural induction on abstract syntax. It is argued that in this setting it is natural to require that strong bisimulation equivalence is a congruence on the states of the transition systems. A general format, called the tyft/tyxt format, is presented for the inductive rules in a transition system specification, such that bisimulation is always a congruence when all the rules fit into this format. With a series of examples\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "NIII-R0437 September 2004\n", "abstract": " A switched probabilistic I/O automaton is a special kind of probabilistic I/O automaton (PIOA), enriched with an explicit mechanism to exchange control with its environment. Every closed system of switched automata satisfies the key property that, in any reachable state, at most one component automaton is active. We define a tracebased semantics for switched PIOAs and prove it is compositional. We also propose switch extensions of an arbitrary PIOA and use these extensions to define a new trace-based semantics for PIOAs.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Design Space Exploration of Printer Datapaths using Timed Automata\n", "abstract": " Design space exploration is a common approach to improve the performance of distributed embedded systems. Some characteristics like hardware capacity can easily be explored by changing some parameters in the model and re-running the experiments. However, searching for improvements of scheduling rules is not that straightforward. It is difficult to find generic and simple scheduling rules which ensure a high performance of the system for all its possible applications. Usually, one rule is more favorable for one category of applications but disadvantaging others. We describe an approach to explore the design space of a soft realtime embedded system using timed automata model checking. The system studied consists of the system architecture of an Oc\u00e9 printer and the concurrent programmed paths which data can take on it. We consider the system in an overloaded state (memory full, many files in the system) and search for improvements of the existing scheduling rules. We also indicate the pros and cons of this analysis technique for our case study.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Nieuwe Citatie-Index Voorkomt Dubbel Werk\n", "abstract": " In: Automatisering Gids 34(8):19, February 25, 2000. Nieuwe Citatie-Index Voorkomt Dubbel Werk Het informatica-onderzoek heeft er een nieuw hulpmiddel bij: de citatie-index van het Nec Research Institute. Informatici kunnen hier volgens prof. dr. Frits Vaandrager hun voordeel mee doen. De Nec-index is actueler en vollediger dan de traditionele science citation index. Men komt er snel achter waar onderzoekers mee bezig zijn. De nieuwe index laat ook zien hoe goed het Nederlandse onderzoek is ten opzichte van de rest van de wereld. Frits Vaandrager Sinds kort is er voor informatica-onderzoekers een zeer relevante citatie-index die wordt bijgehouden door het Nec Research Institute en gratis toegankelijk is via http://citeseer.nj.nec.com/cs. Het innovatieve in de aanpak van het Nec Research Institute is dat een programma volledig automatisch het Internet afstruint op zoek naar artikelen op het terrein van \u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Centrum voor Wiskunde en lnformatica Centre for Mathematics and Computer Science\n", "abstract": " The discussion of this paper takes place in the framework of ACP, the Algebra of Communicating Processes, as described in BERGSTRA & KLoP [BKI, BK2]. ACP is the core of a family of axiom systems. These axiom systems are constructed out of a number of building blocks of operators and axioms. Each block describes a feature of concurrency in a certain semantical setting. In the first section we present a brief review of the theory of process algebra. We also define, in terms of the ACP and Renaming (RN) operators, a chaining operator~>. At this moment there are a lot of programming languages which offer facilities for concurrent programming. The basic notions of some of these languages, for example CSP (HOARE [HJ), Occam (INMOS [IN]) and LOTOS (ISO [IS]), are rather close to the basic notions in ACP, and it is not very difficult to give semantics of these languages in the framework of ACP. MILNER [Mi] showed how a simple high level concurrent language can be translated into CCS. However, it is not obvious at first sight how to give process algebra semantics of more complex concurrent programming languages like", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Report CS-R9366 November 1993\n", "abstract": " This paper discusses some axioms from the literature which have been used to define properties of timed transition systems. The additivity axiom proposed by (amongst others) Wang, and Nicollin and Sifakis is compared with the trajectory axiom of Lynch and Vaandrager. Some conditions for an additive transition system to be trajectoried are discussed. These are proved sufficient by using some simple terminology from category theory to show how this problem about timed transition systems can be turned into an equivalent problem about monotone functions on partially ordered sets. We also discuss trajectory (bi) simulation, which is a variant of Ho-Stuart's path bisimulation, and use similar techniques to discuss when (bi) simulation is equivalent to trajectory (bi) simulation.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Algebraic Theories of Concurrency\n", "abstract": " In this paper we discuss the issue of interleaving semantics versus True concurrency in an algebraic setting. We present vari-ous equivalence notions on Petri nets which can be used in the construction of algebraic models:(a) the occurrence net equivalence ct Nielsen, Plotkin Gt Winskel;-(b) bisimulation equivalence. which leads to a model which is isomorphic to the graph model of Baeten. Bergstra A Klopz (c) the concurrent bisimulation equivalence, which is also described by Nielsen & Thiagaraian. and Goltz:(d) partial order equivalences which are inspired by work of Pratt. and Boudol 8. Castellani. A central role in the paper will be played by the notion of real-time consistency. We show that. besides occurrence net equivalence, none ot the equivalences mentioned above (including the penis order equivalencesl) is real-time consistent. Therefore we introduce the notion of ST-bisimulation equivalence. which is\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Informatica en Rationalisme\n", "abstract": " In de loso e worden denkers als Plato, Descartes en Leibniz\\rationalisten\" genoemd omdat zij geloven in het bestaan van synthetische, a priori waarheden. Hiertegenover plaatst men de\\empiristen\", losofen als Locke, Berkeley en Hume, die stellen dat de mens de wereld alleen kennen kan uit zijn ervaringen, door zien, tasten, herinneren en dergelijke. Wanneer Ollongren en Van den Herik de algoritmiek tot het rationalisme rekenen, dan lijken zij daarmee te bedoelen dat de denkwetten (spelregels) van dit vakgebied vastliggen en dat alle belangrijke resultaten daaruit verkregen kunnen worden louter door gebruik van het verstand. Wanneer men een voldoende geniaal iemand, zeg Donald Knuth, op jeugdige leeftijd zou opsluiten in een afgelegen en volstrekt ge soleerd klooster met een paar de nities waaronder die van een Turing machine, dan zou deze persoon de hele algoritmiek als het ware opnieuw kunnen uitvinden. Wanneer men de kloosterling na veertig jaar zou opzoeken, dan zou hij (of zij) mogelijk hebben ontdekt dat er zo iets is als een berekenbare functie, dat er diverse complexiteitsklassen van algoritmes zijn (zoals P en NP), en wie weet zelfs een driedelig werk hebben geschreven over\\The art of computer programming\". Al deze", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R0013 July 2000\n", "abstract": " In existing simulation proof techniques, a single step in a lower-level specication may be simulated by an extended execution fragment in a higher-level one. As a result, it is cumbersome to mechanize these techniques using general purpose theorem provers. Moreover, it is undecidable whether a given relation is a simulation, even if tautology checking is decidable for the underlying specication logic. This paper introduces various types of normed simulations. In a normed simulation, each step in a lower-level specication can be simulated by at most one step in the higher-level one, for any related pair of states. We show that, under some reasonable assumptions, it is decidable whether a given relation is a normed forward simulation, provided tautology checking is decidable for the underlying logic. We also prove that, at the semantic level, normed forward and backward simulations together form a complete proof\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R9813 April 1998\n", "abstract": " PLC-Automata are a class of real-time automata suitable to describe the behaviour of polling real-time systems. PLC-Automata can be compiled to source code for PLCs, a hardware widely used in industry to control processes. Also, PLC-Automata have been equipped with a logical and operational semantics, using Duration Calculus (DC) and Timed Automata (TA), respectively. The three main results of this paper are:(1) A simpli ed operational semantics.(2) A minor extension of the logical semantics, and a proof that this semantics is complete relative to our operational semantics. This means that if an observable satis es all formulas of the DC semantics, then it can also be generated by the TA semantics.(3) A proof that the logical semantics is sound relative to our operational semantics. This means that each observable that is accepted by the TA semantics constitutes a model for all formulas of the DC semantics.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "REPORT'RAPPORT I\u2122\n", "abstract": " 'The actual occurrence \u00f3f each event in the life of an object should be regarded as an instantaneous or an atomic action without duration. Extended or time-consuming actions should be represented by a pair of events, the first denoting its start and the second denoting its finish.'(p. 24)In interleaving semantics the behavior of a system that performs two actions a and b in parallel is considered the same as the behavior of a system that either does an a followed by a b, or a b followed by an a. Algebraically this leads to equations like", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CS-R9579 1995\n", "abstract": " Notions of weak and strong fairness are studied in the setting of the I/O automaton model of Lynch & Tuttle.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CS-R9578 1995\n", "abstract": " We propose a new hybrid I/O automaton model that is capable of describing both continuous and discrete behavior. The model, which extends the timed I/O automaton model of 12, 7] and the phase transition system models of 15, 2], allows communication among components using both shared variables and shared actions.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Minimum-Cost Reachability for Priced Timed Automata Gerd Behrmann Ansgar Fehnker Thomas S. Hune\n", "abstract": " This paper introduces the model of linearly priced timed automata as an extension of timed automata, with prices on both transitions and locations. For this model we consider the minimum-cost reachability problem: ie given a linearly priced timed automaton and a target state, determine the minimum cost of executions from the initial state to the target state. This problem generalizes the minimum-time reachability problem for ordinary timed automata. We prove decidability of this problem by offering an algorithmic solution, which is based on a combination of branch-and-bound techniques and a new notion of priced regions. The latter allows symbolic representation and manipulation of reachable states together with the cost of reaching them", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Centrum voor Wfskund\u00a9 eri Informatica\n", "abstract": " \u00a7 1 Introduction A (discrete) concurrent system generates events as it evolves in time. At any moment a set of events will have occurred and these will be ordered'in time'or by'causal precedence'. This order may be partial. When modelling concurrent systems and reasoning about their behaviour, it is often useful to consider different events as occurrences of the same action. This may indicate that certain events are produced by the same physical resource or that they cannot be distinguished by an observer. The relation between events and actions can be expressed by a labelling function l: E-* A that relates an action to each event. Different approaches to the modelling of concurrent systems can be classified by looking at the types of labelling functions they allow for. For instance, if one models a concurrent system with an elementary net system [24], then it can never be the case that in some behaviour two events\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "KEPOK\u00cdRAPPORT^\n", "abstract": " We analyze a simple version of a protocol developed by Philips for the physical layer of an interface bus that connects the various devices of some stereo equipment (tuner, CD player,...). The protocol, which uses Manchester encoding, has to deal with a significant uncertainty in the timing of events, due to both hardware and software constraints. We present a formal specification of the protocol, and a proof of correctness for the case where the tolerance of the clocks used within the system is less than^ s. A counterexample shows that the protocol fails for tolerances greater than or equal to this value. The verification is carried out using a model of linear hybrid systems, which is similar to the phase transition system model of Manna and Pnueli, and the model of linear hybrid automata of Alur, Henzinger and Ho. The semantics of linear hybrid systems is defined via a translation to the timed I/O automata model of Lynch\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R0109 March 2001\n", "abstract": " \u0419\u0431 \u0430 \u0432\u0437 \u0436\u0418 \u0439 \u0418 \u043a \u0432 \u0437\u041a \u0439\u0432\u041a\u0432\u0430\u041a \u0434 \u0436\u0438\u0431 \u0432\u0438 \u0433 \u0433\u0431\u0434\u0439\u0438 \u0436 \u042b\u043d\u0437\u0438 \u0431\u0437\u0418 \u0421\u0432 \u0433\u0436\u0431 \u0438 \u0433\u0432 \u042c \u0432\u0433\u0430\u0433 \u043d\u0418 \u042d\u0434\u0434\u0437 \u0430 \u042d\u0432 \u043a \u0436\u0437 \u0438\u043d\u0418 \u0419\u0431 \u0430 \u0434 \u0439\u0434 \u0438 \u0433 \u0437\u041a\u0439\u0439\u041a\u0437\u041a \u0437\u0438\u0436 \u0438\u041a \u042c \u0437 \u0434 \u0434 \u0436 \u0432\u0438\u0436\u0433 \u0439 \u0437 \u0438 \u0431\u0433 \u0430 \u0433 \u0430 \u0432 \u0436\u0430\u043d \u0434\u0436 \u0438 \u0431 \u0439\u0419 \u0438\u0433\u0431 \u0438 \u0437 \u0432 \u043c\u0438 \u0432\u0437 \u0433\u0432 \u0433 \u0438 \u0431 \u0439\u0438\u0433\u0431 \u0438 \u0418 \u043b \u0438 \u0434\u0436 \u0437 \u0433\u0432 \u0433\u0438 \u0438\u0436 \u0432\u0437 \u0419 \u0438 \u0433\u0432\u0437 \u0432 \u0430\u0433 \u0438 \u0433\u0432\u0437\u041a \u0433\u0436 \u0438 \u0437 \u0431\u0433 \u0430 \u043b \u0433\u0432\u0437 \u0436 \u0438 \u0431 \u0432 \u0431\u0439\u0431\u0419 \u0433\u0437\u0438 \u0436 \u0419 \u0430 \u0438\u043d \u0434\u0436\u0433 \u0430 \u0431 \u041a \u041a \u043a \u0432 \u0430 \u0432 \u0436\u0430\u043d \u0434\u0436 \u0438 \u0431 \u0439\u0438\u0433\u0431 \u0438\u0433\u0432 \u0432 \u0438 \u0436 \u0438 \u0437\u0438 \u0438 \u0418 \u0438 \u0436\u0431 \u0432 \u0438 \u0431 \u0432 \u0431\u0439\u0431 \u0433\u0437\u0438 \u0433 \u043c \u0439\u0438 \u0433\u0432\u0437 \u0436\u0433\u0431 \u0438 \u0432 \u0438 \u0430 \u0437\u0438 \u0438 \u0438\u0433 \u0438 \u0438 \u0436 \u0438 \u0437\u0438 \u0438 \u041a \u042c \u0437 \u0434\u0436\u0433 \u0430 \u0431 \u0432 \u0436 \u0430 \u043e \u0437 \u0438 \u0431 \u0432 \u0431\u0439\u0431\u0419\u0438 \u0431 \u0436 \u0419 \u0430 \u0438\u043d \u0434\u0436\u0433 \u0430 \u0431 \u0433\u0436 \u0433\u0436 \u0432 \u0436\u043d \u0438 \u0431 \u0439\u0438\u0433\u0431 \u0438 \u041a \u042f \u0434\u0436\u0433\u043a \u0430 \u0438\u043d \u0433 \u0438 \u0437 \u0434\u0436\u0433 \u0430 \u0431 \u043d \u0433\u040b \u0436 \u0432 \u0432 \u0430 \u0433\u0436 \u0438 \u0431 \u0437\u0433\u0430\u0439\u0438 \u0433\u0432\u0418 \u043b \u0437 \u0437 \u0433\u0432 \u0433\u0431 \u0432 \u0438 \u0433\u0432 \u0433 \u0436 \u0432 \u0419 \u0432 \u0419 \u0433\u0439\u0432 \u0438 \u0432 \u0435\u0439 \u0437 \u0432 \u0432 \u043b \u0432\u0433\u0438 \u0433\u0432 \u0433 \u0434\u0436 \u0436 \u0433\u0432\u0437\u041a \u042c \u0430 \u0438\u0438 \u0436 \u0430\u0430\u0433\u043b\u0437 \u0437\u043d\u0431 \u0433\u0430 \u0436 \u0434\u0436 \u0437 \u0432\u0438 \u0438 \u0433\u0432 \u0432 \u0431 \u0432 \u0434\u0439\u0430 \u0438 \u0433\u0432 \u0433 \u0436 \u0430 \u0437\u0438 \u0438 \u0437 \u0438\u0433 \u0438 \u0436 \u043b \u0438 \u0438 \u0433\u0437\u0438 \u0433 \u0436 \u0432 \u0438 \u0431\u041a \u0423 \u043d\u043b\u0433\u0436 \u0437 \u042c \u0431 \u0439\u0438\u0433\u0431 \u0438 \u0418 \u042e \u0436 \u040c \u0438 \u0433\u0432\u0418 \u0438 \u042b\u0438\u0436\u0439 \u0438\u0439\u0436 \u0437\u0418 \u0430 \u0433\u0436 \u0438 \u0431\u0437\u0418 \u0427\u0434\u0438 \u0431 \u043e \u0438 \u0433\u0432\u041a", "num_citations": "0\n", "authors": ["1601"]}
{"title": "Probabilistic I/O Automata Models\n", "abstract": " 2. It should be able to express a variety of features of real systems, for example, timing assumptions and guarantees, continuous evolution of real-world system components, and probabilistic behavior. It should be able to express any combination of these features.3. It should support description of systems in a modular manner. Of course, it should support description of components and their interactions. In addition, it should allow description of systems at different levels of abstraction.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "CSI-R9712 August 1997\n", "abstract": " We present a generalization of the classical theory of testing for Mealy machines to a setting of dense real-time systems. A model of timed I/O automata is introduced, inspired by the timed automaton model of Alur and Dill, together with a notion of test sequence for this model. Our main contribution is a test generation algorithm for black-box conformance testing of timed I/O automata. Although it is highly exponential and cannot be claimed to be of practical value, it is the rst algorithm that yields a nite and complete set of tests for dense real-time systems.", "num_citations": "0\n", "authors": ["1601"]}
{"title": "A Theory of Abstractions for Learning I/O Automata\n", "abstract": " Regular inference of state machines is a promising technique for obtaining high-level models of software components. State-of-the-art tools are able to learn state machines with at most in the order of 10.000 states. This is not enough for learning models of realistic software components which, due to the presence of program variables, typically have much larger state spaces. Recently, Aarts, Jonsson & Uijen have proposed a framework for regular inference with abstraction in which, depending on the history, a large set of concrete events is mapped to a small set of abstract events. Using this framework they succeeded to automatically infer models of several realistic software components with large state spaces, including fragments of the TCP and SIP protocols. In this article, we provide a solid theoretical foundation for a generalization of the framework of Aarts et al. Our theory supports (a) I/O automata instead of the\u00a0\u2026", "num_citations": "0\n", "authors": ["1601"]}