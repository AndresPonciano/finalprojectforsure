{"title": "Mondrian: an agile information visualization framework\n", "abstract": " Data visualization is the process of representing data as pictures to support reasoning about the underlying data. For the interpretation to be as easy as possible, we need to be as close as possible to the original data. As most visualization tools have an internal meta-model, which is different from the one for the presented data, they usually need to duplicate the original data to conform to their meta-model. This leads to an increase in the resources needed, increase which is not always justified. In this work we argue for the need of having an engine that is as close as possible to the data and we present our solution of moving the visualization tool to the data, instead of moving the data to the visualization tool. Our solution also emphasizes the necessity of reusing basic blocks to express complex visualizations and allowing the programmer to script the visualization using his preferred tools, rather than a third party\u00a0\u2026", "num_citations": "122\n", "authors": ["229"]}
{"title": "Reverse engineering software ecosystems\n", "abstract": " Reverse engineering is an active area of research concerned with the development of techniques and tools that support the understanding of software systems. All the techniques that were pro-posed until now study individual systems in isolation. However, software systems are seldom developed in isolation; instead, they are developed together with other projects in the wider context of an organization. We call the collection of projects that are developed in such a con-text a software ecosystem. Understanding the code base, the inter-project relationships and the emergent social structure of an ecosystem is critical for the efficient functioning of the organiza-tion. In this thesis we propose ecosystem reverse engineering as a technique for ecosystem under-standing. We then introduce Revenge, a methodology for reverse engineering entire software ecosystems, we present in detail multiple steps of the process, we provide tools that support the methodology, and we validate both the methodology and tools on multiple case studies. Revenge is based on analyzing the super-repository associated with an ecosystem and gen-erating ecosystem viewpoints, visual representations that capture complementary aspects of the ecosystem. The viewpoints can be either holistic and present the entire ecosystem as a whole, or focused and present a single component of the ecosystem in the broader context. The viewpoints are interactive and a user can navigate between them during the analysis process. One essential type of exploration is vertical navigation, which allows zooming in on a single project in the ecosystem, and provides a bridge between\u00a0\u2026", "num_citations": "105\n", "authors": ["229"]}
{"title": "Towards reverse engineering software ecosystems\n", "abstract": " Reverse engineering is the process of recovering a projectpsilas components and the relationships between them with the goal of creating representations of the project at a higher level of abstraction. When dealing with the large amounts of information that are analyzed during reverse engineering visualization and exploratory navigation are important tools. However, a software system does not exist by itself. Instead, a project is part of a larger software ecosystem of projects that is developed in the context of an organization, a research group of an open-source community. In our work, we argue that reverse engineering an ecosystem is a natural and complementary extension to the traditional single system reverse engineering. We propose a methodology based on visualization, top-down exploration, architecture recovery and software evolution analysis for the reverse engineering software ecosystems. Our\u00a0\u2026", "num_citations": "88\n", "authors": ["229"]}
{"title": "Package patterns for visual architecture recovery\n", "abstract": " Recovering the architecture is the first step towards reengineering a software system. Many reverse engineering tools use top-down exploration as a way of providing a visual and interactive process for architecture recovery. During the exploration process, the user navigates through various views on the system by choosing from several exploration operations. Although some sequences of these operations lead to views which, from the architectural point of view, are mode relevant than others, current tools do not provide a way of predicting which exploration paths are worth taking and which are not. In this article, we propose a set of package patterns which are used for augmenting the exploration process with information about the worthiness of the various exploration paths. The patterns are defined based on the internal package structure and on the relationships between the package and the other packages in\u00a0\u2026", "num_citations": "64\n", "authors": ["229"]}
{"title": "Software architecture recovery\n", "abstract": " Software Architecture Recovery Page 1 Mircea Lungu Software Architecture Recovery Selected material courtesy Oscar Nierstrasz Friday, November 4, 11 Page 2 > Introduction to SAR > Top-down SAR > Bottom-up SAR > Tool Demo Roadmap 2 Friday, November 4, 11 Page 3 > Introduction to SAR \u2014Architecture \u2014Viewpoints, Styles, ADL\u2019s \u2014Recovery > Top-down SAR > Bottom-up SAR > Tool Demo Roadmap 3 Friday, November 4, 11 Page 4 > Introduction to SAR \u2014Architecture \u2014Viewpoints, Styles, ADL\u2019s \u2014Recovery > Top-down SAR > Bottom-up SAR > Tool Demo Roadmap 4 Friday, November 4, 11 Page 5 Friday, November 4, 11 Page 6 Architecture is... 6 Architecture Design Code [Lungu09] ...an abstraction level Friday, November 4, 11 Page 7 Architecture is... 6 Architecture Design Code [Lungu09] \u201c[...] the fundamental organization of a system embodied in its components, their relationships to each other, .\u2026", "num_citations": "55\n", "authors": ["229"]}
{"title": "Reverse engineering super-repositories\n", "abstract": " Reverse engineering and software evolution research has been focused mostly on analyzing single software systems. However, rarely a project exists in isolation; instead, projects exist in parallel within a larger context given by a company, a research group or the open-source community. Technically, such a context manifests itself in the form of super-repositories, containers of several projects developed in parallel. Well-known examples of such super-repositories include SourceForge and CodeHaus. We present an easily accessible platform which supports the analysis of such super-repositories. The platform can be valuable for reverse engineering both the projects and the structure of the organization as reflected in the interactions and collaborations between developers. Throughout the paper we present various types of analysis applied to three open-source and one industrial Smalltalk super- repositories\u00a0\u2026", "num_citations": "40\n", "authors": ["229"]}
{"title": "A low-effort analytics platform for visualizing evolving Flask-based Python web services\n", "abstract": " Tens of thousands of web applications are written in Flask, a Python-based web framework. Despite a rich ecosystem of extensions, there is none that supports the developer in gaining insight into the evolving performance of their service. In this paper, we introduce Flask Dashboard, a library that addresses this problem. We present the ease with which the library can be integrated in an already existing web application, discuss some of the visualization perspectives that the library provides and point to some future challenges for similar libraries.", "num_citations": "37\n", "authors": ["229"]}
{"title": "Exploring inter-module relationships in evolving software systems\n", "abstract": " Many of the existing approaches to reverse architecting - the reverse engineering of the architecture of software systems - are based on software exploration tools which provide interactive ways of exploring the system. These tools start with high-level views of the system and refine them with drill-down techniques applied on the high-level entities such as modules and packages, leaving aside valuable information contained in the dependencies between them. In this article we argue that the visualization of inter-module relations bears great potential for supporting the understanding of large evolving software systems. We present two concrete examples of such visualizations. The first, the semantic dependency matrix is a technique for displaying details about a dependency between two modules which groups together classes with similar behavior. The second, the edge evolution film-strip presents the evolution of\u00a0\u2026", "num_citations": "34\n", "authors": ["229"]}
{"title": "Softwarenaut: Exploring hierarchical system decompositions\n", "abstract": " Softwarenaut is a tool used for the top-down exploration of large software systems. Using it, the reverse engineer can obtain various architectural views of a system by interactively navigating a hierarchical decomposition of the system. In order to accommodate many possible decompositions of a system Softwarenaut was designed as a framework which provides visualization and exploration services that can be applied on various hierarchical decompositions of the system", "num_citations": "32\n", "authors": ["229"]}
{"title": "Geo-locating the knowledge transfer in StackOverflow\n", "abstract": " Stack Overflow can be seen as an information market for software engineering knowledge in which the goods that are exchanged are answers to questions and the rewards are score points and badges that contribute to a users reputation. By analyzing the transactions in Stack Overflow we can get a glimpse of the way in which the different geographical regions in the world contribute to the knowledge market represented by the website. In this paper we aggregate the knowledge transfer from the level of the users to the level of geographical regions and learn that Europe and North America are the principal and virtually equal contributors; Asia comes as a distant third, mainly represented by India; and Oceania contributes less than Asia but more than South America and Africa together.", "num_citations": "30\n", "authors": ["229"]}
{"title": "Replaying past changes in multi-developer projects\n", "abstract": " What was I working on before the weekend? and What were the members of my team working on during the last week? are common questions that are frequently asked by a developer. They can be answered if one keeps track of who changes what in the source code. In this work, we present Replay, a tool that allows one to replay past changes as they happened at a fine-grained level, where a developer can watch what she has done or understand what her colleagues have done in past development sessions. With this tool, developers are able to not only understand what sequence of changes brought the system to a certain state (eg, the introduction of a defect), but also deduce reasons for why her colleagues performed those changes. One of the applications of such a tool is also discovering the changes that broke the code of a developer.", "num_citations": "29\n", "authors": ["229"]}
{"title": "Visualizing gnome with the small project observatory\n", "abstract": " We analyzed the gnome family of systems with the small project observatory, our online ecosystem visualization platform. We begin by briefly introducing the model of SPO. We then observe and discuss several phases in the activity of the gnome ecosystem. We follow and look at how the contributors are distributed between writing source code and doing other activities such as internationalization. We end with a visual overview of the activity of more than 900 contributors in the 10 years of existence of gnome.", "num_citations": "27\n", "authors": ["229"]}
{"title": "Interactive exploration of semantic clusters\n", "abstract": " Using visualization and exploration tools can be of great use for the understanding of a software system when only its source code is available. However, understanding a large software system by visualizing only its lower level artifacts (e.g., classes, methods) and the relations between them does not scale for industrial-size systems. To address the scalability issue, higher level hierarchical abstractions (e.g., package structure, clustered decompositions of the system) should be used together with relations between them that are usually aggregated from the lower level relations. In this paper, we present the concepts behind Softwarenaut, a tool aimed at exploring any kind of hierarchical decompositions of a system, and then we look at a specific exploration of a system. In the experiment, the hierarchical decomposition of the system is the result of applying a semantic clustering to group classes that use similar terms", "num_citations": "22\n", "authors": ["229"]}
{"title": "The small project observatory: a tool for reverse engineering software ecosystems\n", "abstract": " Software evolution researchers have focused mostly on analyzing single software systems. However, often projects are developed and co-exist within software ecosystems, ie, the larger contexts of companies, research groups or open-source communities. We present The Small Project Observatory, a web-based analysis platform for ecosystem reverse engineering through interactive visualization and exploration.", "num_citations": "18\n", "authors": ["229"]}
{"title": "Accelerating software engineering research adoption with analysis bots\n", "abstract": " An important part of software engineering (SE) research is to develop new analysis techniques and to integrate these techniques into software development practice. However, since access to developers is non-trivial and research tool adoption is slow, new analyses are typically evaluated as follows: a prototype tool that embeds the analysis is implemented, a set of projects is identified, their revisions are selected, and the tool is run in a controlled environment, rarely involving the developers of the software. As a result, research artifacts are brittle and it is unclear if an analysis tool would actually be adopted. In this paper, we envision harnessing the rich interfaces provided by popular social coding platforms for automated deployment and evaluation of SE research analysis. We propose that SE analyses can be deployed as analysis bots. We focus on two specific benefits of such an approach: (1) analysis bots can\u00a0\u2026", "num_citations": "17\n", "authors": ["229"]}
{"title": "Bootstrapping an ubiquitous monitoring ecosystem for accelerating vocabulary acquisition\n", "abstract": " Learning the vocabulary of a new language is a very slow and time consuming process which can take many years of dedicated study. Free reading is known to be important for improving vocabulary and so are optimally timed repetitions of learned concepts. However, these two have not been put together until now.", "num_citations": "15\n", "authors": ["229"]}
{"title": "Pangea: A workbench for statically analyzing multi-language software corpora\n", "abstract": " Software corpora facilitate reproducibility of analyses, however, static analysis for an entire corpus still requires considerable effort, often duplicated unnecessarily by multiple users. Moreover, most corpora are designed for single languages increasing the effort for cross-language analysis. To address these aspects we propose Pangea, an infrastructure allowing fast development of static analyses on multi-language corpora. Pangea uses language-independent meta-models stored as object model snapshots that can be directly loaded into memory and queryed without any parsing overhead. To reduce the effort of performing static analyses, Pangea provides out-of-the box support for: creating and refining analyses in a dedicated environment, deploying an analysis on an entire corpus, using a runner that supports parallel execution, and exporting results in various formats. In this tool demonstration we introduce\u00a0\u2026", "num_citations": "14\n", "authors": ["229"]}
{"title": "Gaucho: From integrated development environments to direct manipulation environments\n", "abstract": " Object-oriented programming languages promote reasoning that revolves around objects that send each other messages. To practically make this happen, developers write programs, aided by integrated development environments (IDEs). A modern IDE offers a large number of tools that work on a textual representation of the program. We argue that while modern IDEs\u2013and their many tools\u2013offer powerful means for manipulating source code, at the same time they introduce a barrier between the developer and the concepts under development because they still treat programs as files of text.We present Gaucho, a lightweight development environment we are currently creating, which minimizes the presence of tools and allows the developer to directly manipulate objects. Drawing inspirations from both the Smalltalk and the SELF languages, our goal is to conceive a direct manipulation environment (DME) for software. We present the current status of our implementation, discuss its advantages and drawbacks, and delineate our next steps.", "num_citations": "14\n", "authors": ["229"]}
{"title": "Biomedical information visualization\n", "abstract": " The ongoing developments in the fields of molecular biology, genetics, and medical sciences have recently generated an explosion of information collected from living organisms. For the scientist who analyzes these huge amounts of data, information visualization can be a very useful tool.               Because an exhaustive survey of the use of information visualization in the molecular biology, genetics and medical science is beyond the scope or space of this chapter, the chapter will present several highlights on the use of information visualization in the aforementioned domains.               The reader is not expected to be an expert in any of the analyzed fields, in fact, the material is organized in such a way that it does not make any assumptions on reader\u2019s domain knowledge. This means that for the domain expert, the level of discourse might be superficial, but one can always refer to the original papers for more\u00a0\u2026", "num_citations": "13\n", "authors": ["229"]}
{"title": "Softwarenaut: Cutting edge visualization\n", "abstract": " Many reverse engineering and program understanding tools support the static analysis of large software systems by providing exploratory analysis and visualization services. Most of these tools use graph-based representations, in which entities are represented as nodes and dependencies between them as edges.", "num_citations": "10\n", "authors": ["229"]}
{"title": "As We May Study: Towards the Web as a Personalized Language Textbook\n", "abstract": " We present a system designed to enable learners of a foreign language to read materials that are personally interesting to them from the web and practice vocabulary with interactive exercises based on their past readings. We report on the results of deploying the system for one month with three classes of Dutch highschool students learning French. The students and their teacher were positive about the system and in particular about the personalization aspects that the system enables.", "num_citations": "8\n", "authors": ["229"]}
{"title": "On planning an evaluation of the impact of identifier names on the readability and quality of smalltalk programs\n", "abstract": " One of the long running debates between programmers is whether camelCaseldentifiers are better than underscore_identifiers. This is ultimately a matter of programming language culture and personal taste, and to our best knowledge none of the camps has won the argument yet. It is our intuition that a solution exists which is superior to both the previous ones from the point of view of usability: the solution we name sentence case identifiers allows phrases as nams for program entities such as classes or methods. In this paper we propose a study in which to evaluate the impact of sentence case identifiers in practice.", "num_citations": "6\n", "authors": ["229"]}
{"title": "Zeeguu translate application\n", "abstract": " Zeeguu is a user based learning platform which enables the user to expand his vocabulary and receive feedback about his progress while he is reading about topics he loves.To reach the best efficiency possible, the user should be able to access the Platform from as many devices as possible, all connected with one single account. This way Zeeguu supports the user when he is reading foreign languages, monitors his progress of those languages and gives him further possibilities to improve the language everywhere and at any time. This paper introduces an Android application as an extension for the Zeeguu ecosystem and since Android is the leading mobile operating system, this work represents an important step towards getting Zeeguu into the daily life of the users.", "num_citations": "5\n", "authors": ["229"]}
{"title": "The small project observatory\n", "abstract": " Maintenance is an important activity in software engineering with studies attributing it more than 75% of the total cost of a system. More than half the time dedicated to maintenance is spent on reverse engineering the code which often is the only accurate source of information. In this context, among the many approaches, software visualization tools have long been seen as an important asset to support the comprehension process, offering facilities to understand a given software system.However, systems do not exist in isolation, but they exist in the context of organizations, research groups or open-source communities. We call these larger contexts, that contain version repositories for multiple systems in parallel,\u201csuper-repositories\u201d. We argue that there is a need for software visualization tools that support the reverse-engineering of such super-repositories. We present a tool called the Small Project Observatory (SPO) that supports the visualization and interactive exploration of super-repositories.", "num_citations": "5\n", "authors": ["229"]}
{"title": "A small observatory for super-repositories\n", "abstract": " Software evolution research has been focused mostly on analyzing the evolution of single software systems. However, it is rarely the case that a project exists as standalone, independent of others. Rather, projects exist in parallel within larger contexts in companies, research groups or even the open-source communities, contexts that we call super-repositories. In this paper, we argue that visualization of super-repositories is useful in a range of situations, and we describe The Small Project Observatory, a prototype tool which aims to visualize super-repositories.", "num_citations": "4\n", "authors": ["229"]}
{"title": "Technical Debt Management: A systematic literature review and research agenda for digital government\n", "abstract": " Technical debt is created when software engineers knowingly or unknowingly introduce shortcuts or unsuitable choices in the development or maintenance of the software system, that will have a negative impact on the future evolution of the system until corrected. Therefore, it is crucial to manage established debt particular in the public sector. The aim of this study is to introduce Technical debt to the field of Digital Government. We create an overview of the state of the art of the knowledge on technical debt management, the methods applied to gain this knowledge, and propose a research agenda to Digital Government scholars. We conduct a systematic literature review, which focuses on the concept of technical debt management. Forty-nine papers published within 2017\u20132020 are selected and analyzed. We identify several gaps in the existing literature: 1) an absence of theory explaining the relation of events, 2\u00a0\u2026", "num_citations": "3\n", "authors": ["229"]}
{"title": "Designing personalized learning environments through monitoring and guiding user interactions with code and natural language\n", "abstract": " Learning the vocabulary of a new language and a new programming API are similar in multiple ways. In this paper we evaluate several of the similarities and show that based on them we can design systems that can guide the learner towards improving their knowledge without an external tutor or preset curriculum. Instead, the class of systems we propose here are based on automated approaches of building maps of knowledge of the domain by mining repositories. By intersecting this knowledge with models of learner knowledge built by observing past learner interactions with artifacts of the domain we can generate highly personalized learning guidance.", "num_citations": "2\n", "authors": ["229"]}
{"title": "Using RSS feeds to support second language acquisition\n", "abstract": " Zeeguu is a language learning platform that allows people to extend their vocabulary and language skills by reading any text they like. Additionally, it provides feedback on the progress and exercises to further improve the aquired knowledge.This thesis introduces the Zeeguu Reader, a mobile application for Android that uses RSS feeds to automatically provide the user with the newest articles from the news sources or blogs he subscribes to, while supporting the user with translations and keeping track of his reading progress. Its features include an article recommender that tries to automatically select the articles that fit best to the user\u2019s current language level. For the RSS part, the application uses the Feedly Cloud 1, which synchronizes the subscriptions and reading progress between different devices and allows the user to continue reading where he left on any computer in the Feedly web interface and keep learning the language with the Zeeguu Chrome plugin.", "num_citations": "2\n", "authors": ["229"]}
{"title": "Categorising test smells\n", "abstract": " The aim of this investigation into test smells was to find out how familiar developers are with test smells, the frequency of test smells and their severity in the industrial world. First of all, a taxonomy of different test smells was created and grouped according to programming principles as a basis for this study. Several interviews were then conducted to find out which test smells to include in the subsequent survey. 20 people with different industrial experience levels participated in this survey. It was hypothesised that test smells are not identified as such and that their names are unknown. The hypothesis was supported by the results of the survey. The results revealed that test smells are not quite well-known despite the fact that some of them occur rather frequently and pose severe problems.", "num_citations": "2\n", "authors": ["229"]}
{"title": "Welcome from the tool demonstration chairs\n", "abstract": " Welcome from the Tool Demonstration Chairs, Holger M. Kienle, hkienle@ acm. org, http://holgerkienle. wikispaces. com, Mircea Lungu, lungu@ iam. unibe. ch, http://lungu. org/mircea, I. M, OTIVATION, The Tool Demonstration Track at CSMR 2012 provides an opportunity for researchers to present novel research tools, for software maintenance and reengineering. Eight tools which aim to aid software developers and maintainers in their, work have been selected for presentation and demonstration. The tools are meant to be explored and applied by interested, users and to inspire fellow researchers. Tool developers can thus get feedback on how to further improve upon their, tools. This track also provides an outlet to publish about research embodied in tools. This was recognized by the track\u2019s, call:, Since tools are central to research in software maintenance and reengineering, tool demonstrations will have a\u00a0\u2026", "num_citations": "2\n", "authors": ["229"]}
{"title": "Erase and rewind--Learning by replaying examples\n", "abstract": " Much of human learning is built on observing, retaining, and replicating behavior witnessed in a model. On this basis, instructors often teach informatics by providing programming examples to be observed and analyzed by learners. By retaining and replicating the steps leading to the final artifacts, students learn. However, professors usually illustrate an example program only once and provide only its finalized version. This hinders the students' need of repeated observation and replication. With the Eclipse plug-in Replay, we strive to overcome the limitations of the current approach to learning by example. Replay records every code edit of a programming session, making it available as an interactive executable\" tape\". Professors can accurately design the steps of an example, and\" play\" them as live sessions in class, without the burden of concurrent coding and explaining; students have their hands in the complete\u00a0\u2026", "num_citations": "2\n", "authors": ["229"]}
{"title": "Introduction to Software Engineering\n", "abstract": " A definition in Steve McConnell's Code Complete divides quality into two pieces: internal and external quality characteristics. External quality characteristics are those parts of a product that face its users, where internal quality characteristics are those that do not. Surely, every thing faces some users. So we could consider the internal ones o be external to the developers.", "num_citations": "2\n", "authors": ["229"]}
{"title": "A Polite Solution to Interact with EV3 Robots\n", "abstract": " Lego Mindstorms is a combination of hardware and software to build and program a variety of different Lego robots. The Evolution 3 (short EV3) represents the third generation of these promising robots. Besides Lego itself, plenty of other organisations, researchers and developers have designed software to interact with the EV3 robots, many of them with the target to teach Computational Thinking to amateur programmers, others to reach high functionality and open new possibilities. But although there are already a lot of existing projects, there seems to be a gap between the simple and visual learning programs, and the richer programming environments.", "num_citations": "1\n", "authors": ["229"]}
{"title": "Adding Class Support and Global Methods to Polite Smalltalk\n", "abstract": " Polite Smalltalk was created as part of a proposed study about the impact of Sentence Identifier Names on code readability and maintainability. It was based on a Smalltalk environment where it was parsed and compiled to Smalltalk code. Polite syntax was kept very minimal and did not support class or method definitions, even though Smalltalk classes and their methods could be used.In order to create code that is both more readable and very similar to natural language, the goal of this thesis is to extend the grammar and implementation of Polite Smalltalk with class and method definitions, as well as the necessary tools to provide a workspace for writing and executing a complete Polite program. In order to handle these new requirements, the original Polite\u2019s compiler architecture must be improved. The validation of our work shows that several non-trivial programs, each highlighting one aspect of the new functionality, can be written and executed yielding the expected results. Furthermore, arbitrary code can be parsed and evaluated in the Polite Playground with expected features and results.", "num_citations": "1\n", "authors": ["229"]}
{"title": "Inter-Project Dependencies in Java Software Ecosystems\n", "abstract": " Understanding the legacy of code in a software ecosystem is critical for the organization that is the owner of the ecosystem as well as for individual developers that work on particular systems in the ecosystem. Model driven development (MDD) and model driven architecture (MDA) techniques for describing inter-project dependencies are rarely used or they're not updated by anyone during software evolution process. Describing the dependencies by hand can be painful and error prone process. Another solution is recovering the dependencies using some reverse-engineering process. There are some existing technologies today. One of them is an Ecco model of inter-project dependencies with a set of methods for recovering the dependencies from Smalltalk based software ecosystems developed by Lungu et al. Aim of our research is applying this model with its methods on Java based software ecosystem.", "num_citations": "1\n", "authors": ["229"]}
{"title": "Reverse Engineering through Holistic Software Exploration.\n", "abstract": " Software Exploration tools usually work at a single level of abstraction. We argue for an approach which integrates multiple levels of abstraction in exploration. Each of these levels presents complementary information which is useful for the reverse engineering and understanding process.Introduction. Software exploration is a technique to analyze software projects. Most software exploration tools work at a single level of abstraction. We propose the concept of holistic software exploration which encourages exploring multiple levels of abstraction at the same time. We distinguish the following abstraction levels that contain useful information about software projects:", "num_citations": "1\n", "authors": ["229"]}