{"title": "Decentralised LTL Monitoring\n", "abstract": " Users wanting to monitor distributed or component-based systems often perceive them as monolithic systems which, seen from the outside, exhibit a uniform behaviour as opposed to many components displaying many local behaviours that together constitute the system\u2019s global behaviour. This level of abstraction is often reasonable, hiding implementation details from users who may want to specify the system\u2019s global behaviour in terms of an LTL formula. However, the problem that arises then is how such a specification can actually be monitored in a distributed system that has no central data collection point, where all the components\u2019 local behaviours are observable. In this case, the LTL specification needs to be decomposed into sub-formulae which, in turn, need to be distributed amongst the components\u2019 locally attached monitors, each of which sees only a distinct part of the global behaviour\u00a0\u2026", "num_citations": "122\n", "authors": ["1652"]}
{"title": "AutoMoDe\u2014notations, methods, and tools for model-based development of automotive software\n", "abstract": " This paper describes the first results from the AutoMoDe project (Automotive Model-based Development), where an integrated methodology for model-based development of automotive control software is being developed. The results presented include a number of problem-oriented graphical notations, based on a formally defined operational model, which are associated with system views for various degrees of abstraction. It is shown how the approach can be used for partitioning comprehensive system designs for subsequent implementation-related tasks. Recent experiences from a case study of an engine management system, specific issues related to reengineering, and the current status of CASE-tool support are also presented.", "num_citations": "65\n", "authors": ["1652"]}
{"title": "A novel architecture for situation awareness systems\n", "abstract": " Situation Awareness (SA) is the problem of comprehending elements of an environment within a volume of time and space. It is a crucial factor in decision-making in dynamic environments. Current SA systems support the collection, filtering and presentation of data from different sources very well, and typically also some form of low-level data fusion and analysis, e.g., recognizing patterns over time. However, a still open research challenge is to build systems that support higher-level information fusion, viz., to integrate domain specific knowledge and automatically draw conclusions that would otherwise remain hidden or would have to be drawn by a human operator. To address this challenge, we have developed a novel system architecture that emphasizes the r\u00f4le of formal logic and automated theorem provers in its main components. Additionally, it features controlled natural language for operator I\u00a0\u2026", "num_citations": "61\n", "authors": ["1652"]}
{"title": "SALT\u2014structured assertion language for temporal logic\n", "abstract": " This paper presents Salt. Salt is a general purpose specification and assertion language developed for creating concise temporal specifications to be used in industrial verification environments. It incorporates ideas of existing approaches, such as specification patterns, but also provides nested scopes, exceptions, support for regular expressions and real-time. The latter is needed in particular for verification tasks to do with reactive systems imposing strict execution times and deadlines. However, unlike other formalisms used for temporal specification of properties, Salt does not target a specific domain. The paper details on the design rationale, syntax and semantics of Salt in terms of a translation to temporal (real-time) logic, as well as on the realisation in form of a compiler. Our results will show that the higher level of abstraction introduced with Salt does not deprave the efficiency of the subsequent\u00a0\u2026", "num_citations": "61\n", "authors": ["1652"]}
{"title": "The contribution of free software to software evolution\n", "abstract": " It is remarkable to think that even without any interest in finding suitable methods and concepts that would allow complex software systems to evolve and remain manageable, the ever growing open source movement has silently managed to establish highly successful evolution techniques over the last two decades. These concepts represent best practices that could be applied equally to a number of today's most crucial problems concerning the evolution of complex commercial software systems. The authors state and explain some of these principles from the perspective of experienced open source developers, and give the rationale as to why the highly dynamic \"free software development process\", as a whole, is entangled with constantly growing code bases and changing project sizes, and how it deals with these successfully.", "num_citations": "55\n", "authors": ["1652"]}
{"title": "Runtime verification using a temporal description logic\n", "abstract": " Formulae of linear temporal logic (LTL) can be used to specify (wanted or unwanted) properties of a dynamical system. In model checking, the system\u2019s behavior is described by a transition system, and one needs to check whether all possible traces of this transition system satisfy the formula. In runtime verification, one observes the actual system behavior, which at any time point yields a finite prefix of a trace. The task is then to check whether all continuations of this prefix to a trace satisfy (violate) the formula.               In this paper, we extend the known approaches to LTL runtime verification in two directions. First, instead of propositional LTL we use -LTL, which can use axioms of the description logic  instead of propositional variables to describe properties of single states of the system. Second, instead of assuming that the observed system behavior provides us with complete information about the states\u00a0\u2026", "num_citations": "40\n", "authors": ["1652"]}
{"title": "A brief top-down and bottom-up philosophy on software evolution\n", "abstract": " The decision on whether to proceed to top-down or bottom-up during software development has a strong and underestimated impact on the quality of the final product including its later evolvability. Various examples for both strategies taken from such different domains as operating systems and computer games provide evidence that bottom-up developed systems are more suitable for future evolution. The reasons for this range from the increased compositionality of bottom-up developed artefacts at the technical level up to a greater independence from certain requirements which constitute the most transient part of a software system. Besides those advantages concerning evolvability, the negative effects of bottom-up orientation can not be ignored. Furthermore, proceeding bottom-up contradicts most conventional development processes. We regard this as a clear indication for the need of new development\u00a0\u2026", "num_citations": "37\n", "authors": ["1652"]}
{"title": "A first-order policy language for history-based transaction monitoring\n", "abstract": " Online trading invariably involves dealings between strangers, so it is important for one party to be able to judge objectively the trustworthiness of the other. In such a setting, the decision to trust a user may sensibly be based on that user\u2019s past behaviour. We introduce a specification language based on linear temporal logic for expressing a policy for categorising the behaviour patterns of a user depending on its transaction history. We also present an algorithm for checking whether the transaction history obeys the stated policy. To be useful in a real setting, such a language should allow one to express realistic policies which may involve parameter quantification and quantitative or statistical patterns. We introduce several extensions of linear temporal logic to cater for such needs: a restricted form of universal and existential quantification; arbitrary computable functions and relations in the term language\u00a0\u2026", "num_citations": "32\n", "authors": ["1652"]}
{"title": "LTL Goal Specifications Revisited.\n", "abstract": " The language of linear temporal logic (LTL) has been proposed as a formalism for specifying temporally extended goals and search control constraints in planning. However, the semantics of LTL is defined wrt. infinite state sequences, while a finite plan generates only a finite trace. This necessitates the use of a finite trace semantics for LTL. A common approach is to evaluate LTL formulae on an infinite extension of the finite trace, obtained by infinitely repeating the last state. We study several aspects of this finite LTL se mantics: we show its satisfiability problem is PSpace-complete (same as normal LTL), show that it complies with all equivalence laws that hold under standard (infinite) LTL semantics, and compare it with other finite trace semantics for LTL proposed in planning and in runtime verification. We also examine different mechanisms for determining whether or not a finite trace satisfies or violates an LTL\u00a0\u2026", "num_citations": "30\n", "authors": ["1652"]}
{"title": "Security protocols, properties, and their monitoring\n", "abstract": " This paper examines the suitability and use of runtime verification as means for monitoring security protocols and their properties. In particular, we employ the runtime verification framework introduced in [5] to monitor complex, history-based security-properties of the SSL-protocol. We give a detailed account of the methodology, compare its formal expressiveness to prior art, and describe its application to an open-source Java-implementation of the SSLprotocol. In particular, we show how one can make use of runtime verification to dynamically enforce that assumptions on the crypto-protocol implementations (that are commonly made when statically verifying crypto-protocol specifications against security requirements) are actually satisfied in a given protocol implementation at runtime. Our analysis of these properties shows that some important runtime correctness properties of the SSL-protocol exceed the commonly\u00a0\u2026", "num_citations": "25\n", "authors": ["1652"]}