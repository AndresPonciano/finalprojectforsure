{"title": "Schedule of bad smell detection and resolution: A new way to save effort\n", "abstract": " Bad smells are signs of potential problems in code. Detecting and resolving bad smells, however, remain time-consuming for software engineers despite proposals on bad smell detection and refactoring tools. Numerous bad smells have been recognized, yet the sequences in which the detection and resolution of different kinds of bad smells are performed are rarely discussed because software engineers do not know how to optimize sequences or determine the benefits of an optimal sequence. To this end, we propose a detection and resolution sequence for different kinds of bad smells to simplify their detection and resolution. We highlight the necessity of managing bad smell resolution sequences with a motivating example, and recommend a suitable sequence for commonly occurring bad smells. We evaluate this recommendation on two nontrivial open source applications, and the evaluation results suggest\u00a0\u2026", "num_citations": "121\n", "authors": ["989"]}
{"title": "Monitor-Based Instant Software Refactoring\n", "abstract": " Software refactoring is an effective method for improvement of software quality while software external behavior remains unchanged. To facilitate software refactoring, a number of tools have been proposed for code smell detection and/or for automatic or semi-automatic refactoring. However, these tools are passive and human driven, thus making software refactoring dependent on developers' spontaneity. As a result, software engineers with little experience in software refactoring might miss a number of potential refactorings or may conduct refactorings later than expected. Few refactorings might result in poor software quality, and delayed refactorings may incur higher refactoring cost. To this end, we propose a monitor-based instant refactoring framework to drive inexperienced software engineers to conduct more refactorings promptly. Changes in the source code are instantly analyzed by a monitor running in the\u00a0\u2026", "num_citations": "55\n", "authors": ["989"]}
{"title": "Modeling of a metal monolith catalytic reactor for methane steam reforming\u2013combustion coupling\n", "abstract": " A novel metal monolith reactor for coupling methane steam reforming with catalytic combustion is proposed in this work, the metal monolith is used as a co-current heat exchanger and the catalysts are deposited on channel walls of the monolith. The transport and reaction performances of the reactor are numerically studied utilizing heterogeneous model based on the whole reactor. The influence of the operating conditions like feed gas velocity, temperature and composition are predicted to be significant and they must be carefully adjusted in order to avoid hot spots or insufficient methane conversion. To improve reactor performance, several different channel arrangements and catalyst distribution modes in the monolith are designed and simulated. It is demonstrated that reasonable reactor configuration, structure parameters and catalyst distribution can considerably enhance heat transfer and increase the\u00a0\u2026", "num_citations": "55\n", "authors": ["989"]}
{"title": "Facilitating software refactoring with appropriate resolution order of bad smells\n", "abstract": " Bad smell is a key concept in software refactoring. We have a bunch of bad smells, refactoring rules, and refactoring tools, but we do not know which kind of bad smells should be resolved first. The resolution of one kind of bad smells may have impact on the resolution of other bad smells. Consequently, different resolution orders of the same set of bad smells may require different effort, and/or lead to different quality improvement. In order to ease the work and maximize the effect of refactoring, we try to analyze the relationships among different kinds of bad smells, and their impact on resolution orders of these bad smells. With the analysis, we recommend a resolution order of common bad smells. The main contribution of this paper is to motivate the necessity to arrange resolution orders of bad smells, and recommend a resolution order of common bad smells.", "num_citations": "53\n", "authors": ["989"]}
{"title": "Traceability-enabled refactoring for managing just-in-time requirements\n", "abstract": " Just-in-time requirements management, characterized by lightweight representation and continuous refinement of requirements, fits many iterative and incremental development projects. Being lightweight and flexible, however, can cause wasteful and procrastinated implementation, leaving certain stakeholder goals not satisfied. This paper proposes traceability-enabled refactoring aimed at fulfilling more requirements fully. We make a novel use of requirements traceability to accurately locate where the software should be refactored, and develop a new scheme to precisely determine what refactorings should be applied to the identified places. Our approach is evaluated through an industrial study. The results show that our approach recommends refactorings more appropriately than a contemporary recommender.", "num_citations": "49\n", "authors": ["989"]}
{"title": "Nomen est omen: Exploring and exploiting similarities between argument and parameter names\n", "abstract": " Programmer-provided identifier names convey information about the semantics of a program. This information can complement traditional program analyses in various software engineering tasks, such as bug finding, code completion, and documentation. Even though identifier names appear to be a rich source of information, little is known about their properties and their potential usefulness. This paper presents an empirical study of the lexical similarity between arguments and parameters of methods, which is one prominent situation where names can provide otherwise missing information. The study involves 60 real-world Java programs. We find that, for most arguments, the similarity is either very high or very low, and that short and generic names often cause low similarities. Furthermore, we show that inferring a set of low-similarity parameter names from one set of programs allows for pruning such names in\u00a0\u2026", "num_citations": "47\n", "authors": ["989"]}
{"title": "Identifying fragments to be extracted from long methods\n", "abstract": " Long and complex methods are hard to read or maintain, and thus usually treated as bad smells, known as Long Method. On the contrary, short and well-named methods are much easier to read, maintain, and extend. In order to divide long methods into short ones, refactoring Extract Method was proposed and has been widely used. However, extracting methods manually is time consuming and error prone. Though existing refactoring tools can automatically extract a selected fragment from its inclosing method, which fragment within a long method should be extracted has to be determined manually. In order to facilitate the decision-making, we propose an approach to recommend fragments within long methods for extraction. The approach is implemented as a prototype, called AutoMeD. With the tool, we evaluate the approach on a nontrivial open source project. The evaluation results suggest that refactoring cost\u00a0\u2026", "num_citations": "44\n", "authors": ["989"]}
{"title": "Deep learning based feature envy detection\n", "abstract": " Software refactoring is widely employed to improve software quality. A key step in software refactoring is to identify which part of the software should be refactored. To facilitate the identification, a number of approaches have been proposed to identify certain structures in the code (called code smells) that suggest the possibility of refactoring. Most of such approaches rely on manually designed heuristics to map manually selected source code metrics to predictions. However, it is challenging to manually select the best features, especially textual features. It is also difficult to manually construct the optimal heuristics. To this end, in this paper we propose a deep learning based novel approach to detecting feature envy, one of the most common code smells. The key insight is that deep neural networks and advanced deep learning techniques could automatically select features (especially textual features) of source code\u00a0\u2026", "num_citations": "43\n", "authors": ["989"]}
{"title": "Emotion based automated priority prediction for bug reports\n", "abstract": " Issue tracking systems allow users to report bugs. Bug reports often contain product name, product component, description, and severity. Based on such information, triagers often manually prioritize the bug reports for investigation. However, manual prioritization is time consuming and cumbersome. DRONE is an automated state-of-the-art approach that recommends the priority level information of the bug reports. However, its performance for all levels of priorities is not uniform and may be improved. To this end, in this paper, we propose an emotion-based automatic approach to predict the priority for a report. First, we exploit natural language processing techniques to preprocess the bug report. Second, we identify the emotion-words that are involved in the description of the bug report and assign it an emotion value. Third, we create a feature vector for the bug report and predict its priority with a machine learning\u00a0\u2026", "num_citations": "43\n", "authors": ["989"]}
{"title": "\u5143\u5efa\u6a21\u6280\u672f\u7814\u7a76\u8fdb\u5c55\n", "abstract": " \u968f\u7740 UML (unified modeling language) \u4e0e MDA (model driven architecture) \u7684\u5174\u8d77\u548c\u6d41\u884c, \u6a21\u578b\u5df2\u7ecf\u6210\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u7684\u6838\u5fc3\u5236\u54c1, \u800c\u6a21\u578b\u91cd\u8981\u6027\u7684\u63d0\u5347\u4f7f\u5f97\u5efa\u6a21\u8bed\u8a00\u4ee5\u53ca\u5b9a\u4e49\u5efa\u6a21\u8bed\u8a00\u7684\u5143\u6a21\u578b\u9010\u6e10\u6210\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u4e00\u4e2a\u6838\u5fc3\u8981\u7d20. \u8f6f\u4ef6\u5f00\u53d1\u5f80\u5f80\u6d89\u53ca\u591a\u4e2a\u9886\u57df, \u800c\u4e0d\u540c\u7684\u9886\u57df\u5f80\u5f80\u9700\u8981\u4e0d\u540c\u7684\u5efa\u6a21\u8bed\u8a00\u53ca\u5176\u5efa\u6a21\u5de5\u5177. \u4f46\u662f, \u624b\u5de5\u5730\u4e3a\u4e0d\u540c\u7684\u5efa", "num_citations": "43\n", "authors": ["989"]}
{"title": "Preparation and characterization of LaFe1\u2212 xMgxO3/Al2O3/FeCrAl: Catalytic properties in methane combustion\n", "abstract": " A series of the LaFe1\u2212xMgxO3/Al2O3/FeCrAl catalysts (x\u00a0=\u00a00\u20131) were prepared. The structure of the catalysts was characterized using X-ray powder diffraction (XRD), scanning electron microscope (SEM) and temperature-programmed reduction (TPR). The catalytic activity of the catalysts for the methane combustion was evaluated. The catalytic stability of the catalysts for 100\u00a0h was tested with a fixed bed reactor. The results indicated that in the LaFe1\u2212xMgxO3/Al2O3/FeCrAl catalysts the phase structure were the LaFe1\u2212xMgxO3 perovskite-type oxides, \u03b1-Al2O3 and \u03b3-Al2O3. The surface particle shape and size were more different with the variety of the molar ratio of Fe to Mg in the LaFe1\u2212xMgxO3. The Fe component of the LaFe1\u2212xMgxO3/Al2O3/FeCrAl catalysts played an important role to the catalytic activity for the methane combustion and the order of the catalytic activity in terms of x was 0.5\u00a0>\u00a00.3\u00a0>\u00a00.7\u00a0>\u00a00.9\u00a0>\u00a00\u00a0>\u00a0\u2026", "num_citations": "42\n", "authors": ["989"]}
{"title": "Conflict-aware schedule of software refactorings\n", "abstract": " Software refactoring is to restructure the internal structure of object-oriented software to improve software quality, especially maintainability, extensibility and reusability while preserving its external behaviours. According to predefined refactoring rules, we may find many places in the software where refactorings can be applied. Applying each refactoring, we may achieve some effect (quality improvement). If we can apply all of the available refactorings, we can achieve the greatest effect. However, the conflicts among refactorings usually make it impossible. The application of a refactoring may change or delete elements necessary for other refactorings, and thus disables these refactorings. As a result, the application order (schedule) of the available refactorings determines which refactorings will be applied, and thus determines the total effect achieved by the refactoring activity. Consequently, conflicting refactorings\u00a0\u2026", "num_citations": "36\n", "authors": ["989"]}
{"title": "Simulation of heat transfer and hydrodynamics for metal structured packed bed\n", "abstract": " Modeling and simulation based on computational hydrodynamics and heat transfer for metal structured packed bed are carried out to predict the flow field and temperature field, and to evaluate its performance in transport aspect. The comparison between the simulation results for the metal structured packed bed and the experimental heat transfer performance as well as pressure drop of the conventional pellet packed bed is made, which quantitatively validates that transport performance of the metal structured packed bed is much better. Furthermore, the effects of geometric parameters and the property of solid phase on heat transfer of the metal structured packed bed are discussed. It is found that at low Re, the specific surface area is a key factor to determine the heat transfer capability of the structured bed. However, when Re turns to be high, the property of solid phase and voidage of the structured packed bed\u00a0\u2026", "num_citations": "30\n", "authors": ["989"]}
{"title": "Catalytic combustion of methane over Ce1\u2212 xLaxO2\u2212 x/2/Al2O3/FeCrAl catalysts\n", "abstract": " A series of the Ce1\u2212xLaxO2\u2212x/2/Al2O3/FeCrAl monolithic catalysts (x\u00a0=\u00a00\u20131) were prepared. The structure of the catalysts was characterized by X-ray powder diffraction (XRD), scanning electron microscope (SEM) and temperature-programmed reduction (TPR). The catalytic activity of the catalysts for the methane combustion was evaluated with a fixed bed reactor. The results showed that in the Ce1\u2212xLaxO2\u2212x/2/Al2O3/FeCrAl catalysts the phase structure was the Ce1\u2212xLaxO2\u2212x/2 solid solutions, \u03b1-Al2O3 and \u03b3-Al2O3. The molar ratio of Ce to La in the Ce1\u2212xLaxO2\u2212x/2 solid solutions significantly influenced the surface particle shape and size of the catalysts. The catalytic activity for the methane combustion strongly depended on the La component of the Ce1\u2212xLaxO2\u2212x/2/Al2O3/FeCrAl catalysts, and the order of the catalytic activity in terms of x was 0.7\u00a0>\u00a00.9\u00a0>\u00a00.5\u00a0>\u00a00.3\u00a0>\u00a00\u00a0>\u00a01. TPR analyses of the catalysts\u00a0\u2026", "num_citations": "28\n", "authors": ["989"]}
{"title": "Enhancing automated requirements traceability by resolving polysemy\n", "abstract": " Requirements traceability provides critical support throughout all phases of software engineering. Automated tracing based on information retrieval (IR) reduces the effort required to perform a manual trace. Unfortunately, IR-based trace recovery suffers from low precision due to polysemy, which refers to the coexistence of multiple meanings for a term appearing in different requirements. Latent semantic indexing (LSI) has been introduced as a method to tackle polysemy, as well as synonymy. However, little is known about the scope and significance of polysemous terms in requirements tracing. While quantifying the effect, we present a novel method based on artificial neural networks (ANN) to enhance the capability of automatically resolving polysemous terms. The core idea is to build an ANN model which leverages a term's highest-scoring coreferences in different requirements to learn whether this term has the\u00a0\u2026", "num_citations": "27\n", "authors": ["989"]}
{"title": "Dynamic and Automatic Feedback-Based Threshold Adaptation for Code Smell Detection\n", "abstract": " Most code smell detection tools expose thresholds to engineers for customization because code smell detection is essentially subjective and application specific. Another reason why engineers should customize these thresholds is that they have different working schedules and different requirements on software quality. They have their own unique need on precision and recall in smell detection. This unique need should be fulfilled by adjusting thresholds of smell detection tools. However, it is difficult for software engineers, especially inexperienced ones, to adjust often contradicting and related thresholds manually. One of the possible reasons is that engineers do not know the exact quantitative relation between threshold values and performance, e.g., precision. In this paper, we propose an approach to adapting thresholds automatically and dynamically. Engineers set a target precision manually according to their\u00a0\u2026", "num_citations": "27\n", "authors": ["989"]}
{"title": "Ce1\u2212 xCuxO2\u2212 x/Al2O3/FeCrAl catalysts for catalytic combustion of methane\n", "abstract": " A series of the Ce1\u2212xCuxO2\u2212x/Al2O3/FeCrAl catalysts (x\u00a0=\u00a00\u20131) were prepared. The structure of the catalysts was characterized using XRD, SEM and H2-TPR. The catalytic activity of the catalysts for the combustion of methane was evaluated. The results indicated that in the Ce1\u2212xCuxO2\u2212x/Al2O3/FeCrAl catalysts the surface phase structure were the Ce1\u2212xCuxO2\u2212x solid solution, \u03b1-Al2O3 and \u03b3-Al2O3. The surface particle shape and size were different with the variety of the molar ratio of Ce to Cu in the Ce1\u2212xCuxO2\u2212x solid solution. The Cu component of the Ce1\u2212xCuxO2\u2212x/Al2O3/FeCrAl catalysts played an important role to the catalytic activity for the methane combustion. There were the stronger interaction among the Ce1\u2212xCuxO2\u2212x solid solution and the Al2O3 washcoats and the FeCrAl support.", "num_citations": "27\n", "authors": ["989"]}
{"title": "Identification of generalization refactoring opportunities\n", "abstract": " Generalization refactoring helps relate classes and share functions, including both interfaces and implementation, by inheritance. To apply generalization refactoring, developers should first identify potential generalization refactoring opportunities, i.e., software entities that might benefit from generalization refactoring. For non-trivial software systems, manual identification of these opportunities is challenging and time-consuming. However, to the best of our knowledge, no existing tools have been specifically designed for this task. As a result, people have to identify these opportunities manually or with the help of tools designed for other purposes, e.g., clone detectors. To this end, we propose a tool GenReferee (Generalization Referee) to identify potential refactoring opportunities according to conceptual relationship, implementation similarity, structural correspondence, and inheritance hierarchies. It was first\u00a0\u2026", "num_citations": "25\n", "authors": ["989"]}
{"title": "Machine learning based recommendation of method names: how far are we\n", "abstract": " High quality method names are critical for the readability and maintainability of programs. However, constructing concise and consistent method names is often challenging, especially for inexperienced developers. To this end, advanced machine learning techniques have been recently leveraged to recommend method names automatically for given method bodies/implementation. Recent large-scale evaluations also suggest that such approaches are accurate. However, little is known about where and why such approaches work or don't work. To figure out the state of the art as well as the rationale for the success/failure, in this paper we conduct an empirical study on the state-of-the-art approach code2vec. We assess code2vec on a new dataset with more realistic settings. Our evaluation results suggest that although switching to new dataset does not significantly influence the performance, more realistic settings\u00a0\u2026", "num_citations": "24\n", "authors": ["989"]}
{"title": "CNN-based automatic prioritization of bug reports\n", "abstract": " Software systems often receive a large number of bug reports. Triagers read through such reports and assign different priorities to different reports so that important and urgent bugs could be fixed on time. However, manual prioritization is tedious and time-consuming. To this end, in this article, we propose a convolutional neural network (CNN) based automatic approach to predict the multiclass priority for bug reports. First, we apply natural language processing (NLP) techniques to preprocess textual information of bug reports and covert the textual information into vectors based on the syntactic and semantic relationship of words within each bug report. Second, we perform the software engineering domain specific emotion analysis on bug reports and compute the emotion value for each of them using a software engineering domain repository. Finally, we train a CNN-based classifier that generates a suggested\u00a0\u2026", "num_citations": "22\n", "authors": ["989"]}
{"title": "Identifying Renaming Opportunities by Expanding Conducted Rename Refactorings\n", "abstract": " To facilitate software refactoring, a number of approaches and tools have been proposed to suggest where refactorings should be conducted. However, identification of such refactoring opportunities is usually difficult because it often involves difficult semantic analysis and it is often influenced by many factors besides source code. For example, whether a software entity should be renamed depends on the meaning of its original name (natural language understanding), the semantics of the entity (source code semantics), experience and preference of developers, and culture of companies. As a result, it is difficult to identify renaming opportunities. To this end, in this paper we propose an approach to identify renaming opportunities by expanding conducted renamings. Once a rename refactoring is conducted manually or with tool support, the proposed approach recommends to rename closely related software entities\u00a0\u2026", "num_citations": "22\n", "authors": ["989"]}
{"title": "Tagging in assisted tracing\n", "abstract": " Assisted tracing is the process where human analyst vets and makes decisions concerning the automated method's output. Current research reveals human fallibility in this process, and shows that analyst often makes incorrect decisions that lead to inaccurate final trace matrix. To help enhance analyst performance, we leverage tagging in assisted tracing. Specifically, we implement tagging as a front-end feature that allows analysts to freely mark what they feel worth externalizing during tracing. We then carry out an experiment to investigate the tagging practices of 28 student analysts in vetting requirements-to-source-code trace matrices. Our study shows that tagging is readily adopted by analysts, tags produced in tracing follow power laws, and tags greatly enhance the precision of analyst-submitted final trace matrices. Our work opens up new avenues for researching improved ways to foster analyst-tool integration.", "num_citations": "20\n", "authors": ["989"]}
{"title": "Automatic approval prediction for software enhancement requests\n", "abstract": " Software applications often receive a large number of enhancement requests that suggest developers to fulfill additional functions. Such requests are usually checked manually by the developers, which is time consuming and tedious. Consequently, an approach that can automatically predict whether a new enhancement report will be approved is beneficial for both the developers and enhancement suggesters. With the approach, according to their available time, the developers can rank the reports and thus limit the number of reports to evaluate from large collection of low quality enhancement requests that are unlikely to be approved. The approach can help developers respond to the useful requests more quickly. To this end, we propose a multinomial naive Bayes based approach to automatically predict whether a new enhancement report is likely to be approved or rejected. We acquire the enhancement\u00a0\u2026", "num_citations": "18\n", "authors": ["989"]}
{"title": "\u6a21\u578b\u8f6c\u6362\u4e2d\u7279\u6027\u4fdd\u6301\u7684\u63cf\u8ff0\u4e0e\u9a8c\u8bc1\n", "abstract": " \u6a21\u578b\u8f6c\u6362\u4e3b\u8981\u7528\u4e8e\u6a21\u578b\u7684\u6f14\u5316, \u6c42\u7cbe\u4ee5\u53ca\u91cd\u6784. \u6a21\u578b\u8f6c\u6362\u9700\u8981\u9075\u5faa\u4e00\u5b9a\u7684\u7ea6\u675f\u89c4\u5219\u4ee5\u4fdd\u6301\u6a21\u578b\u7684\u67d0\u4e9b\u7279\u6027. \u6a21\u578b\u6f14\u5316\u901a\u5e38\u8981\u6c42\u4fdd\u6301\u5df2\u6709\u7684\u63a5\u53e3; \u6a21\u578b\u91cd\u6784\u5219\u5fc5\u987b\u4fdd\u8bc1\u91cd\u6784\u524d\u540e\u7684\u8f6f\u4ef6\u5177\u6709\u76f8\u540c\u7684\u5916\u90e8\u884c\u4e3a\u7279\u6027. \u4e3a\u4e86\u4e25\u683c\u8bc1\u660e\u67d0\u4e2a\u6a21\u578b\u8f6c\u6362\u89c4\u5219\u662f\u5426\u6ee1\u8db3\u8fd9\u4e9b\u7ea6\u675f, \u7279\u6027\u4fdd\u6301\u7ea6\u675f\u5fc5\u987b\u5f62\u5f0f\u5316\u5730\u52a0\u4ee5\u63cf\u8ff0. \u4e3a\u4e86\u5b9e\u73b0\u8bc1\u660e\u8fc7\u7a0b\u7684\u81ea\u52a8\u5316, \u9700\u8981\u603b\u7ed3\u901a\u7528\u7684\u8bc1\u660e\u8fc7\u7a0b\u5e76\u7ed9\u51fa\u5b9e\u73b0\u7b97\u6cd5. \u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u56fe\u8f6c\u6362\u7684\u7279\u6027\u4fdd\u6301\u7ea6\u675f\u63cf\u8ff0\u673a\u5236, \u5c06\u6a21\u578b\u6f14\u5316\u4e0e\u91cd\u6784\u4e2d\u7684\u8f6c\u6362\u89c4\u5219\u4ee5\u53ca\u7279\u6027\u4fdd\u6301\u7ea6\u675f\u90fd\u63cf\u8ff0\u4e3a\u56fe\u8f6c\u6362\u89c4\u5219. \u501f\u52a9\u56fe\u8f6c\u6362\u7684\u51b2\u7a81\u68c0\u6d4b\u673a\u5236, \u7ed9\u51fa\u4e86\u4e25\u683c\u8bc1\u660e\u8f6c\u6362\u89c4\u5219\u662f\u5426\u6ee1\u8db3\u7279\u6027", "num_citations": "18\n", "authors": ["989"]}
{"title": "An initial study on refactoring tactics\n", "abstract": " Software refactoring might be done in two different tactics. The first one is XP-style small-step refactoring, also called floss refactoring. The other tactic, called root canal refactoring, is to set aside an extended period specially for refactoring. Floss refactoring, as one of the corner stones of XP, is well acknowledged. In contrast, root canal refactoring is doubted, especially by XP advocators. Despite the doubts, however, no large scale empirical study on refactoring tactics has been reported. In contrast to the doubts, cases of root canal refactoring have been reported from industry, e.g., Microsoft. Researchers from academe have also proposed various approaches to facilitating root canal refactoring. To this end, this paper would investigate the following questions. (1)How often are the two different tactics employed, respectively? (2) Is there any correlation between refactoring tactics and categories of refactorings? In\u00a0\u2026", "num_citations": "15\n", "authors": ["989"]}
{"title": "Preparation of Pd\u2010Based Metal Monolithic Catalysts and a Study of Their Performance in the Catalytic Combustion of Methane\n", "abstract": " A series of Pd/SBA\u201015/Al2O3/FeCrAl and Pd/5\u2005wt\u2009% Ce1\u2212xZrxO2/SBA\u201015/Al2O3/FeCrAl (x=0\u20131) metal monolithic catalysts were prepared and characterized by various techniques. The catalytic activity and the stability of the catalysts for methane combustion were evaluated. All the catalysts retain the SBA\u201015 mesoporous structure, with PdO being confined in its channels. The results show that the addition of Ce1\u2212xZrxO2 as promoters can improve the activity and stability of the catalysts. The stabilities of the metal monolithic catalysts are much better than those of Pd/SBA\u201015 particle catalysts. The catalyst with ZrO2 as promoter exhibits the best activity and stability (T90=395\u2009\u00b0C), and the conversion of methane remains constant during the 700\u2005h test.", "num_citations": "15\n", "authors": ["989"]}
{"title": "Recommending refactoring solutions based on traceability and code metrics\n", "abstract": " Software refactoring has been extensively used to rectify the design flaws and improve software quality without affecting its observable behaviors. For a given code smell, it is common that there exist multiple refactoring solutions. However, it is challenging for developers to select the best one from such potential solutions. Consequently, a number of approaches have been proposed to facilitate the selection. Such approaches compare and select among alternative refactoring solutions based on their impact on metrics of source code. However, their impact on the traceability between source code and requirements is ignored although the importance of such traceability has been well recognized. To this end, we select among alternative refactoring solutions according to how they improve the traceability as well as source code design. To quantify the quality of traceability and source code design we leverage the use of\u00a0\u2026", "num_citations": "13\n", "authors": ["989"]}
{"title": "Scheduling of conflicting refactorings to promote quality improvement\n", "abstract": " Software refactoring is to restructure object-oriented software to improve its quality, especially extensibility, reusability and maintainability while preserving its external behaviors. For a special software system, there are usually quite a few refactorings available at the same time. But these refactorings may conflict with each other. In other words, carrying out a refactoring may disable other refactorings. Consequently, only a subset of the available refactorings can be applied together, and which refactorings will be applied depends on the schedule (application order) of the refactorings. Furthermore, carrying out different subsets of the refactorings usually leads to different improvement of software quality. As a result, in order to promote the improvement of software quality, refactorings should be scheduled rationally. However, how to schedule refactorings is rarely discussed. Usually, software engineers carry out\u00a0\u2026", "num_citations": "13\n", "authors": ["989"]}
{"title": "Sentiment based approval prediction for enhancement reports\n", "abstract": " The maintenance and evolution of the software application is a continuous phase in the industry. Users are frequently proposing enhancement requests for further functionalities. However, although only a small part of these requests are finally adopted, developers have to go through all of such requests manually, which is tedious and time consuming. To this end, in this paper we propose a sentiment based approach to predict how likely enhancement reports would be approved or rejected so that developers can first handle likely-to-be-approved requests. This could help the software applications to compete in the industry by upgrading their features in time as per user\u2019s requirements. First, we preprocess enhancement reports using natural language preprocessing techniques. Second, we identify the words having positive and negative sentiments in the summary attribute of the enhancements reports and calculate\u00a0\u2026", "num_citations": "11\n", "authors": ["989"]}
{"title": "Domino Effect: Move More Methods Once A Method Is Moved\n", "abstract": " Software refactoring is a popular technology to improve the design of existing source code, and thus it is widely used to facilitate software evolution. Moving methods is one of the most popular refactorings. It helps to reduce coupling between classes and to improve cohesion of involved classes. However, it is difficult to manually identify such methods that should be moved. Consequently, a number of approaches and tools have been proposed to identify such methods based on source code metrics, change history, and textual information. In this paper we propose a new way to identify methods that should be moved. Whenever a method is moved, the approach checks other methods within the same class, and suggests to move the one with the greatest similarity and strongest relationship with the moved method. The rational is that similar and closely related methods should be moved together. The approach has\u00a0\u2026", "num_citations": "10\n", "authors": ["989"]}
{"title": "Automated recommendation of software refactorings based on feature requests\n", "abstract": " During software evolution, developers often receive new requirements expressed as feature requests. To implement the requested features, developers have to perform necessary modifications (refactorings) to prepare for new adaptation that accommodates the new requirements. Software refactoring is a well-known technique that has been extensively used to improve software quality such as maintainability and extensibility. However, it is often challenging to determine which kind of refactorings should be applied. Consequently, several approaches based on various heuristics have been proposed to recommend refactorings. However, there is still lack of automated support to recommend refactorings given a feature request. To this end, in this paper, we propose a novel approach that recommends refactorings based on the history of the previously requested features and applied refactorings. First, we exploit the\u00a0\u2026", "num_citations": "9\n", "authors": ["989"]}
{"title": "Major motivations for extract method refactorings: analysis based on interviews and change histories\n", "abstract": " Extract method is one of the most popular software refactorings. However, little work has been done to investigate or validate the major motivations for such refactorings. Digging into this issue might help researchers to improve tool support for extract method refactorings, e.g., proposing better tools to recommend refactoring opportunities, and to select fragments to be extracted. To this end, we conducted an interview with 25 developers, and our results suggest that current reuse, decomposition of long methods, clone resolution, and future reuse are the major motivations for extract method refactorings.We also validated the results by analyzing the refactoring history of seven open-source applications. Analysis results suggest that current reuse was the primary motivation for 56% of extract method refactorings, decomposition of methods was the primary motivation for 28% of extract method refactorings, and\u00a0\u2026", "num_citations": "8\n", "authors": ["989"]}
{"title": "Analyzing Refactorings' Impact on Regression Test Cases\n", "abstract": " Software refactoring is to improve readability, maintainability and expansibility of software by adjusting its internal structure, whereas the external behaviors of software are not changed. Although software refactoring should not change the external behaviors of software systems, they might make a regression test case obsolete (with syntax and runtime errors) or fail. People have investigated which refactorings had an influence on regression test case. However, how test cases are influenced by refactorings and what kind of errors might be introduced remain unknown. To this end, in this paper, we proposed an approach to analyze refactorings' impact on regression test cases. On one hand, we analyzed why regression test cases failed. On the other hand, we analyzed the influence of refactorings on software interfaces. Based on the analysis, we built up a mapping between refactorings and test case failure. Such a\u00a0\u2026", "num_citations": "8\n", "authors": ["989"]}
{"title": "Catalytic Combustion of Methane over Co1\u2212 xMgxO/Al2O3/FeCrAl Monolithic Catalysts\n", "abstract": " A series of Co1\u2212xMgxO/Al2O3/FeCrAl catalysts (x=0\u22121) were prepared. The structures of the catalysts were characterized using XRD, SEM, and TPR analyses. The catalytic activity of the catalysts for methane combustion was evaluated in a continuous flow microreactor. The results indicated that the active washcoats adhered well on the FeCrAl foils. The phases in the catalysts were Co1\u2212xMgxO solid solutions, \u03b1-Al2O3, and \u03b3-Al2O3. The surface particle size of the catalysts varied with variations in the molar ratios of Co to Mg. The Co component of the Co1\u2212xMgxO/Al2O3/FeCrAl catalysts played an important role in the catalytic activity for methane combustion. In the Co1\u2212xMgxO/Al2O3/FeCrAl (x=0.2\u22120.8), the catalytic activity in terms of x was in the order of 0.5>0.2>0.8 under the experimental conditions. The presence of Mg in these catalysts could promote the thermal stability to a large extent. There were strong\u00a0\u2026", "num_citations": "7\n", "authors": ["989"]}
{"title": "Catalytic combustion of methane over Ce~ 1~-~ xCu~ xO~ 2~-~ x/Al~ 2O~ 3 solid solution catalyst\n", "abstract": " In this study, Ce_ 1-xCu_xO_ 2-x/Al_2O_3 (x= 0\u20141) solid solution catalysts and Ce_ 0.2 Cu_ 0.8 O_ 1.2/Al_2O_3 catalysts with different Ce_ 0.2 Cu_ 0.8 O_ 1.2 loading were prepared with the co-impregnation method. The catalysts were characterized by means of X-ray diffraction (XRD) and temperature-programmed reduction (TPR). It was found that some of the Ce_ 1-xCu_ xO_ 2-x/Al_2O_3 catalysts exhibited high activity for catalytic combustion of methane because of the formation of the solid solution which promoted the dispersion of Cu, and changed redox property of the catalyst. There existed synergetic effect between CeO_2 and CuO and the mole ratio of Ce to Cu influenced the activity of the catalyst.[Fund]: \u56fd\u5bb6\u81ea\u7136\u79d1\u5b66\u57fa\u91d1\u91cd\u70b9\u57fa\u91d1 (20136010);; \u56fd\u5bb6\u81ea\u7136\u79d1\u5b66\u57fa\u91d1 (20376005);; \u9ad8\u7b49\u5b66\u6821\u535a\u58eb\u5b66\u79d1\u70b9\u4e13\u9879\u79d1\u7814\u57fa\u91d1 (20030010002);; \u4e2d\u56fd\u77f3\u5316\u96c6\u56e2\u516c\u53f8\u57fa\u91d1 (X502019);; \u5317\u4eac\u5316\u5de5\u5927\u5b66\u9752\u5e74\u6559\u5e08\u79d1\u7814\u57fa\u91d1 (QN0301) \u8d44\u52a9\u9879\u76ee.~~", "num_citations": "7\n", "authors": ["989"]}
{"title": "Feature requests-based recommendation of software refactorings\n", "abstract": " Software requirements are ever-changing which often leads to software evolution. Consequently, throughout software lifetime, developers receive new requirements often expressed as feature requests. To implement the requested features, developers sometimes apply refactorings to make their systems adapt to the new requirements. However, deciding what refactorings to apply is often challenging and there is still lack of automated support to recommend refactorings given a feature request. To this end, we propose a learning-based approach that recommends refactorings based on the history of the previously requested features, applied refactorings, and code smells information. First, the state-of-the-art refactoring detection tools are leveraged to identify the previous refactorings applied to implement the past feature requests. Second, a machine classifier is trained with the history data of the feature requests\u00a0\u2026", "num_citations": "6\n", "authors": ["989"]}
{"title": "Deep Learning Based Identification of Suspicious Return Statements\n", "abstract": " Identifiers in source code are composed of terms in natural languages. Such terms, as well as phrases composed of such terms, convey rich semantics that could be exploited for program analysis and comprehension. To this end, in this paper we propose a deep learning based approach, called MLDetector, to identifying suspicious return statements by leveraging semantics conveyed by the natural language phrases that are used as identifiers in the source code. We specially design a deep neural network to tell whether a given return statement matches its corresponding method signature. The rationale is that both method signature and return value should explicitly specify the output of the method, and thus a significant mismatch between method signature and return value may suggest a suspicious return statement. To address the challenge of lacking negative training data, i.e., incorrect return statements, we\u00a0\u2026", "num_citations": "6\n", "authors": ["989"]}
{"title": "Refactoring formal specifications in object-Z\n", "abstract": " Software refactoring is to restructure artifacts to improve software quality, especially readability, extensibility, and maintainability, while preserving its external behaviors. Software refactoring has been successfully applied to source code and design models. However, refactoring has not yet been introduced to formal specifications. Compared to source code in programming languages similar to nature languages, formal specifications in formal mathematic languages are in urgent need of refactoring because mathematic languages are usually more difficult to understand or modify. Furthermore, formal specifications' inherent formality makes it easier to validate behavior preservation of refactorings, which dramatically increases the dependability of refactorings. This paper illustrates the necessity and possibility of refactoring formal specifications. It first illustrates the necessity with an motivating example, and then\u00a0\u2026", "num_citations": "6\n", "authors": ["989"]}
{"title": "An empirical study on competitive crowdsource software development: motivating and inhibiting factors\n", "abstract": " Crowdsourcing is gaining more and more popularity among the academic and industrial community. Organizations are adopting this technological advent and increasingly crowdsourcing their tasks to the unknown individuals. However, in the context of competitive crowdsourcing software development (CCSD), crowdsourcing is still unexplored. Too little is presently known about what intricate developers to participate in crowdsourcing software development competitions. Most importantly, what kind of developers are more likely to participate? Such open questions remain to be explored. To this end, in this paper, we present the results of an empirical study conducted to investigate what motivates software developers to participate in CCSD and what inhibits software developers to participate in such competitions. An online questionnaire is sent out to more than 300 crowdsource software participants, of which 113\u00a0\u2026", "num_citations": "5\n", "authors": ["989"]}
{"title": "Case study on software refactoring tactics\n", "abstract": " Refactorings might be done using two different tactics: root canal refactoring and floss refactoring. Root canal refactoring is to set aside an extended period specially for refactoring. Floss refactoring is to interleave refactorings with other programming tasks. However, no large-scale case study on refactoring tactics is available. To this end, the authors carry out a case study to investigate the following research questions. (i) How often are root canal refactoring and floss refactoring employed, respectively? (ii) Are some kinds of refactorings more likely than others to be applied as floss refactorings or root canal refactorings? (iii) Do engineers employing both tactics have obvious bias to or against either of the tactics? They analyse the usage data information collected by Eclipse usage data collector. Results suggest that about 14% of refactorings are root canal refactorings. These findings reconfirm the hypothesis that, in\u00a0\u2026", "num_citations": "5\n", "authors": ["989"]}
{"title": "\u4ee3\u7801\u574f\u5473\u7684\u5904\u7406\u987a\u5e8f\n", "abstract": " \u9009\u53d6\u4e86 10 \u79cd\u5177\u6709\u4ee3\u8868\u6027\u7684\u4ee3\u7801\u574f\u5473\u8fdb\u884c\u7814\u7a76. \u4ece\u6bcf\u79cd\u4ee3\u7801\u574f\u5473\u7684\u4ea7\u751f\u539f\u56e0, \u75c7\u72b6, \u5bf9\u8f6f\u4ef6\u7684\u5f71\u54cd\u4ee5\u53ca\u76f8\u5e94\u7684\u5904\u7406\u8fd9 4 \u4e2a\u65b9\u9762\u8fdb\u884c\u5206\u6790, \u63d0\u51fa\u4e86\u4e00\u4e2a\u4ee3\u7801\u574f\u5473\u5904\u7406\u987a\u5e8f\u7684\u4f18\u5148\u7ea7. \u901a\u8fc7\u95ee\u5377\u8c03\u67e5\u548c\u4e24\u4e2a\u5b9e\u9a8c, \u5bf9\u4ee3\u7801\u574f\u5473\u5904\u7406\u987a\u5e8f\u4f18\u5148\u7ea7\u8fdb\u884c\u4e86\u521d\u6b65\u9a8c\u8bc1.", "num_citations": "5\n", "authors": ["989"]}
{"title": "\u4e00\u79cd\u57fa\u4e8e\u56fe\u8f6c\u6362\u7684\u6a21\u578b\u91cd\u6784\u63cf\u8ff0\u8bed\u8a00\n", "abstract": " \u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u56fe\u8f6c\u6362\u7684\u6a21\u578b\u91cd\u6784\u63cf\u8ff0\u8bed\u8a00. \u9488\u5bf9\u6a21\u578b\u91cd\u6784\u7684\u7279\u5f81, \u8bbe\u8ba1\u4e86\u6a21\u578b\u91cd\u6784\u63cf\u8ff0\u8bed\u8a00\u7684\u57fa\u672c\u5143\u7d20, \u5e76\u7ed9\u51fa\u4e86\u5982\u4f55\u901a\u8fc7\u8fd9\u4e9b\u57fa\u672c\u5143\u7d20\u63cf\u8ff0\u6a21\u578b\u91cd\u6784\u53ca\u91cd\u6784\u89c4\u5219\u7684\u65b9\u6cd5. \u5728\u6b64\u57fa\u7840\u4e0a, \u7ed9\u51fa\u4e86\u6839\u636e\u5f62\u5f0f\u5316\u91cd\u6784\u89c4\u5219\u6267\u884c\u6a21\u578b\u91cd\u6784\u7684\u5177\u4f53\u6b65\u9aa4\u548c\u7b56\u7565, \u5e76\u63d0\u4f9b\u4e86\u8f83\u4e3a\u5b8c\u6574\u7684\u6a21\u578b\u91cd\u6784 CASE \u652f\u6491\u5de5\u5177. \u901a\u8fc7\u5b9e\u4f8b\u8ba8\u8bba\u4e86\u8be5\u6a21\u578b\u91cd\u6784\u63cf\u8ff0\u8bed\u8a00\u7684\u63cf\u8ff0\u80fd\u529b. \u7ed3\u679c\u8868\u660e, \u8be5\u8bed\u8a00\u5177\u6709\u8f83\u5f3a\u7684\u63cf\u8ff0\u80fd\u529b, \u80fd\u591f\u6bd4\u8f83\u7b80\u6d01\u5730\u63cf\u8ff0\u590d\u6742\u7684\u6a21\u578b\u91cd\u6784\u89c4\u5219.", "num_citations": "5\n", "authors": ["989"]}
{"title": "Test-Based Clone Detection: an Initial Try on Semantically Equivalent Methods\n", "abstract": " Most code clone detection approaches identify clones via static source code analysis. Such approaches are effective and efficient in detecting lexically similar clones. However, they are less effective in detecting semantic clones that are similar in functionality but different in implementation. As an initial try to detect semantic clones, in this paper, we propose a test-based approach to detecting methods that are semantically equivalent to API methods. For a given method m, we generate its test cases automatically and search for semantically equivalent API methods by running the generated test cases. If two methods generate the same output on each of the test cases, they are taken as semantically equivalent methods. One of the weakness of test-based clone detection is that it is often time consuming. To reduce the time complexity, we take the following measures. First, we focus on methods instead of arbitrary\u00a0\u2026", "num_citations": "4\n", "authors": ["989"]}
{"title": "Simulation of heat transfer and pressure drop of metal structured packed bed\n", "abstract": " Modeling and simulation based on computational fluid dynamics and heat transfer for the metal structured packed bed were carried out to predict the flow field and temperature field, and to evaluate its performance in heat transfer and hydrodynamics. The effects of geometric parameters and the properties of solid phase on heat transfer of the structured packed bed were discussed. It was found that at low Re and the same properties and voidage of the packed bed, the larger the specific surface area, the better the ability of heat transfer of the packed bed. Furthermore, the comparison between the simulation results of the metal structured packed bed and heat transfer performance and pressure drop of the pellet packed bed was made, which validated better transport performance of the metal structured packed bed.", "num_citations": "4\n", "authors": ["989"]}
{"title": "Automated classification of actions in bug reports of mobile apps\n", "abstract": " When users encounter problems with mobile apps, they may commit such problems to developers as bug reports. To facilitate the processing of bug reports, researchers proposed approaches to validate the reported issues automatically according to the steps to reproduce specified in bug reports. Although such approaches have achieved high success rate in reproducing the reported issues, they often rely on a predefined vocabulary to identify and classify actions in bug reports. However, such manually constructed vocabulary and classification have significant limitations. It is challenging for the vocabulary to cover all potential action words because users may describe the same action with different words. Besides that, classification of actions solely based on the action words could be inaccurate because the same action word, appearing in different contexts, may have different meaning and thus belongs to\u00a0\u2026", "num_citations": "3\n", "authors": ["989"]}
{"title": "A survey on renamings of software entities\n", "abstract": " More than 70% of characters in the source code are used to label identifiers. Consequently, identifiers are one of the most important source for program comprehension. Meaningful identifiers are crucial to understand and maintain programs. However, for reasons like constrained schedule, inexperience, and unplanned evolution, identifiers may fail to convey the semantics of the entities associated with them. As a result, such entities should be renamed to improve software quality. However, manual renaming and recommendation are fastidious, time consuming, and error prone, whereas automating the process of renamings is challenging: (1) It involves complex natural language processing to understand the meaning of identifers; (2) It also involves difficult semantic analysis to determine the role of software entities. Researchers proposed a number of approaches and tools to facilitate renamings. We present a\u00a0\u2026", "num_citations": "3\n", "authors": ["989"]}
{"title": "LSTM-based argument recommendation for non-API methods\n", "abstract": " Automatic code completion is one of the most useful features provided by advanced IDEs. Argument recommendation, as a special kind of code completion, is widely used as well. While existing approaches focus on argument recommendation for popular APIs, a large number of non-API invocations are requesting for accurate argument recommendation as well. To this end, we propose an LSTM-based approach to recommending non-API arguments instantly when method calls are typed in. With data collected from a large corpus of open-source applications, we train an LSTM neural network to recommend actual arguments based on identifiers of the invoked method, the corresponding formal parameter, and a list of syntactically correct candidate arguments. To feed these identifiers into the LSTM neural network, we convert them into fixed-length vectors by Paragraph Vector, an unsupervised neural network\u00a0\u2026", "num_citations": "2\n", "authors": ["989"]}
{"title": "How are design patterns concerned by developers?\n", "abstract": " In recent years, design pattern has become an accepted concept in software design and many studies have involved various aspects of design patterns. However, it is an open question that how design patterns are discussed by developers. In this study, we conduct an empirical study to answer this question by soliciting Stack Overflow. First we build a new open catalog with 425 design patterns. Then, we extract 187,493 design pattern relevant posts from Stack Overflow. As to these posts, we find that the popularity of design patterns follows a long tail distribution. More surprisingly, nearly half of the posts focus on only five design patterns. We also successfully detect many potential new co-occuring design patterns, which could well complement the deficiency of existing studies.", "num_citations": "2\n", "authors": ["989"]}
{"title": "Lexical similarity between argument and parameter names: An empirical study\n", "abstract": " Identifiers chosen by programmers convey rich semantic information that could be exploited to enhance program analysis for various software engineering tasks, e.g., anomaly detection, argument recommendation, and code completion. However, such information has not yet been fully exploited, and little is known about its properties. In this paper, we carry out an empirical study to investigate the lexical similarity between the actual argument and the formal parameter names in method invocations. By analyzing actual arguments and formal parameters from 127 Java applications and 30 open-source C applications, we observe a number of interesting and valuable findings concerning the distribution of similarity, reasons for dissimilarity, and so on. Such findings have been exploited to facilitate argument-related software engineering tasks, i.e., anomaly detection and code completion.", "num_citations": "2\n", "authors": ["989"]}
{"title": "Simulation of a novel monolith catalytic reactor for coupled endothermic and exothermic reactions\n", "abstract": " A metal monolith reactor with complicated structure, used in coupled methane steam reforming-combustion, was investigated by using a heterogeneous model based on the whole reactor in this work. Preliminary results showed that the application was considerably attractive, and the significant effects on the reactor performance of the operating parameters, such as inlet gas velocity ratio of reforming side and combustion side, inlet gas temperature and volumetric flux ratio of combustion side and reforming side were presented.", "num_citations": "2\n", "authors": ["989"]}
{"title": "Slicing Based Code Recommendation for Type Based Instance Retrieval\n", "abstract": " It is common for developers to retrieve an instance of a certain type from another instance of other types. However, it is quite often that developers do not exactly know how to retrieve the instance although they know exactly what they need (the instance to re retrieved, also known as the target instance) and where it could be retrieved (i.e., the source instance). Such kind of instance retrieval is popular and thus their implementations, in different forms, are often publicly available on the Internet. Consequently, a number of approaches have been proposed to retrieve such implementations (code snippets) and release developers from reinventing such snippets. However, the performance of such approaches deserves further improvement. To this end, in this paper, we propose a slicing based approach to recommending code snippets that could retrieve the target instance from the source instance. The\u00a0\u2026", "num_citations": "1\n", "authors": ["989"]}
{"title": "Dynamic Ranking of Refactoring Menu Items for Integrated Development Environment\n", "abstract": " Software refactoring is popular and thus most mainstream IDEs, e.g., Eclipse, provide a top level menu, especially for refactoring activities. The refactoring menu is designed to facilitate refactorings, and it has become one of the most commonly used menus. However, to support a large number of refactoring types, the refactoring menu contains a long list of menu items. As a result, it is tedious to select the intended menu item from the lengthy menu. To facilitate the menu selection, in this paper, we propose an approach to dynamic ranking of refactoring menu items for IDE. We put the most likely refactoring menu item on the top of the refactoring menu according to developers' source code selection and code smells associated with the selected source code. The ranking is dynamic because it changes frequently according to the context. First, we collect the refactoring history of the open source applications and detect\u00a0\u2026", "num_citations": "1\n", "authors": ["989"]}
{"title": "\u9006\u5411\u5de5\u7a0b\u4e2d\u7684\u5927\u7c7b\u56fe\u62c6\u5206\u65b9\u6cd5\n", "abstract": " \u63d0\u51fa\u4e86\u4e00\u79cd\u5927\u7c7b\u56fe\u62c6\u5206\u65b9\u6cd5. \u9996\u5148\u901a\u8fc7\u5ea6\u91cf\u5de5\u5177\u8ba1\u7b97\u7c7b\u56fe\u4e2d\u7c7b\u76ee (\u7c7b\u53ca\u63a5\u53e3) \u95f4\u7684\u8026\u5408\u5ea6. \u6839\u636e\u9762\u5411\u5bf9\u8c61\u8bbe\u8ba1\u4e2d\u9ad8\u5185\u805a\u4f4e\u8026\u5408\u7684\u8bbe\u8ba1\u539f\u5219, \u5c06\u7d27\u8026\u5408\u7684\u7c7b\u76ee\u5212\u5165\u540c\u4e00\u4e2a\u7c7b\u56fe, \u800c\u8026\u5408\u5ea6\u4f4e\u7684\u7c7b\u76ee\u95f4\u5b9e\u73b0\u5206\u79bb. \u4e3a\u4e86\u786e\u4fdd\u751f\u6210\u7684\u7c7b\u56fe\u5927\u5c0f\u5408\u9002, \u62c6\u5206\u65b9\u6cd5\u5bf9\u6bcf\u4e2a\u7c7b\u56fe\u7684\u5927\u5c0f\u8fdb\u884c\u9650\u5b9a, \u5c06\u6bcf\u4e2a\u7c7b\u56fe\u7684\u5927\u5c0f\u9650\u5b9a\u5728\u9884\u5148\u5b9a\u4e49\u7684\u5408\u7406\u533a\u95f4\u5185.", "num_citations": "1\n", "authors": ["989"]}
{"title": "Detecting Duplicate Event Flows in Use Case Models\n", "abstract": " In order to deal with the complexity of large systems, the divide-and-conquer policy is adopted in requirements engineering: collect requirements from different groups of stakeholders, and then compose them together as a complete requirements specification. However, the policy brings forward the problem of overlapping use cases: similar event flows appear in more than one use case. Duplicate event flows lower the readability and maintainability of use case diagrams. The problem has been recognized, but no detecting approach is available to find out duplicate event flows. The paper proposes a heuristic algorithm which is based on information retrieval technologies. Evaluation results suggest that the algorithm is efficient and effective.", "num_citations": "1\n", "authors": ["989"]}