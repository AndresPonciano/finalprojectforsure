{"title": "Model-Driven Engineering of Self-Adaptive Software with EUREMA\n", "abstract": " The development of self-adaptive software requires the engineering of an adaptation engine that controls the underlying adaptable software by feedback loops. The engine often describes the adaptation by runtime models representing the adaptable software and by activities such as analysis and planning that use these models. To systematically address the interplay between runtime models and adaptation activities, runtime megamodels have been proposed. A runtime megamodel is a specific model capturing runtime models and adaptation activities. In this article, we go one step further and present an executable modeling language for ExecUtable RuntimE MegAmodels (EUREMA) that eases the development of adaptation engines by following a model-driven engineering approach. We provide a domain-specific modeling language and a runtime interpreter for adaptation engines, in particular feedback loops\u00a0\u2026", "num_citations": "148\n", "authors": ["556"]}
{"title": "Adaptation and abstract runtime models\n", "abstract": " Runtime adaptability is often a crucial requirement for today's complex software systems. Several approaches use an architectural model as a runtime representation of a managed system for monitoring, reasoning and performing adaptation. To ease the causal connection between a system and a model, these models are often closely related to the implementation and at a rather low level of abstraction. This makes them as complex as the implementation and it impedes reusability and extensibility of autonomic managers. Moreover, the models often do not cover different concerns, like security or performance, and therefore they do not support several self-management capabilities at once.", "num_citations": "111\n", "authors": ["556"]}
{"title": "Software engineering meets control theory\n", "abstract": " The software engineering community has proposed numerous approaches for making software self-adaptive. These approaches take inspiration from machine learning and control theory, constructing software that monitors and modifies its own behavior to meet goals. Control theory, in particular, has received considerable attention as it represents a general methodology for creating adaptive systems. Control-theoretical software implementations, however, tend to be ad hoc. While such solutions often work in practice, it is difficult to understand and reason about the desired properties and behavior of the resulting adaptive software and its controller. This paper discusses a control design process for software systems which enables automatic analysis and synthesis of a controller that is guaranteed to have the desired properties and behavior. The paper documents the process and illustrates its use in an example\u00a0\u2026", "num_citations": "109\n", "authors": ["556"]}
{"title": "Incremental model synchronization for efficient run-time monitoring\n", "abstract": " The model-driven engineering community has developed expressive model transformation techniques based on metamodels, which ease the specification of translations between different model types. Thus, it is attractive to also apply these techniques for autonomic and self-adaptive systems at run-time to enable a comprehensive monitoring of their architectures while reducing development efforts. This requires special solutions for model transformation techniques as they are applied at run-time instead of their traditional usage at development time. In this paper we present an approach to ease the development of architectural monitoring based on incremental model synchronization with triple graph grammars. We show that the provided incremental synchronization between a running system and models for different self-management capabilities provides a significantly better compromise between\u00a0\u2026", "num_citations": "80\n", "authors": ["556"]}
{"title": "Control strategies for self-adaptive software systems\n", "abstract": " The pervasiveness and growing complexity of software systems are challenging software engineering to design systems that can adapt their behavior to withstand unpredictable, uncertain, and continuously changing execution environments. Control theoretical adaptation mechanisms have received growing interest from the software engineering community in the last few years for their mathematical grounding, allowing formal guarantees on the behavior of the controlled systems. However, most of these mechanisms are tailored to specific applications and can hardly be generalized into broadly applicable software design and development processes. This article discusses a reference control design process, from goal identification to the verification and validation of the controlled system. A taxonomy of the main control strategies is introduced, analyzing their applicability to software adaptation for both functional\u00a0\u2026", "num_citations": "66\n", "authors": ["556"]}
{"title": "The role of models and megamodels at runtime\n", "abstract": " In model-driven software development a multitude of interrelated models are used to systematically realize a software system. This results in a complex development process since the models and the relations between the models have to be managed. Similar problems appear when following a model-driven approach for managing software systems at runtime. A multitude of interrelated runtime models are employed simultaneously, and thus they have to be maintained at runtime. While for the development case megamodels have emerged to address the problem of managing models and relations, the problem is rather neglected for the case of runtime models by applying ad-hoc solutions.               Therefore, we propose to utilize megamodel concepts for the case of multiple runtime models. Based on the current state of research, we present a categorization of runtime models and conceivable relations\u00a0\u2026", "num_citations": "64\n", "authors": ["556"]}
{"title": "A language for feedback loops in self-adaptive systems: Executable runtime megamodels\n", "abstract": " The development of self-adaptive software requires the engineering of proper feedback loops where an adaptation logic controls the underlying software. The adaptation logic often describes the adaptation by using runtime models representing the underlying software and steps such as analysis and planning that operate on these runtime models. To systematically address this interplay, runtime megamodels, which are specific runtime models that have themselves runtime models as their elements and that also capture the relationships between multiple runtime models, have been proposed. In this paper, we go one step further and present a modeling language for runtime megamodels that considerably eases the development of the adaptation logic by providing a domain-specific modeling approach and a runtime interpreter for this part of a self-adaptive system. This supports development by modeling the\u00a0\u2026", "num_citations": "55\n", "authors": ["556"]}
{"title": "Model-driven architectural monitoring and adaptation for autonomic systems\n", "abstract": " Architectural monitoring and adaptation allows self-management capabilities of autonomic systems to realize more powerful adaptation steps, which observe and adjust not only parameters but also the software architecture. However, monitoring as well as adaptation of the architecture of a running system in addition to the parameters are considerably more complex and only rather limited and costly solutions are available today. In this paper we propose a model-driven approach to ease the development of architectural monitoring and adaptation for autonomic systems. Using meta models and model transformation techniques, we were able to realize an incremental synchronization between the run-time system and models for different self-management activities. The synchronization might be triggered when needed and therefore the activities can operate concurrently.", "num_citations": "55\n", "authors": ["556"]}
{"title": "A learning approach to enhance assurances for real-time self-adaptive systems\n", "abstract": " The assurance of real-time properties is prone to context variability. Providing such assurance at design time would require to check all the possible context and system variations or to predict which one will be actually used. Both cases are not viable in practice since there are too many possibilities to foresee. Moreover, the knowledge required to fully provide the assurance for self-adaptive systems is only available at runtime and therefore difficult to predict at early development stages. Despite all the efforts on assurances for self-adaptive systems at design or runtime, there is still a gap on verifying and validating real-time constraints accounting for context variability. To fill this gap, we propose a method to provide assurance of self-adaptive systems, at design-and runtime, with special focus on real-time constraints. We combine off-line requirements elicitation and model checking with on-line data collection and data\u00a0\u2026", "num_citations": "32\n", "authors": ["556"]}
{"title": "A model-driven configuration management system for advanced it service management\n", "abstract": " A popular guideline to manage today\u2019s complex and heterogeneous IT systems is the IT Infrastructure Library (ITIL), which provides a catalogue of best practices for IT Service Management (ITSM). However, state-of-the-art implementations of ITIL rely on a set of XML-based standards. To ease manageability and effectively exploit a Configuration Management System (CMS), which is the integral part of ITSM, we suggest in this paper a model-driven CMS by applying Model-Driven Engineering (MDE). Metamodel based models improve the manageability by providing a suitable abstraction, which enables direct user interaction as well as the application of MDE techniques such as model transformations. Furthermore, vital elements of a model-driven CMS are runtime models, which capture the managed system. In addition, this paper reports on a first prototype implementation of a model-driven CMS that exploits runtime models, their automatic maintenance, modelbased analysis on these runtime models, and automatic adaptation of the managed system by facilitating changes on runtime models.", "num_citations": "30\n", "authors": ["556"]}
{"title": "Efficient utility-driven self-healing employing adaptation rules for large dynamic architectures\n", "abstract": " Self-adaptation can be realized in various ways. Rule-based approaches prescribe the adaptation to be executed if the system or environment satisfy certain conditions and result in scalable solutions, however, with often only satisfying adaptation decisions. In contrast, utility-driven approaches determine optimal adaptation decisions by using an often costly optimization step, which typically does not scale well for larger problems. We propose a rule-based and utility-driven approach that achieves the beneficial properties of each of these directions such that the adaptation decisions are optimal while the computation remains scalable since an expensive optimization step can be avoided. The approach can be used for the architecture-based self-healing of large software systems. We define the utility for large dynamic architectures of such systems based on patterns capturing issues the self-healing must address and\u00a0\u2026", "num_citations": "27\n", "authors": ["556"]}
{"title": "Graph transformations for mde, adaptation, and models at runtime\n", "abstract": " Software evolution and the resulting need to continuously adapt the software is one of the main challenges for software engineering. The model-driven development movement therefore aims at improving the longevity of software by keeping the development artifacts more consistent and better changeable by employing models and to a certain degree automated model operations. Another trend are systems that tackle the challenge at runtime by being able to adapt their structure and behavior to be more flexible and operate in more dynamic environments (e.g., context-aware software, autonomic computing, self-adaptive software). Finally, models at runtime, where the benefits of model-driven development are employed at runtime to support adaptation capabilities, today lead towards a unification of both ideas.             In this paper, we present graph transformations and show that they can be employed to\u00a0\u2026", "num_citations": "24\n", "authors": ["556"]}
{"title": "mRUBiS: an exemplar for model-based architectural self-healing and self-optimization\n", "abstract": " Self-adaptive software systems are often structured into an adaptation engine that manages an adaptable software by operating on a runtime model that represents the architecture of the software (model-based architectural self-adaptation). Despite the popularity of such approaches, existing exemplars provide application programming interfaces but no runtime model to develop adaptation engines. Consequently, there does not exist any exemplar that supports developing, evaluating, and comparing model-based self-adaptation off the shelf. Therefore, we present mRUBiS, an extensible exemplar for model-based architectural self-healing and self-optimization. mRUBiS simulates the adaptable software and therefore provides and maintains an architectural runtime model of the software, which can be directly used by adaptation engines to realize and perform self-adaptation. Particularly, mRUBiS supports injecting\u00a0\u2026", "num_citations": "23\n", "authors": ["556"]}
{"title": "State of the art in architectures for self-aware computing systems\n", "abstract": " In this chapter, we review the state of the art in self-aware computing systems with a particular focus on software architectures. Therefore, we compare existing approaches targeting computing systems with similar characteristics as self-aware systems to the architectural concepts for single and collective self-aware systems discussed in the previous chapters. These approaches are particularly reference architectures and architectural frameworks and languages. Based on this comparison, we discuss open challenges for architectures of self-aware computing systems.", "num_citations": "21\n", "authors": ["556"]}
{"title": "A testing scheme for self-adaptive software systems with architectural runtime models\n", "abstract": " Self-adaptive software systems (SASS) are equipped with feedback loops to adapt autonomously to changes of the software or environment. In established fields, such as embedded software, sophisticated approaches have been developed to systematically study feedback loops early during the development. In order to cover the particularities of feedback, techniques like one-way and in-the-loop simulation and testing have been included. However, a related approach to systematically test SASS is currently lacking. In this paper we therefore propose a systematic testing scheme for SASS that allows engineers to test the feedback loops early in the development by exploiting architectural runtime models. These models that are available early in the development are commonly used by the activities of a feedback loop at runtime and they provide a suitable high-level abstraction to describe test inputs as well as\u00a0\u2026", "num_citations": "20\n", "authors": ["556"]}
{"title": "Model-driven engineering of adaptation engines for self-adaptive software: executable runtime megamodels\n", "abstract": " The development of self-adaptive software requires the engineering of an adaptation engine that controls and adapts the underlying adaptable software by means of feedback loops. The adaptation engine often describes the adaptation by using runtime models representing relevant aspects of the adaptable software and particular activities such as analysis and planning that operate on these runtime models. To systematically address the interplay between runtime models and adaptation activities in adaptation engines, runtime megamodels have been proposed for self-adaptive software. A runtime megamodel is a specific runtime model whose elements are runtime models and adaptation activities. Thus, a megamodel captures the interplay between multiple models and between models and activities as well as the activation of the activities. In this article, we go one step further and present a modeling language for ExecUtable RuntimE MegAmodels (EUREMA) that considerably eases the development of adaptation engines by following a model-driven engineering approach. We provide a domain-specific modeling language and a runtime interpreter for adaptation engines, in particular for feedback loops. Megamodels are kept explicit and alive at runtime and by interpreting them, they are directly executed to run feedback loops. Additionally, they can be dynamically adjusted to adapt feedback loops. Thus, EUREMA supports development by making feedback loops, their runtime models, and adaptation activities explicit at a higher level of abstraction. Moreover, it enables complex solutions where multiple feedback loops interact or even operate\u00a0\u2026", "num_citations": "17\n", "authors": ["556"]}
{"title": "Requirements and assessment of languages and frameworks for adaptation models\n", "abstract": " Approaches to self-adaptive software systems use models at runtime to leverage benefits of model-driven engineering (MDE) for providing views on running systems and for engineering feedback loops. Most of these approaches focus on causally connecting runtime models and running systems, and just apply typical MDE techniques, like model transformation, or well-known techniques, like event-condition-action rules, from other fields than MDE to realize a feedback loop. However, elaborating requirements for feedback loop activities for the specific case of runtime models is rather neglected.               Therefore, we investigate requirements for Adaptation Models that specify the analysis, decision-making, and planning of adaptation as part of a feedback loop. In particular, we consider requirements for a modeling language of adaptation models and for a framework as the execution environment of\u00a0\u2026", "num_citations": "17\n", "authors": ["556"]}
{"title": "Planning as Optimization: Dynamically Discovering Optimal Configurations for Runtime Situations\n", "abstract": " The large number of possible configurations of modern software-based systems, combined with the large number of possible environmental situations of such systems, prohibits enumerating all adaptation options at design time and necessitates planning at run time to dynamically identify an appropriate configuration for a situation. While numerous planning techniques exist, they typically assume a detailed state-based model of the system and that the situations that warrant adaptations are known. Both of these assumptions can be violated in complex, real-world systems. As a result, adaptation planning must rely on simple models that capture what can be changed (input parameters) and observed in the system and environment (output and context parameters). We therefore propose planning as optimization: the use of optimization strategies to discover optimal system configurations at runtime for each distinct\u00a0\u2026", "num_citations": "16\n", "authors": ["556"]}
{"title": "Architectural concepts for self-aware computing systems\n", "abstract": " Self-awareness in a computing system is achieved by implementing a model-based learning, reasoning, and acting loop (LRA-M loop). Similar to the feedback loops for self-adaptive software, we argue that the LRA-M loop should be addressed during the architectural design of self-aware computing systems. This allows engineers to explicitly decide and reason about the system\u2019s self-awareness capabilities. This chapter, therefore, introduces the relevant architectural concepts to address and make the LRA-M loop visible in the architectural design. Based on these concepts, we discuss how context-awareness, self-awareness, and meta-self-awareness become manifest in an architecture. Finally, we relate the presented architectural concepts to the definition and framework for self-aware computing systems introduced in the previous chapters.", "num_citations": "16\n", "authors": ["556"]}
{"title": "Toward Megamodels at Runtime.\n", "abstract": " In model-driven software development a multitude of development models that are related with each other are used to systematically realize a software system. This results in a complex development process since these models and the relations between these models have to be managed. Similar problems appear when following a model-driven approach for managing software systems at runtime. A multitude of runtime models that are related with each other are likely to be employed simultaneously, and thus they have to be maintained at runtime. While for the development case megamodels have emerged to address the problem of managing development models and relations, the problem is rather neglected for the case of runtime models by applying ad-hoc solutions. Therefore, we propose to utilize concepts of megamodels in the domain of runtime system management. Based on existing work in the research field of runtime models, we demonstrate that different kinds of runtime models and relations are already employed simultaneously in several approaches. Then, we show how megamodels help in structuring and maintaining runtime models and relations in a model-driven manner while supporting a high level of automation. Finally, we present two case studies exemplifying the application and benefits of megamodels at runtime.", "num_citations": "15\n", "authors": ["556"]}
{"title": "Model-driven engineering of self-adaptive software\n", "abstract": " Model-Driven Engineering of Self-Adaptive Software Page 1 Model-Driven Engineering of Self-Adaptive Software UCT CS Colloquium University of Cape Town, South Africa, 19th August 2015 Thomas Vogel @tomvog System Analysis and Modeling Group Hasso Plattner Institute University of Potsdam, Germany Page 2 Continuous Change Software aging [Parnas, 1994] When not being adapted to changing user needs (lack of movement) Adapting the software often violates the design (ignorant surgery) Lehman\u2019s laws of software evolution (real-world applications) [Lehman and Belady, 1985, Lehman and Ramil, 2001] I. A \u201csystem must be continually adapted else it becomes progressively less satisfactory in use\u201d VI. \u201cThe functional capability of [...] systems must be continually increased to maintain user satisfaction over the system lifetime\u201d \u21d2 Software Evolution and Maintenance [Mens and Demeyer, 2008, Mens et al\u2026", "num_citations": "13\n", "authors": ["556"]}
{"title": "Comprehensive support for management of Enterprise Applications\n", "abstract": " During the last decades, performance of available hardware resources constantly increased (Moore, 1965), which enabled the assignment of more and more complex tasks to software systems. As one consequence, the inherent complexity of these software systems also increases, influencing all phases of their lifecycle. The concept of component orientation (CO) (Szyperski, 1999) allows the development of software systems in a modular way through functional decomposition. Administration and maintenance of software systems are addressed by the vision of autonomic computing (AC) (Horn, 2001), based on the idea to assign low level administrative tasks to the system itself. With mKernel an AC-infrastructure for component oriented enterprise applications is provided, based on the enterprise Java bean (EJB) standard, version 3.0 (DeMichiel and Keith, 2006). In contrast to existing approaches, the main\u00a0\u2026", "num_citations": "13\n", "authors": ["556"]}
{"title": "On unifying development models and runtime models (position paper)\n", "abstract": " Models@ run. time research primarily focuses on developing and using selfrepresentations, that is, runtime models reflecting running software systems. Such models are the basis for feedback loops to monitor, analyze, and adapt these systems while the goal is typically to completely automate these feedback loops (cf. self-adaptation). This focus ignores (1) the beneficial use of runtime models for (manual) maintenance, which can already be observed in practice, and (2) the inevitable coexistence of self-adaptation and maintenance. Both issues require the integration of development (or maintenance) models and runtime models. In this position paper, we envision the unification of development and runtime models to systematically realize the integration and we discuss the benefits of this unification for addressing these issues with an illustrative example. We claim that Models@ run. time research should broaden its focus to the unification to support an incremental adoption of runtime models from manual maintenance to automated self-adaptation, and the coexistence. Finally, we discuss Models@ run. time challenges for achieving this claim.", "num_citations": "12\n", "authors": ["556"]}
{"title": "Improving scalability and reward of utility-driven self-healing for large dynamic architectures\n", "abstract": " Self-adaptation can be realized in various ways. Rule-based approaches prescribe the adaptation to be executed if the system or environment satisfies certain conditions. They result in scalable solutions but often with merely satisfying adaptation decisions. In contrast, utility-driven approaches determine optimal decisions by using an often costly optimization, which typically does not scale for large problems. We propose a rule-based and utility-driven adaptation scheme that achieves the benefits of both directions such that the adaptation decisions are optimal, whereas the computation scales by avoiding an expensive optimization. We use this adaptation scheme for architecture-based self-healing of large software systems. For this purpose, we define the utility for large dynamic architectures of such systems based on patterns that define issues the self-healing must address. Moreover, we use pattern-based\u00a0\u2026", "num_citations": "8\n", "authors": ["556"]}
{"title": "Taming Uncertainty in the Assurance Process of Self-Adaptive Systems: a Goal-Oriented Approach\n", "abstract": " Goals are first-class entities in a self-adaptive system (SAS) as they guide the self-adaptation. A SAS often operates in dynamic and partially unknown environments, which cause uncertainty that the SAS has to address to achieve its goals. Moreover, besides the environment, other classes of uncertainty have been identified. However, these various classes and their sources are not systematically addressed by current approaches throughout the life cycle of the SAS. In general, uncertainty typically makes the assurance provision of SAS goals exclusively at design time not viable. This calls for an assurance process that spans the whole life cycle of the SAS. In this work, we propose a goal-oriented assurance process that supports taming different sources (within different classes) of uncertainty from defining the goals at design time to performing self-adaptation at runtime. Based on a goal model augmented with\u00a0\u2026", "num_citations": "7\n", "authors": ["556"]}
{"title": "Towards smart systems of systems\n", "abstract": " Systems of Systems (SoS) have started to emerge as a consequence of the general trend toward the integration of beforehand isolated systems. To unleash the full potential, the contained systems must be able to operate as elements in open, dynamic, and deviating SoS architectures and to adapt to open and dynamic contexts while being developed, operated, evolved, and governed independently. We name the resulting advanced SoS to be smart as they must be self-adaptive at the level of the individual systems and self-organizing at the SoS level to cope with the emergent behavior at that level. In this paper we analyze the open challenges for the envisioned smart SoS. In addition, we discuss our ideas for tackling this vision with our SMARTSOS approach that employs open and adaptive collaborations and models at runtime. In particular, we focus on preliminary ideas for the construction and\u00a0\u2026", "num_citations": "7\n", "authors": ["556"]}
{"title": "Language and framework requirements for adaptation models\n", "abstract": " Approaches to self-adaptive software systems use models at runtime to leverage benefits of model-driven engineering (MDE) for providing views on running systems and for engineering feedback loops. Most of these approaches focus on causally connecting runtime models and running systems, and just apply typical MDE techniques, like model transformation, or well-known techniques, like event-conditionaction rules, from other fields than MDE to realize a feedback loop. However, elaborating requirements for feedback loop activities for the specific case of runtime models is rather neglected. Therefore, we investigate requirements for Adaptation Models that specify the analysis, decision-making, and planning of adaptation as part of a feedback loop. In particular, we consider requirements for a modeling language of adaptation models, and for a framework as the execution environment of adaptation models. Moreover, we discuss patterns for using adaptation models within the feedback loop regarding the structuring of loop activities. The patterns and the requirements for adaptation models influence each other, which impacts the design of the feedback loop.", "num_citations": "7\n", "authors": ["556"]}
{"title": "A hybrid approach combining control theory and AI for engineering self-adaptive systems\n", "abstract": " Control theoretical techniques have been successfully adopted as methods for self-adaptive systems design to provide formal guarantees about the effectiveness and robustness of adaptation mechanisms. However, the computational effort to obtain guarantees poses severe constraints when it comes to dynamic adaptation. In order to solve these limitations, in this paper, we propose a hybrid approach combining software engineering, control theory, and AI to design for software self-adaptation. Our solution proposes a hierarchical and dynamic system manager with performance tuning. Due to the gap between high-level requirements specification and the internal knob behavior of the managed system, a hierarchically composed components architecture seek the separation of concerns towards a dynamic solution. Therefore, a two-layered adaptive manager was designed to satisfy the software requirements with\u00a0\u2026", "num_citations": "6\n", "authors": ["556"]}
{"title": "Generic architectures for individual self-aware computing systems\n", "abstract": " Making computing systems self-aware calls for appropriate architectural designs of such systems that allow developers to explicitly decide and reason about the system\u2019s self-awareness capabilities. In this context, a critical issue is the development of appropriate reflections that enable self-awareness and that impact the architectural design. This chapter, therefore, discusses generic architectures for pre-reflective, reflective, and meta-reflective self-awareness as well as various forms of constructing reflections while focusing on an individual system as opposed to a collective of self-aware computing systems. Finally, we discuss the presented ideas with respect to existing control schemes and architectural styles for self-adaptive software that seem to be promising for the architectural design of self-aware computing systems.", "num_citations": "6\n", "authors": ["556"]}
{"title": "Towards linking adaptation rules to the utility function for dynamic architectures\n", "abstract": " To benefit from utility-driven and rule-based approaches to self-adaptation, we propose combining both by defining and linking the utility function and the adaptation rules in a pattern-based way at the architectural level.", "num_citations": "6\n", "authors": ["556"]}
{"title": "Explainable Software for Cyber-Physical Systems (ES4CPS): Report from the GI Dagstuhl Seminar 19023, January 06-11 2019, Schloss Dagstuhl\n", "abstract": " This report documents the program and results of the GI-Dagstuhl Seminar 19023 on Explainable Software for Cyber-Physical Systems (ES4CPS). The seminar was concerned with the challenge that for future Cyber-Physical Systems (CPS), it will become increasingly relevant to explain their behavior (past, current, and future behavior, why a certain action was taken, how a certain goal can be achieved, etc.) to users, engineers, and other stakeholders. In order to increase the explainability of CPS and their engineering tools, fundamental, interdisciplinary research is required; solutions from multiple disciplines within software engineering, systems engineering, and related fields have to be applied, combined, and researched further. The goal of this seminar was to serve as a starting point for an interdisciplinary coordination of research activities targeting ES4CPS and an incubator of a new research community around this topic.", "num_citations": "5\n", "authors": ["556"]}
{"title": "A domain specific language to support HAZOP studies of SysML models\n", "abstract": " To deal with the rising system complexity, Model-Based System Development (MBSD) approaches are becoming popular due to their promise to improve consistency between different views of the system model. For dependable systems, safety analysis is one of the important views. Model-Based Safety Analysis (MBSA) can partially automate the generation of safety artifacts and provide traceability between the system model and the generated safety artifacts. Thus, MBSA not only supports the safety analysis of the system, it also eases an impact analysis of model changes and hence supports an iterative and agile development of safety-critical systems. This paper presents an MBSA approach for the                                            (HAZOP) studies using a Domain-Specific Language (DSL) for guidance and establishing strong links to the system model and requirements for consistency and traceability. The\u00a0\u2026", "num_citations": "4\n", "authors": ["556"]}
{"title": "mRUBiS: An exemplar for model-based architectural self-healing and self-optimization (artifact)\n", "abstract": " Self-adaptive software systems are often structured into an adaptation engine that manages an adaptable software by operating on a runtime model that represents the architecture of the software (model-based architectural self-adaptation). Despite the popularity of such approaches, existing exemplars provide application programming interfaces but no runtime model to develop adaptation engines. Consequently, there does not exist any exemplar that supports developing, evaluating, and comparing model-based self-adaptation off the shelf. Therefore, we present mRUBiS, an extensible exemplar for model-based architectural self-healing and self-optimization. mRUBiS simulates the adaptable software and therefore provides and maintains an architectural runtime model of the software, which can be directly used by adaptation engines to realize and perform self-adaptation. Particularly, mRUBiS supports injecting issues into the model, which should be handled by self-adaptation, and validating the model to assess the self-adaptation. For this purpose, the exemplar provides two case studies of self-healing and self-optimization. Finally, mRUBiS allows developers to explore variants of adaptation engines (eg, event-driven self-adaptation) and to evaluate the effectiveness, efficiency, and scalability of the engines.", "num_citations": "3\n", "authors": ["556"]}
{"title": "Software Engineering for Intelligent and Autonomous Systems: Report from the GI Dagstuhl Seminar 18343\n", "abstract": " Software systems are increasingly used in application domains characterised by uncertain environments, evolving requirements and unexpected failures; sudden system malfunctioning raises serious issues of security, safety, loss of comfort or revenue. During operation, these systems will likely need to deal with several unpredictable situations including variations in system performance, sudden changes in system workload and component failures. These situations can cause deviation from the desired system behaviour and require dynamic adaptation of the system behaviour, parameters or architecture. Through using closed-loop control, typically realized with software, intelligent and autonomous software systems can dynamically adapt themselves, without any or with limited human involvement, by identifying abnormal situations, analysing alternative adaptation options, and finally, self-adapting to a suitable new configuration. This report summarises the research carried out during SEfIAS GI Dagstuhl seminar which provided a forum for strengthening interaction and collaboration for early-career researchers and practitioners from the research communities of SEAMS, ICAC/ICCAC, SASO, Self-Aware Computing and AAMAS.", "num_citations": "2\n", "authors": ["556"]}
{"title": "Multiple Runtime Models and their Relations for Self-Management\n", "abstract": " In contrast, we propose a model-driven approach that provides multiple causally connected runtime models reflecting the architecture at different levels of abstraction for adapting a managed system. Each runtime model focuses on a specific concern and abstracts from the underlying system and platform leveraging reusability and extensibility of managers. The different models are maintained automatically at runtime using model-driven engineering techniques that also reduce development efforts. Besides causally connected architectural models, other kinds of models are generally used at runtime. Based on the current state of the research field, we present a categorization of runtime models, conceivable relations between those models, and how runtime management using multiple models can benefit from megamodel concepts.", "num_citations": "1\n", "authors": ["556"]}
{"title": "Models at Runtime for Monitoring and Adapting Software Systems\n", "abstract": " The use of model-driven engineering techniques for managing or self-managing software systems can yield to signi\ufb01cant bene\ufb01ts as models can be used to provide a rich semantic base for monitoring, analyzing, planning and adapting software systems. Moreover, the administration of today\u2019s complex systems could be eased. This paper outlines the application of models at runtime for monitoring and adapting software systems. This includes a discussion of the causal relationship between those models and a running system, appropriate abstractions of runtime models, the maintenance of runtime models, and of emerged research challenges. The ideas are presented in the context of IT Service Management and of autonomic/self-adaptive software. Both have in common that runtime models re\ufb02ecting a running system can be used for monitoring and adapting the system.", "num_citations": "1\n", "authors": ["556"]}
{"title": "Design and Implementation of Autonomous Reconfiguration Procedures for EJB-based Enterprise Applications\n", "abstract": " Enterprise Applications (EA) are complex software systems for supporting the business of a company. According to Lehman\u2019s laws [LRW+ 97] software implementing real world applications like EAs must continually evolve, else they become progressively less satisfactory and their use and value would decline. Therefore, huge amounts of the IS budgets of companies are spent on software maintenance and evolution [RBBC04, Rau00, Erl].", "num_citations": "1\n", "authors": ["556"]}