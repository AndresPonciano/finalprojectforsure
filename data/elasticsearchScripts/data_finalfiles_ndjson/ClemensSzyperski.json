{"title": "Component software: beyond object-oriented programming\n", "abstract": " The author describes his book as a\" unique blend of market and technology coverage, broad and fair coverage of current technologies and a deep discussion of real problems with their solutions where known\". The first edition won the\" Jolt Award\" became the leading book on the market to combine explanations of what the key technologies are, how to use them and why they are important in the software market-place, and look at these in terms of both the technical and business issues. The book was also the first to define components and clarify the key questions surrounding them, show how they are key to software design and offer a historical overview of their development.", "num_citations": "9641\n", "authors": ["743"]}
{"title": "Software ecosystem: Understanding an indispensable technology and industry\n", "abstract": " Our society increasingly revolves around software-based products and services, yet few writers have attempted to examine the interdependencies that surround software's inception, realization, marketing, use, and regulation. In this book, Messerschmitt and Szyperski successfully adopt a holistic approach in their examination of the software industry and of software technologies. After a brief overview of the most important features of information technology, the two authors examine the scene through six different points of view, namely those associated with users, developers, managers, industrialists, policy experts, and economists. This division allows the authors to cover the outlook of the ubiquitous everyday software user; the developer who translates the user's needs into code; the managers and industrialists who allocate and orchestrate resources to develop, distribute, and deploy software; and those\u00a0\u2026", "num_citations": "748\n", "authors": ["743"]}
{"title": "Component technology-what, where, and how?\n", "abstract": " Software components, if used properly, offer many software engineering benefits. Yet, they also pose many original challenges starting from quality assurance and ranging to architectural embedding and composability. In addition, the recent movement towards services, as well as the established world of objects, causes many to wonder what purpose components might have. This extended abstract summarizes the main points of my Frontiers of Software Practice (FOSP) talk at ICSE 2003. The topics covered aim to offer an end-to-end overview of what role components should play, where they should be used, and how this can be achieved Some key open problems are also pointed out.", "num_citations": "253\n", "authors": ["743"]}
{"title": "How is open source affecting software development?\n", "abstract": " Clemens Szyperski, Microsoft Research tributed with the FreeBSD operating system.(Many projects appear on more than one of the locations just listed.) Following the reused open source code\u2019s evolution and deploying the corresponding components are also becoming less haphazard operations, with mechanisms such as installable packages and anonymous Concurrent Versions System (CVS) access enabling the automation of many operations. This special issue examines how the proliferation and availability of open source are affecting software development practices. From a developer\u2019s perspective, open source is a combination of two important properties: visible source code and a right to make (relatively) unencumbered derivatives. The motivations behind the two properties are different, and each can occur in isolation\u2014examples include Microsoft\u2019s shared source and library vendors\u2019 code licenses for developing derivative products from nonvisible source. Both properties affect\u2014in positive and negative ways\u2014the software artifacts (products) we develop and how we develop them (process).", "num_citations": "187\n", "authors": ["743"]}
{"title": "What characterizes a (software) component?\n", "abstract": " The definitions and discussions below were contributed via e-mail. They are arranged by date. The experts, listed alphabetically above, participated in this virtual round table during the first quarter of 1998.", "num_citations": "161\n", "authors": ["743"]}
{"title": "Independently extensible systems-software engineering potential and challenges\n", "abstract": " Component-based software, open systems, and document-based user interfaces are about to revolutionise most areas traditionally addressed by the software engineer. We claim that many traditional software engineering methods, from life-cycle models to programming languages to system architectures are at least insu cient when facing the new trends. In this paper we present the main points of criticism and state a few unavoidable facts of life: extensible systems are in principle modular, have no nal form or nal integration phase, cannot be subjected to nal total analysis, cannot be exhaustively tested, and have to allow for mutual independence of extension providers. We also hint at possible solutions for part of the problem set. In particular, we investigate the problem of dependence on global analysis, the e ects of Cartesian Products in the design space, and the resulting design constraints on programming languages as the exemplary and most important tool of the software engineer. The relevance of the observations will be underlined by several examples drawn from contemporary programming languages and methods that got it wrong.", "num_citations": "151\n", "authors": ["743"]}
{"title": "Import is not Inheritance Why we need both: Modules and Classes\n", "abstract": " The design of many popular object-oriented languages like Smalltalk, Eiffel, or Sather follows a certain trend: The class is the only structuring form. In this paper, the need for having modules besides classes is claimed. Modules stem from a different language family and at first glance it seems that they can easily be unified with classes. Among other things, unifying modules and classes carries the danger of unifying the import and inheritance relationships. Constructs in several languages are discussed that indicate that modules and classes should indeed be kept separate.", "num_citations": "150\n", "authors": ["743"]}
{"title": "Web services engineering: promises and challenges\n", "abstract": " Web services are emerging technologies to reuse software as services over the Internet by wrapping underlying computing models with XML. Web services are rapidly evolving and are expected to change the paradigms of both software development and use. This panel will discuss the current status and challenges of Web services technologies.", "num_citations": "112\n", "authors": ["743"]}
{"title": "Engineering a programming language: The type and class system of Sather\n", "abstract": " Sather 1.0 is a programming language whose design has resulted from the interplay of many criteria. It attempts to support a powerful object-oriented paradigm without sacrificing either the computational performance of traditional procedural languages or support for safety and correctness checking. Much of the engineering effort went into the design of the class and type system. This paper describes some of these design decisions and relates them to approaches taken in other languages. We particularly focus on issues surrounding inheritance and subtyping and the decision to explicitly separate them in Sather.", "num_citations": "109\n", "authors": ["743"]}
{"title": "Why Objects Are Not Enough\n", "abstract": " Object\u2212 oriented programming hasn't created a viable software component industry. From a technical perspective, the reason for this failure lies in an insufficient consideration of the unique requirements of component software. Object\u2212 oriented programming too often concentrates on individual objects, instead of whole collections of objects, ie, components. Component\u2212 oriented programming requires more stringent information hiding, a more dynamic approach, and better safety properties than object\u2212 oriented programming.", "num_citations": "87\n", "authors": ["743"]}
{"title": "Transaction transforms\n", "abstract": " A method and system for maintaining isolated data in an application is disclosed which data to be selectively isolated until a data client orders the changes to be committed or abandoned. A computer-readable medium for constructing an application capable of localized data isolation is also disclosed. An application specification is used to determine which data entities should be isolated, and one or more transaction transforms are implemented for each data entity to be isolated.", "num_citations": "77\n", "authors": ["743"]}
{"title": "Iteration abstraction in Sather\n", "abstract": " Sather extends the notion of an iterator in a powerful new way. We argue that iteration abstractions belong in class interfaces on an equal footing with routines. Sather iterators were derived from CLU iterators but are much more flexible and better suited for object-oriented programming. We retain the property that iterators are structured, i.e., strictly bound to a controlling structured statement. We motivate and describe the construct along with several simple examples. We compare it with iteration based on CLU iterators, cursors, riders, streams, series, generators, coroutines, blocks, closures, and lambda expressions. Finally, we describe experiences with iterators in the Sather compiler and libraries.", "num_citations": "70\n", "authors": ["743"]}
{"title": "Fully capturing outer variables as data objects\n", "abstract": " Providing for read/write access to captured free variables expressed as environment data objects is disclosed herein. By way of example, free variables can be rewritten as a field of a private class, and accessed via an instance of the private class captured within the environment data object. In such a manner, no need of a placeholder or proxy function is required to access the free variable. Consequently, the subject innovation provides a simplified method for capturing free variables within expression trees and providing read/write access to such variables.", "num_citations": "57\n", "authors": ["743"]}
{"title": "Component software and the way ahead\n", "abstract": " Components capture the deployment nature of software; objects capture its runtime nature. Components and objects together enable the construction of nextgeneration software. However, as discussed in this chapter, many problems still need to be solved before component software can become ubiquitous. One important step to be taken is to move from component introversion to component extroversion and to adopt component-based software architecture on a much broader basis. To avoid the many traps on that way, it is useful to emphasize: Components are units of deployment and versioning but the atoms of configuration. To control the complexity explosion of peer-to-peer component architectures, component frameworks need to be pursued beyond their current weak foundation.", "num_citations": "54\n", "authors": ["743"]}
{"title": "Industrial and economic properties of software: Technology, processes, and value\n", "abstract": " Software technology and its related activities are examined from an industrial and economic perspective. More specifically, the distinct characteristics of software from the perspective of the end-user, the software engineer, the operational manager, the intellectual property lawyer, the owner, and the economist are identified. The overlaps and relationships among these perspectives are discussed, organized around three primary issues: technology, processes, and value relationships. Examples of the specific issues identified are licensing vs. service provider models, alternative terms and conditions of licensing, distinct roles in the supplier value chain (development, provisioning, operation, and use) and requirements value chain (user needs and requirements), and the relationship of these issues to industrial organization and pricing. The characteristics of software as an economic good and how they differ from material and information goods are emphasized, along with how these characteristics affect commercial relationships and industrial organization. A primary goal of this paper is to stimulate more and better research relevant to the software industry in the economic, business, and legal disciplines.", "num_citations": "52\n", "authors": ["743"]}
{"title": "Emerging component software technologies\u2014a strategic comparison\n", "abstract": " Component software addresses the fundamental requirement that software systems need to be composed from components. Potentially, each component can evolve on its own as a product. Composition may be static, much in the sense of traditional product assembly, but could just as well be dynamic. Dynamic assembly is even required in the increasingly important case of content-oriented solutions. In all cases the effectiveness of a component approach will rest on the degree of standardization achieved in a specific domain. This article provides a strategic comparison of the two major competing component software standards: COM and CORBA/JavaBeans.", "num_citations": "46\n", "authors": ["743"]}
{"title": "XML application framework\n", "abstract": " The present invention relates to an XML application framework (XAF). XAF applications are data driven such that all operations with the computer system are data focused. In addition, the components used in the XAF application are instantiated and connected according to how the data is displayed and what type of data is used. Applications within XAF comprise a user interface (UI) connector, an action module, and a data connector. UI connectors receive UI events and connect the UI event to an action module. The action module generates a standard format action from the UI event and sends it to the data connector. The data connector translates the standard format action into a data-specific action that changes data in a data store. A data connector then sends a standard format data representation corresponding to the changed data back to the UI connector to provide the changed data to the UI.", "num_citations": "45\n", "authors": ["743"]}
{"title": "XML application framework\n", "abstract": " An extensible markup language (XML) application framework (XAF) may be provided. XAF applications are data driven such that all operations with a computer system are data focused. In addition, the components used in the XAF application are instantiated and connected according to how data is displayed and what data type is used. Applications within XAF comprise a user interface (UI) connector, an action module, and a data connector. UI connectors receive UI events and connect the UI event to an action module. The action module generates a standard format action from the UI event and sends it to the data connector. The data connector translates the standard format action into a data-specific action that changes data in a data store. A data connector then sends a standard format data representation corresponding to the changed data back to the UI connector to provide the changed data to the UI.", "num_citations": "36\n", "authors": ["743"]}
{"title": "Insight ETHOS: On object-orientation in operating systems\n", "abstract": " Ethos The characteristic spirit, prevalent tone ofsentiment, ofa people or community, the\" genius\" ofan institution or system (Anstoteles-Rhetorics n xi,~ xiv)", "num_citations": "36\n", "authors": ["743"]}
{"title": "Write-ing Applications: Design of an Extensible Text Editor as an Application Framework.\n", "abstract": " Using an object\u2212 oriented approach, the text editor Write has been designed to be extensible while its basic structure has been kept small and simple. As its main extension concept, Write supports extensible objects floating in a text. An important result presented is that the extended editor can play the role of various dedicated applications. It can be stated that the editor together with its extension model constitutes an application framework of rather wide applicability. This paper presents the editing model chosen for Write and its effects on efficiency and ease of extension. To demonstrate the effectiveness of the approach, several editor extensions are presented.", "num_citations": "35\n", "authors": ["743"]}
{"title": "Streaming joins in constrained memory environments\n", "abstract": " Large amounts of memory can be consumed in streaming joins because events from one stream are held in memory while waiting for matching events from a second stream. Memory needs can be reduced by analyzing the join condition to determine the bounds on the time discrepancy between events in the two streams. When it is determined that an event from one stream must occur prior to the matching event from the other stream, the later-arriving stream data can be ingested with an intentional delay. When it is determined that regardless of input received from a first stream, no output will be produced when there is no input from the second stream, pulling data from the first stream can cease. A multi-stage join plan can be employed so that a less busy stream can be scanned with increasing amounts of intentional delay. Only unmatched data is stored.", "num_citations": "33\n", "authors": ["743"]}
{"title": "System and method for identifying namespaces\n", "abstract": " Described is a system and method that enable the incorporation of one namespace into another namespace while avoiding name collisions by defining namespaces with a common name and a unique identifier. In accordance with the invention, a namespace may incorporate another namespace by unique identifier and assign an alias to that incorporated namespace. The use of the alias provides a developer with the flexibility to reference the imported namespace and its declarations by common, understandable, or human-meaningful names. In addition, name collisions between the imported namespace and local declarations are avoided by the uniqueness provided by the unique identifier. Furthermore, by way of re-exports, multiple parallel namespace hierarchies can be formed over the same definitions to reflect multiple parallel taxonomies.", "num_citations": "31\n", "authors": ["743"]}
{"title": "Overcoming independent extensibility challenges\n", "abstract": " Independent extensibility requires a strong handle on versioning through precise names.", "num_citations": "30\n", "authors": ["743"]}
{"title": "A characterization of multi-party interactive multimedia applications\n", "abstract": " This document tries to de ne and characterize a class of applications called Multi-Party Interactive Multimedia (MIM), for which many examples are given. This class includes applications such as CSCW, teleconferencing, and remote education; its consideration in this report is based on the observation that MIM applications are both important and representative for the area of high-performance real-time communication. Purely functional criteria are used to capture the MIM class, ie ones that are not related to any particular way of implementation. Thus, future directions are sketched that give some indications on what a network architecture will need to provide, in order to e ectively support such applications.", "num_citations": "28\n", "authors": ["743"]}
{"title": "Do we need inheritance\n", "abstract": " Object-oriented programming rests on four pillars: polymorphism, late binding, encapsulation, and inheritance. Of these, inheritance is the one most controversially discussed. Various problems have been stated, that occur when inheritance is used for object composition, modification, and extension. These problems are caused by the possibility to override single methods of the inherited object, thereby changing it rather than reusing it as a whole. This possibility contradicts actually the requirements of encapsulation.Note that in this context delegation (as used in object-based language such as Self [US 87]) is equivalent to inheritance [eg, Stein 87] and introduces the same problems. Overriding of individual methods then corresponds to implementing individual methods while delegating others. Forwarding is a weaker mechanism and does not have the problems of inheritance or delegation; for a simple statement on how forwarding and delegation differ, cf [JZ 91].", "num_citations": "27\n", "authors": ["743"]}
{"title": "Sather iters: Object-oriented iteration abstraction\n", "abstract": " Sather iters are a powerful new way to encapsulate iteration. We argue that such iteration abstractions belong in a class' interface on an equal footing with its routines. Sather iters were derived from CLU iterators but are much more exible and better suited for object-oriented programming. We motivate and describe the construct along with several simple examples. We compare it with iteration based on CLU iterators, cursors, riders, streams, series, generators, coroutines, blocks, closures, and lambda expressions. Finally, we describe how to implement them in terms of coroutines and then show how to transform this implementation into e cient code.", "num_citations": "23\n", "authors": ["743"]}
{"title": "Accessing and manipulating data in a data flow graph\n", "abstract": " The present invention extends to methods, systems, and computer program products for accessing and manipulating data in a data flow graph. A data flow graph includes one more transforms for transforming data from one or more data stores into different formats accessible to clients. Transforms can be configured to join and split data from the same or different data stores. A metadata tree logically represents the data flow graph including locations that provide output from transforms of the data flow graph. The locations can be referenced by clients to access transformed outputs. Clients can register dependencies on data at various locations and can request evaluation of the data in response to data changes at a corresponding data store. Clients can also request data changes be propagated back through the data flow graph to one or more data stores and implemented at the one or more data stores.", "num_citations": "19\n", "authors": ["743"]}
{"title": "Components vs. objects vs. component objects\n", "abstract": " In the present upswing of component software it is not too surprising to observe a common confusion of terms. It is understandable but not helpful that some promoters of object-oriented programming try to \u2018sell\u2019their established apparatus to the component world by renaming objects into components. Emerging component-based approaches and tools combine objects and components in ways that hint at the possibility that these are indeed different concepts. This article highlights the key differences between objects and components, points out that they are orthogonal concepts, and provides an integrating conceptual framework that addresses systems supporting objects and components. Seeming conflicts are resolved that result from \u2018visual assembly\u2019tools, which really assemble objects, not components.", "num_citations": "19\n", "authors": ["743"]}
{"title": "Dynamic distributed query execution over heterogeneous sources\n", "abstract": " An execution strategy is generated for a program that interacts with data from multiple heterogeneous data sources during program execution as a function of data source capabilities and costs. Portions of the program can be executed locally and/or remotely with respect to the heterogeneous data sources and results combined.", "num_citations": "18\n", "authors": ["743"]}
{"title": "Components and objects together\n", "abstract": " Components and objects together | Software Development ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Software Development Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsSoftware DevelopmentVol. , No. Components and objects together article Components and objects together Share on Author: Clemens Szyperski profile image Clemens Szyperski View Profile Authors Info & Affiliations Publication: Software DevelopmentMay 1999 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: \u2026", "num_citations": "18\n", "authors": ["743"]}
{"title": "Network support for realtime multi-party applications\n", "abstract": " Many important applications of the future require predictable performance from the network service. For example, applications that support multimedia interactive communication between multiple remote participants (MIM applications) have several such requirements: guaranteed throughput, bounded delay and delay-jitter. The Tenet group has implemented a suite of realtime protocols to provide a simplex unicast data service with performance guarantees [FBZ92]. In order to minimize the complexity of implementation, the first scheme (Scheme1) was designed to provide minimal support for realtime communication. Therefore, Scheme1 is cumbersome and inefficient for multi-party communication. In this paper we describe extensions to this work to provide support for multi-party realtime communication and a more flexible client-service interface. We refer to the resulting scheme as Scheme2.Support for multi-party communication falls in two areas:(i) networking abstractions for multi-party communication (eg, a of destination group id that allows sources to send data to a dynamically-changing group of interested parties); and (ii) optimizations that improve the efficient utilization of network resources for multi-party communication (eg using true multicast).", "num_citations": "18\n", "authors": ["743"]}
{"title": "Lightweight parametric polymorphism for Oberon\n", "abstract": " Strongly typed polymorphism is necessary for expressing safe reusable code. Two orthogonal forms of polymorphism exist: inclusion and parametric, the Oberon language only supports the former. We describe a simple extension to Oberon to support parametric polymorphism. The extension is in keeping with the Oberon language: it is simple and has an explicit cost. In the paper we motivate the need for parametric polymorphism and describe an implementation in terms of translating extended Oberon to standard Oberon.", "num_citations": "17\n", "authors": ["743"]}
{"title": "Multithreading with concurrency domains\n", "abstract": " Methods, systems and computer products are provided for partitioning software application components into separate domains called concurrency domains. Computationally expensive, slow or long-running methods may be deployed into such domains, thus keeping the associated application more responsive to the end user. According to one aspect of the invention, a given concurrency domain is a partition of runtime objects for providing synchronization and thread isolation within the partition and for providing concurrency with other such partitions in a data-driven dynamically composed and reconfigured application.", "num_citations": "16\n", "authors": ["743"]}
{"title": "Conciliation: The adaptation of independently developed components\n", "abstract": " Components which are developed independently but have similar behaviour, generally cannot be substituted for use by a client due to structural differences and minor but subtle behavioural differences. An automated solution for adaptation of these mismatches would be desirable. Although automatic adaptation has been addressed by recent works, it fails to go beyond simple structural differences. In this paper an approach for semi-automatic adaptation is proposed, called Conciliation. As well as structural mismatch, Conciliation addresses behaviour mismatch. It does so without requiring modification or recompilation of the clients or the providing components. The Conciliation process is guided by specification; the structure of these specifications is designed for use with component systems. An example of Conciliation in the context of Microsoft\u2019s Component Object Model (COM) and the Common Object Request Broker Architecture (CORBA) is studied in detail, illustrating how Conciliation fits into a real world component model. In a world of overlapping component software standards, Conciliation is a promising solution.", "num_citations": "15\n", "authors": ["743"]}
{"title": "The role of programming languages in the life-cycle of safe systems\n", "abstract": " Safety as understood in the conference theme can be separated into the more technical terms of safety, progress, and security: nothing bad happens, the right things do happen, and things happen under proper authorization. All three interact to make a system\\safe\" in the broader sense. This article introduces to the degree of safety in the technical sense that can be directly supported by programming languages and their type systems in particular. From a generalized de nition of type a brief journey through contemporary type systems is taken and illustrated using examples from di erent programming languages. Finally, current trends and some novel approaches are presented.", "num_citations": "15\n", "authors": ["743"]}
{"title": "Framework for open dynamic reflective applications\n", "abstract": " A framework for open, dynamic, and reflective applications contains high level metadata that define blocks of composable elements using a service definition, which defines specific keys for using the block of code. The service definition may be exported from the code using reflection without having to load the code into memory, and decisions on which block of code and how to load the code may be made at runtime. The composable elements may be grouped into composable parts. Composable part definitions may be used to instantiate or produce composable parts. At runtime, dynamic applications may search from many composable elements, and instantiate and execute the composable element as part of the application.", "num_citations": "14\n", "authors": ["743"]}
{"title": "Entity domains\n", "abstract": " Strategies are described for organizing the runtime components of an application into an entity domain framework. The entity domain framework includes one or more entity domains arranged in a hierarchical fashion. Each entity domain further groups one or more components together in a hierarchical fashion. Each entity domain can include one or more services that provide a policy to the components within the entity domain. Composite functionality couples the framework together, and further provides a bus-like mechanism whereby an entity can forward service requests up through the hierarchy until a domain is found that satisfies the requests. Exemplary services provided by the entity domain framework include lifetime management services, error handling services, and so forth. The hierarchical structure provides an efficient way of exposing functionality to groups of components that will share this functionality\u00a0\u2026", "num_citations": "14\n", "authors": ["743"]}
{"title": "Transplanting in gardens: Efficient heterogeneous task migration for fully inverted software architectures\n", "abstract": " . Task migration across heterogeneous platforms is one of the great challenges of distributed computing. While several approaches are known, very few actual implementations are available. The problem is even harder in the context of high performance computing, where it is imperative to not restrict optimising compilers in their effectiveness, something that all existing approaches to heterogeneous task migration do. In this paper we present a novel and efficient approach to heterogeneous task migration based on the model of fully inverted software architectures. We discuss the approach in general and an implementation specific to the Gardens parallel computing system. 1 Introduction Migration of tasks from one computer to another can be very useful. For example task migration can be used to realise:--mobile agents,--load balancing and--fault tolerance (by periodically migrating tasks to stable storage). Unfortunately, migrating tasks across heterogeneous computers is difficul...", "num_citations": "14\n", "authors": ["743"]}
{"title": "Mianjin is Gardens Point: A parallel language taming asynchronous communication\n", "abstract": " The Gardens language, Mianjin, supports task based parallel computation, which utilises Active Messages style asynchronous communication. Unlike raw Active Messages, which is a library, this is achieved safely and without degrading performance by enforcing all necessary restrictions statically at the language level. Also supported is the de nition of communication abstractions. To do this Mianjin utilises a partitioned address space where local objects are distinguished from those made globally accessible; this is achieved via type annotations. Type annotations are also used to distinguish those routines which may perform communications from those which will not; a distinction important for the static safety of an Active Message implementation. A special parameter mechanism is used to implement and enforce the conditions necessary for safe reply (read) operations.", "num_citations": "14\n", "authors": ["743"]}
{"title": "System and method for recognizing structure in text\n", "abstract": " A method, system, and computer product for processing information embedded in a text file with a grammar programming language is provided. A text file is parsed according to a set of rules and candidate textual shapes corresponding to potential interpretations of the text file are provided by compiling a script. An output is provided, which may include either a processed value corresponding to a particular textual shape, or a textual representation of the text file that includes generic data structures that facilitate providing any of the candidate textual shapes, where the generic data structures are a function of the set of rules.", "num_citations": "13\n", "authors": ["743"]}
{"title": "Dynamic lazy type system\n", "abstract": " A dynamic, lazy type system is provided for a dynamic, lazy programming language. Consequently, programs can benefit from runtime flexibility and lightweight notation in combination with benefits afforded by a substantial type system.", "num_citations": "12\n", "authors": ["743"]}
{"title": "Consistently signaling state changes\n", "abstract": " A signaling system of the present invention provides a synchronized approach to delivering, reporting, and/or otherwise processing status changes in a software dependency chain. In a first phase, the signaling system identifies all dependencies between software components, and further sets a binary indicator of each node in a first representation. After identifying any changes in a source node, the system (eg, a value is updated), the system updates each binary indicator to a second setting. In a second phase, the system initiates all listeners in the dependency chain in an essentially progressive order from source node, to intermediate node, and end-node, etc. Once all listeners have had a chance to perform one or more processes based on the updated value, the system can discard the dependency graph, allowing a new dependency graph to be built for subsequent value changes.", "num_citations": "12\n", "authors": ["743"]}
{"title": "A case for meta-interworking: Projecting CORBA meta-data into COM\n", "abstract": " The pressure to reduce the time and effort required to produce and update software components, together with the existence of multiple competing component worlds, has forced the introduction of interworking standards. Unfortunately the interworking standards fail to suitably address the need for access to meta information. In the light of meta-data being increasingly important for component environments, this inaccessibility of meta-data can lead to components being unusable by their intended clients. What exasperates the situation is that if access to meta-data repositories is provided using an implementation of the interworking standard, the information retrieved is incorrect. The paper describes these difficulties. To exemplify the solution, the construction of an adapter is described. This adapter provides access to the Common Object Request Broker Architectures' (CORBA) Interface Repository via the Interfaces\u00a0\u2026", "num_citations": "12\n", "authors": ["743"]}
{"title": "Gardens: An integrated programming language and system for parallel programming across networks of workstations\n", "abstract": " Gardens is an integrated programming language and system supporting parallel computation across networks of workstations. It addresses a combination of goals: it (i) maximises performance and (ii) is still safe, it supports (iii) the programming of abstractions (parallel libraries) and (iv) adaptive parallel computation, ie, computation that adapts at run-time to a changing set of available workstations. In Gardens, tasks represent units of work and task migration supports adaptation: releasing workstations on demand. To support adaptation, problems are over-decomposed into more tasks than processors. Tasking is non-preemptive: simplifying semantics and admitting a very e cient implementation. Within its local heap, each task manages a collection of global objects. These support: communication via global methods which other tasks may invoke, abstraction and typed safe asynchronous communication (including freedom from self-in icted and distributed network deadlocks). The implementation of global objects maps e ciently to high performance messaging layers, such as Active Messages.", "num_citations": "12\n", "authors": ["743"]}
{"title": "Three experts on big data engineering\n", "abstract": " Clemens Szyperski (Microsoft), Martin Petitclerc (IBM), and Roger Barga (Amazon Web Services) answer three questions: What major challenges do you face when building scalable, big data systems? How do you address these challenges? Where should the research community focus its efforts to create tools and approaches for building highly reliable, scalable, big data systems? This article is part of a special issue on Software Engineering for Big Data Systems.", "num_citations": "11\n", "authors": ["743"]}
{"title": "Accessing different application data via a common data structure\n", "abstract": " A common data type structure can be used to correlate access requests between applications that implement data in accordance with different types or type structures. In one implementation, a common data structure includes schemes for operations, sequences, records, and atoms (ie, undefined). The system can then map any type structure to the schemes of the common data structure. In operation, a request for data by an application can involve identifying one or more proxies used by an application to map the data to the common data structure. The proxies map the data to the common data structure based on the shape of the data (to the extent it can be identified). The proxies then can return one or more data structures that comprise the identified mapping information. The application can then perform operations directly on the received data structures.", "num_citations": "11\n", "authors": ["743"]}
{"title": "Business Process Management Workshops: BPM 2009 International Workshops, Ulm, Germany, September 7, 2009, Revised Papers\n", "abstract": " Business process management (BPM) constitutes one of the most exciting-search areas in computer science and the BPM Conference together with its workshops provides a distinct platform for presenting the latest research and showing future directions in this area. These proceedings contain the? nal v-sions of papers accepted for the workshops held in conjunction with the 7th International Conference on Business Process Management (BPM 2009). The BPM 2009 conference and workshops took place in Ulm, Germany. We received many interesting workshop proposals, eight of which were selected. Ultimately the workshops ran on September 7, 2009 featuring highly interesting keynotes, inspiring scienti? c presentations, and fruitful discussions. The history of? ve years of BPM workshops in a row proves the continued success of the workshop program. Theworkshopsheldin2009includedonenewworkshoponempiricalresearch in business process management and seven well-established workshops. First International Workshop on Empirical Research in Business Process Management (ER-BPM 2009). The ER-BPM 2009 workshop addressed the demand for empirical research methods such as experimental or case studies to BPM and invited fellow colleagues to investigate both the potential and the limitations of BPM methods and technologies in practice. The ER-BPM workshop aimed at closing the gap in knowledge on process management and at discussing empirical research in the space of BPM and associated phenomena. 12th International Workshop on Reference Modeling (RefMod 2009). Although conceptual models have proven\u00a0\u2026", "num_citations": "11\n", "authors": ["743"]}
{"title": "Modules and Components-Rivals or Partners?\n", "abstract": " Component software sets out to address some of the fundamental prob-lems separating software construction as executed today from a long-held vision of reuse, extensibility, and evolvability. At the same time, program-ming languages began to explicitly support modular programming already in the late 1970's. In this chapter these efforts are summarized and related to the goals of component software. As it turns out, modularization is a necessary condition for component software; language support is thus clearly a good idea. However, modularization is not sufficient for component software and components are not just modules. This observation opens new avenues for programming language innovation. Some of the interesting dimensions are explored in this chapter. Since composability is at the heart of component software, language features that improve the degree of composability are particularly important. Examples from spaces as diverse as exception handling and type systems are examined to illustrate this point.", "num_citations": "11\n", "authors": ["743"]}
{"title": "Partial on-demand lazy semantic analysis\n", "abstract": " Computing responses to semantic queries. A method includes accessing a plurality of objects that represent source code for an input program. The source code is transformed into a plurality of immutable objects that are structured such that the immutable objects can be used to derive any response as defined by the semantic rules about the source code. A query is received from a requestor requesting a semantic characteristic of the input program. The semantic characteristic is calculated. The semantic characteristic is returned to the requestor. The semantic characteristic is cached in a cache. Information describing a dependency between the cached semantic characteristic and one or more of the objects in the plurality of objects is stored.", "num_citations": "10\n", "authors": ["743"]}
{"title": "Generic XAD processing model\n", "abstract": " Embodiments are directed to dynamically building software applications and dynamically updating software applications based on changed data values. In one embodiment, a computer system receives an indication that a software application is to be initiated. The computer system also receives an application description including tags describing software objects that are to be included in the software application, automatically maps portions of the application description identified by the tags to software objects using reflection, where the reflecting includes accessing properties associated with the software objects, and automatically binds properties of the software objects to the portions of the application description based declarative rules included in the software object properties associated with the software object.", "num_citations": "10\n", "authors": ["743"]}
{"title": "The COMEL language\n", "abstract": " In this paper, we propose an examplary language, COMEL, that support the Microsoft''s Component Object Model (COM) facilities. Microsoft''s COM is a leading example of the currently emerging technologies for component software. As such, it is the foundation of Microsoft''s OLE (Object Linking and Embedding) and ActiveX. Despite its importance, COM does not have a formal specification. An examplary language, COMEL, is used to model COM''s rules. A formal type system for COMEL is presented. This paper in effect presents an approach to the formalization of COM.", "num_citations": "10\n", "authors": ["743"]}
{"title": "Bubble execution: Resource-aware reliable analytics at cloud scale\n", "abstract": " Enabling interactive data exploration at cloud scale requires minimizing end-to-end query execution latency, while guaranteeing fault tolerance, and query execution under resource-constraints. Typically, such a query execution involves orchestrating the execution of hundreds or thousands of related tasks on cloud scale clusters. Without any resource constraints, all query tasks can be scheduled to execute simultaneously (gang scheduling) while connected tasks stream data between them. When the data size referenced by a query increases, gang scheduling may be resource-wasteful or un-satisfiable with a limited, per-query resource budget. This paper introduces Bubble Execution, a new query processing framework for interactive workloads at cloud scale, that balances cost-based query optimization, fault tolerance, optimal resource management, and execution orchestration. Bubble execution involves\u00a0\u2026", "num_citations": "9\n", "authors": ["743"]}
{"title": "Application framework phasing model\n", "abstract": " The present invention comprises phasing systems and methods for software systems. In embodiments of the present invention, the phasing system comprises a multi-tiered phasing space where operations within the software system are constrained to a phase or a sub-phase. The operations execute only in the specified phase. Thus, operations that could yield improper results in large and complex software systems do not execute simultaneously but follow a certain order. The present invention also provides a data structure to introduce the phase constraints as software attributes into the software code.", "num_citations": "9\n", "authors": ["743"]}
{"title": "What's in a Name?. NET as a Component Framework\n", "abstract": " In this paper, we analyze the challenges surrounding the problem of reuse and independent extensibility of software components beyond source sharing, relate them back to the development and deployment process, and show how many of the problems in this area can be traced back to name resolution problems. We show how the Common Language Infrastructure (CLI) addresses these problems in novel ways.", "num_citations": "9\n", "authors": ["743"]}
{"title": "Formalization of component object model (COM)-the COMEL language\n", "abstract": " Microsoft\u2019s OLE provides an application integration framework for Microsoft Windows. OLE rests on the Component Object Model (COM), which specifies a programming language independent binary standard for object invocations, plus a number of interfaces for foundational services.", "num_citations": "9\n", "authors": ["743"]}
{"title": "Discovery and use of navigational relationships in tabular data\n", "abstract": " Detection and use of relationships in tabular data is enhanced. A foreign-key-based relationship between two tables in memory is automatically discovered by a module. A view over table data is computationally augmented by adding an expandable hierarchical column. The expandable hierarchical column includes second table data that is related to rows of a first table by the discovered foreign-key-based relationship. A naming scheme for the added column is described. Sometimes the augmentation places an AddJoinColumn operator in a query expression tree; sometimes the tree is rewritten by moving a query operator or replacing a specified pattern of operators by a flat Join operation between two tables. Column expansion may be followed by reshaping data into a flat table, by getting a homogeneous query, by performing a join, or other operations.", "num_citations": "8\n", "authors": ["743"]}
{"title": "Efficient multicasting for interactive multimedia applications\n", "abstract": " A specific class of multimedia applications is expected to be of importance for future communication networks: Multi-Party Interactive Multimedia (MIM). Based on the isolation and characterization of MIM applications, concrete network support requirements are derived in this paper. The varying degree of connectivity, the vastly different sizes in terms of participants and the reliance on a guaranteed Quality of Service make MIM support a difficult problem. Starting with the definition of multimedia communication abstractions, principles of solutions are sketched. For an important subclass of applications a particularly efficient and practicable alternative implementation based on half-duplex channels is introduced. Finally, interfaces at both the transport and network layers are considered. The Tenet Group, Computer Science Division, Department of EECS, University of California, Berkeley and International Computer Science Institute, Berkeley. E-mail: fszyperski, ventreg@ icsi. berkeley...", "num_citations": "8\n", "authors": ["743"]}
{"title": "Handling out of order events\n", "abstract": " Processing streaming data in accordance with policies that group data by source, enforce a maximum permissible late arrival value for streaming data, a maximum permissible early arrival for data and/or a maximum degree to which data can be out of order and still be compliant with the out of order policy is described. The correct starting point for reading a data stream so as to produce correct output from a given output start time can be enabled using the early arrival policy. Using combinations of policies, output can be generated promptly (with low latency). When input from a given source is not disrupted, output can be generated with low latency. Output can be generated even when the input stops by applying a late arrival policy.", "num_citations": "7\n", "authors": ["743"]}
{"title": "Constructing queries for execution over multi-dimensional data structures\n", "abstract": " Various technologies pertaining to construction of a query for execution over a cube are described. Tabular data is presented on a displayed on a display screen, where the tabular data represents at least a portion of a data cube. Input is received with respect to the tabular data, and responsive to the input being received, a query is constructed based upon the input. The query is executed over the data cube, resulting in provisioning of a new table.", "num_citations": "7\n", "authors": ["743"]}
{"title": "Enterprise, Business-Process and Information Systems Modeling: 12th International Conference, BPMDS 2011, and 16th International Conference, EMMSAD 2011, Held at CAiSE 2011\u00a0\u2026\n", "abstract": " This book contains the refereed proceedings of the 12th International Conference on Business Process Modeling, Development and Support (BPMDS 2011) and the 16th International Conference on Exploring Modeling Methods for Systems Analysis and Design (EMMSAD 2011), held together with the 23rd International Conference on Advanced Information Systems Engineering (CAiSE 2011) in London, UK, in June 2011. The 22 papers accepted for BPMDS were selected from 61 submissions and cover a wide spectrum of issues related to business processes development, modeling, and support. They are grouped into sections on BPMDS in practice, business process improvement, business process flexibility, declarative process models, variety of modeling paradigms, business process modeling and support systems development, and interoperability and mobility. The 16 papers accepted for EMMSAD were chosen from 31 submissions and focus on exploring, evaluating, and enhancing current information modeling methods and methodologies. They are grouped in sections on workflow and process modeling extensions, requirements analysis and information systems development, requirements evolution and information systems evolution, data modeling languages and business rules, conceptual modeling practice, and enterprise architecture.", "num_citations": "7\n", "authors": ["743"]}
{"title": "Observing and reporting changes in complex software dependencies\n", "abstract": " An observation system includes mechanisms for efficiently tracking the state of source components, which include functions, arguments, or values, etc. In one implementation, an observing component requests that a source component processes a request. The observation system then identifies all possible components in a dependency chain for the request, and all such components that are configured for change notifications. A dependency registry stores a representation of each identified component that is configured for change notifications. Any time any component configured for change notifications changes, including indirectly related components, the observing component can be immediately notified of the change, without having to reprocess the entire set of component dependencies.", "num_citations": "6\n", "authors": ["743"]}
{"title": "System and method for mapping a domain modeling language to a relational store\n", "abstract": " A method and system for mapping between constructs in a domain modeling language and a relational storage language is provided. A source code authored in a source language is received and a set of constructs in the source code are identified. The set of constructs in the source code are mapped to a set of constructs in a target language. The source code is then compiled into a target code authored in the target language such that one of the source code or target code include a declarative constraint-based and/or order-independent execution model.", "num_citations": "6\n", "authors": ["743"]}
{"title": "Versioning support in object-oriented programming languages and tools\n", "abstract": " A versioning policy included in a target component indicates how the target component is to be accessed, for example, either as a library component or a platform component. A component may be designated as a library component when it is not versioned in a binary compatible manner. When other components request such a component they receive specifically the version of the component they requested. On the other hand, a component may be designated as a platform component when it is versioned in a binary compatible manner. When other components request such a component they may receive the latest upgraded version of the component requested instead. Thus, access to an appropriate version of the component (even a version differing from the requested version) is facilitated. Other embodiments include mechanisms for stratifying component scope based on different processing levels.", "num_citations": "6\n", "authors": ["743"]}
{"title": "Objectively: Components versus Web Services\n", "abstract": " We are observing a dramatic confluence of several different aspects: software components, software as a service, and an ever growing space of Internet and Web standards. Over the past year all major players in the software industry have announced their support of XML Web Services in one form or another. So, are services here to displace components? And what about our good old objects?               Drawing boundaries that help to understand the key concepts without obstructing the path towards future development is important but challenging. Concepts such as contracts, specifications, and perhaps even the very notion of correctness need to be rethought. Or are they? A strange feeling of deja vue spreads as we see computer science and software engineering rediscovered - this time at your service.               After years of both academic and entrepreneurial experience, Clemens Szyperski has joined\u00a0\u2026", "num_citations": "6\n", "authors": ["743"]}
{"title": "Efficient group communication with guaranteed quality of service\n", "abstract": " A specific class of multimedia applications is expected to be of importance for future communication networks: multi-party interactive multimedia (MIM). Based on the isolation and characterization of MIM applications, concrete network support requirements are derived. The varying degree of connectivity, the vastly different sizes in terms of participants and the reliance on a guaranteed quality of service make MIM support a difficult problem. Starting with the definition of multimedia communication abstractions, principles of solutions are sketched. For an important subclass of applications, a particularly efficient and practicable alternative implementation based on half-duplex channels is introduced. Interfaces at both the transport and network layers are also considered.< >", "num_citations": "6\n", "authors": ["743"]}
{"title": "Write: an extensible text editor for the Oberon system\n", "abstract": " Extensible software systems open the opportunity of reducing complexity by trading offinitial functionality. Instead of building everything into \u00e0 monolythic system, a core system with a certain. built-in potential for later extension is separated from\" an arbitrarily rich set of extensions (and, in principle, extensions of extensions). This report concentrates on the text editor Write and some of its existing extensions. lt is discussed how extensibility is opened but also limited by the core system's design. It is observed that a potentially very rich and flexible basic framework may actually lead to few or no implemented extensions if the chosen model was inadequately complex for the typical extension demands. On the other hand, a too rigid core structure may impose limits preventing useful extensions right from the beginning.", "num_citations": "6\n", "authors": ["743"]}
{"title": "The making of a software engineer challenges for the educator\n", "abstract": " Software engineering is foremost an engineering discipline. Engineering in general and software engineering specifically has to balance many factors to achieve viable tradeoffs - an understanding of the factors as well as the viability criteria is at the heart of the educational challenge. All engineering has one ultimate goal: the delivery of artifacts (products, commercial or not) that meet the needs of those using such artifacts. All engineering lives in the intersection of people, technology, domain, and opportunity aspects. Software engineering, however, is laden with its own specific difficulties. Software as an engineering medium fills a space between the fluidity of digital content, with which software shares the representation, and the nature of machines, with which software shares the flexible and repeatable application.", "num_citations": "5\n", "authors": ["743"]}
{"title": "Efficient support for multiparty communication\n", "abstract": " Communication of multimedia data among multiple parties can be costly in terms of use of network resources if guaranteed quality of service is requested. We believe, however, that knowledge of the functional characteristics of real applications can be helpful to devise new mechanisms to support isochronous communication efficiently. In this paper we follow this approach to introduce a new communication abstraction, called the Half-Duplex Real-Time channel. The new abstraction can reduce the amount of resources needed by real-time protocols to offer guaranteed performance networking by exploiting the interaction patterns typical of multimedia applications such as tele-conferencing and tele-education.", "num_citations": "5\n", "authors": ["743"]}
{"title": "Extensible Object-Orientation\n", "abstract": " Object_oriented languages seem to be ideal to implement extensible systems. However, the fact that extensible systems can never be considered\" closed\" has consequences for the used language and its implementation. The challenge is to master for an open system correctness in general and type safety in particular. The following discussion is based on experiences with the design of the hybrid OOL Oberon_2, and its use to implement the extensible OO document editor Write and the extensible OO operating system Ethos.", "num_citations": "5\n", "authors": ["743"]}
{"title": "Using anchors for reliable stream processing\n", "abstract": " Stream processing can be performed using a pull-based, anchor-based methodology that guarantees once and only once processing and repeatability of the creation of output with no additional communication overhead during normal processing. Each node (computing device) in the graph (representing interconnected computing devices) establishes a system of anchors. An anchor describes a point in the output stream of the node, so that every event in the stream is either before or after any given anchor.", "num_citations": "4\n", "authors": ["743"]}
{"title": "Mode-specific container runtime attachment\n", "abstract": " The operation of a multi-mode application. The multi-mode application has a number of mode-specific logical containers of components. Each mode-specific container contains components that assist the multi-mode application in operating in a corresponding mode. If the application transitions to another mode, the component (s) of the other corresponding mode-specific logical container is used to assist in operating in the other mode. The logical containers may be activated and deactivated during execution time as the application transitions from mode to mode.", "num_citations": "4\n", "authors": ["743"]}
{"title": "Information Systems: Modeling, Development, and Integration: Third International United Information Systems Conference, UNISCON 2009, Sydney, Australia, April 21-24, 2009\u00a0\u2026\n", "abstract": " UNISCON 2009 (United Information Systems Conference) was the third conf-ence in the series that is based on the idea to pool smaller but highly interesting scienti? c events on information systems into one large conference. Here, people from di? erent scienti? c backgrounds can present their research results, share their ideas and discuss future trends in these various areas. UNISCON 2009 was held in Sydney, Australia in the University of Western Sydney, Campbelltown Campus. In 2009 the following scienti? c events were held under the umbrella of UNISCON 2009: th\u20138 International Conference on Information Systems Technology and Its Applications (ISTA 2009) th\u20138 International Workshop on Conceptual Modelling Approaches for e-Business (eCOMO 2009)\u2013Second Workshop on Model-Based Software and Data Integration (MBSDI 2009) We received 115 papers for the three events. Papers were submitted from over 25 countries. After a rigorous review process, 39 papers were accepted as full papers and 14 papers as short papers for presentation at the conference and published in these proceedings. In addition to the above three events, we also organized a Doctoral Cons-tium to provide a forum for doctoral students to get feedback from experts in the area about their research projects.", "num_citations": "4\n", "authors": ["743"]}
{"title": "DESIGN CENTER-The Flexible Factory\n", "abstract": " \u201cCompetition has been shown to be useful up to a certain point and no further, but cooperation\u2026 begins where competition leaves off,\u201d said Franklin Roosevelt. Today, we commonly see solutions composed from multiple software products by systems integrators or suppliers who license modules from other sources. Just as Roosevelt observed so many years ago, cooperation is increasingly important. But how do we arrive at automatically composable solutions?", "num_citations": "4\n", "authors": ["743"]}
{"title": "Retrofitting workflows for B2B component assembly\n", "abstract": " Sudden and significant demand for B2B process automation has seen the entry of workflow management systems (WFMS) into the component arena. Workflows offer highly expressive and graphical process control constructs for the coordinative component assembly, however, current provisions seem more suitable for internal process pipelines in single organizations, built without future reuse in mind. In this paper, we identify particular areas of workflow legacy which obstruct flexible reuse and composition under B2B assembly. New abstractions are identified for the tighter multi-lateral coupling of workflows such that: synchronization is possible across encapsulated workflows boundaries and external interactions occur through blackbox interfaces. Against the stifled efforts of loosely-coupled WFMS interoperability, a top-down architectural strategy is charted, where regulation can occur \"above\" workflow\u00a0\u2026", "num_citations": "4\n", "authors": ["743"]}
{"title": "E cient multicasting for interactive multimedia applications\n", "abstract": " A speci c class of multimedia applications is expected to be of importance for future communication networks: Multi-Party Interactive Multimedia (MIM). Based on the isolation and characterization of MIM applications, concrete network support requirements are derived in this paper. The varying degree of connectivity, the vastly di erent sizes in terms of participants and the reliance on a guaranteed Quality of Service make MIM support a di cult problem. Starting with the de nition of multimedia communication abstractions, principles of solutions are sketched. For an important subclass of applications a particularly e cient and practicable alternative implementation based on half-duplex channels is introduced. Finally, interfaces at both the transport and network layers are considered.", "num_citations": "4\n", "authors": ["743"]}
{"title": "Modular Programming Languages: 7th Joint Modular Languages Conference, JMLC 2006, Oxford, UK, September 13-15, 2006, Proceedings\n", "abstract": " On behalf of the Steering Committee we are pleased to present the proceedings of the 2006 Joint Modular Languages Conference (JMLC), organized by Oxford Brookes University, Oxford, UK and held at Jesus College, Oxford. The mission of JMLC is to explore the concepts of well-structured programming languages and software and those of teaching good design and programming style. JMLC 2006 was the seventh in a series of successful conferences with themes including the construction of large and distributed software systems, and software en-neering aspects in new and dynamic application areas. We were fortunate to have a dedicated Program Committee comprising 41 internationally recognized researchers and industrial practitioners. We received 36 submissions and each paper was reviewed by at least three Program C-mittee members (four for papers with an author on the Program Committee). The entire reviewing process was supported by the OpenConf system. In total, 23 submissions were accepted along with two invited papers and are included in this proceedings volume. For the successful local organization of JMLC we thank Muneera Masterson, Ali McNi? e and Fiona Parker and other sta? and student helpers of Oxford BrookesUniversityaswellasRosemaryFrameandJoKnightonandothersta? of JesusCollege, Oxford. TheproceedingsyounowholdwerepublishedbySpringer and we are grateful for their support. Finally, we must thank the many authors who contributed the high-quality papers contained within these proceedings.", "num_citations": "3\n", "authors": ["743"]}
{"title": "Component-based development? refining the blueprint\n", "abstract": " Beyond Objects Component-Based Software Engineering (Smith) As the speed of change in both business and technology increases, post Y2K, it's becoming increasingly clear that software development needs to move from a craft activity to a modern industrial process capable of using componentization to reduce cost and time-to-market. The Windows 2000 and Enterprise JavaBeans platforms are arguably the first mature platforms specifically designed to support enterprise scale component-based applications. Over the next few years, most new applications will be delivered onto one or the other of these platforms. The new component-based platforms are also being complemented by widespread adoption of XML (eXtensible Markup Language) as an internal and external interoperability backplane, which enables heterogeneous component connectivity. Specific issues that will be addressed by the panel include\u00a0\u2026", "num_citations": "3\n", "authors": ["743"]}
{"title": "Can Component Object Model (COM) be Formalized?-The Formal \u0116emantics of the COMEL Language\n", "abstract": " This paper presents an approach to formalize COM. Despite its importance, COM still does not have a formal specification. In order to understand the COM's informal rules better, the COMEL language is being introduced. We formalized some of the important COM's rules and present COMEL's abstract syntax, formal semantics and subject reduction theorem.", "num_citations": "3\n", "authors": ["743"]}
{"title": "Recycling in gardens: E cient memory management for a parallel system\n", "abstract": " Gardens is a system which supports parallel computation across networks of workstations. This is achieved by over decomposing a program into more tasks than there are processors. Tasks have separate heaps which comprise partitions (segments) of a global address space. Gardens supports a modern object oriented programming language which requires garbage collection. Furthermore since tasks may be dynamically created, heap segments and tasks must also be garbage collected. Performance is the goal of Gardens, therefore the garbage collector must be very e cient. To this end Gardens adopts a radical strategy of only supporting very e cient global garbage collection. Unlike other systems local garbage collection is not supported; this means no book-keeping overheads are incurred to support this. The Gardens garbage collector collects cells within task heap segments, task heap segments and tasks. This paper presents the Gardens memory management model, its implementation and some preliminary performance gures.", "num_citations": "3\n", "authors": ["743"]}
{"title": "Big data processing at microsoft: Hyper scale, massive complexity, and minimal cost\n", "abstract": " The past decade has seen a tremendous interest in large-scale data processing at Microsoft. Typical scenarios include building business-critical pipelines such as advertiser feedback loop, index builder, and relevance/ranking algorithms for Bing; analyzing user experience telemetry for Office, Windows or Xbox; and gathering recommendations for products like Windows and Xbox. To address these needs a first-party big data analytics platform, referred to as Cosmos, was developed in the early 2010s at Microsoft. Cosmos makes it possible to store data at exabyte scale and process in a serverless form factor, with SCOPE [4] being the query processing workhorse. Over time, however, several newer challenges have emerged, requiring major technical innovations in Cosmos to meet these newer demands. In this abstract, we describe three such challenges from the query processing viewpoint, and our approaches\u00a0\u2026", "num_citations": "2\n", "authors": ["743"]}
{"title": "Enterprise Interoperability\n", "abstract": " Several developments are expected to change the nature and affect the operation of enterprises in the near future. These developments are not new, and their influence when considered in isolation may not be decisive, but combined they represent important challenges as well as opportunities. Globalization, as one of the most important drivers of modern times, continues to influence enterprises and makes the boundaries for enterprise operation increasingly disappear. Constant and rapid change in technological capabilities, consumer demands, and legal/regulatory constraints push enterprises to become more agile and adaptive. The ability to create and offer value-added services by anyone to anyone has blurred the distinction between the consumer role and producer role, and between the employee role and employer role. One conclusion to be drawn from these developments is that the success of an enterprise more and more depends on its ability to interoperate with other enterprises, of any size and in any place. Enterprises have to function in dynamic networks, with value being created in both directions, in order to stay competitive and achieve their business goals. The design of information, services, and processes is of key importance for enterprises in an increasingly interoperation-demanding economy and society. Information that is exchanged needs to be correctly understood at the recipient end; processes that receive, process, and send information need to do this in a way that realizes the interoperation goals; and services need to properly represent such interoperation goals to customers as well as to remote processes. This\u00a0\u2026", "num_citations": "2\n", "authors": ["743"]}
{"title": "Iterative component binding\n", "abstract": " Component domains used to define a binding between various components associated with the component domain. The component domain tracks the various services to be imported by each component, and tracks the various services exported by each component. At runtime, rather than at compile time, the various interrelations between the components are bound using the service import and export data. Accordingly, depending on the components available and their characteristics, the bindings may differ. This permits applications to be much more flexible. In one implementation, the binding is performed iteratively. For example, if after one iteration of binding service imports to service exports, some components may expand the services that they export, or the services that they desire to import.", "num_citations": "2\n", "authors": ["743"]}
{"title": "Lecture Notes in Business Information Processing 325\n", "abstract": " The following preface is a collection of the prefaces of the post-workshop proceedings of the individual workshops. The workshop papers, grouped by event, form the body of the volume.", "num_citations": "2\n", "authors": ["743"]}
{"title": "CoCoME Jury Evaluation and Conclusion\n", "abstract": " The CoCoME Jury attended the two-day seminar with presentations from all participating teams. The jury provided individual feedback to each of the teams. This chapter is an attempt at both organizing the contributions into groups of related themes and summarizing some of the more salient feedback. The jury concludes with a few observations about the CoCoME contest as such and its overall outcome.", "num_citations": "2\n", "authors": ["743"]}
{"title": "Architecting Systems with Trustworthy Components: International Seminar, Dagstuhl Castle, Germany, December 12-17, 2004. Revised Selected Papers\n", "abstract": " This book constitutes the thoroughly refereed post-proceedings of the International Dagstuhl-Seminar on Architecting Systems with Trustworthy Components, held in Dagstuhl Castle, Germany, in December 2004. Presents 10 revised full papers together with 5 invited papers contributed by outstanding researchers. Discusses core problems in measurement and normalization of non-functional properties, modular reasoning over non-functional properties, capture of component requirements in interfaces and protocols, interference and synergy of top-down and bottom-up aspects, and more.", "num_citations": "2\n", "authors": ["743"]}
{"title": "Product Focused Software Process Improvement: 6th International Conference, PROFES 2005, Oulu, Finland, June 13-18, 2005, Proceedings\n", "abstract": " On behalf of the PROFES Organizing Committee we are proud to present to you the proceedings of the 6th International Conference on Product Focused Software Process Improvement (PROFES 2005), held in Oulu, Finland. Since 1999, PROFES has established itself as one of the recognized inter-tional software process improvement conferences. Thepurposeoftheconferenceistobringtolightthemostrecent? ndingsand results in the area and to stimulate discussion between researchers, experienced professionals, andtechnologyproviders. Thelargenumberofparticipantscoming from industry con? rms that the conference provides a variety of up-to-date t-ics and tackles industry problems. The main theme of PROFES is professional software process improvement (SPI) motivated by product and service quality needs. SPI is facilitated by software process assessment, software measurement, process modeling, and technology transfer. It has become a practical tool for quality software engineering and management. The conference addresses both the solutions found in practice and the relevant research results from academia. This is re? ected in the 42 full papers, which are\u2013as in the years before\u2013a well-balanced mix of academic papers as well as industrial experience reports. The business of developing new applications like mobile and Internet services orenhancingthefunctionalityofavarietyofproductsusingembeddedsoftwareis rapidlygrowing, maturingandmeetingtheharshbusinessrealities. Theaccepted papers focusing on wireless and the Internet are grouped into a special \u201cmobile and wireless\u201d session. WewishtothankVTTElectronics\u00a0\u2026", "num_citations": "2\n", "authors": ["743"]}
{"title": "Industrial and economic properties of software: Technology, processes\n", "abstract": " Software technology and its related activities are examined from an industrial and economic perspective. More specifically, the distinct characteristics of software from the perspective of the end-user, the software engineer, the operational manager, the intellectual property lawyer, the owner, and the economist are identified. The overlaps and relationships among these perspectives are discussed, organized around three primary issues: technology, processes, and value relationships. Examples of the specific issues identified are licensing vs. service provider models, alternative terms and conditions of licensing, distinct roles in the supplier value chain (development, provisioning, operation, and use) and requirements value chain (user needs and requirements), and the relationship of these issues to industrial organization and pricing. The characteristics of software as an economic good and how they differ from\u00a0\u2026", "num_citations": "2\n", "authors": ["743"]}
{"title": "Mianjin: A parallel language with a type system that governs global system behaviour\n", "abstract": " For the past few years we have been working on a parallel programming language, Mianjin, suitable for writing parallel programs for non-dedicated networks of workstations. This paper reviews an innovative feature of the language, a type system that statically enforces global system behaviour. This is achieved by typing the behaviour of commands, thereby differentiating commands that may admit communication from those that do not. Doing this guarantees safe asynchronous communications; in particular it prevents deadlocks caused by exhaustion of system-level communication resources (such as buffers) which are beyond an application programmer\u2019s control. These command types propagate though client and library code thereby simplifying some problems associated with constructing software components. The type system is semi-formally described using type rules, and some further applications of\u00a0\u2026", "num_citations": "2\n", "authors": ["743"]}
{"title": "Gardens: High performance objects, tasking and migration for cluster computing\n", "abstract": " Gardens is an integrated programming language and system which supports ecient parallel computation across workstation clusters. In particular it addresses the three goals of: high performance, adaptive parallelism and abstraction. High performance is the goal of parallel computing, and abstraction simpli es programming. Adaptive parallelism entails a program adapting during its execution to utilise a changing set of otherwise idle workstations. Tasks are used as units of work, and task migration to realise adaptive parallelism. Tasking is non-preemptive; compared to preemptive tasking this leads to simpler programming and greater e ciency. Global objects are used for inter-task communication. These support abstraction and importantly directly map to active messages: a very e cient messaging system. These features of Gardens are tightly integrated yet orthogonal.", "num_citations": "2\n", "authors": ["743"]}
{"title": "Microsoft codename\" Montego\" data import, transformation, and publication for information workers\n", "abstract": " A fundamental problem in database systems is deriving useful information from untold quantities of data fragments that exist in the web's data stores. Data is abundant, useful information is rare. This problem space plays host to many successful and innovative solutions from industry (e.g., [2, 4, 5, 9]), and the open-source community (e.g., [11]). Each solution has its strengths and weaknesses based their balance of utility and usability. In this paper, we demonstrate the unique approach to data mashups that Microsoft Codename \"Montego\" brings to the space. The \"Montego\" tool allows non-technical users to create complex data queries in a familiar graphical environment, while making the full expressiveness of a query language available to professional users. \"Montego\" operates both as a standalone client, where a user can launch it from an application like Excel\u00ae to import and manipulate data into a spreadsheet\u00a0\u2026", "num_citations": "1\n", "authors": ["743"]}
{"title": "The. NET Primitives for Open, Dynamic and Reflective Component Frameworks\n", "abstract": " \u201cComposition Primitives\u201d is a novel component model targeting .NET. The model facilitates composition across component programming frameworks via an adaptation mechanism external to the component. Constructing adapters is relatively inexpensive, because the model is minimal and focused on just one concern: offering enough information to support composition. Although small, the model supports static discovery of the services provided and consumed by a component\u2014in other words, it is reflective. To strengthen the value of its reflection capabilities, it purposely does not rely on the Service Locator pattern and it supports n\u2013order composition scenarios. In this paper, we present our model and support our claims.", "num_citations": "1\n", "authors": ["743"]}
{"title": "Business Information Systems\n", "abstract": " This book contains the refereed proceedings of the 12th International Conference on Business Information Systems, BIS 2009, held in Poznan, Poland, in april 2009.  The 22 revised full papers were carefully reviewed and selected from 74 submissions.  Following the theme of the conference \"Information Systems for Agile Organizations\", the contributions illustrate recent tendencies in making organizations more adaptive  and responsive with respect to changing external conditions. They are grouped in sections on ontologies in organizations, ontologies and security, Web search, process modelling, process analysis and mining, service-oriented architecture, and enterprise resource planning.  Researchers in academia and industry", "num_citations": "1\n", "authors": ["743"]}
{"title": "The making of a software engineer\n", "abstract": " Software engineering is foremost an engineering discipline. Engineering in general and software engineering specifically has to balance many factors to achieve viable tradeoffs\u2013an understanding of the factors as well as the viability criteria is at the heart of the educational challenge. All engineering has one ultimate goal: the delivery of artifacts (products, commercial or not) that meet the needs of those using such artifacts. All engineering lives in the intersection of people, technology, domain, and opportunity aspects. Software engineering, however, is laden with its own specific difficulties. Software as an engineering medium fills a space between the fluidity of digital content, with which software shares the representation, and the nature of machines, with which software shares the flexible and repeatable application. This brief article covers some of the author\u2019s personal observations and suggestions with a\u00a0\u2026", "num_citations": "1\n", "authors": ["743"]}
{"title": "Rethinking our trade and science: from developing components to component-based development\n", "abstract": " Almost all of traditional software engineering and applied computer science focuses on some kind of deliverable of supposedly closed nature. While traditional applications aren\u2019t really closed (they interact with other applications, middleware, and the operating system), the closed-world assumption is nevertheless a sufficiently useful approximation to enable the production of successful software. Shifting the emphasis from the production of the one deliverable to the production of systems that are composed out of components has an almost traumatic consequence. A lot of what we know about how to build software requires revision and sometimes radical departure from the established past. This talk spans much of the spectrum from why components are a good idea to why we need to rethink our trade and science to what approaches are now emerging to make all this possible.", "num_citations": "1\n", "authors": ["743"]}
{"title": "High Performance Computing on Clusters?\n", "abstract": " The history of computing has always also been a history of hunting for higher performance. Until recently it was accepted that to go beyond the current sweet spot in terms of performance per money of available machines, it was required to invest. In fact, to invest enormously. While dedicated high end machines still have their place, and probably always will, the construction of special machines close to the top and that of clusters of less dramatic machines co-evolved to something quite comparable. As a result, engineering sparks could bridge the gab and we now find high-performance system area and even local area networks that derive from the backbone communication infrastructure of massively parallel supercomputers.", "num_citations": "1\n", "authors": ["743"]}
{"title": "Discovery and use of independently developed objects in distributed systems\n", "abstract": " The recent realisation of global computer network connectivity has provided the opportunity to exploit the use of remote services. The use of distributed services poses problems which do not occur in centralised systems. To fully utilise a distributed system the ability to substitute compatible services is required due to the transient nature of some services. The independent development of distributed services makes it difficult to derive useful relationships between these services and produces inevitable incompatibilities between their interfaces. The work presented here describes an information model and evaluation service which overcomes these difficulties. The model uses behavioural information to determine which relationships exist between services. The evaluation system uses the information to determine compatibility and how to overcome interface incompatibilities. A detailed description of the model, how it\u00a0\u2026", "num_citations": "1\n", "authors": ["743"]}
{"title": "The Gardens Prototype: An Extensible Architecture Supporting Adaptive Parallel Computation\n", "abstract": " The Gardens system is designed to create a virtual high performance computer from a network of idle workstations. The network presents a dynamic set of idle workstations to the Gardens system. Therefore Gardens must e ciently support adaptive parallel computation. Furthermore to support experimentation and di erent paradigms of parallel computation, requiring customised policies, the Gardens system is extensible. That is it has a component-oriented architecture supporting plug-in system components, such as schedulers and load balancers.", "num_citations": "1\n", "authors": ["743"]}
{"title": "Guaranteed quality of service for efficient multiparty communication\n", "abstract": " Communication of multimedia data among multiple parties can be costly in terms of the use of network resources if guaranteed quality of service is requested. We believe, however, that knowledge of the functional characteristics of real applications can be helpful in devising new mechanisms to support isochronous communication efficiently. In this paper, we follow this approach to introduce a new communication abstraction, called the half-duplex real-time channel. The new abstraction can reduce the resources needed by real-time protocols to offer guaranteed performance networking by exploiting the interaction patterns typical of multimedia applications such as teleconferencing and teleeducation.", "num_citations": "1\n", "authors": ["743"]}
{"title": "Network communication in the Oberon environment\n", "abstract": " dspace cover page Page 1 Research Collection Report Network communication in the Oberon environment Author(s): Szyperski, Clemens A. Publication Date: 1990-02 Permanent Link: https://doi.org/10.3929/ethz-a-000534271 Rights / License: In Copyright - Non-Commercial Use Permitted This page was generated automatically upon download from the ETH Zurich Research Collection. For more information please consult the Terms of use. ETH Library Page 2 Page 3 Page 4 Page 5 Page 6 Page 7 Page 8 Page 9 Page 10 Page 11 Page 12 Page 13 Page 14 Page 15 Page 16 Page 17 Page 18 Page 19 Page 20 Page 21 Page 22 Page 23 Page 24 Page 25 Page 26 Page 27 Page 28 Page 29 Page 30 Page 31 Page 32 Page 33 Page 34 Page 35 Page 36 Page 37 Page 38 Page 39 Page 40 Page 41 Page 42 Page 43 Page 44 \u2026", "num_citations": "1\n", "authors": ["743"]}