{"title": "Distance hijacking attacks on distance bounding protocols\n", "abstract": " After several years of theoretical research on distance bounding protocols, the first implementations of such protocols have recently started to appear. These protocols are typically analyzed with respect to three types of attacks, which are historically known as Distance Fraud, Mafia Fraud, and Terrorist Fraud. We define and analyze a fourth main type of attack on distance bounding protocols, called Distance Hijacking. This type of attack poses a serious threat in many practical scenarios. We show that many proposed distance bounding protocols are vulnerable to Distance Hijacking, and we propose solutions to make these protocols resilient to this type of attack. We show that verifying distance bounding protocols using existing informal and formal frameworks does not guarantee the absence of Distance Hijacking attacks. We extend a formal framework for reasoning about distance bounding protocols to include\u00a0\u2026", "num_citations": "186\n", "authors": ["1772"]}
{"title": "EasyCrypt: A Tutorial\n", "abstract": " Cryptography plays a key role in the security of modern communication and computer infrastructures; therefore, it is of paramount importance to design cryptographic systems that yield strong security guarantees. To achieve this goal, cryptographic systems are supported by security proofs that establish an upper bound for the probability that a resource-constrained adversary is able to break the cryptographic system. In most cases, security proofs are reductionist, i.e. they construct from an (arbitrary but computationally bounded) adversary that would break the security of the cryptographic construction with some reasonable probability another computationally bounded adversary that would break a hardness assumption with reasonable probability. This approach, known as provable security, is in principle able to deliver rigorous and detailed mathematical proofs. However, new cryptographic designs (and\u00a0\u2026", "num_citations": "143\n", "authors": ["1772"]}
{"title": "Jasmin: High-assurance and high-speed cryptography\n", "abstract": " Jasmin is a framework for developing high-speed and high-assurance cryptographic software. The framework is structured around the Jasmin programming language and its compiler. The language is designed for enhancing portability of programs and for simplifying verification tasks. The compiler is designed to achieve predictability and efficiency of the output code (currently limited to x64 platforms), and is formally verified in the Coq proof assistant. Using the supercop framework, we evaluate the Jasmin compiler on representative cryptographic routines and conclude that the code generated by the compiler is as efficient as fast, hand-crafted, implementations. Moreover, the framework includes highly automated tools for proving memory safety and constant-time security (for protecting against cache-based timing attacks). We also demonstrate the effectiveness of the verification tools on a large set of cryptographic\u00a0\u2026", "num_citations": "86\n", "authors": ["1772"]}
{"title": "Fully automated analysis of padding-based encryption in the computational model\n", "abstract": " Computer-aided verification provides effective means of analyzing the security of cryptographic primitives. However, it has remained a challenge to achieve fully automated analyses yielding guarantees that hold against computational (rather than symbolic) attacks. This paper meets this challenge for public-key encryption schemes built from trapdoor permutations and hash functions. Using a novel combination of techniques from computational and symbolic cryptography, we present proof systems for analyzing the chosen-plaintext and chosen-ciphertext security of such schemes in the random oracle model. Building on these proof systems, we develop a toolset that bundles together fully automated proof and attack finding algorithms. We use this toolset to build a comprehensive database of encryption schemes that records attacks against insecure schemes, and proofs with concrete bounds for secure ones.", "num_citations": "48\n", "authors": ["1772"]}
{"title": "Key confirmation in key exchange: A formal treatment and implications for TLS 1.3\n", "abstract": " Key exchange protocols allow two parties at remote locations to compute a shared secret key. The common security notions for such protocols are secrecy and authenticity, but many widely deployed protocols and standards name another property, called key confirmation, as a major design goal. This property should guarantee that a party in the key exchange protocol is assured that another party also holds the shared key. Remarkably, while secrecy and authenticity definitions have been studied extensively, key confirmation has been treated rather informally so far. In this work, we provide the first rigorous formalization of key confirmation, leveraging the game-based security framework well-established for secrecy and authentication notions for key exchange. We define two flavors of key confirmation, full and almost-full key confirmation, taking into account the inevitable asymmetry of the roles of the parties with\u00a0\u2026", "num_citations": "43\n", "authors": ["1772"]}
{"title": "Formal analysis of key exchange protocols and physical protocols\n", "abstract": " A security protocol is a distributed program that might be executed on a network controlled by an adversary. Even in such a setting, the protocol should satisfy the desired security property. Since it is hard to consider all possible executions when designing a protocol, formal methods are often used to ensure the correctness of a protocol with respect to a model of the protocol and the adversary. Many such formal models use a symbolic abstraction of cryptographic operators by terms in a term algebra. The properties of these operators can then be modeled by equations. In this setting, we make the following contributions:1. We present a general approach for the automated symbolic analysis of security protocols that use Diffie-Hellman exponentiation and bilinear pairings to achieve advanced security properties. We model protocols as multiset rewriting systems and security properties as first-order formulas. We analyze them using a novel constraint-solving algorithm that supports both falsification and verification, even in the presence of an unbounded number of protocol sessions. The algorithm exploits the finite variant property and builds on ideas from strand spaces and proof normal forms. We demonstrate the scope and the effectiveness of our algorithm on non-trivial case studies. For example, the algorithm successfully verifies the NAXOS protocol with respect to a symbolic version of the eCK security model.", "num_citations": "43\n", "authors": ["1772"]}
{"title": "Machine-checked proofs of privacy for electronic voting protocols\n", "abstract": " We provide the first machine-checked proof of privacy-related properties (including ballot privacy) for an electronic voting protocol in the computational model. We target the popular Helios family of voting protocols, for which we identify appropriate levels of abstractions to allow the simplification and convenient reuse of proof steps across many variations of the voting scheme. The resulting framework enables machine-checked security proofs for several hundred variants of Helios and should serve as a stepping stone for the analysis of further variations of the scheme. In addition, we highlight some of the lessons learned regarding the gap between pen-and-paper and machine-checked proofs, and report on the experience with formalizing the security of protocols at this scale.", "num_citations": "26\n", "authors": ["1772"]}
{"title": "Mind the Gap: Modular Machine-Checked Proofs of One-Round Key Exchange Protocols\n", "abstract": " Using EasyCrypt, we formalize a new modular security proof for one-round authenticated key exchange protocols in the random oracle model. Our proof improves earlier work by Kudla and Paterson (ASIACRYPT 2005) in three significant ways: we consider a stronger adversary model, we provide support tailored to protocols that utilize the  trick, and we support proofs under the Computational DH assumption not relying on Gap oracles. Furthermore, our modular proof can be used to obtain concrete security proofs for protocols with or without adversarial key registration. We use this support to investigate, still using EasyCrypt, the connection between proofs without Gap assumptions and adversarial key registration. For the case of honestly generated keys, we obtain the first proofs of the  and  protocols under the Computational DH assumption. For the case of adversarial key registration, we obtain\u00a0\u2026", "num_citations": "26\n", "authors": ["1772"]}
{"title": "Automated proofs of pairing-based cryptography\n", "abstract": " Analyzing cryptographic constructions in the computational model, or simply verifying the correctness of security proofs, are complex and error-prone tasks. Although computer tools have significant potential to increase confidence in security proofs and to reduce the time for building these proofs, existing tools are either limited in scope, or can only be used by formal methods experts, and have a significant overhead. In effect, it has remained a challenge to design usable and intuitive tools for building and verifying cryptographic proofs, especially for more advanced fields such as pairing-based or lattice-based cryptography.", "num_citations": "24\n", "authors": ["1772"]}
{"title": "Generic Transformations of Predicate Encodings: Constructions and Applications.\n", "abstract": " Predicate encodings (Wee, TCC 2014; Chen, Gay, Wee, EUROCRYPT 2015), are symmetric primitives that can be used for building predicate encryption schemes. We give an algebraic characterization of the notion of privacy from predicate encodings, and explore several of its consequences. Specifically, we propose more efficient predicate encodings for boolean formulae and arithmetic span programs, and generic optimizations of predicate encodings. We define new constructions to build boolean combination of predicate encodings. We formalize the relationship between predicate encodings and pair encodings (Attrapadung, EUROCRYPT 2014), another primitive that can be transformed generically into predicate encryption schemes, and compare our constructions for boolean combinations of pair encodings with existing similar constructions from pair encodings. Finally, we demonstrate that our\u00a0\u2026", "num_citations": "22\n", "authors": ["1772"]}
{"title": "Automated unbounded analysis of cryptographic constructions in the generic group model\n", "abstract": " We develop a new method to automatically prove security statements in the Generic Group Model as they occur in actual papers. We start by defining (i) a general language to describe security definitions, (ii) a class of logical formulas that characterize how an adversary can win, and (iii) a translation from security definitions to such formulas. We prove a Master Theorem that relates the security of the construction to the existence of a solution for the associated logical formulas. Moreover, we define a constraint solving algorithm that proves the security of a construction by proving the absence of solutions.               We implement our approach in a fully automated tool, the \u00a0tool, and use it to verify different examples from the literature. The results improve on the tool by Barthe et al. (CRYPTO\u201914, PKC\u201915): for many constructions, \u00a0succeeds in proving standard (unbounded) security, whereas Barthe\u2019s tool is\u00a0\u2026", "num_citations": "18\n", "authors": ["1772"]}
{"title": "Certified synthesis of efficient batch verifiers\n", "abstract": " Many algorithms admit very efficient batch versions that compute simultaneously the output of the algorithms on a set of inputs. Batch algorithms are widely used in cryptography, especially in the setting of pairing-based computations, where they deliver significant speed-ups. AutoBatch is an automated tool that computes highly optimized batch verification algorithms for pairing-based signature schemes. Thanks to finely tuned heuristics, AutoBatch is able to rediscover efficient batch verifiers for several signature schemes of interest, and in some cases to output batch verifiers that outperform the best known verifiers from the literature. However, AutoBatch only provides weak guarantees (in the form of a LaTeX proof) of the correctness of the batch algorithms it outputs. In this paper, we verify the correctness and security of these algorithms using the EasyCrypt framework. To achieve this goal, we define a domain\u00a0\u2026", "num_citations": "8\n", "authors": ["1772"]}
{"title": "Application Layer Transport Security\n", "abstract": " \u25cf Transparency:\u25cb All RPCs are ALTS-secured by default\u25cb No need to worry about credential management or security configurations\u25cb Peer information propagated to application for authorization\u25cf State-of-the-art cryptography:\u25cb AES-GCM with auto-rekeying\u25cb Google controls ALTS: crypto protocols are easily upgraded and deployed\u25cf Identity model:", "num_citations": "4\n", "authors": ["1772"]}
{"title": "Computer-aided cryptography: some tools and applications\n", "abstract": " The goal of modern cryptography is to design efficient constructions that simultaneously achieve some desired functionality and provable security against resource-bounded adversaries. Over the years, the realm of cryptography has expanded from basic functionalities such as encryption, authentication and key agreement, to elaborate functionalities such as zero-knowledge protocols, secure multi-party computation, and more recently verifiable computation. In many cases, these elaborate functionalities can only be achieved through cryptographic systems, in which several elementary constructions interact. As a consequence of the evolution towards more complex functionalities, cryptographic proofs have become significantly more involved, and more difficult to check. Several cryptographers have therefore advocated the use of tool-supported frameworks for building and verifying proofs; the most vivid\u00a0\u2026", "num_citations": "1\n", "authors": ["1772"]}