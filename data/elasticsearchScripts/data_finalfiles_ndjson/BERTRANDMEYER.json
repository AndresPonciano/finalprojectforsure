{"title": "Object-oriented software construction\n", "abstract": " Born in the ice-blue waters of the festooned Norwegian coast; amplified (by an aberration of world currents, for which marine geographers have yet to find a suitable explanation) along the much grayer range of the Californian Pacific; viewed by some as a typhoon, by some as a tsunami, and by some as a storm in a teacup\u0393\u00c7\u00f6a tidal wave is hitting the shores of the computing world.\u0393\u00c7\u00a3Object-oriented\u0393\u00c7\u00a5 is the latest in term, complementing and in many cases replacing \u0393\u00c7\u00a3structured\u0393\u00c7\u00a5 as the high-tech version of \u0393\u00c7\u00a3good\u0393\u00c7\u00a5. As is inevitable in such a case, the term is used by different people with different meanings; just as inevitable is the well-known three-step sequence of reactions that meets the introduction of a new methodological principle:(1)\u0393\u00c7\u00a3it\u0393\u00c7\u00d6s trivial\u0393\u00c7\u00a5;(2)\u0393\u00c7\u00a3it cannot work\u0393\u00c7\u00a5;(3)\u0393\u00c7\u00a3that\u0393\u00c7\u00d6s how I did it all along anyway\u0393\u00c7\u00a5.(The order may vary.)", "num_citations": "10949\n", "authors": ["32"]}
{"title": "Applying \"Design by Contract\"\n", "abstract": " Methodological guidelines for object-oriented software construction that improve the reliability of the resulting software systems are presented. It is shown that the object-oriented techniques rely on the theory of design by contract, which underlies the design of the Eiffel analysis, design, and programming language and of the supporting libraries, from which a number of examples are drawn. The theory of contract design and the role of assertions in that theory are discussed.< >", "num_citations": "3237\n", "authors": ["32"]}
{"title": "Eiffel: the language\n", "abstract": " Eiffel: the language | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksEiffel: the language Export Citation Select Citation format Download citation Copy citation Categories Journals Magazines Books Proceedings SIGs Conferences Collections People About About ACM Digital Library Subscription Information Author Guidelines Using ACM Digital Library All Holdings within the ACM Digital Library ACM Computing Classification System Join Join ACM Join SIGs Subscribe to Publications Institutions and Libraries Connect Contact Facebook Twitter Linkedin The ACM Digital Library is published by the Association for . \u252c\u2310 \u0393\u00c7\u00aa", "num_citations": "2543\n", "authors": ["32"]}
{"title": "Reusability: The case for object-oriented design\n", "abstract": " Simply being more organized will not make the reuse problem go away. The issues are technical, not managerial. The answers lie in object-oriented design.", "num_citations": "546\n", "authors": ["32"]}
{"title": "Design by Contract: The lessons of Ariane\n", "abstract": " Design by contract is the principle that the interfaces between modules of a software system-especially a mission-critical one-should be governed by precise specifications. The contracts cover mutual obligations (pre-conditions), benefits (post-conditions), and consistency constraints (invariants). Together, these properties are known as assertions, and are directly supported in some design and programming languages. A recent $500 million software error provides a sobering reminder that this principle is not just a pleasant academic ideal. On June 4, 1996, the maiden flight of the European Ariane 5 launcher crashed, about 40 seconds after takeoff. The rocket was uninsured. The French space agency, CNES (Centre National d'Etudes Spatiales), and the European Space Agency (ESA) immediately appointed an international inquiry board. The board makes several recommendations with respect to software\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "386\n", "authors": ["32"]}
{"title": "Reusable software: the Base object-oriented component libraries\n", "abstract": " Doug McIlroy first discussed reuse as being the way forward in software construction in a brilliant paper published over 25 years ago [1]. As long as software developers spend their time producing endless individual variants of the same basic software patterns, the state of software construction is unlikely to change much. Despite this urgent need for software reuse, few practical references exist for those who are interested in reusable software and are looking for advice on how to use it. This book is a significant contribution in this area. The author introduces reusable software components and lays bare his experience in the development and use of those modules. The components described cover some of the basic software development patterns for any application area. The name \u0393\u00c7\u00a3Base libraries\u0393\u00c7\u00a5 covers several thousand re usable classes, grouped into clusters. The clusters are then grouped as five libraries: kernel\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "301\n", "authors": ["32"]}
{"title": "Introduction to the Theory of Programming Languages\n", "abstract": " Programming language theory is an unusual case in the domain of theoretical computer science, being an almost perfect example of the kind of bridges that can exist between theory and practice by going from the realm of the very abstract mathematical concepts of semantics to their practical implications in software engineering. Moreover, programming languages are so central to computer science that one could almost assert that system design amounts to programming language design. Every user or program interface is defined by a small language, whether concrete, as in button clicks or shell commands, or abstract, as in module specifications. The approach taken here is a gentle introduction, at the undergraduate level, to the various facets of this fascinating domain, presenting the major contributions and their implications for a better understanding and mastery of programs. The first two chapters present the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "281\n", "authors": ["32"]}
{"title": "Systematic concurrent object-oriented programming\n", "abstract": " SYSTEMATIC CONCURRENT OBJECT-ORIENTED PROGRAMMING udging by the looks of the two parties, the marriage between concurrent computation and object-oriented programming--a union much desired by practitioners in such fields as telecommunications, highperformance computing, banking and operating systems--appears easy enough to arrange. This appearance, however, is deceptive: the problem is a hard one. This article points the way toward a pos,; ible solution. The precise problem examined here is restricted to:", "num_citations": "277\n", "authors": ["32"]}
{"title": "The grand challenge of trusted components\n", "abstract": " Reusable components equipped with strict guarantees of quality can help reestablish software development on a stronger footing, by taking advantage of the scaling effect of reuse to justify the extra effort of ensuring impeccable quality. This discussion examines work intended to help the concept of Trusted Component brings its full potential to the software industry, along two complementary directions: a \"low road\" leading to qualification of existing components, and a \"high road\" aimed at the production of components with fully proved correctness properties.", "num_citations": "261\n", "authors": ["32"]}
{"title": "ARTOO: adaptive random testing for object-oriented software\n", "abstract": " Intuition is often not a good guide to know which testing strategies will work best. There is no substitute for experimental analysis based on objective criteria: how many faults a strategy finds, and how fast.\" Random\" testing is an example of an idea that intuitively seems simplistic or even dumb, but when assessed through such criteria can yield better results than seemingly smarter strategies. The efficiency of random testing is improved if the generated inputs are evenly spread across the input domain. This is the idea of Adaptive Random Testing (ART).", "num_citations": "248\n", "authors": ["32"]}
{"title": "Genericity versus inheritance\n", "abstract": " Genericity, as in Ada or ML, and inheritance, as in object-oriented languages, are two alternative techniques for ensuring better extendibility, reusability and compatibility of software components. This article is a comparative analysis of these two methods. It studies their similarities and differences and assesses to what extent each may be simulated in a language offering only the other. It shows what features are needed to successfully combine the two approaches in a statically typed language and presents the main features of the programming language Eiffel, whose design, resulting in part from this study, includes multiple inheritance and limited form of genericity under full static typing.", "num_citations": "234\n", "authors": ["32"]}
{"title": "Objektorientierte Softwareentwicklung\n", "abstract": " Objektorientierte Softwareentwicklung Page 1 SS 2013 Objektorientierte Softwareentwicklung Prof. Dr. Andreas Weber Durchschnittsnote: 2.6 Teilnehmer (ausgewertete Frageb\u251c\u2562gen): 32 \u0393\u00c7\u00f3 Bachelor: 24 \u0393\u00c7\u00f3 Master: 0 \u0393\u00c7\u00f3 Diplom: 0 \u0393\u00c7\u00f3 Lehramt: 1 \u0393\u00c7\u00f3 Nebenfach: 2 \u0393\u00c7\u00f3 FFF: 5 1 Bitte beurteile die Gestaltung der Veranstaltung durch die Dozentin / den Dozenten. ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A Verst\u251c\u00f1ndlichkeit der Darstellung der Inhalte 0 5 10 15 2 18 9 1 2 ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A Struktur (roter Faden) der Inhalte 0 5 10 15 2 18 8 1 3 ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A Qualit\u251c\u00f1t der Lehrmaterialien (Folien, \u251c\u00a3bungsbl\u251c\u00f1tter, Skript, ...) 0 5 10 15 6 17 6 1 2 ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A N\u251c\u255dtzlichkeit der Lehrmaterialien zur Vor\u0393\u00ea\u00c6/Nachbereitung 0 5 10 15 3 16 8 1 4 ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A Veranschaulichung der Inhalte durch Beispiele 0 5 10 15 2 16 8 2 4 ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A Verst\u251c\u00f1ndlichkeit der Aussprache der Dozentin / des Dozenten 0 5 10 15 5 13 11 2 1 ++ + \u0393\u00ea\u00c6 \u0393\u00ea\u00c6\u0393\u00ea\u00c6 N/A Erkennbarkeit der fachlichen Kompetenz der / +\u0393\u00c7\u00aa", "num_citations": "226\n", "authors": ["32"]}
{"title": "Lessons from the design of the Eiffel libraries\n", "abstract": " The nature of programming is changing. Most of the software engineering literature still takes for granted a world of individual projects, where the sole aim is to produce specific software systems in response to particular requirements, little attention being paid to each system's relationship to previous or subsequent efforts. This implicit model seems unlikely to allow drastic improvements in software quality and productivity. Such order-of-magnitude advances will require a process of industrialization, not unlike what happened in those disciplines which have been successful at establishing a production process based on the reuse of quality-standardized components. This implies a shift to a \u0393\u00c7\u00a3new culture\u0393\u00c7\u00a5 [14] whose emphasis is not on projects but instead on components. The need for such a shift was cogently expressed more than 20 years ago by Doug McIlroy in his contribution, entitled Mass-Produced Software\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "201\n", "authors": ["32"]}
{"title": "M\u251c\u2310thodes de programmation\n", "abstract": " Ce livre sur la s\u251c\u2310curit\u251c\u2310 sous Windows Vista pr\u251c\u2310sente les fonctionnalit\u251c\u2310s de s\u251c\u2310curit\u251c\u2310 de ce syst\u251c\u00bfme, leur mode de fonctionnement, leur impl\u251c\u2310mentation interne ainsi que leur param\u251c\u2310trage. Il s' adresse \u251c\u00e1 tout informaticien en charge de la s\u251c\u2310curit\u251c\u2310 sur des postes \u251c\u2310quip\u251c\u2310s de Windows Vista mais \u251c\u2310galement aux d\u251c\u2310veloppeurs d'applications compatibles avec ce syst\u251c\u00bfme d'exploitation. Le premier et le second chapitre sont consacr\u251c\u2310s \u251c\u00e1 la nouvelle architecture du syst\u251c\u00bfme, aux nouveaux m\u251c\u2310canismes du noyau et aux nouveaux outils tels que Windows Defender ou l'outil de suppression des logiciels malveillants. Le pare-feu Windows, enti\u251c\u00bfrement r\u251c\u2310\u251c\u2310crit, s' int\u251c\u00bfgre compl\u251c\u00bftement avec IPSEC et fait l'objet du chapitre 3. Le chapitre 4 traite des nouveaut\u251c\u2310s de partage de fichiers et d'imprimantes, de SMB W, de NAP et de la gestion des r\u251c\u2310seaux sans fil dans Windows Vista. Le chapitre 5 est enti\u251c\u00bfrement consacr\u251c\u2310 \u251c\u00e1 UAC\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "198\n", "authors": ["32"]}
{"title": "Eiffel: A language and environment for software engineering\n", "abstract": " The Eiffel language and environment address the problem of building quality software in practical development environments.Two software quality factors were deemed essential in the design of the language: reusability and reliability. They led to the following choices: language features that support the underlying bottom-up software design methodology; modular structures based on the object-oriented approach, with support for both generic parameters and multiple inheritance (including a new extension, repeated inheritance); automatic storage management; highly dynamic execution model; support for polymorphism and dynamic binding; fully static typing; information hiding facilities; assertions and invariants that may be monitored at run-time.The Eiffel programming environment, using C as an intermediate language, supports separate compilation of classes and achieves a good run-time performance in both\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "173\n", "authors": ["32"]}
{"title": "Touch of class\n", "abstract": " \u252c\u2310 Springer-Verlag Berlin Heidelberg 2009, Corrected printing 2013", "num_citations": "144\n", "authors": ["32"]}
{"title": "Software engineering in the academy\n", "abstract": " Institutions that teach software are responsible for producing professionals who will build and maintain systems to the satisfaction of their beneficiaries. The article presents some ideas on how best to honor this responsibility. It presents five goals of a curriculum: principles: lasting concepts that underlie the whole field; practices: problem-solving techniques that good professionals apply consciously and regularly; applications: areas of expertise in which the principles and practices find their best expression; tools: state-of-the-art products that facilitate the application of these principles and practices; mathematics: the formal basis that makes it possible to understand everything else.", "num_citations": "140\n", "authors": ["32"]}
{"title": "The unspoken revolution in software engineering\n", "abstract": " In this article the author describes the outsourcing aspects of software engineering. The author finds outsourcing so fascinating partly because it serves as a magnifier and revelator of just about everything in software engineering. The development of offshoring also raises a new challenge for those of us entrusted with educating future software professionals in the industrialized world.", "num_citations": "139\n", "authors": ["32"]}
{"title": "Automated fixing of programs with contracts\n", "abstract": " This paper describes AutoFix, an automatic debugging technique that can fix faults in general-purpose software. To provide high-quality fix suggestions and to enable automation of the whole debugging process, AutoFix relies on the presence of simple specification elements in the form of contracts (such as pre- and postconditions). Using contracts enhances the precision of dynamic analysis techniques for fault detection and localization, and for validating fixes. The only required user input to the AutoFix supporting tool is then a faulty program annotated with contracts; the tool produces a collection of validated fixes for the fault ranked according to an estimate of their suitability. In an extensive experimental evaluation, we applied AutoFix to over 200 faults in four code bases of different maturity and quality (of implementation and of contracts). AutoFix successfully fixed 42 percent of the faults, producing, in the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "135\n", "authors": ["32"]}
{"title": "Agile vs. structured distributed software development: A case study\n", "abstract": " In globally distributed software development, does it matter being agile rather than structured? To answer this question, this paper presents an extensive case study that compares agile (Scrum, XP, etc.) vs. structured (RUP, waterfall) processes to determine if the choice of process impacts aspects such as the overall success and economic savings of distributed projects, the motivation of the development teams, the amount of communication required during development, and the emergence of critical issues. The case study includes data from 66 projects developed in Europe, Asia, and the Americas. The results show no significant difference between the outcome of projects following agile processes and structured processes, suggesting that agile and structured processes can be equally effective for globally distributed development. The paper also discusses several qualitative aspects of distributed software\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "132\n", "authors": ["32"]}
{"title": "\u2568\u20a7\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2561 \u2568\u2551\u2568\u255b\u2568\u255c\u2564\u00fc\u2564\u00e9\u2564\u00c7\u2564\u00e2\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u255c\u2564\u00ef\u2564\u00e0 \u2564\u00fc\u2568\u2555\u2564\u00fc\u2564\u00e9\u2568\u2561\u2568\u255d\n", "abstract": " \u2568\u20a7\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2561 \u2568\u2551\u2568\u255b\u2568\u255c\u2564\u00fc\u2564\u00e9\u2564\u00c7\u2564\u00e2\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u255c\u2564\u00ef\u2564\u00e0 \u2564\u00fc\u2568\u2555\u2564\u00fc\u2564\u00e9\u2568\u2561\u2568\u255d \u2568\u00dc\u2568\u20a7\u2568\u00e1\u2568\u00f9\u2568\u00ff\u2568\u00a5\u2568\u00c9 \u2568\u0192\u2568\u20a7\u2568\u00ff\u2568\u00ed\u2568\u00dc \u2568\u00a5\u2568\u00c9\u2568\u00c6\u2568\u00ff\u2568\u00f4\u2568\u00c9\u2568\u00f3\u2568\u20a7\u2568\u00e1 \u2568\u00a5\u2568\u2591\u2564\u00e7\u2568\u2591\u2568\u2557\u2564\u00ee\u2568\u255c\u2568\u2591\u2564\u00c5 \u2564\u00fc\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00e5\u2568\u2591 \u2568\u00dc\u2568\u2591\u2564\u00e9\u2568\u2591\u2568\u2557\u2568\u255b\u2568\u2502 \u2568\u2562\u2564\u00e2\u2564\u00c7\u2568\u255c\u2568\u2591\u2568\u2557\u2568\u255b\u2568\u2593 \u2568\u00c9\u2568\u2593\u2564\u00e9\u2568\u255b\u2564\u00c7\u2564\u00fc\u2568\u2551\u2568\u2555\u2568\u2563 \u2564\u00e2\u2568\u2551\u2568\u2591\u2568\u2556\u2568\u2591\u2564\u00e9\u2568\u2561\u2568\u2557\u2564\u00ee \u2568\u00ed\u2568\u2510\u2568\u2555\u2564\u00fc\u2568\u255b\u2568\u2551 \u2568\u255b\u2564\u00c7\u2568\u2502\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2556\u2568\u2591\u2564\u00e5\u2568\u2555\u2568\u2563 \u2568\u00f3\u2568\u2561\u2568\u255d\u2568\u2591\u2564\u00e9\u2568\u2555\u2564\u00e7\u2568\u2561\u2564\u00fc\u2568\u2551\u2568\u2555\u2568\u2563 \u2564\u00c7\u2564\u00e2\u2568\u2592\u2564\u00c7\u2568\u2555\u2568\u2551\u2568\u2591\u2564\u00e9\u2568\u255b\u2564\u00c7 \u2568\u0192\u2568\u255b\u2568\u2555\u2564\u00fc\u2568\u2551\u2568\u255b\u2568\u2593\u2564\u00ef\u2568\u2561 \u2568\u2556\u2568\u2591\u2568\u2510\u2564\u00c7\u2568\u255b\u2564\u00fc\u2564\u00ef \u2568\u00a5\u2568\u2591\u2564\u00fc\u2564\u00e9\u2564\u00c7\u2568\u255b\u2568\u2563\u2568\u2551\u2568\u2591 \u2568\u00ed\u2568\u00f2\u2568\u00ed\u2568\u00ed\u2568\u00ff\u2568\u00bb \u2568\u00dc\u2568\u20a7\u2568\u00a5\u2568\u00f3\u2568\u00c9\u2568\u00dc\u2568\u00f3\u2568\u00bd \u2568\u00ff\u2568\u00a5\u2568\u00f1\u2568\u20a7\u2568\u00e1\u2568\u00a3\u2568\u00c9\u2568\u00aa\u2568\u00ff\u2568\u00bb \u2568\u20a7 \u2568\u0192\u2568\u00fa\u2568\u00e6\u2568\u00a2\u2568\u00ff\u2568\u00dc\u2568\u00c9\u2568\u00aa\u2568\u00ff\u2568\u00ff eLIBRARY ID: 19584387 \u2568\u20a7\u2568\u00e6\u2568\u00ac\u2568\u00f2\u2568\u00dc\u2568\u00f3\u2568\u00a5\u2568\u20a7-\u2568\u20a7\u2568\u00e1\u2568\u00ff\u2568\u00f2\u2568\u00a5\u2568\u00f3\u2568\u00ff\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00c9\u2568\u00a5\u2568\u00a5\u2568\u20a7\u2568\u00f2 \u2568\u00dc\u2568\u20a7\u2568\u00a5\u2568\u00ed\u2568\u00f3\u2568\u00e1\u2568\u00fa\u2568\u00ff\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00c9\u2568\u00a5\u2568\u00ff\u2568\u00f2 \u2568\u0192\u2568\u00e1\u2568\u20a7\u2568\u00f4\u2568\u00e1\u2568\u00c9\u2568\u00a3\u2568\u00a3\u2568\u00a5\u2568\u00bd\u2568\u00d1 \u2568\u00ed\u2568\u00ff\u2568\u00ed\u2568\u00f3\u2568\u00f2\u2568\u00a3 \u2568\u00e6\u2568\u2561\u2564\u00c7\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u255c \u2568\u00a3\u2568\u2561\u2568\u2563\u2568\u2561\u2564\u00c7 ; [\u2568\u2510\u2568\u2561\u2564\u00c7. \u2564\u00fc \u2568\u2591\u2568\u255c\u2568\u2502\u2568\u2557. : \u2568\u00c6\u2568\u00c9\u2568\u00e6\u2568\u2555\u2568\u2557\u2568\u2557\u2568\u2555\u2568\u2502 \u2568\u2555 \u2568\u2524\u2564\u00c7.] \u2568\u00a3\u2568\u00f2\u2568\u00d6\u2568\u00f2\u2568\u00e1 \u2568\u00e6\u2568\u00f2\u2568\u00e1\u2568\u00f3\u2568\u00e1\u2568\u00c9\u2568\u00a5 \u2568\u00f3\u2568\u2555\u2568\u2510: \u2568\u255d\u2568\u255b\u2568\u255c\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2564\u00e4\u2568\u2555\u2564\u00c5 \u2568\u00bb\u2568\u2556\u2564\u00ef\u2568\u2551: \u2564\u00c7\u2564\u00e2\u2564\u00fc\u2564\u00fc\u2568\u2551\u2568\u2555\u2568\u2563 ISBN: 5-7502-0255-0 \u2568\u00f4\u2568\u255b\u2568\u2524 \u2568\u2555\u2568\u2556\u2568\u2524\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5: 2005 \u2568\u00a3\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u255b \u2568\u2555\u2568\u2556\u2568\u2524\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5: \u2568\u00a3\u2568\u255b\u2564\u00fc\u2568\u2551\u2568\u2593\u2568\u2591 \u2568\u00ba\u2568\u2555\u2564\u00fc\u2568\u2557\u2568\u255b \u2564\u00fc\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00e5: \u2568\u00ff\u2568\u2556\u2568\u2524\u2568\u2591\u2564\u00e9\u2568\u2561\u2568\u2557\u2564\u00ee\u2564\u00fc\u2564\u00e9\u2568\u2593\u2568\u255b: \u2568\u00e1\u2564\u00e2\u2564\u00fc. \u2564\u00c7\u2568\u2561\u2568\u2524. \u2568\u00dc\u2568\u00a2\u2568\u00ab\u2568\u00ba\u2568\u00f2\u2568\u00c6\u2568\u00bd\u2568\u00f2 \u2568\u00ed\u2568\u00a2\u2568\u20a7\u2568\u00c6\u2568\u00c9: \u2568\u20a7\u2568\u00e6\u2568\u00ac\u2568\u00f2\u2568\u00dc\u2568\u00f3\u2568\u00a5\u2568\u20a7-\u2568\u20a7\u2568\u00e1\u2568\u00ff\u2568\u00f2\u2568\u00a5\u2568\u00f3\u2568\u00ff\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00c9\u2568\u00a5\u2568\u00a5\u2568\u20a7\u2568\u00f2 \u2568\u0192\u2568\u00e1\u2568\u20a7\u2568\u00f4\u2568\u00e1\u2568\u00c9\u2568\u00a3\u2568\u00a3\u2568\u00ff\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00c9\u2568\u00a5\u2568\u00ff\u2568\u00f2(\u2568\u00dc\u2568\u20a7\u2568\u00a3\u2568\u0192\u2568\u00bc\u2568\u00ab\u2568\u00f3.), \u2568\u00c6\u2568\u00bd\u2568\u00ba\u2568\u00ff\u2568\u00ed\u2568\u00a2\u2568\u00ff\u2568\u00f3\u2568\u00f2\u2568\u00a2\u2568\u00bc\u2568\u00a5\u2568\u00c9\u2568\u00bb \u2568\u00f3\u2568\u00f2\u2568\u00d1\u2568\u00a5\u2568\u00ff\u2568\u00dc\u2568\u00c9, \u2568\u00c6\u2568\u00bd\u2568\u00ba\u2568\u00ff\u2568\u00ed\u2568\u00a2\u2568\u00ff\u2568\u00f3\u2568\u00f2\u2568\u00a2\u2568\u00bc\u2568\u00a5\u2568\u00bd\u2568\u00f2 \u2568\u00a3\u2568\u00c9\u2568\u00bf\u2568\u00ff\u2568\u00a5\u2568\u00bd \u2568\u00a1\u2568\u00a2\u2568\u00f2\u2568\u00dc\u2568\u00f3\u2568\u00e1\u2568\u20a7\u2568\u00a5\u2568\u00a5\u2568\u00bd\u2568\u00f2 \u2568\u00aa\u2568\u00ff\u2568\u00f1\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00bd\u2568\u00f2, \u2568\u0192\u2568\u00e1\u2568\u20a7\u2568\u00f4\u2568\u00e1\u2568\u00c9\u2568\u00a3\u2568\u00a3\u2568\u00ff\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00c9\u2568\u00a5\u2568\u00ff\u2568\u00f2, \u2568\u20a7\u2568\u00e6\u2568\u00ac\u2568\u00f2\u2568\u00dc\u2568\u00f3\u2568\u00a5\u2568\u20a7-\u2568\u20a7\u2568\u00e1\u2568\u00ff\u2568\u00f2\u2568\u00a5\u2568\u00f3\u2568\u00ff\u2568\u00e1\u2568\u20a7\u2568\u00c6\u2568\u00c9\u2568\u00a5\u2568\u00a5\u2568\u20a7\u2568\u00f2 , \u2568\u20a7\u2568\u00e6\u2568\u00ac\u2568\u00f2\u2568\u00dc\u2568\u00f3\u2568\u00a5\u2568\u20a7-: \u2568\u00c6\u2564\u00e0\u2568\u255b\u2568\u2524\u2568\u2555\u2564\u00e9 \u0393\u00c7\u00aa", "num_citations": "128\n", "authors": ["32"]}
{"title": "Experimental assessment of random testing for object-oriented software\n", "abstract": " Progress in testing requires that we evaluate the effectiveness of testing strategies on the basis of hard experimental evidence, not just intuition or a priori arguments. Random testing, the use of randomly generated test data, is an example of a strategy that the literature often deprecates because of such preconceptions. This view is worth revisiting since random testing otherwise offers several attractive properties: simplicity of implementation, speed of execution, absence of human bias.", "num_citations": "114\n", "authors": ["32"]}
{"title": "An empirical study of API usability\n", "abstract": " Modern software development extensively involves reusing library components accessed through their Application Programming Interfaces (APIs). Usability is therefore a fundamental goal of API design, but rigorous empirical studies of API usability are still relatively uncommon. In this paper, we present the design of an API usability study which combines interview questions based on the cognitive dimensions framework, with systematic observations of programmer behavior while solving programming tasks based on ``tokens''. We also discuss the implementation of the study to assess the usability of a persistence library API (offering functionalities such as storing objects into relational databases). The study involved 25 programmers (including students, researchers, and professionals), and provided additional evidence to some critical features evidenced by related studies, such as the difficulty of finding good\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "111\n", "authors": ["32"]}
{"title": "Compiler error messages: What can help novices?\n", "abstract": " Novices find it difficult to understand and use compiler error messages. It is useful to refine this observation and study the effect of different message styles on how well and quickly students identify errors in programs. For example, does an increased level of detail simplify the understanding of errors and their correction? We analyzed messages produced by a number of compilers for five programming languages, and grouped them into three style categories from their level of detail and presentation format, and correlated the level of experience and error type with performance and speed of response. The study involved two groups of students taking an introductory programming course at two different institutions; they used messages in these three styles to debug erroneous code. The results indicate that more detailed messages do not necessarily simplify the understanding of errors but that it matters more where\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "109\n", "authors": ["32"]}
{"title": "Eiffel: programming for reusability and extendibility\n", "abstract": " Eiffel is a language and environment intended for the design and implementation of quality software in production environments. The language is based on the principles of object-oriented design, augmented by features enhancing correctness, extendibility and efficiency; the environment includes a basic class library and tools for such tasks as automatic configuration management, documentation and debugging.", "num_citations": "109\n", "authors": ["32"]}
{"title": "Automatic testing of object-oriented software\n", "abstract": " Effective testing involves preparing test oracles and test cases, two activities which are too tedious to be effectively performed by humans, yet for the most part remain manual. The AutoTest unit testing framework automates both, by using Eiffel contracts \u0393\u00c7\u00f6 already present in the software \u0393\u00c7\u00f6 as test oracles, and generating objects and routine arguments to exercise all given classes; manual tests can also be added, and all failed test cases are automatically retained for regression testing, in a \u0393\u00c7\u00a3minimized\u0393\u00c7\u00a5 form retaining only the relevant instructions. AutoTest has already detected numerous hitherto unknown bugs in production software.", "num_citations": "107\n", "authors": ["32"]}
{"title": "A comparative study of programmer-written and automatically inferred contracts\n", "abstract": " Where do contracts-specification elements embedded in executable code-come from? To produce them, should we rely on the programmers, on automatic tools, or some combination?", "num_citations": "106\n", "authors": ["32"]}
{"title": "Reconciling manual and automated testing: The AutoTest experience\n", "abstract": " Software can be tested either manually or automatically. The two approaches are complementary: automated testing can perform a large number of tests in little time, whereas manual testing uses the knowledge of the testing engineer to target testing to the parts of the system that are assumed to be more error-prone. Despite this complementarity, tools for manual and automatic testing are usually different, leading to decreased productivity and reliability of the testing process. AutoTest is a testing tool that provides a \"best of both worlds\" strategy: it integrates developers' test cases into an automated process of systematic contract-driven testing. This allows it to combine the benefits of both approaches while keeping a simple interface, and to treat the two types of tests in a unified fashion: evaluation of results is the same, coverage measures are added up, and both types of tests can be saved in the same format", "num_citations": "101\n", "authors": ["32"]}
{"title": "Research evaluation for computer science\n", "abstract": " Reassessing the assessment criteria and techniques traditionally used in evaluating computer science research effectiveness.", "num_citations": "98\n", "authors": ["32"]}
{"title": "Seven principles of software testing\n", "abstract": " While everyone knows the theoretical limitations of software testing, in practice we devote considerable effort to this task and would consider it foolish or downright dangerous to skip it. Other verification techniques such as static analysis, model checking, and proofs have great potential, but none is ripe for overtaking tests as the dominant verification technique. This makes it imperative to understand the scope and limitations of testing and perform it right. The principles that follow emerged from experience studying software testing and developing automated tools such as AutoTest.", "num_citations": "95\n", "authors": ["32"]}
{"title": "Inferring loop invariants using postconditions\n", "abstract": " One of the obstacles in automatic program proving is to obtain suitable loop invariants. The invariant of a loop is a weakened form of its postcondition (the loop\u0393\u00c7\u00d6s goal, also known as its contract); the present work takes advantage of this observation by using the postcondition as the basis for invariant inference, using various heuristics such as \u0393\u00c7\u00a3uncoupling\u0393\u00c7\u00a5 which prove useful in many important algorithms. Thanks to these heuristics, the technique is able to infer invariants for a large variety of loop examples. We present the theory behind the technique, its implementation (freely available for download and currently relying on Microsoft Research\u0393\u00c7\u00d6s Boogie tool), and the results obtained.", "num_citations": "92\n", "authors": ["32"]}
{"title": "Object success: a manager's guide to object orientation, its impact on the corporation, and its use for reengineering the software process\n", "abstract": " Meyer sets himself a daunting challenge: to present the highly technical computing methodology of object-oriented (OO) development to \u0393\u00c7\u00a3high or middle\u0393\u00c7\u00a5 managers of a Fortune 500 company and justify introducing it. The book is excellent and well written, with a flair seldom seen in such works. In my experience, the book will benefit organizations looking to understand OO, although it is too technical for its stated audience and would be more appropriate for first-or second-level supervisors and computing technology planners who are current in software development but not in OO. For most information systems people, this will be an eminently readable and thorough introduction to OO development, with emphasis on the management practices needed to introduce the technology successfully. The following topics are covered in the chapters: introduction and expectation setting; key concepts; the software life cycle\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "91\n", "authors": ["32"]}
{"title": "Towards an Object-Oriented Curriculum.\n", "abstract": " Towards an Object-Oriented Curriculum Bertrand Meyer ISE ) Santa Barbara (California Abstract Page 1 Towards an Object-Oriented Curriculum Bertrand Meyer ISE ) Santa Barbara (California Abstract r s This proposal suggests a redesign of the teaching of programming and othe oftware topics in universities on the basis of object-oriented principles. It argues t that the new \u0393\u00c7\u00ff\u0393\u00c7\u00ffinverted curriculum\u0393\u00c7\u00d6\u0393\u00c7\u00d6 should give a central place to libraries, and ake students from the reuse consumer\u0393\u00c7\u00d6s role to the role of producer through a process of \u0393\u00c7\u00ff\u0393\u00c7\u00ffprogressive opening of black boxes\u0393\u00c7\u00d6\u0393\u00c7\u00d6. ________________________________________________________________ p This article is ISE Technical Report TR-EI-38/TE, January 1993. The resent version is a draft. Revised versions were published in the Journal , a of Object-Oriented Programming, vol. 6, no. 2, May 1993, pages 76-81 nd in TOOLS USA 1993. Cite as Bertrand Meyer, an -, in \u0393\u00c7\u00aa", "num_citations": "91\n", "authors": ["32"]}
{"title": "Contract-Driven Development = Test-Driven Development - Writing Test Cases\n", "abstract": " Although unit tests are recognized as an important tool in software development, programmers prefer to write code, rather than unit tests. Despite the emergence of tools like JUnit which automate part of the process, unit testing remains a time-consuming, resource-intensive, and not particularly appealing activity. This paper introduces a new development method, called Contract Driven Development. This development method is based on a novel mechanism that extracts test cases from failure-producing runs that the programmers trigger. It exploits actions that developers perform anyway as part of their normal process of writing code. Thus, it takes the task of writing unit tests off the developers' shoulders, while still taking advantage of their knowledge of the intended semantics and structure of the code. The approach is based on the presence of contracts in code, which act as the oracle of the test cases. The test\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "89\n", "authors": ["32"]}
{"title": "From structured programming to object-oriented design: The road to Eiffel.\n", "abstract": " An exploration of how object-oriented design, as implemented in the Eiffel language and environment, integrates and extends the seminal concepts of structured programming.", "num_citations": "89\n", "authors": ["32"]}
{"title": "Component-based development: From buzz to spark\n", "abstract": " Component-based development (CBD) is the building of software systems out of prepackaged generic elements. The current excitement about CBD results from the convergence of four phenomena originating from quite different backgrounds: on the scientific side, the progress of modern software engineering ideas with their special emphasis on reuse. On the industrial side, the widespread success of theoretically unpretentious but practically useful techniques for building GUIs, databases, and other parts of applications out of components. On the political side, the push by some of the major players for competing interconnection technologies: CORBA, COM, and Enterprise JavaBeans. In the software world at large, the generalization of object technology, which provides both the conceptual basis and the practical tools for building and using components. The catalyst behind component-based development is the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "82\n", "authors": ["32"]}
{"title": "Advances in object oriented software engineering\n", "abstract": " The book consists of nine chapters: Design by contract, by B. Meyer; The new culture of software development, by B. Meyer; An object oriented approach to domain analysis, by S. Shlaer and S. Mellor; Active software objects in a knowledge-based software life cycle support environment, by A. Van Lamsweerde; On eclectic specification envirnments, by C. Ghezzi and D. Mandrioli; Distributed software design techniques, by M. Jazayeri; A tour of Hybrid, by O. Nierstrasz; An object-oriented architecture for real-time applications, by L. Nigro and F. Tisato; A development in Eiffel, by C. Gindre and F. Sada.", "num_citations": "80\n", "authors": ["32"]}
{"title": "Object distance and its application to adaptive random testing of object-oriented programs\n", "abstract": " Testing with random inputs can give surprisingly good results if the distribution of inputs is spread out evenly over the input domain; this is the intuition behind Adaptive Random Testing, which relies on a notion of\" distance\" between test values. Such distances have so far been defined for integers and other elementary inputs; extending the idea to the testing of today's object-oriented programs requires a more general notion of distance, applicable to composite programmer-defined types. We define a notion of object distance, with associated algorithms to compute distances between arbitrary objects, and use it to generalize Adaptive Random Testing to such inputs. The resulting testing strategies open the way for effective automated testing of large, realistic object-oriented programs.", "num_citations": "75\n", "authors": ["32"]}
{"title": "Componentization: The visitor example\n", "abstract": " Patterns provide a vocabulary and catalog for common design solutions but are not reusable software. Through advanced object-oriented language mechanisms it is possible to simplify the application developer's job by turning certain patterns into fully reusable solutions", "num_citations": "74\n", "authors": ["32"]}
{"title": "On the predictability of random tests for object-oriented software\n", "abstract": " Intuition suggests that random testing of object-oriented programs should exhibit a significant difference in the number of faults detected by two different runs of equal duration. As a consequence, random testing would be rather unpredictable. We evaluate the variance of the number of faults detected by random testing over time. We present the results of an empirical study that is based on 1215 hours of randomly testing 27 Eiffel classes, each with 30 seeds of the random number generator. Analyzing over 6 million failures triggered during the experiments, the study provides evidence that the relative number of faults detected by random testing over time is predictable but that different runs of the random test case generator detect different faults. The study also shows that random testing quickly finds faults: the first failure is likely to be triggered within 30 seconds.", "num_citations": "67\n", "authors": ["32"]}
{"title": "The inverted curriculum in practice\n", "abstract": " Teaching introductory programming today presents considerable challenges, which traditional techniques do not properly address. Students start with a wide variety of backgrounds and prior computing experience; to retain their attention it is useful to provide graphical interfaces at the level set by video games; and with the ever-increasing presence of computing in society the stakes are higher, requiring a computing curriculum to introduce students early to the issues of large systems. We address these challenges through an\" outside-in\" approach, or\" inverted curriculum\", which emphasizes the reuse of existing components in an example domain involving graphics and multimedia, a gentle introduction to formal reasoning thanks to Design by Contract techniques, and an object-oriented method throughout. The new course has now been taught twice, with considerable gathering of student data and feedback; we\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "65\n", "authors": ["32"]}
{"title": "Design by contract\n", "abstract": " This chapter is a contribution to software reliability. It presents a view of software design based on a metaphor: software construction as a succession of documented contracting decisions.", "num_citations": "65\n", "authors": ["32"]}
{"title": "Informatics education: Europe cannot afford to miss the boat\n", "abstract": " 3. Informatics covers the science behind information technology. Informatics is a distinct science, characterized by its own concepts, methods, body of knowledge and open issues. It has emerged, in a role similar to that of mathematics, as a crossdiscipline field underlying today\u0393\u00c7\u00d6s scientific, engineering and economic progress.", "num_citations": "64\n", "authors": ["32"]}
{"title": "Teaching software engineering using globally distributed projects: the DOSE course\n", "abstract": " Distributed software development poses new software engineering challenges. To prepare student for these new challenges, we have been teaching software engineering using globally distributed projects. The projects were developed in collaboration with eleven universities in ten different countries in Europe, Asia, and South America. This paper reports the experience teaching the course, describing the settings, problems faced organizing the projects and the lessons learned.", "num_citations": "60\n", "authors": ["32"]}
{"title": "Finding faults: Manual testing vs. random+ testing vs. user reports\n", "abstract": " The usual way to compare testing strategies, whether theoretically or empirically, is to compare the number of faults they detect. To ascertain definitely that a testing strategy is better than another, this is a rather coarse criterion: shouldn't the nature of faults matter as well as their number? The empirical study reported here confirms this conjecture. An analysis of faults detected in Eiffel libraries through three different techniques-random tests, manual tests, and user incident reports-shows that each is good at uncovering significantly different kinds of faults. None of the techniques subsumes any of the others, but each brings distinct contributions.", "num_citations": "60\n", "authors": ["32"]}
{"title": "Loop invariants: Analysis, classification, and examples\n", "abstract": " Software verification has emerged as a key concern for ensuring the continued progress of information technology. Full verification generally requires, as a crucial step, equipping each loop with a \u0393\u00c7\u00a3loop invariant.\u0393\u00c7\u00a5 Beyond their role in verification, loop invariants help program understanding by providing fundamental insights into the nature of algorithms. In practice, finding sound and useful invariants remains a challenge. Fortunately, many invariants seem intuitively to exhibit a common flavor. Understanding these fundamental invariant patterns could therefore provide help for understanding and verifying a large variety of programs. We performed a systematic identification, validation, and classification of loop invariants over a range of fundamental algorithms from diverse areas of computer science. This article analyzes the patterns, as uncovered in this study, governing how invariants are derived from postconditions\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "59\n", "authors": ["32"]}
{"title": "The many faces of inheritance: A taxonomy of taxonomy\n", "abstract": " One of the most important considerations in constructing object-oriented software is the methodology of inheritance: how to use this mechanism well. The paper presents a taxonomy comprising twelve kinds of inheritance usage grouped into three broad categories: model inheritance; software inheritance; and variation inheritance.", "num_citations": "58\n", "authors": ["32"]}
{"title": "Usable verification of object-oriented programs by combining static and dynamic techniques\n", "abstract": " With formal techniques becoming more and more powerful, the next big challenge is making software verification practical and usable. The Eve verification environment contributes to this goal by seamlessly integrating a static prover and an automatic testing tool into a development environment. The paper discusses the general principles behind the integration of heterogeneous verification tools; the peculiar challenges involved in combining static proofs and dynamic testing techniques; and how the combination, implemented in Eve through a blackboard architecture, can improve the user experience with little overhead over usual development practices. Eve is freely available for download.", "num_citations": "57\n", "authors": ["32"]}
{"title": "The new culture of software development: Reflections on the practice of object-oriented design\n", "abstract": " Object-oriented techniques, when applied seriously and on a broad scale, reflect a new culture of software engineering. which may be called the component culture. After contrasting this new culture with the more traditional project culture, this article examines some of the technical. economical and managerial implications of the new approach. The discussion explores the fundamental object-oriented processes of abstraction and extraction (recognizing inheritance structures a posteriori). and introduces a new lifecyclemodel which seems to fit best with object-oriented development of reusable software: the Cluster Model.", "num_citations": "56\n", "authors": ["32"]}
{"title": "What good are strong specifications?\n", "abstract": " Experience with lightweight formal methods suggests that programmers are willing to write specification if it brings tangible benefits to their usual development activities. This paper considers stronger specifications and studies whether they can be deployed as an incremental practice that brings additional benefits without being unacceptably expensive. We introduce a methodology that extends Design by Contract to write strong specifications of functional properties in the form of preconditions, postconditions, and invariants. The methodology aims at being palatable to developers who are not fluent in formal techniques but are comfortable with writing simple specifications. We evaluate the cost and the benefits of using strong specifications by applying the methodology to testing data structure implementations written in Eiffel and C#. In our extensive experiments, testing against strong specifications detects twice as\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "55\n", "authors": ["32"]}
{"title": "How do distribution and time zones affect software development? a case study on communication\n", "abstract": " Software projects have crossed seas and continents looking for talented developers, moving from local developments to geographically distributed projects. This paper presents a case study analyzing the effect of distribution and time zones on communication in distributed projects. The study was performed in a university course during two semesters, where students developed projects jointly with teams located in ten different countries in South America, Europe, and Asia. The study compares the results of the projects distributed in two locations with projects distributed in three locations. It also analyzes projects in different time zone ranges. The initial results show that the amount of communication in projects distributed in two locations is bigger than the communication in projects distributed in three locations. We also found that projects in closer time zones have more communication than projects in farther time\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "53\n", "authors": ["32"]}
{"title": "On the number and nature of faults found by random testing\n", "abstract": " Intuition suggests that random testing should exhibit a considerable difference in the number of faults detected by two different runs of equal duration. As a consequence, random testing would be rather unpredictable. This article first evaluates the variance over time of the number of faults detected by randomly testing object\u0393\u00c7\u00c9oriented software that is equipped with contracts. It presents the results of an empirical study based on 1215\u0393\u00c7\u00ebh of randomly testing 27 Eiffel classes, each with 30 seeds of the random number generator. The analysis of over 6 million failures triggered during the experiments shows that the relative number of faults detected by random testing over time is predictable, but that different runs of the random test case generator detect different faults. The experiment also suggests that the random testing quickly finds faults: the first failure is likely to be triggered within 30\u0393\u00c7\u00ebs. The second part of this article\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "53\n", "authors": ["32"]}
{"title": "The software knowledge base\n", "abstract": " We describe a system for maintaining useful information about a software project. The \u0393\u00c7\u00a3software knowledge base\u0393\u00c7\u00a5 keeps track of software components and their properties; these properties are described through binary relations and the con&taints that these relations must satisfy. The relations and constraints are entirely user-definable, although a set of predefined libraries of relations with associated constraints is provided for some of the most important aspects of software development (specification, design, implementation, testing, project management). The use of the binary relational model for describing the properties of software is hacked by a theoretical study of the relations and constraints which play an important role in software development,.", "num_citations": "51\n", "authors": ["32"]}
{"title": "SPOC-supported introduction to programming\n", "abstract": " MOOCs (Massive Open Online Courses), which have taken higher education by storm, are an opportunity to elevate the quality of existing residential courses. We report about an experimental attempt during the Autumn 2013 semester at ETH Zurich, involving our\" Introduction to Programming\" course. We designed and implemented a MOOC infrastructure and used it as a SPOC (Small Private Online Course) to support and complement the existing course. The results reported in this article are encouraging for two reasons: first, the participation level was good, in spite of the fact that the online course was an optional addition to the residential course; second, students really liked the assessments (quizzes and programming exercises), in spite of the fact that assessments did not count towards the course final grade. The data we collected suggest that this may, at least in part, be due to a gamification aspect we\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "50\n", "authors": ["32"]}
{"title": "Design and code reviews in the age of the internet\n", "abstract": " New collaboration tools allow geographically distributed software-development teams to boost the venerable concept of code review.", "num_citations": "50\n", "authors": ["32"]}
{"title": "Is branch coverage a good measure of testing effectiveness?\n", "abstract": " Most approaches to testing use branch coverage to decide on the quality of a given test suite. The intuition is that covering branches relates directly to uncovering faults. The empirical study reported here applied random testing to 14 Eiffel classes for a total of 2520 hours and recorded the number of uncovered faults and the branch coverage over time. For the tested classes, (1) random testing reaches 93% branch coverage (2) it exercises almost the same set of branches every time, (3) it detects different faults from execution to execution, (4) during the first 10 minutes of testing, while branch coverage increases rapidly, there is a strong correlation between branch coverage and the number of uncovered faults, (5) over 50% of the faults are detected at a time where branch coverage hardly changes, and the correlation between branch coverage and the number of uncovered faults is weak.             These results\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "48\n", "authors": ["32"]}
{"title": "Benchmarking usability and performance of multicore languages\n", "abstract": " Developers face a wide choice of programming languages and libraries supporting multicore computing. Ever more diverse paradigms for expressing parallelism and synchronization become available while their influence on usability and performance remains largely unclear. This paper describes an experiment comparing four markedly different approaches to parallel programming: Chapel, Cilk, Go, and Threading Building Blocks (TBB). Each language is used to implement sequential and parallel versions of six benchmark programs. The implementations are then reviewed by notable experts in the language, thereby obtaining reference versions for each language and benchmark. The resulting pool of 96 implementations is used to compare the languages with respect to source code size, coding time, execution time, and speedup. The experiment uncovers strengths and weaknesses in all approaches\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "45\n", "authors": ["32"]}
{"title": "Eiffel: Object-oriented design for software engineering\n", "abstract": " A number of individual concepts embodied in Eiffel were present in previous languages, notably Simula 67, Ada and Alphard. However the design has brought in many new contributions.             From the language standpoint, one may quote the safe treatment of multiple inheritance through renaming, the combination between genericity and inheritance, disciplined polymorphism by explicit redefinition, the integration of the assertion/invariant mechanism with inheritance, a clean interface with external routines, and the introduction of full static typing into an object-oriented language with multiple inheritance.             From the implementation standpoint, a number of our solutions are original: constant-time routine access, separate compilation with automatic configuration management in an object-oriented world, support for debugging and automatic interface documentation, support for the preparation of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "44\n", "authors": ["32"]}
{"title": "Conception et programmation orient\u251c\u2310es objet\n", "abstract": " R\u251c\u2310\u251c\u2310dition d'un des plus grands classiques de la litt\u251c\u2310rature informatique. Ecrit dans un style d'une clart\u251c\u2310 absolue, cet ouvrage r\u251c\u2310ussit le tour de force d'\u251c\u00actre \u251c\u00e1 la fois un livre de r\u251c\u2310flexion approfondie sur les concepts objet et un ouvrage pratique, apportant des r\u251c\u2310ponses concr\u251c\u00bftes aux questions que se posent tous les programmeurs et concepteurs de logiciels: comment construire des applications logicielles fiables, performantes, faciles \u251c\u00e1 utiliser et \u251c\u00e1 faire \u251c\u2310voluer? Th\u251c\u2310orie du typage, gestion de la m\u251c\u2310moire, techniques d'h\u251c\u2310ritage, programmation concurrente, objets distribu\u251c\u2310s, persistance et bases de donn\u251c\u2310es objet, analyse et conception, r\u251c\u2310utilisabilit\u251c\u2310...: tous les aspects du processus de d\u251c\u2310veloppement logiciel et des technologies objet sont expliqu\u251c\u2310s et discut\u251c\u2310s dans leurs moindres d\u251c\u2310tails, dans un style brillant, souvent dr\u251c\u2524le et provocateur.", "num_citations": "43\n", "authors": ["32"]}
{"title": "The role of object-oriented metrics\n", "abstract": " Perhaps the most common concern of project managers who use or who are about to use object technology is for more measurement tools. There is, in fact, an extensive literature on software metrics, including much that pertains to object-oriented development, but surprisingly little of it is of direct use to actual projects. The author presents a classification of software metrics and five basic rules for their application.", "num_citations": "41\n", "authors": ["32"]}
{"title": "Flexible invariants through semantic collaboration\n", "abstract": " Modular reasoning about class invariants is challenging in the presence of collaborating objects that need to maintain global consistency. This paper presents semantic collaboration: a novel methodology to specify and reason about class invariants of sequential object-oriented programs, which models dependencies between collaborating objects by semantic means. Combined with a simple ownership mechanism and useful default schemes, semantic collaboration achieves the flexibility necessary to reason about complicated inter-object dependencies but requires limited annotation burden when applied to standard specification patterns. The methodology is implemented in AutoProof, our program verifier for the Eiffel programming language (but it is applicable to any language supporting some form of representation invariants). An evaluation on several challenge problems proposed in the literature\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "40\n", "authors": ["32"]}
{"title": "Testable, reusable units of cognition\n", "abstract": " An entity that embodies a collection of concepts, operational skills, and assessment criteria, the Truc offers a useful tool for codifying knowledge about a domain and its teaching. Considering the goals of an educational program from a pragmatic perspective suggests that we decompose its topics into atomic elements, for which this discussion proposes the name testable, reusable unit of cognition or Truc.", "num_citations": "40\n", "authors": ["32"]}
{"title": "The outside-in method of teaching introductory programming\n", "abstract": " The new design for the introductory programming course at ETH relies on object technology, Eiffel, extensive reuse, a graphics-rich library (TRAFFIC) built specifically for the course, a textbook (\u0393\u00c7\u00a3Touch of Class\u0393\u00c7\u00a5) and an Outside-In approach based on \u0393\u00c7\u00a3inverted curriculum\u0393\u00c7\u00a5 ideas. This article presents the key aspects of the approach.                                        Note: readers interested in following the development of our course, the \u0393\u00c7\u00a3Touch of Class\u0393\u00c7\u00a5 textbook and the supporting TRAFFIC software project may look up the page se.inf.ethz.ch/touch, where they can also subscribe to mailing lists connected with the approach.", "num_citations": "40\n", "authors": ["32"]}
{"title": "The next software breakthrough\n", "abstract": " Software development evolves less quickly than the industry's own hype would suggest: The basic issues surrounding the design and construction of software have remained unchanged throughout its history. Nevertheless, it is possible to identify five breakthroughs that have occurred since the time software development was recognized as a discipline in its own right:", "num_citations": "40\n", "authors": ["32"]}
{"title": "40^ sup th^ EASD Annual Meeting of the European Association for the Study of Diabetes\n", "abstract": " Materials and methods: 81 diabetic patients with significant sensory-motor and autonomic peripheral neuropathy without relevant peripheral artery occlusion disease were randomised and two kinds of diabetes-adapted shoes were selected:\" comfortable shoes\"(\" CS\") n= 39 or\" semi-orthopaedic shoes\"(\" SOS\") n~ 42. For each pair of shoes a special kind of similar individually manufactured diabetes-adapted insole was made. The study was carried out over a period of 24.3 1.8 months and every 3 months structured examination and documentation of shoes and feet were performed in the foot clinic (including pedography barefoot with emed-platform) and also at the orthopaedic shoe manufacturer (within the shoes with emed-pedar).Results: 33%(13 out of 39) patients who were randomised to the\" cs\"group had to be switched to the\" sos\" because of anatomical reasons. The dropout rate was 38% after 24 months\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "38\n", "authors": ["32"]}
{"title": "Contracts in practice\n", "abstract": " Contracts are a form of lightweight formal specification embedded in the program text. Being executable parts of the code, they encourage programmers to devote proper attention to specifications, and help maintain consistency between specification and implementation as the program evolves. The present study investigates how contracts are used in the practice of software development. Based on an extensive empirical analysis of 21 contract-equipped Eiffel, C#, and Java projects totaling more than 260 million lines of code over 7700 revisions, it explores, among other questions: 1) which kinds of contract elements (preconditions, postconditions, class invariants) are used more often; 2) how contracts evolve over time; 3) the relationship between implementation changes and contract changes; and 4) the role of inheritance in the process. It has found, among other results, that: the percentage of program\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "37\n", "authors": ["32"]}
{"title": "Collaborative software development on the web\n", "abstract": " Software development environments (IDEs) have not followed the IT industry's inexorable trend towards distribution. They do too little to address the problems raised by today's increasingly distributed projects; neither do they facilitate collaborative and interactive development practices. A consequence is the continued reliance of today's IDEs on paradigms such as traditional configuration management, which were developed for earlier modes of operation and hamper collaborative projects. This contribution describes a new paradigm: cloud-based development, which caters to the specific needs of distributed and collaborative projects. The CloudStudio IDE embodies this paradigm by enabling developers to work on a shared project repository. Configuration management becomes unobtrusive; it replaces the explicit update-modify-commit cycle by interactive editing and real-time conflict tracking and management. A case study involving three teams of pairs demonstrates the usability of CloudStudio and its advantages for collaborative software development over traditional configuration management practices.", "num_citations": "37\n", "authors": ["32"]}
{"title": "Understanding novice errors and error paths in object-oriented programming through log analysis\n", "abstract": " What difficulties do beginners face when learning object-oriented programming? How are these reflected in the code they write? In the context of a new introductory programming course based on \u0393\u00c7\u00a3inverted curriculum\u0393\u00c7\u00a5 ideas, and taking advantage of our ability to instrument the compiler, we obtained interaction logs from two different groups of students across two unrelated universities. We developed a methodology for analysing these logs to identify students\u0393\u00c7\u00d6 intentions, with the goal of providing contextual feedback in an Intelligent Tutoring System.", "num_citations": "37\n", "authors": ["32"]}
{"title": "Specifying reusable components\n", "abstract": " Reusable software components need expressive specifications. This paper outlines a rigorous foundation of model\u0393\u00c7\u00eb\u0393\u00ea\u00c6\u0393\u00c7\u00ebbased                 contracts, a method to equip classes with strong contracts that support accurate design, implementation, and formal verification of reusable components. Model-based contracts conservatively extend the classic Design by Contract approach with a notion of model, which underpins the precise definitions of such concepts as abstract object equivalence and specification completeness. Experiments applying model-based contracts to libraries of data structures suggest that the method enables accurate specification of practical software.", "num_citations": "36\n", "authors": ["32"]}
{"title": "Uncovering hidden contracts: The .NET example\n", "abstract": " Software contracts take the form of routine preconditions, postconditions, and class invariants written into the program itself. The design by contract methodology uses such contracts for building each software element, an approach that is particularly appropriate for developing safety-critical software and reusable libraries. This methodology is a key design element of some existing libraries, especially the Eiffel Software development environment, which incorporates contract mechanisms in the programming language itself. Because the authors see the contract metaphor as inherent to quality software development, they undertook the work reported in the article as a sanity check to determine whether they see contracts everywhere simply because their development environment makes using them natural or whether contracts are intrinsically present, even when other designers don't express or even perceive them\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "36\n", "authors": ["32"]}
{"title": "Design of an empirical study for comparing the usability of concurrent programming languages\n", "abstract": " Context: Developing concurrent software has long been recognized as a difficult and error-prone task. To support developers, a multitude of language proposals exist that promise to make concurrent programming easier. Empirical studies are needed to support the claim that a language is more usable than another.Objective: This paper presents the design of a study to compare concurrent programming languages with respect to comprehending and debugging existing programs and writing correct new programs. The design is applied to a comparison of two object-oriented languages for concurrency, multithreaded Java and SCOOP.Method: A critical challenge for such a study is avoiding the bias that might be introduced during the training phase and when interpreting participants\u0393\u00c7\u00d6 solutions. We address these issues by the use of self-study material and an evaluation scheme that exposes any subjective decisions\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "35\n", "authors": ["32"]}
{"title": "Making specifications complete through models\n", "abstract": " Good components need precise contracts. In the practice of Design by ContractTM, applications and libraries typically express, in their postconditions and class invariants, only a subset of the relevant properties. We present:               An approach to making these contract elements complete without extending the assertion language, by relying on \u0393\u00c7\u00a3model classes\u0393\u00c7\u00a5 directly deduced from mathematical concepts.               An actual \u0393\u00c7\u00a3Mathematical Model Library\u0393\u00c7\u00a5 (MML) built for that purpose               A method for using MML to express complete contracts through abstraction functions, and an associated theory of specification soundness.               As a direct application of these ideas, a new version of a widely used data structure and algorithms library equipped with complete contracts through MML.               All the software is available for download. The approach retains the pragmatism of the Design by Contract\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "33\n", "authors": ["32"]}
{"title": "Can aspects implement contracts?\n", "abstract": " Design by ContractTMis commonly cited as an example of the \u0393\u00c7\u00a3crosscutting\u0393\u00c7\u00a5 concerns that aspect-oriented programming can address. We test this conjecture by attempting to implement contracts through aspects and assessing the outcome. The results of this experiment cast doubt on the validity of the conjecture, showing that aspects appear unable to capture contracts in a way that retains the benefits of the Design by Contract methodology.", "num_citations": "33\n", "authors": ["32"]}
{"title": "Design by contract. the eiffel method\n", "abstract": " To deliver on its promises, object-oriented technology must be able to produce systems that are reliable (correct and robust). Only under these conditions will the other quality factors advertized for the method, in particular the increase in reusability and extendibility, yield the expected benefits for software practitioners.It is indeed possible to use object-oriented technology to produce, almost routinely, software systems that reach a degree of reliability without any equivalent in conventional methods, languages and tools. This requires a strict application of pure object-oriented concepts, in particular seamlessness (the use of a consistent method and notation throughout the software lifecycle), information hiding, automatic garbage collection, static typing, and the combination of static typing and dynamic binding. Another key component of this approach is the notion of design by contract, which leads to the production of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "33\n", "authors": ["32"]}
{"title": "Present and ulterior software engineering\n", "abstract": " The PAUSE symposium took place from the 16th to the 19th of December 2015. It was the first scientific event in the elegant Ch\u251c\u00f3teau of Villebrumier, in the Southwest of France, newly equipped to serve as a conference center for technical meetings, with a particular focus on information technology. The aim of PAUSE was to mark the completion of 14 years of work at the Chair of Software Engineering at ETH Zurich. The participants were former members of the Chair and colleagues from every part of the world who had the opportunity to collaborate with it over the years.", "num_citations": "32\n", "authors": ["32"]}
{"title": "Attached types and their application to three open problems of object-oriented programming\n", "abstract": " The three problems of the title \u0393\u00c7\u00f6 the first two widely discussed in the literature, the third less well known but just as important for further development of object technology \u0393\u00c7\u00f6 are:               \u0393\u00c7\u00f4 Eradicating the risk of void calls: x.f with, at run time, the target x not denoting any object, leading to an exception and usually a crash.               \u0393\u00c7\u00f4 Eradicating the risk of \u0393\u00c7\u00a3catcalls\u0393\u00c7\u00a5: erroneous run-time situations, almost inevitably leading to crashes, resulting from the use of covariant argument typing.               \u0393\u00c7\u00f4 Providing a simple way, in concurrent object-oriented programming, to lock an object handled by a remote processor or thread of control, or to access it without locking it, as needed by the context and in a safe way.               A language mechanism provides a combined solution to all three issues.               This mechanism also allows new solutions to two known problems: how to check that a certain object has a certain type\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "32\n", "authors": ["32"]}
{"title": "Advanced hands-on training for distributed and outsourced software engineering\n", "abstract": " Today's software projects are often distributed across multiple locations. This distribution poses new challenges produced by the cooperation across different countries, times zones, and cultures. Software engineering courses have to prepare students accordingly. This paper reports an experience on teaching a distributed software engineering course. In this course, students develop software in collaboration with five universities located in Italy, Hungary, Russia, Switzerland, and Ukraine. The projects allow students to face the difficulties of developing software in a globalized context, and provide a practical experience on distributed software engineering. We describe the major obstacles on organizing such a course, and we suggest best practices to achieve successful outcome.", "num_citations": "31\n", "authors": ["32"]}
{"title": "Overloading vs. object technology\n", "abstract": " Bertrand Meyer is CTO of Interactive Software Engineering, which just released ISE Eiffel 5.0, the most important new version since ISE Eiffel 3 in 1993.(http://www. eiffel. com). His latest book is The .NET Training Course (P rentice Hall). He may be reached at Bertrand_Meyer@ eiffel. com. www. joopmag. com October/November 2001 Journal of Object-Oriented Programming 3", "num_citations": "31\n", "authors": ["32"]}
{"title": "Multirequirements\n", "abstract": " Multirequirements - Research Collection Header Upper Right Menu Log in de jump to https://www.ethz.ch Research Collection Toggle navigation Upper Right Menu Login Help Help Language Deutsch Toggle navigation Search View Item Home Books Book Chapter View Item Home Books Book Chapter View Item Research Collection Navigational link Search Multirequirements Mendeley CSV RIS BibTeX Thumbnail Metadata only Author Meyer, Bertrand Date 2013 Type Book Chapter ETH Bibliography yes Altmetrics Publication status published External links Search via SFX Editor Seyff, Norbert Koziolek, Anne Book title Modelling and Quality in Requirements Engineering : Essays dedicated to Martin Glinz on the occasion of his 60th birthday Publisher Verl.-Haus Monsenstein u. Vannerdat Organisational unit 03594 - Meyer, Bertrand (emeritus) Notes Festschrift. More Show all metadata ETH Bibliography yes \u2229\u2557\u2510 by \u0393\u00c7\u00aa", "num_citations": "30\n", "authors": ["32"]}
{"title": "Verifying eiffel programs with boogie\n", "abstract": " Static program verifiers such as Spec#, Dafny, jStar, and VeriFast define the state of the art in automated functional verification techniques. The next open challenges are to make verification tools usable even by programmers not fluent in formal techniques. This paper presents AutoProof, a verification tool that translates Eiffel programs to Boogie and uses the Boogie verifier to prove them. In an effort to be usable with real programs, AutoProof fully supports several advanced object-oriented features including polymorphism, inheritance, and function objects. AutoProof also adopts simple strategies to reduce the amount of annotations needed when verifying programs (e.g., frame conditions). The paper illustrates the main features of AutoProof's translation, including some whose implementation is underway, and demonstrates them with examples and a case study.", "num_citations": "30\n", "authors": ["32"]}
{"title": "The role of contracts in distributed development\n", "abstract": " Distributed software development raises new software engineering challenges resulting from the difficulty of making several teams cooperate across different countries, time zones and cultures. These obstacles can lead to critical delays or even failures. One of the most effective techniques for overcoming them is to improve the quality of software specifications. Our experience with a distributed software project in an educational environment suggests that Design by Contract techniques provide a promising solution.", "num_citations": "30\n", "authors": ["32"]}
{"title": "Object-oriented applications\n", "abstract": " Written by key researchers in the field of object-oriented technology, this is the first book to provide in-depth study of actual object-oriented applications. Technically detailed, it includes interesting source code extracts, specification of important classes, system structure diagrams, and much more.", "num_citations": "30\n", "authors": ["32"]}
{"title": "Reasoning about function objects\n", "abstract": " Modern object-oriented languages support higher-order implementations through function objects such as delegates in C#, agents in Eiffel, or closures in Scala. Function objects bring a new level of abstraction to the object-oriented programming model, and require a comparable extension to specification and verification techniques. We introduce a verification methodology that extends function objects with auxiliary side-effect free (pure) methods to model logical artifacts: preconditions, postconditions and modifies clauses. These pure methods can be used to specify client code abstractly, that is, independently from specific instantiations of the function objects. To demonstrate the feasibility of our approach, we have implemented an automatic prover, which verifies several non-trivial examples.", "num_citations": "29\n", "authors": ["32"]}
{"title": "Steps towards a theory and calculus of aliasing\n", "abstract": " A theory, graphical notation, mathematical calculus and implementation for finding whether two given expressions can, at execution time, denote references attached to the same object. Intended as the basis for a comprehensive solution to the \"frame problem\" and as a complement to, or even a replacement for, separation logic, shape analysis, ownership types and dynamic frames.", "num_citations": "29\n", "authors": ["32"]}
{"title": "Balancing Agility and Formalism in Software Engineering: Second IFIP TC 2 Central and East European Conference on Software Engineering Techniques, CEE-SET 2007, Poznan, Poland\u252c\u00e1\u0393\u00c7\u00aa\n", "abstract": " This book constitutes the thoroughly refereed post-conference proceedings of the Second IFIP TC 2 Central and East Conference on Software Engineering Techniques, CEE-SET 2007, held in Poznan, Poland, in October 2007. The 21 revised full papers presented together with 2 keynote addresses were carefully reviewed and selected from 73 initial submissions. The papers are organized in topical sections on measurement, processes, UML, experiments, tools, and change.", "num_citations": "29\n", "authors": ["32"]}
{"title": "Awareness and merge conflicts in distributed software development\n", "abstract": " Collaborative software development requires programmers to coordinate their work and merge individual contributions into a consistent shared code base. Traditionally, coordination follows a series of update-modify-commit\" cycles, where merge conflicts arise upon committing if individual modifications have diverged and must be explicitly reconciled. Researchers have been suggesting that providing timely awareness information about \"who's changing what\" may not only help deal with conflicts but, more generally, improve the effectiveness of collaboration. This paper investigates the impact of awareness information in the context of globally distributed software development. Based on an analysis of data from 105 student developers constituting 12 development teams located in different countries, we analyze, among other things: 1) the frequency of merge conflicts and insufficient awareness, 2) the impact of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "28\n", "authors": ["32"]}
{"title": "Information technology and managing quality education\n", "abstract": " As editors of this volume we are very happy to publish a selection of the papers that were presented at the 9th Conference of Working Group 3.7 of the International Federation for Information Processing, which was held in July 2010. The focus of Working Group 3.7 is on ITEM: Information Technology in Educational Management (for more information, please visit our website http://item. wceruw. org/), and the theme of its 2010 conference was:\u0393\u00c7\u00a3Information Technology and Managing Quality Education.\u0393\u00c7\u00a5 The conference was a very special occasion. Our Working Group started its activities in 1994 in Israel (officially we were not an IFIP Working Group at that time yet). As a Working Group we have since then organized two-yearly conferences in Asia (Hong Kong, Japan), the USA, Europe (Gran Canarias, Spain and Finland), New Zealand and in Australia. In 2010 our Working Group travelled to Kasane in northern\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "28\n", "authors": ["32"]}
{"title": "Using contracts and boolean queries to improve the quality of automatic test generation\n", "abstract": " Since test cases cannot be exhaustive, any effective test case generation strategy must identify the execution states most likely to uncover bugs. The key issue is to define criteria for selecting such interesting states.             If the units being tested are classes in object-oriented programming, it seems attractive to rely on the boolean queries present in each class, which indeed define criteria on the states of the corresponding objects, and \u0393\u00c7\u00f6 in contract-equipped O-O software \u0393\u00c7\u00f6 figure prominently in preconditions, postconditions and invariants. As these queries are part of the class specification and hence relevant to its clients, one may conjecture that the resulting partition of the state space is also relevant for tests.             We explore this conjecture by examining whether relying on the boolean queries of a class to extract abstract states improves the results of black-box testing. The approach uses constraint\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "28\n", "authors": ["32"]}
{"title": "An incremental hint system for automated programming assignments\n", "abstract": " The advent of Massive Open Online Courses makes it essential to develop tools and techniques that automatically support computer science students in solving programming assignments. Complementing existing tools for automatically checking the correctness of students' programs, we have developed and evaluated an incremental hint system for programming exercises. The hint system displays, upon request from a student, a series of hints on how to approach a solution. The hints are created in advance from the source code of the exercise's reference solution using our hint generation tool. This tool can run in fully automatic mode, where hints reveal more and more parts of the solution code; in manual mode, where teachers can customize hints by annotating the input source code; and in a combination of the two modes. We evaluated the hint system throughout our Introduction to Programming course which\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "27\n", "authors": ["32"]}
{"title": "Methods need theory\n", "abstract": " Methods Need Theory - Research Collection Header Upper Right Menu Log in de jump to https://www.ethz.ch Research Collection Toggle navigation Upper Right Menu Login Help Help Language Deutsch Toggle navigation Search View Item Home Other Publications Other Publication View Item Home Other Publications Other Publication View Item Research Collection Navigational link Search Methods Need Theory Mendeley CSV RIS BibTeX Thumbnail Metadata only Author Jacobsen, Ivar Meyer, Bertrand Date 2009 Type Other Publication ETH Bibliography yes Altmetrics Publication status published Journal / series Dr. Dobb's Journal Publisher TechWeb More Show all metadata ETH Bibliography yes Altmetrics \u2229\u2557\u2510 Browse Organisational UnitsPublication TypesAuthors Publish New Submission Statistics Downloads by CountryMost Popular ItemsMost Popular Authors Footer Imprint Terms of Use About Research \u0393\u00c7\u00aa", "num_citations": "27\n", "authors": ["32"]}
{"title": "Dependable software\n", "abstract": " Achieving software reliability takes many complementary tech-niques, directed at the process or at the products. This survey summarizes some of the most fruitful ideas.", "num_citations": "27\n", "authors": ["32"]}
{"title": "Sequential and concurrent object-oriented programming\n", "abstract": " How can the object-oriented model cover concurrent programming as effectively as it addresses sequential computation? The answer proposed in this article suggests that a modest adaptation to the semantics of object-oriented programs may suffice. This includes introducing an explicit notion of procesSor (but not of process, a concept which objectoriented techniques already cover), explicit declarations for\" separate'\" entities, a new semantics for preconditions on routines handled by different processors, and\"'lazy wait\" for implicit resynchronization.", "num_citations": "27\n", "authors": ["32"]}
{"title": "Stateful testing: Finding more errors in code and contracts\n", "abstract": " Automated random testing has shown to be an effective approach to finding faults but still faces a major unsolved issue: how to generate test inputs diverse enough to find many faults and find them quickly. Stateful testing, the automated testing technique introduced in this article, generates new test cases that improve an existing test suite. The generated test cases are designed to violate the dynamically inferred contracts (invariants) characterizing the existing test suite. As a consequence, they are in a good position to detect new faults, and also to improve the accuracy of the inferred contracts by discovering those that are unsound. Experiments on 13 data structure classes totalling over 28,000 lines of code demonstrate the effectiveness of stateful testing in improving over the results of long sessions of random testing: stateful testing found 68.4% new faults and improved the accuracy of automatically inferred\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "26\n", "authors": ["32"]}
{"title": "Contracts for concurrency\n", "abstract": " The SCOOP model extends the Eiffel programming language to provide support for concurrent programming. The model is based on the principles of Design by Contract. The semantics of contracts used in the original proposal (SCOOP_97) is not suitable for concurrent programming because it restricts parallelism and complicates reasoning about program correctness. This article outlines a new contract semantics which applies equally well in concurrent and sequential contexts and permits a flexible use of contracts for specifying the mutual rights and obligations of clients and suppliers while preserving the potential for parallelism. We argue that it is indeed a generalisation of the traditional correctness semantics. We also propose a proof technique for concurrent programs which supports proofs\u0393\u00c7\u00f6similar to those for traditional non-concurrent programs\u0393\u00c7\u00f6of partial correctness and loop termination in the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "26\n", "authors": ["32"]}
{"title": "Towards practical proofs of class correctness\n", "abstract": " Preliminary steps towards a theory, framework and process for proving that contract-equipped classes satisfy their contracts, including when the run-time structure involves pointers; and its application to correctness proofs of routines from a LINKED_LIST class, such as element removal and list reversal.", "num_citations": "26\n", "authors": ["32"]}
{"title": "C to OO translation: Beyond the easy stuff\n", "abstract": " Can we reuse some of the huge code-base developed in C to take advantage of modern programming language features such as type safety, object-orientation, and contracts? This paper presents a source-to-source translation of C code into Eiffel, a modern object-oriented programming language, and the supporting tool C2Eif. The translation is completely automatic and supports the entire C language (ANSI, as well as many GNU C Compiler extensions, through CIL) as used in practice, including its usage of native system libraries and inlined assembly code. Our experiments show that C2Eif can handle C applications and libraries of significant size (such as vim and libgsl), as well as challenging benchmarks such as the GCC torture tests. The produced Eiffel code is functionally equivalent to the original C code, and takes advantage of some of Eiffel's features to produce safe and easy-to-debug translations.", "num_citations": "25\n", "authors": ["32"]}
{"title": "A framework for describing and comparing courses and curricula\n", "abstract": " Curriculum and course planning is a key step in developing quality educational programs, but current practices very often lack a systematic approach. This article addresses this issue by refining and expanding the concept of Testable, Reusable Unit of Cognition (Truc). The methodology allows modeling courses and verifying compliance of a given course to a given description. It also makes it possible to describe precisely what students have previously learned and, as a result, adapt the teaching to their specific needs. The article presents a case study of comparing a subset of two introductory programming textbooks and describes the application TrucStudio that supports the methodology.", "num_citations": "25\n", "authors": ["32"]}
{"title": "Pattern componentization: the factory example\n", "abstract": " Can Design Patterns be turned into reusable components? To help answer this question, we have performed a systematic study of the standard design patterns. One of the most interesting is Abstract Factory, for which we were indeed able to build a reusable component fulfilling the same needs as the original pattern. This article presents the component\u0393\u00c7\u00d6s design and its lessons for the general issue of pattern componentization.", "num_citations": "25\n", "authors": ["32"]}
{"title": "Writing correct software\n", "abstract": " M y aim in designing Eiffel was to produce a major programming language for the 1990s, catering to the needs of those. software engineers willing to do what it takes to produce high-quality software. A key aspect of Eiffel, which makes it original in the world of object-oriented languages, and in the world of programming languages at large, is its strong emphasis on techniques that help produce highly reliable software.", "num_citations": "25\n", "authors": ["32"]}
{"title": "Incremental string matching\n", "abstract": " The problem studied in this paper is to search a given text for occurrences of certain strings, in the particular case where the set of strings may change as the search proceeds.A well-known algorithm by Aho and Corasick applies to the simpler case when the set of strings is known beforehand and does not change. This algorithm builds a transition diagram (finite automaton) from the strings, and uses it as a guide to traverse the text. The search can then be done in linear time.We show how this algorithm can be modified to allow incremental diagram construction, so that new keywords may be entered at any time during the search. The incremental algorithm presented essentially retains the time and space complexities of the non-incremental one.", "num_citations": "25\n", "authors": ["32"]}
{"title": "Complete contracts through specification drivers\n", "abstract": " Existing techniques of Design by Contract do not allow software developers to specify complete contracts in many cases. Incomplete contracts leave room for malicious implementations. This article complements Design by Contract with a simple yet powerful technique that removes the problem without adding syntactical mechanisms. The proposed technique makes it possible not only to derive complete contracts, but also to rigorously check and improve completeness of existing contracts without instrumenting them.", "num_citations": "24\n", "authors": ["32"]}
{"title": "Unifying requirements and code: an example\n", "abstract": " Requirements and code, in conventional software engineering wisdom, belong to entirely different worlds. Is it possible to unify these two worlds? A unified framework could help make software easier to change and reuse. To explore the feasibility of such an approach, the case study reported here takes a classic example from the requirements engineering literature and describes it using a programming language framework to express both domain and machine properties. The paper describes the solution, discusses its benefits and limitations, and assesses its scalability.", "num_citations": "24\n", "authors": ["32"]}
{"title": "Object-oriented modeling of object-oriented concepts\n", "abstract": " Teaching introductory object-oriented programming presents considerable challenges. Some of these challenges are due to the intrinsic complexity of the subject matter \u0393\u00c7\u00f6 object-oriented concepts are tightly interrelated and appear in many combinations. The present work describes an approach to modeling educational domains and reports on the results for object-orientation. It analyzes the dependency structure of object-oriented concepts and describes the implications that the high interrelatedness of concepts has on teaching introductory programming.", "num_citations": "24\n", "authors": ["32"]}
{"title": "SCOOP\u0393\u00c7\u00f4A contract-based concurrent object-oriented programming model\n", "abstract": " SCOOP is a concurrent object-oriented programming model based on contracts. The model introduces processors as a new concept and it generalizes existing object-oriented concepts for the concurrent context. Simplicity is the main objective of SCOOP. The model guarantees the absence of data races in any execution of a SCOOP program. This article is a technical description of SCOOP as defined by Nienaltowski [11] and Meyer [7,9,10].", "num_citations": "24\n", "authors": ["32"]}
{"title": "The power of abstraction, reuse, and simplicity: An object-oriented library for event-driven design\n", "abstract": " A new library for event-driven design, defining a general and extendible scheme yet easy to learn and use on both the publisher and subscriber sides, provides an opportunity to analyze such other approaches as the \u0393\u00c7\u00a5Observer Pattern\u0393\u00c7\u00a5, the event-delegate mechanism of .NET and its \u0393\u00c7\u00a5Web Forms\u0393\u00c7\u00a5, then to draw some general software engineering lessons.", "num_citations": "24\n", "authors": ["32"]}
{"title": "An object-oriented environment: Principles and application\n", "abstract": " Meyer has introduced his object technology through a series of four books covering the object-oriented language Eiffel; an object-oriented development methodology; reusability through the object-oriented approach; and an object-oriented environment. This is the fourth book, describing the object-oriented environment based on the Eiffel language. The book starts with a preface presenting the key issues in object-oriented development as well as the use of Eiffel Bench in the construction of portable standard C code. The rest of the book is organized into 12 chapters. The first chapter provides a roadmap for the environment. The second chapter introduces the use of Eiffel Bench as the main driver for project specification and module integration. Fundamental design principles of the environment are discussed in chapter 3, including the consistency principle, direct manipulation, strong typing, and error prevention\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "24\n", "authors": ["32"]}
{"title": "Seamless requirements\n", "abstract": " Popular notations for functional requirements specifications frequently ignore developers\u0393\u00c7\u00d6 needs, target specific development models, or require translation of requirements into tests for verification; the results can give out-of-sync or downright incompatible artifacts. Seamless requirements, a new approach to specifying functional requirements, contributes to developers\u0393\u00c7\u00d6 understanding of requirements and to software quality regardless of the process, while the process itself becomes lighter due to the absence of tests in the presence of formal verification. A development case illustrates these benefits, and a discussion compares seamless requirements to other approaches.", "num_citations": "23\n", "authors": ["32"]}
{"title": "Automatic verification of advanced object-oriented features: The AutoProof approach\n", "abstract": " Static program verifiers such as Spec#, Dafny, jStar, and VeriFast define the state of the art in automated functional verification techniques. The next open challenges are to make verification tools usable even by programmers not fluent in formal techniques. This paper discusses some techniques used in AutoProof, a verification tool that translates Eiffel programs to Boogie and uses the Boogie verifier to prove them. In an effort to be usable with real programs, AutoProof fully supports several advanced object-oriented features including polymorphism, inheritance, and function objects. AutoProof also adopts simple strategies to reduce the amount of annotations needed when verifying programs (e.g., frame conditions). The paper illustrates the main features of AutoProof\u0393\u00c7\u00d6s translation, including some whose implementation is underway, and demonstrates them with examples and a case study.", "num_citations": "23\n", "authors": ["32"]}
{"title": "Proof-transforming compilation of eiffel programs\n", "abstract": " In modern development schemes the processing of programs often involves an intermediate step of translation to some intermediate bytecode, complicating the verification task. Expanding on the ideas of Proof-Carrying Code (PCC), we have built a proof-transforming compiler which translates a contract-equipped program and its proof into bytecode representing both the program and the proof; before execution starts, the program will be run through a proof checker. The proofs address not only security properties, as in the original PCC work, but full functional correctness as expressed by the original contracts. The task of the proof-transforming compiler is made particularly challenging by the impedance mismatch between the source language, Eiffel, and the target code, .NET CIL, which does not directly support such important Eiffel mechanisms as multiple inheritance and contract-based exceptions. We\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "23\n", "authors": ["32"]}
{"title": "Contracts for concurrency\n", "abstract": " The SCOOP model extends the Eiffel programming language to provide support for concurrent programming. The model is largely based on the principles of Design by Contract. Nevertheless, the semantics of contracts used in SCOOP is not suitable for concurrent programming because it only allows for restricted reasoning about correctness properties; liveness properties are completely intractable. Additionally, SCOOP does not provide a clear semantics for postconditions. We propose a generalized semantics of preconditions, postconditions, and invariants that is applicable in concurrent and sequential contexts. We demonstrate how this semantics may be used for reasoning about correctness of SCOOP programs. We also analyze the relation between assertion violations and deadlocks. We illustrate the discussion with several examples.", "num_citations": "23\n", "authors": ["32"]}
{"title": "Building reliable client-server software using actively replicated objects\n", "abstract": " Combining replication and objects is a profitable approach to build fault tolerant distributed software. However, replication brings up several problems related to object interactions. In particular, this paper investigates the duplicated interaction problem which is raised whenever actively replicated objects interact. The paper presents the pre-filtering approach, a general solution to this problem. Prefiltering has been implemented in GARF, an objectoriented system intended to simplify the programming of fault tolerant distributed software.", "num_citations": "22\n", "authors": ["32"]}
{"title": "Making sense of agile methods\n", "abstract": " Bertrand Meyer runs agile methods and practices through his personal friend-or-foe test. He also offers his experiences and opinions about the hype, ugly, good, and even brilliant aspects of agile development.", "num_citations": "21\n", "authors": ["32"]}
{"title": "Efficient and reasonable object-oriented concurrency\n", "abstract": " Making threaded programs safe and easy to reason about is one of the chief difficulties in modern programming. This work provides an efficient execution model for SCOOP, a concurrency approach that provides not only data-race freedom but also pre/postcondition reasoning guarantees between threads. The extensions we propose influence both the underlying semantics to increase the amount of concurrent execution that is possible, exclude certain classes of deadlocks, and enable greater performance. These extensions are used as the basis of an efficient runtime and optimization pass that improve performance 15x over a baseline implementation. This new implementation of SCOOP is, on average, also 2x faster than other well-known safe concurrent languages. The measurements are based on both coordination-intensive and data-manipulation-intensive benchmarks designed to offer a mixture of workloads.", "num_citations": "21\n", "authors": ["32"]}
{"title": "A framework for proving contract-equipped classes\n", "abstract": " As part of a general effort to provide a new basis for software development through reuse of \u0393\u00c7\u00a3Trusted Components\u0393\u00c7\u00a5, we outline a scheme for proving that classes equipped with contracts in the Eiffel style meet these contracts. The approach takes advantage of the inheritance structure to separate proof obligations between deferred (abstract) classes, to be validated against a model, and their effective implementations, which then must only be proved against the contracts of the deferred ancestors. The testbed for this study is the EiffelBase library of fundamental data structures and algorithms, whose classes include extensive contracts.", "num_citations": "21\n", "authors": ["32"]}
{"title": "The reusability challenge\n", "abstract": " The traditional \"reuse or redo\" dilemma is unacceptable; we need to reuse what is applicable to our current need and redo the rest. This is where object technology helps. The argument we examine-that object technology promotes reusability-has been one of the central claims of OO proponents since the field's emergence in the mid-1980s. The paper considers the features that make object oriented ideas so special in the quest for reusable software.", "num_citations": "21\n", "authors": ["32"]}
{"title": "Disciplined exceptions\n", "abstract": " One of the most delicate problems of software construction is the handling of abnormal a situations. How can a programmer write robust software components, which will take care of ll possible cases, without impairing the elegance of the structure and the processing of normal cases?", "num_citations": "21\n", "authors": ["32"]}
{"title": "Principles of package design\n", "abstract": " Subprogram packages are groups of related subroutines used to extend the available facilities in a programming system. The results of developing several such packages for various applications are presented, with a distinction made between external and internal design criteria\u0393\u00c7\u00f6 what properties packages should offer to their users and the guidelines designers should follow in order to provide them. An important issue, the design of reusable software, is thus addressed, and the concept of abstract data types proposed as a desirable solution.", "num_citations": "21\n", "authors": ["32"]}
{"title": "A modular scheme for deadlock prevention in an object-oriented programming model\n", "abstract": " Despite the advancements of concurrency theory in the past decades, practical concurrent programming has remained a challenging activity. Fundamental problems such as data races and deadlocks still persist for programmers since available detection and prevention tools are unsound or have otherwise not been well adopted. In an alternative approach, programming models that exclude certain classes of errors by design can address concurrency problems at a language level. In this paper we review SCOOP, an existing race-free programming model for concurrent object-oriented programming, and extend it with a scheme for deadlock prevention based on locking orders. The scheme facilitates modular reasoning about deadlocks by associating annotations with the interfaces of routines. We prove deadlock-freedom of well-formed programs using a rigorous formalization of the locking semantics of the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "20\n", "authors": ["32"]}
{"title": "Concurrent object-oriented programming on. NET\n", "abstract": " The SCOOP model (Simple Concurrent Object-Oriented Programming) offers a comprehensive approach to building high-quality concurrent and distributed systems. The model takes advantage of the inherent concurrency implicit in object-oriented programming to provide programmers with a simple extension enabling them to produce concurrent applications with little more effort than sequential ones. In the paper, the authors discuss the basic concepts of the model, such as processors and separate objects. They also present SCOOPLI, a library implementation of SCOOP for the .NET platform. They show how SCOOP concepts are mapped to .NET constructs, and discuss distributed programming with SCOOPLI, with a focus on .NET remoting capabilities. Several programming examples illustrate the discussion.", "num_citations": "20\n", "authors": ["32"]}
{"title": "Many (= all) are called, but few (= not all) are chosen\n", "abstract": " The conviction that God is good, that he takes \u0393\u00c7\u00ffno pleasure in the death of the wicked\u0393\u00c7\u00d6 (Ezek 18. 23), that he \u0393\u00c7\u00ffdesires all men to be saved\u0393\u00c7\u00d6 (1 Tim 2. 4), and that Christ \u0393\u00c7\u00ffgave himself as a ransom for all\u0393\u00c7\u00d6 (1 Tim 2. 4), belongs to the main thrust of Christian soteriology. Although there have been soteriological pessimists (Thomas Aquinas, the Angelic Doctor, was an optimist on the salvation of the angels, but a pessimist on the salvation of human beings) and optimists (Karl Barth construed Paul's universalist teleology as a flat guarantee of universal salvation), most Christians have had to content themselves with an affirmation of God's at least antecedently universal salvific will, with the hope for the salvation of many and even of all, and with a straightforward agnosticism respecting whether the finally lost will be \u0393\u00c7\u00ffany\u0393\u00c7\u00d6 or \u0393\u00c7\u00ffmany\u0393\u00c7\u00d6 or something in between. But, in the word of Matt 22.14 (l.v. 20. 16), Jesus himself speaks, and he\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "20\n", "authors": ["32"]}
{"title": "Eiffel: An Introdution\n", "abstract": " The Eiffel language and environment apply the conceplS of object-oriented design and programming to the construction of high quality software. As a language, Eiffel provides a range of features for the construction of reusable and reliable software components: classes. multiple inheritance. polymorphism and dynamic binding. genericity. strict static type checking. a disciplined exception mechanism. systematic use of assertions, invariants and other constructs for ensuring program correctness.Eiffel is implemented by compilation through C. ensuring wide portability. On option. a stand alone C package, movable to any machine supporting C. may be generated from the text of an Eiffel system. However the language itself is an original design and has no relation to C. The environment ensures separate compilation of Eiffel classes; it also takes care of recompilation mangagement, automatically triggering re-compilation of modified classes without programmer intervention. The tools of the environment include facilities for automatic documentation (producing a class interface description from the clauss texIS), class browsers, an interactive debugger. a system for graphical display of class hierarchies. an optimising postprocessor and other facilities.", "num_citations": "20\n", "authors": ["32"]}
{"title": "Prototyping a concurrency model\n", "abstract": " Many novel programming models for concurrency have been proposed in the wake of the multicore computing paradigm shift. They aim to raise the level of abstraction for expressing concurrency and synchronization in a program, and hence to help developers avoid programming errors. Because of this goal, the semantics of the models themselves becomes ever more complex, increasing the risk of design flaws. We propose a methodology for prototyping concurrency models using executable formal specifications. The prototype can be used to test and correct the model at an early stage. Once the development is completed, the executable formal specification serves as an unambiguous reference. We apply this methodology to SCOOP, an object-oriented concurrency model. Using this approach, we were able to uncover and fix three major flaws in the model.", "num_citations": "19\n", "authors": ["32"]}
{"title": "A sound and complete program logic for Eiffel\n", "abstract": " Object-oriented languages provide advantages such as reuse and modularity, but they also raise new challenges for program verification. Program logics have been developed for languages such as C# and Java. However, these logics do not cover the specifics of the Eiffel language. This paper presents a program logic for Eiffel that handles exceptions, once routines, and multiple inheritance. The logic is proven sound and complete w.r.t. an operational semantics. Lessons on language design learned from the experience are discussed.", "num_citations": "19\n", "authors": ["32"]}
{"title": "Copwatching et perception publique de la police. L'intervention polici\u251c\u00bfre comme performance sous surveillance\n", "abstract": " Envisag\u251c\u2310e comme une situation sociale de rassemblement en rue, l'intervention polici\u251c\u00bfre se caract\u251c\u2310rise par sa nature publique et observable. Le \u252c\u00bd copwatching \u252c\u2557, en tant que pratique amateur de captation vid\u251c\u2310o des interventions de police, probl\u251c\u2310matise la visibilit\u251c\u2310 des agents sur la voie publique en les soumettant \u251c\u00e1 une surveillance m\u251c\u2310diatique. M'appuyant sur des exemples vid\u251c\u2310os, j'explore les dimensions visuelles et symboliques du travail policier. De la performance polici\u251c\u00bfre en rue \u251c\u00e1 la figuration m\u251c\u2310diatique du policier, l'\u251c\u2310tude des m\u251c\u2310diations entre action et image permet d'interroger la perception publique de la police engag\u251c\u2310e dans les rassemblements. Abstract Cop-watching and the public perception of the police. Police intervention as performance under surveillance. This paper deals with police work as a public performance on the street. Cop-watching, a way of publicly observing and documenting police activities, reveals the complex relationship between public perceptions of law enforcement and the visual nature of much police work. Three methodological approaches to cop-watching videos allow us to highlight the visual dimensions of police work : the study of mass-media images of cops, the study of street performance by real cops, and the study of the ways people make sense of the visual symbolic environment present in everyday police work.", "num_citations": "18\n", "authors": ["32"]}
{"title": "On the effectiveness of test extraction without overhead\n", "abstract": " Developers write and execute ad-hoc tests as they implement software. While these tests reflect important insights of the developers (e.g., which parts of the software need testing and what inputs should be used), they are usually not persistent and are easily forgotten. They cannot always be re-executed automatically, for example to debug or to test for regressions. Several methods that make such test cases persistent and automatically executable have been proposed. They rely on capturing state and/or events at runtime and thus induce significant overhead or require specialized hardware. In previous work we proposed a method that, in the event of a failure, extracts test cases solely from the state at the time of the failure (and not from before the failure). We call this method \"failure-state extraction\". Capturing the state only at the moment of failure reduces the run-time overhead to zero, but comes at a cost: state\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "18\n", "authors": ["32"]}
{"title": "Language, Context and Text: Aspects of Language in a Social\u0393\u00c7\u00c9Semiotic Perspective: M.A.K. Halliday and Ruqaiya Hasan.\n", "abstract": " In conclusion, then, the Longman Dictionary of Applied Linguistics is an extremely useful resource for students of applied linguistics, but the authors may want to include more relevant terminology from recent linguistic theory in future editions. Common acronyms for organizations, such as ACTFL or BAAL, may be useful too, though I realize their choice would be difficult. Expanding certain entries, finally, may make the Dictionary more useful to scholars and advanced students of applied linguistics who want to brush up their memories about concepts they are less familiar with. At any rate, the authors and their collaborators have done an impressive job, and their work may become a major study tool, as it fills a real gap in our reference sections.", "num_citations": "18\n", "authors": ["32"]}
{"title": "Automated program repair in an integrated development environment\n", "abstract": " We present the integration of the AutoFix automated program repair technique into the EiffelStudio Development Environment. AutoFix presents itself like a recommendation system capable of automatically finding bugs and suggesting fixes in the form of source-code patches. Its performance suggests usage scenarios where it runs in the background or during work interruptions, displaying fix suggestions as they become available. This is a contribution towards the vision of semantic Integrated Development Environments, which offer powerful automated functionality within interfaces familiar to developers. A screencast highlighting the main features of AutoFix can be found at: http://youtu.be/Ff2ULiyL-80.", "num_citations": "17\n", "authors": ["32"]}
{"title": "Collaborative debugging\n", "abstract": " Debugging - the process of finding and correcting programming mistakes - faces too the challenges of distributed and collaborative development. The debugging tools commonly used by programmers are integrated into traditional development environments such as Eclipse or Visual Studio, and hence do not offer specific features for collaboration or remote shared usage. In this paper, we describe CDB, a debugging technique and integrated tool specifically designed to support effective collaboration among developers during shared debugging sessions. We also discuss the design and results of an empirical study aimed at identifying features that can ameliorate the effectiveness of collaborative debugging processes, and at evaluating the usefulness of our CDB collaborative debugging approach. The study suggests that CDB's collaboration features are often perceived as important for effective debugging, and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "17\n", "authors": ["32"]}
{"title": "Unifying configuration management with merge conflict detection and awareness systems\n", "abstract": " As software development becomes an increasingly collaborative effort, traditional development tools have to be extended to support seamless collaboration while minimizing the chances of conflicts. This paper describes Cloud Studio, a collaboration framework that integrates a fine-grained software configuration management model and a real-time awareness system. Cloud Studio's configuration management operates transparently by automatically sharing the changes of developers working on the same project, the real-time awareness system allows for dynamic views on the project selectively including or excluding other developers' changes. With this tight integration, conflicts are prevented in many cases, while leaving individual developers free to experiment without blocking others. The paper also describes a freely available prototype web-based implementation of Cloud Studio and a case study that\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "17\n", "authors": ["32"]}
{"title": "Avoid a void: The eradication of null dereferencing\n", "abstract": " All object-oriented programs, but also those in C or Pascal as soon as they use pointers, are subject to the risk of run-time crash due to \u0393\u00c7\u00a3null pointer dereferencing\u0393\u00c7\u00a5. Until recently this was the case even in statically typed languages. Tony Hoare has called this problem his \u0393\u00c7\u00a3billion-dollar mistake\u0393\u00c7\u00a5. In the type system of ISO-standard Eiffel, the risk no longer exists: void safety (the absence of null pointer dereferencing) has become a property guaranteed by the type system and enforced by the compiler. The mechanism is fully implemented and major libraries and applications have been made void-safe. This presentation describes the principles of Eiffel\u0393\u00c7\u00d6s void safety, their implementation and the lessons gained.", "num_citations": "17\n", "authors": ["32"]}
{"title": "Physics Education in Virtual Reality: An Example.\n", "abstract": " We present an immersive virtual reality (VR) application for physics education. It utilizes a recent physics engine developed for the PC gaming market to simulate physical experiments correctly and accurately. Students are enabled to actively build their own experiments and study them. A variety of tools are provided to analyze forces, mass, paths and other properties of objects before, during and after experiments. Innovative teaching content is presented that exploits the strengths of the 3D virtual environment. Physics Playground serves as an example of how current technologies can be combined to deliver a new quality in physics education.", "num_citations": "17\n", "authors": ["32"]}
{"title": "SmartWalker: An intelligent robotic walker\n", "abstract": " Ensuring mobility of the elderly is an important task in our aging society. To this end, this paper presents SmartWalker, a high-tech extension of a regular walker that aims to navigate around its environment autonomously and assist its user intelligently. The walker is equipped with sensors and actuators and operates in two modes, autonomous and assistive. In the autonomous mode, the walker accepts gesture commands via its gesture-based interface and navigates around accordingly. The interface uses a k-nearest neighbors classifier with dynamic time warping to recognize gestures and the Viola and Jones face detector to locate the user. In the assistive mode, its automatic speed controller determines the optimal speed for the walker. The walker locates its user by detecting the user\u0393\u00c7\u00d6s legs using a laser range scanner and combines the information with other sensory data for the speed control. The walker was\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "16\n", "authors": ["32"]}
{"title": "Automatic program repair by fixing contracts\n", "abstract": " While most debugging techniques focus on patching implementations, there are bugs whose most appropriate corrections consist in fixing the specification to prevent invalid executions\u0393\u00c7\u00f6such as to define the correct input domain of a function. In this paper, we present a fully automatic technique that fixes bugs by proposing changes to contracts (simple executable specification elements such as pre- and postconditions). The technique relies on dynamic analysis to understand the source of buggy behavior, to infer changes to the contracts that emend the bugs, and to validate the changes against general usage. We have implemented the technique in a tool called SpeciFix which works on programs written in Eiffel, and evaluated it on 44 bugs found in standard data-structure libraries. Manual analysis by human programmers found that SpeciFix suggested repairs that are deployable for 25% of the faults; in\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "16\n", "authors": ["32"]}
{"title": "Design by contract: Making object-oriented programs that work\n", "abstract": " To deliver on its promises, object-oriented technology must be able to produce systems that are reliable (correct and robust). Only under these conditions will the other quality factors advertised for the method, in particular the increase in re-usability and extendibility, yield the expected benefits for software practitioners. It is indeed possible to use object-oriented technology to produce, almost routinely, software systems that reach a degree of reliability without any equivalent in conventional methods, languages and tools. This requires a strict application of pure object-oriented concepts, in particular, seamlessness (the use of a consistent method and notation throughout the software life-cycle), information hiding, automatic garbage collection, static typing, and the combination of static typing and dynamic binding. Another key component of this approach is the notion of design by contract, which leads to the production\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "16\n", "authors": ["32"]}
{"title": "An experiment on teaching coordination in a globally distributed software engineering class\n", "abstract": " The importance of planning and management skills in software development is very difficult to convey in software engineering courses. We present the synopsis of an assignment whose purpose is to demonstrate the significance of such skills, including effective communication, team coordination and collaboration, and overall project planning. The assignment is organized in the context of a distributed software engineering course carried out in collaboration with 12 universities in South America, Europe and Africa. The assignment is a globally distributed contest issued before most development activities related to the course's software project are performed, aiming at favoring the collaboration between students prior to project development. The contest does not involve any programming, and is not related to the project development activities. Instead, it consists of making teams in different countries compete in\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "15\n", "authors": ["32"]}
{"title": "Program checking with less hassle\n", "abstract": " The simple and often imprecise specifications that programmers may write are a significant limit to a wider application of rigorous program verification techniques. Part of the reason why non-specialists find writing good specification hard is that, when verification fails, they receive little guidance as to what the causes might be, such as implementation errors or inaccurate specifications. To address these limitations, this paper presents two-step verification, a technique that combines implicit specifications, inlining, and loop unrolling to provide improved user feedback when verification fails. Two-step verification performs two independent verification attempts for each program element: one using standard modular reasoning, and another one after inlining and unrolling; comparing the outcomes of the two steps suggests which elements should be improved. Two-step verification is implemented in AutoProof, our\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "15\n", "authors": ["32"]}
{"title": "Immune response to xenogeneic matrix grafts used in pediatric surgery\n", "abstract": " Background: Lyoplant\u252c\u00ab is an acellular, bovine derived extracellular matrix (ECM) that has been used for tissue remodelling and repair in numerous xenotransplantations. The aim of our study was to evaluate the inflammatory response and tensile strength after xenogeneic matrix (Lyoplant\u252c\u00ab) implantation compared to the more widely used synthetic polypropylene matrix. Methods: Full-thickness abdominal wall defects were created in 15 Wistar WU rats and reconstructed with either a Lyoplant\u252c\u00ab matrix (B. Braun Aesculap, Tuttlingen, Germany) or a Prolene\u252c\u00ab matrix (a polypropylene matrix [PPP]; Prolene\u252c\u00ab, Ethicon, Norderstedt, Germany). Animals in both the treatment and the control groups were checked daily for local and systemic complications. Bodyweight was recorded and the possible development of a hernia was monitored. After 6 weeks the abdomen was reopened and adhesions to the intestine were\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "15\n", "authors": ["32"]}
{"title": "The future of object technology\n", "abstract": " In the future, object technology will not be confined to a niche. Objects will be pervasive; very little serious software will not be object-oriented at least in some way in 1998 and beyond. Object technology isn't a matter of fashion. It's simply that no-one really knows how to tackle the kind of sophisticated systems that our users now want, without using object technology. It's also that no one has found anything better. Since object technology came into prominence a decade ago, pundits have at various times predicted its demise, with the inevitable periodic announcements of the so-called \"Object Winter\"-an allusion to the \"AI Winter\" that froze the spread of artificial intelligence in the late 1970s-but winter has not come, and all the signs indicate that spring will continue.", "num_citations": "15\n", "authors": ["32"]}
{"title": "Practice to perfect: the quality first model\n", "abstract": " The author is a software engineer. He describes his own personal strategy for achieving quality software, using the \"Quality First\" method. The steps involved are: the syntax should always be correct; recompilation is done at least every 15 minutes; analysis, design, implementation and maintenance are all intertwined; execution is done straight after compilation; assertions are included everywhere; execution is done with assertion checking on; abnormal cases are tackled immediately; internationalization is catered for; at every stage, there is always a working system; and other people are used when testing.", "num_citations": "15\n", "authors": ["32"]}
{"title": "What do beginning CS majors know?\n", "abstract": " The standard \u0393\u00c7\u00a3Introduction to Programming\u0393\u00c7\u00a5 or \u0393\u00c7\u00a3CS1\u0393\u00c7\u00a5 course traditionally assumes that it will be, for most students, the first serious exposure to programming. For the past six years, we have queried our students, in the first weeks of class, about what they know. Results are compelling: virtually all beginning CS students have used computers for over two years, and many for ten years or more; on average, they know at least one programming language in depth; many have written significant systems. These and other measures of prior knowledge have been stable over the query period. This article analyzes both the results obtained and their pedagogical implications for courses and textbooks.", "num_citations": "14\n", "authors": ["32"]}
{"title": "Reality: a cousin twice removed [object technology]\n", "abstract": " Reasoning too much in terms of the real world can actually be detrimental to software quality. What matters is not how closely we model today's reality but how extensible and reusable our software is, so it can be adapted to a new or changed reality. The paper considers how reusability and extensibility are object technology's central goals. Object technology is not about modeling the real world. Object technology is about producing quality software, and the way to obtain this is to devise the right abstractions, whether or not they model what someone sees as the reality.", "num_citations": "14\n", "authors": ["32"]}
{"title": "Class schema evolution for persistent object-oriented software: Model, empirical study, and automated support\n", "abstract": " With the wide support for object serialization in object-oriented programming languages, persistent objects have become commonplace and most large object-oriented software systems rely on extensive amounts of persistent data. Such systems also evolve over time. Retrieving previously persisted objects from classes whose schema has changed is, however, difficult, and may lead to invalidating the consistency of the application. The ESCHER framework addresses these issues through an IDE-integrated approach that handles class schema evolution by managing versions of the code and generating transformation functions automatically. The infrastructure also enforces class invariants to prevent the introduction of potentially corrupt objects. This paper describes a model for class attribute changes, a measure for class evolution robustness, four empirical studies, and the design and implementation of the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["32"]}
{"title": "Verified Software: Theories, Tools, Experiments: First IFIP TC 2/WG 2.3 Conference, VSTTE 2005, Zurich, Switzerland, October 10-13, 2005, Revised Selected Papers and Discussions\n", "abstract": " A Step Towards Verified Software Worries about the reliability of software are as old as software itself; techniques for allaying these worries predate even James King\u0393\u00c7\u00d6s 1969 thesis on \u0393\u00c7\u00a3A program verifier.\u0393\u00c7\u00a5 What gives the whole topic a new urgency is the conjunction of three phenomena: the blitz-like spread of software-rich systems to control ever more facets of our world and our lives; our growing impatience with deficiencies; and the development\u0393\u00c7\u00f6proceeding more slowly, alas, than the other two trends\u0393\u00c7\u00f6of techniques to ensure and verify software quality. In 2002 Tony Hoare, one of the most distinguished contributors to these advances over the past four decades, came to the conclusion that piecemeal efforts are no longer sufficient and proposed a \u0393\u00c7\u00a3Grand Challenge\u0393\u00c7\u00a5 intended to achieve, over 15 years, the production of a verifying compiler: a tool that while processing programs would also guarantee their adherence to specified properties of correctness, robustness, safety, security and other desirable properties. As Hoare sees it, this endeavor is not a mere research project, as might normally be carried out by one team or a small consortium of teams, but a momentous endeavor, comparable in its scope to the successful mission to send a man to the moon or to the sequencing of the human genome.", "num_citations": "13\n", "authors": ["32"]}
{"title": "Type-safe covariance: Competent compilers can catch all catcalls\n", "abstract": " Goals of expressiveness and flexibility in typed object-oriented programming suggest a \u0393\u00c7\u00a3covariant\u0393\u00c7\u00a5 type policy, where routine redefinitions can change the types of both arguments and results in the same direction as the inheritance hierarchy. Unfortunately, a careless covariant policy, when combined with polymorphism, genericity and dynamic binding\u0393\u00c7\u00f6other OO mechanisms that are just as fundamental\u0393\u00c7\u00f6may lead to run-time type violations known as catcalls. We present a new solution to this problem, resulting from recent advances in the Eiffel language, which enables compilers to spot all potential catcalls and forces programmer to resolve them. The resulting language rules statically guarantee type safety; they only require local analysis and are easy to explain to programmers.", "num_citations": "13\n", "authors": ["32"]}
{"title": "Proving pointer program properties. part 1: Context and overview\n", "abstract": " Efforts to reason formally about programs, and in particular to prove their properties mathematically, have no practical value unless they can handle all the language facilities on which realistic programs depend. It is then not surprising that one of the biggest obstacles to the spread of such correctness-guaranteeing methods has been the lack of a good way to model the highly dynamic nature of the run-time structures created by object-oriented programs\u0393\u00c7\u00f6and by most plain C or Pascal programs\u0393\u00c7\u00f6with their heavy use of pointers, or references, from object to object. The present discussion proposes a mathematical theory for modeling pointer-rich object structures and proving their properties. The model only uses simple concepts from set theory: sets, relations, functions, composition, restriction, image. For run-time operations all it needs is the notion of event, a function yielding a new program state from an existing one. The model has two principal applications:\u0393\u00c7\u00f3 The coarse-grained version of the model, considering only the existence or not of a reference between an object and another, gives a basis for discussing overall properties of the object structure, defining as a result the correctness constraints of memory management and especially garbage collection, full or incremental. Mathematically, this model uses a binary relation.\u0393\u00c7\u00f3 The fine-grained version, based on functions which together make up the relation of the coarse-grained version, integrates the properties of individual object fields. As a result, it allows proving the correctness of classes describing structures with luxurious pointer foliage, from linked lists and graphs to B-trees and double\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["32"]}
{"title": "Static typing\n", "abstract": " E very once in a while, in the history of science, there arises a problem whose statement is so deceptively simple as to fit in a few sentences that a curious adolescent can understand, and whose solution baffles the best minds of a generation. It is of such a problem, central to the understanding and use of object-oriented principles, that I propose to present both the statement and a solution.The simplicity of the problem comes from the simplicity of the object-oriented model of computation, introduced almost thirty years ago by Professors Dahl and Nygaard. If one puts aside the details of an object-oriented language, necessary to write realistic software but auxiliary to the basic model, only one kind of event ever occurs during the execution of an object-oriented system: routine call. In its general form it may be written, using the syntax of Simula and Eiffel, as", "num_citations": "13\n", "authors": ["32"]}
{"title": "Introduction a la theorie des langages de programmation\n", "abstract": " Introduction a la theorie des langages de programmation Toggle navigation English fran\u251c\u00baais \u256a\u00ba\u2518\u00e4\u256a\u2563\u256a\u2592\u256a\u00bf\u2518\u00e8\u256a\u2310 fran\u251c\u00baais English fran\u251c\u00baais \u256a\u00ba\u2518\u00e4\u256a\u2563\u256a\u2592\u256a\u00bf\u2518\u00e8\u256a\u2310 Ouvrir une session Toggle navigation Voir le document Accueil La Biblioth\u251c\u00bfque Centrale Collection 8 Voir le document Accueil La Biblioth\u251c\u00bfque Centrale Collection 8 Voir le document Introduction a la theorie des langages de programmation Thumbnail Date 2017-01-01 Auteur Meyer Bertrand Metadata Afficher la notice compl\u251c\u00bfte URI http://hdl.handle.net/123456789/113949 Collections Collection 8 [10000] DSpace software copyright \u252c\u2310 2002-2015 DuraSpace Contactez-nous | Faire parvenir un commentaire Theme by @mire NV Chercher dans le d\u251c\u2310p\u251c\u2524t Cette collection Parcourir Toute l\u0393\u00c7\u00d6ArchiveCommunaut\u251c\u2310s & CollectionsPar date de publicationAuteursTitresSujetsCette collectionPar date de publicationAuteursTitresSujets Mon compte Ouvrir une sessionS'inscrire DSpace software \u252c\u2310 -\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["32"]}
{"title": "The allure and risks of a deployable software engineering project: Experiences with both local and distributed development\n", "abstract": " The student project is a key component of a software engineering course. What exact goals should the project have, and how should the instructors focus it? While in most cases projects are artificially designed for the course, we use a deployable, realistic project. This paper presents the rationale for such an approach and assesses our experience with it, drawing on this experience to present guidelines for choosing the theme and scope of the project, selecting project tasks, switching student groups, specifying deliverables and grading scheme. It then expands the discussion to the special but exciting case of a project distributed between different universities, the academic approximation of globalized software development as practiced today by the software industry.", "num_citations": "12\n", "authors": ["32"]}
{"title": "Formalizing proof-transforming compilation of eiffel programs\n", "abstract": " The execution of mobile code can produce unexpected behavior, which may comprise security and correctness of a software system. Proof-Carrying Code allows one to execute mobile code in a safe way by checking a formal proof before the code is executed. However, automatic generation of proofs works only for basic safety properties such as type safety. To apply PCC to functional correctness properties, we propose to verify the source program interactively and then to translate the proof to bytecode. This proof translation is relatively straightforward if the source and target language are similar, such as Java and Java bytecode, but poses challenges for more complex translations. In this paper, we present a prooftransforming compiler for a subset of Eiffel to the .NET CIL. In particular, we show how the non-trivial translations of multiple inheritance and Eiffel\u0393\u00c7\u00d6s exceptions can be handled.", "num_citations": "12\n", "authors": ["32"]}
{"title": "Empirical study of novice errors and error paths in objectoriented programming\n", "abstract": " What kind of errors do beginners make? Objective answers to this question are essential to the design and implementation of curricula that don\u0393\u00c7\u00d6t just reflect the educators\u0393\u00c7\u00d6 theories but succeed in conveying a course\u0393\u00c7\u00d6s topics and skills to the students. In the context of a new introductory programming course based on \u0393\u00c7\u00a3inverted curriculum\u0393\u00c7\u00a5 ideas, and taking advantage of our ability to instrument the compiler, we performed automatic analysis of the\u0393\u00c7\u00f6sometimes contorted\u0393\u00c7\u00f6paths students actually take to solve programming exercises on their own. The results, collected from three different groups of students across two unrelated universities, included a number of surprises. These findings will help improve future sessions of the course, and are being used in the design and implementation of an Intelligent Tutoring System.", "num_citations": "12\n", "authors": ["32"]}
{"title": "Asynchronous exceptions in concurrent object-oriented programming\n", "abstract": " Exceptions in concurrent object-oriented languages with asynchronous call semantics may raise a serious problem in certain situations. Since separate calls are asynchronous it might happen that the context of the enclosing routine, from which the asynchronous call was launched, has been already left and hence any exception raised by the asynchronous call can not be handled anymore by the enclosing routine. In this paper we present a practical solution for this problem, which relies on the notion of busy processors.", "num_citations": "12\n", "authors": ["32"]}
{"title": "Proving pointer program properties. part 2: The overall object structure\n", "abstract": " The run-time object structure of object-oriented programs typically relies on extensive use of references (or pointers). This second part of a general mathematical framework for reasoning about references handles the overall properties of the structure, not distinguishing between individual links but only considering whether any reference exists between two objects. It provides a basis for dealing with memory management and especially garbage collection.", "num_citations": "12\n", "authors": ["32"]}
{"title": "A metric framework for object-oriented development\n", "abstract": " Metrics (quantitative estimates of product and project properties) can, if defined from sound engineering principles, be a precious tool for both project management and software development. We have recently developed an extensive set of metrics facilities for the Eiffel/Studio development environment. We describe the principles on which it is the based, the facilities it provides and how to use them. The metrics workbench is closely integrated with the rest of the environment. Among other capabilities, it allows users to: apply pre-defined metrics to components of a system at various levels (feature, class, cluster or the entire system); define new metrics, through mathematical formulae or Boolean selection, and apply them to projects; store measurement results, as well as metric definitions, into an XML archive that can be stored locally or made available on the Web for future reference; and compare the measurements\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "12\n", "authors": ["32"]}
{"title": "From calls to agents\n", "abstract": " Of the recent Eiffel extensions previewed in the last column (\" Extension Season\", June 1999, see http://www. inf. ethz. ch/personal/meyer/publications/joop/extensions. pdf), some are intended to clean up and simplify existing mechanisms, but a few significantly raise the expressive power of the language. The most spectacular of these is agents, a new mechanism for manipulating operations as objects\u0393\u00c7\u00f6so important on its own that it deserves a presentation of its own.", "num_citations": "12\n", "authors": ["32"]}
{"title": "Smartwalker: Towards an intelligent robotic walker for the elderly\n", "abstract": " This paper presents SmartWalker and evaluates the appropriateness and usefulness of the walker and its gesture-based interface for the elderly. As a high-tech extension of a regular walker, the SmartWalker aims to assist its user intelligently and navigate around its environment autonomously. Equipped with sensors and actuators, the prototype accepts gesture commands and navigates around accordingly. The gesture-based interface uses a k-nearest neighbours classifier with dynamic time warping to recognize gestures and the Viola and Jones face detector to locate the user. We evaluated the walker with 23 residents and eight staff members at five different retirement homes in Zurich. The elderly found the SmartWalker useful and exciting, but few were willing to replace their walkers by robotic walkers. Their reluctance may stem from the walker's size and weight and their unfamiliarity with technology.", "num_citations": "11\n", "authors": ["32"]}
{"title": "Alias calculus, change calculus and frame inference\n", "abstract": " Alias analysis, which determines whether two expressions in a program may reference to the same object, has many potential applications in program construction and verification. We have developed a theory for alias analysis, the \u0393\u00c7\u00a3alias calculus\u0393\u00c7\u00a5, implemented its application to an object-oriented language, and integrated the result into a modern IDE. The calculus has a higher level of precision than many existing alias analysis techniques.One of the principal applications is to allow automatic change analysis, which leads to inferring \u0393\u00c7\u00a3modifies\u0393\u00c7\u00a5 clauses, providing a significant advance towards addressing the Frame Problem. Experiments were able to infer the \u0393\u00c7\u00a3modifies\u0393\u00c7\u00a5 clauses of an existing formally specified library. Other applications, in particular to concurrent programming, also appear possible.The article presents the calculus, the application to frame inference including experimental results, and other projected\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["32"]}
{"title": "An ide-based, integrated solution to schema evolution of object-oriented software\n", "abstract": " With the wide support for serialization in object-oriented programming languages, persistent objects have become common place. Retrieving previously \u252c\u2510persisted\u252c\u2510 objects from classes whose schema changed is however difficult, and may lead to invalidating the consistency of the application. The ESCHER framework addresses this issues through an IDE-based approach that handles schema evolution by managing versions of the code and generating transformation functions automatically. The infrastructure also enforces class invariants to prevent the introduction of any corrupt objects. This article describes the principles behind invariant-safe schema evolution,and the design and implementation of the ESCHER system.", "num_citations": "11\n", "authors": ["32"]}
{"title": "The dependent delegate dilemma\n", "abstract": " A criticism of the object-oriented style of programming is that the notion of class invariant seems to collapse in non-trivial client-supplier relationships: a supplier (\u0393\u00c7\u00a3Dependent Delegate\u0393\u00c7\u00a5) called from within the execution of a routine, where the invariant is not required to hold, may call back into the originating object, which it then catches in an inconsistent state. This is one of the problems arising from the application of assertion-based semantics to a model of computation involving references and the resulting possibility of dynamic aliasing.               This note suggests handling such cases by applying the basic non-objectoriented Hoare rule, instead of the version involving the invariant. It does not consider inheritance and dynamic binding.", "num_citations": "11\n", "authors": ["32"]}
{"title": "The power of abstraction, reuse and simplicity: an object-oriented library for event-driven design\n", "abstract": " A new library for event-driven design, defining a general and extendible scheme, yet easy to learn and use on both the publisher and subscriber sides, provides an opportunity to analyze such other approaches as the\" Observer Pattern\", the event-delegate mechanism of .NET and its\" Web Forms\", then to draw some general software engineering lessons.", "num_citations": "11\n", "authors": ["32"]}
{"title": "Toward More expressive contracts\n", "abstract": " Eiffel's contracts are the result of a design trade-offbetween the full extent of formal specifications and what is acceptable to practicing software developers. The latter criterion has been critical: The ideas had to be practical; any competent programmer can immediately see their benefits, and start using them. In James McKim's words,\" If you can code, you can spec.\" This is the principle behind Eiffel contracts-not a dream for a perfect world, but a practical tool for solving everyday problems. The design has proved its value, and Eiffel programmers enjoy it. But the time may have come to revisit the trade-off and see how much more we could express with contracts-how close we could come to the goal of full specification without losing the simplicity and self-evidence of the classic Eiffel mechanism. Developments such as the Object Constraint Language (OCL) addition to UML show that interest in contracts has grown beyond the Eiffel community, together with a search for ways to express higher-level contracts, including, in particular, properties of first-order predicate calculus. Eiffel has the considerable advantage of including contracts as a part of the programming language, intricately woven into the process of conceiving, developing, documenting, debugging, and maintaining software. This is all the more reason to explore whether we can make contracts more expressive. This article explores recent progress in this direction, resulting from work in several areas:\u0393\u00c7\u00f3 a language development: the new\" agent\" language mechanism presented in an earlier columnl with a new variant (inline agents);\u0393\u00c7\u00f3 new Eiffellibrary work, especially around EiffelBase, an\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["32"]}
{"title": "A really good idea [object-oriented software development]\n", "abstract": " Reflects on the contributions made by object-oriented (OO) development and its future. Don't blame OO programming in general for the limitations of those who don't know how to apply the principles! Only a minority of the industry has tried seriously and without compromise. The experience of others-those who go at it half-heartedly-is not a good technology. So the author's answer to the OO critics is the application to object technology of Gandhi's retort when he was asked for his thoughts about Western civilization: it would be a good idea.", "num_citations": "11\n", "authors": ["32"]}
{"title": "Rules for component builders\n", "abstract": " Rules for component builders | Software Development ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Software Development Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsSoftware DevelopmentVol. , No. Rules for component builders article Rules for component builders Share on Author: Bertrand Meyer profile image Bertrand Meyer View Profile Authors Info & Affiliations Publication: Software DevelopmentMay 1999 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: You will be notified a . .\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["32"]}
{"title": "Teaching object technology\n", "abstract": " Since 1986 I have hardly spent a month without teaching at least one object technology class, to groups large and small. I draw from this experience to suggest a few rules for effective object training in industrial environments. A mOOzak effect is caused by the omnipresence of OO this and OO that in the computer press. The words flow so continuously as to cause a general dilution of the concepts. The words are familiar, but are the concepts understood? Often they are not. The trainer must convince the trainees that they do not yet know everything, because no one can learn a subject he thinks he already knows. The only strategy guaranteed to overcome the mOOzak effect is to present the initial training course; have the students try their hand at OO development; and present the initial training course. Initial training should focus on implementation and design. Do not limit yourself to introductory courses, however\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["32"]}
{"title": "EIFFEL: reusability and reliability\n", "abstract": " EIFFEL: reusability and reliability | Software reuse: emerging technology ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware reuse: emerging technologyEIFFEL: reusability and reliability chapter EIFFEL: reusability and reliability Share on Author: B Meyer profile image B. Meyer View Profile Authors Info & Affiliations Publication: Software reuse: emerging technologyJanuary 1988 Pages 216\u0393\u00c7\u00f4228 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: You will be notified a record . \u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["32"]}
{"title": "A Basis for the Constructive Approach to Programming.\n", "abstract": " The evolution of the various domains of computer science has led to the development of powerful program analysis methods. They make it possible to study many properties of problems and programs; eg, to determine whether a problem can be solved at all, and, if so, whether there exist realistic algorithms; to evaluate the abstract and concrete complexity of a program; and to prove it correct relative to some specification.Useful as these techniques may be, they do not provide a completely satisfactory answer to the practicing programmer, whose immediate concern is to build programs which will solve given problems. Programming is a difficult intellectual activity, and it can hardly be expected that straightforward\" methods\" will ever be discovered, let alone\" algorithms\", to deduce programs from problems. To anyone seriously concerned with programming, however, it is obvious that certain fruitful thought patterns do recur with a remarkable frequency, and it is quite a temptation to try to analyze and formalize them with the hope that their knowledge will be of some help for those who construct programs. Such is the aim of this paper.", "num_citations": "11\n", "authors": ["32"]}
{"title": "AutoReq: Expressing and verifying requirements for control systems\n", "abstract": " The considerable effort of writing requirements is only worthwhile if the result meets two conditions: the requirements reflect stakeholders\u0393\u00c7\u00d6 needs, and the implementation satisfies them. In usual approaches, the use of different notations for requirements (often natural language) and implementations (a programming language) makes both conditions elusive. AutoReq, presented in this article, takes a different approach to both the writing of requirements and their verification. Applying the approach to a well-documented example, a landing gear system, allowed for a mechanical proof of consistency and uncovered an error in a published discussion of the problem.", "num_citations": "10\n", "authors": ["32"]}
{"title": "Towards monitoring firefighting teams with the smartphone\n", "abstract": " Two important aspects for efficient and safe firefighting operations are team communication behavior and physical activity coordination. In close cooperation with a firefighting brigade we investigate the potential of modern smartphones to acquire objective data on team communication and physical activity in an automatic way. We envision that such a monitoring is helpful for improving post incident feedback to enhance the efficiency and safety of firefighting operations. In this contribution we present our findings of a feasibility study in which two firefighting teams had to extinguish a kitchen fire. We present the obtained measures of speech and physical activity levels and show how the difference in performance between the two teams can be explained by the smartphone measures.", "num_citations": "10\n", "authors": ["32"]}
{"title": "Contract-driven development\n", "abstract": " In spite of cultural difference between the corresponding scientific communities, recognition is growing that test-based and specification-based approaches to software development actually complement each other. The revival of interest in testing tools and techniques follows in particular from the popularity of \u0393\u00c7\u00a3Test-Driven Development\u0393\u00c7\u00a5; rigorous specification and proofs have, for their part, also made considerable progress. There remains, however, a fundamental superiority of specifications over test: you can derive tests from a specification, but not the other way around.               Contract-Driven Development is a new approach to systematic software construction combining ideas from Design by Contract, from Test-Driven Development, from work on formal methods, and from advances in automatic testing as illustrated for example in our AutoTest tool. Like TDD it gives tests a central role in the development\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "10\n", "authors": ["32"]}
{"title": "Dependable systems: software, computing, networks: research results of the DICS program\n", "abstract": " Modern civilization relies on a functioning information infrastructure. As a result, dependability has become a central issue in all disciplines of systems engineering and software architecture. Theories, methods and tools that help to master the problems encountered in the design process and the management of operations are therefore of utmost importance for the future of information and communication technology. The present volume documents the results of a research program on Dependable Information and Communication Systems (DICS). The members of the project met in two workshops organized by the Hasler Foundation. This state-of-the-art survey contains 3 overview articles identifying major issues of dependability and presenting the latest solutions, as well as 10 carefully selected and revised papers depicting the research results originating from those workshops. The first workshop took place in M\u251c\u255dnchenwiler, Switzerland, in March 2004, and the second workshop, which marked the conclusion of the projects, in L\u251c\u2562wenberg, Switzerland, in October 2005. The papers are organized in topical sections on surveys, dependable software, dependable computing, and dependable networks.", "num_citations": "10\n", "authors": ["32"]}
{"title": "Defense and illustration of Wikipedia\n", "abstract": " This note, more precisely Part One, was prepared in late December of 2005 as a reaction to a critique of Wikipedia by four well-known computer scientists. Their article highlights, Cassandra-style, all that can go wrong with the Wikipedia concept of an encyclopedia produced by an iterative \u0393\u00c7\u00a3community process\u0393\u00c7\u00a5 allowing anyone to edit any entry. A scary prospect indeed. As my response acknowledges, it\u0393\u00c7\u00d6s hard to find fault with their cogently argued indictment\u0393\u00c7\u00f6except for one detail: in its eagerness to paint a theoretical picture of Wikipedia as a disaster waiting to happen, it skipped checking the real Wikipedia, which would have revealed that the disaster has not happened, A more pragmatic look at Wikipedia as it exists today indicates that the project, while perhaps not living up to the hype of its most fervent promoters, has become a superbly useful tool for Web-based fact-finding. The original critique suffered, in my opinion, from a halfempty-glass perspective, and from a misunderstanding of Wikipedia\u0393\u00c7\u00d6s role in the world. Without in the end disagreeing fundamentally with the authors\u0393\u00c7\u00d6 analysis, I take a half-full-glass view, based on a different understanding of what is Wikipedia\u0393\u00c7\u00d6s competition: not the traditional professionally produced encyclopedias, but the legions of sites that, springing up all over the Web, purport to contain answers, unverified and often unverifiable, to every topic on earth. Against that standard, Wikipedia is a resounding success. That\u0393\u00c7\u00d6s the analysis I produced in December, based on an assessment of what Wikipedia is, not what it could degrade into. You will find it in Part One.", "num_citations": "10\n", "authors": ["32"]}
{"title": "Eiffel as a framework for verification\n", "abstract": " The Eiffel method and language integrate a number of ideas originating from work on program verification. This position paper describes the goals of the Eiffel approach, presents current Eiffel-based verification techniques using contracts for run-time checks for testing and debugging, and outlines ongoing work on static verification.", "num_citations": "10\n", "authors": ["32"]}
{"title": "Empirical study of novice errors and error paths\n", "abstract": " What kind of errors do beginners make? Objective answers to this question are essential to the design and implementation of curricula that do not just reflect the educators\u0393\u00c7\u00d6 theories but succeed in conveying a course\u0393\u00c7\u00d6s topics and skills to the students. In the context of a new introductory programming course based on \u0393\u00c7\u00a3inverted curriculum\u0393\u00c7\u00a5 ideas, and taking advantage of our ability to instrument the compiler, we performed an analysis of the-sometimes contorted-paths students actually take to solve programming exercises on their own. The results, collected from two different groups of students across two unrelated universities, include a number of surprises; they will help improve future sessions of the course, and are being used in the design and implementation of an Intelligent Tutoring System.", "num_citations": "10\n", "authors": ["32"]}
{"title": "Showing programs on a screen\n", "abstract": " We present a strategy and algorithms for displaying a meaningful view of structured objects such as programs on a screen of limited size. The methods introduced here are language-independent; they were developed for the implementation of C\u251c\u2310page, a structural editor making full use of modern display technology. The algorithms are linear with respect to the number of nodes in the syntax tree.We use a formal model of the screen allocation, the \u0393\u00c7\u00ffcalculus of windows\u0393\u00c7\u00d6, which makes it possible to reason about the display process at a proper level of abstraction. A systematic approach was followed, in which a number of \u0393\u00c7\u00ffinvariants\u0393\u00c7\u00d6 and \u0393\u00c7\u00ffattributes\u0393\u00c7\u00d6 were defined before the actual construction of the algorithms and data structures, and served as a basis for their development; the paper describes the methodology used and includes a semi-formal correctness proof of the main algorithm, which involves mutually recursive\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "10\n", "authors": ["32"]}
{"title": "A note on iterative Hanoi\n", "abstract": " We define the level of a node of this binary tree to be 1 if the node is a leaf, 2 if it is the parent of a leaf, etc. Let S n be the sequence of the levels of the nodes encountered during the traversal. It follows directly from the recursive structure of the algorithm that S n has 2n-l-1 elements and sat [sties:", "num_citations": "10\n", "authors": ["32"]}
{"title": "Concurrent software engineering and robotics education\n", "abstract": " This paper presents a new, multidisciplinary robotics programming course, reports initial results, and describes subsequent improvements. With equal emphasis on software engineering and robotics, the course teaches students how software engineering applies to robotics. Students learn independently and interactively and gain hands-on experience by implementing robotics algorithms on a real robot. To understand the effects of the course, we conducted an exit and an 8-month survey and measured software quality of the students' solutions. The analysis shows that the hands-on experience helped everyone learn and retain robotics well, but the students' knowledge gain in software engineering depended on their prior programming knowledge. Based on these findings, we propose improvements to the course. Lastly, we reflect our experience on andragogy, minimalism, and interactive learning.", "num_citations": "9\n", "authors": ["32"]}
{"title": "Safe and efficient data sharing for message-passing concurrency\n", "abstract": " Message passing provides a powerful communication abstraction in both distributed and shared memory environments. It is particularly successful at preventing problems arising from shared state, such as data races, as it avoids sharing in general. Message passing is less effective when concurrent access to large amounts of data is needed, as the overhead of messaging may be prohibitive. In shared memory environments, this issue could be alleviated by supporting direct access to shared data; but then ensuring proper synchronization becomes again the dominant problem. This paper proposes a safe and efficient approach to data sharing in message-passing concurrency models based on the idea of distinguishing active and passive computational units. Passive units do not have execution capabilities but offer to active units exclusive and direct access to the data they encapsulate. The access is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["32"]}
{"title": "A scalable implementation of malware detection based on network connection behaviors\n", "abstract": " When hundreds of thousands of applications need to be analyzed within a short period of time, existing static and dynamic malware detection methods may become less desirable because they could quickly exhaust system and human resources. Additionally, many behavioral malware detection methods may not be practical because they require the collection of applications' system-level and network-level activities, which may not always be available. In this paper, we propose a malware behavioral clustering approach to detect malware variants based on applications' simple network connection data, which can be easily collected from anti-virus (AV) products. This approach is highly scalable and has been used on huge volumes of real-world data. Our experiments demonstrate that, at a false positive rate lower than 0.001%, the proposed method achieved a detection rate of 80%+ in identifying spambots and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["32"]}
{"title": "How to cancel a task\n", "abstract": " Task parallelism is ubiquitous in modern applications for event-based, distributed, or reactive systems. In this type of programming, the ability to cancel a running task arises as a critical feature. Although there are a variety of cancellation techniques, a comprehensive account of their characteristics is missing. This paper provides a classification of task cancellation patterns, as well as a detailed analysis of their advantages and disadvantages. One promising approach is cooperative cancellation, where threads must be continuously prepared for external cancellation requests. Based on this pattern, we propose an extension of SCOOP, an object-oriented concurrency model.", "num_citations": "9\n", "authors": ["32"]}
{"title": "Who is accountable for asynchronous exceptions?\n", "abstract": " Large parts of today's software systems are devoted to detecting and recovering from failures, making exception handling a critical issue in software development. Concurrent software complicates this issue: most concurrent programming languages require a mechanism to deal with asynchronous exceptions, but because of the diverse design choices underlying each language, no approach fits all situations. We introduce a classification of possible approaches to guide the development of asynchronous exception mechanisms, and we show its applicability by deriving a sound and comprehensible mechanism for SCOOP, an object-oriented programming model for concurrency. We describe the key idea of the mechanism using the accountability framework, which precisely defines the obligations of client and supplier regarding the reporting of exceptions. The framework not only provides the necessary intuition to\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["32"]}
{"title": "Automatic verification of Eiffel programs\n", "abstract": " Correctness of software systems can be proven by using static verification techniques. Static verifiers such as Spec# and ESC/Java have been developed for object-oriented languages. These verifiers have shown that static verification can be applied to object-oriented languages such as C# and Java. However, these verifiers are not easy to use, as they introduce many new concepts that programmers have to learn. To apply these verifiers to a real project, one has to modify existing code by adding contracts and annotations such as pure method marks or ownership information. Eiffel supports Design by Contract. Current libraries and programs are therefore already annotated with contracts.The goal of this thesis is to develop an automatic verifier for Eiffel which can prove existing code without the need of further annotations. The main features supported by the tool are agents and dynamic invocation. The tool, called EVE Proofs, translates Eiffel programs to Boogie and runs a fully automatic theorem prover to check correctness of the code. EVE Proofs is integrated in EVE, the Eiffel Verification Environment. This integration enables Eiffel programmers to use it directly from the programming environment. To reason about framing of routines, one needs modifies clauses. To prove existing Eiffel code, we implemented an automatic extraction of modifies clauses. Although the extraction of modifies clauses is limited, it enables us to prove examples with simple frame conditions.", "num_citations": "9\n", "authors": ["32"]}
{"title": "Principles of language design and evolution\n", "abstract": " Heeded or not, Tony Hoare\u0393\u00c7\u00d6s Hints on Programming Language Design [1] remains, more than 25 years after publication, the principal source of wisdom on how to produce sound programming languages. I will try to expand on Hoare\u0393\u00c7\u00d6s principles by presenting some of what my own experience has taught me, through my work not only on Eiffel but also on numerous \u0393\u00c7\u00a3little languages\u0393\u00c7\u00a5 as well formal specification languages such as Jean-Raymond Abrial\u0393\u00c7\u00d6s Z [2], and through a lifetime passion for critical observation of languages of all kinds, from JCL, Fortran, troff, csh and awk to Miranda, Java, Perl, and XML.The topic is not just language design but the often neglected case of language evolution. In the same way that a software engineering curriculum misses its target if it confines itself to initial program construction and fails to address the successive mutations that in the end account for most of the work on a real program, a discussion of language design must encompass the successive revisions that mark the life of a language\u0393\u00c7\u00f6especially a successful language\u0393\u00c7\u00f6and constantly threaten to annul whatever qualities its original version may have had.", "num_citations": "9\n", "authors": ["32"]}
{"title": "Schema evolution: Concepts, terminology, and solutions\n", "abstract": " Most applications must keep objects from one session to the next. This is known as persistence. But objects are not raw data: They are instances of classes. What happens if an object's class (its generator) changes from one session to the next? This problem is known as schema evolution (the term schema is borrowed from relational databases). This column defines a framework for addressing schema evolution in object technology.", "num_citations": "9\n", "authors": ["32"]}
{"title": "Genericity versus inheritance.\n", "abstract": " Genericity, as in Ada or ML, and inheritance, as in object-oriented languages, are two alternative techniques for ensuring better extendibility, reusability, and compatibility of software components. This article is a comparative analysis of these two methods. It studies their similarities and differences and assesses to what extent each may be simulated in a language offering only the other. It shows what features are needed to successfully combine the two approaches in an object-oriented language that also features strong type checking. The discussion introduces the principal aspects of the language EiffePM whose design, resulting in part from this study, includes multiple inheritance and a limited form of genericity under full static typing.", "num_citations": "9\n", "authors": ["32"]}
{"title": "Automatic speed control for SmartWalker\n", "abstract": " Ensuring mobility of the elderly is an important task in our aging society. To this end, this paper presents an automatic speed controller for the SmartWalker--a high-tech extension of a regular walker. The walker locates its user by detecting the user's legs using a laser range scanner. The controller then determines the optimal speed for the walker using the user's location and other sensory data. We evaluated the walker and its speed controller with thirteen residents at three different retirement homes. Our analysis showed that the walker with the controller is slightly more comfortable and easier to maneuver than the walker without the controller and is more liked than traditional walkers.", "num_citations": "8\n", "authors": ["32"]}
{"title": "Handling parallelism in a concurrency model\n", "abstract": " Programming models for concurrency are optimized for dealing with nondeterminism, for example to handle asynchronously arriving events. To shield the developer from data race errors effectively, such models may prevent shared access to data altogether. However, this restriction also makes them unsuitable for applications that require data parallelism. We present a library-based approach for permitting parallel access to arrays while preserving the safety guarantees of the original model. When applied to SCOOP, an object-oriented concurrency model, the approach exhibits a negligible performance overhead compared to ordinary threaded implementations of two parallel benchmark programs.", "num_citations": "8\n", "authors": ["32"]}
{"title": "Demonic testing of concurrent programs\n", "abstract": " Testing presents a daunting challenge for concurrent programs, as non-deterministic scheduling defeats reproducibility. The problem is even harder if, rather than testing entire systems, one tries to test individual components, for example to assess them for thread-safety. We present demonic testing, a technique combining the tangible results of unit testing with the rigour of formal rely-guarantee reasoning to provide deterministic unit testing for concurrent programs. Deterministic execution is provided by abstracting threads away via rely-guarantee reasoning, and replacing them with \u0393\u00c7\u00a3demonic\u0393\u00c7\u00a5 sequences of interfering instructions that drive the program to break invariants. Demonic testing reuses existing unit tests to drive the routine under test, using the execution to discover demonic interference. Programs carry contract-based rely-guarantee style specifications to express what sort of thread interference\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["32"]}
{"title": "Towards a Calculus of Object Programs\n", "abstract": " Verifying properties of object-oriented software requires a method for handling references in a simple and intuitive way, closely related to how O-O programmers reason about their programs. The method presented here, a Calculus of Object Programs, combines four components: compositional logic, a framework for describing program semantics and proving program properties; negative variables to address the specifics of O-O programming, in particular qualified calls; the alias calculus, which determines whether reference expressions can ever have the same value; and the calculus of object structures, a specification technique for the structures that arise during the execution of an object-oriented program.           The article illustrates the Calculus by proving the standard algorithm for reversing a linked list.", "num_citations": "8\n", "authors": ["32"]}
{"title": "Verifying executable object-oriented specifications with separation logic\n", "abstract": " Specifications of Object-Oriented programs conventionally employ Boolean expressions of the programming language for assertions. Programming errors can be discovered by checking at runtime whether an assertion, such as a precondition or class invariant, holds. In this work, we show how separation logic can be used to verify that these executable specifications will always hold at runtime. Both the program and its executable assertions are verified with respect to separation logic specifications. A novel notion called relative purity embraces historically problematic side-effects in executable specifications, and verification boils down to proving connecting implications. Even model-based specifications can be verified. The framework is also well-suited to separation logic proof tools and now implemented in jStar. Numerous automatically verified examples illustrate the framework\u0393\u00c7\u00d6s use and utility.", "num_citations": "8\n", "authors": ["32"]}
{"title": "The start of an Eiffel standard\n", "abstract": " The launching of the JOT provides a welcome opportunity to resume the Eiffel column that ran for many years in JOOP from 1998 (edited first by Rock Howard from whom I took over in 1998). It will run pretty much like its predecessor, with a mix of contributions by guest columnists and by me, and a mix of topics\u0393\u00c7\u00f6from language matters to methodological issues of object-oriented software construction to reports on industry projects\u0393\u00c7\u00f6that I hope will be of interest not only to Eiffel users but also to many others.", "num_citations": "8\n", "authors": ["32"]}
{"title": "35th Annual Meeting of the European Association for the Study of Diabetes\n", "abstract": " A 155 A 157 A 160 A 162 A 164 A 167 A 169 A 171 A 173 A 175 A 178 A 180 A 182 A 185 A 187 A 189 A 192 A 194 A 196 A 198", "num_citations": "8\n", "authors": ["32"]}
{"title": "What is an object-oriented environment?\n", "abstract": " MOST EVERY SOFTWARE development environment these days claims to be object oriented. But what does the phrase really mean? In some cases it seems that the authors of any tool that has so much as a menu or perhaps a few icons feel they deserve to call it 0-0. In other cases the justification is simply that the environment supports an object-oriented language, or perhaps an object-oriented analysis method. About two years ago, as our group at ISE was starting the development of EiffelBench (the development environment for ISE Eiffel 3), we decided to explore how we could apply the concepts of object orientation to the environment itself-not just to the software developed with it. Impressed as we were by generally accepted ideas, which usually come directly or indirectly from the brilliant example of Smalltalk, we felt that current efforts stopped short of providing the true benefits of object orientation at the environment level.In this guest column I will share some of the insights that we gained from that effort, describe five key principles of objectoriented environments and explain why, in our opinion, such an environment should have no browser, no debugger, and, in a sense, not even a compiler or an interpreter-while providing all the needed browsing, debugging, compiling, and interpreting facilities, and more.(If you think this is a contradiction, just read on.)", "num_citations": "8\n", "authors": ["32"]}
{"title": "Design and implementation of an object-oriented, interactive animation system\n", "abstract": " Design and implementation of an object-oriented, interactive animation system \u0393\u00c7\u00f6 Eindhoven University of Technology research portal Skip to main navigation Skip to search Skip to main content Eindhoven University of Technology research portal Logo Help & FAQ English Nederlands Home Researchers Research output Organisational units Activities Projects Prizes Press / Media Facilities / Equipment Datasets Courses Research areas Student theses Search by expertise, name or affiliation Design and implementation of an object-oriented, interactive animation system EAJ Peeters Research output: Chapter in Book/Report/Conference proceeding \u0393\u00c7\u2551 Conference contribution \u0393\u00c7\u2551 Academic \u0393\u00c7\u2551 peer-review Overview Original language English Title of host publication Proceedings 12th International Conference on Technology of Object-Oriented Languages and Systems (TOOLS-12, November 1993) Editors C. Mingins, W. , J\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["32"]}
{"title": "Ending null pointer crashes\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmVoid safety, says Bertrand Meyer, relies on type declarations and static analysis.", "num_citations": "7\n", "authors": ["32"]}
{"title": "Simple concurrency for robotics with the Roboscoop framework\n", "abstract": " Concurrency is inherent to robots, and using concurrency in robotics can greatly enhance performance of the robotics applications. So far, however, the use of concurrency in robotics has been limited and cumbersome. This paper presents Roboscoop, a new robotics framework based on Simple Concurrent Object Oriented Programming (SCOOP). SCOOP excludes data races by construction, thereby eliminating a major class of concurrent programming errors. Roboscoop utilizes SCOOP's concurrency and synchronization mechanisms for coordination in robotics applications. We demonstrate Roboscoop's simplicity by comparing Roboscoop to existing middlewares and evaluate Roboscoop's usability by employing it in education.", "num_citations": "7\n", "authors": ["32"]}
{"title": "Negative variables and the essence of object-oriented programming\n", "abstract": " Reasoning about object-oriented programs requires an appropriate technique to reflect a fundamental \u0393\u00c7\u00a3general relativity\u0393\u00c7\u00a5 property of the approach: every operation is relative to a current object, which changes with every qualified call; such a call needs access to the context of the client object. The notion of negative variable, discussed in this article, provides a framework for reasoning about OO programs in any semantic framework. We introduce a fundamental rule describing the semantics of object-oriented calls, its specific versions for such frameworks as axiomatic (Hoare-style) logic and denotational semantics, and its application to such problems as alias analysis and the consistency of concurrent programs. The approach has been implemented as part of a verification environment for a major object-oriented language and used to perform a number of proofs and analyses.", "num_citations": "7\n", "authors": ["32"]}
{"title": "Empirical assessment of languages for teaching concurrency: Methodology and application\n", "abstract": " Concurrency has been rapidly gaining importance in computing, and correspondingly in computing curricula. Concurrent programming is, however, notoriously hard even for expert programmers. New language designs promise to make it easier, but such claims call for empirical validation. We present a methodology for comparing concurrent languages for teaching purposes. A critical challenge is to avoid bias, especially when (as in our example application) the experimenters are also the designers of one of the approaches under comparison. For a study performed as part of a course, it is also essential to make sure that no student is penalized. The methodology addresses these concerns by using self-study material and applying an evaluation scheme that minimizes opportunities for subjective decisions. The example application compares two object-oriented concurrent languages: multithreaded Java and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["32"]}
{"title": "A comparative study of the usability of two object-oriented concurrent programming languages\n", "abstract": " Concurrency has been rapidly gaining importance in general-purpose computing, caused by the recent turn towards multicore processing architectures. As a result, an increasing number of developers have to learn to write concurrent programs, a task that is known to be hard even for the expert. Language designers are therefore working on languages that promise to make concurrent programming \"easier\" than using traditional thread libraries. However, the claim that a new language is more usable than another cannot be supported by purely theoretical considerations, but calls for empirical studies. In this paper, we present the design of a study to compare concurrent programming languages with respect to comprehending and debugging existing programs and writing correct new programs. A critical challenge for such a study is avoiding the bias that might be introduced during the training phase and when interpreting participants' solutions. We address these issues by the use of self-study material and an evaluation scheme that exposes any subjective decisions of the corrector, or eliminates them altogether. We apply our design to a comparison of two object-oriented languages for concurrency, multithreaded Java and SCOOP (Simple Concurrent Object-Oriented Programming), in an academic setting. We obtain results in favor of SCOOP even though the study participants had previous training in Java Threads.", "num_citations": "7\n", "authors": ["32"]}
{"title": "A formal reference for SCOOP\n", "abstract": " Operational semantics is a flexible but rigorous means to describe the meaning of programming languages. Small semantics are often preferred, for example to facilitate model checking. However, omitting too many details in a semantics limits results to a core language only, leaving a wide gap towards real implementations. In this paper we present a comprehensive semantics of the concurrent programming model SCOOP (Simple Concurrent Object-Oriented Programming). The semantics has been found detailed enough to guide an implementation of the SCOOP compiler and runtime system, and to detect and correct a variety of errors and ambiguities in the original informal specification and prototype implementation. In our formal specification, we use abstract data types with preconditions and axioms to describe the state, and introduce a number of special operations to model the runtime system with our\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["32"]}
{"title": "Software Engineering Approaches for Offshore and Outsourced Development: First International Conference, SEAFOOD 2007, Zurich, Switzerland, February 5-6, 2007, Revised Papers\n", "abstract": " SEAFOOD for Thought Headline-grabbing though it may be, the software industry\u0393\u00c7\u00d6s large-scale allo-tion of work to developing countries has not so far generated much technical analysis. Attention is usually limited to the possible political and economic c-sequences, in particular the fears of loss of employment in the West. The aim of the present volume is di? erent. We recognize that o? shore development is here to stay, and not just a result of cost considerations. It is\u0393\u00c7\u00f4more accurately\u0393\u00c7\u00f4a form of distributed development, relying on advances in communications to let the software industry, in our globalizedworld, bene? t from the wide distribution of human talent. But it is also the source of a new set of challenges, to which accepted software engineering principles and techniques have not completely prepared us. Producing high-quality software on time and within budget is hard enough when the QA team is across the aisle from the core developers, and the customers across the street; what then when the bulk of the development team is across an ocean or two? The? rst SEAFOOD\u0393\u00c7\u00f4Software Engineering Advances For Outsourced and 1 O? shore Development\u0393\u00c7\u00f4conference (prompted by an earlier article) was an-tempt not only to bring software engineering to outsourcing but also to bring outsourcing into the collective consciousness of the software engineering c-munity. This is bene? cial to both sides: successful outsourcing requires strong softwareengineering guidance, but researchin the? eld must for its part account forthenewworldofsoftwaredevelopment.", "num_citations": "7\n", "authors": ["32"]}
{"title": "Corkite from Aggeneys, Bushmanland, South Africa\n", "abstract": " Corkite associated with plumbojarosite and goethite occurs in gossan and iron-formation at Black Mountain and Broken Hill, Aggeneys. Electron microprobe analyses indicate that there are two groups of corkite present in the area; one with high Cu and low (PO4)3\u0393\u00ea\u00c6 and the other with low Cu and high (PO and the other with low Cu and high (PO4)3\u0393\u00ea\u00c6 contents. This can be explained in terms of the general formula contents. This can be explained in terms of the general formula AB                      2(XO                      4)2(OH)6, where the incorporation of divalent ions in the B site is accompanied by the exchange of trivalent anions by divalent ones to retain charge balance. Complete solid-solution is inferred between (SO4)2\u0393\u00ea\u00c6and (PO4)3\u0393\u00ea\u00c6 end members, indicating that the jarosite and beudantite groups form part of the same solid-solution series. The distribution of Zn in corkite also reflects the regional\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["32"]}
{"title": "Seamless integration of multirequirements in complex systems\n", "abstract": " Requirements are the keystone of complex systems development. In order to reduce inconsistencies, requirements analysis is an important issue of systems engineering. In this context, there is a need for conciliating views of several stakeholders from different domains and for tracing these requirements from specification to realization. The computerization of analysis, with the help of a clearly defined semantics linked to a non-specialist readable language, should lead to overcome this major issue. Several works already go into this direction. The most popular ones are dealing with natural language, easily understandable but with few semantics. Other approaches propose more formal notations, with stronger semantics but then being less affordable by stakeholders. In this paper, we propose a preliminary work that should drive us to define a language dedicated to requirements which combine the best of both\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["32"]}
{"title": "An interference-free programming model for network objects\n", "abstract": " Network objects are a simple and natural abstraction for distributed object-oriented programming. Languages that support network objects, however, often leave synchronization to the user, along with its associated pitfalls, such as data races and the possibility of failure. In this paper, we present D-Scoop, a distributed programming model that allows for interference-free and transaction-like reasoning on (potentially multiple) network objects, with synchronization handled automatically, and network failures managed by a compensation mechanism. We achieve this by leveraging the runtime semantics of a multi-threaded object-oriented concurrency model, directly generalizing it with a message-based protocol for efficiently coordinating remote objects. We present our pathway to fusing these contrasting but complementary ideas, and evaluate the performance overhead of the automatic synchronization in D\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["32"]}
{"title": "Framing the Frame Problem.\n", "abstract": " Some parts of the software verification process require human annotation, but as much as possible of the rest should be automatic. An excellent candidate for full automation is change analysis, also known as the frame problem: how to determine which program properties remain unchanged under a given operation. The problem is particularly delicate in the case of programs using pointers or references, in particular object-oriented programs. The double frame inference strategy automates both frame specification and frame verification. On the specification side, it deduces the set of permissible changes of a routine (its \u0393\u00c7\u00a3modifies clause\u0393\u00c7\u00a5) from a simple examination of its postcondition. On the implementation side, it applies the change calculus, itself based on the alias calculus, to determine the set of expressions whose values the routine can actually change. Frame verification then consists of ascertaining that the actual change set is a subset of the permissible change set.", "num_citations": "6\n", "authors": ["32"]}
{"title": "Really automatic scalable object-oriented reengineering\n", "abstract": " Even when implemented in a purely procedural programming language, properly designed programs possess elements of good design that are expressible through object-oriented constructs and concepts. For example, placing structured types and the procedures operating on them together in the same module achieves a weak form of encapsulation that reduces inter-module coupling. This paper presents a novel technique, and a supporting tool AutoOO, that extracts such implicit design elements from C applications and uses them to build reengineered object-oriented programs. The technique is completely automatic: users only provide a source C program, and the tool produces an object-oriented application written in Eiffel with the same input/output behavior as the source. An extensive evaluation on 10 open-source programs (including the editor vim and the math library libgsl) demonstrates that our\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["32"]}
{"title": "Informatics Education in Europe: Institutions, Degrees, Students, Positions, Salaries\u0393\u00c7\u00f6Key Data 2008-2012\n", "abstract": " From the beginnings of Informatics Europe (the association of university departments and industrial research labs in computer science in Europe) it was clear that one of the principal tasks would be to collect the facts. The report is one of the first results of this effort. The principal author is Cristina Pereira, who collected and organized the relevant data over more than a year; I helped with the preparation of the final text. Gathering the information is particularly difficult for Europe given the national variations and the absence of centralized statistical data. Even the list of names under which institutions teach informatics in Europe fills a large table in the report. Cristina's decision was, from the start, to favor quality over quantity: to focus on impeccable data for countries for which we could get it, rather than trying to cover the whole continent with data of variable credibility. The result is the first systematic repository of basic information on informatics education in Europe: institutions, degrees offered and numbers awarded, student numbers, position titles and definitions, and salaries for PhD students, postdocs and professors of various ranks.", "num_citations": "6\n", "authors": ["32"]}
{"title": "Incremental research vs. paradigm-shift mania\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmBertrand Meyer asks why too many research agencies seem obsessed with funding only groundbreaking projects.", "num_citations": "6\n", "authors": ["32"]}
{"title": "Deriving concurrent control software from behavioral specifications\n", "abstract": " Concurrency is an integral part of many robotics applications, due to the need for handling inherently parallel tasks such as motion control and sensor monitoring. Writing programs for this complex domain can be hard, in particular because of the difficulties of retaining a robust modular design. We propose to use SCOOP, an object-oriented programming model for concurrency which by construction is free of data races, therefore excluding a major class of concurrent programming errors. Synchronization requirements are expressed by waiting on routine preconditions, which turns out to provide a natural framework for implementing coordination requirements in robotics applications. As demonstration application, we describe a control program for hexapod locomotion, whose implementation closely follows the corresponding behavioral specification given by the biological model. We compare the architecture with\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["32"]}
{"title": "\u2568\u20a7\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2564\u00ef \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5\n", "abstract": " \u2568\u00f1\u2564\u00e2\u2568\u255c\u2568\u2524\u2568\u2591\u2568\u255d\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2591\u2568\u2557\u2564\u00ee\u2568\u255c\u2564\u00ef\u2568\u2563 \u2564\u00e2\u2564\u00e7\u2568\u2561\u2568\u2592\u2568\u255c\u2568\u2555\u2568\u2551 \u2568\u2510\u2568\u255b \u2568\u255b\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255d \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5 \u2568\u2555 \u2568\u2555\u2568\u255c\u2568\u2562\u2568\u2561\u2568\u255c\u2568\u2561\u2564\u00c7\u2568\u2555\u2568\u2555 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d. \u2568\u00c6 \u2568\u2551\u2568\u255c\u2568\u2555\u2568\u2502\u2568\u2561 \u2568\u2510\u2568\u255b\u2568\u2524\u2564\u00c7\u2568\u255b\u2568\u2592\u2568\u255c\u2568\u255b \u2568\u2555\u2568\u2556\u2568\u2557\u2568\u2591\u2568\u2502\u2568\u2591\u2564\u00c4\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2568\u255b\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2568\u255c\u2564\u00ef\u2568\u2561 \u2568\u2510\u2568\u255b\u2568\u255c\u2564\u00c5\u2564\u00e9\u2568\u2555\u2564\u00c5 \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b\u2568\u2563 \u2564\u00e9\u2568\u2561\u2564\u00e0\u2568\u255c\u2568\u255b\u2568\u2557\u2568\u255b\u2568\u2502\u2568\u2555\u2568\u2555\u0393\u00c7\u00f4\u2568\u2551\u2568\u2557\u2568\u2591\u2564\u00fc\u2564\u00fc\u2564\u00ef, \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2564\u00ef, \u2564\u00e2\u2568\u2510\u2564\u00c7\u2568\u2591\u2568\u2593\u2568\u2557\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2510\u2568\u2591\u2568\u255d\u2564\u00c5\u2564\u00e9\u2564\u00ee\u2564\u00c4, \u2564\u00e9\u2568\u2555\u2568\u2510\u2568\u2555\u2568\u2556\u2568\u2591\u2564\u00e5\u2568\u2555\u2564\u00c5, \u2568\u255c\u2568\u2591\u2564\u00fc\u2568\u2557\u2568\u2561\u2568\u2524\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561, \u2564\u00e2\u2568\u255c\u2568\u2555\u2568\u2593\u2568\u2561\u2564\u00c7\u2564\u00fc\u2568\u2591\u2568\u2557\u2568\u2555\u2568\u2556\u2568\u2591\u2564\u00e5\u2568\u2555\u2564\u00c5. \u2568\u00e6\u2568\u255b\u2568\u2557\u2564\u00ee\u2564\u00ea\u2568\u255b\u2568\u2561 \u2568\u2593\u2568\u255c\u2568\u2555\u2568\u255d\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561 \u2564\u00e2\u2568\u2524\u2568\u2561\u2568\u2557\u2564\u00c5\u2568\u2561\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c4 \u2568\u2510\u2568\u255b \u2568\u2551\u2568\u255b\u2568\u255c\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u2551\u2564\u00e9\u2564\u00e2 \u2568\u2555 \u2568\u255b\u2568\u2592\u2564\u00c7\u2568\u2591\u2568\u2592\u2568\u255b\u2564\u00e9\u2568\u2551\u2568\u2561 \u2568\u2555\u2564\u00fc\u2568\u2551\u2568\u2557\u2564\u00c4\u2564\u00e7\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2563, \u2568\u2551\u2568\u2591\u2568\u2551 \u2568\u255d\u2568\u2561\u2564\u00e0\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2556\u2568\u255d\u2568\u2591\u2568\u255d, \u2568\u255b\u2568\u2592\u2568\u2561\u2564\u00fc\u2568\u2510\u2568\u2561\u2564\u00e7\u2568\u2555\u2568\u2593\u2568\u2591\u2564\u00c4\u2564\u00eb\u2568\u2555\u2568\u255d \u2568\u2551\u2568\u255b\u2564\u00c7\u2564\u00c7\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b\u2564\u00fc\u2564\u00e9\u2564\u00ee \u2568\u2555 \u2564\u00e2\u2564\u00fc\u2564\u00e9\u2568\u255b\u2568\u2563\u2564\u00e7\u2568\u2555\u2568\u2593\u2568\u255b\u2564\u00fc\u2564\u00e9\u2564\u00ee \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u255c\u2564\u00ef\u2564\u00e0 \u2564\u00fc\u2568\u2555\u2564\u00fc\u2564\u00e9\u2568\u2561\u2568\u255d. \u2568\u00c6 \u2568\u2551\u2568\u255c\u2568\u2555\u2568\u2502\u2568\u2561 \u2568\u00e6\u2568\u2561\u2564\u00c7\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u255c\u2568\u2591 \u2568\u00a3\u2568\u2561\u2568\u2563\u2568\u2561\u2564\u00c7\u2568\u2591 \u2564\u00c7\u2568\u2591\u2564\u00fc\u2564\u00fc\u2568\u255d\u2568\u2591\u2564\u00e9\u2564\u00c7\u2568\u2555\u2568\u2593\u2568\u2591\u2564\u00c4\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2568\u255b\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2564\u00ef \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5. \u2568\u00ff\u2568\u2556\u2568\u2557\u2568\u255b\u2568\u2562\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u255c\u2568\u2591\u2564\u00e7\u2568\u2555\u2568\u255c\u2568\u2591\u2568\u2561\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2564\u00fc \u2564\u00c7\u2568\u2591\u2564\u00fc\u2564\u00fc\u2568\u255d\u2568\u255b\u2564\u00e9\u2564\u00c7\u2568\u2561\u2568\u255c\u2568\u2555\u2564\u00c5 \u2568\u2551\u2564\u00c7\u2568\u2555\u2564\u00e9\u2568\u2561\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u2593 \u2568\u2551\u2568\u2591\u2564\u00e7\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u2593\u2568\u2591 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u255c\u2564\u00ef\u2564\u00e0 \u2564\u00fc\u2568\u2555\u2564\u00fc\u2564\u00e9\u2568\u2561\u2568\u255d \u2568\u2555 \u2568\u255b\u2568\u2592\u2568\u255b\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5 \u2564\u00e9\u2568\u255b\u2568\u2502\u2568\u255b, \u2568\u2551\u2568\u2591\u2568\u2551 \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u2591\u2564\u00c5 \u2564\u00e9\u2568\u2561\u2564\u00e0\u2568\u255c\u2568\u255b\u2568\u2557\u2568\u255b\u2568\u2502\u2568\u2555\u2564\u00c5 \u2564\u00c7\u2568\u2591\u2568\u2556\u2564\u00c7\u2568\u2591\u2568\u2592\u2568\u255b\u2564\u00e9\u2568\u2551\u2568\u2555 \u2568\u255d\u2568\u255b\u2568\u2562\u2568\u2561\u2564\u00e9 \u2568\u255b\u2568\u2592\u2568\u2561\u2564\u00fc\u2568\u2510\u2568\u2561\u2564\u00e7\u2568\u2555\u2564\u00e9\u2564\u00ee \u2564\u00e9\u2564\u00c7\u2568\u2561\u2568\u2592\u2564\u00e2\u2568\u2561\u2568\u255d\u2568\u255b\u2568\u2561 \u2568\u2551\u2568\u2591\u2564\u00e7\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u2593\u2568\u255b. \u2568\u20a7\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2568\u255c\u2564\u00ef\u2568\u2561 \u2568\u2510\u2568\u255b\u2568\u255c\u2564\u00c5\u2564\u00e9\u2568\u2555\u2564\u00c5 \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b\u2568\u2563 \u2564\u00e9\u2568\u2561\u2564\u00e0\u2568\u255c\u2568\u255b\u2568\u2557\u2568\u255b\u2568\u2502\u2568\u2555\u2568\u2555 \u2568\u2555 \u2564\u00fc\u2568\u255b\u2568\u255b\u2564\u00e9\u2568\u2593\u2568\u2561\u2564\u00e9\u2564\u00fc\u2564\u00e9\u2568\u2593\u2564\u00e2\u2564\u00c4\u2564\u00eb\u2568\u2591\u2564\u00c5 \u2568\u255c\u2568\u255b\u2564\u00e9\u2568\u2591\u2564\u00e5\u2568\u2555\u2564\u00c5 \u2568\u2510\u2568\u255b\u2564\u00c5\u2568\u2593\u2568\u2557\u2564\u00c5\u2564\u00c4\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2568\u2551\u2568\u2591\u2568\u2551 \u2564\u00c7\u2568\u2561\u2568\u2556\u2564\u00e2\u2568\u2557\u2564\u00ee\u2564\u00e9\u2568\u2591\u2564\u00e9 \u2564\u00e9\u2564\u00eb\u2568\u2591\u2564\u00e9\u2568\u2561\u2568\u2557\u2564\u00ee\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2591\u2568\u255c\u2568\u2591\u2568\u2557\u2568\u2555\u2568\u2556\u2568\u2591 \u2568\u2555 \u2568\u255b\u2568\u2592\u2564\u00fc\u2564\u00e2\u2568\u2562\u2568\u2524\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2563. \u2568\u0192\u2568\u255b\u2568\u2524\u2564\u00c7\u2568\u255b\u2568\u2592\u2568\u255c\u2568\u255b\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["32"]}
{"title": "IDE-integrated Support for Schema Evolution in Object-Oriented Applications.\n", "abstract": " When an application retrieves serialized objects of a class that changed, it may have to cope with modifications of the semantics. While there are numerous ways to handle the resulting mismatch at runtime, developers are typically required to provide some code to reestablish the intended semantics of the new class. We show here how to instruct an IDE with class version information, in a way that it can provide help and guidance for a semantically correct schema evolution.", "num_citations": "6\n", "authors": ["32"]}
{"title": "At the edge of design by contract\n", "abstract": " At the Edge of Design by Contract | Proceedings of the Technology of Object-Oriented Languages and Systems ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsTOOLS '01At the Edge of Design by Contract ARTICLE At the Edge of Design by Contract Share on Author: B Meyer profile image B. Meyer View Profile Authors Info & Affiliations Publication: TOOLS '01: Proceedings of the Technology of Object-Oriented Languages and SystemsMarch 2001 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully to\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["32"]}
{"title": "Effel for E-Commerce under. NET\n", "abstract": " At its July 2000 Professional Developers Conference (PDC), Microsoft introduced a new development framework, .NET, providing a whole set of mechanisms to program Web and Web-aware applications. Presented by Microsoft officials as the company's most important innovation since the introduction of Windows at the firstPDC in 1991, .NET makes an unprecedented effort at supporting many different languages through a Common Language Runtime. Heeding the lesson from Sun's failed attempt to impose a one-Ianguage-fits-all Java corset (as stated, eg, by", "num_citations": "6\n", "authors": ["32"]}
{"title": "Contract-based general-purpose GPU programming\n", "abstract": " Using GPUs as general-purpose processors has revolutionized parallel computing by offering, for a large and growing set of algorithms, massive data-parallelization on desktop machines. An obstacle to widespread adoption, however, is the difficulty of programming them and the low-level control of the hardware required to achieve good performance. This paper suggests a programming library, SafeGPU, that aims at striking a balance between programmer productivity and performance, by making GPU data-parallel operations accessible from within a classical object-oriented programming language. The solution is integrated with the design-by-contract approach, which increases confidence in functional program correctness by embedding executable program specifications into the program text. We show that our library leads to modular and maintainable code that is accessible to GPGPU non-experts, while\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["32"]}
{"title": "Concurrency patterns for easier robotic coordination\n", "abstract": " Software design patterns are reusable solutions to commonly occurring problems in software development. Growing complexity of robotics software increases the importance of applying proper software engineering principles and methods such as design patterns to robotics. Concurrency design patterns are particularly interesting to robotics because robots often have many components that can operate in parallel. However, there has not yet been any established set of reusable concurrency design patterns for robotics. For this purpose, we choose six known concurrency patterns - Future, Periodic timer, Invoke later, Active object, Cooperative cancellation, and Guarded suspension. We demonstrate how these patterns could be used for solving common robotic coordination tasks. We also discuss advantages and disadvantages of the patterns and how existing robotics programming frameworks can support them.", "num_citations": "5\n", "authors": ["32"]}
{"title": "Tools for Practical Software Verification: International Summer School, LASER 2011, Elba Island, Italy, Revised Tutorial Lectures\n", "abstract": " The LASER summer school, organized by the Chair of Software Engineering at ETH Zurich, brings together concepts and practices of software engineering. Since its inception in 2004, each year the LASER summer school has focused on an important software engineering topic. This volume contains selected lecture notes from the 8th LASER Summer School on Software Engineering: Tools for Practical Software Verification held during September 4\u0393\u00c7\u00f410, 2011 in Elba Island, Italy.", "num_citations": "5\n", "authors": ["32"]}
{"title": "Automatic version control system for distributed software development\n", "abstract": " A successful software engineering company nowadays is often spread over multiple locations or has an offshore software production. The teams have to work across borders as well as the differences of cultures and face the challenges of distributed software development. In this situation communication and collaboration are of utmost importance [23, 11]. The design of a well defined API, for example using contracts as discussed in the paper by Nordio et. al.[26], becomes essential. The effect of distribution on software development have been researched from different angles [15, 14, 23]. Espinosa et al.[14] looked at the impact of time zones on the performance during software development. During the DOSE [25, 24] university course, Nordio et al.[23] studied the effect of time and cultural differences on the communication within the teams. Possible tactical approaches to face global software development are discussed by Carmel et al.[12].", "num_citations": "5\n", "authors": ["32"]}
{"title": "Soundness and completeness of a program logic for Eiffel\n", "abstract": " Object-oriented languages provide advantages such as reuse and modularity, but they also raise new challenges for program verification. Program logics have been developed for languages such as C# and Java. However, these logics do not cover the specifics of the Eiffel language. This paper presents a program logic for Eiffel that handles exceptions, once routines, and multiple inheritance. The logic is proven sound and complete wrt an operational semantics. Lessons on language design learned from the experience are discussed.", "num_citations": "5\n", "authors": ["32"]}
{"title": "Course management with TrucStudio\n", "abstract": " Ever growing expectations from students, university management and other stakeholders make course preparation increasingly time-consuming. Setting up a course from scratch requires producing many supporting documents such as syllabi, schedules, and course web sites listing the concepts being taught. This can be a considerable effort, taking time away from tasks with a more immediate pedagogical value, such as answering student questions and refining the concepts themselves. The TrucStudio course development framework supports a systematic approach to these necessary but arduous tasks. TrucStudio is organized like a modern programming environment, but its elements of discourse, rather than software modules, are units of knowledge such as notions, Trucs and clusters. In addition to course development, applications of TrucStudio include checking sound coverage of topics and comparing\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["32"]}
{"title": "Automatic extraction of notions from course material\n", "abstract": " Formally defining the knowledge units taught in a course helps instructors ensure a sound coverage of topics and provides an objective basis for comparing the content of two courses. The main issue is to list and define the course concepts, down to basic knowledge units. Ontology learning techniques can help partially automate the process by extracting information from existing materials such as slides and textbooks. The TrucStudio course planning tool, discussed in this article, provides such support and relies on Text2Onto to extract concepts from course material. We conducted experiments on two different programming courses to assess the quality of the results.", "num_citations": "5\n", "authors": ["32"]}
{"title": "Physics education in the field of mechanics with virtual reality\n", "abstract": " PhysicsPlayground is an educational virtual reality application that should help students in understanding the concepts of mechanics in the field of physics. By the help of virtual reality the student is immersed into a computer generated world in which everything behaves similar to real world physics. Within this virtual environment, the student has access to several tools. Amongst others he can create, modify and simulate physical bodies. Moreover the student has additional possibilities to interaction an analysis all entities within the virtual world. This again provides the student with an appealing educational environment.", "num_citations": "5\n", "authors": ["32"]}
{"title": "Extracting implicit contracts from .NET components\n", "abstract": " Extracting implicit contracts from .NET components Page 1 \u252c\u2310Karine Arnout - 2002 1 Extracting implicit contracts from .NET components Karine Arnout Chair of Software Engineering\u0393\u00c7\u00f4Bertrand Meyer ETH Zurich, Switzerland Karine.Arnout@inf.ethz.ch Page 2 \u252c\u2310Karine Arnout - 2002 2 Presentation outline 1. Context of the study 2. Design by Contract 3. Analysis of class ArrayList 4. Addition of contracts a posteriori 5. Conclusion and future work Page 3 \u252c\u2310Karine Arnout - 2002 3 Presentation outline 1. Context of the study 2. Design by Contract 3. Analysis of class ArrayList 4. Addition of contracts a posteriori 5. Conclusion and future work Page 4 \u252c\u2310Karine Arnout - 2002 4 The Closet Contract Conjecture Which of the following is true? 1. Eiffel libraries have contracts just because Eiffel supports contracts. 2. Contracts are inherent in any good library design. Page 5 \u252c\u2310Karine Arnout - 2002 5 Expected impact of the study \u0393\u00ea\u00c4 Help . \u0393\u00c7\u00a3\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["32"]}
{"title": "Tell less, say more: The power of implicitness\n", "abstract": " Implicitness is a very practical feature of OO development, as distinctive as anything that is routinely considered part of the definition. It is the constant refusal to say more than what we strictly need to say. The double refusal (refusal to close, refusal to assert completeness) requires some intellectual audacity, but yields a productive development process. In the end, what resolves the contradiction is the release of the software. The release process (the process of closing what was until now open) is the process of equating each type with the Cartesian product of its properties. So when everything has been said, the objects are indeed what they have. But only at the end. Until then, you always leave room for more properties. Everything is open until officially closed; and by telling less now you retain the possibility of saying more later.", "num_citations": "5\n", "authors": ["32"]}
{"title": "Technology of Object-Oriented Languages and Systems 24\n", "abstract": " Technology of Object-Oriented Languages and Systems 24 \u0393\u00c7\u00f6 Monash University Skip to main navigation Skip to search Skip to main content Monash University Logo Help & FAQ Home Profiles Research Units Equipment Projects Research Output Prizes Activities Press / Media Technology of Object-Oriented Languages and Systems 24 Jian Chen, Mingshu Li, Christine Mingins, Bertrand Meyer Research output: Book/Report \u0393\u00c7\u2551 Edited Book \u0393\u00c7\u2551 Other Overview Original language English Place of Publication Melbourne Vic Australia Publisher Monash University Publishing Number of pages 503 Volume 1 ISBN (Print) 0818685514 Publication status Published - 1997 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Chen, J., Li, M., Mingins, C., & Meyer, B. (1997). Technology of Object-Oriented Languages and Systems 24. Monash University Publishing. Chen, Jian ; Li, Mingshu ; Mingins, Christine ; Meyer, . / \u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["32"]}
{"title": "Cepage: Toward computer-aided design of software\n", "abstract": " The C\u251c\u2310page system for structural document manipulation combines the techniques of structural editing with modern concepts about user interfaces. C\u251c\u2310page may be used to produce and modify documents in any language. Adaptation to a new language or to variants of a previously described language are carried out using a simple notation, LDL (Language Description Language). The system relies on an elaborate display mechanism that automatically produces structural representations, adjusted to the current window size, with facilities for quick document traversal. The interface allows both menu-driven and text-driven entry; the built-in parser is able to complete partial input into syntactically correct forms.", "num_citations": "5\n", "authors": ["32"]}
{"title": "The Programming Language for Reusability and Extendability\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - The Programming Language for Reusability and Extendability CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa \u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6 \u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa\u00b5\u00d1\u00a1\u03c3\u00ef\u00d6\u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa The Programming Language for Reusability and Extendability MEYER B. \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 MEYER B. \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 SIGPLAN Notice SIGPLAN Notice 22(2), 85-96, 1987 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03c3\u00ea\u00e5\u00b5\u00f2\u00fa\u03a3\u2555\u00aa\u03a6\u00ed\u00ee\u03c0\u00e9\u00ac\u03c0\u00e2\u00fb\u03c0\u00e9\u2555\u03c0\u00e9\u00ba\u03c0\u00e9\u00bb\u03c0\u00e2\u00ea\u00b5\u00ee\u00e7\u03c3\u00c9\u00e6\u03a6\u00bf\u00c7\u03a6\u00ac\u20a7ACOOL\u03c0\u00fc\u00ab \u03c3\u00ab\u0192\u03a6\u00fa\u00e0 \u03a3\u2555\u2555\u03c3\u2592\u2592 \u03c3\u00ef\u00a5\u03c3\u2556\u2593 \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00e7\u00aa\u03c4\u00c9\u00e5\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03a6\u00ac\u00ee 36(1), 207-217, 1995-01-15 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab15\u03a3\u2557\u2562 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab3\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 80003301769 NII\u00b5\u00a2\u2555\u03a6\u00ac\u00eeID(NCID) AA00446468 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u0398\u00a2\u00e6\u03a6\u00ac\u00ee \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 RefWorks\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 EndNote\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 Mendeley\u03c0\u00fc\u00bdRefer\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["32"]}
{"title": "Quelques concepts importants des langages de programmation modernes et leur expression en Simula 67\n", "abstract": " IV. 2 Les objets virtuels IV. 3 Discrimination entre sous-classes IV. 4 Constitution de modules d'application V-GENERICITE", "num_citations": "5\n", "authors": ["32"]}
{"title": "Software Engineering Aspects of Continuous Development and New Paradigms of Software Production and Deployment\n", "abstract": " The study of software development processes has a long and respectable history as a subdiscipline of software engineering, so long and venerable indeed that the field became a bit sleepy and self-complacent when the jolt of agile methods caught it by surprise in the 2000s. Another incentive to question long-established wisdom was the spectacular rise of technologies made possible by the World Wide Web, notably cloud computing and software-as-a-service. No longer could we content ourselves with the well-honed scheme in which a software system is analyzed, then designed, then programmed and tested, then released unto the world, then updated at a leisurely pace as problem reports and requests for new features get filed, weeded out, and patiently implemented. The pace frantically increases: For idea\u0393\u00c7\u00f4development\u0393\u00c7\u00f4deployment cycles that we used to think of as spreading over months, the timeline now is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["32"]}
{"title": "Towards an Anatomy of Software Requirements\n", "abstract": " Requirements engineering is crucial to software development but lacks a precise definition of its fundamental concepts. Even the basic definitions in the literature and in industry standards are often vague and verbose. To remedy this situation and provide a solid basis for discussions of requirements, this work provides precise definitions of the fundamental requirements concepts and two systematic classifications: a taxonomy of requirement elements (such as components, goals, constraints...); and a taxonomy of possible relations between these elements (such as \u0393\u00c7\u00a3extends\u0393\u00c7\u00a5, \u0393\u00c7\u00a3excepts\u0393\u00c7\u00a5, \u0393\u00c7\u00a3belongs\u0393\u00c7\u00a5 ...). The discussion evaluates the taxonomies on published requirements documents; readers can test the concepts in two online quizzes. The intended result of this work is to spur new advances in the study and practice of software requirements by clarifying the fundamental concepts.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Expressing and verifying embedded software requirements\n", "abstract": " Writing requirements for embedded software is pointless unless they reflect actual needs and the final software implements them. In usual approaches, the use of different notations for requirements (often natural language) and code (a programming language) makes both conditions elusive. To address the problem, we propose to write requirements in the programming language itself. The expected advantages of this seamless approach, called AutoReq include: avoiding the potentially costly miss due to the use of different notations; facilitating software change and evolution, by making it easier to update code when requirements change and conversely; benefiting from the remarkable expressive power of modern object-oriented programming languages, while retaining a level of abstraction appropriate for requirements; leveraging, in both requirements and code, the ideas of Design by Contract, including (as the article shows) applying Hoare-style assertions to express temporal-logic-style properties and timing constraints; and taking advantage of the powerful verification tools that have been developed in recent years. The last goal, verification, is a focus of this article. While the idea of verifying requirements is not widely applied, the use of a precise formalism and a modern program prover (in our case, AutoProof for Eiffel) makes it possible at a very early stage to identify errors and inconsistencies which would, if not caught in the requirements, contaminate the final code. Applying the approach to a well-documented industrial example (a landing gear system) allowed a mechanical proof of consistency and uncovered an error in a previously\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["32"]}
{"title": "Autoteach: incremental hints for programming exercises\n", "abstract": " In recent years, e-learning platforms and MOOCs (Massive Open Online Courses) have gained great popularity, and the Computer Science area is not excluded from this trend. A challenge for MOOCs is providing effective exercises to the students, and this is even more important in applied disciplines such as programming. A major difficulty of this challenge is ensuring that students do not get stuck in solving the exercises, which eventually leads to giving up. This is one of the most significant drawbacks of MOOCs over more traditional forms of teaching, where teachers can provide direct guidance to students who lack the necessary idea for solving an exercise.We designed AutoTeach, an incremental hint system for programming exercises. Given a complete solution of a programming exercise, AutoTeach can generate several stripped out versions of it, numbered by hint level, which initially only contain the skeleton of the solution\u0393\u00c7\u00d6s code, and then, for higher hint levels, gradually reveal more parts of the code and/or hints on how to write it. Students who get stuck on an exercise can ask for a hint (one or multiple times) and receive versions of the code where more and more parts of the solution are revealed, until they are able to proceed on their own. This way we ensure that students who happen to lack the necessary idea for solving an exercise can receive the help they need, instead of immediately giving up.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Rule-based code analysis\n", "abstract": " Program analysis static or dynamic is an important method to improve and maintain code quality. Static analysis gives immediate feedback during the development of a computer program, and can be a great help for programmers. The language design of the Eiffel programming language already encourages high code quality, but the Eiffel IDE has no light-weight static analysis tool.We designed a versatile and extensible rule-based framework for light-weight static program analysis for the Eiffel language called Inspector Eiffel. We implemented a basic set of rules and developed a user interface that is integrated in EiffelStudio, the main Eiffel IDE. The tool is fully usable by programmers and integrates well in the development process. We present several case studies of applying the tool on existing libraries and programs, which show the usefulness of the tool by detecting coding issues and suggesting improvements.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Alias and change calculi, applied to frame inference\n", "abstract": " Alias analysis, which determines whether two expressions in a program may reference to the same object, has many potential applications in program construction and verification. We have developed a theory for alias analysis, the \"alias calculus\", implemented its application to an object-oriented language, and integrated the result into a modern IDE. The calculus has a higher level of precision than many existing alias analysis techniques. One of the principal applications is to allow automatic change analysis, which leads to inferring \"modifies clauses\", providing a significant advance towards addressing the Frame Problem. Experiments were able to infer the \"modifies\" clauses of an existing formally specified library. Other applications, in particular to concurrent programming, also appear possible. The article presents the calculus, the application to frame analysis including ex-perimental results, and other projected applications. The ongoing work includes building more efficient model capturing aliasing properties and soundness proof for its essential elements.", "num_citations": "4\n", "authors": ["32"]}
{"title": "News and notification: Propagating relevant changes to developers\n", "abstract": " In any software development team staying up to date on the current changes that are occurring in the project is mandatory. There exist many forms today through which that is accomplished: standup meetings, mailing lists, configuration management logs, and many more. However, a lot of information is proliferated naturally as a result of developers working on projects usually being co-located. However when these developers move into a distributed environment, this natural information proliferation cannot occur, and much more attention must be placed on keeping each other up to date on the changes that are occurring. In this report, a notification system that delivers notifications in real-time as well as notifications that were sent while offline was designed and implemented. The system is well designed, highly extendible, server push driven and tailor-maid especially for the Integrated Development Environment and toolset Cloudstudio. Additionally, two widgets were also created for displaying the notifications in the system.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Evidence-based automated program fixing\n", "abstract": " Many programmers, when they encounter an error, would like to have the benefit of automatic fix suggestions\u0393\u00c7\u00f6as long as they are, most of the time, adequate. Initial research in this direction has generally limited itself to specific areas, such as data structure classes with carefully designed interfaces, and relied on simple approaches. To provide high-quality fix suggestions in a broad area of applicability, the present work relies on the presence of contracts in the code, and on the availability of dynamic analysis to gather evidence on the values taken by expressions derived from the program text. The ideas have been built into the AutoFix-E2 automatic fix generator. Applications of AutoFix-E2 to general-purpose software, such as a library to manipulate documents, show that the approach provides an improvement over previous techniques, in particular purely model-based approaches.", "num_citations": "4\n", "authors": ["32"]}
{"title": "A comprehensive operational semantics of the SCOOP programming model\n", "abstract": " Operational semantics has established itself as a flexible but rigorous means to describe the meaning of programming languages. Oftentimes, it is felt necessary to keep a semantics small, for example to facilitate its use for model checking by avoiding state space explosion. However, omitting many details in a semantics typically makes results valid for a limited core language only, leaving a wide gap towards any real implementation. In this paper we present a full-fledged semantics of the concurrent object-oriented programming language SCOOP (Simple Concurrent Object-Oriented Programming). The semantics has been found detailed enough to guide an implementation of the SCOOP compiler and runtime system, and to detect and correct a variety of errors and ambiguities in the original informal specification and prototype implementation. In our formal specification, we use abstract data types with preconditions and axioms to describe the state, and introduce a number of special run-time operations to model the runtime system with our inference rules. This approach allows us to make our large formal specification manageable, providing a first step towards reference documents for specifying object-oriented languages based on operational semantics.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Developing JavaScript applications in Eiffel\n", "abstract": " Today\u0393\u00c7\u00d6s software projects are increasingly moving from native applications to web applications. A web application is a program that is downloaded and executed by a web browser. Popular examples are email clients, map applications or social networks. They have several advantages such as no installation required (they run in the user\u0393\u00c7\u00d6s browser), always up to date (users always fetch the latest version of the application from the web server), centralised data and lower maintenance costs. The most popular programming language of the browser is JavaScript 1. Although it brings flexibility and power, programming with JavaScript introduces several problems. The language is dynamically and weakly typed and everything runs together in the same global scope, thus making it hard to define interfaces. Moreover, since JavaScript is not compiled and different browsers implement the specifications differently, it is easy for programmers to introduce errors.Alternatives to JavaScript have been proposed. For example, browser plugins such as Adobe Flash [3] for ActionScript, Microsoft Silverlight [34] for .NET languages or Java Applets [4] for the Java language have been developed in order to enable programmers to execute code in the browser and to avoid writing JavaScript. Lack of adoption of these technologies [32, 33], performance or security issues [2, 11, 31] introduce risks in using these solutions. Even though some of these browser plugins provide APIs to a programmer which are not available from JavaScript, with the development and adoption of HTML5 [14], JavaScript gains even more ground.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Point/Counterpoint\n", "abstract": " Bertrand Meyer recently proposed seven principles of software testing. Other sets of principles embraced by testing professionals worldwide suggest that Meyer's list can be improved. One such set is the International Software Testing Qualifications Board Certified Tester Foundation Level Syllabus.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Systematic evaluation of test failure results\n", "abstract": " Systematic software testing provides an important source of software failure analysis. The field suffers, however, from insufficiently reproducible results, lack of standard credible data, and insufficiently explicit assumptions. The present article attempts to provide an objective basis for failure analysis through an automatic testing framework (AutoTest) for contractequipped software. We present five principles for scientific failure analysis, a set of reproducible test results, and a first analysis of their consequences for software development.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Europe's computer scientists take fate into their own hands\n", "abstract": " CS chairs from universities throughout Europe and beyond came together for a momentous meeting to examine the fate and the future of the field.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Implementing a Proof-Transforming Compiler from Eiffel to CIL\n", "abstract": " Recently, proof-transforming compilation from a logic for common object-oriented languages to bytecode logic has been presented [2]. The goal of this work was to implement this proof-transforming compilation in Eiffel from a subset of the Eiffel language to CIL. The proof-transforming compiler (PTC) takes a source code proof in an xml file as input and generates the bytecode proof. It uses the logic and the translation functions presented in [1, 2] for Eiffel specific constructs.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Reusable mathematical models\n", "abstract": " In this thesis we develop a framework of reusable mathematical models intended to be used in EIFFEL contracts. As first steps towards this goal we identify the necessary mathematical concepts and compare already existing approaches to formal software development to the current specification-related facilities provided by the EIFFEL language.Equipped with this theoretical background, we derive a new contract language named Intermediate Functional Language (IFL), which is specifically designed to support high-level mathematical constructs from set theory and relation algebra. To give the proof of concept, we extend some existing classes of the EIFFELBASE library with mathematical model contracts. The principal contribution of this thesis consists of a set of library classes bundled in the Mathematical Model Library (MML), providing the necessary support to write powerful and expressive model contracts in\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["32"]}
{"title": "Contrats cach\u251c\u2310s en. NET: Mise au jour et ajout de contrats a posteriori\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u251c\u00actre utilis\u251c\u2310 dans le cadre d\u0393\u00c7\u00d6une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u251c\u2592alado antes, el contenido de este registro bibliogr\u251c\u00edfico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "4\n", "authors": ["32"]}
{"title": "Multi-language programming: how .NET does it\n", "abstract": " What does it take to support several programming languages within one environment? The example of .NET, which has taken language interoperability to new heights, shows that it\u0393\u00c7\u00d6s possible, but only with the right design, the right infrastructure, and appropriate effort on the basis of both compiler writers and programmers. In this three-part article, I\u0393\u00c7\u00d6d like to go deeper than what I have seen published on the topic, to elucidate what it takes to provide true language openness. The experience that my colleagues have accumulated over the last three years of working to port Eiffel on .NET, as well as the countless discussions we have had with other .NET language implementers, informs this discussion.", "num_citations": "4\n", "authors": ["32"]}
{"title": "Ensuring strong typing in an object-oriented language\n", "abstract": " Static typing, also known as strong typing, has a long and rich history in programming languages. Object-oriented technology makes typing even more interesting for two reasons:", "num_citations": "4\n", "authors": ["32"]}
{"title": "Eiffel: applying the principles of object-oriented design\n", "abstract": " Eiffel: applying the principles of object-oriented design | Computer Language ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Computer Language Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsComputer LanguageVol. , No. Eiffel: applying the principles of object-oriented design article Eiffel: applying the principles of object-oriented design Share on Author: Bertrand Meyer profile image B. Meyer View Profile Authors Info & Affiliations Publication: Computer LanguageMay 1988 1citation 0 Downloads Metrics Total Citations1 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been to.\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["32"]}
{"title": "Ce\u2560\u00fcpage: A software design tool\n", "abstract": " Cepage: A software design tool | Computer Language ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Computer Language Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsComputer LanguageVol. , No. Cepage: A software design tool article Cepage: A software design tool Share on Author: Bertrand Meyer profile image Bertrand Meyer View Profile Authors Info & Affiliations Publication: Computer LanguageSeptember 1986 2citation 0 Downloads Metrics Total Citations2 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: You will be a that . \u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["32"]}
{"title": "An occurrence of the hydrous lead-copper-iron silicate creaseyite in South Africa\n", "abstract": " //static.cambridge.org/content/id/urn%3Acambridge.org%3Aid%3Aarticle%3AS0026461X00036434/resource/name/firstPage-S0026461X00036434a.jpg", "num_citations": "4\n", "authors": ["32"]}
{"title": "A three-level approach to the description of data structures, and notational framework\n", "abstract": " When talking about data structures, whether local to a program or persistent over time, three different viewpoints are equally important. The first one is that of the user, who is interested in the external properties of a certain structure, more precisely, its noticeable behavior in response to outside effects (queries, requests for modifications, etc.). The second viewpoint is that of the language designer, who is in search of a small number of basic objects and building mechanisms which will allow for the description of complex objects in terms of simpler ones. The last view is that of the implementor, who must find efficient representations for the constructs thus described. Based on this remark, a three-level description of data structures has been used by the author in previous work [6, 7, 8]. The three levels may be called:", "num_citations": "4\n", "authors": ["32"]}
{"title": "A contract-based method to specify stimulus-response requirements\n", "abstract": " The verification of many practical systems in particular, embedded systems involves processes executing over time, for which it is common to use models based on temporal logic, in either its linear (LTL) or branching (CTL). Some of today\u0393\u00c7\u00d6s most advanced automatic program verifiers, however, rely on non-temporal theories, particularly Hoare-style logic. Can we still take advantage of this sophisticated verification technology for more challenging systems? As a step towards a positive answer, we have defined a translation scheme from temporal specifications to contract-equipped object-oriented programs, expressed in Eiffel and hence open for processing by the AutoProof program prover. We have applied this scheme to a published CTL model of a widely used realistic example, the \u0393\u00c7\u00a3landing gear\u0393\u00c7\u00a5 system which has been the subject of numerous competing specifications. An attempt to verify the result in AutoProof failed to prove one temporal property, which on further inspection seemed to be wrong in the original published model, even though the published work claimed to have verified an Abstract State Machine implementation of that model. Correcting the CTL specification to reflect the apparent informal attempt, re-translating again to contracted Eiffel and re-running the verification leads to success. The LTL-to-contracted-Eiffel process is still ad hoc, and tailored to generate the kind of scheme that the target verification tool (AutoProof) can handle best, rather than the simplest or most elegant scheme. Even with this limitation, the results highlight the need for rigor in the verification process, and (on the positive side) demonstrate that the highly\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["32"]}
{"title": "On the verification of SCOOP programs\n", "abstract": " In this paper we focus on the development of a unifying framework for the formal modeling of an object oriented-programming language, its underlying concurrency model and their associated analysis tools. More precisely, we target SCOOP \u0393\u00c7\u00f4 an elegant concurrency model, recently formalized based on Rewriting Logic (RL) and Maude. SCOOP is implemented in Eiffel and its applicability is demonstrated also from a practical perspective, in the area of robotics programming. Our contribution consists of devising and integrating an alias analyzer and a Coffman deadlock detector under the roof of the same RL-based semantic framework of SCOOP. This enables using the Maude rewriting engine and its LTL model-checker \u0393\u00c7\u00a3for free,\u0393\u00c7\u00a5 in order to perform the analyses of interest. We discuss the limitations of our approach for model-checking deadlocks and provide possible workarounds for the state space explosion\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["32"]}
{"title": "Class invariants: concepts, problems, solutions\n", "abstract": " Class invariants are both a core concept of object-oriented programming and the source of the two key open OO verification problems: furtive access (from callbacks) and reference leak. Existing approaches force on programmers an unacceptable annotation burden. This article explains invariants and solves both problems modularly through the O-rule, defining fundamental OO semantics, and the inhibition rule, using information hiding to remove harmful reference leaks. It also introduces the concept of \"object tribe\" as a basis for other possible approaches. For all readers: this article is long because it includes a tutorial, covers many examples and dispels misconceptions. To understand the key ideas and results, however, the first two pages suffice. For non-experts in verification: all concepts are explained; anyone with a basic understanding of object-oriented programming can understand the discussion. For experts: the main limitation of this work is that it is a paper proposal (no soundness proof, no implementation). It addresses, however, the known problems with class invariants, solving such examples as linked lists and Observer, through a simple theory and without any of the following: ownership; separation logic; universe types; object wrapping and unwrapping; semantic collaboration, observer specifications; history invariants; \"inc\" and \"coop\" constructs; friendship construct; non-modular reasoning. More generally, it involves no new language construct and no new programmer annotations.", "num_citations": "3\n", "authors": ["32"]}
{"title": "Coffman deadlocks in SCOOP\n", "abstract": " In this paper we address the deadlock detection problem in the context of SCOOP - an OO-programming model for concurrency, recently formalized in Maude. We present the integration of a deadlock detection mechanism on top of the aforementioned formalization and analyze how an abstract semantics of SCOOP based on a notion of \"may alias expressions\" can contribute to improving the deadlock detection procedure.", "num_citations": "3\n", "authors": ["32"]}
{"title": "How specifications change and why you should care\n", "abstract": " Contracts are a form of lightweight formal specification embedded in the program text; by combining specification and implementation, they try to make it easier for programmers to write and update the specification. Motivated by the importance of having accurate specifications over a system\u0393\u00c7\u00d6s lifetime, this paper presents an extensive empirical study of 15 software projects in Eiffel and C# using contracts over a total of 97 years of development. The study analyzes 1) how specifications change over time, 2) what is the relationship between code changes and specification changes for the same project, and 3) what are the consequences for project development activities. The results include: the percentage of program elements with specification is above 33% for most projects and tends to be stable over time; there is no strong preference for a certain type of specification element (preconditions, postconditions, class invariants); specifications are quite stable compared to implementations.", "num_citations": "3\n", "authors": ["32"]}
{"title": "Targeted expressions: safe object creation with void safety\n", "abstract": " In a language supporting void safety [1], object creation poses a particular problem, since a creation procedure (constructor) may be cause calls to non-fully-initialized objects and hence cause crashes (several examples follow). We may call this problem the fragile delegate dilemma by analogy with [2].A solution to this problem for Java was proposed by M\u251c\u255dller [3, 4], but it involves a significant language extension (commit and free keywords) and it seems unrealistic that programmers would go for it. We have developed a solution that does not rely on any new syntax or", "num_citations": "3\n", "authors": ["32"]}
{"title": "Schema evolution for persistent object-oriented software: Model, empirical study, and automated support\n", "abstract": " With the wide support for object serialization in object-oriented programming languages, persistent objects have become common place and most large object-oriented software systems rely on extensive amounts of persistent data. Such systems also evolve over time. Retrieving previously persisted objects from classes whose schema has changed is however difficult, and may lead to invalidating the consistency of the application. The ESCHER framework addresses this issues through an IDE-integrated approach that handles schema evolution by managing versions of the code and generating transformation functions automatically. The infrastructure also enforces class invariants to prevent the introduction of any corrupt objects. This article describes the principles behind invariant-safe schema evolution, and the design and implementation of the ESCHER system.", "num_citations": "3\n", "authors": ["32"]}
{"title": "Objective-C frameworks to Eiffel converter\n", "abstract": " EiffelVision [2] is an object-oriented framework for graphical user interface development, originally created by Eiffel Software. It is designed to be platform independent but it is not implemented for Mac OS X (although a GTK+/X11 based version exists). A necessary step towards this direction is the porting of Cocoa, an Apple framework used to create Mac OS X native applications, to Eiffel. This led to the development of an automated tool that converts Objective-C frameworks to Eiffel.", "num_citations": "3\n", "authors": ["32"]}
{"title": "By students, for students: a production-quality multimedia library and its application to game-based teaching.\n", "abstract": " The attractive idea of using game development for teaching programming can only meet student expectations and modern software engineering requirements if it uses advanced multimedia technology, at the level of the best commercial solutions. In implementing novel pedagogical techniques, we have developed a powerful multimedia library, with major contributions from students, and used it to offer games as course projects. More than 150 games have been developed, many of very high quality, and publicly available for everyone\u0393\u00c7\u00d6s enjoyment. This experience combines advanced software development with student participation, strong OO software engineering principles, and the excitement of one of the coolest areas of technology.", "num_citations": "3\n", "authors": ["32"]}
{"title": "TrucStudio: a prototype\n", "abstract": " This master thesis was written in winter semester 2006/2007 at the Chair of Software Engineering at ETH Zurich as a part of developing a new methodology for managing courses. An important goal was the development of a framework allowing knowledge definition, hierarchical structuring, and dependency description as presented in [Mey06] and refined in [POM07]. The resulting tool TrucStudio eases course preparation and thereby helps improving the teaching quality. A first version was released and is herein documented. Further development is still ongoing...", "num_citations": "3\n", "authors": ["32"]}
{"title": "European computer science takes its fate in its own hands\n", "abstract": " Europe\u0393\u00c7\u00d6s contribution to computer science, going back seventy years with Turing and Zuse, is extensive and prestigious; but the European computer science community is far from having achieved the same strength and unity as its American counterpart. On 20 and 21 October 2005, at ETH Zurich, the \u0393\u00c7\u00a3European Computer Science Summit\u0393\u00c7\u00a5 brought together, for the first time, heads of computer science departments throughout Europe and its periphery. This landmark event was a joint undertaking of the CS departments of the two branches of the Swiss Federal Institute of Technology: EPFL (Lausanne) and ETH (Zurich).The initiative attracted interest far beyond its original scope. Close to 100 people attended, representing most countries of the European Union, plus Switzerland, Turkey, Ukraine, Russia, Israel, a delegate from South Africa, and a representative of the ACM, Russ Shackelford, from the US. Eastern Europe was well represented. The program consisted of two keynotes and a number of panels and workshops on such themes as research policy, curriculum harmonization, attracting students, teaching CS to non-CS students, existing national initiatives, and plans for a Europe-wide organization.", "num_citations": "3\n", "authors": ["32"]}
{"title": "Component-based development? refining the blueprint\n", "abstract": " Beyond Objects Component-Based Software Engineering (Smith) As the speed of change in both business and technology increases, post Y2K, it's becoming increasingly clear that software development needs to move from a craft activity to a modern industrial process capable of using componentization to reduce cost and time-to-market. The Windows 2000 and Enterprise JavaBeans platforms are arguably the first mature platforms specifically designed to support enterprise scale component-based applications. Over the next few years, most new applications will be delivered onto one or the other of these platforms. The new component-based platforms are also being complemented by widespread adoption of XML (eXtensible Markup Language) as an internal and external interoperability backplane, which enables heterogeneous component connectivity. Specific issues that will be addressed by the panel include\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["32"]}
{"title": "The Unity of Software and the Power of Roundtrip Engineering\n", "abstract": " Part of the initial progress in developing an engineering basis for software development was to identify the specific tasks at hand and highlight their differences. Although that step was probably inevitable, it has led to a somewhat skewed view of software engineering, which ignores the fundamental unity of software construction, and leads to unnecessary gaps, detrimental to quality and productivity. It is more fruitful to take advantage of the fundamental invariants of software development and view system engineering as a continuous, seamless and reversible process. The talk will show how that full roundtrip engineering is possible in practice, leading to far higher quality of both process and product.", "num_citations": "3\n", "authors": ["32"]}
{"title": "Software Architecture\n", "abstract": " Software Architecture Bertrand Meyer Lecture 4: Design by Contract Page 1 1 Software Architecture Bertrand Meyer ETH Zurich, March-July 2007 Last update: 10 April 2007 Lecture 4: Design by Contract 2 Reading material OOSC2: \u0393\u20a7\u00f3 Chapter 11: Design by Contract 3 Design by Contract A discipline of analysis, design, implementation, management 4 Applications Getting the software right Analysis Design Implementation Debugging Testing Management Maintenance Documentation 5 Design by Contract \u0393\u20a7\u00f3 Origin: work on \u0393\u00c7\u00a3axiomatic semantics\u0393\u00c7\u00a5 (Floyd, Hoare, Dijkstra), early seventies \u0393\u20a7\u00f3 Some research languages had a built-in assertion mechanism: Euclid, Alphard \u0393\u20a7\u00f3 Eiffel introduced the connection with objectoriented programming and made contracts a software construction methodology and an integral part of the language \u0393\u20a7\u00f3 Mechanisms for other languages: Nana macro package for C++, JML for Java, Spec# (of (\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["32"]}
{"title": "Reversibility in software engineering\n", "abstract": " Part of the attraction of object technology is its ability to remove or lower the walls that have traditionally stood between various aspects of software construction-analysis, design, implementation, maintenance. A good OO process should be reversible, allowing developers to move between tasks backward as well as forward, with many benefits for the quality of the process and the product. The author explains the concept.", "num_citations": "3\n", "authors": ["32"]}
{"title": "The conceptual perspective\n", "abstract": " Object technology is here to stay. For a while, after object-oriented ideas burst onto the software scene in the mid-eighties, we heard people say,\" It's just a fad and will go away like the others.\" Not any more. The commitment of the big players is proof enough. Just mention your favorite household name in hardware or software; almost certainly it has defined an\" all object\" software policy (although one might quibble about how seriously they are doing it, how much is show and how much is reality). True, except forbanking, networking, and other areas with particularly demanding requirements, the spread of 00 ideas is not as universal in the applications software community as in the core group of computer vendors and major software houses. But the move is irresistible, and very few software experts doubt that object technology is the way to go. Not since Dijkstra came up with structured programming around 1970 has\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["32"]}
{"title": "On the role of methodology: Advice to the advisors\n", "abstract": " The field of software development methodology is not new. Its origins may be traced to Dijkstra's famous\" Goto\" letter [1] and subsequent publications by the same author and his colleagues on structured programming. More recent literature, however, has not always been up to the intellectual standards of that early work. The present discussion was prompted by a critical examination of the currently available methodological work in the object-oriented area. This leads to a number of precepts that all methodologists should follow. Even a casual look at the objectoriented literature yields many counter-examples: rules that are unusable, poorly thought out, or simply wrong. This article focuses on the precepts rather than the counter-examples, if only to avoid the unpleasantness of having to take well-known methodologists to task. 2. Theory and Practice The methodologist is entrusted with a serious responsibility: telling software developers how to write their software, and how not to write it. In a field where religious metaphors come up so often, it is natural to compare methodologists to preachers or", "num_citations": "3\n", "authors": ["32"]}
{"title": "The design of vector programs\n", "abstract": " Current vector computers such as the CraY-I, Cyber 205 S 1, DAP or BSP pose a special challenge to the software designer as the available software tools and techniques are far behind the hardware developments, and the goals of efficient vector programming seem to conflict with some of the basic principles of good software engineering. After studying some properties of these computers, with particular emphasis on the Cray-l, we purport to show that a systematic approach to vector programming is possible and fruitful; the proposed methods are applied to the systematic, proof-oriented derivation of several vector algorithms. Language aspects are also considered.", "num_citations": "3\n", "authors": ["32"]}
{"title": "The role of formalism in system requirements (full version)\n", "abstract": " A major determinant of the quality of software systems is the quality of their requirements, which should be both understandable and precise. Most requirements are written in natural language, good for understandability but lacking in precision. To make requirements precise, researchers have for years advocated the use of mathematics-based notations and methods, known as \"formal\". Many exist, differing in their style, scope and applicability. The present survey discusses some of the main formal approaches and compares them to informal methods. The analysis uses a set of 9 complementary criteria, such as level of abstraction, tool availability, traceability support. It classifies the approaches into five categories: general-purpose, natural-language, graph/automata, other mathematical notations, seamless (programming-language-based). It presents approaches in all of these categories, altogether 22 different ones, including for example SysML, Relax, Eiffel, Event-B, Alloy. The review discusses a number of open questions, including seamlessness, the role of tools and education, and how to make industrial applications benefit more from the contributions of formal approaches. (This is the full version of the survey, including some sections and two appendices which, because of length restrictions, do not appear in the submitted version.)", "num_citations": "2\n", "authors": ["32"]}
{"title": "The role of formalism in system requirements\n", "abstract": " A major determinant of the quality of software systems is the quality of their requirements, which should be both understandable and precise. Most requirements are written in natural language, which is good for understandability but lacks precision. To make requirements precise, researchers have for years advocated the use of mathematics-based notations and methods, known as \u0393\u00c7\u00a3formal.\u0393\u00c7\u00a5 Many exist, differing in their style, scope, and applicability. The present survey discusses some of the main formal approaches and compares them to informal methods. The analysis uses a set of nine complementary criteria, such as level of abstraction, tool availability, and traceability support. It classifies the approaches into five categories based on their principal style for specifying requirements: natural-language, semi-formal, automata/graphs, mathematical, and seamless (programming-language-based). It includes examples\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["32"]}
{"title": "Fourteen years of software engineering at ETH Zurich\n", "abstract": " A Chair of Software Engineering existed at ETH Zurich, the Swiss Federal Insti-tute of Technology, from 1 October 2001 to 31 January 2016, under my leader-ship. Our work, summarized here, covered a wide range of theoretical and practi-cal topics, with object technology in the Eiffel method as the unifying thread .", "num_citations": "2\n", "authors": ["32"]}
{"title": "Rational Ethics\n", "abstract": " An effort, originating from an invited talk on \u0393\u00c7\u00a3ethics and computers\u0393\u00c7\u00a5, to re-found ethics on the rules of logical reasoning, from three concrete principles (Goodness, Truth, Fairness) and two meta-principles (Restraint and Importance).", "num_citations": "2\n", "authors": ["32"]}
{"title": "Theory of Programs\n", "abstract": " \u0393\u00c7\u00a3Computer science\u0393\u00c7\u00a5 (informatics) is really program science since a computer, by itself too general a machine to be of practical interest, yields useful machines through programs that people write for it.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Inheritance\n", "abstract": " The world (are you ready, this early in the chapter, for deep revelations about life?) is a mess. Nature perhaps abhors a mess, perhaps not, I am not sure, it depends on whom you read \u0393\u00c7\u00f6 Plato, Aristotle, Kant \u0393\u00c7\u00f6 but science definitely does. Sane reasoning about the world demands order.", "num_citations": "2\n", "authors": ["32"]}
{"title": "A survey of loop invariants\n", "abstract": " At the heart of every loop, and hence of all algorithms, lies a loop invariant: a property ensured by the initialization and maintained by every iteration so that, when combined with the exit condition, it yields the loop\u0393\u00c7\u00d6s final effect. Identifying the invariant of every loop is not only a required step for software verification, but also a key requirement for understanding the loop and the program to which it belongs. The systematic study of loop invariants of important algorithms can, as a consequence, yield insights into the nature of software. We performed this study over a wide range of fundamental algorithms from diverse areas of computer science. We analyze the patterns according to which invariants are derived from postconditions, propose a classification of invariants according to these patterns, and present its application to the algorithms reviewed. The discussion also shows the need for high-level specifications and invariants based on \u0393\u00c7\u00a3domain theory\u0393\u00c7\u00a5. The included invariants and the corresponding algorithms have been mechanically verified using an automatic program prover. Along with the classification and applications, the conclusions include suggestions for automatic invariant inference and general techniques for model-based specification.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Performance analysis of SCOOP programs\n", "abstract": " To support developers in writing reliable and efficient concurrent programs, novel concurrent programming abstractions have been proposed in recent years. Programming with such abstractions requires new analysis tools because the execution semantics often differs considerably from established models. We present a performance analyzer that is based on new metrics for programs written in SCOOP, an object-oriented programming model for concurrency. We discuss how the metrics can be used to discover performance issues, and we use the tool to optimize a concurrent robotic control software.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Automatic translation of C source code to Eiffel\n", "abstract": " Can we reuse some of the huge code-base developed in C to take advantage of modern programming language features such as type safety, object-orientation, and contracts? This paper presents a source-to-source translation of C code into Eiffel, a modern object-oriented programming language, and the supporting tool C2Eif. The translation is completely automatic and supports the entire C language (ANSI, as well as many GNU C Compiler extensions, through CIL) as used in practice, including its usage of native system libraries and inlined assembly code. Our experiments show that C2Eif can handle C applications and libraries of significant size (such as vim and libgsl), as well as challenging benchmarks such as the GCC torture tests. The produced Eiffel code is functionally equivalent to the original C code, and takes advantage of some of Eiffel\u0393\u00c7\u00d6s features to produce safe and easy-to-debug translations.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Empirical Software Engineering and Verification: International Summer Schools, LASER 2008-2010, Elba Island, Italy, Revised Tutorial Lectures\n", "abstract": " Software engineering, is widely recognized as one of today's most exciting, stimulating, and profitable research areas, with a significant practical impact on the software industry and academia. The LASER school, held annually since 2004 on Elba Island, Italy, is intended for professionals from industry (engineers and managers) as well as university researchers, including PhD students. This book contains selected lecture notes from the LASER summer schools 2008-2010, which focused on concurrency and correctness in 2008, software testing in 2009, and empirical software engineering, in 2010.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Refinements and Git Integration with Notifications and Monitoring\n", "abstract": " In this report, refinements to improve the work developed in the previous two reports (Monitors:", "num_citations": "2\n", "authors": ["32"]}
{"title": "Monitors: Keeping Informed on Code Changes\n", "abstract": " In small, localized teams information proliferation about ongoing code changes is a natural consequence of the immediate proximity of the developers. However, larger projects and especially distributed projects face challenges where developers may not be aware of all changes that are occurring within a specific project. This report introduces the concept of Monitors, the ability to keep an eye on those changes which are important to a developer. A \u0393\u00c7\u00a3monitor\u0393\u00c7\u00a5 is added to a particular \u0393\u00c7\u00a3aspect\u0393\u00c7\u00a5 of code (library, file, class, feature, pre/post condition, invariant, etc.). When the monitor is added, a \u0393\u00c7\u00a3shadow\u0393\u00c7\u00a5 of the current state of the monitored aspect is archived. The degree to which the aspect should be monitored is specified within a \u0393\u00c7\u00a3comparator,\u0393\u00c7\u00a5 which continuously compares the current state of the aspect as well as the shadow to determine if a \u0393\u00c7\u00a3violation\u0393\u00c7\u00a5 has occurred. If a violation has occurred, the monitor informs the developer through one or more specified communication means. This report also documents the implementation of monitors into the Integrated Development Environment and toolset provided by Cloudstudio.", "num_citations": "2\n", "authors": ["32"]}
{"title": "In support of open reviews; better teaching through large-scale data mining\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmBertrand Meyer writes about his long-standing decision not to provide anonymous reviews. Greg Linden considers how educational practices could be improved through the data mining of students' schoolwork.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Transformation of scientific algorithms to parallel computing code: Single GPU and MPI Multi GPU backends with subdomain support\n", "abstract": " We propose an approach for high-performance scientific computing that separates the description of algorithms from the generation of code for parallel hardware architectures like Multi-Core CPUs, GPUs or FPGAs. This way, a scientist can focus on his domain of expertise by describing his algorithms generically without the need to have knowledge of specific hardware architectures, programming languages, APIs or tool flows. We present our prototype implementation that allows for transforming generic descriptions of algorithms with intensive array-type data access to highly optimized code for GPU and multi GPU cluster systems. We evaluate the approach for an example from the domain of computational nanophotonics and show that our current tool flow is able to generate efficient code that achieves speedups of up to 15.3x for a single GPU and even 35.9x for a multi GPU setup compared to a reference CPU\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["32"]}
{"title": "The prior experience of entering CS students\n", "abstract": " One of the foremost issues for instructors of \"Introduction to Programming\" or \"CS1\" courses is the diversity of students' backgrounds { on one end of the range, a signicant portion of students start their computing degree without prior programming expertise, while on the other end, many students have even worked in a job where programming was a substantial part. This diversity makes it dicult to adapt programming instruction to students' prior experience. The present article describes students' programming and computing experience when entering the ETH Computer Science bachelor program. It is based on the data of over 900 ETH students participating in the study in the past seven years and 77 students from University of York answering the questionnaire in 2008. The article reports on the analysis of changes over the years, presents a comparison between the data of ETH and York, and describes the pedagogical implications for courses and textbooks.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Automatic testing and fixing for Eiffel\n", "abstract": " Key aspects of software development, in particular testing and debugging, still commonly rely on manual techniques. If the programs contain enough built-in correctness information, in the form of contracts, it is possible to automate some of the most tedious and error-prone aspects of testing, and even to perform corrections automatically.               At both ETH and Eiffel Software we have developed such techniques and integrated them into Eiffel programming environments, in the form of tools for automated program testing and automated program fixing: the AutoTest and AutoFix frameworks.               Some of the work is still research in progress, but many results have already been integrated in the production version of the EiffelStudio environment.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Software Engineering Approaches for Offshore and Outsourced Development: 4th International Conference, SEAFOOD 2010, St. Petersburg, Russia, June 17-18, 2010, Proceedings\n", "abstract": " Today\u0393\u00c7\u00d6s software production is increasingly distributed. Gone are the days of one-company, one-siteprojects; mostindustrialdevelopmentsinvolveteamssplit over locations, countries, and cultures. This distribution poses new challenges, for example, how to develop the software requirements speci? cation, and how to manage the project. These challenges are formidable; many failures have been reportedinoutsourcedanddistributedprojects, oftenduenottolackoftechnical expertise, but to di? culties in management and communication. SEAFOOD 2010, the fourth international conference on Software Engine-ing Advances For Outsourced and O? shore Development, was held in Peterhof (SaintPetersburg), Russia, on17-18June2010. SEAFOOD2010providedan-portunity for participants from academia and industry to confront experiences, ideas and proposals. The submissions received covered a wide range of topics, from country-wide reports from Russia and Argentina to global projectmana-ment. This volume includes 8 papers (4 full papers and 4 short papers) from the conference, selected after review by the Program Committee. The program also included two keynote presentations and the extended abstracts are included in this volume:\u0393\u00c7\u00a3A Smarter Way: The Software Engineering Method and Theory Initiative (Semat)\u0393\u00c7\u00a5, by Ivar Jacobson, and \u0393\u00c7\u00a3The Consortium for IT Software Quality\u0393\u00c7\u00a5, by Richard Mark Soley and Bill Curtis. Many people contributed to SEAFOOD 2010. We thank the Program C-mittee and the external reviewers for their excellent work in reviewing and-lecting the papers. The role of Andrei Voronkov\u0393\u00c7\u00d6s EasyChair conference system is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["32"]}
{"title": "The theory and calculus of aliasing\n", "abstract": " A theory, graphical notation, mathematical calculus and implementation for finding whether two given expressions can, at execution time, denote references attached to the same object. Intended as the basis for a comprehensive solution to the \u0393\u00c7\u00a3frame problem\u0393\u00c7\u00a5 and as an alternative (for the specific issue of determining aliases) to separation logic, shape analysis, ownership types and dynamic frames.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Software Engineering Approaches for Offshore and Outsourced Development: Second International Conference, SEAFOOD 2008, Zurich, Switzerland, July 2-3, 2008, Revised Papers\n", "abstract": " Majoreconomicupheavalscanhavethesortofe? ectthatSchumpeterforesaw60 yearsagoascreativedestruction. Inscienceandtechnology, equivalentupheavals resultfromeitherscienti? crevolutions (asobservedbyKuhn) ortheintroduction of what Christensen calls disruptive technologies. And in software engineering, there has been no technology more disruptive than outsourcing. That it should so quickly reach maturity and an unparalleled scale is truly remarkable; that it should now be called to demonstrate its sustainability in the current? nancial turmoil is the challenge that will prove whether and how it will endure. Early signs under even the bleak market conditions of the last 12 months are that it will not only survive, it will? rmly establish its role across the world of business. Outsourcing throws into sharp focus the entire software engineering life-cle. Topics as diverse as requirements analysis, concurrency and model-checking need to? nd a composite working partnership in software engineering practice. This con? uence arises from need, not dogma, and the solutions required are those that will have the right e? ect on the associated activities in the world of the application: eg, reducing the time for a transaction or making the results of a complex analysis available in real-time. While the business of outsourcing continues to be studied, the engineering innovations that make it compelling are constantly changing. It is in this milieu that this series of conferences has placed itself.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Objects, Components, Models and Patterns\n", "abstract": " Objects, Components, Models and Patterns - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Objects, Components, Models and Patterns Oriol, Manuel ; Meyer, Bertrand Abstract Publication: Objects, Components, Models and Patterns Pub Date: 2009 DOI: 10.1007/978-3-642-02571-6 Bibcode: 2009ocmp.book.....O Keywords: Computer Science; Software Engineering; Models and Principles; Information Systems Applications (incl.Internet); Management of Computing and Information Systems full text sources Publisher | \u252c\u2310 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo Resources About ADS ADS Help What's New Careers@ADS Social @adsabs ADS Blog Project Switch to full ADS Is ADS down? (or is it just me...) \u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["32"]}
{"title": "Software Architecture: Object-Oriented vs Functional\n", "abstract": " One of the arguments for functional programming is better modular design. By analyzing publications advocating this approach, in particular through the example of a framework for financial contracts, we assess is strengths and weaknesses, and compare it with object-oriented design. The overall conclusion is that objectoriented design, especially in a modern form supporting high-level routine objects or \u0393\u00c7\u00a3agents\u0393\u00c7\u00a5, subsumes the functional approach, retaining its benefits while providing higher-level abstractions more supportive of extension and reuse.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Integrating proof-transforming compilation into EiffelStudio\n", "abstract": " The execution of untrusted bytecode (such as mobile code) can produce unwanted behavior. A proof on the bytecode programs can be generated to ensure safe execution. Automatic techniques to generate proofs, such as certifying compilation, can only be used for a restricted set of properties such as type safety. In this thesis we present a proof-transforming compiler for a subset of Eiffel to .NET CIL. In particular we introduce new translations of the Eiffel specific keywords and then and or else. Furthermore we formalized the translation of classes routines and attributes. To show the feasibility of the approach we developed an PTC and a corresponding interface in EiffelStudio.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Proof-Transforming Compilation of Eiffel Contracts\n", "abstract": " Modern object-oriented software [1] is complex: it is highly complicated and can contain thousands if not millions of lines of source code. Such huge software is nearly always written within a team of developers, which have to rely on and to trust each other. However, even in the most experienced teams it is possible if not the rule that\u0393\u00c7\u00f4due to for example miscommunication\u0393\u00c7\u00f4defects are introduced on any stage of the development process.", "num_citations": "2\n", "authors": ["32"]}
{"title": "\u2568\u00e1\u2568\u2561\u2564\u00e7\u2564\u00ee \u2568\u255c\u2568\u2591 \u2564\u00e9\u2568\u255b\u2564\u00c7\u2568\u2562\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u2593\u2568\u2561\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u255d \u2568\u2593\u2564\u00c7\u2564\u00e2\u2564\u00e7\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2555 \u2568\u255d\u2568\u2591\u2568\u255c\u2564\u00e9\u2568\u2555\u2568\u2555 \u2568\u2555 \u2568\u2524\u2568\u2555\u2568\u2510\u2568\u2557\u2568\u255b\u2568\u255d\u2568\u2591 \u2568\u2510\u2568\u255b\u2564\u00e7\u2568\u2561\u2564\u00e9\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2524\u2568\u255b\u2568\u2551\u2564\u00e9\u2568\u255b\u2564\u00c7\u2568\u2591 \u2568\u00ed\u2568\u0192\u2568\u2592\u2568\u00f4\u2568\u00fa \u2568\u00ff\u2568\u00f3\u2568\u00a3\u2568\u20a7\n", "abstract": " \u2568\u00ed\u2564\u00e9\u2568\u2591\u2564\u00e9\u2564\u00ee\u2564\u00c5 \u2564\u00c5\u2568\u2593\u2568\u2557\u2564\u00c5\u2568\u2561\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2568\u2555\u2568\u2556\u2568\u2557\u2568\u255b\u2568\u2562\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2561\u2568\u255d \u2568\u2524\u2568\u255b\u2568\u2551\u2564\u00e9\u2568\u255b\u2564\u00c7\u2564\u00fc\u2568\u2551\u2568\u255b\u2568\u2563 \u2568\u2557\u2568\u2561\u2568\u2551\u2564\u00e5\u2568\u2555\u2568\u2555 \u2568\u2555\u2568\u2556\u2568\u2593\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2564\u00e2\u2564\u00e7\u2568\u2561\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2593 \u2568\u255b\u2568\u2592\u2568\u2557\u2568\u2591\u2564\u00fc\u2564\u00e9\u2568\u2555 \u2568\u2555\u2568\u255c\u2564\u00e4\u2568\u255b\u2564\u00c7\u2568\u255d\u2568\u2591\u2564\u00e5\u2568\u2555\u2568\u255b\u2568\u255c\u2568\u255c\u2564\u00ef\u2564\u00e0 \u2564\u00e9\u2568\u2561\u2564\u00e0\u2568\u255c\u2568\u255b\u2568\u2557\u2568\u255b\u2568\u2502\u2568\u2555\u2568\u2563, \u2568\u2593 \u2568\u255b\u2568\u2592\u2568\u2557\u2568\u2591\u2564\u00fc\u2564\u00e9\u2568\u2555 \u2568\u255b\u2568\u2592\u2564\u00e8\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5, \u2568\u2510\u2564\u00c7\u2568\u255b\u2564\u00e4\u2568\u2561\u2564\u00fc\u2564\u00fc\u2568\u255b\u2564\u00c7\u2568\u2591 \u2568\u00e6\u2568\u2561\u2564\u00c7\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u255c\u2568\u2591 \u2568\u00a3\u2568\u2561\u2568\u2563\u2568\u2561\u2564\u00c7\u2568\u2591. 28 \u2568\u255d\u2568\u2591\u2564\u00c7\u2564\u00e9\u2568\u2591 2006 \u2568\u2502\u2568\u255b\u2568\u2524\u2568\u2591 \u2568\u2510\u2568\u255b \u2564\u00c7\u2568\u2561\u2564\u00ea\u2568\u2561\u2568\u255c\u2568\u2555\u2564\u00c4 \u2568\u00fa\u2564\u00e7\u2568\u2561\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2564\u00fc\u2568\u255b\u2568\u2593\u2568\u2561\u2564\u00e9\u2568\u2591 \u2568\u00e6\u2568\u2561\u2564\u00c7\u2564\u00e9\u2564\u00c7\u2568\u2591\u2568\u255c\u2564\u00e2 \u2568\u00a3\u2568\u2561\u2568\u2563\u2568\u2561\u2564\u00c7\u2564\u00e2 \u2568\u2510\u2564\u00c7\u2568\u2555\u2564\u00fc\u2568\u2593\u2568\u255b\u2568\u2561\u2568\u255c\u2568\u255b \u2568\u2556\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2510\u2568\u255b\u2564\u00e7\u2568\u2561\u2564\u00e9\u2568\u255c\u2568\u255b\u2568\u2502\u2568\u255b \u2568\u2524\u2568\u255b\u2568\u2551\u2564\u00e9\u2568\u255b\u2564\u00c7\u2568\u2591 \u2568\u255c\u2568\u2591\u2564\u00e2\u2568\u2551 \u2568\u00ed\u2568\u0192\u2568\u2592\u2568\u00f4\u2568\u00fa \u2568\u00ff\u2568\u00f3\u2568\u00a3\u2568\u20a7. \u2568\u00a2\u2568\u2561\u2568\u2551\u2564\u00e5\u2568\u2555\u2564\u00c4 \u2568\u00a3\u2568\u2561\u2568\u2563\u2568\u2561\u2564\u00c7 \u2568\u2510\u2568\u255b\u2568\u2557\u2568\u255c\u2568\u255b\u2564\u00fc\u2564\u00e9\u2564\u00ee\u2564\u00c4 \u2564\u00e7\u2568\u2555\u2564\u00e9\u2568\u2591\u2568\u2557 \u2568\u2510\u2568\u255b-\u2564\u00c7\u2564\u00e2\u2564\u00fc\u2564\u00fc\u2568\u2551\u2568\u2555. \u2568\u00f6\u2568\u255b\u2568\u2551\u2568\u2557\u2568\u2591\u2568\u2524\u2564\u00e7\u2568\u2555\u2568\u2551 \u2568\u2510\u2568\u255b\u2568\u2556\u2568\u255c\u2568\u2591\u2568\u2551\u2568\u255b\u2568\u255d\u2568\u2555\u2568\u2557 \u2564\u00fc\u2564\u00e9\u2564\u00e2\u2568\u2524\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u255b\u2568\u2593 \u2568\u2555 \u2568\u2510\u2564\u00c7\u2568\u2561\u2568\u2510\u2568\u255b\u2568\u2524\u2568\u2591\u2568\u2593\u2568\u2591\u2564\u00e9\u2568\u2561\u2568\u2557\u2568\u2561\u2568\u2563 \u2568\u00ed\u2568\u0192\u2568\u2592\u2568\u00f4\u2568\u00fa \u2568\u00ff\u2568\u00f3\u2568\u00a3\u2568\u20a7 \u2564\u00fc \u2568\u255c\u2568\u2561\u2568\u2551\u2568\u255b\u2564\u00e9\u2568\u255b\u2564\u00c7\u2564\u00ef\u2568\u255d\u2568\u2555 \u2568\u255c\u2568\u2591\u2568\u2510\u2564\u00c7\u2568\u2591\u2568\u2593\u2568\u2557\u2568\u2561\u2568\u255c\u2568\u2555\u2564\u00c5\u2568\u255d\u2568\u2555 \u2564\u00fc\u2568\u2593\u2568\u255b\u2568\u2561\u2568\u2563 \u2564\u00c7\u2568\u2591\u2568\u2592\u2568\u255b\u2564\u00e9\u2564\u00ef \u2568\u2593 \u2564\u00e9\u2568\u2561\u2564\u00e7\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2510\u2568\u255b\u2564\u00fc\u2568\u2557\u2568\u2561\u2568\u2524\u2568\u255c\u2568\u2555\u2564\u00e0 \u2568\u2557\u2568\u2561\u2564\u00e9.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Proving program pointer properties\n", "abstract": " The last article is not yet available in the same form as the others parts, but the results so far are covered in a self-contained article written to be readable independently of the rest: Towards practical proofs of class correctness.(Revision: 17 February 2003)", "num_citations": "2\n", "authors": ["32"]}
{"title": "Assessing a C# text\n", "abstract": " In a typed OO language, programmers declare every variable with a type, restricting the kind of values that it can take at runtime. This declaration can be an \u0393\u00c7\u00a3expanded\u0393\u00c7\u00a5 type in Eiffel terminology, or a value type in .NET, meaning that the variable will directly denote objects or other values. Or it can be a reference type so that the variable denotes references to objects of certain types compatible with its declaration. The preceding description, however, commingles everything. The stack doesn\u0393\u00c7\u00d6t store the variables, it stores their values. Value types are not allocated on the stack, their instances are. An instance of a type is a value or object described by that type. In both cases, the \u0393\u00c7\u00a3eg\u0393\u00c7\u00a5 is wrong: An integer is not an example of a value type\u0393\u00c7\u00f6it\u0393\u00c7\u00d6s an instance of a sample value type, int. Nor is an object an example of a reference type\u0393\u00c7\u00f6it\u0393\u00c7\u00d6s twice remote: the value of a reference type\u0393\u00c7\u00d6s variable is a reference that, if not void, is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["32"]}
{"title": "In memory of Ole-Johan Dahl and Kristen Nygaard\n", "abstract": " The Summer of 2002 has been particularly somber for the history of software in general and object technology in particular. Ole-Johan Dahl passed away on June 29. Only a few weeks later, on August 9, his old friend and colleague Kristen Nygaard died suddenly. In-between, as JOT readers have probably learned, another great pioneer, Edsger Dijsktra, lost his battle with cancer.Dahl and Nygaard are the indisputed founders of object technology. Their collaboration in the nineteen-sixties led to the Simula languages, culminating with Simula 67 which created a whole new discipline, even if it took another twenty years for the industry at large to understand it. The inspiration of these two pioneers is without peer; the whole field\u0393\u00c7\u00f4JOT included, of which Kristen Nygaard was a founding Advisory Board member\u0393\u00c7\u00f4would not exist without them.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Software Construction\n", "abstract": " The hardest single part of building a software system is deciding precisely what to build. No other part of the conceptual work is as difficult as establishing the detailed technical requirements, including all the interfaces to people, to machines, and to other software systems. No other part of the work so cripples the resulting system if done wrong. No other part is more difficult to rectify later.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Concurrent Object-Oriented Programming.\n", "abstract": " For multiprocessor: test and set instruction of processor (1) If the bit is zero then set it to one and return zero (2) If the bit is one return one these actions are indivisible\u0393\u00fb\u00ac two parallel processes (both wishing to execute eg a wait will do a test and set operation on the same lock bit (initially zero)\u0393\u00fb\u00ac one will succeed and set the bit to one\u0393\u00fb\u00ac the other process will have returned a one will therefore have to loop round and retest the lock\u0393\u00fb\u00ac when first process completes the wait operation it will set the bit to zero (that is unlock the semaphore)\u0393\u00fb\u00ac other process will proceed to execute its wait operation", "num_citations": "2\n", "authors": ["32"]}
{"title": "EiffelStudio: A Guided Tour\n", "abstract": " \u0393\u00c7\u00f3 Open compiled project, to retrieve and open an existing project. As a beginner, you would probably choose the first option (and you would be right!), which guides you through the different steps of starting a new ISE Eiffel project. But as a guided tour, this introductory paper would like to go a little further in the use of EiffelStudio. Therefore we will use an example provided with your ISE Eiffel delivery\u0393\u00c7\u00f4the Tour example\u0393\u00c7\u00f4which is located in $ ISE_EIFFEL/examples/studio/tour. This example is not meant to be a best-of-breed example of what you can do with EiffelStudio. It is a very simple example\u0393\u00c7\u00f4the same kind of the well-known HelloWorld sample\u0393\u00c7\u00f4whose only merit is to be already written and ready to be compiled!", "num_citations": "2\n", "authors": ["32"]}
{"title": "DESIGN BY CONTRACT and Genericity for Java\n", "abstract": " \u0393\u00c7\u00a3I should not design a small language, and I should not design a large one. I need to design a language that can grow. I need to plan ways in which it might grow but I need, too, to leave some choices so that other persons can make those choices at a later time.\u0393\u00c7\u00a5", "num_citations": "2\n", "authors": ["32"]}
{"title": "Prelude to a Theory of Void\n", "abstract": " A set of rules to ascertain that in calls of the form x. f (...) there will always be an object attached to x.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Technology of Object-oriented Languages and Systems\n", "abstract": " The papers in this book comprise the proceedings of the meeting mentioned on the cover and title page. They reflect the authors\u0393\u00c7\u00d6 opinions and, in the interests of timely dissemination, are published as presented and without change. Their inclusion in this publication does not necessarily constitute endorsement by the editors, the IEEE Computer Society, or the Institute of Electrical and Electronics Engineers. Inc.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Gurus share insights onn objects\n", "abstract": " Get three of the best-known object methodologists in a room and what do you get? A wide-ranging interview in which Grady Booch, lvar Jacobson, and James Rumbaugh share their insights about some of the topics of most interest to the readers of this department, from patterns to the role of modeling and the future of the software industry Separately, they wrote three of the best-known books in the field. Now teamed up at Rational, they are attempting to define the modeling language of tomorrow through their work on the Unified Modeling Language. They were interviewed by Computer staff members Angela Burgess and Scott Hamilton at Software Development\u0393\u00c7\u00d695.-Bertrand Meyer", "num_citations": "2\n", "authors": ["32"]}
{"title": "Static typing\n", "abstract": " The policy known as static typing, which I will argue is the only reasonable one for professional software development, states that we should answer the\" when\" part of the question by\" before we ever think of running the system\", and the\" how\" part by\" through mere examination of the software text\".Let us make the terminology precise, x will be called an entity; this is a generalization of the traditional notion of variable, f will, in interesting cases, be a routine; SmaUtalk would call it a method, but there is no need for a new term since the older one is well established. At run time the value of x, if not void, will be attached to a certain object, OBJ on the figure.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Eiffel: The Reference\n", "abstract": " a shorter bo unit cell length than the sample from Cruz del Sur and the iron content of the two samples are inversely proportional to the unit cell lengths. oa b_ ol X 21. i21~", "num_citations": "2\n", "authors": ["32"]}
{"title": "Technology of Object-oriented Languages and Systems: TOOLS 4: Proceedings of the Fourth International Conference\n", "abstract": " This conference proceeding provides a comprehensive look into the state of the object-oriented art. Based on the contributions to TOOLS 4, it covers every major aspect of the technology. As the major international forum devoted entirely to the practical applications of object-oriented technology, this guide reveals the latest practical developments in the hottest area in the software field. It describes industrial applications leading to actual products... results of increased practical experience with OO methods and tools (even from those still at the prototype stage)... and offers a deeper appreciation the problems involved. The Tools 4 meeting was held in Paris in March 1991.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Discovering classes and their properties in large-scale information systems\n", "abstract": " This paper discusses that part of an objectoriented method which addresses the techniques or\" mind-sets\" useful in conducting an analysis of any given problem domain, with particular consideration given to information systems. The method has been designed to be business-driven, minimise transformations during the software lifecycle, defer arbitrary distinctions between function and data, and provide an evolutionary step from data modelling/information engineering. Analysis is presented as an activity of discovering classes and their properties. The analytical techniques discussed have been drawn from a variety of already published material. Specifically, Responsibility-Driven Analysis is presented as the pivotal technique: its advantages and draw-backs are discussed from the view of analysing information systems. Further techniques are incorporated to compensate for the perceived weaknesses ofResponsibility-Driven Analysis.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Axiomatic semantics\n", "abstract": " The grammar of a theory may be expressed using standard techniques such as BNF or abstract syntax, both of which apply to metalanguages just as well as to languages. An example will illustrate the general form of a grammar. Consider a simple theory a v of natural integers. Its grammar might be defined by the following rules (based on ocabulary comprising letters, the digit 0 and the symbols=,<,==>,\u252c\u00bc and\u0393\u00c7\u00d6): 1\u0393\u00c7\u00f3 The formulae of the metalanguage are boolean expressions. 2\u0393\u00c7\u00f3 A boolean expression is of one of the four forms \u256c\u2592 \u256c\u2592= \u256c\u2593< \u256c\u2593 \u256c\u2502\u252c\u00bc \u256c\u2502==> \u256c\u2524 where \u256c\u2592 and \u256c\u2593 are integer expressions and \u256c\u2502 and \u256c\u2524 are boolean expressions. 3\u0393\u00c7\u00f3 An integer expression is of one of the three forms \u256c\u2592 n", "num_citations": "2\n", "authors": ["32"]}
{"title": "Les langages de specification\n", "abstract": " II. I. Introduction 11.2. Criteres d'evaluation des langages de specification 1I. 2. l. Aspect statiquejdynamique 11.2. 2. Niveau d'abstraction 11.2. 3. Generalite", "num_citations": "2\n", "authors": ["32"]}
{"title": "La Description des Structures de DonnCes\n", "abstract": " La necessite de separer, dans la description d'une structure de donnees, les proprietes abstraites des objets et leur representation concrete, est reconnue depuis longtemps sur Ie plan des idees. Dans [7], par exemple, d'Imperio faisait deja la distinction entre\" structures de donnees\" et~'structures de memoire\". En pratique, cependant, cette distinction reste souvent un voeu pieux, et la manipulation concrete des structures de donnees melange caracteristiques logiques et problemes de representation physique.II est souvent important, pourtant, de degager les proprietes\" intrinseques\" d'une structure de donnees des caracteristiques de sa representation. Dans un traite recent sur la conception et l'analyse des algorithmes [2], les\" files\"(queues) sont introduites initialement (\u252c\u00ba 2.1) par Ie biais d'une representation formee d'un tableau et de deux pointeurs. Or, Ie premier a] gorithme qui utilise des files (figure 3.1 de [2]) effectue l'operation\" concatenation de 2 files\" dont l'implementation efficace requiert une representation chainee (bien que l'utilisation d'une representation contigue ne change pas la complexite globale de l'algorithme en question, qui est Oe (m+ n) k)). II semble done qu'on doive utiliser une notion\" abstraite\" de file, preexistente a toute representation physique.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Spotting hidden contracts: the .NET example\n", "abstract": " Can libraries written without explicit support for Design by Contract in the language or the method benefit from a posteriori addition of contracts? To explore this question of design and programming methodology, we performed an empirical study of library classes from the .NET Collections library, which doesn\u0393\u00c7\u00d6t use Design by Contract, to search for unexpressed contracts. This article reports on the buried contracts we have found, assesses improvements that might result from making the contracts explicit, and discusses the feasibility of automating the contract elicitation process.", "num_citations": "2\n", "authors": ["32"]}
{"title": "Frontiers in Software Engineering Education\n", "abstract": " The First International Workshop on Frontiers in Software Engineering Education (FISEE 2019)(https://www. laser-foundation. org/fisee/fisee-2019/), held during November 11\u0393\u00c7\u00f413, 2019, at the Ch\u251c\u00f3teau de Villebrumier, France, builds on top of the experience gained with previous events run at the same place, for example DEVOPS 2018 and DEVOPS 2019. It aimed at bringing the attention to a topic of great importance and actuality for academia, namely education. The event happened before the global and massive move to online teaching, therefore the emphasis is more on \u0393\u00c7\u00a3classic\u0393\u00c7\u00a5 education, still there is mention of \u0393\u00c7\u00a3remote teaching.\u0393\u00c7\u00a5 It can be considered a compendium on best practices in the world pre 2020; a starting point to explore the ongoing changes happening right now, while we are writing. The event was kicked off by an outstanding introduction to the field by Professor Alexander Tormasov, Founding\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "In search of the shortest possible schedule\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmBertrand Meyer considers how to speed up software engineering.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Autoframe: automatic frame inference for object-oriented languages\n", "abstract": " Automatic program verification has made tremendous strides, but is not yet for the masses. How do we make it less painful? This article addresses one of the obstacles: the need to specify explicit \"frame clauses\", expressing what properties are left unchanged by an operation. It is fair enough to ask the would-be (human) prover to state what each operation changes, and how, but the (mechanical) prover also requires knowledge of what it does not change. The process of specifying and verifying these properties is tedious and error-prone, and must be repeated whenever the software evolves. it is also hard to justify, since all the information about what the code changes is in the code itself. The AutoFrame tool presented here performs this analysis entirely automatically. It applies to object-oriented programming, where the issue is compounded by aliasing: if x is aliased to y, any update to x.a also affects y.a, even though the updating instruction usually does not even mention y. This aspect turns out to be the most delicate, and is addressed in AutoFrame by taking advantage of a companion tool, AutoAlias, which performs sound and sufficiently precise alias analysis, also in an entirely automatic way. Some practical results of AutoFrame so far are: (1) the automatic reconstruction (in about 25 seconds on an ordinary laptop) of the exact frame clauses, a total of 169 clauses, for an 8,000-line data structures and algorithms library which was previously (with the manually written frame clauses) verified for functional correctness using a mechanical program prover; and (2) the automatic generation (in less than 4 minutes) of frame conditions for a 150,000\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "The costs and pleasures of a computer science teacher\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmMark Guzdial considers the enormous opportunity costs of computer science teachers, while Bertrand Meyer ponders the pleasures of arguing with graduate students.", "num_citations": "1\n", "authors": ["32"]}
{"title": "An automatic technique for static deadlock prevention\n", "abstract": " Deadlocks remain one of the biggest threats to concurrent programming. Usually, the best programmers can expect is dynamic deadlock detection, which is only a palliative. Object-oriented programs, with their rich reference structure and the resulting presence of aliasing, raise additional problems. The technique developed in this paper relies on the \u0393\u00c7\u00a3alias calculus\u0393\u00c7\u00a5 to offer a completely static and completely automatic analysis of concurrent object-oriented programs. The discussion illustrates the technique by applying it to two versions of the \u0393\u00c7\u00a3dining philosophers\u0393\u00c7\u00a5 program, of which it proves that the first is deadlock-free and the second deadlock-prone.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Teaching Software Engineering through Robotics\n", "abstract": " This paper presents a newly-developed robotics programming course and reports the initial results of software engineering education in robotics context. Robotics programming, as a multidisciplinary course, puts equal emphasis on software engineering and robotics. It teaches students proper software engineering -- in particular, modularity and documentation -- by having them implement four core robotics algorithms for an educational robot. To evaluate the effect of software engineering education in robotics context, we analyze pre- and post-class survey data and the four assignments our students completed for the course. The analysis suggests that the students acquired an understanding of software engineering techniques and principles.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Coordination Models and Languages\n", "abstract": " This volume contains the papers presented at COORDINATION 2014: the 16th IFIP WG 6.1 International Conference on Coordination Models and Languages held during June 3\u0393\u00c7\u00f44, 2014, in Berlin. The conference is the premier forum for publishing research results and experience reports on software technologies for collaboration and coordination in concurrent, distributed, and complex systems. Its distinctive feature is the emphasis on high-level abstractions that capture interaction patterns manifest at all levels of the software architecture and extending into the realm of the end-user domain. COORDINATION 2014 called for high-quality contributions on the usage, study, design, and implementation of languages, models, and techniques for coordination in distributed, concurrent, pervasive, and multicore software systems. The Program Committee (PC) of COORDINATION 2014 consisted of 26 top researchers from\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "Agile principles\n", "abstract": " Specific agile techniques all derive from a set of principles. Chapter 4, the longest in the book, is an in-depth exploration of agile principles, presenting the theoretical basis of agile ideas and the goals that agile methods seek to achieve.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Agile practices: managerial\n", "abstract": " From agile principles, agile methods derive specific practices: standardized activities that agile projects apply regularly and systematically. Chapter 6 covers management practices, including specific meetings held at predetermined stages in a project; other examples are the rules regarding code ownership and agile techniques of cost estimation.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Agile roles\n", "abstract": " One of the defining characteristics of agile methods is that they redefine the actors of software development and in particular reject the traditional role of project managers. Chapter 5 describes agile roles, explaining in particular how agile methods redistribute the tasks of the traditional manager among new actors in the project.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Certificates and separation logic\n", "abstract": " Modular and local reasoning about object-oriented programs has been widely studied for programing languages such as C# and Java. Once source programs have been proven, the next verification challenge is to ensure that the code produced by the compiler is correct. Since verifying a compiler can be extremely complex, this paper uses proof-transforming compilation, an alternative approach which automatically generates certificates, a bytecode proof, from proofs in the source language. The paper develops a bytecode logic using separation logic, and proof translation from proofs of object-oriented programs to bytecode. The translation also handles proofs for concurrent programs. The bytecode logic and the proof transformation are proven sound.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Applying search in an automatic contract-based testing tool\n", "abstract": " Automated random testing has been shown to be effective at finding faults in a variety of contexts and is deployed in several testing frameworks. AutoTest is one such framework, targeting programs written in Eiffel, an object-oriented language natively supporting executable pre- and postconditions; these respectively serving as test filters and test oracles. In this paper, we propose the integration of search-based techniques\u0393\u00c7\u00f6along the lines of Tracey\u0393\u00c7\u00f6to try and guide the tool towards input data that leads to violations of the postconditions present in the code; input data that random testing alone might miss, or take longer to find. Furthermore, we propose to minimise the performance impact of this extension by applying GPU programming to amenable parts of the computation.", "num_citations": "1\n", "authors": ["32"]}
{"title": "When reviews do more than sting\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmBertrand Meyer wonders why malicious reviews run rampant in computer science.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Programming languages and tools\n", "abstract": " Over the past four decades software tools have profoundly changed how people from all industries design their products, from cars to pharmaceutical drugs, newspapers, bridges and buildings \u0393\u00c7\u00f6 the list goes on. This is known as Computer-Aided Design (CAD, complemented by CAM, Computer-Aided Manufacturing). Software construction is design too; disproving the old saying about the cobbler\u0393\u00c7\u00d6s children, software engineers have developed CAD tools for themselves, from fairly simple programs such as text editors to entire tool suites known as integrated development environments or IDEs.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Can asynchronous exceptions expire?\n", "abstract": " A multitude of asynchronous exception mechanisms have been proposed. They specify where and when an asynchronous exception propagates. We highlight another aspect that has largely been overlooked: can an asynchronous exception expire? We discuss scenarios where it is meaningful for an asynchronous exception to expire. We further elaborate on one of the scenarios, thereby outlining an asynchronous exception mechanism for the SCOOP concurrency model.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Processors and their collection\n", "abstract": " In a flexible approach to concurrent computation, \u0393\u00c7\u00a3processors\u0393\u00c7\u00a5 \u0393\u00c7\u00d6 (computational resources such as threads) are allocated dynamically, just as objects are; but then, just as objects, they can become unused, leading to performance degradation or worse. We generalized the notion of garbage collection (GC), traditionally applied to objects, so that it also handles collecting unused processors.               The paper describes the processor collection problem, formalizes it as a set of fixpoint equations, introduces the resulting objects-and-processor GC algorithm implemented as part of concurrency support (the SCOOP model) in the latest version of EiffelStudio, and presents benchmarks results showing that the new technique introduces no overhead as compared to traditional objects-only GC, and in fact improves its execution time slightly in some cases.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Knowledgeable beginners\n", "abstract": " The Communications Web site, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmBertrand Meyer presents data on the computer and programming knowledge of two groups of novice CS students.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Freefinement\n", "abstract": " Freefinement is an algorithm that constructs a sound refinement calculus from a verification system under certain conditions. In this paper, a verification system is any formal system for establishing whether an inductively defined term, typically a program, satisfies a specification. Examples of verification systems include Hoare logics and type systems. Freefinement first extends the term language to include specification terms, and builds a verification system for the extended language that is a sound and conservative extension of the original system. The extended system is then transformed into a sound refinement calculus. The resulting refinement calculus can interoperate closely with the verification system - it is even possible to reuse and translate proofs between them. Freefinement gives a semantics to refinement at an abstract level: it associates each term of the extended language with a set of terms from the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "1 Synopsis\n", "abstract": " The Federal Office of Transportation wants to simulate changes to their traffic system. The Swiss government pays well, so this is a great opportunity for your small team of developers. You have to hand in a prototype that can successfully simulate a subset of the current traffic system.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Record-replay debugging for concurrent scoop programs\n", "abstract": " We report on the implementation of a record-replay tool for programs written in SCOOP, an object-oriented programming model for concurrency. The tool enables developers to reproduce the nondeterministic execution of a concurrent program, a necessary prerequisite for debugging and testing. The implementation is based on Choi and Srinivasan\u0393\u00c7\u00d6s approach of using logical thread schedules, which represent classes of physical schedules that are equivalent with respect to memory accesses.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Record-replay debugging for the SCOOP concurrency model\n", "abstract": " To support developers in writing reliable and efficient concurrent programs, novel concurrent programming abstractions have been proposed in recent years. Programming with such abstractions requires new analysis tools because the execution semantics often differs considerably from established models. We present a record-replay technique for programs written in SCOOP, an object-oriented programming model for concurrency. The resulting tool enables developers to reproduce the nondeterministic execution of a concurrent program, a necessary prerequisite for debugging and testing.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Concurrency Made Easy\n", "abstract": " It includes both the Extended Synopsis (pages 5 to 9) and the full scientific proposal (pages 10 to 25). The 5-page description of the Principal Investigator\u0393\u00c7\u00d6s background (CV, awards etc.) has been removed, as well as the detailed budget table. The contribution of Sebastian Nanz to the preparation of the project is gratefully acknowledged, as well as the help of Carlo Furia and Claudia G\u251c\u255dnthart.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Objects, components, models and patterns\n", "abstract": " The TOOLS conference series started in 1989 and, over the following 15 years, held 45 sessions: TOOLS EUROPE, TOOLS USA, TOOLS PACIFIC, TOOLS CHINA and TOOLS EASTERN EUROPE. TOOLS played a major role in the spread of object-oriented and component technologies; many seminal software concepts now taken for granted were first discussed at TOOLS, taking advantage of the informal, application-oriented, technically intense and marketing-free atmosphere of the conference. Invited speakers have included countless luminaries of science and industry.After an interruption of four years, TOOLS started again in June 2007, hosted by ETH Zurich with great success. TOOLS has broadened its scope beyond the original topics of object technology and component-based development to encompass all modern, practical approaches to software development. In doing so, it kept with the traditional\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "Student diversity in CS1\n", "abstract": " Student diversity in CS1 Page 1 Chair of Software Engineering Student diversity in CS1 ECSS Paris October 2009 ECSS, Paris, October 2009 Michela Pedroni Bertrand Meyer (ETH) y ( ) Manuel Oriol (University of York, UK) Page 2 Context Introduction to Programming course at ETH Zurich Since 2003 2 Page 3 Motivation To \u0393\u00c7\u00a3know your audience\u0393\u00c7\u00a5 is one of the fundamental rules of y mass communication In introductory programming courses: ypg g high diversity of prior knowledge 3 Page 4 Study setup Questionnaire on computing and programming knowledge \u0393\u20a7\u00f3 Computer literacy p y \u0393\u20a7\u00f3 Programming experience \u0393\u20a7\u00f3 Programming languages g g gg Participants of ETH Changes over years? p f \u0393\u20a7\u00f3 Beginning of Introduction to Programming 2003-2008 \u0393\u20a7\u00f3 On paper (2003), later online On paper ( 003), later onl ne \u0393\u20a7\u00f3 Answers from 753 of 1130 CS students Participants of University of York \u0393\u20a7\u00f3 2008 only \u0393\u20a7\u00f3 Online Differences ? : \u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "An introduction to Java (from material by Marco Piccioni)\n", "abstract": " Java was introduced in 1995, the result of an internal research project at Sun Microsystems led by James Gosling (other key contributors include Bill Joy, Guy Steele and Gilad Bracha). The language came at just the right time to benefit from two separate phenomena:\u0393\u00c7\u00f3 Widespread dissatisfaction, after initial enthusiasm for object technology in the late eighties, with the C++ language (see appendix C), particularly its complexity and the limits of its \u0393\u00c7\u00a3hybrid\u0393\u00c7\u00a5 approach retaining compatibility with the non-object-oriented C language.\u0393\u00c7\u00f3 The spread of Internet access and the advent of the World-Wide Web, which seemed to call for a universal mechanism to execute programs securely from within browsers.The Java project, initially intended for \u0393\u00c7\u00a3set-top boxes\u0393\u00c7\u00a5 and network appliances, was ready to support such programs, called applets. As noted in an earlier chapter, applets never became the dominant computing model as\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "An introduction to C++ (from material by Nadia Polikarpova)\n", "abstract": " Today the idea of using an object-oriented language hardly scares anyone, but in the late eighties it was sulfurous; many programmers and managers in industry and academia, while intuitively attracted by OO concepts, were suspicious of their applicability. From 1979 on Bjarne Stroustrup, then of Bell Laboratories, designed and implemented a language initially called \u0393\u00c7\u00a3C with classes\u0393\u00c7\u00a5, which extended C with concepts imitated from Simula 67, the first object-oriented language; code was translated into plain C through a \u0393\u00c7\u00a3preprocessor\u0393\u00c7\u00a5. The language soon proved a hit, as it promised a reassuring transition path for C programmers.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Embedding proof-carrying components into Isabelle\n", "abstract": " The execution of mobile code can produce unexpected behaviour which may compromise security and correctness of a software system. Proof-Carrying Components are a way to overcome this problem. Proof-Carrying Components carry a mathematical proof showing that the component satisfies certain properties, known as the contract of the component. A code consumer can check the mathematical proof attached to the component before executing the mobile code. In this way, the consumer can make sure in advance that the mobile code will be executed in a safe way.Proof-Carrying Components can be automatically generated using Proof-Transforming Compilers. Proof-Transforming Compilers are compilers that take a source proof with contracts as input and produce a bytecode proof and its contract as output. An important property of Proof-Transforming Compilers is that they do not have to be trusted. If a Proof-Transforming Compiler produces a wrong specification or a wrong proof for a component, the proof checker of the code consumer will reject the component. In this Master thesis, we show how a bytecode proof produced as output of a Proof-Transforming Compiler can be embedded in a theorem prover. We have embedded the Proof-Carrying Components into Isabelle, using shallow embedding for the component contracts and a deep embedding for the bytecode instructions. To show that a component satisfies its contract, the generator produces a proof script. We have optimized this proof script and the measurements show that proofs are checked at least twice as fast compared to the non-optimized proof script. The embedding has\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "Eiffel Vision for Mac OS X\n", "abstract": " EiffelVision is an object-oriented framework for graphical user interface development, originally created by Eiffel Software. Although generally designed to be platform independent, there is currently no native version for Mac OS X. While the GTK+/X11 based version (used on Linux) works on Mac OS X as well it has many problems which cannot be overcome with the current architecture. For this reason we developed an implementation of EiffelVision which is based on Cocoa-the native graphics framework of Mac OS X. The development of this implementation also led to an Eiffel based Cocoa framework which can be used to write native applications on Mac OS X and inspired the development of an iPhone library for Eiffel.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Integrating SCOOP into EVE\n", "abstract": " SCOOP (Simple Concurrent Object-Oriented Programming) is a simple but very powerful OO contract based framework for concurrent programming. The idea which was initially published in 1990 has since been developed to a comprehensive model with enriched type system, generalized semantics of contracts, flexible locking policy and library implementation.To use SCOOP one important step is missing: The integration in Eiffel\u0393\u00c7\u00f4which defines the scope of the presented work. In this master thesis we integrate SCOOP into EVE\u0393\u00c7\u00f4a research branch of EiffelStudio. The goal is to get SCOOP code compiled in EVE like any other Eiffel program. To achieve this goal, we change the parser, perform a AST to AST transformation and integrate the whole SCOOP compilation into the existing EVE compiler.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Panel: Programming Language Paradigms: Past, Present, and Future\n", "abstract": " Panel: Programming Language Paradigms: Past, Present, and Future | Proceedings of the third ACM SIGPLAN conference on History of programming languages ACM Digital Library Logo ACM Logo Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search hopl Conference Proceedings Upcoming Events Authors Affiliations Award Winners More HomeConferencesHOPLProceedingsHOPL IIIPanel: Programming Language Paradigms: Past, Present, and Future ARTICLE Panel: Programming Language Paradigms: Past, Present, and Future Share on Authors: Kathleen Fisher profile image Kathleen Fisher AT&T Labs - Research AT&T Labs - Research View Profile , Bertrand Meyer profile image Bertrand Meyer ETH Zurich ETH Zurich View Profile , Olin , \u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "Complete contracts for EiffelBase\n", "abstract": " Formal verification of programs is a very important topic. But on the other hand it is rather difficult to be able to verify a program if only the source code is given. Using Eiffel, not only the code itself can be used but also contracts. Each feature has preconditions and postconditions which can be used to enhance and simplify the verification process. But unfortunately the contracts currently used in Eiffel are under-specifications in the sense that there are always some properties when invoking Eiffel features that are not expressed through its contracts. To be able to write complete contracts, Dynamic Frame Contracts are added for each feature and Models are used to enhance existing contracts.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Tests and Proofs First International Conference, TAP 2007, Zurich, Switzerland, February 12-13, 2007. Revised Papers\n", "abstract": " The 12 revised full papers presented were carefully reviewed and selected for inclusion in the book. The papers are devoted to the convergence of software proofing and testing and feature current research work that combines ideas from both sides to foster software quality. Topics addressed are generation of test cases or oracles by theorem proving, constraint logic programming, model checking, or symbolic execution; program proving with the aid of testing techniques; automatic tools; case studies; formal frameworks; as well as verification techniques combining proofs and tests.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Software engineering for Outsourcing and Offshoring\n", "abstract": " US state adopts anti-BPO bill(source: Rediff) The state of Kansas has adopted a bill seeking to bar outsourcing telephone enquiries about its food stamp program to India and other countries. The Department of Social and Rehabilitation Services signed a contract with eFunds Corp in September 2002 to handle food stamp benefits and take clients' calls. In its 2003 annual report, eFunds said it has two customer call centers in India and that about 3,100 of its 5,400 employees are outside the United States. Outsourcing became an issue in the legislature when it was revealed that Kansas' calls about food stamps were answered by workers not in Kansas but in India.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Doing more with contracts: towards automatic tests and proofs\n", "abstract": " Equipping software with contracts, especially in the case of library components, opens up a whole range of applications. I will describe two of them, part of current work in the chair of software engineering at ETH. The first is automatic, \u0393\u00c7\u00a3push-button\u0393\u00c7\u00a5 testing of contract-equipped components. The second is mathematical proof that such components satisfy their contracts. In both cases the effort is made more interesting by the existence of library versions that are fully contracted\u0393\u00c7\u00a5 thanks to the use of model classes based on set-theoretical concepts. Both the tests and the proofs apply to actual libraries as used in practical software development.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Touch of class: Teaching introductory programming outside-in\n", "abstract": " Touch of class: Teaching introductory programming outside-in - Dialnet Ir al contenido Dialnet Buscar Revistas Tesis Congresos Ayuda Touch of class: Teaching introductory programming outside-in Autores: Bertrand Meyer Localizaci\u251c\u2502n: JENUI 2004: X Jornadas de Ense\u251c\u2592anza Universitaria de la Inform\u251c\u00edtica. Alicante del 14 al 16 de julio de 2004, 2004, ISBN 84-9732-334-3, p\u251c\u00edgs. 5-10 Idioma: ingl\u251c\u2310s Fundaci\u251c\u2502n Dialnet Acceso de usuarios registrados Imagen de identificaci\u251c\u2502n Identificarse \u252c\u2510Es nuevo? Reg\u251c\u00a1strese Mi Dialnet Ventajas de registrarse Dialnet Plus M\u251c\u00eds informaci\u251c\u2502n sobre Dialnet Plus Opciones de compartir Facebook Twitter Opciones de entorno Sugerencia / Errata \u252c\u2310 2001-2020 Fundaci\u251c\u2502n Dialnet \u252c\u2556 Todos los derechos reservados Dialnet Plus Accesibilidad Aviso Legal Coordinado por: Fundaci\u251c\u2502n Dialnet Inicio Buscar Revistas Tesis Congresos Ayuda Registrarse Universidad de La Rioja \u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "From Patterns to Components: The Factory Library Example\n", "abstract": " Can design patterns be turned into reusable components using some advanced programming language mechanisms? We reviewed all patterns described in the book by Gamma et al.[Gamma 1995] and built a new classification of these patterns by level of \u0393\u00c7\u00a3componentizability\u0393\u00c7\u00a5(possibility to turn the pattern into a component). This article first describes our \u0393\u00c7\u00a3componentization\u0393\u00c7\u00a5 approach and the pattern classification we obtained [Arnout 2004b]. Then, it focuses on one \u0393\u00c7\u00a3componentizable\u0393\u00c7\u00a5 pattern, Abstract Factory, and explains how we devised the corresponding Factory Library in Eiffel. Finally, it describes the limitations of the approach and presents related works, before giving some future research directions.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Trusted Components\n", "abstract": " \u0393\u00c7\u00a3Thus spoke the master:\u0393\u00c7\u00a3Any program, no matter how small, contains bugs.\u0393\u00c7\u00a5 The novice did not believe the master\u0393\u00c7\u00d6s words.\u0393\u00c7\u00a3What if the program were so small that it performed a single function?\u0393\u00c7\u00a5 he asked.\u0393\u00c7\u00a3Such a program would have no meaning,\u0393\u00c7\u00a5 said the master,\u0393\u00c7\u00a3but if such a one existed, the operating system would fail eventually, producing a bug.\u0393\u00c7\u00a5 But the novice was not satisfied.\u0393\u00c7\u00a3What if the operating system did not fail?\u0393\u00c7\u00a5 he asked.", "num_citations": "1\n", "authors": ["32"]}
{"title": "A model-view-controller approach to object persistence\n", "abstract": " The model-view-controller framework (MVC) is discussed to some extent, first within the context of a user interface to a business model. After a new, generic definition of object persistence is presented, it is shown that the concept of persistence, according to that definition, can also be fitted within a model-view-controller scheme. That will lead to a unified MVC concept, which can easily be further generalized to other related issues, such as interprocess communication and other forms of communications with the outside world. SCOOP (Scalable Object Oriented Persistence), a set of C++ classes which support object persistence, is presented. It is shown how it offers a seamless migration path from more traditional to fall blown object-oriented database systems. The position of SCOOP within the MVC architecture is discussed.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Eiffel: Version 3 and beyond\n", "abstract": " With version 3 of ISE\u0393\u00c7\u00d6s Eiffel implementation the various components of the Eiffel approach\u0393\u00c7\u00f6method, language, environments, libraries\u0393\u00c7\u00f6have been put together. This presentation will introduce the components of the brand new implementation, emphasizing the more novel tools, the support for object-oriented analysis and design, and the mechanisms allowing database access, graphics, and user interface construction.", "num_citations": "1\n", "authors": ["32"]}
{"title": "To object-oriented design: the road to Eiffel\n", "abstract": " \u0393\u00c7\u00ffStructured programming\u0393\u00c7\u00d6\u0393\u00c7\u00d6has two meanings. One refers to a movement of ideas which approximately e fi spanned the decade starting in 1968, a year notable both for Dijkstra\u0393\u00c7\u00d6s anti-goto letter [12] and for th rst software engineering symposium [8]. The other denotes an enduring view of software construction as a valuable scientific pursuit.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Object-Oriented Software Construction, Interactive Software Engineering\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Object-Oriented Software Construction, Interactive Software Engineering CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab \u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c0\u00fc\u00ab\u03c0\u00e9\u2561\u03c0\u00e2\u255d\u03c0\u00e2\u00f4\u03c0\u00e9\u2563\u03c0\u00fc\u00bd\u0398\u00fb\u00f3\u03c0\u00fc\u00d6\u03c0\u00e9\u00ef\u03c0\u00e9\u00f3\u03c0\u00e2\u2502\u03c0\u00e9\u2592\u03c0\u00e2\u255d\u03c0\u00e2\u00ea\u03c0\u00e9\u00c6\u03c3\u00ab\u0192\u00b5\u00fb\u255c\u03a3\u2555\u00a1\u03c0\u00fc\u00ba\u03c0\u00fc\u00d6\u2229\u255d\u00ea11/11(\u00b5\u2591\u2524)-12/23(\u00b5\u2591\u2524)\u2229\u255d\u00eb Object-Oriented Software Construction, Interactive Software Engineering MEYER B. \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 MEYER B. \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 1988 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u03c0\u00e2\u00f2\u03c0\u00e2\u00a1\u03c0\u00e2\u255d\u03c0\u00e2\u00f3\u03c0\u00e2\u00e7\u03c0\u00e2\u00bd\u03c0\u00fc\u00bd\u03c3\u0192\u2551\u03c0\u00fc\u00d1\u03c0\u00fc\u00c5\u03a6\u2562\u00e0\u03a3\u2555\u00aa\u03c3\u00ea\u00f9 V\u03a6\u00bf\u00c7\u03a6\u00ac\u20a7\u03c0\u00fc\u00bf\u03c0\u00fc\u00a5\u03c0\u00fc\u00ab\u03c3\u00f2\u00e5\u03c4\u00f6\u00bf\u03a3\u2555\u00aa\u03c3\u00ea\u00f9\u03a6\u00bf\u00ea\u03c4\u00ab\u00f9\u00b5\u2310\u0192\u03a3\u2555\u00e8\u03c0\u00fc\u00ab\u03c3\u00ab\u0192\u03a6\u00fa\u00e0\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa \u00b5\u00f9\u00d1\u03a3\u2555\u00ef\u0398\u00e2\u00bf \u03a6\u00ee\u00e9 , \u0398\u00bd\u00ff\u00b5\u2310\u00ef \u03a6\u00ef\u2592\u03a3\u2555\u00c7 , \u03a6\u2591\u2556\u03c3\u00c5\u00fa \u03c3\u00c7\u00bd\u03a3\u2555\u00c7\u0398\u00e2\u00c4 , \u0398\u00a2\u00bf\u03c3\u00ab\u00ab \u03c4\u00a3\u0192\u03a3\u2551\u2551 \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00e7\u00aa\u03c4\u00c9\u00e5\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03a6\u00ac\u00ee 36(7), 1529-1541, 1995-07-15 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab25\u03a3\u2557\u2562 CiNii\u03c3\u00ea\u2310\u03c4\u00f6\u00bf\u03a6\u00c7\u00e0\u03c0\u00e9\u00f3\u03c0\u00e2\u2502\u03c0\u00e9\u2592\u03c0\u00e2\u255d\u03c0\u00e2\u00ea Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 10000004237 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03c0\u00fc\u00a5\u03c0\u00fc\u00ab\u03a3\u2557\u00fb \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 /(\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "Landscaping for Programming Environments\n", "abstract": " During the plenary talk by one of us, 1 the word\" landscaping\" was substituted for\" architecture.\" While roughly synonymous, we felt that\" landscaping\" gave a better feel for the unknown realm of foundations for environments, and also better conveyed a sense of how programming environments must largely make do with the existing lay of the land (ie, underlying operating system and hardware). As the workshop developed, both terms came to be used synonymously, and so they will be here.The remainder of this introductory section summarizes chronologically the structure of the panel. We laid out a plan on Day 1, and largely followed it through to Day 4. The following section summarizes the results of our discussions, and the final section discusses the issues we identified with respect to several specific architectures.", "num_citations": "1\n", "authors": ["32"]}
{"title": "An application of program transformation to supercomputer programming\n", "abstract": " We show how a sequence of systematic program transformations can be used to derive an efficient, vectorizable program (to be used on vector computers such as the Cray machines) from an initial version which is mathematically simple but recursive and very inefficient.The example chosen is that of cyclic reduction. We start with a description of the algorithm which follows directly from a mathematical analysis of the problem and is expressed in terms of operations of the \u0393\u00c7\u00a3vector machine\u0393\u00c7\u00a5, specified as an abstract data type; we end up with an Ada package.We discuss the advantages and limitations of Ada with respect to vector programming and raise some issues concerning the use of program transformations in software design methodology.", "num_citations": "1\n", "authors": ["32"]}
{"title": "C\u251c\u2310page: Un \u251c\u2310diteur structurel pleine page\n", "abstract": " Nous decrivons Cepage, un editeur de documents structures coneu pour etre d'emploi agreable sur les terminaux actuels. Cepage se trouve au confluent des travaux sur les editeurs synta: lCiques, du developpement des editeurs pleine page, et des etudes sur les environnements logiciels avances. C'est un editeur universel, dans lequella description du langage est un simple parametre; son interface externe est faite pour les enfants de l'~ re video. Cepage constitue un prototype de ce que pourrait etre un editeur structurel utilisable dans un environnement industriel.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Some mistakes are worse than others: an open letter to professor David Gries\n", "abstract": " Remembering that in a sorted array a plateau is simply given by equalit y of its end elements, the first line (E...) clearly means that there is a plateau of length p (starting at position k, for some k in the allowabl e range) in the array; and the second line clearly means that there is no plateau of length p+ l (starting at position k, for any k in the allowabl e range).... Or do they really mean this? Let us look carefully at the ranges fo r k. The remark following this predicate in your text indeed prompts us to check them carefully:\" The only difficulty in writing (16.3. 9) might have been in getting k's bounds right\". Indeed it might: Simple arithmetic shows that a p lateau of length p in bA0: n-1] may have as its starting position an index k in the range 0: np; a plateau of length p+ l will start at some k in the rang e 0: npl. Thus two (signs should be replaced by 5 in (16. 3. 9), which shoul d read:", "num_citations": "1\n", "authors": ["32"]}
{"title": "A low cost satellite for fast interactive graphics in a time-sharing environment\n", "abstract": " This paper describes a system that improves the performance of a time-shared host computer for users of TEKTRONIX series 4010/4014/4015 graphics terminals. The system consists of a mini or microcomputer situated at the terminal, a program that runs in the satellite computer and a library of FORTRAN callable subroutines that provide a convenient interface between an application program in the host computer and the program in the satellite computer. The system ensures that the satellite has advance information about the expected dialogue, so that the satellite is able to react instantly to input from the user, even if the response of the host computer is slow. The satellite gathers several trivial inputs together and sends them to the host in a burst. This allows the program in the host to process more information each time it is rolled into memory, hence the efficiency of its operation is improved. The satellite also\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["32"]}
{"title": "A note on computing multiple sums\n", "abstract": " In a recent paper, a method was given for computing multidimensional sums in FORTRAN in a particular case. We show that the general problem of computing multidimensional sums is best expressed by a recursive definition which can then be translated into a programming language. The method is applied to an example optimization problem.", "num_citations": "1\n", "authors": ["32"]}
{"title": "Eiffel vs C+\n", "abstract": " Since we often get the question of Eiffel versus C++, Mr. Geary's initiative provides a welcome opportunity to clarify what I see as the major differences. I am the main designer of Eiffel, so the following discussion cannot claim to be that of an independent observer, although it is certainly honest, and technically correct to the best of my knowledge. In all likelihood, others will contribute different viewpoints.", "num_citations": "1\n", "authors": ["32"]}
{"title": "The Eiffel Object-Oriented Parsing Library\n", "abstract": " This bias towards high level frameworks for small or fairly homogeneous applications is largely due to deficiencies in the early designs of object-oriented languages; Naive implementations of inheritance involved inefficient lookup tables for dynamic binding which rendered extensive use of inheritance at a low level impractical, and the artificial restriction to inheritance from a single parent precluded intricate use of inheritance in high level design.The availability of multiple inheritance object systems with efficient message passing mechanisms has changed the outlook of objectoriented programmers. Inheritance structures of great complexity can be built with no effect on the efficiency of the message passing, and systems built using nlultiplc inheritance, lrc much more flexible than the\\I hicrarchicst", "num_citations": "1\n", "authors": ["32"]}