{"title": "Implementing distribution and persistence aspects with AspectJ\n", "abstract": " This paper reports our experience using AspectJ, a general-purpose aspect-oriented extension to Java, to implement distribution and persistence aspects in a web-based information system. This system was originally implemented in Java and restructured with AspectJ. Our main contribution is to show that AspectJ is useful for implementing several persistence and distribution concerns in the application considered, and other similar applications. We have also identified a few drawbacks in the language and suggest some minor modifications that could significantly improve similar implementations. Despite the drawbacks, we argue that the AspectJ implementation is superior to the pure Java implementation. Some of the aspects implemented in our experiment are abstract and constitute a simple aspect framework. The other aspects are application specific but we suggest that different implementations might follow\u00a0\u2026", "num_citations": "432\n", "authors": ["1295"]}
{"title": "Six years of systematic literature reviews in software engineering: An updated tertiary study\n", "abstract": " ContextSince the introduction of evidence-based software engineering in 2004, systematic literature review (SLR) has been increasingly used as a method for conducting secondary studies in software engineering. Two tertiary studies, published in 2009 and 2010, identified and analysed 54 SLRs published in journals and conferences in the period between 1st January 2004 and 30th June 2008.ObjectiveIn this article, our goal was to extend and update the two previous tertiary studies to cover the period between 1st July 2008 and 31st December 2009. We analysed the quality, coverage of software engineering topics, and potential impact of published SLRs for education and practice.MethodWe performed automatic and manual searches for SLRs published in journals and conference proceedings, analysed the relevant studies, and compared and integrated our findings with the two previous tertiary studies\u00a0\u2026", "num_citations": "199\n", "authors": ["1295"]}
{"title": "Distribution and persistence as aspects\n", "abstract": " This paper reports our experience using AspectJ, a general\u2010purpose aspect\u2010oriented extension to Java, to implement distribution and persistence concerns in a Web\u2010based information system. This system was originally implemented in Java and restructured with AspectJ. Our main contribution is to show that AspectJ is useful for implementing several persistence and distribution concerns in the considered application, but also in similar applications. We have also identified interferences between the implemented aspects and a few drawbacks in the language, so we suggest some minor language modifications that could significantly improve similar implementations. Despite those problems, we argue that the AspectJ implementation is superior to the pure Java implementation. Some of the aspects implemented in our experiment are abstract and constitute a simple aspect framework. The other aspects are\u00a0\u2026", "num_citations": "115\n", "authors": ["1295"]}
{"title": "An aspect-oriented implementation method\n", "abstract": " Aspect-oriented development Aspect-oriented refactoring Page 1 An Aspect-Oriented Implementation Method Persistence aspects framework Distribution aspects framework Concurrency control aspects framework S\u00e9rgio Soares and Paulo Borba Software Productivity Group Informatics Center - Federal University of Pernambuco - Brazil {scbs,phmb}@cin.ufpe.br http://www.cin.ufpe.br/spg Functional requirements Concurrency control Non-persistent data management User interface Persistent data management Distribution Milestone (end of iteration) a and b are use-cases or sets of use-cases Aspect-oriented development Aspect-oriented refactoring Software architecture Timestamp <<Aspect>> TimestampedObject PessimisticSynchronization <<Aspect>> ConcurrencyManager OptimisticSynchronization <<Aspect>> Synchronization <<Aspect>> ClientSide <<Aspect>> ServerSide <<Aspect>> Remote (from java.rmi) \u2026", "num_citations": "44\n", "authors": ["1295"]}
{"title": "Hybrid morphological methodology for software development cost estimation\n", "abstract": " In this paper we propose a hybrid methodology to design morphological-rank-linear (MRL) perceptrons in the problem of software development cost estimation (SDCE). In this methodology, we use a modified genetic algorithm (MGA) to optimize the parameters of the MRL perceptron, as well as to select an optimal input feature subset of the used databases, aiming at a higher accuracy level for SDCE problems. Besides, for each individual of MGA, a gradient steepest descent method is used to further improve the MRL perceptron parameters supplied by MGA. Finally, we conduct an experimental analysis with the proposed methodology using six well-known benchmark databases of software projects, where two relevant performance metrics and a fitness function are used to assess the performance of the proposed methodology, which is compared to classical machine learning models presented in the literature.", "num_citations": "43\n", "authors": ["1295"]}
{"title": "Implementing java modeling language contracts with aspectj\n", "abstract": " The Java Modeling Language (JML) is a behavioral interface specification language (BISL) designed for Java. It was developed to improve functional software correctness of Java applications. However, instrumented object program generated by the JML compiler use the Java reflection mechanism and data structures not supported by Java ME applications. To deal with this limitation, we propose the use of AspectJ to implement a new JML compiler, which generates an instrumented bytecode compliant with both Java SE and Java ME applications. The paper includes a comparative study to demonstrate the quality of the final code generated by our compiler. The size of the code is compared against the code generated by an existent JML compiler. Moreover, we evaluate the amount of additional code required to implement the JML assertions in Java applications. Results indicate that the overhead in code size\u00a0\u2026", "num_citations": "40\n", "authors": ["1295"]}
{"title": "A critical appraisal of systematic reviews in software engineering from the perspective of the research questions asked in the reviews\n", "abstract": " After a seminal article introducing-evidence based software engineering in 2004, systematic reviews (SR) have been increasingly used as a method for conducting secondary studies in software engineering. Our goal is to critically appraise the use of SR in software engineering with respect to the research questions asked and the ways the questions were used in the reviews. We analyzed 53 literature reviews that had been collected in two published tertiary studies. We found that over 65% of the research questions asked in the reviews were exploratory and only 15% investigated causality questions. We concluded that there is a need for a consistent use of terminology to classify secondary studies and that reports of literature reviews should follow reporting guidelines to support assessment and comparison.", "num_citations": "39\n", "authors": ["1295"]}
{"title": "A shift-invariant morphological system for software development cost estimation\n", "abstract": " This work presents a shift-invariant morphological system to solve the problem of software development cost estimation (SDCE). It consists of a hybrid morphological model, which is a linear combination between a morphological-rank (MR) operator (nonlinear) and a Finite Impulse Response (FIR) operator (linear), referred to as morphological-rank-linear (MRL) filter. A gradient steepest descent method to adjust the MRL filter parameters (learning process), using the Least Mean Squares (LMS) algorithm, and a systematic approach to overcome the problem of non-differentiability of the morphological-rank operator are used to improve the numerical robustness of the training algorithm. Furthermore, an experimental analysis is conducted with the proposed system using the NASA software project database, and in the experiments, two relevant performance metrics and an evaluation function are used to assess its\u00a0\u2026", "num_citations": "37\n", "authors": ["1295"]}
{"title": "An evolutionary morphological approach for software development cost estimation\n", "abstract": " In this work we present an evolutionary morphological approach to solve the software development cost estimation (SDCE) problem. The proposed approach consists of a hybrid artificial neuron based on framework of mathematical morphology (MM) with algebraic foundations in the complete lattice theory (CLT), referred to as dilation-erosion perceptron (DEP). Also, we present an evolutionary learning process, called DEP(MGA), using a modified genetic algorithm (MGA) to design the DEP model, because a drawback arises from the gradient estimation of morphological operators in the classical learning process of the DEP, since they are not differentiable in the usual way. Furthermore, an experimental analysis is conducted with the proposed model using five complex SDCE problems and three well-known performance metrics, demonstrating good performance of the DEP model to solve SDCE problems.", "num_citations": "33\n", "authors": ["1295"]}
{"title": "PaDA: A pattern for distribution aspects\n", "abstract": " This paper presents a pattern that provides a structure for implementing distribution using AOP\u2014aspect-oriented programming. The main goal is to achieve better separation of concerns avoiding tangled code (code with different concerns interlacing to each other) and spread code (code regarding one concern scattered in several units of the system). Therefore, system modularity, and hence, maintainability and extensibility are increased. The paper also presents an example of distribution aspects using AspectJ, an aspect-oriented extension to Java.", "num_citations": "33\n", "authors": ["1295"]}
{"title": "Assessing intra-application exception handling reuse with aspects\n", "abstract": " Recent studies have attempted to evaluate the benefits and drawbacks of using aspect-oriented programming to modularize exception handling code. In spite of their many interesting findings, these studies have not reached a consensus when it comes to the impact of aspectization on exception handler reuse. In fact, their results are sometimes in direct contradiction.In this paper we describe a study aiming to answer the question of whether AOP really promotes the implementation of reusable exception handling. We analyze reuse in a specific context: in terms of the number of duplicated or very similar error handlers that can be removed from a program when extracting error handling code to aspects. Our study targets three industrial-strength, medium-size software systems from different domains and employs a comprehensive set of concern-specific metrics.", "num_citations": "31\n", "authors": ["1295"]}
{"title": "A systematic mapping study on software engineering testbeds\n", "abstract": " Even though empirical research has grown in interest, techniques, methodologies and best practices are still in debate. In this context, test beds are effective when one needs to evaluate and compare technologies. The concept is well disseminated in other areas such as Computer Networks, but remains poorly explored in Software Engineering (SE). This paper presents a systematic mapping study on the SE test beds literature. From the initial set of 4239 studies, 13 primary studies were selected and categorized. Based on that, we found that Software Architecture is the most investigated topic, controlled experiment is the most used method to evaluate such test beds, 20 benefits of using test beds in SE have been identified and that test beds comprise very heterogeneous structural elements.", "num_citations": "30\n", "authors": ["1295"]}
{"title": "Towards a catalog of object-oriented software maintainability metrics\n", "abstract": " A high number of metrics have been used to measure Object-Oriented Software Maintainability (OOSM). However, there is no comprehensive and useful catalog showing which metrics are more appropriated for adoption in OOSM assessment in both, academic and industrial environments. In a previous work we performed a systematic mapping study to identify maintainability metrics resulting in 570 OOSM metrics found. We classified those metrics in 15 domain categories to help us on the catalog building process. This categorization will be the basement of our inclusion/exclusion criteria when we select which metrics will compose a catalog. Using the proposed categorization we believe that we can select the most relevant and/or popular OOSM metrics. In this position paper we discuss a range of options of OOSM metrics categorization, making the OOSM metrics catalog building process accurate and reliable\u00a0\u2026", "num_citations": "21\n", "authors": ["1295"]}
{"title": "A quantum-inspired hybrid methodology for financial time series prediction\n", "abstract": " In this work a quantum-inspired hybrid methodology is proposed to overcome the random walk dilemma for financial time series prediction. It consists of a hybrid model composed of a Qubit Multilayer Perceptron (QuMLP) with a Quantum-Inspired Evolutionary Algorithm (QIEA), which searches for the best particular time lags able to characterize the time series phenomenon, as well as to evolve the complete QuMLP architecture and parameters. Each individual of the QIEA population is adjusted by the Complex Back-Propagation (CBP) algorithm to further improve the QuMLP parameters supplied by the QIEA. After the prediction model search procedure, it uses a behavioral statistical test and a phase fix procedure to adjust time phase distortions that appear in financial time series. An experimental analysis is conducted with the proposed methodology through four real world financial time series, and the obtained\u00a0\u2026", "num_citations": "20\n", "authors": ["1295"]}
{"title": "On the benefits of quantification in AspectJ systems\n", "abstract": " In this paper, we argue that the most favorable uses of aspects happen when their code relies extensively on quantified statements, i.e.,\u00a0statements that may affect many parts of a system. When this happens, aspects better contribute to separation of concerns, since the otherwise duplicated and tangled code related to the implementation of a crosscutting concern is confined in a single block of code. We provide in the paper both qualitative and quantitative arguments in favor of quantification. We also propose two new metrics to capture in a simple way the amount of quantification employed in the aspects of a given system. Finally, we describe an Eclipse plugin, called ConcernMetrics that estimates the proposed metrics directly from the object-oriented code of an existing system, i.e.,\u00a0before crosscutting concerns are extracted to aspects. Our main motivation is to help developers and maintainers to decide in a cost-effective way if it is worthwhile to use aspects in their systems.", "num_citations": "19\n", "authors": ["1295"]}
{"title": "AspectJ-Programa\u00e7ao orientada a aspectos em Java\n", "abstract": " This document presents a tutorial about AspectJ, an aspect-oriented extension to Java. Aspect-oriented programming (AOP) tries to solve some inefficiency of object-orientation, such as tangled code and code spread over several units, making harder software development and maintainability. AOP increases system modularity by separating code that implements specific functions, affecting different parts of the system, called crosscutting concerns. We present the main constructions of AspectJ, as well as examples of aspects to assist the assimilation of the concepts. We also discuss using design patterns to implement some features of AspectJ, and its benefits and liabilities.Resumo. Este documento apresenta um tutorial sobre AspectJ, uma extensao orientada a aspectos de Java. Programa\u00e7ao orientada a aspectos (AOP) procura solucionar algumas inefici\u00eancias da orienta\u00e7ao a objetos, como o entrela\u00e7amento e espalhamento de c\u00f3digo com diferentes prop\u00f3sitos. Este entrela\u00e7amento e espalhamento tornam o desenvolvimento e a manuten\u00e7ao destes sistemas extremamente dif\u0131cil. AOP aumenta a modularidade separando c\u00f3digo que implementa fun\u00e7oes espec\u0131ficas, afetando diferentes partes do sistema, chamadas preocupa\u00e7 oes ortogonais (crosscutting concern). N\u00f3s apresentamos as principais constru\u00e7oes de AspectJ, bem como exemplos de aspectos para auxiliar a assimila\u00e7 ao dos conceitos. Tamb\u00e9m discutimos o uso de padroes de projetos para implementar algumas caracter\u0131sticas de AspectJ, e discutimos suas vantagens e desvantagens.", "num_citations": "19\n", "authors": ["1295"]}
{"title": "Ontologies supporting the distributed software development: a systematic mapping study\n", "abstract": " Background: Along the last decade, there has been a significant increase in the adoption of the approaches based on Distributed Software Development (DSD). This approach has brought several competitive advantages, as well as new challenges such as communication and information sharing. In this context, the ontologies can provide benefits such as the definition, standardization and sharing of knowledge involved in the project, allowing a uniform understanding of information and facilitating the collaboration among distributed software development teams. Aim: Identifying evidence to determine which tools, models, techniques and best practices that use ontologies to support the DSD projects, and which ontologies proposed in this context. Method: This paper presents a systematic mapping study conducted in order to investigate how ontologies are being applied as a support to the DSD. The research\u00a0\u2026", "num_citations": "17\n", "authors": ["1295"]}
{"title": "Concurrency manager\n", "abstract": " The advent of web\u2013based information systems significantly increased the number of concurrent programs. Concurrent programs must control concurrency to guarantee safe implementations, which avoid interference that lead systems to inconsistent states and behaviors. To implement some of these controls we need to use programming language features, such as blocking methods to avoid their concurrent execution in the same object. In the Java [6] programming language we can do this synchronizing methods with the synchronized method modifier, which forbid concurrent execution of methods within an object.However, implementation of such features brings performance overhead, serializing the execution of some operations. There are several approaches concerned about guaranteeing performance increasing, removing unnecessary synchronization of Java concurrent programs [3, 1, 5]. They show the negative impact in efficiency of the Java concurrency control mechanisms. This negative impact demands alternatives to increase programs\u2019 performance.", "num_citations": "17\n", "authors": ["1295"]}
{"title": "Mechanisms to Characterize Context of Empirical Studies in Software Engineering.\n", "abstract": " Background: It has become evident that empirical studies in software engineering (SE) have problems related to context characterization. This situation jeopardizes studies replication, result interpretation, knowledge transfer between academia and industry, and evidence integration of secondary studies. Goals: Our goals in this research are to identify and classify the mechanisms that support context characterization of empirical studies in SE. Method: A systematic mapping study with exhaustive coverage was conducted in accordance with the guidelines of evidence-based software engineering. Results: Out of 13,355 studies, 13 studies published between 1999 and 2012 were selected. Only one mechanism adopts the omnibus context approach, against 12 that follow the discrete approach. Ten studies present mechanisms to support context characterization of experiments. Only four out of the ten software engineering topics are covered by the found mechanisms. Conclusions: We found few mechanisms that support context characterization in SE. Besides, these mechanisms do not cover the specificities of many software engineering topics and empirical methods. Thus, we believe that more research to define mechanisms focused on these specificities is needed.", "num_citations": "16\n", "authors": ["1295"]}
{"title": "The impact of scrum on customer satisfaction: An empirical study\n", "abstract": " In the beginning of the last decade, agile methodologies emerged as a response to software development processes that were based on rigid approaches. In fact, the flexible characteristics of agile methods are expected to be suitable to the less-defined and uncertain nature of software development. However, many studies in this area lack empirical evaluation in order to provide more confident evidences about which contexts the claims are true. This paper reports an empirical study performed to analyze the impact of Scrum adoption on customer satisfaction as an external success perspective for software development projects in a software intensive organization. The study uses data from real-life projects executed in a major software intensive organization located in a nation wide software ecosystem. The empirical method applied was a cross-sectional survey using a sample of 19 real-life software development\u00a0\u2026", "num_citations": "16\n", "authors": ["1295"]}
{"title": "A morphological-rank-linear approach for software development cost estimation\n", "abstract": " This work presents a Morphological-Rank-Linear approach to solve the problem of Software Development Cost Estimation (SDCE). It consists of a hybrid morphological model, which is a linear combination between a Morphological-Rank (MR) operator (nonlinear) and a Finite Impulse Response (FIR) operator (linear), referred to as Morphological-Rank-Linear (MRL) filter. A gradient steepest descent method to adjust the MRL filter parameters (learning process), using the Least Mean Squares (LMS) algorithm, and a systematic approach to overcome the problem of nondifferentiability of the morphological-rank operator are used to improve the numerical robustness of training algorithm. Furthermore, an experimental analysis is conducted with the proposed approach using the well-known NASA database. In the experiments, two relevant performance metrics and an evaluation function are used to assess the\u00a0\u2026", "num_citations": "16\n", "authors": ["1295"]}
{"title": "A Marriage of MDD and Early Aspects in Software Product Line Development.\n", "abstract": " Model-driven development (MDD) shifts the development focus from code to models, allowing automatic or assisted transformations that are able to generate more refined, detailed or complete models. In Software Product Line (SPL) development, variation point implementation might inevitable lead to (crosscutting) concerns that are tangled and spread with other concerns, suggesting the use of aspect-oriented (AO) approaches. In this context, Early Aspects techniques can be applied to identify crosscutting concerns at early development process stages, positively affecting the application models as soon as possible. In this work we propose a marriage of MDD and early aspects for the development of SPL. Our approach takes an AO feature model and automatically transforms it into an AO early design model and this model into an AO architecture specification. We applied our proposal to a real-life SPL to better exemplify its use.", "num_citations": "16\n", "authors": ["1295"]}
{"title": "Refactoring and code generation tools for AspectJ\n", "abstract": " Code generation and refactoring tools have been quite useful for developing objectoriented applications [4, 2]. They increase development productivity by automating tedious, repetitive, and error-prone tasks. By reducing the number of programming errors, they also help to improve software quality. Based on our experience developing AspectJ [5] applications, we believe that aspect-aware code generation and refactoring tools can bring similar benefits for the development of aspect-oriented applications as well. Although aspect-oriented languages such as AspectJ provide some of the power of metaprogramming constructs, we think this is not enough for dispensing with code manipulation tools. In fact, code generation tools could generate part of the implementation of specific AspectJ patterns. For instance, we have noticed [6, 7] that the implementation of persistence and distribution aspects in several applications might follow the same structure, which could be automatically generated. The generation tools could also be used to instantiate specific AspectJ frameworks. This sometimes involves tedious coding that can only be avoided by generation tools or metaprogramming constructs more powerful than the ones currently supported by AspectJ. Similarly, AspectJ-aware refactoring tools could be used for improving and maintaining existing AspectJ code. Again, this would be necessary when implementing distribution concerns as suggested elsewhere [6], since for every newly introduced remote method we should introduce an associated advice following an specific pattern. The advice should also be removed when the method is removed\u00a0\u2026", "num_citations": "15\n", "authors": ["1295"]}
{"title": "Concurrency control with Java and relational databases\n", "abstract": " As Web-based information systems usually run in concurrent environment, the complexity for implementing and testing those systems is significantly high. Therefore it is useful to have guidelines to introduce concurrency control, avoiding ad hoc control strategies, which may have a negative impact in efficiency and may not guarantee system safety. This paper defines guidelines for concurrency control in Web-based information systems implemented in Java with relational databases. In particular we show where Java and relational database concurrency control mechanisms should be used in order to implement our concurrency control strategy. Additionally, we analyze the performance of different concurrency controls approaches. The main point of the guidelines is to guarantee system correctness without redundant concurrency control, both increasing performance and guaranteeing safely.", "num_citations": "15\n", "authors": ["1295"]}
{"title": "Support mechanisms to conduct empirical studies in software engineering: a systematic mapping study\n", "abstract": " Context: Empirical studies are gaining recognition in the Software Engineering (SE) research community, allowing improved quality of research and accelerating the adoption of new technologies in the software market. However, empirical studies in this area are still limited. In order to foster empirical research in SE, it is essential to understand the resources available to aid these studies. Goal: Identify support mechanisms (methodology, tool, guideline, process, etc.) used to conduct empirical studies in the Empirical Software Engineering (ESE) community. Method: We performed a systematic mapping study that included all full papers published at EASE, ESEM and ESEJ since their first editions. Were selected 891 studies between 1996 and 2013. Results: A total of 375 support mechanisms were identified. We provide the full list of mechanisms and the strategies that uses them. Despite this, we identified a high\u00a0\u2026", "num_citations": "14\n", "authors": ["1295"]}
{"title": "Support mechanisms to conduct empirical studies in software engineering\n", "abstract": " Context: Empirical studies are gaining recognition in the Software Engineering (SE) research community. In order to foster empirical research, it is essential understand the environments, guidelines, process, and other mechanisms available to support these studies in SE. Goal: Identifying the mechanisms used to support the empirical strategies adopted by the researches in the major Empirical Software Engineering (ESE) scientific venues. Method: We performed a systematic mapping study that included all full papers published at EASE, ESEM and ESEJ since their first editions. A total of 898 studies were selected. Results: We provide the full list of identified support mechanisms and the strategies that uses them. The most commonly mechanisms used to support the empirical strategies were two sets of guidelines, one to secondary studies and another to experiments. The most reported empirical strategies are\u00a0\u2026", "num_citations": "14\n", "authors": ["1295"]}
{"title": "Assessing the impact of AOSD on layered software architectures\n", "abstract": " Software structuring techniques aim to make software systems easier to develop and maintain, increasing their quality. Aspect-Oriented Software Development (AOSD) and Software Architectural Styles are examples of such techniques. In spite of all the benefits of structuring techniques, both actual and intended, it is not always easy or even advantageous to integrate two or more of these techniques. For example, the effects of combining AOSD and Layered Software Architectures are still not well understood. This might be detrimental to system quality and can be a decisive factor when deciding whether or not to employ AOSD, specially considering the pervasiveness of layered architectures. This paper presents a study aiming to assess the impact of AOSD on software architectures adopting the layered style. To better account for the influence of aspects on the layered structure of the system, we have\u00a0\u2026", "num_citations": "14\n", "authors": ["1295"]}
{"title": "On the need to update systematic literature reviews\n", "abstract": " ContextMany Systematic Literature Reviews (SLRs) were performed in the recent past, but just a few are being updated. Keeping SLRs updated is essential to prolong their lifespan.ObjectiveTo give a picture about how SLRs are being updated and what researchers think about SLRs updates.MethodIn this work, we present a Systematic Mapping (SM) study about SLRs updates and a survey with EBSE researchers that published their SLRs between 2011 and 2015.ResultsWe included 22 studies in the SM, where 15 changed some artifact from the original study, including changes in research questions. We obtained 28 answers in our survey with SLRs authors that, in general, consolidate interpretations retrieved from the SM, but some answers did not.ConclusionSLRs may lose their impact over the years. Identifying actions to keep them updated is of great importance to SLR research field.", "num_citations": "13\n", "authors": ["1295"]}
{"title": "Hybrid intelligent design of morphological-rank-linear perceptrons for software development cost estimation\n", "abstract": " This paper presents a hybrid intelligent method to design Morphological-Rank-Linear (MRL) perceptrons to solve the Software Development Cost Estimation (SDCE) problem. The proposed method uses a modified genetic algorithm (MGA) to determine the best particular features to improve the MRL perceptron performance, as well as its initial parameters. Furthermore, for each individual of MGA, a gradient steepest descent method is used to optimize the MRL perceptron parameters supplied by MGA. An experimental analysis is conducted with the proposed method using the Desharnais and Cocomo databases. In the experiments, two relevant performance metrics and a fitness function are used to assess the performance of the proposed method. The results obtained are compared to methods recently presented in literature.", "num_citations": "13\n", "authors": ["1295"]}
{"title": "Progressive implementation of distributed Java applications\n", "abstract": " This paper is organized as follows. We first explain how we forrealize and justify rim's ativities and key tasks. We then discuss in separate sections the introduction of distribution and concurrency aspects, in that order. rersistence aspects are not considered here for scope and spae reasons. Examples are used to illustrate several aspects of rim, including some refinement laws and the constraints imposed on design methods. The current version of rim is specific to Java [4] and RMI [7], so that we use them throughout the paper. At the end we discuss the current status of this work and its limitations", "num_citations": "13\n", "authors": ["1295"]}
{"title": "Six years of systematic literature reviews in software engineering: an extended tertiary study\n", "abstract": " After the introduction of evidence-based software engineering in 2004, systematic literature reviews (SLR) have been increasingly used as a method for conducting secondary studies in software engineering. Our goal is to analyze quality, coverage of software engineering topics, and potential impact of published SLRs, extending and updating two previous similar studies. We searched for SLRs published between July 2008 and December 2009, analyzed the relevant studies, compared and integrated our findings with previous studies. We found 67 SLRs, addressing 24 software engineering topics. The number of SLRs in software engineering is increasing and the overall quality of the studies is improving, suggesting that the software engineering research community is starting to consistently adopt SLRs as a research method. However, the majority of the SLRs did not evaluate the quality of primary studies and fail to provide guidelines to practitioners, thus decreasing their potential impact to influence software engineering practice.", "num_citations": "11\n", "authors": ["1295"]}
{"title": "Agile testing of exceptional behavior\n", "abstract": " The lack of testing and a priori design of the exceptional behavior are causing many of the problems found in the use of exception handling. As a consequence, exceptions flow in unforeseen ways during the execution of a software system, having a negative impact on reliability. This paper presents an agile approach to test the exceptional behavior of a system. It supports developers in checking whether exceptions, at runtime, travel through the expected paths. It is agile because tests are written without the need for extra documentation and are, themselves, considered live documentation. We have evaluated our approach by applying it to different versions of two production quality Java open source applications (i.e., aTunes and JEdit). Using the proposed approach, we could find twelve bugs --- eight of them previously unknown by the open source projects. In addition, from the viewpoint of automated tests as\u00a0\u2026", "num_citations": "10\n", "authors": ["1295"]}
{"title": "Mecanismos para guiar estudos empiricos em engenharia de software: Um mapeamento sistematico\n", "abstract": " Empirical studies have been reported as important mechanisms to the scientific advance in several research areas, such as social and medical sciences. In Software Engineering (SE) it has not been different. Since 1986, when Basili et al. evidenced the importance of experimentation in SE, empirical studies have grown in attention in the area, fostering the development of tools, methodologies, and techniques to support them. In this sense, this study presents a systematic mapping study on the mechanisms that guide empirical studies in SE, aggregating in an objective and systematic way the knowledge in the area, pointing gaps, and indicating new studies.Resumo. Estudos emp\u0131ricos se revelaram importantes mecanismos para o avan\u00e7o cient\u0131fico em diversas \u00e1reas de pesquisa, como, por exemplo, as ci\u00eancias sociais e m\u00e9dicas. Em Engenharia de Software (ES) nao tem sido diferente. Desde 1986, quando Basili et al. evidenciaram a import\u00e2ncia da experimenta\u00e7ao em ES, os estudos emp\u0131ricos v\u00eam ganhando espa\u00e7o na \u00e1rea e promovendo o desenvolvimento de ferramentas, metodologias e t\u00e9cnicas para apoiar estes estudos. Dessa forma, este trabalho apresenta um mapeamento sistem\u00e1tico de mecanismos para guiar estudos emp\u0131ricos em ES, reunindo de forma objetiva e sistem\u00e1tica o conhecimento da \u00e1rea, apontando lacunas e indicando propostas de novos estudos.", "num_citations": "10\n", "authors": ["1295"]}
{"title": "A JML compiler based on AspectJ\n", "abstract": " The Java modeling language (JML) is a behavioral interface specification language (BISL) designed for Java. It was developed with the aim of improving the functional software correctness of Java applications. The JML compiler (jmlc) generates bytecodes that use the Java reflection mechanism and data structures not supported by Java ME applications. In order to overcome this limitation, we propose the use of AspectJ to implement a new JML compiler, which generates an instrumented bytecode compliant with both Java SE and Java ME applications. The paper also includes a comparative study to demonstrate the quality of the final code generated by our compiler. Results indicate that the overhead in code size produced by our compiler is very small, which is essential for Java ME applications.", "num_citations": "10\n", "authors": ["1295"]}
{"title": "Progressive implementation with aspect-oriented programming\n", "abstract": " The object-oriented paradigm has some limitations, such as tangled code and code spread over several units, making harder software maintainability. Some of these limitations maybe compensated by design patterns and implementation methods guiding the software structure. On the other hand, extensions of the object-oriented paradigm, such as aspect-oriented programming, try to solve the object-oriented limitations. These techniques allow higher software modularity making easer software reuse and maintainability in practical situation where the object-oriented paradigm, design patterns, and implementation methods do not offer an adequate support. The aim of the work presented here is to analyze if different concerns (non-functional requirements) can be implemented and tested separately, in a progressive way, providing quality software and development productivity.", "num_citations": "10\n", "authors": ["1295"]}
{"title": "An analysis of software engineering experiments using human subjects\n", "abstract": " Context: Researchers perform experiments to check their proposals under controlled conditions. Thus, experiments are an important category of empirical studies and are the classical approach for identifying cause-effect relationships. Goal: Quantitatively characterize and analyze the controlled experiments in software engineering published in journal and conference proceedings in the decade from 2003 to 2013. Method: We performed a systematic mapping study that includes all full papers published at EASE, ESEM and ESEJ. A total of 731 were selected. Results: We obtained 110 papers that report controlled experiments. In these experiments we obtained quantitative data about authors and institutions, subjects, tasks, environment, replication and threats to validity. Conclusions: The main contribution of this work is the amount of experiments published in the three main venues of Empirical Software\u00a0\u2026", "num_citations": "9\n", "authors": ["1295"]}
{"title": "Classifying metrics for assessing object-oriented software maintainability: A family of metrics\u2019 catalogs\n", "abstract": " Object-Oriented Programming is one of the most used paradigms. Complementarily, the software maintainability is considered a software attribute playing an important role in quality level. In this context, Object-Oriented Software Maintainability (OOSM) has been studied through years, and many researchers have proposed a large number of metrics to measure it. Consequently, the decision-making process about which metrics can be adopted in experiments on OOSM is a hard task. Therefore, a metrics\u2019 categorization has been proposed to facilitate this process. As result, 7 categories and 17 subcategories were identified. These categories represent the scenarios of OOSM metrics adoption, and a family of OOSM metrics catalog was generated based on the selection of a metrics\u2019 categorization. Additionally, a quasi-experiment was conducted to check the coverage index of the catalogs generated using our\u00a0\u2026", "num_citations": "9\n", "authors": ["1295"]}
{"title": "Analyzing structure-based techniques for test coverage on a J2ME software product line\n", "abstract": " To constantly test software, in order to keep it as free as possible from defects, it is required to find and apply a testing approach that best fits the product under test. The variety of problems and the richness of existing approaches make the challenge to choose and plan for a better combination to reach desired quality level even harder. This paper introduces a case study that aims presenting different test coverage values according to the used approach. The context of our study considers the application of structure-based techniques on a Java ME software product line, which makes testing even more critical due to software complexity. In this work we present code coverage analysis and evaluation of main differences between data flow and control flow techniques, considering the use of a test tool and the reuse of test assets in different software versions from a software product line.", "num_citations": "9\n", "authors": ["1295"]}
{"title": "Specifying design rules in aspect-oriented systems\n", "abstract": " Modularization of crosscutting concerns is the main benefit provided by Aspect-Oriented constructs. However, current AO languages do not address class modularity adequately. In order to achieve both class and crosscutting modularity, Design Rules for AO Systems should be defined. In this work we propose a language to specify Design Rules that establish the minimum requirements to enable the parallel development of class and aspects. Beyond the modularization improvement, the language creates a simpler and unambiguous specification, supporting the development of mechanisms for automatically checking the specified rules and making easier the using of the parametrization mechanisms.", "num_citations": "8\n", "authors": ["1295"]}
{"title": "A comparative study of model-driven approaches for scoping and planning experiments\n", "abstract": " Context: Through the years researchers have proposed several approaches to foster the growth and quality of experiments in Software Engineering. Among these approaches, there are some initiatives that rely on tool support for specifying controlled experiments. Goal: This paper reports results from a study, which aims to organize, analyze and outline the specifications of each initiative through a comparative analysis. Method: Specifications of each initiative have been compared through a comparative analysis, carried out according to eight criteria:(i) standard empirical concepts,(ii) goals and targets,(iii) involved variables,(iv) subject description,(v) design of experiment,(vi) tasks and activities,(vii) instruments and measurements, and (viii) the threats to research validity. Results: The results show that, among the tools currently existing and used in literature, the eSEE (Experimental Software Engineering\u00a0\u2026", "num_citations": "7\n", "authors": ["1295"]}
{"title": "On inter-application reuse of exception handling aspects\n", "abstract": " In this paper we describe a study whose goal is to answer the question:\u201cIs exception handling a reusable aspect\u201d? To this end, we have systematically attempted to reuse exception handling AspectJ aspects across seven different real applications, some of them from the same domain, some based on the same development platform. Our preliminary results indicate that, due to a number of reasons, inter-application reuse is very difficult to achieve in practice. It was only possible to reuse handlers for particular cases, mainly empty handlers and trivial logging handlers. No handler with more than one line of code could be reused.", "num_citations": "7\n", "authors": ["1295"]}
{"title": "JML and aspects: The benefits of instrumenting JML features with AspectJ\n", "abstract": " The Java Modeling Language (JML) is used to specify designs of Java classes and interfaces. To this end, JML has a rich set of features for specifying methods, including specification inheritance. Thus, the most fundamental motivation for employing JML is to improve functional software correctness of Java applications, and helps to reduce corrective maintenance effort of those applications. Previously, we presented a new JML compiler (ajmlc) that generates aspects (AspectJ) for contract enforcement. This paper describes the main reasons to instrument JML features with AspectJ, with particular emphasis on issues related to instrumentation code size\u2014we also defined guidelines to use ajmlc that always generate compact instrumented code than the classical JML compiler (jmlc). In addition, we discuss the analogy between JML and AspectJ, and how the ajmlc also deals with Java ME applications, which is not possible with jmlc. Moreover, we implemented other JML features such as the new the new assertion semantics based on \u201cstrong validity\u201d presented elsewhere. The paper includes studies to compare the final code generated by ajmlc with the one produced by jmlc. Results indicate that the overhead in code size produced by our compiler is very small when using the proposed guidelines, which is essential for Java ME applications.", "num_citations": "7\n", "authors": ["1295"]}
{"title": "On the benefits of scenario variability as crosscutting\n", "abstract": " Variability management allows product customization by specifying variation points and composition rules related to feature models and product configurations. This is an interesting kind of crosscutting concern, since a feature might require variation points to be spread into different artifacts of each Software Product Line model (requirements, design, source code, and tests). In order to modularize use case scenario variability management, we proposed a crosscutting approach that weaves scenarios, feature models, product configurations, and configuration knowledge. The result leads to independent specification of behavior and variability concerns. In this work, we report the benefits of such kind of separation of concerns by comparing our approach with other techniques for handling scenario variability management.", "num_citations": "7\n", "authors": ["1295"]}
{"title": "PIP: Progressive implementation pattern\n", "abstract": " When developing a persistent, distributed, and concurrent system, implementation and tests are usually hard. During tests, database, distribution, concurrency, and functional errors might appear at the same time, increasing debugging complexity. When using EJB [10] as the persistence and distribution technology, the deployment time might be very high. To fix errors\u2014including functional, persistence, and concurrency control errors\u2014we might waste a lot of time by compiling the code and them deploying the system into the application server. Another problem happens when using a database to persist data. We might have to write specific programs to check if the data stored into the database conforms to the expected results. Similarly, if the system can be concurrently accessed, programmers should worry about concurrent executions when implementing functional requirements, increasing programming complexity.", "num_citations": "7\n", "authors": ["1295"]}
{"title": "Describing What Experimental Software Engineering Experts Do When They Design Their Experiments-A Qualitative Study\n", "abstract": " Background: Although there has been a significant amount of research focused on designing and conducting controlled experiments, few studies report how experienced experimental software engineering researchers actually design and conduct their studies. Aims: This study aimed to offer a practical perspective from their viewpoint regarding controlled experiment planning. Method: We collected data through semi-structured interviews from 11 researchers, and we used qualitative analysis methods from the grounded theory approach to analyze them. Result: Although the complete study presents four research questions, in this paper, we answer the first one. As a result, we present a preliminary result about what these experts actually do when they design experiments. Conclusions: This work contributes to a better understanding of the practical performance of experimental software engineering.", "num_citations": "6\n", "authors": ["1295"]}
{"title": "Towards reusable and modular aspect-oriented concurrency control\n", "abstract": " Information systems based on the World Wide Web increased the impact of concurrent programs. Such increase demands the definition of methods for obtaining safe and efficient implementations of concurrent programs, since the complexity of implementation and tests in concurrent environments is bigger than in sequential environments. This work defined guidelines to restructure object-oriented software in order to modularize concurrency control using aspect-oriented programming. Those guidelines are supported by a concurrency control implementation that guarantees system correctness without redundant concurrency control, both increasing performance and guaranteeing safety. We define abstract aspects that constitute a simple aspect framework that can be reused to implement concurrency control in other applications. The achieved modularization makes the concurrency control easy to evolve and\u00a0\u2026", "num_citations": "6\n", "authors": ["1295"]}
{"title": "On the design of an end-to-end aosd testbed for software stability\n", "abstract": " With AOSD techniques gaining attention in academic and industrial settings, it is vital that empirical evaluation is performed to determine their positive and negative impacts on the entire software development process. Assessments of AOSD are currently limited due to two main factors. First, they are currently performed in isolation of individual lifecycle stages, bearing little correlation to preceding and subsequent stages. Second, little attention is given to pivotal maintenance-related attributes, such as software stability. As a result, we have not been able to build a clear understanding of the effects of AOSD when compared to other modularization techniques, especially in realistic constantly-changing development scenarios.This paper reports initial issues on the design of a testbed to provide end-to-end systematic comparison of AOSD with other mainstream development approaches. The project began in June 2006 and has currently involved eight research institutions. The goal is to allow proponents of AO and non-AO modularization techniques to compare their approaches in a consistent manner at all stages of the software development process. The core of this testbed is presently based on:(i) a common application (benchmark) that involves heterogeneous types of crosscutting and non-crosscutting concerns, and (ii) a suite of metrics for assessing and comparing (but not limited to) software stability phenomena in different non-AO and AO lifecycle artefacts. In particular, the testbed is also being designed to support end-to-end analysis of evolving concern interactions and how they manifest themselves through the development process under\u00a0\u2026", "num_citations": "6\n", "authors": ["1295"]}
{"title": "Semistructured merge in JavaScript systems\n", "abstract": " Industry widely uses unstructured merge tools that rely on textual analysis to detect and resolve conflicts between code contributions. Semistructured merge tools go further by partially exploring the syntactic structure of code artifacts, and, as a consequence, obtaining significant merge accuracy gains for Java-like languages. To understand whether semistructured merge and the observed gains generalize to other kinds of languages, we implement two semistructured merge tools for JavaScript, and compare them to an unstructured tool. We find that current semistructured merge algorithms and frameworks are not directly applicable for scripting languages like JavaScript. By adapting the algorithms, and studying 10,345 merge scenarios from 50 JavaScript projects on GitHub, we find evidence that our JavaScript tools report fewer spurious conflicts than unstructured merge, without compromising the correctness of\u00a0\u2026", "num_citations": "5\n", "authors": ["1295"]}
{"title": "Gradient-based morphological approach for software development cost estimation\n", "abstract": " In this paper we present a gradient-based morphological approach to solve the software development cost estimation (SDCE) problem. The proposed approach consists of a dilation-erosion perceptron (DEP) trained by a gradient steepest descent method using the back propagation (BP) algorithm and a systematic approach to overcome the problem of nondifferentiability of morphological operators. Furthermore, we compare the proposed approach with other neural and statistical models using five complex SDCE problems.", "num_citations": "5\n", "authors": ["1295"]}
{"title": "A metrics suite to evaluate the impact of aosd on layered software architectures\n", "abstract": " Software structuring techniques aim to make systems easier to develop and maintain, increasing their quality. Aspect-Oriented Software Development (AOSD) and Software Architectural Styles are examples of such techniques. In spite of all the benefits of such structuring techniques, it is not always easy or even advantageous to integrate two or more of these techniques. For example, the effects of combining AOSD and Layered Software Architectures are still not well understood. This paper proposes a metrics suite to assess the impact of AOSD on layered software architectures. To better account for the influence of aspects on the layered system, we defined new metrics and extended existing ones to measure coupling between system layers and layering violations. These metrics are an initial effort to measure the maintainability of aspectoriented software adopting the layered architectural style. In addition, they can be used to support decision making on combining aspects and layered software architectures. We also developed a tool to automatically collect the proposed metrics.", "num_citations": "5\n", "authors": ["1295"]}
{"title": "Towards an analysis of layering violations in aspect-oriented software architectures\n", "abstract": " Empirical experiments with quantitative results are of great importance to analyze the benefits and drawbacks of aspect-oriented programming (AOP) in different contexts. Although many assessments of this new paradigm have been conducted in the last few years, only a small number of studies address specifically the impact of AOP on the architecture of a software system. This seriously hinders the adoption of AOP, as AOP techniques challenge the traditional notion of modularity on which most of the research on software architecture is based. More specifically, it is not clear what the effect of AOP on layered software architectures is. In this work, we present a study with the goal of analyzing the influence of AOP on violations of the layered structure of software architectures. We argue that the existing metrics for layering violations do not appropriately accommodate the notion of aspects. We explain the problems with these metrics and motivate the need to extend them to allow more precise quantitative evaluations of layering violations when aspects are involved. The target application of the study is a real-life web-based system that has been used in many other scientific studies.", "num_citations": "5\n", "authors": ["1295"]}
{"title": "AJaTS: AspectJ Transformation System\n", "abstract": " The interest in aspect-oriented software development naturally demands tool support for both implementation and evolution of aspect-oriented software, as well as refactoring current objectoriented software to aspect-oriented. In this paper, we present AJaTS\u2013a general purpose AspectJ Transformation System, that supports AspectJ code generation and transformation. AJaTS allows the definition of specific transformations, providing a simple template-based language, as well as pre-defined aspectoriented refactorings.", "num_citations": "5\n", "authors": ["1295"]}
{"title": "Maintaining systematic literature reviews: Benefits and drawbacks\n", "abstract": " Background: Maintenance and traceability (versioning) are constant concerns in Software Engineering (SE), however, few works related to these topics in Systematic Literature Reviews (SLR) were found. Goal: The goal of this research is to elucidate how SLRs can be maintained and what are the benefits and drawbacks in this process. Method: This work presents a survey where experienced researchers that conducted SLRs between 2011 and 2015 answered questions about maintenance and traceability and, using software maintenance concepts, it addresses the SLRs maintenance process. From the 79 e-mails sent we reach 28 answers. Results: 19 of surveyed researchers have shown interest in keeping their SLRs up-to-date, but they have expressed concerns about the effort to be made to accomplish it. It was also observed that 20 participants would be willing to share their SLRs in common repositories\u00a0\u2026", "num_citations": "4\n", "authors": ["1295"]}
{"title": "Codex: A metamodel ontology to guide the execution of coding experiments\n", "abstract": " Background: Experiments have been conducted in many domains of software engineering (SE). Objective: This paper presents a metamodel, the Codex metamodel, containing standard concepts found in any coding experiment. We classify coding experiments as any SE experiment where participants have to carry out coding activities (construct, test, debug, and forth). Method: The paper presents results of an exploratory study that proposes a metamodel for the domain of coding experiments. Besides, we present how our metamodel specifies a real coding experiment. Results: Our metamodel for coding experiments was modeled with few elements, and it can precisely describe all coding activities. Conclusions: Our metamodel facilitates the development of a tool to support executing a coding experiment.", "num_citations": "4\n", "authors": ["1295"]}
{"title": "Towards agile testing of exceptional behavior\n", "abstract": " Many of the problems found in the uses of exception handling are caused by the lack of testing and a priori design of the exceptional behavior. As a consequence, exceptions flow in unforeseen ways during the execution of a software system, causing a negative impact on reliability. This paper presents a new agile approach to test the exceptional behavior of a system. It supports developers in checking whether exceptions, at runtime, travel through the expected paths. It is agile because tests are written without the need for extra documentation. We present a preliminary evaluation of the proposed approach, where it helped us to uncover four bugs in a production system, two of them previously unknown. We have implemented the proposed approach as an extension of the JUnit framework.", "num_citations": "4\n", "authors": ["1295"]}
{"title": "Applying xp to an agile\u2013inexperienced software development team\n", "abstract": " Agile Methods are becoming each day a more and more frequently used alternative among software developing organizations producing high-quality products in real-world projects. Despite this growth in industry, few academic institutions provide courses related to this new software development approach. This paper describes an initiative of introducing agile method concepts through a Master\u2019s Degree course where the students had not experienced XP before. In spite of being MSc students they had previous software development background in industry environment. In this work we present how the issues found over the process may and have been handled as well as the benefits found; how the XP practices have been adapted and applied in a project with time, personnel, and skill constraints and what hindered some principles from being fully effective. We also present real results and open problems\u00a0\u2026", "num_citations": "4\n", "authors": ["1295"]}
{"title": "Desenvolvimento de Software Orientado a Aspectos utilizando RUP e AspectJ\n", "abstract": " Desenvolvimento de Software Orientado a Aspectos utilizando RUP e AspectJ Programa\u00e7\u00e3o Orientada a Objetos Exemplo: Sistema Dis Page 1 1 Desenvolvimento de Software Orientado a Aspectos utilizando RUP e AspectJ S\u00e9rgio Soares sergio@dsc.upe.br ESCOLA POLIT\u00c9CNICA DE PERNAMBUCO 2 S\u00e9rgio Castelo Branco Soares Programa\u00e7\u00e3o Orientada a Objetos \u220e Lida com conceitos mais intuitivos \u220e Permite ganhos \u2022 Reuso \u2022 Manuten\u00e7\u00e3o \u2022 Adapta\u00e7\u00e3o \u220e Padr\u00f5es de projetos \u2022 Auxiliam a POO 3 S\u00e9rgio Castelo Branco Soares Exemplo: Sistema Disque Sa\u00fade \u220e Um sistema de informa\u00e7\u00e3o \u2022 Registra e encaminha queixas para o sistema de sa\u00fade \u2022 Exibe informa\u00e7\u00f5es sobre unidades de sa\u00fade e suas especialidades \u220e Requisitos n\u00e3o-funcionais \u2022 Distribu\u00eddo \u2022 Acesso concorrente \u2022 Extens\u00edvel \u2014Armazenamento de dados \u2014Tecnologia de distribui\u00e7\u00e3o 4 S\u00e9rgio Castelo Branco Soares \u220e Implementado em Java \u2022 \u2026", "num_citations": "4\n", "authors": ["1295"]}
{"title": "Facilitators and Barriers to Using Alternative and Augmentative Communication Systems by Aphasic: Therapists Perceptions\n", "abstract": " Previous research identifies facilitators and barriers related to the use of Alternative and Augmentative Communication Systems, however, more evidence is needed to understand aspects related to introduction of such systems in an outpatient setting. This paper aims to analyze theses aspects by identifying the facilitators and barriers that comprise systems' use by aphasic people at a University Clinic in Brazil. Semi-structured interviews were conducted and the collected data were analyzed based on qualitative techniques like open coding and constant comparison. In addition to the factors found in previous research, this study identified new factors such as: cost, infantilized systems and sentences' quality produced, that can be considered as facilitators or barriers in using AAC systems. The results of this research can be used to improve the current and new AAC systems.", "num_citations": "3\n", "authors": ["1295"]}
{"title": "Threats to validity in controlled experiments in software engineering: what the experts say and why this is relevant\n", "abstract": " Context: Every experimental study has some threats to validity hindering its results. Goal: Improve software engineering controlled experiments quality by better understanding threats to validity control process. Method: A systematic Survey was executed to collect information from software engineering controlled experiments specialists. Data was quantitative and qualitatively analyzed. Results: 115 researchers took part in the study. Most of them (78.26%) consider extremely important to identify threats to validity during experiments planning to adjust it reducing the probability of threats to validity impacting experiment execution. Conclusions: Results bring participants point of view about identifying controlled experiments threats to validity. However, the study reveals some concerns since a considerable number (18.26%) of participants are not aware of threats to their studies or to new threats raised by actions took to\u00a0\u2026", "num_citations": "3\n", "authors": ["1295"]}
{"title": "Improving performance and maintainability of object cloning with lazy clones: An empirical evaluation\n", "abstract": " Object cloning is demanded by the prototype design pattern, copy-on-write strategy, some graph transformations, and many other scenarios. We have been developing a static analysis tool that clones objects frequently. In that context, issues related to performance, memory usage, and code maintainability might arise. Traditional deep cloning with dynamic allocation, reflection, and serialization, have not fulfilled those requirements. Thus, we developed novel implementations of lazy cloning with dynamic proxies and aspect-oriented programming (AOP). We defined benchmarks based on real workload to quantitatively assess the benefits of each implementation. AOP was chosen since it better harmonizes performance, memory usage and code maintainability. It was 88% faster than serialization, consumed 9 times less memory than reflection, and required 25 times less modifications on source code than dynamic\u00a0\u2026", "num_citations": "3\n", "authors": ["1295"]}
{"title": "Overcoming the random walk dilemma using a covariance matrix adaptation evolutionary method\n", "abstract": " This paper proposes the Covariance Matrix Adaptation based Evolutionary (CMAbE) methodology to overcome the random walk dilemma, characterized by one step delay regarding the real time series values, adjusting time phase distortions in the financial time series forecasting problem. The proposed CMAbE methodology consists of a hybrid model composed of the MultiLayer Perceptron (MLP) networks and the Covariance Matrix Adaptation Evolution Strategy (CMAES), which searches for the best particular time lags to optimally describe the time series phenomenon, as well for the best architecture, parameters and training algorithm of MLP networks. An experimental analysis is conducted with the proposed methodology through four real world financial time series, and the obtained results are discussed and compared to results found with recently methods presented in literature.", "num_citations": "3\n", "authors": ["1295"]}
{"title": "A concern-specific metrics collection tool\n", "abstract": " Static code metrics are widely used to evaluate quality attributes of software. Automated collection of these metrics is a must, which reduces errors inherent to manual collection, also improving the measurement process and guaranteeing the uniformity of the results, making it possible to compare them. Most metrics collection tools implement generic metrics that sometimes are inappropriate to evaluate quality attributes related to specifics concerns of software systems, such as reuse. Furthermore, few of them are capable of measuring aspect-oriented programs. This paper presents an approach that uses a tool to collect metrics relative to a specific concern, Exception Handling. The proposed tool was used in a case study to collect metrics from various software systems written in Java and AspectJ. Feedback from these studies and comparison with other collection approach and tool are also presented.", "num_citations": "3\n", "authors": ["1295"]}
{"title": "Dynamic Interface for Multi-Physics Simulator\n", "abstract": " Simulation is a well known technique to study complex systems. However, the implementation of a simulator may be more complex than the simulation itself. For instance, graphical user interface (GUI) development might consume around 50% of the software development time. Therefore, strategies and techniques to reduce costs in the development of GUI are mandatory in modern software engineering. In this paper we present a framework called GUI Generation Tool that dynamically constructs user interfaces based on specifications defined in XML files. This framework was defined to support automatic generation of simulators for multi-physics phenomena using software reuse techniques and software product lines concepts.", "num_citations": "3\n", "authors": ["1295"]}
{"title": "AJaTS\u2013AspectJ Transformation System: Tool Support for Aspect-Oriented Development and Refactoring\n", "abstract": " The interest in aspect-oriented software development naturally demands tool support for both implementing and evolution of aspect-oriented applications, as well as refactoring current object-oriented software to aspectoriented. In this paper, we present AJaTS\u2013a general purpose AspectJ Transformation System for AspectJ code generation and transformation. AJaTS allows the specification of aspect-oriented refactorings in a templatesbased language, syntatically similar to the AspectJ language. It also applies pre-defined recommended aspect-oriented refactorings and concerns implementation with aspects, such as distribution and persistence, increasing software development productivity.", "num_citations": "3\n", "authors": ["1295"]}
{"title": "CML: C modeling language\n", "abstract": " Non-functional requirements such as performance, program size, and energy consumption significantly affect the quality of software systems. Small devices like PDAs and mobile phones have little memory, slow processors, and energy constraints. The C programming language has been the choice of many programmers when developing application for small devices. On the other hand, the need for functional software correctness has derived several specification languages that adopt the Design by Contract (DBC) technique. In this work we propose a specification language for C, called CML (C Modeling Language), focused on non-functional requirements. CML is inspired on the Design By Contract technique. An additional contribution is a verification tool for hard real-time systems. The tool is the first application developed for CML. The practical usage of CML is presented through a case study, which is a real\u00a0\u2026", "num_citations": "3\n", "authors": ["1295"]}
{"title": "Is Exception Handling a Reusable Aspect?\n", "abstract": " A number of studies have evaluated the impact of modularizing the exception handling concern using aspect-oriented programming (AOP). Even though some of these studies have claimed that reuse through AOP is possible and advantageous in some cases, they have not focused specifically on reuse, often using the overall number of lines of code as a proxy for it. This has produced often contradictory results that are difficult to understand and extrapolate. In this paper we describe a study whose goal is to answer the question in the title of the paper. We have extracted exception handlers from 10 distinct applications to AspectJ aspects and, whenever possible, reused the handlers that were duplicated throughout each application. We have also collected a number of metrics from these systems and analyzed whether there is a relationship between the exception handling strategies that an application employs and\u00a0\u2026", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Mapeamento Sistem\u00e1tico de Gerenciamento de Projetos no Desenvolvimento Distribu\u00eddo de Software\n", "abstract": " As evid\u00eancias encontradas na literatura cient\u00edfica e na pr\u00e1tica industrial tem deixado claro que, gerenciamento de projetos \u00e9 fundamental para o sucesso de projetos de software tradicionais. Devido ao aumento das pr\u00e1ticas de desenvolvimento de software distribu\u00eddos na ind\u00fastria, alguma vari\u00e1veis como dist\u00e2ncia f\u00edsica, diferen\u00e7a temporal, intera\u00e7\u00e3o entre equipe e comunica\u00e7\u00e3o, s\u00e3o acrescentados ao j\u00e1 complexo problema de gerenciar projetos de software. No entanto, guias e modelos existentes para desenvolvimento co-localizado, s\u00e3o usados em projetos de desenvolvimento distribu\u00eddo de software. A partir desse contexto, esta pesquisa selecionou os trabalhos mais relevantes da \u00e1rea identificando os desafios, melhores pr\u00e1ticas, ferramentas e modelos de apoio ao gerenciamento de projetos quando o desenvolvimento \u00e9 distribu\u00eddo. O m\u00e9todo de pesquisa utilizado foi um estudo de mapeamento sistem\u00e1tico, em que quatro quest\u00f5es foram utilizadas para gui\u00e1-lo. Inicialmente identificou-se 2123 estudos e, ap\u00f3s aplica\u00e7\u00e3o dos crit\u00e9rios de exclus\u00e3o, restaram 373 estudos potencialmente relevantes. Ap\u00f3s a leitura dos resumos e conclus\u00f5es, destes, 224 estudos prim\u00e1rios responderam as quest\u00f5es de pesquisa. Os selecionados, serviram como base para coleta dos dados, de forma a comparar os mais evidenciados com o estudo de Costa (2009), contribuindo assim \u00e0 identifica\u00e7\u00e3o dos desafios e solu\u00e7\u00f5es (melhores pr\u00e1ticas, modelos e ferramentas) demonstrados na literatura.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "A quantum-inspired evolutionary learning process to design dilation-erosion perceptrons for financial forecasting\n", "abstract": " Financial forecasting problems are rather difficult to be solved due to many complex features present in these time series. Several techniques have been proposed in the literature to solve this kind of problem. However, a dilemma arises from them, known as random walk dilemma, where the forecasts generated show a characteristic one step delay with respect to the real time series data. In this sense, this work presents a quantum-inspired evolutionary learning process to design the dilation-erosion perceptron (DEP) in order to overcome the random walk dilemma for financial forecasting. Furthermore, an experimental analysis is presented using the Dow Jones Industrial Average Index, where five well-known performance metrics and an evaluation function are used to assess forecasting performance.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Designing dilation-erosion perceptrons with differential evolutionary learning for air pressure forecasting\n", "abstract": " The dilation-erosion perceptron (DEP) is a class of hybrid artificial neurons based on framework of mathematical morphology (MM) with algebraic foundations in the complete lattice theory (CLT). A drawback arises from the gradient estimation of dilation and erosion operators into classical gradient-based learning process of the DEP model, since they are not differentiable of usual way. In this sense, we present a differential evolutionary learning process, called DEP(MDE), using a modified differential evolution (MDE) to design the DEP model for air pressure forecasting. Also, we have included an additional step into learning process, called automatic phase fix procedure (APFP), to eliminate time phase distortions observed in some forecasting problems. Furthermore, an experimental analysis is presented using two complex time series, where five well-known performance metrics and an evaluation function are used\u00a0\u2026", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Analyzing architectural conformance of layered aspect-oriented systems with arche meter\n", "abstract": " We present ArchE Meter, a tool that supports developers in understanding how the implementation of an aspect-oriented system conforms to its intended layered software architecture. Based on the principles of layered software architectures, ArchE Meter indicates to what extent the implementation of a software system violates its layering structure in terms of three different kinds of violations.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "A covariance matrix adaptation based evolutionary methodology for phase adjustment in financial time series forecasting\n", "abstract": " In this paper we present a methodology, called covariance matrix adaptation based evolutionary (CMAbE), to solve the financial time series forecasting problem. The proposed methodology consists of a hybrid model composed of multilayer perceptrons (MLPs) combined with the Covariance Matrix Adaptation Evolution Strategy (CMAES), which determines the most fitted time lags to characterize the time series phenomenon, as well as searches for the best architecture, parameters and training algorithm of MLP networks. An experimental analysis is conducted with the proposed methodology through two real world financial time series, and the obtained results are discussed and compared to results found with recently methods presented in literature.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Hybrid evolutionary quantum inspired method to adjust time phase distortions in financial time series\n", "abstract": " This work presents a hybrid evolutionary quantum inspired method to adjust time phase distortions present in financial time series, overcoming the random walk dilemma for financial prediction. It is composed of a Qubit Multilayer Perceptron (QuMLP) with a Quantum Inspired Evolutionary Algorithm (QIEA), which is able to evolve the complete QuMLP architecture and parameters, as well as searches for the best time lags to describe the time series generator phenomenon. An experimental analysis is conducted with the proposed approach through two real world financial time series, and the obtained results are discussed and compared to results found with classical models in literature.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "On the role of features and goals models in the aspect-oriented development of software product line\n", "abstract": " Requirements of a Software Product Line (SPL) are usually captured in the form of a feature model, which represents the product line variation model, but this model lets several requirements details aside, such as the specification of functional and non-funcional requirements. Due to the crosscutting nature of SPL variations, researchers are using aspect-oriented techniques, to deal with such crosscutting concerns. In this context, the sooner these aspects can be identified the better, influencing the SPL and products architecture upfront. In this work we propose a Product Line extension to an aspect-oriented intentional model. The extended model provides both variability information and requirements details, promoting a natural blending of SPL and aspect-oriented architectural abstractions. We present the mapping between the SPL and the modeling approach abstractions and discuss two development scenarios: starting with a plain feature model and generating the extended aspect-oriented intentional model and the opposite approach.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Towards a framework for guiding aspect-oriented software maintenance empirical studies\n", "abstract": " Aspect-Oriented (AO) software development aims to improve software maintenance through the encapsulation of crosscutting concerns. However, empirical studies assessing the maintainability of AO software are still limited. Even worse, they are rarely replicated by different groups of researchers, thereby hampering the progress of the field. One of the key reasons for this is the lack of support for designing AO software exemplars or benchmarks to be reused across the community. This paper presents a framework for AO software maintenance, which has the purpose of guiding:(i) the planning, evaluation and replication of empirical studies, and (ii) the development, adaptation and evaluation of benchmark applications. The framework defines criteria to be satisfied by representative AO applications and their releases. We assess the effectiveness of the framework by comparing two different designs of the same empirical study: one that leverages the framework and another that was designed by an expert in empirical assessments of AO techniques.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Concurrency control modularization with aspect-oriented programming\n", "abstract": " Concurrent programs are essential in the development of Web based information systems. The wide dissemination of these systems increased the need for methods to create correct and efficient concurrent programs, which are usually difficult to implement and test. This paper presents guidelines to improve the concurrent control structure of object-oriented software using aspect-oriented programming through AspectJ based on an existent object-oriented concurrency control implementation method. We have defined a simple aspect framework that can be extended to implement concurrency control in applications complying with a software architecture presented in this paper. The framework comprises a set of reusable aspects useful for modularizing concurrency control.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "SimRWA-D: uma abordagem distribu\u00edda para simula\u00e7\u00e3o de redes \u00f3pticas transparentes\n", "abstract": " SimRWA-D, uma abordagem distribu\u00edda do SimRWA. Al\u00e9m disso, \u00e9 realizado um estudo de avalia\u00e7\u00e3o de desempenho, comparando em termos de tempo de resposta o SimRWA (abordagem centralizada) com o SimRWA-D (abordagem distribu\u00edda). Nossos experimentos mostram que o SimRWA-D obteve ganhos de at\u00e9 93% em rela\u00e7\u00e3o ao SimRWA. Outra contribui\u00e7\u00e3o \u00e9 um framework para processamento distribu\u00eddo resultante da implementa\u00e7\u00e3o do SimRWA-D, o qual pode ser reusado para distribuir o processamento n\u00e3o apenas de simuladores, mas de aplica\u00e7\u00f5es em geral.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Aspect-oriented implementation method: progressive or non-progressive approach?\n", "abstract": " Object-oriented programming languages provide effective means to achieve better reuse and extensibility levels, which increases development productivity. However, the object-oriented paradigm has several limitations, sometimes leading to tangled code and spread code. For example, business code tangled with presentation code or data access code, and distribution, concurrency control, and exception handling code spread over several classes. This decreases readability, and therefore, system maintainability. Some extensions of the object-oriented paradigm try to correct those limitations allowing reuse and maintenance in practical situations where the original paradigm does not offer an adequate support. However, in order to guarantee that those benefits will be achieved by those techniques it is necessary to use them together with an implementation method. Our objective is to adapt and to analyze an\u00a0\u2026", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Controle de concorr\u00eancia com Java e bancos de dados relacionais\n", "abstract": " O advento de sistemas de informa\u00e7ao baseados na World Wide Web aumentou o impacto dos sistemas concorrentes na sociedade. Tal crescimento torna mais necess\u00e1rio a defini\u00e7ao de diretrizes para a obten\u00e7ao de implementa\u00e7oes seguras e eficientes de programas concorrentes, uma vez que a complexidade de implementa\u00e7ao e testes em ambientes concorrentes \u00e9 maior que em ambientes seq\u00fcenciais. Este artigo define diretrizes para o controle de concorr\u00eancia em sistemas orientados a objetos escritos em Java e que utilizam banco de dados relacionais. Em particular, mostramos como e onde os recursos da linguagem de programa\u00e7ao de do banco de dados podem ser utilizados para controle de concorr\u00eancia. O objetivo principal das diretrizes \u00e9 garantir a corretude do sistema sem redund\u00e2ncia no controle de concorr\u00eancia, tanto aumentando a performance quanto garantindo a seguran\u00e7a do sistema.", "num_citations": "2\n", "authors": ["1295"]}
{"title": "Programming Language Adoption as an Epidemiological Phenomenon\n", "abstract": " In Software Engineering, technology transfer has been faced as a peer to peer problem, concerning only the adoption and innovation agents. This approach works well when one is just seeking the adoption of a technology by a specific client, but it can not solve a common problem that is the adoption of new technologies by a large mass of potential new users. In wider context, it no longer makes sense to focus on peer to peer transfer. A new way of looking at the problem is necessary. The diffusion of innovations is more natural when it is treated as a spread of information in a community, similar to that observed in epidemics. This work proposes a paradigm shift to show that the adoption of programming languages can be formally treated as an epidemic. This shift of focus allows the dynamics of adoption of programming languages to be mathematically modeled as such, defining models that explain the communities'\u00a0\u2026", "num_citations": "1\n", "authors": ["1295"]}
{"title": "Toward a Meta-Ontology for Accurate Ontologies to Specify Domain Specific Experiments in Software Engineering\n", "abstract": " Background: Experiments have been conducted in many domains of software engineering (SE). Objective: This paper presents a meta-ontology containing the common concepts present in any SE experiment. This meta-ontology aims at simplifying the proposition of accurate domain specific ontologies for the SE experiments. Method: The paper presents results of an exploratory study that proposes a general ontologyS and its specialization for the domain of coding experiments. Besides, we present how this domain specific ontology specifies a real experiment. Results: The ontology for coding experiments was modeled with few elements. Moreover, it focused only on elements specific to the coding activities. Conclusions: Our meta-ontology facilitates the development of a domain specific ontology in SE, however more research is necessary to evaluate our meta-ontology in other domains of SE.", "num_citations": "1\n", "authors": ["1295"]}
{"title": "Lazily Cloning Objects: A Microbenchmark Based on Real Workload\n", "abstract": " Object cloning is demanded by the prototype design pattern, copy-on-write strategy, some graph transformations, and many other scenarios. We have been developing a static analysis tool that clones objects frequently. In that context, issues related to performance, memory usage, and code maintainability might arise. Traditional deep cloning with dynamic allocation, reflection, and serialization, have not fulfilled those requirements. Thus, we developed novel implementations of lazy cloning with dynamic proxies and aspect-oriented programming (AOP). We defined benchmarks based on real workload to quantitatively assess the benefits of each implementation. AOP was chosen since it better harmonizes performance, memory usage and code maintainability. It was 88% faster than serialization, consumed 9 times less memory than reflection, and required 25 times less modifications on source code than dynamic allocation. In summary, we believe that the results can be extrapolated to broader contexts helping developers to make evidence-based decisions when object cloning is needed.", "num_citations": "1\n", "authors": ["1295"]}
{"title": "An\u00e1lise da qualidade de experimentos controlados no contexto da engenharia de software emp\u00edrica\n", "abstract": " Contexto \u2013 Considerando o aumento do interesse em pesquisas que conduzem Estudos Emp\u00edricos (EE), assim como, do aumento no n\u00famero de pesquisadores e institui\u00e7\u00f5es em todo o mundo que investigam processos experimentais em Engenharia de Software (ES), autores t\u00eam criticado a falta de qualidade e padroniza\u00e7\u00e3o dos experimentos quanto aos m\u00e9todos, procedimentos e forma de divulgar os resultados de EE. Objetivo \u2013 Realizar uma an\u00e1lise quantitativa da qualidade dos estudos categorizados como experimentos controlados no contexto da comunidade de Engenharia de Software Emp\u00edrica (ESE) quanto aos mecanismos de suporte utilizados, replicabilidade e rigor estat\u00edstico. M\u00e9todo \u2013 Em virtude de n\u00e3o ter encontrado na literatura revisada um padr\u00e3o de perguntas para avaliar a qualidade de EE em ES, decidiu-se criar uma escala de qualidade baseada, principalmente, em listas de verifica\u00e7\u00e3o amplamente utilizadas por pesquisadores da \u00e1rea de ES. O m\u00e9todo de procedimento utilizado foi a abordagem GQM - Goal Question Metric, composta pelas fases: defini\u00e7\u00e3o, planejamento, coleta e interpreta\u00e7\u00e3o. Resultados \u2013 Os estudos que mencionaram o uso de mecanismos de suporte tiveram um \u00edndice de qualidade igual a 58,54, numa escala que vai de zero a cem pontos, enquanto aos que n\u00e3o usaram, tiveram um \u00edndice igual a 51,32. A classifica\u00e7\u00e3o da vari\u00e1vel replicabilidade e rigor estat\u00edstico foi respectivamente 63,42 (Boa) e 70,79 (Muito Boa) e, no geral, os resultados mostraram que o \u00edndice de qualidade dos estudos foi 57,15, sendo que entre os locais avaliados, houve diferen\u00e7a estatisticamente significativa apenas\u00a0\u2026", "num_citations": "1\n", "authors": ["1295"]}
{"title": "Transfer\u00eancia de tecnologia entre academia e ind\u00fastria em engenharia de software: um mapeamento sistem\u00e1tico\n", "abstract": " A transfer\u00eancia de tecnologia \u00e9 o processo pelo qual a ind\u00fastria se mant\u00e9m em constante evolu\u00e7\u00e3o e competitividade. Esta atividade proporciona um modo em que as empresas possam alcan\u00e7ar maior efetividade no uso de seus recursos, provendo informa\u00e7\u00e3o e aux\u00edlio, que conduz a melhorias em diversas \u00e1reas do neg\u00f3cio. Em engenharia de software, o processo tende a ser laborioso, dependente de condu\u00e7\u00e3o rigorosa e de fatores (ou influenciadores), que geralmente est\u00e3o inclinados a assumir papel decisivo quando do momento da ado\u00e7\u00e3o. Evid\u00eancia contundente, benef\u00edcio claro, apoio organizacional e treinamento s\u00e3o alguns dos muitos fatores que podem atuar com protagonismo e mudar o curso da atividade. A parceria entre academia e ind\u00fastria \u00e9 propensa a ser uma fonte f\u00e9rtil para inova\u00e7\u00f5es tecnol\u00f3gicas de forma a saciar o anseio do mercado e impulsionar a cria\u00e7\u00e3o de novas ideias e vis\u00f5es renovadas. Este estudo tem como objetivo a coleta e investiga\u00e7\u00e3o do conhecimento dispon\u00edvel na literatura, de forma sistem\u00e1tica, que tenham rela\u00e7\u00e3o com fatores que influenciam positiva ou negativamente a transfer\u00eancia de tecnologia entre academia e ind\u00fastria no campo da engenharia de software, assim como as abordagens existentes. De modo a alcan\u00e7ar o objetivo, foi utilizado, como m\u00e9todo de pesquisa, o estudo de mapeamento sistem\u00e1tico. Este mapeamento obteve um total de 6228 estudos, por meio de buscas automatizadas e manuais, dentre os quais 87 estudos prim\u00e1rios foram identificados como relevantes e classificados de acordo com as perguntas de pesquisa. Com base na an\u00e1lise realizada, conclui-se que a\u00a0\u2026", "num_citations": "1\n", "authors": ["1295"]}
{"title": "Dilation-erosion perceptrons with evolutionary learning for weather forecasting\n", "abstract": " The Dilation-erosion perceptron (DEP) is considered a good forecasting model, whose foundations are based on mathematical morphology (MM) and complete lattice theory (CLT). However, a drawback arises from the gradient estimation of morphological operators into classical gradient-based learning process, since they are not differentiable of usual way. In this sense, this work presents an evolutionary learning process, called DEP(MGA), using a modified genetic algorithm (MGA) to design the DEP model for weather forecasting. In addition, we have included an automatic phase fix procedure (APFP) into the proposed learning process to eliminate time phase distortions observed in some temporal phenomena. At the end, an experimental analysis is presented using two complex time series, where five well-known performance metrics and an evaluation function are used to assess forecasting performance.", "num_citations": "1\n", "authors": ["1295"]}
{"title": "An evolutionary approach to design dilation-erosion perceptrons for stock market indices forecasting\n", "abstract": " In this work we present an evolutionary learning process using the covariance matrix adaptation evolutionary strategy (CMAES) to design the dilation-erosion perceptron (DEP) for stock market indices forecasting. Also, we have included an automatic phase fix procedure (APFP) into proposed learning process to eliminate time phase distortions observed in some forecasting problems. The main advantage of the DEP model designed by our learning process, apart from its higher forecasting performance, is do not request any methodology to overcome the nondifferentiability of morphological operators needed into classical gradient-based learning process of the DEP model. Besides, we present an experimental analysis using two stock market indices, where five well-known performance metrics and an evaluation function are used to assess forecasting performance.", "num_citations": "1\n", "authors": ["1295"]}
{"title": "Towards progressive and non-progressive implementation approaches evaluation\n", "abstract": " Unfortunately, there is a lack of experiments in software engineering. For example, it is common to propose new processes, paradigms, methods, development architectures, frameworks, and others, using only intuitive or textual arguments, instead of trying to demonstrate effectiveness of the proposal by using experiments techniques, when real case studies might be to expensive. We are particularly interested to present some results and get feed back about a performed study to identify if and when a progressive implementation approach is better than a non-progressive one. In a progressive approach, persistence, distribution, and concurrency control are not initially considered in the implementation activities, but are gradually introduced, preserving the application\u2019s functional requirements. This approach helps in dealing with the inherent complexity of the modern applications, through the support to gradual implementations and tests of the intermediate versions of the application.", "num_citations": "1\n", "authors": ["1295"]}
{"title": "A Framework for Defining Object-oriented Languages using Action Semantics\n", "abstract": " The benefits of formally specifying programming languages are widely recognized. Formalization is even more important for object-oriented languages whose design involves subtle interactions between several different concepts. Many formalisms have been proposed and Action Semantics is among the most successful. This paper defines a set of semantic entities useful for formally specifying object-oriented programming languages using Action Semantics. As a case study, we use these entities to describe the object-oriented kernel of Java.", "num_citations": "1\n", "authors": ["1295"]}
{"title": "Implementando Sistemas Orientados a Objetos para Web usando Servlets Java\n", "abstract": " Este trabalho apresenta uma proposta para desenvolvimento de sistema para a Web que favorecem fatores de qualidade de software. A abordagem de constru\u00e7\u00e3o de aplica\u00e7\u00f5es utilizando o estilo CGI tende a tornar o sistema mal estruturado dificultando sua extens\u00e3o e manuten\u00e7\u00e3o.Uma sugest\u00e3o de arquitetura orientada a objetos para a implementa\u00e7\u00e3o do n\u00facleo do sistema \u00e9 apresentada. Al\u00e9m disto, \u00e9 definida uma estrat\u00e9gia de integra\u00e7\u00e3o entre interfaces leves e eficientes implementada com a linguagem HTML e Javascript, com um sistema orientado a objetos, onde a comunica\u00e7\u00e3o entre estas partes \u00e9 feita utilizando-se Servlets Java.", "num_citations": "1\n", "authors": ["1295"]}