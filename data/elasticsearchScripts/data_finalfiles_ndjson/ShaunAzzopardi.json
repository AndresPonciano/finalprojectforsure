{"title": "Monitoring smart contracts: Contractlarva and open challenges beyond\n", "abstract": " Smart contracts present new challenges for runtime verification techniques, due to features such as immutability of the code and the notion of gas that must be paid for the execution of code. In this paper we present the runtime verification tool ContractLarva and outline its use in instrumenting monitors in smart contracts written in Solidity, for the Ethereum blockchain-based distributed computing platform. We discuss the challenges faced in doing so, and how some of these can be addressed, using the ERC-20 token standard to illustrate the techniques. We conclude by proposing a list of open challenges in smart contract and blockchain monitoring.", "num_citations": "25\n", "authors": ["1683"]}
{"title": "Integrating natural language and formal analysis for legal documents\n", "abstract": " Although much research has gone into natural language legal document analysis, practical solutions to support legal document drafting and reasoning are still limited in number and functionality. However given the textual basis of law there is much potential for NLP techniques to aid in the context of drafting legal documents, in particular contracts. Furthermore, there is a body of work focusing on the formal semantics of norms and legal notions which has direct applications in analysis of such documents. In this paper we present our attempt to use several off-the-shelf NLP techniques to provide a more intelligent contract editing tool to lawyers. We exploit these techniques to extract information from contract clauses to allow intelligent browsing of the contract. We use this surface analysis to bridge the gap between the English text of a contract to its formal representation, which is then amenable to automated deduction, specifically it allows us to identify conflicts in the contract.", "num_citations": "14\n", "authors": ["1683"]}
{"title": "A model-based approach to combining static and dynamic verification techniques\n", "abstract": " Given the complementary nature of static and dynamic analysis, there has been much work on identifying means of combining the two. In particular, the use of static analysis as a means of alleviating the overheads induced by dynamic analysis, typically by trying to prove parts of the properties, which would then not need to be verified at runtime. In this paper, we propose a novel framework which combines static with dynamic verification using a model-based approach. The approach allows the support of applications running on untrusted devices whilst using centralised sensitive services whose use is to be tightly regulated. In particular, we discuss how this approach is being adopted in the context of the Open Payments Ecosystem (OPE) \u2014 an ecosystem meant to support the development of payment and financial transaction applications with strong compliance verification to enable adoption by payment\u00a0\u2026", "num_citations": "11\n", "authors": ["1683"]}
{"title": "Contract automata with reparations\n", "abstract": " Although contract reparations have been extensively studied in the context of deontic logics, there is not much literature using reparations in automata-based deontic approaches. Contract automata is a recent approach to modelling the notion of contract-based interaction between different parties using synchronous composition. However, it lacks the notion of reparations for contract violations. In this article we look into, and contrast different ways reparation can be added to an automaton-and state-based contract approach, extending contract automata with two forms of such clauses: catch-all reparations for violation and reparations for specific violations.", "num_citations": "11\n", "authors": ["1683"]}
{"title": "Runtime verification using VALOUR\n", "abstract": " In this paper we give an overview of Valour, a runtime verification tool which has been developed in the context of a project to act as a backend verification tool for financial transaction software. A Valour script is written by the user and is then compiled into a verification system. Although, developed as part of a project, the tool has been designed as a stand-alone general-purpose verification engine with a particular emphasis on event consumption. The strong points of Valour when compared to other runtime verification tools is its focus on scalability and robustness.", "num_citations": "10\n", "authors": ["1683"]}
{"title": "On observing contracts: deontic contracts meet smart contracts\n", "abstract": " Smart contracts have been proposed as executable implementations enforcing real-life contracts. Unfortunately, the semantic gap between these allows for the smart contract to diverge from its intended deontic behaviour. In this paper we show how a deontic contract can be used for real-time monitoring of smart contracts specifically and request-based interactive systems in general, allowing for the identification of any violations. The deontic logic of actions we present takes into account the possibility of action failure (which we can observe in smart contracts), allowing us to consider novel monitorable semantics for deontic norms. For example, taking a rights-based view of permissions allows us to detect the violation of a permission when a permitted action is not allowed to succeed. A case study is presented showing this approach in action for Ethereum smart contracts.", "num_citations": "9\n", "authors": ["1683"]}
{"title": "Control-flow residual analysis for symbolic automata\n", "abstract": " Where full static analysis of systems fails to scale up due to system size, dynamic monitoring has been increasingly used to ensure system correctness. The downside is, however, runtime overheads which are induced by the additional monitoring code instrumented. To address this issue, various approaches have been proposed in the literature to use static analysis in order to reduce monitoring overhead. In this paper we generalise existing work which uses control-flow static analysis to optimise properties specified as automata, and prove how similar analysis can be applied to more expressive symbolic automata - enabling reduction of monitoring instrumentation in the system, and also monitoring logic. We also present empirical evidence of the effectiveness of this approach through an analysis of the effect of monitoring overheads in a financial transaction system.", "num_citations": "8\n", "authors": ["1683"]}
{"title": "Compliance checking in the open payments ecosystem\n", "abstract": " Given the strict legal frameworks which regulate the movements and management of funds, building financial applications typically proves to be prohibitively expensive for small companies. Not only is it the case that understanding legal requirements and building a framework of compliance checks to ensure that such legislation is adhered to is a complex process, but also, service providers such as banks require certification and reporting before they are willing to take on the risks associated with the adoption of applications from small application developers. In this paper, we propose a solution which provides a centralised Open Payments Ecosystem which supports compliance checking and allows for the matching of financial applications with service providers and programme managers, automatically providing risk analysis and reporting. The solution proposed combines static and dynamic verification in\u00a0\u2026", "num_citations": "8\n", "authors": ["1683"]}
{"title": "A Technique for Automata-based Verification with Residual Reasoning.\n", "abstract": " Analysing programs at a high-level of abstraction reduces the effort required for verification, but may abstract away details required for full verification of a specification. Working at a lower level, eg through model checking or runtime verifying program code, can avoid this problem of abstraction, at the expense of much larger resource requirements. To reduce the resources required by verification, analysis techniques at decreasing levels of abstraction can be combined in a complementary manner through partial verification or residual analysis, where any useful partial information discovered at a high-level is used to reduce the verification problem, leaving an easier residual problem for lowerlevel analyses. Our contribution in this paper is a technology-agnostic symbolic-automata-based framework to project verification effort onto different verification stages. Properties and programs are both represented as symbolic automata, with an event-based view of verification. We give correctness conditions for residual analysis based on equivalence with respect to verification of the original problem. Furthermore we present an intraprocedural residual analysis to identify parts of the property respected by the program, and parts of the program that cannot violate the property.", "num_citations": "6\n", "authors": ["1683"]}
{"title": "CLARVA: Model-based Residual Verification of Java Programs.\n", "abstract": " Runtime verification (RV) is an established approach that utilises monitors synthesized from a property language (eg temporal logics or some form of automata) to observe program behaviour at runtime, determining compliance of the program with the property at runtime. An issue with RV is that it introduces overheads at runtime, while identifying a violation at runtime may be too late. This can be tackled by introducing light analyses that attempt to prove parts of the property with respect to the program, leaving a residual property that induces a smaller monitoring footprint at runtime and encodes some static guarantees. In this paper we present CLARVA as a tool developed for this end for the RV tool LARVA. CLARVA transforms Java code into an automaton-based model, and allows for the incorporation of control-flow analyses that analyse this model against Dynamic Automata with Timers and Events or DATES (the property language used by LARVA) to produce residuals that produce an equivalent judgement at runtime.", "num_citations": "6\n", "authors": ["1683"]}
{"title": "A Controlled Natural Language for Financial Services Compliance Checking\n", "abstract": " Controlled natural languages have long been used as a surface form for formal descriptions, allowing easy transitioning between natural language specifications and implementable specifications. In this paper we motivate the use of a controlled natural language in the representation and verification of financial services regulations. The verification context is that of payment applications that come with a model of their promised behaviour and which are deployed on a payments ecosystem. The semantics of this financial services regulations controlled natural language (FSRCNL) can produce compliance checks that analyse both the promised model and/or monitor the application itself after it is deployed.", "num_citations": "4\n", "authors": ["1683"]}
{"title": "Model-Based Static and Runtime Verification for Ethereum Smart Contracts\n", "abstract": " Distributed ledger technologies, e.g. blockchains, are an innovative solution to the problem of trust between different parties. Smart contracts, programs executing on these ledgers present new challenges given their non-traditional execution context \u2013 blockchains. The immutability of smart contracts once they are deployed makes their pre-deployment correctness essential. This can be achieved through verification methods, which attempt to answer conclusively whether the code respects some specification. Another approach is model-driven development, where the specification is used directly to create a correct-by-const-ruction implementation. A specification may however still need to be verified to ensure it satisfies some properties. Verifying properties pre-deployment is ideal, however it may not always be possible to do completely, depending on the complexity of the smart contract. Traditionally upon\u00a0\u2026", "num_citations": "2\n", "authors": ["1683"]}
{"title": "Residual Control-Flow Static Analysis with Symbolic Automata\n", "abstract": " Runtime verification involves checking whether or not a particular program trace generated during its execution satisfies a given specification. The extra monitoring logic necessary to check for compliance, lying on top of the original program, induces overhead at runtime and much effort is put into reducing this overhead to make monitoring less prohibitive. One approach to address this issue involves trying to prove parts of the specification before runtime, ie statically, by analysing the source code, leaving a residual specification to check at runtime. CompiLe-Time Approximation of Residual Analyses [1](Clara) is a framework developed by Bodden et. al. that, for a property specified as a finite-state machine, and a Java program, combines such residual static analyses to finally produce a more efficient monitor for verification. It incorporates several analyses that approximate the possible control-flow behaviour of a\u00a0\u2026", "num_citations": "1\n", "authors": ["1683"]}