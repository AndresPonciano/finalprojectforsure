{"title": "Software engineering for self-adaptive systems: A second research roadmap\n", "abstract": " The goal of this roadmap paper is to summarize the state-of-the-art and identify research challenges when developing, deploying and managing self-adaptive software systems. Instead of dealing with a wide range of topics associated with the field, we focus on four essential topics of self-adaptation: design space for self-adaptive solutions, software engineering processes for self-adaptive systems, from centralized to decentralized control, and practical run-time verification & validation for self-adaptive systems. For each topic, we present an overview, suggest future directions, and focus on selected challenges. This paper complements and extends a previous roadmap on software engineering for self-adaptive systems published in 2009 covering a different set of topics, and reflecting in part on the previous paper. This roadmap is one of the many results of the Dagstuhl Seminar 10431 on Software\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2095\n", "authors": ["46"]}
{"title": "State models and java programs\n", "abstract": " We structure complex systems as sets of simpler activities, each represented as a sequential process. Processes can overlap or be concurrent, so as to reflect the concurrency inherent in the physical world, or to offload time-consuming tasks, or to manage communications or other devices.", "num_citations": "1558\n", "authors": ["46"]}
{"title": "Specifying distributed software architectures\n", "abstract": " There is a real need for clear and sound design specifications of distributed systems at the architectural level. This is the level of the design which deals with the high-level organisation of computational elements and the interactions between those elements. The paper presents the Darwin notation for specifying this high-level organisation. Darwin is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language supports the specification of both static structures and dynamic structures which may evolve during execution. The central abstractions managed by Darwin are components and services. Services are the means by which components interact.             In addition to its use in specifying the architecture of a distributed system, Darwin has an operational semantics for\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1301\n", "authors": ["46"]}
{"title": "The evolving philosophers problem: Dynamic change management\n", "abstract": " A model for dynamic change management which separates structural concerns from component application concerns is presented. This separation of concerns permits the formulation of general structural rules for change at the configuration level without the need to consider application state, and the specification of application component actions without prior knowledge of the actual structural changes which may be introduced. In addition, the changes can be applied in such a way so as to leave the modified system in a consistent state, and cause no disturbance to the unaffected part of the operational system. The model is applied to an example problem, 'evolving philosophers'. The principles of this model have been implemented and tested in the Conic environment for distributed systems.< >", "num_citations": "1133\n", "authors": ["46"]}
{"title": "The Koala component model for consumer electronics software\n", "abstract": " Most consumer electronics today contain embedded software. In the early days, developing CE software presented relatively minor challenges, but in the past several years three significant problems have arisen: size and complexity of the software in individual products; the increasing diversity of products and their software; and the need for decreased development time. The question of handling diversity and complexity in embedded software at an increasing production speed becomes an urgent one. The authors present their belief that the answer lies not in hiring more software engineers. They are not readily available, and even if they were, experience shows that larger projects induce larger lead times and often result in greater complexity. Instead, they believe that the answer lies in the use and reuse of software components that work within an explicit software architecture. The Koala model, a component\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1074\n", "authors": ["46"]}
{"title": "Self-managed systems: an architectural challenge\n", "abstract": " Self-management is put forward as one of the means by which we could provide systems that are scalable, support dynamic composition and rigorous analysis, and are flexible and robust in the presence of change. In this paper, we focus on architectural approaches to self-management, not because the language-level or network-level approaches are uninteresting or less promising, but because we believe that the architectural level seems to provide the required level of abstraction and generality to deal with the challenges posed. A self-managed software architecture is one in which components automatically configure their interaction in a way that is compatible with an overall architectural specification and achieves the goals of the system. The objective is to minimise the degree of explicit management necessary for construction and subsequent evolution whilst preserving the architectural properties implied by\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1064\n", "authors": ["46"]}
{"title": "Dynamic structure in software architectures\n", "abstract": " Much of the recent work on Architecture Description Languages (ADL) has concentrated on specifying organisations of components and connectors which are static. When the ADL specification is used to drive system construction, then the structure of the resulting system in terms of its component instances and their interconnection is fixed. This paper examines ADL features which permit the description of dynamic software architectures in which the organisation of components and connectors may change during system execution.The paper outlines examples of language features which support dynamic structure. These examples are taken from Darwin, a language used to describe distributed system structure. An operational semantics for these features is presented in the \u2567\u00c7-calculus, together with a discussion of their advantages and limitations. The paper discusses some general approaches to dynamic\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "923\n", "authors": ["46"]}
{"title": "A framework for expressing the relationships between multiple views in requirements specification\n", "abstract": " Composite systems are generally comprised of heterogeneous components whose specifications are developed by many development participants. The requirements of such systems are invariably elicited from multiple perspectives that overlap, complement, and contradict each other. Furthermore, these requirements are generally developed and specified using multiple methods and notations, respectively. It is therefore necessary to express and check the relationships between the resultant specification fragments. We deploy multiple ViewPoints that hold partial requirements specifications, described and developed using different representation schemes and development strategies. We discuss the notion of inter-ViewPoint communication in the context of this ViewPoints framework, and propose a general model for ViewPoint interaction and integration. We elaborate on some of the requirements for expressing\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "779\n", "authors": ["46"]}
{"title": "Inconsistency handling in multiperspective specifications\n", "abstract": " The development of most large and complex systems necessarily involves many people-each with their own perspectives on the system defined by their knowledge, responsibilities, and commitments. To address this we have advocated distributed development of specifications from multiple perspectives. However, this leads to problems of identifying and handling inconsistencies between such perspectives. Maintaining absolute consistency is not always possible. Often this is not even desirable since this can unnecessarily constrain the development process, and can lead to the loss of important information. Indeed since the real-world forces us to work with inconsistencies, we should formalize some of the usually informal or extra-logical ways of responding to them. This is not necessarily done by eradicating inconsistencies but rather by supplying logical rules specifying how we should act on them. To achieve\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "713\n", "authors": ["46"]}
{"title": "Model-based verification of web service compositions\n", "abstract": " In this paper, we discuss a model-based approach to verifying Web service compositions for Web service implementations. The approach supports verification against specification models and assigns semantics to the behavior of implementation model so as to confirm expected results for both the designer and implementer. Specifications of the design are modeled in UML (Unified Modeling Language), in the form of message sequence charts (MSC), and mechanically compiled into the finite state process notation (FSP) to concisely describe and reason about the concurrent programs. Implementations are mechanically translated to FSP to allow a trace equivalence verification process to be performed. By providing early design verification, the implementation, testing, and deployment of Web service compositions can be eased through the understanding of the differences, limitations and undesirable traces allowed\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "710\n", "authors": ["46"]}
{"title": "Is abstraction the key to computing?\n", "abstract": " Why is it that some software engineers and computer scientists are able to produce clear, elegant designs and programs, while others cannot? Is it possible to improve these skills through education and training? Critical to these questions is the notion of abstraction.", "num_citations": "569\n", "authors": ["46"]}
{"title": "Dynamic configuration for distributed systems\n", "abstract": " Dynamic system configuration is the ability to modify and extend a system while it is running. The facility is a requirement in large distributed systems where it may not be possible or economic to stop the entire system to allow modification to part of its hardware or software. It is also useful during production of the system to aid incremental integration of component parts, and during operation to aid system evolution. The paper introduces a model of the configuration process which permits dynamic incremental modification and extension. Using this model we determine the properties required by languages and their execution environments to support dynamic configuration. CONIC, the distributed system which has been developed at Imperial College with the specific objective of supporting dynamic configuration, is described to illustrate the feasibility of the model.", "num_citations": "501\n", "authors": ["46"]}
{"title": "Constructing distributed systems in Conic\n", "abstract": " The Conic environment provides a language-based approach to the building of distributed systems which combines the simplicity and safety of a language approach with the flexibility and accessibility of an operating systems approach. It provides a comprehensive set of tools for program compilation, configuration, debugging, and execution in a distributed environment. A separate configuration language is used to specify the configuration of software components into logical nodes. This provides a concise configuration description and facilitates the reuse of program components in different configurations. Applications are constructed as sets of one or more interconnected logical nodes. Arbitrary, incremental change is supported by dynamic configuration. In addition, the system provides user-transparent datatype transformation between heterogeneous processors. Applications may be run on a mixed set of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "462\n", "authors": ["46"]}
{"title": "Regis: A constructive development environment for distributed programs\n", "abstract": " Regis is a programming environment aimed at supporting the development and execution of distributed programs. It embodies a constructive approach to the development of programs based on separating program structure from communication and computation, The emphasis is on constructing programs from multiple parallel computational components which cooperate to achieve the overall goal. The environment is designed to easily accommodate multiple communication mechanisms and primitives. Both the computational and communication elements of Regis programs are programmed in the object oriented programming language C++. The elements are combined into distributed programs using the configuration language Darwin. The paper describes programming in Regis through a set of small example programs drawn from the implementation of an Active Badge system.", "num_citations": "439\n", "authors": ["46"]}
{"title": "Self-organising software architectures for distributed systems\n", "abstract": " A self-organising software architecture is one in which components automatically configure their interaction in a way that is compatible with an overall architectural specification. The objective is to minimise the degree of explicit management necessary for construction and subsequent evolution whilst preserving the architectural properties implied by its specification. This paper examines the feasibility of using architectural constraints as the basis for the specification, design and implementation of self-organising architectures for distributed systems. Although we focus on organising the structure of systems, we show how component state can influence reconfiguration via interface attributes.", "num_citations": "365\n", "authors": ["46"]}
{"title": "Synthesis of behavioral models from scenarios\n", "abstract": " Scenario-based specifications such as Message Sequence Charts (MSCs) are useful as part of a requirements specification. A scenario is a partial story, describing how system components, the environment, and users work concurrently and interact in order to provide system level functionality. Scenarios need to be combined to provide a more complete description of system behavior. Consequently, scenario synthesis is central to the effective use of scenario descriptions. How should a set of scenarios be interpreted? How do they relate to one another? What is the underlying semantics? What assumptions are made when synthesizing behavior models from multiple scenarios? In this paper, we present an approach to scenario synthesis based on a clear sound semantics, which can support and integrate many of the existing approaches to scenario synthesis. The contributions of the paper are threefold. We first\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "358\n", "authors": ["46"]}
{"title": "Incremental elaboration of scenario-based specifications and behavior models using implied scenarios\n", "abstract": " Behavior modeling has proved to be successful in helping uncover design flaws of concurrent and distributed systems. Nevertheless, it has not had a widespread impact on practitioners because model construction remains a difficult task and because the benefits of behavior analysis appear at the end of the model construction effort. In contrast, scenario-based specifications have a wide acceptance in industry and are well suited for developing first approximations of intended behavior; however, they are still maturing with respect to rigorous semantics and analysis tools.This article proposes a process for elaborating system behavior that exploits the potential benefits of behavior modeling and scenario-based specifications yet ameliorates their shortcomings. The concept that drives the elaboration process is that of implied scenarios. Implied scenarios identify gaps in scenario-based specifications that arise from\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "254\n", "authors": ["46"]}
{"title": "Structuring parallel and distributed programs\n", "abstract": " Darwin is a configuration language which allows distributed and parallel programs to be structured in terms of groups of process instances which communicate by message-passing. In addition to expressing static structure, Darwin can be used to express structures which change dynamically as execution progresses. In this paper, we present a set of examples illustrating the use of Darwin in constructing parallel programs. As processes can be considered as abstractions of physical processors, Darwin can also be used to describe the hardware structure of distributed memory multicomputers in terms of processors and their interconnection. We illustrate this for a multicomputer constructed from transputers and show its use in the process of mapping the logical structure of a parallel program to the physical hardware.", "num_citations": "237\n", "authors": ["46"]}
{"title": "LTSA-WS: a tool for model-based verification of web service compositions and choreography\n", "abstract": " In this paper we describe a tool for a model-based approach to verifying compositions of web service implementations. The tool supports verification of properties created from design specifications and implementation models to confirm expected results from the viewpoints of both the designer and implementer. Scenarios are modeled in UML, in the form of Message Sequence Charts (MSCs), and then compiled into the Finite State Process (FSP) process algebra to concisely model the required behavior. BPEL4WS implementations are mechanically translated to FSP to allow an equivalence trace verification process to be performed. By providing early design verification and validation, the implementation, testing and deployment of web service compositions can be eased through the understanding of the behavior exhibited by the composition. The approach is implemented as a plug-in for the Eclipse development\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "233\n", "authors": ["46"]}
{"title": "Compatibility verification for web service choreography\n", "abstract": " In this paper we discuss a model-based approach to verifying process interactions for coordinated Web service compositions. The approach uses finite state machine representations of Web service orchestrations and assigns semantics to the distributed process interactions. The move towards implementing Web service compositions by multiple interested parties as a form of distributed system architecture motivates the need for supporting compatibility verification of activities and transactions in all the processes. The described approach is supported by a suite of cooperating tools for specification, formal modeling and providing verification results from orchestrated Web service interactions.", "num_citations": "228\n", "authors": ["46"]}
{"title": "Behaviour analysis of software architectures\n", "abstract": " The overall structure of a system described by a set of components and their interconnections is termed its software architecture. In this paper, we associate behavioural specifications with components and use these specifications to analyze the overall system architecture. The approach is based on the use of Labelled Transition Systems to specify behaviour and Compositional Reachability Analysis to check composite system models. The architecture description of a system is used directly in the construction of the model used for analysis. Analysis allows a designer to check whether an architecture satisfies the properties required of it. The paper uses examples to illustrate the approach and discusses some open questions arising from the work.", "num_citations": "223\n", "authors": ["46"]}
{"title": "Methodical analysis of adaptive load sharing algorithms\n", "abstract": " This paper presents a method for qualitative and quantitative analysis of load sharing algorithms, using a number of well known examples as illustration. Algorithm design choices are considered with respect to the main activities of information dissemination and allocation decision making. We argue that nodes must be capable of making local decisions, and for this efficient state dissemination techniques are necessary. Activities related to remote execution should be bounded and restricted to a small proportion of the activity in the system. The quantitative analysis provides both performance and efficiency measures, including consideration of the load and delay characteristics of the environment. To assess stability, which is also a precondition for scalability, we introduce and measure load sharing hit-ratio, the ratio of remote execution requests concluded successfully. Using our analysis method, we are able to suggest improvements to some published algorithms.", "num_citations": "223\n", "authors": ["46"]}
{"title": "Distributed systems and computer networks\n", "abstract": " The authors' objective is to teach the reader the concepts and terminology of distributed systems. Their audience includes senior undergraduates, postgraduates, and working professionals. The emphasis throughout is on issues of connectivity and control as opposed to applications design. Using the ISO Reference Model for Open Systems Interconnection, they arrange the chapters to correspond with the seven layers of the communications system architecture. First, though, they justify the need for distributing applications, databases, and physical resources. This Introduction is succinct and informative. The subsequent chapters are not as useful. A basic decision was made to illustrate various aspects of distributed systems by giving several examples from different implementations. This decision does not work. It leads to unnecessary detail without making any useful points and without giving a thorough explanation\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "202\n", "authors": ["46"]}
{"title": "From goals to components: a combined approach to self-management\n", "abstract": " Autonomous or semi-autonomous systems are deployed in environments where contact with programmers or technicians is infrequent or undesirable. To operate reliably, such systems should be able to adapt to new circumstances on their own. This paper describes our combined approach for adaptable software architecture and task synthesis from high-level goals, which is based on a three-layer model. In the uppermost layer, reactive plans are generated from goals expressed in a temporal logic. The middle layer is responsible for plan execution and assembling a configuration of domain-specific software components, which reside in the lowest layer. Moreover, the middle layer is responsible for selecting alternative components when the current configuration is no longer viable for the circumstances that have arisen. The implementation demonstrates that the approach enables us to handle non-determinism in\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "186\n", "authors": ["46"]}
{"title": "Detecting implied scenarios in message sequence chart specifications\n", "abstract": " Scenario-based specifications such as Message Sequence Charts (MSCs) are becoming increasingly popular as part of a requirements specification. Scenario describe how system components, the environment and users work concurrently and interact in order to provide system level functionality. Each scenario is a partial story which, when combined with other scenarios, should conform to provide a complete system description. However, although it is possible to build a set of components such that each component behaves in accordance with the set of scenarios, their composition may not provide the required system behaviour. Implied scenarios may appear as a result of unexpected component interaction. In this paper, we present an algorithm that builds a labelled transition system (LTS) behaviour model that describes the closest possible implementation for a specification based on basic and high-level\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "183\n", "authors": ["46"]}
{"title": "Viewpoint oriented software development\n", "abstract": " In this paper we propose a new approach to software development which explicitly avoids the use of a single representation scheme or common schema. Instead, multiple ViewPoints are utilised to partition the domain information, the development method and the formal representations used to express software specifications. System specifications and methods are then described as configurations of related ViewPoints. This partitioning of knowledge facilitates distributed development, the use of multiple representation schemes and scalability. Furthermore, the approach is general, covering all phases of the software process from requirements to evolution. This paper motivates and systematically characterises the concept of a \"ViewPoint\", illustrating the concepts using a simplified example.", "num_citations": "183\n", "authors": ["46"]}
{"title": "Conic: an integrated approach to distributed computer control systems\n", "abstract": " Distributed computer control systems (DCCS) have a number of potential advantages over centralised systems, especially where the application is itself physically distributed. A computer station can be placed close to the plant being controlled, and a communications network used to enable the stations to communicate to co-ordinate their actions. However, the software must be carefully designed to exploit the potential advantages of distribution. In the paper, the CONIC architecture for DCCS is described, concentrating on the software structure but also briefly describing the physical architecture designed to support a CONIC system. The software structure emphasises the distinction between the writing of individual software components and the construction and configuration of a system from a set of components. A modular structure is used to separate programming from configuration. Typed entry and exit ports\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "177\n", "authors": ["46"]}
{"title": "Coordinating Distributed ViewPoints: the anatomy of a consistency check\n", "abstract": " Support for concurrent engineering must address the \"multiple perspectives problem\"\u0393\u00c7\u00f6many actors, many representation schemes, diverse domain knowledge, and differing development strategies, all in the context of distributed asynchronous development Central to this problem is the issue of managing consistency between the various elements of an emerging design In this paper we argue that striving to maintain complete consistency at all points in the development process is unnecessary, and an approach based on tolerance and management of inconsistency can be adopted instead. We present a scenario which highlights a number of important issues raised by this approach, and we describe how these issues are addressed in our framework of distributed ViewPoints The approach allows an engineering team to develop independent ViewPoints, and to establish relationships between them incrementally\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "165\n", "authors": ["46"]}
{"title": "Analysing dynamic change in software architectures: a case study\n", "abstract": " The software architecture of a system is the overall structure of the system in terms of its constituent components and their interconnections. Dynamic changes to the instantiated system architecture-to the components and/or interconnections-may take place while it is running. In order that these changes do not violate the integrity of the system, we adopt a general model of dynamic configuration which only permits change to occur when the affected portions of the system are quiescent. In this paper we investigate the ability to perform behaviour analysis on systems which conform to the change model. Our analysis approach associates behavioural specifications with the components of a software architecture and analyses the behaviour of systems composed from these components. We use Labelled Transition Systems to specify behaviour and Compositional Reachability Analysis to check composite system models\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "149\n", "authors": ["46"]}
{"title": "Configuration programming-a framework for the development of distributable systems\n", "abstract": " A brief description is given of the author's use of configuration programming in the conic environment, and an assessment is made of the benefits of such an approach. Based on this experience, the author extends the notions of configuration programming to cover many more aspects of the software development process. Emphasis is on the structural decisions and descriptions for each of the phases in the process, and on the need for compositionality. The configuration programming framework has been adopted as the basis of a recent ESPRIT II Project, REX, on reconfigurable and extensible parallel and distributed systems. This major project uses two large demonstrators in the telecommunication and CIM areas to act as a focus for the work and as a means for demonstrating the techniques and tools developed. A brief description of the development of REX work is used to indicate the general research direction\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "142\n", "authors": ["46"]}
{"title": "A workbench for synthesising behaviour models from scenarios\n", "abstract": " Scenario-based specifications such as Message Sequence Charts (MSCs) are becoming increasingly popular as part of a requirements specification. Our objective is to facilitate the development of behaviour models in conjunction with scenarios. In this paper, we first present an MSC language with semantics in terms of labelled transition systems and parallel composition. The language integrates existing languages based on the use of high-level MSCs (hMSCs) and on identifying component states. This integration allows stakeholders to break up scenario specifications into manageable parts using hMCSs and to explicitly introduce additional information and domain-specific or other assumptions using state labels. Secondly, we present an algorithm, implemented in Java, which translates scenarios into a specification in the form of Finite Sequential Processes. This can then be fed to the labelled transition system\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "139\n", "authors": ["46"]}
{"title": "Context constraints for compositional reachability analysis\n", "abstract": " Behavior analysis of complex distributed systems has led to the search for enhanced reachability analysis techniques which support modularity and which control the state explosion problem. While modularity has been achieved, state explosion in still a problem. Indeed, this problem may even be exacerbated, as a locally minimized subsystem may contain many states and transitions forbidden by its environment or context. Context constraints, specified as interface processes, are restrictions imposed by the environment on subsystem behavior. Recent research has suggested that the state explosion problem can be effectively controlled if context constraints are incorporated in compositional reachability analysis (CRA). Although theoretically very promising, the approach has rarely been  used in practice because it generally requires a more complex computational model and does not contain a mechanism to\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "135\n", "authors": ["46"]}
{"title": "Checking safety properties using compositional reachability analysis\n", "abstract": " The software architecture of a distributed program can be represented  by a hierarchical composition of subsystems, with interacting processes at the leaves of the hierarchy. Compositional reachability analysis (CRA) is a promising state reduction technique which can be automated and used in stages to derive the overall behavior of a distributed program based on its architecture. CRA is particularly suitable for the analysis of programs that are subject to evolutionary change. When a program evolves, only the behaviors of those subsystems affected by the change need be reevaluated. The technique however has a limitation. The properties available for analysis are constrained by the set of actions that remain globally observable. Properties involving actions encapsulated by subsystems  may therefore not be analyzed. In this article, we enhance the CRA technique to check safety properties which may contain\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "133\n", "authors": ["46"]}
{"title": "Model-based analysis of obligations in web service choreography\n", "abstract": " In this paper we discuss a model-based approach to the analysis of service interactions for coordinated web service compositions using obligation policies specified in the form of Message Sequence Charts (MSCs) and implemented in the Web Service Choreography Description Language (WSCDL). The approach uses finite state machine representations of web service compositions (implemented in BPEL4WS) and service choreography rules, and assigns semantics to the distributed process interactions. The move towards implementing web service choreography requires design time verification of these service interactions to ensure that service implementations fulfill requirements for multiple interested partners before such compositions and choreographies are deployed. The described approach is supported by a suite of cooperating tools for specification, formal modeling, animation and providing verification\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "128\n", "authors": ["46"]}
{"title": "Software engineering: a roadmap\n", "abstract": " This paper provides a roadmap for software engineering. It identifies the principal research challenges being faced by the discipline and brings together the threads derived from the key research specialisations within software engineering. The paper draws heavily on the roadmaps covering specific areas of software engineering research collected in this volume.", "num_citations": "118\n", "authors": ["46"]}
{"title": "Inconsistency handling in multi-perspective specifications\n", "abstract": " The development of most large and complex systems necessarily involves many people \u0393\u00c7\u00f6 each with their own perspectives on the system defined by their knowledge, responsibilities, and commitments. To address this we have advocated distributed development of specifications from multiple perspectives. However, this leads to problems of identifying and handling inconsistencies between such perspectives. Maintaining absolute consistency is not always possible. Often this is not even desirable since this can unnecessarily constrain the development process, and can lead to the loss of important information. Indeed since the real-world forces us to work with inconsistencies, we should formalise some of the usually informal or extra-logical ways of responding to them. This is not necessarily done by eradicating inconsistencies but rather by supplying logical rules specifying how we should act on them. To\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "114\n", "authors": ["46"]}
{"title": "Deriving event-based transition systems from goal-oriented requirements models\n", "abstract": " Goal-oriented methods are increasingly popular for elaborating software requirements. They offer systematic support for incrementally building intentional, structural, and operational models of the software and its environment. Event-based transition systems on the other hand are convenient formalisms for reasoning about software behaviour at the architectural level.               The paper relates these two worlds by presenting a technique for translating formal specification of software operations built according to the KAOS goal-oriented method into event-based transition systems analysable by the LTSA toolset. The translation involves moving from a declarative, state-based, timed, synchronous formalism typical of requirements modelling languages to an operational, event-based, untimed, asynchronous one typical of architecture description languages. The derived model can be used for the formal analysis\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "109\n", "authors": ["46"]}
{"title": "Modes for software architectures\n", "abstract": " Modern systems are heterogeneous, geographically distributed and highly dynamic since the communication topology can vary and the components can, at any moment, connect to or detach from the system. Service Oriented Computing (SOC) has emerged as a suitable paradigm for specifying and implementing such global systems. The variety and dynamics in the possible scenarios implies that considering such systems as belonging to a single architectural style is not helpful. This considerations take us to propose the notion of Mode as a new element of architectural descriptions. A mode abstracts a specific set of services that must interact for the completion of a specific subsystem task. This paper presents initial ideas regarding the formalization of modes and mode transitions as explicit elements of architectural descriptions with the goal of providing flexible support for the description and verification of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "109\n", "authors": ["46"]}
{"title": "Learning operational requirements from goal models\n", "abstract": " Goal-oriented methods have increasingly been recognised as an effective means for eliciting, elaborating, analysing and specifying software requirements. A key activity in these approaches is the elaboration of a correct and complete set of opertional requirements, in the form of pre- and trigger-conditions, that guarantee the system goals. Few existing approaches provide support for this crucial task and mainly rely on significant effort and expertise of the engineer. In this paper we propose a tool-based framework that combines model checking, inductive learning and scenarios for elaborating operational requirements from goal models. This is an iterative process that requires the engineer to identify positive and negative scenarios from counterexamples to the goals, generated using model checking, and to select operational requirements from suggestions computed by inductive learning.", "num_citations": "103\n", "authors": ["46"]}
{"title": "Stateful distributed event processing and adaptive security\n", "abstract": " The invention provides method and apparatus for maintaining a networked computer system including first and second nodes and an event processing server, the method comprising the first and second nodes detecting changes in state, the event processing server receiving notification of the changes in state from the first and second nodes, the event processing server correlating changes in state detected in the first and second nodes, and the event processing server executing a maintenance decision which affects the first and second nodes. The detecting, transmitting, correlating, and executing occurs without human intervention.", "num_citations": "101\n", "authors": ["46"]}
{"title": "An abductive approach for analysing event-based requirements specifications\n", "abstract": " We present a logic and logic programming based approach for analysing event-based requirements specifications given in terms of a system\u0393\u00c7\u00d6s reaction to events and safety properties. The approach uses a variant of Kowalski and Sergot\u0393\u00c7\u00d6s Event Calculus to represent such specifications declaratively and an abductive reasoning mechanism for analysing safety properties. Given a system description and a safety property, the abductive mechanism is able to identify a complete set of counterexamples (if any exist) of the property in terms of symbolic \u0393\u00c7\u00a3current\u0393\u00c7\u00a5 states and associated event-based transitions. A case study of an automobile cruise control system specified in the SCR framework is used to illustrate our approach. The technique described is implemented using existing tools for abductive logic programming.", "num_citations": "101\n", "authors": ["46"]}
{"title": "Graphical configuration programming\n", "abstract": " The structural description, construction, and evolution of software systems using the Conic graphs environment are discussed. The configuration programming concepts embodied in conic are described and illustrated by the example of a patient monitoring system. The characteristics of the ConicDraw graphic workstation are examined. Browsing and animation extensions are described.< >", "num_citations": "101\n", "authors": ["46"]}
{"title": "Graphical animation of behavior models\n", "abstract": " Graphical animation is a way of visualizing the behavior of design models. This visualization is of use in validating a design model against informally specified requirements and in interpreting the meaning and significance of analysis results in relation to the problem domain. The authors describe how behavior models specified by Labeled Transition Systems (LTS) can drive graphical animations. The semantic framework for the approach is based on Timed Automata. Animations are described by an XML document that is used to generate a set of JavaBeans. The elaborated JavaBeans perform the animation actions as directed by the LTS model.", "num_citations": "100\n", "authors": ["46"]}
{"title": "Method engineering for multi-perspective software development\n", "abstract": " This paper examines the role of the method engineer in the context of multi-perspective software development. Such development is characterized by the existence of multiple development participants who hold multiple views on a system and its domain. These views may be described and developed using multiple representation schemes and development strategies respectively. The paper outlines the Viewpoints framework\u0393\u00c7\u00f6an organizational framework developed to model such a scenario\u0393\u00c7\u00f6and then examines the method engineering process required to support the kind of multi-perspective development described. The role of tool support in this context is also explored.", "num_citations": "95\n", "authors": ["46"]}
{"title": "Maintaining node consistency in the face of dynamic change\n", "abstract": " With the increasing demand for long running and highly available distributed services, interest in systems which can undergo dynamic reconfiguration has risen. However for dynamic change to yield valid systems, change actions must be carried out such that the consistency of the software modules making up the system is not breached. This can be ensured if the subset of the system which is to undergo change is in a state amenable to reconfiguration. This paper presents an algorithm which imposes a safe state over the part of the system undergoing change. The algorithm suits a particular class of transactional systems and places special emphasis on minimising the interference to the rest of the system and reducing the programmer contribution necessary for achieving this safe state.", "num_citations": "93\n", "authors": ["46"]}
{"title": "A constructive approach to the design of distributed systems\n", "abstract": " The underlying model of distributed systems is that of loosely coupled components running in parallel and communicating by message passing. Description, construction and evolution of these systems is facilitated by separating the system structure, as a set of components and their interconnections, from the functional description of individual component behaviour. The Conic environment for distributed programming supports this model. In particular, Conic provides a separate configuration language for the description, construction and evolution of distributed systems. The Conic environment has demonstrated a working environment which supports system distribution, reconfiguration and extension. The principles of explicit system structure and context independent components that underlie Conic have lead naturally to a design approach which differs from that of both current industrial practice and current\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "91\n", "authors": ["46"]}
{"title": "Configuring object-based distributed programs in REX\n", "abstract": " The popularity of the object-oriented programming paradigm has stimulated research into its use for parallel and distributed programming. The major issues that affect such use are concurrency control, object interfaces, binding and inheritance. In this paper, we discuss the relative merits of current solutions to these issues and describe an approach based on the use of active objects with essentially explicit interfaces and bindings, and composition as a pragmatic alternative to inheritance. The key feature of our approach is the use of a configuration language to define program structure as a set of objects and their bindings. The configuration language includes facilities for hierarchic definition of composite objects, parameterisation of objects, conditional configurations and recursive definition of objects. This separate and explicit description of program structure complements object-oriented programming. The\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "90\n", "authors": ["46"]}
{"title": "Monitoring and control in scenario-based requirements analysis\n", "abstract": " Scenarios are an effective means for eliciting, validating and documenting requirements. At the requirements level, scenarios describe sequences of interactions between the software-to-be and agents in the environment. Interactions correspond to the occurrence of an event that is controlled by one agent and monitored by another. This paper presents a technique to analyse requirements-level scenarios for unforeseen, potentially harmful, consequences. Our aim is to perform analysis early in system development, where it is highly cost-effective. The approach recognises the importance of monitoring and control issues and extends existing work on implied scenarios accordingly. These so-called input-output implied scenarios expose problematic behaviours in scenario descriptions that cannot be detected using standard implied scenarios. Validation of these implied scenarios supports requirements elaboration\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "89\n", "authors": ["46"]}
{"title": "Analysing the behaviour of distributed software architectures: a case study\n", "abstract": " A software architecture is the overall structure of a system in terms of its constituent components and their interconnections. We describe work to associate behavioural specifications with the components of a distributed software architecture and an approach to analysing the behaviour of systems composed from these components. The approach is based on the use of labelled transition systems to specify behaviour and compositional reachability analysis to check composite system models. The architecture description of a system is used directly to generate the model used for analysis. Analysis allows a designer to check whether an architecture satisfies the properties required of it. The approach is illustrated using a case study of an active badge system.", "num_citations": "87\n", "authors": ["46"]}
{"title": "Tool support for model-based engineering of web service compositions\n", "abstract": " In this paper we describe tool support for a model-based approach to verifying compositions of Web service implementations. The tool supports verification of properties created from design specifications and implementation models to confirm expected results from the viewpoints of both the designer and implementer. Scenarios are modeled in UML, in the form of message sequence charts (MSCs), and then compiled into the finite state process (FSP) algebra to concisely model the required behavior. BPEL4WS implementations are mechanically translated to FSP to allow an equivalence trace verification process to be performed. By providing early design verification and validation, the implementation, testing and deployment of Web service compositions can be eased through the understanding of the behavior exhibited by the composition. The tool is implemented as a plug-in for the Eclipse development\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "86\n", "authors": ["46"]}
{"title": "Analysing dynamic change in distributed software architectures\n", "abstract": " The software architecture of a system is the overall structure of the system in terms of its constituent components and their interconnections. Dynamic changes to the instantiated system architecture (to the components and/or interconnections) may take place while it is running. In order that these changes do not violate the integrity of the system, we adopt a general model of dynamic configuration which only permits change to occur when the affected portions of the system are quiescent. This paper investigates the feasibility of performing behaviour analysis on systems which conform to the change model. The analysis approach associates behavioural specifications with the components of a software architecture and analyses the behaviour of systems composed from these components. The changes that can occur are modelled as constraints on the architecture, thereby permitting incremental and even concurrent\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "83\n", "authors": ["46"]}
{"title": "Enhancing compositional reachability analysis with context constraints\n", "abstract": " Compositional techniques have been proposed for traditional reachability analysis in order to introduce modularity and to control the state explosion problem. While modularity has been achived, state explosion is still a problem. Indeed, this problem may even be exacerbated as a locally minimised subsystem may contain many states and transitions forbidden by its context or environments. This paper presents a method to alleviate this problem effectively by including context constraints in local subsystem minimisation. The global behaviour generated using the method is observationally equivalent to that generated by compositional reachability analysis without the inclusion of context constraints. Context constraints, specified as interface processes, are restrictions imposed by the environment on subsystem behaviour. The minimisation produces a simplified machine that describes the behaviour of the subsystem\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "82\n", "authors": ["46"]}
{"title": "Composing distributed objects in CORBA\n", "abstract": " The paper addresses the problem of structuring and managing large distributed systems constructed from many distributed objects. Specifically, the paper proposes a component model which can be used to compose objects into manageable entities. Components are specified using Darwin, an architecture description language developed by the authors. A mapping of distributed objects into Darwin components is described together with an outline of how Darwin and its associated tools are implemented in a CORBA compliant environment.", "num_citations": "81\n", "authors": ["46"]}
{"title": "Model checking service compositions under resource constraints\n", "abstract": " When enacting a web service orchestration defined using the Business Process Execution Language (BPEL) we observed various safety property violations. This surprised us considerably as we had previously established that the orchestration was free of such property violations using existing BPEL model checking techniques. In this paper, we describe the origins of these violations. They result from a combination of design and deployment decisions, which include the distribution of services across hosts, the choice of synchronisation primitives in the process and the threading configuration of the servlet container that hosts the orchestrated web services. This leads us to conclude that model checking approaches that ignore resource constraints of the deployment environment are insufficient to establish safety and liveness properties of service orchestrations specifically, and distributed systems more generally\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "80\n", "authors": ["46"]}
{"title": "Checking subsystem safety properties in compositional reachability analysis\n", "abstract": " The software architecture of a distributed program can be represented by an hierarchical composition of subsystems, with interacting processes at the leaves of the hierarchy. Compositional reachability analysis has been proposed as a promising automated method to derive the overall behavior of a distributed program in stages, based on its architecture. The method is particularly suitable for the analysis of programs which are subject to evolutionary change. When a program evolves, only behavior of those subsystems affected by the change need be re-evaluated. The method however has a limitation. The properties available for analysis are constrained by the set of actions that remain globally observable. The properties of subsystems, may not be analyzed. We extend the method to check safety properties of subsystems which may contain actions that are not globally observable. These safety properties can still\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "78\n", "authors": ["46"]}
{"title": "An architecture for managing distributed systems\n", "abstract": " The authors describe an architecture for managing distributed systems which has been jointly specified by two Esprit projects, SYSMAN (7026) and IDSM (6311). The emphasis, in this architecture, is on the use of domains to group managed objects and partition the management structure to cope with very large scale inter-organizational distributed systems. Another key aspect of the architecture is a policy service to support the specification, storage and manipulation of policies which can be used to influence the behavior of automated managers. The architecture advocates the use of object-based distributed processing techniques for management and essentially extends the OSF DME approach to cater to domains and policies as underlying management services for all aspects of management.< >", "num_citations": "78\n", "authors": ["46"]}
{"title": "Negative scenarios for implied scenario elicitation\n", "abstract": " Scenario-based specifications such as Message Sequence Charts (MSCs) are popular for requirement elicitation and specification. MSCs describe two distinct aspects of a system: on the one hand they provide examples of intended system behaviour and on the other they outline the system architecture. A mismatch between architecture and behaviour may give rise to implied scenarios. Implied scenarios occur because a component's local view of the system state is insufficient to enforce specified system behaviour. An implied scenario indicates a gap in the MSC specification that needs to be clarified. It may simply mean that an acceptable scenario has been overlooked and should be added to the scenario specification. Alternatively, it may represent an unacceptable behaviour which should be documented and avoided in the final implementation. Thus implied scenarios can be used to iteratively drive\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "76\n", "authors": ["46"]}
{"title": "Flashmob: distributed adaptive self-assembly\n", "abstract": " Autonomous systems need to support dynamic software adaptation in order to handle the complexity and unpredictability of the execution environment, and the changing needs of the end user. Although a number of approaches have been proposed, few address a key issue: that of distribution.", "num_citations": "73\n", "authors": ["46"]}
{"title": "Verification of liveness properties using compositional reachability analysis\n", "abstract": " The software architecture of a distributed program can be represented by a hierarchical composition of subsystems, with interacting processes at the leaves of the hierarchy. Compositional reachability analysis (CRA) is a promising state reduction technique which can be automated and used to derive in stages the overall behaviour of a distributed program based on its architecture. Conventional CRA however has a limitation. The properties available for analysis after composition and reduction are constrained by the set of actions that remain globally observable. The liveness properties which involve internal actions of subsystems may therefore not be analysed. In this paper, we extend compositional reachability analysis to check liveness properties which may involve actions that are not globally observable. In particular, our approach permits the hiding of actions independently of the liveness properties that\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "73\n", "authors": ["46"]}
{"title": "Learning revised models for planning in adaptive systems\n", "abstract": " Environment domain models are a key part of the information used by adaptive systems to determine their behaviour. These models can be incomplete or inaccurate. In addition, since adaptive systems generally operate in environments which are subject to change, these models are often also out of date. To update and correct these models, the system should observe how the environment responds to its actions, and compare these responses to those predicted by the model. In this paper, we use a probabilistic rule learning approach, NoMPRoL, to update models using feedback from the running system in the form of execution traces. NoMPRoL is a technique for nonmonotonic probabilistic rule learning based on a transformation of an inductive logic programming task into an equivalent abductive one. In essence, it exploits consistent observations by finding general rules which explain observations in terms of the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "72\n", "authors": ["46"]}
{"title": "Hope for the best, prepare for the worst: multi-tier control for adaptive systems\n", "abstract": " Most approaches for adaptive systems rely on models, particularly behaviour or architecture models, which describe the system and the environment in which it operates. One of the difficulties in creating such models is uncertainty about the accuracy and completeness of the models. Engineers therefore make assumptions which may prove to be invalid at runtime. In this paper we introduce a rigorous, tiered framework for combining behaviour models, each with different associated assumptions and risks. These models are used to generate operational strategies, through techniques such controller synthesis, which are then executed concurrently at runtime. We show that our framework can be used to adapt the functional behaviour of the system: through graceful degradation when the assumptions of a higher level model are broken, and through progressive enhancement when those assumptions are satisfied or\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "67\n", "authors": ["46"]}
{"title": "LTSA-MSC: Tool support for behaviour model elaboration using implied scenarios\n", "abstract": " We present a tool that supports the elaboration of behaviour models and scenario-based specification by providing scenario editing, behaviour model synthesis, and model checking for implied scenarios.", "num_citations": "67\n", "authors": ["46"]}
{"title": "Behaviour analysis of distributed systems using the tracta approach\n", "abstract": " Behaviour analysis should form an integral part of the software development process. This is particularly important in the design of concurrent and distributed systems, where complex interactions can cause unexpected and undesired system behaviour. We advocate the use of a compositional approach to analysis. The software architecture of a distributed program is represented by a hierarchical composition of subsystems, with interacting processes at the leaves of the hierarchy. Compositional reachability analysis (CRA) exploits the compositional hierarchy for incrementally constructing the overall behaviour of the system from that of its subsystems. In the Tracta CRA approach, both processes and properties reflecting system specifications are modelled as state machines. Property state machines are composed into the system and violations are detected on the global reachability graph obtained. The\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "67\n", "authors": ["46"]}
{"title": "A rigorous architectural approach to adaptive software engineering\n", "abstract": " The engineering of distributed adaptive software is a complex task which requires a rigorous approach. Software architectural (structural) concepts and principles are highly beneficial in specifying, designing, analysing, constructing and evolving distributed software. A rigorous architectural approach dictates formalisms and techniques that are compositional, components that are context independent and systems that can be constructed and evolved incrementally. This paper overviews some of the underlying reasons for adopting an architectural approach, including a brief \u0393\u00c7\u00a3rational history\u0393\u00c7\u00a5 of our research work, and indicates how an architectural model can potentially facilitate the provision of self-managed adaptive software system.", "num_citations": "65\n", "authors": ["46"]}
{"title": "A case study in goal-driven architectural adaptation\n", "abstract": " To operate reliably in environments where interaction with an operator is infrequent or undesirable, an autonomous system should be capable of both determining how to achieve its objectives and adapting to novel circumstances on its own. We have developed an approach to constructing autonomous systems that synthesise tasks from high-level goals and adapt their software architecture to perform these tasks reliably in a changing environment. This paper presents our approach through a detailed case study, highlighting the challenges involved.", "num_citations": "64\n", "authors": ["46"]}
{"title": "Exposing the skeleton in the coordination closet\n", "abstract": " One of the ways in which we cope with large and complex systems is to abstract away some of the detail, considering them at an architectural level as compositions of interacting components. To this end, the variously termed Coordination, Configuration and Architectural Description Languages (ADL) facilitate description, comprehension and reasoning at that level, providing a clean separation between individual component behaviour and their interaction in a software architecture. However, in the search to provide sufficient detail for reasoning, analysis or construction, many approaches are in danger of obscuring the essential structural aspect of the architecture, thereby losing the benefit of abstraction. In this paper we argue for the use of a concise and simple language explicitly designed for describing architectural structures. This can be used to provide the \"skeleton\" upon which to add the particular\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "64\n", "authors": ["46"]}
{"title": "Exploiting non-functional preferences in architectural adaptation for self-managed systems\n", "abstract": " Among the many challenges of engineering dependable, self-managed, component-based systems is their need to make informed decisions about adaptive reconfigurations in response to changing requirements or a changing environment. Such decisions may be made on the basis of non-functional or QoS aspects of reconfiguration in addition to the purely functional properties needed to meet a goal. We present a practical approach for using non-functional information to guide a procedure for assembling, and subsequently modifying, configurations of software components, and compare the performance of two variants of the approach. In addition, we outline a scheme for monitoring non-functional properties in the running system such that more accurate information can be utilised in the next adaptation.", "num_citations": "63\n", "authors": ["46"]}
{"title": "Plan-directed architectural change for autonomous systems\n", "abstract": " Autonomous systems operate in an unpredictable world, where communication with those people responsible for its software architecture may be infrequent or undesirable. If such a system is to continue reliable operation it must be able to derive and initiate adaptations to new circumstances on its own behalf. Much of the previous work on dynamic reconfigurations supposes that the programmer is able to express the possible adaptations before the system is deployed, or at least is able to add new adaptation strategies after deployment. We consider the challenges in providing an autonomous system with the capability to direct its own adaptation, and describe an initial implementation where change in the software architecture of an autonomous system is enacted as a result of executing a reactive plan.", "num_citations": "61\n", "authors": ["46"]}
{"title": "Behaviour model elaboration using partial labelled transition systems\n", "abstract": " State machine based formalisms such as labelled transition systems (LTS) are generally assumed to be complete descriptions of system behaviour at some level of abstraction: if a labelled transition system cannot exhibit a certain sequence of actions, it is assumed that the system or component it models cannot or should not exhibit that sequence. This assumption is a valid one at the end of the modelling effort when reasoning about properties of the completed model. However, it is not a valid assumption when behaviour models are in the process of being developed. In this setting, the distinction between proscribed behaviour and behaviour that has not yet been defined is an important one. Knowing where the gaps are in a behaviour model permits the presentation of meaningful questions to stakeholders, which in turn can lead to model exploration and thus more comprehensive descriptions of the system\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "61\n", "authors": ["46"]}
{"title": "Scalable, adaptive load sharing for distributed systems\n", "abstract": " Presents a flexible load-sharing algorithm which achieves scalability by partitioning a system into domains. Each node dynamically and adaptively selects other nodes to be included in its domain. FLS applies load sharing within each domain, independently of how it is applied within other domains.< >", "num_citations": "61\n", "authors": ["46"]}
{"title": "Morph: A reference architecture for configuration and behaviour self-adaptation\n", "abstract": " An architectural approach to self-adaptive systems involves runtime change of system configuration (ie, the system's components, their bindings and operational parameters) and behaviour update (ie, component orchestration). Thus, dynamic reconfiguration and discrete event control theory are at the heart of architectural adaptation. Although controlling configuration and behaviour at runtime has been discussed and applied to architectural adaptation, architectures for self-adaptive systems often compound these two aspects reducing the potential for adaptability. In this paper we propose a reference architecture that allows for coordinated yet transparent and independent adaptation of system configuration and behaviour.", "num_citations": "59\n", "authors": ["46"]}
{"title": "ViewPoint oriented software development: Methods and viewpoints in requirements engineering\n", "abstract": " This paper outlines progress on: developing methods to support requirements formalisation; incremental development of formal specifications; tool support for requirements expression; modelling requirements elicitation. A central thread in this work the -concept of \"ViewPoint\"- is examined, motivated and systematically characterised. The implications for methods to support the construction of formal specifications are considered. A framework for further work is outlined.", "num_citations": "59\n", "authors": ["46"]}
{"title": "Ws-engineer: A model-based approach to engineering web service compositions and choreography\n", "abstract": " In this chapter, we describe a model-based approach to the analysis of service interactions for web service choreography and their coordinated compositions. The move towards implementing web service choreography requires both design time verification and execution time validation of these service interactions to ensure that service implementations fulfil requirements of multiple interested partners before such compositions and choreographies are deployed for use. The approach employs several formal analysis techniques and perspectives, and applies these to the domain of web service choreographies and the compositional implementations that each role in these choreographies must satisfy. Our approach models the service interaction designs of choreographies (in the form of Message Sequence Charts), the service choreography descriptions (in WS-CDL \u0393\u00c7\u00f4 the Web Service Choreography\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "56\n", "authors": ["46"]}
{"title": "Distributed software engineering\n", "abstract": " The term \"distributed software engineering\" is ambiguous. It includes both the engineering of distributed software and the process of distributed development of software, such as cooperative work. This paper concentrates on the former, giving an indication of the special needs and rewards in distributed computing. In essence, we argue that the structure of these systems as interacting components is a blessing which forces software engineers towards compositional techniques which offer the best hope for constructing scalable and evolvable systems in an incremental manner. We offer some guidance and recommendations as to the approaches which seem most appropriate, particularly in languages for distributed programming, specification and analysis techniques for modeling and distributed paradigms for guiding design.< >", "num_citations": "55\n", "authors": ["46"]}
{"title": "The future of software engineering\n", "abstract": " Anthony Finkelstein< a. finkelstein@ cs. ucl. ac. uk>[2019: please note that most of these links (from 2000) are no longer valid but are left intact for historical reasons. Some of these links resolve using the WayBackMachine]", "num_citations": "54\n", "authors": ["46"]}
{"title": "Self organising software architectures\n", "abstract": " In this position paper, we identify a class of architectures in which components are required to configure themselves into a system in a way which is consistent with an overall specification of that system\u0393\u00c7\u00d6s architecture. We term these architectures \u0393\u00c7\u00a3Self Organising\u0393\u00c7\u00a5 since the objective is to minimise the degree of explicit management necessary for construction and subsequent evolution. Systems of this class evolve dynamically as new components are introduced and as existing components are removed. The paper motivates the need for this type of architecture and examines the requirements for an Architectural Description Language which could be used both to specify this class of system and play a part in its construction and execution.", "num_citations": "54\n", "authors": ["46"]}
{"title": "Fluent temporal logic for discrete-time event-based models\n", "abstract": " Fluent model checking is an automated technique for verifying that an event-based operational model satisfies some state-based declarative properties. The link between the event-based and state-based formalisms is defined through\" fluents\" which are state predicates whose value are determined by the occurrences of initiating and terminating events that make the fluents values become true or false, respectively. The existing fluent temporal logic is convenient for reasoning about untimed event-based models but difficult to use for timed models. The paper extends fluent temporal logic with temporal operators for modelling timed properties of discrete-time event-based models. It presents two approaches that differ on whether the properties model the system state after the occurrence of each event or at a fixed time rate. Model checking of timed properties is made possible by translating them into the existing\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "51\n", "authors": ["46"]}
{"title": "Compositional reachability analysis of finite-state distributed systems with user-specified constraints\n", "abstract": " The software architecture of a distributed system can be described as a hierarchical composition of subsystems, with interacting processes as the leaves of the hierarchy. Process behaviour can be specified using finite-state machines. A global state machine describing the overall system behaviour can be constructed using compositional reachability analysis techniques. These techniques compose the global state machine of a system from its component processes in stages, based on the specified hierarchy, This staged composition may however exacerbate the state explosion problem. A promising way to alleviate this problem is to include, in the analysis of each subsystem, the behaviour constraints imposed by its environment. Behaviour constraints can be derived algorithmically but may be too weak to adequately constrain the compositional analysis.In this paper, we describe a technique which enables\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "49\n", "authors": ["46"]}
{"title": "Generating obstacle conditions for requirements completeness\n", "abstract": " Missing requirements are known to be among the major causes of software failure. They often result from a natural inclination to conceive over-ideal systems where the software-to-be and its environment always behave as expected. Obstacle analysis is a goal-anchored form of risk analysis whereby exceptional conditions that may obstruct system goals are identified, assessed and resolved to produce complete requirements. Various techniques have been proposed for identifying obstacle conditions systematically. Among these, the formal ones have limited applicability or are costly to automate. This paper describes a tool-supported technique for generating a set of obstacle conditions guaranteed to be complete and consistent with respect to the known domain properties. The approach relies on a novel combination of model checking and learning technologies. Obstacles are iteratively learned from\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "47\n", "authors": ["46"]}
{"title": "Detecting implied scenarios from execution traces\n", "abstract": " A scenario describes how one or more system components interact to provide a certain set of functionalities. Because each scenario only represents a partial view of the overall system behavior, scenario-based specifications may hide unexpected interactions (called implied scenarios) which are not part of any scenario individually. Implied scenarios may either indicate gaps in the original scenario specification, or undesired behavior that should be avoided during scenario implementation. This paper presents a reverse engineering environment to support extraction and detection of implied scenarios from execution traces. The main contribution of the paper is to demonstrate how the concept of implied scenarios, thus far restricted to early phases of the software life-cycle, such as requirements elaboration and reliability prediction, can also be applied to support comprehension and testing of existing systems.", "num_citations": "46\n", "authors": ["46"]}
{"title": "Combining abductive reasoning and inductive learning to evolve requirements specifications\n", "abstract": " The development of requirements specifications inevitably involves modification and evolution. To support modification while preserving particular requirements goals and properties, the use of a cycle composed of two phases: analysis and revision is proposed. In the analysis phase, a desirable property of the system is checked against a partial specification. Should the property be violated, diagnostic information is provided. In the revision phase, the diagnostic information is used to help modify the specification in such a way that the new specification no longer violates the original property. An instance of the above analysis\u0393\u00c7\u00f4revision cycle that combines new techniques of logical abduction and inductive learning to analyse and revise specifications, respectively is investigated. More specifically, given an (event-based) system description and a system property, abductive reasoning is applied in refutation mode to\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "46\n", "authors": ["46"]}
{"title": "An overview of the REX software architecture\n", "abstract": " The authors describe the software architecture currently under development for the REX (reconfigurable and extensible parallel and distributed systems) project, supported by the European Economic Community under the ESPRIT II initiative. The architecture is aimed at supporting the construction of reconfigurable and extensible parallel and distributed systems. The main principle underlying this architecture is that systems should be described, constructed, and modified as a structural configuration of interconnected component instances. The structure should be described by a separate explicit configuration language allowing components to be programmed in a range of heterogeneous programming languages. The authors given an informal description of three elements of architecture, namely, an interface specification language, a set of communication primitives, and a language for describing overall system\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "45\n", "authors": ["46"]}
{"title": "Tractable dataflow analysis for distributed systems\n", "abstract": " Automated behavior analysis is a valuable technique in the development and maintenance of distributed systems. In this paper, we present a tractable dataflow analysis technique for the detection of unreachable states and actions in distributed systems. The technique follows an approximate approach described by Reif and Smolka, but delivers a more accurate result in assessing unreachable states and actions. The higher accuracy is achieved by the use of two concepts: action dependency and history sets. Although the technique does not exhaustively detect all possible errors, it detects nontrivial errors with a worst-case complexity quadratic to the system size. It can be automated and applied to systems with arbitrary loops and nondeterministic structures. The technique thus provides practical and tractable behavior analysis for preliminary designs of distributed systems. This makes it an ideal candidate for an\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "43\n", "authors": ["46"]}
{"title": "Configuring distributed systems\n", "abstract": " Distributed systems are constructed from a set of computational components which are bound together to interact and communicate to achieve some over all objective. In this paper, we examine the issues related to system configuration, particularly those related to component binding. We argue that there is a need for tools to aid the initial construction and subsequent management of the structure of distributed systems. Currently, distributed systems are most commonly structured using a client/server approach. Servers register the service they provide by installing the name and type of the service together with a reference to that service in a distinguished server generally known as a name server. Clients bind to a particular service by looking up the reference in a name server (the reference to which must be well known). Once the client has retrieved the service reference, the service may be directly invoked (although\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "43\n", "authors": ["46"]}
{"title": "Configuration management for distributed software services\n", "abstract": " The paper describes the SysMan approach to interactive configuration management of distributed software components (objects). Domains are used to group objects to apply policy and for convenient naming of objects. Configuration Management involves using a domain browser to locate relevant objects within the domain service; creating new objects which form a distributed service; allocating these objects to physical nodes in the system and binding the interfaces of the objects to each other and to existing services. Dynamic reconfiguration of the objects forming a service can be accomplished using this tool. Authorisation policies specify which domains are accessible by which managers and which interfaces can be bound together.", "num_citations": "42\n", "authors": ["46"]}
{"title": "Using resemblance to support component reuse and evolution\n", "abstract": " The aim of a component-based approach to software is to allow the construction of a system by reusing and connecting together a number of existing components. To successfully reuse a component, alterations generally need to be made to it, particularly if the abstraction level is high. However, existing usage of a component means that it cannot be altered without affecting the systems that reuse it already. This leads to a dilemma which frustrates the goals of the compositional approach to reuse. To help resolve this dilemma, we introduce the resemblance construct, allowing a new component to be defined in terms of changes to a base component. This allows us to effectively alter a base component for reuse, without affecting the existing definition or any users of the component. We use an example to show how this and other constructs ameliorate the reuse problems of complex, possibly composite, components.", "num_citations": "40\n", "authors": ["46"]}
{"title": "Fluent-based animation: Exploiting the relation between goals and scenarios for requirements validation\n", "abstract": " Scenarios and goals are effective and popular techniques for requirements definition. Validation is essential in order to ensure that they represent what stakeholders actually want. Rather than validating scenarios and goals separately, possibly driving the elaboration of one through the validation of the other, This work focuses on exploiting the relation between goals and scenarios. The aim is to provide effective graphical animations as a means of validating both. Goals are objectives that a system is to meet. They are elaborated into a structure that decomposes declarative goals into goals that can be formulated in terms of events that can be controlled or monitored by the system. Scenarios are operational examples of system usage. The relation between scenarios and goals is established by means of fluents that describe how events of the operational description change the state of the basic propositions from\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "40\n", "authors": ["46"]}
{"title": "The Koala Component Model\n", "abstract": " Rob van Ommering, Frank van der Linden, Jeff Kramer, Jeff Magee, IEEE Computer, March 2000, p78-85. Abstract: A component-oriented approach is an ideal way to handle the diversity of software in consumer electronics. The Koala model, used for embedded software in TV sets, allows late binding of reusable components with no additional overhead.", "num_citations": "40\n", "authors": ["46"]}
{"title": "Elaborating requirements using model checking and inductive learning\n", "abstract": " The process of Requirements Engineering (RE) includes many activities, from goal elicitation to requirements specification. The aim is to develop an operational requirements specification that is guaranteed to satisfy the goals. In this paper, we propose a formal, systematic approach for generating a set of operational requirements that are complete with respect to given goals. We show how the integration of model checking and inductive learning can be effectively used to do this. The model checking formally verifies the satisfaction of the goals and produces counterexamples when incompleteness in the operational requirements is detected. The inductive learning process then computes operational requirements from the counterexamples and user-provided positive examples. These learned operational requirements are guaranteed to eliminate the counterexamples and be consistent with the goals. This process is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "39\n", "authors": ["46"]}
{"title": "Software architecture modeling & analysis: A rigorous approach\n", "abstract": " In this overview paper, we outline a tool supported approach to the design and analysis of complex systems at the architectural level. The foundations of this approach are the use of the architectural description language Darwin to capture structural information about components and their interconnection and the use of a process algebra FSP to describe the behaviour of individual components. These descriptions are combined to construct a system behavioural model that can be animated to validate requirements and model checked against properties specified in Linear Temporal Logic. Recently, this foundation has been extended with work on the synthesis of behavioural models from scenarios captured as message sequence charts (MSC). Models described in this way can be used as an initial basis for validating requirements and as a specification that must be satisfied by more detailed models. The\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "39\n", "authors": ["46"]}
{"title": "Tool support for requirements analysis\n", "abstract": " This paper describes an approach to the provision of tool support for two particular aspects of requirements analysis: method support by active guidance, and specification interpretation and validation by animation. Method guidance is supported by a method model used to describe the sequence of method steps that should be followed. Animation provides an indication of the dynamic behaviour of the specified system by walking through a specification fragment to follow some scenario of interest. This approach to tool assistance has been tested by implementing a prototype set of tools for the CORE method and the Analyst workstation, and by application to a major case study. The current status of that work is described and evaluated.", "num_citations": "39\n", "authors": ["46"]}
{"title": "A model for change management\n", "abstract": " The requirements needed to manage arbitrary changes to a system configuration are analyzed, and a model which separates application concerns from those at the configuration level is presented. This permits the formulation of general structural rules for change without the need to consider application state, as well as the specification of application actions without knowledge of the actual changes which might be introduced. The changes can be affected in such a way as to leave the modified system in a consistent state and cause minimal disturbance to the application during change. The model is applied to an example problem, the'evolving philosophers' problem. The principles described in this model have been implemented and tested in the Conic environment for distributed systems.<>", "num_citations": "39\n", "authors": ["46"]}
{"title": "A CASE tool for software architecture design\n", "abstract": " This paper describes the Software Architect's Assistant, an automated visual tool for the design and construction of Regis distributed programs. Unlike conventional CASE tools and their supported methodologies, the Architect's Assistant supports a compositional approach to program development in which the software architecture plays a central role throughout the software life-cycle\u0393\u00c7\u00f6from the early design stage through to system management and evolution.               In its implementation, we have addressed some of the limitations of existing CASE tools, particularly in the degree of automated support offered to the human developer. Conscious effort has been made to maximise usability and efficiency, primarily by enhancing the level of automation and flexibility together with careful design of the user interface. Our objective is to provide a tool which automates all mundane clerical tasks, enforces program\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "38\n", "authors": ["46"]}
{"title": "Requirements for an effective architecture recovery framework\n", "abstract": " In this paper we discuss how some limitations of current reverse engineering approaches prevent them from recovering architectures effectively from legacy systems. We classify several reverse engineering tools and systems into five distinct frameworks. We then propose a set of requirements for an effective architecture recovery framework which benefits from the main features of those five frameworks and tries to overcome their identified limitations..", "num_citations": "37\n", "authors": ["46"]}
{"title": "Fine-grain process modelling\n", "abstract": " We propose the use of fine-grain process modelling as an aid to software development. We suggest the use of two levels of granularity, one at the level of the individual developer and another at the level of the representation scheme used by that developer. The advantages of modelling the software development process at these two levels, we argue, include respectively: the production of models that better reflect actual development processes because they are oriented towards the actors who enact them; and models that are vehicles for providing guidance because they may be expressed in terms of the actual representation schemes employed by those actors. We suggest that the previously published approach (A. Finkelstein et al., 1990; 1992) of using multiple \"ViewPoints\" to model software development participants, the perspectives that they hold, the representation schemes that they deploy and the process\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "37\n", "authors": ["46"]}
{"title": "Software architecture directed behaviour analysis\n", "abstract": " A Software Architecture is the overall structure of a system in terms of its constituent components and their interconnections. In this paper, we discuss an approach to using architectural description for the behavioural analysis of distributed software systems and some of the issues which arise in providing tool support. The approach is based on the use of finite state automata to specify behaviour and Compositional Reachability Analysis to check composite system models. The architecture description of a system is used directly to generate the model used for analysis.", "num_citations": "36\n", "authors": ["46"]}
{"title": "Tractable flow analysis for anomaly detection in distributed programs\n", "abstract": " Each process in a distributed program or design can be modelled as a process flow graph, where nodes represent program statements and directed edges represent control flows. This paper describes a flow analysis method to detect unreachable statements by examining the control flows and communication patterns in a collection of process flow graphs. The method can analyse programs with loops, non-deterministic structures and synchronous communication using an algorithm with a quadratic complexity in terms of program size. The method follows an approach described by Reif and Smolka [9] but delivers a more accurate result in assessing the reachability of statements. The higher accuracy is achieved using three techniques: statement dependency, history sets and statement re-reachability. The method is illustrated by a pump control application for a mining environment. A prototype has been\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "36\n", "authors": ["46"]}
{"title": "Animation of requirements specifications\n", "abstract": " Requirements analysis has been recognized as one of the most critical and difficult tasks in software engineering. The need for tool support is essential. This paper reports some work done to provide such support for interpretation and validation of requirements specifications by animation. The Animator provides facilities for the selection and execution of a transaction to reflect the specified behaviour of a particular scenario specified in the requirements specification. Actions are described in terms of input\u0393\u00c7\u00c9output mappings and or functions with pattern matching. Simple rules can be specified to control the triggering of actions. In addition, facilities are provided to replay and interact with transactions. User interaction during animation includes the ability to change data values or role play selected actions as desired. A full graphical interface is supported. The approach has been tested by the provision of an Animator\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "36\n", "authors": ["46"]}
{"title": "Checking progress with action priority: Is it fair?\n", "abstract": " The liveness characteristics of a system are intimately related to the notion of fairness. However, the task of explicitly modelling fairness constraints is complicated in practice. To address this issue, we propose to check LTS (Labelled Transition System) models under a strong fairness assumption, which can be relaxed with the use of action priority. The combination of the two provides a novel and practical way of dealing with fairness. The approach is presented in the context of a class of liveness properties termed progress, for which it yields an efficient model-checking algorithm. Progress properties cover a wide range of interesting properties of systems, while presenting a clear intuitive meaning to users.", "num_citations": "35\n", "authors": ["46"]}
{"title": "Using a rigorous approach for engineering web service compositions: A case study\n", "abstract": " In this paper we discuss a case study for the UK Police IT Organisation (PITO) on using a model-based approach to verifying Web service composition interactions for a coordinated service-oriented architecture. The move towards implementing Web service compositions by multiple interested parties as a form of distributed system architecture promotes the ability to support 1) early verification of service implementations against design specifications and 2) that compositions are built with compatible interfaces for differing scenarios in such a collaborative environment. The approach uses finite state machine representations of Web service orchestrations and distributed process interactions. The described approach is supported by an integrated tool environment for providing verification and validation results from checking designated properties of service models.", "num_citations": "34\n", "authors": ["46"]}
{"title": "System architecture: the context for scenario-based model synthesis\n", "abstract": " Constructing rigorous models for analysing the behaviour of concurrent and distributed systems is a complex task. Our aim is to facilitate model construction. Scenarios provide simple, intuitive, example based descriptions of the behaviour of component instances in the context of a simplified architecture instance. The specific architecture instance is generally chosen to provide sufficient context to indicate the expected behaviour of particular instances of component types to be used in the real system. Existing synthesis techniques provide mechanisms for building behaviour models for these simplified and specific architectural settings. However, the behaviour models required are those for the full generality of the system architecture, and not the simplified architecture used for scenarios. In this paper we exploit architectural information in the context of behaviour model synthesis from scenarios. Software architecture\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "34\n", "authors": ["46"]}
{"title": "An approach for recovering distributed system architectures\n", "abstract": " Reasoning about software systems at the architectural level is key to effective software development, management, evolution and reuse. All too often, though, the lack of appropriate documentation leads to a situation where architectural design information has to be recovered directly from implemented software artifacts. This is a very demanding process, particularly when involving recovery of runtime abstractions (clients, servers, interaction protocols, etc.) that are typical to the design of distributed software systems. This paper presents an exploratory reverse engineering approach, called X-ray, to aid programmers in recovering architectural runtime information from a distributed system's existing software artifacts. X-ray comprises three domain-based static analysis techniques, namely component module classification, syntactic pattern matching, and structural reachability analysis. These complementary\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "33\n", "authors": ["46"]}
{"title": "Restructuring requirements specifications for managing inconsistency and change: A case study\n", "abstract": " The paper describes our experiences in restructuring multi perspective requirements specifications in order to identify and analyse inconsistencies and manage change. A partial, heterogeneous and reasonably large requirements specification from a NASA project was analysed and decomposed into a structure of \"viewpoints\", where each viewpoint encapsulates partial requirements of some system components described in the specification. Relationships between viewpoints were identified which included not only the interactions explicitly stated in the requirements but also some implicit and potentially problematic inter dependencies. The restructuring process and a first informal analysis of the resulting relationships enabled the detection of inconsistencies and the definition of some interesting domain dependent consistency rules. We believe that this restructuring into view points also facilitated requirements\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "33\n", "authors": ["46"]}
{"title": "The system architect's assistant for design and construction of distributed systems\n", "abstract": " Distributed systems are conveniently described, constructed and managed in terms of their software structure or architecture. However, few current platforms exploit the architectural view. The authors outline current work on the provision of an architectural methodology and graphical support tool, the System Architect's Assistant, for the design and engineering of distributed systems. The tool supports both initial informal design decomposition and subsequent rigorously checked composition when a set of specified, designed and/or implemented components are integrated to analyze and/or construct the desired distributed system. The effectiveness of the methodology and prototype tool are assessed by applying it to case studies supplied by an industrial associate and by conducting controlled productivity experiments.< >", "num_citations": "32\n", "authors": ["46"]}
{"title": "An integrated method for effective behaviour analysis of distributed systems\n", "abstract": " Behavioral analysis is a valuable aid for the design and maintenance of well-behaved distributed systems. Dataflow and reachability analyses are two orthogonal, but complementary, behavioral analysis techniques. Individually, each of these techniques may be inadequate for the analysis of large-scale distributed systems. On the one hand, dataflow analysis algorithms, while tractable, may not be sufficiently accurate to provide meaningful detection of errors. On the other hand, reachability analysis, while providing exhaustive analysis, may be computationally too expensive for complex systems. In this paper, we present a method which integrates dataflow and reachability analysis techniques to provide a flexible and effective means for analysing distributed systems at the preliminary and final design stages respectively. We also describe some effective measures taken to improve the adequacy of the individual\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "29\n", "authors": ["46"]}
{"title": "The software architect's assistant-A visual environment for distributed programming\n", "abstract": " This paper describes work on the application of visual techniques to the design and construction of parallel and distributed programs. In particular, it looks at how the software architectural view can be effectively utilised to provide a common framework for integrating the various software development activities, ranging from early, informal program design to the evolution of the running program. A prototype visual programming environment-the Software Architect's Assistant-has been built for the design and development of Regis distributed programs. It provides the user with automated, intelligent assistance throughout the software design process. Facilities provided include the display of integrated graphical and textual views, a flexible mechanism for recording design information and the automatic generation of program code and formatted reports from design diagrams. Software reuse is also supported through the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "28\n", "authors": ["46"]}
{"title": "An integrated workbench for model-based engineering of service compositions\n", "abstract": " The Service-Oriented Architecture (SOA) approach to building systems of application and middleware components promotes the use of reusable services with a core focus of service interactions, obligations, and context. Although services technically relieve the difficulties of specific technology dependency, the difficulties in building reusable components is still prominent and a challenge to service engineers. Engineering the behavior of these services means ensuring that the interactions and obligations are correct and consistent with policies set out to guide partners in building the correct sequences of interactions to support the functions of one or more services. Hence, checking the suitability of service behavior is complex, particularly when dealing with a composition of services and concurrent interactions. How can we rigorously check implementations of service compositions? What are the semantics of service\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "27\n", "authors": ["46"]}
{"title": "A visual approach to distributed programming\n", "abstract": " The Software Architect\u0393\u00c7\u00d6s Assistant is a visual programming environment for the design and development of Regis distributed programs. It provides the user with automated, intelligent assistance throughout the software design process. Facilities provided include the display of integrated graphical and textual views, a flexible mechanism for recording design information and the automatic generation of program code and formatted reports from design diagrams. Software reuse is also supported through the use of component libraries.               The main focus of the Assistant is on the application of visual techniques to the design and construction of parallel and distributed programs. Particular emphasis is placed on utilising the software architectural view as a framework for integrating the various software development activities, ranging from early, informal program design to the evolution of the running program\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "27\n", "authors": ["46"]}
{"title": "A configurable framework for method and tool integration\n", "abstract": " There is an urgent need to provide a sound generic framework for method and tool integration, where many differing notations are used, software development is distributed and management support for the software development process is provided. This paper argues that there is much to be learnt from proven practical techniques for software construction, particularly those that support distributed software integration, heterogeneity and software management. Configuration Programming is one such approach which advocates the use of a separate, declarative configuration language for the description of system structure. It has been used in the Conic Environment for the development of distributable software, and is being extended for the configuration of heterogeneous components programmed in different programming languages. A number of software tools exist for the development, construction and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "27\n", "authors": ["46"]}
{"title": "Synthesizing modal transition systems from triggered scenarios\n", "abstract": " Synthesis of operational behavior models from scenario-based specifications has been extensively studied. The focus has been mainly on either existential or universal interpretations. One noteworthy exception is Live Sequence Charts (LSCs), which provides expressive constructs for conditional universal scenarios and some limited support for nonconditional existential scenarios. In this paper, we propose a scenario-based language that supports both existential and universal interpretations for conditional scenarios. Existing model synthesis techniques use traditional two-valued behavior models, such as Labeled Transition Systems. These are not sufficiently expressive to accommodate specification languages with both existential and universal scenarios. We therefore shift the target of synthesis to Modal Transition Systems (MTS), an extension of labeled Transition Systems that can distinguish between required\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "26\n", "authors": ["46"]}
{"title": "Automated support for distributed software design\n", "abstract": " Automated support for the software design process has existed for many years in the form of CASE tools. Most of these are tailored to support specific design or analysis methods, and often have knowledge of the corresponding methodology built into the working of the tool. However, in terms of tool support, few of them go much beyond the provision of syntax-sensitive editors and checkers for the design notations concerned. We feel that conventional CASE tools have been too conservative in the level of automated support offered to the human developer. The Software Architect's Assistant is our attempt at addressing this limitation. It is an interactive graphical tool developed to facilitate the manipulation of software architectures, and currently supports the design and construction of Regis distributed programs. In its implementation, conscious effort has been made to maximise usability and efficiency, primarily by\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "26\n", "authors": ["46"]}
{"title": "Automated support for diagnosis and repair\n", "abstract": " Model checking and logic-based learning together deliver automated support, especially in adaptive and autonomous systems.", "num_citations": "25\n", "authors": ["46"]}
{"title": "Developing an approach for the recovery of distributed software architectures\n", "abstract": " The extraction of high-level architectural information from existing software systems, or architecture recovery, is a recent research area. This paper presents X-RAY, an approach for recovering distributed software architectures. X-RAY builds on previous work on architecture recovery and more traditional reverse engineering techniques, as well as on notations for architecture description. The key features of the approach are illustrated through the depiction of a step-by-step recovery experiment performed on a small yet non-trivial distributed software system. Initial results from an ongoing experiment involving a larger-scale system are also discussed.", "num_citations": "25\n", "authors": ["46"]}
{"title": "The conic toolkit for building distributed systems\n", "abstract": " Conic provides a set of tools for building flexible distributed systems for embedded applications such as factory automation, telecommunications, process monitoring and control. The Conic programming language is used to program individual software modules which communicate by naming only local entry and exit ports. This gives configuration independence and allows reuse of the modules in various situations. A separate configuration language is used to specify a system by creating instances of modules and interconnecting exit and entry ports. The configuration language is also used to specify changes which can be performed dynamically without shutting down the complete system. These features of a Conic system provide the flexibility for adapting to changing requirements. The paper describes the Conic programming and configuration languages, as well as the run-time support needed for dynamic\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "25\n", "authors": ["46"]}
{"title": "A software architecture for distributed computer control systems\n", "abstract": " Distributed computer control systems have a number of potential advantages over centralized systems, especially where the application is itself physically distributed. A computer station can be placed close to the plant being controlled, and a communications network used to enable the stations to communicate to coordinate their actions. However, the software must be carefully designed to exploit the potential advantages of distribution. This paper describes the software architecture of CONIC, a system to support distributed computer control applications. This architecture emphasizes the distinction between the writing of individual software components and the construction and configuration of a system from a set of components. A modular structure is used to separate programming from configuration. Typed entry and exit ports are used to clearly define module interfaces. Ports, analagous to the plugs and sockets of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "25\n", "authors": ["46"]}
{"title": "Assured and correct dynamic update of controllers\n", "abstract": " In many application domains, continuous operation is a desirable attribute for software-intensive systems. As the environment or system requirements change, so the system should change and adapt without stopping or unduly disturbing its operation. There is, therefore, a need for sound engineering techniques that can cope with dynamic change. In this paper we address the problem of dynamic update of controllers in reactive systems when the specification (environment assumptions, requirements and interface) of the current system changes. We present a general approach to specifying correctness criteria for dynamic update and a technique for automatically computing a controller that handles the transition from the old to the new specification, assuring that the system will reach a state in which such a transition can correctly occur. Indeed, using controller synthesis we show how to automatically build a\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "24\n", "authors": ["46"]}
{"title": "Goal and scenario validation: a fluent combination\n", "abstract": " Scenarios and goals are effective techniques for requirements definition. Goals are objectives that a system has to meet. They are elaborated into a structure that decomposes declarative goals into goals that can be formulated in terms of events and can be controlled or monitored by the system. Scenarios are operational examples of system usage. Validation of goals and scenarios is essential in order to ensure that they represent what stakeholders actually want. Rather than validating scenarios and goals separately, possibly driving the elaboration of one through the validation of another, this paper exploits the relationship between goals and scenarios. The aim is to provide effective graphical animations as a means of supporting such a validation. The relation between scenarios and goals is established by means of fluents that describe how events of the operational description change the state of the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "24\n", "authors": ["46"]}
{"title": "TARA: Tool assisted requirements analysis\n", "abstract": " The TARA Project conducted research into the provision of tool assistance for requirements analysis techniques. In particular it concentrated on automated support for three specific areas: active method guidance, requirements animation and the reuse of specification fragments. In this article we discuss the aims and status of TARA and the application of CASE technology within a method framework. In addition, we outline work on specification and method integration which is based on some of the approaches developed within TARA. 1 Introduction Requirements analysis is one of the most critical tasks in information systems development. Unrecognised errors made early in the development process may have widespread repercussions in the later phases. As a consequence, the cost of correcting such errors is high (Boehm 1982). Support for requirements analysis is therefore crucial. The main focus of our work was the large class of systems which can be classed as\" real-time information systems\"; t...", "num_citations": "24\n", "authors": ["46"]}
{"title": "Flexible fault tolerance for distributed computer systems\n", "abstract": " Many applications have a need for different degrees of fault tolerance in the same system. The paper presents the software architecture of a fault-tolerant distributed system which supports both cold and hot standby redundancy of selected software modules. Cold standby modules are created and activated by the system in order to replace failed modules, but no state information is preserved. Hot standby modules do preserve state information and provide transparent recovery from failures. A technique is used that allows modules to be programmed without fault-tolerance in mind; afterwards they can be transformed in order to achieve that capability. These two types of redundancy are supported by common mechanisms which provide for detection of failures and reconfiguration of the software modules of the application. Reconfiguration is also used to recover the reliability of the system by providing further standby\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "23\n", "authors": ["46"]}
{"title": "Model extraction using context information\n", "abstract": " This work describes a new approach for behaviour model extraction which combines static and dynamic information. We exploit context information as a way of merging these types of information. Contexts are defined by evaluated control predicates and values of attributes. They create a nested structure that can facilitate the extraction of causal relations between system actions. We show how context information can guide the process of constructing LTS models that are good approximations of the actual behaviour of the systems they describe. These models can be used for automated analysis and property verification. Augmentation of the values of attributes recorded in contexts produces further refined models and leads towards correct models. Completeness of the extracted models depends on the coverage achieved by samples of executions. Our approach is partially automated by a tool called LTSE\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "22\n", "authors": ["46"]}
{"title": "Distributed system construction: Experience with the conic toolkit\n", "abstract": " For the last eight years the Distributed Systems Research Group at Imperial College has conducted research into the development of an environment to support the construction and operation of distributed software. The result has been the Conic Toolkit: a comprehensive set of language and run-time tools for program compilation, building, debugging and execution in a distributed environment. Programs may be run on a set of interconnected host computers running the Unix operating system and/or on target machines with no resident operating system.             Two languages are provided, one for programming individual task modules (processes) and one for the configuration of programs from simpler groups of task modules. In addition the enviroment supports the re-use of program components and allows the configuration of new components into running systems. This dynamic configuration capability is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "22\n", "authors": ["46"]}
{"title": "Dynamic configuration for distributed real-time systems\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Dynamic Configuration for Distributed Real-time Systems CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 \u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa \u00b5\u00d1\u00a1\u03c3\u00ef\u00d6\u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa Dynamic Configuration for Distributed Real-time Systems MAGEE J. \u03a6\u00f3\u00bd \u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 MAGEE J. \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 Proc. IEEE Real Time Systems symposium, Dec., 1983 Proc. IEEE Real Time Systems symposium, Dec., 1983, 1983 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u0398\u00bd\u00ff\u03c3\u2551\u00aaIN\u03c3\u00ea\u00e5\u00b5\u00f2\u00fa\u03c0\u00e9\u2556\u03c0\u00e9\u2563\u03c0\u00e2\u00e5\u03c0\u00e2\u00e1\u03c0\u00fc\u00bd\u03c0\u00fc\u00e8\u03c0\u00fc\u00e6\u03c0\u00e9\u00ef\u03c0\u00e2\u00f9\u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e2\u2310\u03c0\u00e2\u00e1\u00b5\u00a2\u2524\u00b5\u00fb\u2591\u00b5\u00eb\u00ef\u0398\u00e1\u00e5\u03c0\u00fc\u00ab\u00b5\u00f1\u00a3\u03a6\u00bf\u00c4 \u03c3\u00e5\u00e0\u03c4\u00f6\u2591 \u03c4\u00a2\u2524\u00b5\u00bf\u2563 \u0398\u00a2\u2557\u03c3\u00a1\u00c9\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u0398\u00c7\u00dc\u03a3\u2510\u00ed\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u00b5\u00e8\u00c7\u03a6\u00ed\u00f4 \u03c4\u00e1\u00f6\u03c4\u2310\u2562\u03c3\u00e1\u2592\u03c3\u00e6\u00e8. SSE, \u03a3\u2551\u00f1\u00b5\u00c5\u00a2\u03c0\u00e9\u2556\u03c0\u00e9\u2563\u03c0\u00e2\u00e5\u03c0\u00e2\u00e1 96(251), 43-48, 1996-09-24 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab5\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 80002005169 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03a3\u255d\u00dc\u03a6\u00a1\u2591\u03a6\u2502\u00e7\u00b5\u00fb\u00d6 \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 RefWorks\u03c0\u00fc\u00bd\u0393\u00c7\u00aa", "num_citations": "22\n", "authors": ["46"]}
{"title": "Restructuring requirements specifications\n", "abstract": " This paper describes the restructuring of multi-perspective requirements specifications to facilitate the identification and analysis of inconsistencies and the management of change. A partial, heterogeneous and reasonably large requirements specification from a NASA project is analysed and decomposed into a structure of viewpoints, where each viewpoint encapsulates partial requirements of some system components described in the specification. Relationships between viewpoints are identified and include, not only the interactions explicitly stated in the requirements, but also some implicit and potentially problematic inter-dependencies. The restructuring process and a first informal analysis of the resulting relationships enable the detection of inconsistencies and the definition of some interesting domain-dependent consistency rules. It is believed that this restructuring into viewpoints also facilitates requirements\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "21\n", "authors": ["46"]}
{"title": "Towards interoperability in heterogeneous database systems\n", "abstract": " Distributed heterogeneous databases consist of systems which differ physically and logically, containing different data models and data manipulation languages. Although these databases are independently created and administered they must cooperate and interoperate. Users need to access and manipulate data from several databases and applications may require data from a wide variety of independent databases. Therefore, a new system architecture is required to manipulate and manage distinct and multiple databases, in a transparent way, while preserving their autonomy.This report contains an extensive survey on heterogeneous databases, analysing and comparing the different aspects, concepts and approaches related to the topic. It introduces an architecture to support interoperability among heterogeneous database systems. The architecture avoids the use of a centralised structure to assist in the different phases of the interoperability process. It aims to support scalability, and to assure privacy and confidentiality of the data. The proposed architecture allows the databases to decide when to participate in the system, what type of data to share and with which other databases, thereby preserving their autonomy. The report also describes an approach to information discovery in the proposed architecture, without using any centralised structure as repositories and dictionaries, and broadcasting to all databases. It attempts to reduce the number of databases searched and to preserve the privacy of the shared data. The main idea is to visit a database that either contains the requested data or knows about another database that possible\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "21\n", "authors": ["46"]}
{"title": "Towards unifying fault and change management\n", "abstract": " A basic model for dynamic change management is proposed which permits changes to be specified declaratively at the configuration level in terms of structure only. Component nodes can be created and deleted and interconnections made and broken. Rules are provided which permit configuration management to identify the affected part of the system and to generate the required operational changes. These operations change the state of the selected component nodes to that suitable for reconfiguration, perform the particular structural changes, and provide the sequencing of the actions. A node responds by performing node-level actions to maintain local and intermode consistency. This model also provides a sound basis for the management of faults where failure of a component node is modeled as arbitrary deletion. The first steps toward unifying the management of dynamic change and fault recovery are\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "21\n", "authors": ["46"]}
{"title": "Intertask Communication Primitives for Distributed Computer Control Systems.\n", "abstract": " This pa per concentrates on the study of intertask communication primitives suitable for a distributed process control environment. The communication requirements are identified in terms of two transaction types which are characteristic of process control applications. The requirements for task behaviour, robustness and response time described with respect to these transactions. Existing proposals for communication primitives are examined and found to be wanting. Finally, set of primitives are proposed which match the requirements satisfactorily than existing proposals. process control applications. The requirements for task behaviour, robustness and respon se time are identified with respect to the transactions. Section 3. examines the extent to which existing proposals for communication primitives meet the requirements of section 2. Finally, in section 4, a set of primitives are proposed which we feel match the requirements more satisfactorily than the existing proposals. are \u2568\u2591 2. Communication Requirements more", "num_citations": "21\n", "authors": ["46"]}
{"title": "Succeedings of the 8th international workshop on software specification and design\n", "abstract": " The 8th International Workshop on Software Specification and Design (IWSSD-8) was held at Schloss Velen, Germany, in March 1996. In order to foster informed and fruitful discussions, the workshop was an invitation-only event of limited size. Based on formal submissions, approximately 60 people were selected and invited. Like its predecessors, IWSSD-8 maintained the principle that the accepted papers should serve as background material for the workshop. Therefore, the workshop did not include formal paper presentations, but rather provided an opportunity to engage in real work, with intensive discussions focussed around major themes. Each theme was discussed in a separate working group directed by a Working Group Chair who organized their group members so as to discuss the research issues of that particular theme. This year the themes selected were Requirements Engineering, Design\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "20\n", "authors": ["46"]}
{"title": "An introduction to distributed programming in REX\n", "abstract": " Configuration Programming is an object-based approach to distributed programming. The main principle underlying this approach is that programs should be designed, constructed and modified as a structural configuration of interconnected component instances. Program structure is described by a separate explicit configuration language, while the components themselves may be programmed in a range of heterogeneous programming languages. This approach is central to the ESPRIT II project, REX, on reconfigurable and extensible parallel and distributed systems. This paper provides an overview of the main concepts underlying REX, illustrating their use in the Darwin configuration language for describing overall system structure and dynamic configuration. The approach is justified and briefly compared to object-oriented programming.", "num_citations": "20\n", "authors": ["46"]}
{"title": "Using contexts to extract models from code\n", "abstract": " Behaviour models facilitate the understanding and analysis of software systems by providing an abstract view of their behaviours and also by enabling the use of validation and verification techniques to detect errors. However, depending on the size and complexity of these systems, constructing models may not be a trivial task, even for experienced developers. Model extraction techniques can automatically obtain models from existing code, thus reducing the effort and expertise required of engineers and helping avoid errors often present in manually constructed models. Existing approaches for model extraction often fail to produce faithful models, either because they only consider static information, which may include infeasible behaviours, or because they are based only on dynamic information, thus relying on observed executions, which usually results in incomplete models. This paper describes a\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "19\n", "authors": ["46"]}
{"title": "Modelling darwin in the \u2567\u00c7-calculus\n", "abstract": " Darwin is a general purpose structuring tool of use in building complex distributed systems from diverse components and diverse component interaction mechanisms. It is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language allows the specification of both static structures and dynamic structures which evolve during execution. The central abstractions managed by Darwin are components and services. Bindings are formed by manipulating references to services.             The paper describes the operational semantics of Darwin in terms of the \u2567\u00c7-calculus, Milner's calculus of mobile processes. The correspondence between the treatment of names in the \u2567\u00c7-calculus and the management of service references in Darwin leads to an elegant and concise \u2567\u00c7-calculus\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "19\n", "authors": ["46"]}
{"title": "Abstraction-is it teachable?'the devil is in the detail'\n", "abstract": " Summary form only given, as follows. Abstraction is a key skill for software engineers. It is essential during requirements engineering to elicit the critical aspects of the environment and required system while neglecting the unimportant. At design time, we need to articulate the software architecture and component functionalities which satisfy functional and nonfunctional requirements while avoiding unnecessary implementation constraints. Even at the implementation stage we use data abstraction and classes so as to generalize solutions However, my experience is that abstraction is extremely difficult to teach and learn. How should we go about teaching this skill? Indeed, is it teachable? This talk discusses the difficulties and challenges in learning and using abstraction. In particular, we consider whether or not the standard engineering technique of model construction and analysis can help in this venture. The\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "18\n", "authors": ["46"]}
{"title": "Modelling and analysing resilient cyber-physical systems\n", "abstract": " From smart buildings to medical devices to smart nations, software systems increasingly integrate computation, networking, and interaction with the physical environment. These systems are known as Cyber-Physical Systems (CPS). While these systems open new opportunities to deliver improved quality of life for people and reinvigorate computing, their engineering is a difficult problem given the level of heterogeneity and dynamism they exhibit. While progress has been made, we argue that complexity is now at a level such that existing approaches need a major re-think to define principles and associated techniques for CPS. In this paper, we identify research challenges when modelling, analysing and engineering CPS. We focus on three key topics: theoretical foundations of CPS, self-adaptation methods for CPS, and exemplars of CPS serving as a research vehicle shared by a larger community. For each topic\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "17\n", "authors": ["46"]}
{"title": "Process Modelling: a critical analysis\n", "abstract": " Software process modelling has assumed considerable importance in discussions of software engineering. In particular attention has been paid to the use of software process modelling in the construction of software development environments. Essentially, software process modelling is the construction of an abstract description of the activities by which software is developed. In the area of software development environments the focus is on models that are enactable, that is executable, interpretable or amenable to automated reasoning. Marvel is based on experience with a multi-user programming environment called Smile. In Smile the description of the programming process was \u0393\u00c7\u00ffhard-coded\u0393\u00c7\u00d6into the environment. Marvel generalises this approach by providing support for the definition and enaction of software process models. To construct a Marvel environment the developer must produce a data model and a\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "17\n", "authors": ["46"]}
{"title": "Model-based Simulation of Web Applications for Usability Assessment.\n", "abstract": " In this paper we discuss an approach for simulating the behaviour of interactive software systems, before starting on any of the actual implementation, based on a model of the system at the architectural level. By providing a mock-up of the final user interface for controlling the simulation, it is possible to carry out usability assessments of the system much earlier in the design process than is usually the case. This means that design changes informed by this usability assessment can be made at this early stage. This is much less expensive than having to wait until an implementation of the system is completed before discovering flaws and having to make major changes to already implemented components. The approach is supported by a suite of cooperating tools for specification, formal modelling and animation of the system.", "num_citations": "17\n", "authors": ["46"]}
{"title": "Decentralised process modelling\n", "abstract": " In this paper, we advocate decentralised process modelling and suggest that understanding and modelling the development processes of individual development participants is the key to supporting collaborative development. Our approach relies on recognising individual developers' states (\u0393\u00c7\u00a3situations\u0393\u00c7\u00a5) by analysing local development histories. Different situations can be used to trigger a variety of further development actions, such as consistency checks between process models of different development participants. We report on experience using regular expressions to specify particular situations and rules to associate actions with these situations.", "num_citations": "17\n", "authors": ["46"]}
{"title": "Exoskeletal software\n", "abstract": " The author advocates the use of a separate and explicit structural language to describe software architectures. The structural nature makes it amenable to both textual and graphical description. Since it is a language, it can be used to support general descriptions and to provide the framework for checking interconnections. In addition, it can be used to generate and manage the system itself. This approach, initially under the guise of simple\" module interconnection languages\"(MIL) and subsequently as\" configuration languages\", provides generalised support for a wide variety of component and interaction types. Generic (skeleton) architectures provide the means for reusing structures with different constituent components. Dynamic constructs support explicit extension while constraining the potential structures of the system to those expressed as valid. Further, change can be supported at the architectural level, either\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "17\n", "authors": ["46"]}
{"title": "Darwin/mp: An environment for parallel and distributed programming\n", "abstract": " Darwin/MP is a programming environment for distributed memory parallel computers. Programs are constructed from hierarchically structured configurations of processes. These process configurations are described explicitly in the Darwin configuration language. In addition to expressing the initial or static structure of a parallel program, Darwin can be used to express structures which change dynamically as execution progresses. Generic structures allow commonly used parallel programming paradigms to be captured as program skeletons. Processes are programmed in a conventional sequential language augmented with the MP message passing primitives. The authors illustrate program development and execution in the environment by means of a set of examples. In addition, they report on the performance of Darwin/MP programs and on experience with the use of the environment. Darwin/MP is currently\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "17\n", "authors": ["46"]}
{"title": "Supporting incremental behaviour model elaboration\n", "abstract": " Behaviour model construction remains a difficult and labour intensive task which hinders the adoption of model-based methods by practitioners. We believe one reason for this is the mismatch between traditional approaches and current software development process best practices which include iterative development, adoption of use-case and scenario-based techniques and viewpoint- or stakeholder-based analysis; practices which require modelling and analysis in the presence of partial information about system behaviour.               Our objective is to address the limitations of behaviour modelling and analysis by shifting the focus from traditional behaviour models and verification techniques that require full behaviour information to partial behaviour models and analysis techniques, that drive model elaboration rather than asserting adequacy. We aim to develop sound theory, techniques and tools that\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "16\n", "authors": ["46"]}
{"title": "LTSABPEL4WS: Tool Support for Model-based Verification of Web Service Compositions\n", "abstract": " We present a tool which supports a model-based approach to verifying web service compositions for web service implementations. The approach provides verification against specification models and assigns semantics to the behavior of implementation models so as to confirm expected results of compositions for both the designer and implementer.", "num_citations": "16\n", "authors": ["46"]}
{"title": "Ltsa-pca: Tool support for compositional reliability analysis\n", "abstract": " Software systems are often constructed by combining new and existing services and components. Models of such systems should therefore be compositional in order to reflect the architectural structure. We present herein an extension of the LTSA model checker. It supports the specification, visualisation and failure analysis of composable, probabilistic behaviour of component-based systems, modelled as Probabilistic Component Automata (PCA). To evaluate aspects such as the probability of system failure, a DTMC model can be automatically constructed from the composition of the PCA representations of each component and analysed in tools such as PRISM. Before composition, we reduce each PCA to its interface behaviour in order to mitigate state explosion associated with composite representations. Moreover, existing behavioural analysis techniques in LTSA can be applied to PCA representations to verify\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "15\n", "authors": ["46"]}
{"title": "Evolve: tool support for architecture evolution\n", "abstract": " Incremental change is intrinsic to both the initial development and subsequent evolution of large complex software systems. Evolve is a graphical design tool that captures this incremental change in the definition of software architecture. It supports a principled and manageable way of dealing with unplanned change and extension. In addition, Evolve supports decentralized evolution in which software is extended and evolved by multiple independent developers. Evolve supports a model-driven approach in that architecture definition is used to directly construct both initial implementations and extensions to these implementations. The tool implements Backbone - an architectural description language (ADL), which has both a textual and a UML2, based graphical representation. The demonstration focuses on the graphical representation.", "num_citations": "15\n", "authors": ["46"]}
{"title": "Translating FSP into LOTOS and Networks of Automata\n", "abstract": " Many process calculi have been proposed since Robin Milner and Tony Hoare opened the way more than 25\u252c\u00e1years ago. Although they are based on the same kernel of operators, most of them are incompatible in practice. We aim at reducing the gap between process calculi, and especially making possible the joint use of underlying tool support. Finite state processes (FSP) is a widely used calculus equipped with Ltsa, a graphical and user-friendly tool. Language of temporal ordering specification (Lotos) is the only process calculus that has led to an international standard, and is supported by the Cadp verification toolbox. We propose a translation of FSP sequential processes into Lotos. Since FSP composite processes (i.e., parallel compositions of processes) are hard to encode directly in Lotos, they are translated into networks of automata which are another input language accepted by Cadp. Hence, it is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "15\n", "authors": ["46"]}
{"title": "Towards faithful model extraction based on contexts\n", "abstract": " Behaviour models facilitate the analysis of software systems using model-checking tools to detect errors and generate counterexamples. Such models can be generated from existing implementations using a model extraction process. This process should guarantee that an extracted model is a faithful representation of the system, so that analysis results may be trusted. This paper discusses the formal foundations of our model extraction process based on contexts. Contexts are abstractions of concrete states of a system, providing valuable information about dependencies between actions. Models are generated by a tool called LTS Extractor and can be refined to improve correctness by augmenting context information. This refinement process eliminates some false negatives and is property-preserving. Completeness of the models depends on the coverage provided by a set of traces describing behaviours\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "15\n", "authors": ["46"]}
{"title": "Architecture recovery for distributed systems\n", "abstract": " The ability to recover up-to-date architectural information from existing software artifacts is key to effective software maintenance, reengineering and reuse. Although architecture recovery can be facilitated with the help of current reverse engineering techniques and tools, many issues remain to be properly addressed, particularly regarding recovery of runtime abstractions (eg, clients, server, interaction protocols) that are typical to distributed system design. In this position paper we claim that integrating multiple static analysis techniques can be a cost-effective way of recovering a distributed system's \u0393\u00c7\u00a3as-built\u0393\u00c7\u00a5 architectural design. To support this claim, we present X-ray, an integrated, static analysis based architecture recovery approach for distributed systems.", "num_citations": "14\n", "authors": ["46"]}
{"title": "Fairness and priority in progress property analysis\n", "abstract": " The liveness characteristics of a system are intimately related to the notion of fairness. However, the task of modelling explicitly fairness constraints is complicated in practice. To address this issue, we propose to check LTS (Labelled Transition System) models under a strong fairness assumption, which can be relaxed with the use of action priority. The combination of the two provides a novel and practical way of dealing with fairness. The approach is presented in the context of a class of liveness properties termed progress, for which it yields an efficient model-checking algorithm. Progress properties cover a wide range of interesting properties of systems, while presenting a clear intuitive meaning to users. An extensive comparison is provided of the approach proposed with classical LTL model-checking.", "num_citations": "13\n", "authors": ["46"]}
{"title": "Software process modelling and technology\n", "abstract": " Software process modelling and technology | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware process modelling and technology ABSTRACT No abstract available. Index Terms 1.Software process modelling and technology 1.Social and professional topics 1.Professional topics 1.Management of computing and information systems 1.Project and people management 2.Software and its engineering 1.Software creation and management 1.Software development process management 2.Software notations and tools 1.Development frameworks and environments 2.Software configuration management and Login \u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["46"]}
{"title": "The Conic toolkit for building distributed systems\n", "abstract": " CONIC provides a set of tools for building flexible distributed systems for embedded applications such as factory automation, telecommunications, process monitoring and control. The CONIC programming language is used to program individual software modules which communicate by naming only local entryports and exitports. This gives configuration independence and allows reuse of the modules in various situations. A separate configuration language is used to specify a system by creating instances of modules and interconnecting exit and entryports. The configuration language is also used to specify changes which can be performed dynamically without shutting down the complete system. These features of a CONIC system provide the flexibility for adapting to changing requirements. This paper describes the CONIC programming and configuration languages as well as the run-time support needed for\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["46"]}
{"title": "Distribution of modal transition systems\n", "abstract": " In order to capture all permissible implementations, partial models of component based systems are given as at the system level. However, iterative refinement by engineers is often more convenient at the component level. In this paper, we address the problem of decomposing partial behaviour models from a single monolithic model to a component-wise model. Specifically, given a Modal Transition System (MTS) M and component interfaces (the set of actions each component can control/monitor), can MTSs M               1, \u0393\u00c7\u00aa, M                                n                matching the component interfaces be produced such that independent refinement of each M                                i                will lead to a component Labelled Transition Systems (LTS) I                                i                such that composing the I                                i               s result in a system LTS that is a refinement of M? We show that a sound and complete distribution\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "12\n", "authors": ["46"]}
{"title": "Learning from vacuously satisfiable scenario-based specifications\n", "abstract": " Scenarios and use cases are popular means for supporting requirements elicitation and elaboration. They provide examples of how the system-to-be and its environment can interact. However, such descriptions, when large, are cumbersome to reason about, particularly when they include conditional features such as scenario triggers and use case preconditions. One problem is that they are susceptible to being satisfied vacuously: a system that does not exhibit a scenario\u0393\u00c7\u00d6s trigger or a use case\u0393\u00c7\u00d6s precondition, need not provide the behaviour described by the scenario or use case. Vacuously satisfiable scenarios often indicate that the specification is partial and provide an opportunity for further elicitation. They may also indicate conflicting boundary conditions. In this paper we propose a systematic, semi-automated approach for detecting vacuously satisfiable scenarios (using model checking) and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "12\n", "authors": ["46"]}
{"title": "An inductive approach for modal transition system refinement\n", "abstract": " Modal Transition Systems (MTSs) provide an appropriate framework for modelling software behaviour when only a partial specification is available. A key characteristic of an MTS is that it explicitly models events that a system is required to provide and is proscribed from exhibiting, and those for which no specification is available, called maybe events. Incremental elaboration of maybe events into either required or proscribed events can be seen as a process of MTS refinement, resulting from extending a given partial specification with more information about the system behaviour. This paper focuses on providing automated support for computing strong refinements of an MTS with respect to event traces that describe required and proscribed behaviours using a non-monotonic inductive logic programming technique. A real case study is used to illustrate the practical application of the approach.", "num_citations": "12\n", "authors": ["46"]}
{"title": "Deriving non-zeno behaviour models from goal models using ILP\n", "abstract": " One of the difficulties in goal-oriented requirements engineering (GORE) is the construction of behaviour models from declarative goal specifications. This paper addresses this problem using a combination of model checking and machine learning. First, a goal model is transformed into a (potentially Zeno) behaviour model. Then, via an iterative process, Zeno traces are identified by model checking the behaviour model against a time progress property, and inductive logic programming (ILP) is used to learn operational requirements (pre-conditions) that eliminate these traces. The process terminates giving a non-Zeno behaviour model produced from the learned pre-conditions and the given goal model.", "num_citations": "12\n", "authors": ["46"]}
{"title": "Synthesizing concurrency control components from process algebraic specifications\n", "abstract": " Process algebraic specifications can provide useful support for the architectural design of software systems due to the possibility of analyzing their properties. In addition to that, such specifications can be exploited to guide the generation of code. What is needed at this level is a general methodology that accompanies the translation process, which in particular should help understanding whether and when it is more appropriate to implement a software component as a thread or as a monitor. The objective of this paper is to develop a systematic approach to the synthesis of correctly coordinating monitors from arbitrary process algebraic specifications that satisfy some suitable constraints. The whole approach will be illustrated by means of the process algebraic specification of a cruise control system.", "num_citations": "12\n", "authors": ["46"]}
{"title": "Leveraging eclipse for integrated model-based engineering of web service compositions\n", "abstract": " In this paper we detail the design and implementation of an Eclipse plug-in for an integrated, model-based approach, to the engineering of web service compositions. The plug-in allows a designer to specify a service's obligations for coordinated web service compositions in the form of Message Sequence Charts (MSCs) and then generate policies in the form of WS-CDL and services in the form of BPEL4WS. The approach uses finite state machine representations of web service compositions and service choreography rules, and assigns semantics to the distributed process interactions. The move towards implementing web service choreography requires design time verification of these service interactions to ensure that service implementations fulfill requirements for multiple interested partners before such compositions and choreographies are deployed. The plug-in provides a tool for integrated specification\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "12\n", "authors": ["46"]}
{"title": "Dynamic update of discrete event controllers\n", "abstract": " Discrete event controllers are at the heart of many software systems that require continuous operation. Changing these controllers at runtime to cope with changes in its execution environment or system requirements change is a challenging open problem. In this paper we address the problem of dynamic update of controllers in reactive systems. We present a general approach to specifying correctness criteria for dynamic update and a technique for automatically computing a controller that handles the transition from the old to the new specification, assuring that the system will reach a state in which such a transition can correctly occur and in which the underlying system architecture can reconfigure. Our solution uses discrete event controller synthesis to automatically build a controller that guarantees both progress towards update and safe update.", "num_citations": "11\n", "authors": ["46"]}
{"title": "An extended description of morph: A reference architecture for configuration and behaviour self-adaptation\n", "abstract": " An architectural approach to self-adaptive systems involves runtime change of system configuration (i.e., the system\u0393\u00c7\u00d6s components, their bindings and operational parameters) and behaviour update (i.e., component orchestration). The architecture should allow for both configuration and behaviour changes selected from pre-computed change strategies and for synthesised change strategies at run-time to satisfy changes in the environment, changes in the specified goals of the system or in response to failures or degradation in quality attributes, such as performance, of the system itself. Although controlling configuration and behaviour at runtime has been discussed and applied to architectural adaptation, architectures for self-adaptive systems often compound these two aspects reducing the potential for adaptability. In this work we provide an extended description of our proposal for a reference architecture\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["46"]}
{"title": "A New Editor in Chief and the State of the Journal\n", "abstract": " Alas, my term of office from January 2006 to December 2009 as the Editor in Chief of the IEEE Transactions on Software Engineering has ended. It has been a great honor to serve and I have very much enjoyed it. It provided me with an interesting overview of the field and an opportunity to make contact with the many researchers and practitioners who contribute to TSE. Despite the onerous responsibility\u0393\u00c7\u00f6and it is hard work\u0393\u00c7\u00f6I shall miss it. It is my great pleasure to introduce the new Editor in Chief, Professor Bashar Nuseibeh, who takes over from 1 January 2010. Bashar is a professor in computing at the Open University in the United Kingdom and Chief Scientist at Lero\u0393\u00c7\u00f6the Irish Software Engineering Research Centre. He is a gifted researcher with an extensive portfolio of major research contributions. Bashar is a very active member of the software engineering community and a loyal supporter of the IEEE Transactions on Software Engineering, having served as an associate editor on the Editorial Board for the last four years. The journal is in excellent hands, and I am delighted that Bashar agreed to undertake this responsibility.", "num_citations": "11\n", "authors": ["46"]}
{"title": "Towards self-management in service-oriented computing with modes\n", "abstract": " A self-managed system is both self-assembling and self-healing. Service-oriented Computing (SoC) architectures, such as a Web Services Architecture (WS-A)illustrate a highly distributed, potentially dynamic,domain for component configurations. We propose the use of component architecture \u0393\u00c7\u00a5modes\u0393\u00c7\u00a5 to facilitate the self-management of services within a SoC environment. A mode abstracts a set of services that are composed to complete a given task. Our approach, named \u0393\u00c7\u00a5SelfSoC\u0393\u00c7\u00a5 includes designing and implementing key parts of a self-managed system specifically aimed at supporting a dynamic services architecture. We extend Darwin component models, Alloy constraint models and distributed system management policies to specify the mode architectures. We also propose the generation of dynamic orchestrations for service compositions to coordinate different modes of an automotive services platform.", "num_citations": "11\n", "authors": ["46"]}
{"title": "CASE support for the software process: A research viewpoint\n", "abstract": " Thus, under the major concern for integration, the issues which I believe need promotion for the advance of CASE support are distribution, the need to cope with inconsistency and the need for real method guidance. Our current work on ViewPoints aims to facilitate distributed development and the use of multiple representation schemes. The approach is based on partitioning the application domain, the notations and the method steps into separate distributable Viewpoints [2], with a configurable framework for method and tool integration", "num_citations": "11\n", "authors": ["46"]}
{"title": "Configuration support for system description, construction and evolution\n", "abstract": " Software systems can be conveniently described, constructed and managed in terms of their configuration, where configuration is the system structure defined as the set of constituent software components together with their interconnections. A specification of the system confiig; uration can be used both to describe the required system structure and to generate the actual system itself. Evolution of the system is achieved by monitoring the status of the components and making extensions or changes to the system configuration by the addition of software components or the replacement of existing ones. The performance of these tasks at the configuration level is termed configuration programming, and is best supported by the use of a declarative configuration language and associated support tools. This paper discusses the main princilples of this approach and illustrates its practice by describing the support which has\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["46"]}
{"title": "Graphical support for configuration programming\n", "abstract": " Most systems and programs are constructed and managed in terms of their software configuration, that is, the set of constituent software components together with their control and communication interconnections. A graphical system that integrates the textual and graphical information required for configuration programming called Conic is described. It provides stand-alone editing and online configuration monitoring and management tools. The issues raised by graphical configuration programming and management are discussed. The graphical workstation, Conicdraw, is described. Examples and experience using the approach in the Conic environment for distribution and concurrent systems are presented.<>", "num_citations": "11\n", "authors": ["46"]}
{"title": "Leveraging Modes and UML2 for Service Brokering Specifications.\n", "abstract": " A Service-Oriented Computing (SoC) architecture consists of a number of collaborating services to achieve one or more goals. Traditionally, the focus of developing services (as components) has been on the static binding of these services within a single context and constrained in an individual manner. As service architectures are designed to more dynamic, where service binding and context changes with environmental disturbance, the task of designing and analysing such architectures becomes more complex. UML2 introduces an extended notation to define component binding interfaces, enhanced activity diagrams and sequence diagrams. We propose the use of Modes to abstract a selected set of services, their coordination and reconfiguration, and use models constructed in UML2 to describe brokering requirements which can be synthesised for input to service brokers. The approach is implemented through the use of a Modes Browser, which allows service engineers to view specifications to a prototype dynamic service brokering agent.", "num_citations": "10\n", "authors": ["46"]}
{"title": "Implied scenario detection in the presence of behaviour constraints\n", "abstract": " Scenario-based specifications describe how independent components interact to provide system level behaviour. The specified system decomposition and system behaviour can give rise to implied scenarios, which are the result of specifying the global behaviour of a system that will be implemented component-wise. The existence of implied scenarios is an indication that further validation with stakeholders must be done. An implied scenario can be accepted or rejected by stakeholders indicating that the implied scenario is acceptable system behaviour or a situation that should be avoided. In consequence, implied scenarios can be used to iteratively drive requirement elicitation. However, in order to do so, we must be capable of detecting implied scenarios in the presence of rejected implied scenarios, in other words in the presence of behaviour constraints. The contribution of this paper is a technique for detecting\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "10\n", "authors": ["46"]}
{"title": "From sequence diagrams to behaviour models\n", "abstract": " The software engineering community has long understood the importance of requirements elicitation. Stakeholder involvement in the elicitation process and tools to help build a common ground between stakeholders and developers is essential in order to obtain a good requirements definition. Scenarios have become increasingly popular as a means of articulating stakeholder requirements. Scenarios describe how system components (in the broadest sense) and users interact in order to provide system level functionality. Each scenario is a partial story which, when combined with all other scenarios, should conform to provide a complete system description. Thus stakeholders may develop descriptions independently, contributing their own view of the system to those of other stakeholders.The Unified Modelling Language has a notation for scenarios called Sequence Diagrams [1]. These diagrams, together with their counterpart from the telecommunication industry Message Sequence Charts [2], have become widely accepted notations for scenario-based specification. Although sequence diagrams facilitate the requirement elicitation process, they have not been exploited to their full extent for requirement analysis and for transitioning into the design phase. This is due fundamentally to the lack of tool support and the lack of agreement on the exact meaning of this graphical notation.", "num_citations": "10\n", "authors": ["46"]}
{"title": "TRACTA: An Environment for Analysing the Behaviour of Distributed Systems\n", "abstract": " Particular emphasis needs to be placed on the integration of analysis techniques with other software development activities, to form a complete environment for the design and construction of distributed systems. We have addressed this problem by using a compositional approach to analysis. The software architecture of a distributed program is represented by a hierarchical composition of subsystems, with interacting processes at the leaves of the hierarchy. Compositional reachability analysis (CRA) exploits the compositional hierarchy to incrementally construct the overall behaviour of the system from that of its subsystems. In the Tracta CRA approach, both processes and properties reflecting system specifications are modelled as state-machines. Property state machines are also composed into the system and violations are detected on the global graph obtained. The method is supported by an automated tool implemented in C++ and running on Unix.", "num_citations": "10\n", "authors": ["46"]}
{"title": "Configurable distributed systems\n", "abstract": " Distributed computing offers one of the most promising approaches for the provision of computer processing. It offers availability and reliability through replication; response and performance through locality and parallelism; and extensibility and scalability through modularity. The challenge is to harness this flexibility, configuring distributed systems so as to suit the tasks at hand. The software configuration of a distributed system is usually performed by instantiation of software components, binding the components together, and allocation of components to a hardware configuration. Reconfiguration is required to recover from failures and to permit the system to evolve to include new functionality or new technology. Large systems require dynamic reconfiguration to support dynamic change without shutting down the complete system.", "num_citations": "10\n", "authors": ["46"]}
{"title": "Requirements engineering through viewpoints\n", "abstract": " This paper provides a short review of contributions to a better understanding of requirements engineering arising from research at Imperial College. These contributions share a common theme - a focus on \u0393\u00c7\u00a3multiple perspectives\u0393\u00c7\u00a5 or viewpoints.", "num_citations": "10\n", "authors": ["46"]}
{"title": "Scalable load-sharing for distributed systems\n", "abstract": " Adaptive algorithms for load-sharing usually comprise two basic functions: state information dissemination and decision making. The authors describe a flexible load-sharing algorithm, FLS, which includes a third function introduced for scalability purposes, that of partitioning into domains. The system partitioning function at a node is responsible for the selection of other nodes to be included in its domain. The state of other nodes in its domain is held locally, in a cache. Cached data are treated as hints for decision making. The FLS algorithm permits local decisions to be made, aims at minimizing the number of incorrect decisions, and does not allow erroneous decisions to proceed. The algorithm is analyzed and shown to be stable and scalable. Its suitability to a CONIC/RES environment was demonstrated with a prototype implementation, providing an automatic software allocation service as part of configuration\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["46"]}
{"title": "Towards robust self-managed systems\n", "abstract": " Software is pervasive. It plays a part in every aspect of our lives, forming a significant part of every automated system or tool that we use, from washing machines to healthcare systems. Like the washing machine, some of these applications are simple, selfcontained devices; however the majority are far more complex. They are generally distributed systems which rely on interacting, distributed subsystems of software components to perform their function. They are expected to interact with users with changing needs and with other systems with unreliable service provision. The challenge is to provide these software systems in such a way that they are robust in the presence of major issues such as change and complexity. Change is inherent, both in the changing needs of users and in the changes which take place in the operational environment of the system. Hence it is essential that our systems can adapt as\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["46"]}
{"title": "Contextual local analysis in the design of distributed systems\n", "abstract": " Compositional Reachability Analysis is a popular technique for studying behaviour of finite-state distributed systems. The technique is applied by a repetition oflocal analyses, the basic steps of which are to construct and examine the behaviour of subsystems. In most cases, behaviour of the subsystem is constrained by its environment (calledcontext) formed by neighbouring components. These behaviour constraints are normally not considered when using local analysis in conventional techniques of compositional reachability analysis. As a result, many execution paths derived in the local analysis may not be actually traversed by the subsystem. These paths are made impossible to traverse by the constraints. The paths are unnecessary for understanding the subsystem behaviour and their removal greatly simplifies the local analysis.               In this paper, we describe an elegant technique, calledcontextual\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["46"]}
{"title": "System structuring: a convergence of theory and practice?\n", "abstract": " Darwin is a general purpose structuring tool of use in building complex distributed systems from diverse components and diverse component interaction mechanisms. It is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language allows the specification of both static structures and dynamic structures which evolve during execution. The central abstractions managed by Darwin are components and services. Bindings are formed by manipulating references to services.     The paper describes the operational semantics of Darwin in terms of the pi-calculus, Milner\u251c\u00e5s calculus of mobile processes. The correspondence between the treatment of names in the pi-calculus and the management of service references in Darwin leads to an elegant and concise pi-calculus model of Darwin\u251c\u00e5s operational semantics. The model has proved useful in arguing the correctness of Darwin implementations and in designing  extensions to Darwin and reasoning about their behaviour. The paper discusses the reasons why other formalisms fail to capture elegantly the system structuring concepts on which Darwin is based.", "num_citations": "8\n", "authors": ["46"]}
{"title": "Flexible communication structure for distributed embedded systems\n", "abstract": " The paper describes an extensible communication system for Conic, an architecture for distributed embedded systems. Conic provides a high level programming language with interprocess communication primitives suited to both local and remote communication. These primitives are sufficiently powerful to be used for applications programming yet simple and efficient enough for programming system software. The communication system which supports these primitives is itself implemented in the Conic language. It provides a very simple datagram-like service, over interconnected local area networks. The configuration flexibility of Conic is exploited to allow extension of the basic communication system to give additional services such as virtual circuit or routing. The paper also relates the Conic communication system to the ISO Reference Model and indicates some of the problems of using the model. An earlier\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["46"]}
{"title": "Integrating model checking and inductive logic programming\n", "abstract": " Inductive Logic Programming can be used to provide automated support to help correct the errors identified by model checking, which in turn provides the relevant context for learning hypotheses that are meaningful within the domain of interest. Model checking and Inductive Logic Programming can thus be seen as two complementary approaches with much to gain from their integration. In this paper we present a general framework for such an integration, discuss its main characteristics and present an overview of its application.", "num_citations": "7\n", "authors": ["46"]}
{"title": "Modelling undefined behaviour in scenario synthesis\n", "abstract": " Current approaches to scenario synthesis do not distinguish, in the resulting state machine models, proscribed behaviour from behaviour that has not yet been defined. In this paper we propose using partial labelled transition systems (PLTS) to capture what remains undefined of the system behaviour. In the context of scenario synthesis, we show that PLTSs can be used to provide feedback to stakeholders on the parts of the behaviour specification that need further elaboration. In this way we aim to support the iterative incremental elaboration of behaviour models.", "num_citations": "7\n", "authors": ["46"]}
{"title": "An architecture to support interoperability of autonomous database systems\n", "abstract": " We propose an architecture designed to support interoperability between autonomous heterogeneous databases. The architecture supports a distributed information discovery process and avoids the use of integrated schemas and centralised structures containing information about the shared data. Users of a database can access its local data as well as data from other databases in the system. Such access can be supported without violating the privacy and con dentiality of the data, and preserving the autonomy of the databases. With the proposed architecture it is possible to support change by adding and removing databases from the system.", "num_citations": "7\n", "authors": ["46"]}
{"title": "Distributed systems\n", "abstract": " Distributed systems | Network and distributed systems management ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksNetwork and distributed systems managementDistributed systems chapter Distributed systems Share on Author: Jeff Kramer profile image Jeff Kramer View Profile Authors Info & Affiliations Publication: Network and distributed systems managementJanuary 1994 Pages 47\u0393\u00c7\u00f466 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: You will be notified whenever a record .\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["46"]}
{"title": "TARA: Tool Assisted Requirements Analysis\n", "abstract": " Requirements analysis is one of the most critical and difficult tasks in software engineering. The need for tool support is easily justified. This paper describes an approach to the provision of such support for three particular aspects method support by active guidance, validation by transaction anomation, and reuse of specification fragments. Method guidance is supported by a method model used to describe the sequence of method steps that should be followed. This model is directly interpreted by the tools to provide advice and reasoning. It is used in conjunction with rules used for consistency checking to provide remedial advice. The animator provides facilities for the selection and execution of a transaction to reflect the specified behavior given a particular scenario. Actions are described in terms of input-out relations. Simple rules can be specified to control the execution of actions. Facilities are provided to replay and interact with transactions. Reuse is supported by facilities for identifying candidate transactions from a reuse database. The search strategies provided include browsing in an inheritance structure, different levels of pattern matching, casual chain matching matching of the underlying control structures, and purpose matching. Support is then provided for the allocation of the selected fragment to the target environment. The approach has been tested by implementing a prototype set of tools for the CORE method and the Analyst workstation. A major case study, the ASE Advanced Sensor Exploitation test environment, has been analyzed and specified using CORE, the Analyst, and the tools described above. The results of that work are\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["46"]}
{"title": "Whither software architecture?(keynote)\n", "abstract": " Summary form only given. Social media has revolutionized how humans create and curate knowledge artifacts [1]. It has increased individual engagement, broadened community participation and led to the formation of new social networks. This paradigm shift is particularly evident in software engineering in three distinct ways: firstly, in how software stakeholders co-develop and form communities of practice; secondly, in the complex and distributed software ecosystems that are enabled through insourcing, outsourcing, open sourcing and crowdsourcing of components and related artifacts; and thirdly, by the emergence of socially-enabled software repositories and collaborative development environments [2].", "num_citations": "6\n", "authors": ["46"]}
{"title": "Fluent-based web animation: Exploring goals for requirements validation\n", "abstract": " We present a tool that provides effective graphical animations as a means of validating both goals and software designs. Goals are objectives that a system is expected to meet. They are decomposed until they can be represented as fluents. Animations are specified in terms of fluents and driven by behaviour models.", "num_citations": "6\n", "authors": ["46"]}
{"title": "An approach to interoperation between autonomous database systems\n", "abstract": " In this paper we present an approach to support interoperation between autonomous database systems. In particular, we concentrate on distributed information discovery and access for systems with a large number of databases. We avoid the need for integrated global schemas or centralized structures containing information on the available data and its location. We instead provide an architecture that supports data distribution, autonomy and heterogeneity. The architecture also supports system evolution by the addition and removal of databases. A distributed information discovery algorithm is provided to perform data requests, database location and data access. A feature of our approach is to distribute the information about database contents using simple hierarchical information structures composed of special terms. A prototype has been developed to demonstrate and evaluate the approach. A hospital case\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["46"]}
{"title": "Supporting interoperability of autonomous hospital databases: a case study\n", "abstract": " We describe an approach that supports distributed information discovery when interoperating with large number of autonomous hospital databases. The approach is presented through a case study based on the health care network. The idea is to perform complete execution of a query: data request, database location and data access, in a distributed way, avoiding the use of integrated schemas and centralised structures. The discovery process is limited to a group of databases that have either related data or knowledge about other databases that possibly holds the required data. The process is recursive, executed in parallel and avoids cycles. The approach permits dynamic evolution of the system and attempts to preserve the autonomy of the databases. A prototype has been developed for academic and research purposes. It demonstrates the feasiability of the approach as an alternative to interoperate with a large number of autonomous databases without using integrated schemas.", "num_citations": "6\n", "authors": ["46"]}
{"title": "Distributed software architectures (tutorial)\n", "abstract": " We motivate the need for architectural description languages in general, concentrating on Darwin, an architectural description language specifically designed for the specification and construction of distributed software systems.", "num_citations": "6\n", "authors": ["46"]}
{"title": "Managing evolution in distributed systems\n", "abstract": " Distributed computer systems offer the potential for growth and change. Although the underlying support mechanisms for change (software creation, binding, deletion) are well understood, there has been no consensus on how evolutionary change can be managed and controlled. This paper suggests that, since distributed systems are specified and constructed in terms of their software structure (configuration), it is appropriate that changes should be specified in terms of structure and managed at the configuration level. We present a model for managing evolution which separates structural concerns at the configuration level from those application concerns at the component level. This permits the formulation of general structural rules for change without the need to consider application state, and the specification of application actions without knowledge of the actual structural changes which may be introduced. To\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["46"]}
{"title": "Dynamic reconfiguration of business processes\n", "abstract": " Organisations require that their business processes reflect their evolving practices by maintaining compliance with their policies, strategies and regulations. Designing workflows which satisfy these requirements is complex and error-prone. Business process reconfiguration is even more challenging as not only a new workflow must be devised but also an understanding of how the transition between the old and new workflow must be managed. Transition requirements can include both domain independent, such as delayed and immediate change, or user-defined domain specific requirements. In this paper we present a fully automated technique which uses control synthesis to not only produce correct-by-construction workflows from business process requirements but also to compute a reconfiguration process that guarantees the evolution from an old workflow to a new one while satisfying any user\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["46"]}
{"title": "Oxidative stress and cardiovascular risk in type 1 diabetes mellitus: Insights from the DCCT/EDIC study\n", "abstract": " BackgroundHyperglycemia leading to increased oxidative stress is implicated in the increased risk for the development of macrovascular and microvascular complications in patients with type 1 diabetes mellitus. Methods and ResultsA random subcohort of 349 participants was selected from the DCCT/EDIC (Diabetes Control and Complications Trial/Epidemiology of Diabetes Interventions and Complications) cohort. This included 320 controls and 29 cardiovascular disease cases that were augmented with 98 additional known cases to yield a case cohort of 447 participants (320 controls, 127 cases). Biosamples from DCCT baseline, year 1, and closeout of DCCT, and 1 to 2\u252c\u00e1years post\u0393\u00c7\u00c9DCCT (EDIC years 1 and 2) were measured for markers of oxidative stress, including plasma myeloperoxidase, paraoxonase activity, urinary F2\u256c\u2592 isoprostanes, and its metabolite, 2,3 dinor\u0393\u00c7\u00c98 iso prostaglandin F2\u256c\u2592. Following\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["46"]}
{"title": "Web service compositions: From xml syntax to service models\n", "abstract": " This paper presents a rigorous approach to specifying, modelling, verifying and validating the behaviour of web service compositions with the goal of simplifying the task of designing coordinated distributed services and their interaction requirements. We address these issues through the use of rigorous software process analysis techniques, specifying semantics for web service composition standards and by providing an accessible, mechanical tool (as a plug-in to the Eclipse development environment), which automates the tasks involved. As web technology has evolved, an emphasis has been placed on providing ease of design for both visual content and functional services for users. Web Services however, concentrate on the view of systems inter-operating with other systems rather than that of actual human actors, yet the concepts for ease of design are highly related and desired. Firstly, this paper presents a model-based approach to the semantics of web service composition XML documents built upon formal verification, validation and simulation techniques, utilising scenario-based design and implementations built in service composition standards. Secondly, the work assigns the semantics of compositions through the use of Labelled Transition Systems (LTS) in the form of Finite State Processes (FSP). Thirdly, an environment is described forming a tool to assist in undertaking the approach.", "num_citations": "5\n", "authors": ["46"]}
{"title": "An information discovery process for interoperable heterogeneous databases\n", "abstract": " An important issue when dealing with interoperability of heterogeneous databases is information discovery. This is the location and identification of information that is relevant, identical, similar or related to the requested data of a query. As outlined by Sheth [7], in the future, the primary issue will not be to efficiently process the data that is known to be relevant, but to determine which data is relevant and where it is located.Some approaches have been proposed in the literature addressing the information discovery problem for a large number of databases. One approach [1, 8] uses an external indexing scheme. However, the autonomy of the involved databases is not strictly respected, since they have to provide both the content and the structure to other databases. It is not specified how the external indexes are updated when components are added and removed from the system. For simplicity, it is assumed that all\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["46"]}
{"title": "Rapid assessment of decentralized algorithms\n", "abstract": " The overall aim of the research described is to investigate the use of scalable, decentralized state-feedback algorithms for distributed systems resource management. These algorithms are required to be efficient and to respond to system changes in real time but have to base their decisions on incomplete and inaccurate information of the system state. A description is also given of CNCSIM, a software tool developed to support designers in distributed algorithms modelling. Specifically, CNCSIM, which is oriented towards the rapid assessment of decentralized load-sharing algorithms for distributed systems, is a distributed discrete event-driven simulator implemented in CONIC. It provides predictions of response time and other performance measures as a function of offered load, and allows tracing of the progress through the system of each message/event to facilitate model validation and analysis. An algorithm for\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["46"]}
{"title": "Eine neue M\u251c\u2562glichkeit zur Kalibrierung potentiometrischer Bestimmungen unter Flie\u251c\u0192injektionsbedingungen (FIA)\n", "abstract": " A simple guideline equation using the Gaussian gamma function combined with the Nernst equation is introduced for gradient calibration in FIA-ionselective potentiometry. The technique is based on the injection of a standard solution into the continuously flowing carrier stream followed by injection of the sample. Using the new expression that we have introduced, the sample concentration can be calculated on-line with a microcomputer without explicit knowledge of the Nernst factor. The beneficial features of the novel approach are discussed and demonstrated for practical problems by means of appropriate examples. Experimental conditions are given for the ionselective potentiometric determinations of iodide and cadmium. The respective advantages and restrictions over common calibration techniques are outlined.", "num_citations": "5\n", "authors": ["46"]}
{"title": "The CONIC Support Environment for Distributed Systems\n", "abstract": " The Conic environment is designed to support the construction and operation of software for distributed embedded systems. It employs a host/target approach, providing a comprehensive set of tools for program compilation, building, debugging and execution on the host, and supports distributed operation on the targets. In order to provide flexibility, the environment supports dynamic configuration, the ability to reconfigure parts of the system while the rest continues to operate.               This paper sets out the basic philosophy adopted in the construction of the environment and describes in detail its implementation structure and functionality.", "num_citations": "5\n", "authors": ["46"]}
{"title": "A Flexible Communication System for Distributed Computer Control\n", "abstract": " This paper describes an extensible communication system for the CONIC Architecture for Distributed Real-time Systems. The CONIC programming language primitives for both local and remote interprocess communication are presented. The communication system which supports these primitives is itself implemented in the CONIC language. It exploits the configuration flexibility of CONIC to provide a very simple basic datagram service which is extensible at configuration time to give additional services such as virtual circuit and multidestination. The paper relates the CONIC communication system to the ISO Reference Model.", "num_citations": "5\n", "authors": ["46"]}
{"title": "Invariants in the application-oriented specification of control systems\n", "abstract": " The importance of an application-oriented specification as the starting point for control system design has recently been recognized. As an initial stage of the work of a Special Interest Group on Application Oriented Specifications, Halling and others presented a review of the problem and some of the approaches to specification in current use. Control applications were divided into two broad classes: continuous control systems on the one hand, and sequential or discrete variable control systems on the other. Within the class of discrete systems a subclass of systems, where large volumes of data must be handled and real-time data manipulations must be specified, was also recognized. This paper aims to show that emphasis on the invariant properties of system elements can be helpful in presenting a system specification for all these types of systems.", "num_citations": "5\n", "authors": ["46"]}
{"title": "Apparent normal leukocyte acid maltase activity in glycogen storage disease type II (Pompe's disease).\n", "abstract": " We present a case of glycogen storage disease type II (Pompe\u0393\u00c7\u00d6s disease) with the classical clinical presentation and characteristic electrocardiographic changes of this disorder. An acid maltase (EC 3.2.1.20) determination in the peripheral leukocytes revealed normal activity; however, acid maltase activity was completely absent in a pre-mortem skeletal muscle biopsy. Post-mortem studies showed acid maltase activity to be absent in all tissues examined, including cultured skin fibroblasts. Massive glycogen deposition corresponded to the localization of the enzymic deficiency, except in the brain, where glycogen content was within the normal range. The acid maltase activity in mixed peripheral leukocytes was due to an isoenzyme of acid maltase in the granulocyte series. Antenatal diagnosis was accurate in a subsequent pregnancy, but discordance between enzyme activity in different cell lines in an\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["46"]}
{"title": "The design of distributed processing systems using stable modules\n", "abstract": " J. Kramer ABSTRACT. An approach to the design of distributed processing systems is presented. The overall aim of the thesis is to suggest a small set of simple, primitive concepts for reasoning and facilities for describing systems which may be realised in a distributed fashion. The approach is informal but based on sound principles in order to permit the verification of designs. As a basis, the approach provides (i) a modelling notation for the specification and description of distributed systems,(ii) a semantic characterisation for the validation and analysis of designs,(iii) an associated, informal design approach which permits a system to be described at different levels of abstraction, and (iv) facilities for the real time environment. The approach is demonstrated by the inclusion of some nontrivial, practical examples. A feature of the approach is the use of invariant assertions to describe the stable, steady-state properties of a system and its components. Systems are described here as a nested hierarchy of stable, asynchronously processing modules. Each module has a local state space and a defined interface with its environment. A module is designed to preserve its own. integrity by preserving an invariant property characterising operational quiescence. A module is stable in the sense that any change in input will cause the module to remain quiescent or act to restore quiescence. Quiescence is complementary to the condition for action in a module in response to input changes. Since bath quiescent and active aspects of a module's behaviour are meaningful parts of some overall system specification, their relationship imposes a healthy design\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["46"]}
{"title": "Invariants for specifications\n", "abstract": " An approach to the specification of abstract data structures (or modules) is presented. Specifications are given in a state machine form. This approach emphasizes the usefulness of invariants which restrict the operations which act on the structures. Invariants are useful both for informally capturing the required behaviour of the structure, and in the development of formal specifications, Examples are used to illustrate how the invariants help in the refinement process to provide the abstract functions which describe the abstract states of the structures, Also, a nontrivial example illustrates the use of invariants to describe the consequential effects of more complex operations.", "num_citations": "5\n", "authors": ["46"]}
{"title": "Compositional reliability analysis for probabilistic component automata\n", "abstract": " In this paper we propose a modelling formalism, Probabilistic Component Automata (PCA), as a probabilistic extension to Interface Automata to represent the probabilistic behaviour of component-based systems. The aim is to support composition of component-based models for both behaviour and non-functional properties such as reliability. We show how additional primitives for modelling failure scenarios, failure handling and failure propagation, as well as other algebraic operators, can be combined with models of the system architecture to automatically construct a system model by composing models of its subcomponents. The approach is supported by the tool LTSA-PCA, an extension of LTSA, which generates a composite DTMC model. The reliability of a particular system configuration can then be automatically analysed based on the corresponding composite model using the PRISM model checker. This\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["46"]}
{"title": "Domain concept-based queries for cancer research data sources\n", "abstract": " Biomedical scientists generate, access, validate and interpret multiple distributed and heterogeneous data sets. Semantic annotations for these data sets are paramount for exchanging and using the data, and take the form of concepts from a domain ontology. ONIX is a platform that facilitates the access to cancer research data resources and one of its goals is to interoperate with caGrid - a grid computing infrastructure for data sharing. In this paper, we present the ONIX approach to building a semantic layer with support for concept-based queries, which exploit semantic annotations of resources, focusing on caGrid resources. The main contributions of this work are: the automatic generation of OWL ontologies from resources' metadata; concept-based query construction and validation; rewriting and translation from concept-based queries to the caGrid query language.", "num_citations": "4\n", "authors": ["46"]}
{"title": "Translating FSP into LOTOS and Networks of Automata\n", "abstract": " Many process calculi have been proposed since Robin Milner and Tony Hoare opened the way more than 25 years ago. Although they are based on the same kernel of operators, most of them are incompatible in practice. We aim at reducing the gap between process calculi, and especially making possible the joint use of underlying tool support. Fsp is a widely-used calculus equipped with Ltsa, a graphical and user-friendly tool. Lotos is the only process calculus that has led to an international standard, and is supported by the Cadp verification toolbox. We propose a translation from Fsp to Lotos. Since Fsp composite processes are hard to encode into Lotos, they are translated into networks of automata which are another input language accepted by Cadp. Hence, it is possible to use jointly Ltsa and Cadp to validate Fsp specifications. Our approach is completely automated by a translator tool we implemented.", "num_citations": "4\n", "authors": ["46"]}
{"title": "Modeling for mere mortals\n", "abstract": " In the past, attempts to convince practising software engineers to adopt formal methods of software development were generally unsuccessful. The methods were too difficult to learn and use, provided inadequate tool support and did not integrate well into the software development process. In short, they could only be used effectively by the gods who created them! Are we in a better position today? Recent advances in and experience with specification techniques and automated model checking have demonstrated the utility of these techniques. In this paper we outline one such effort which is specifically intended to facilitate modelling as part of the software process, and to try to make model specification and model checking accessible to mere mortals.", "num_citations": "4\n", "authors": ["46"]}
{"title": "Novel modelling approach for parallel simulation\n", "abstract": " For simulation of large systems using Parallel Discrete Event Simulation, we have to cope with the problems of describing models, partitioning and distribution into logical processes, and implementation on multiple processors. In this paper, we propose an approach to aid the modelling process for Parallel Discrete Event Simulation and present a program generator which uses the modelling approach. For ease of use, the approach is based on some current methods for sequential discrete event simulation. An example is used to describe and illustrate the approach and the features of the generator.", "num_citations": "4\n", "authors": ["46"]}
{"title": "Distributed software engineering-invited state-of-the-art report\n", "abstract": " The term\" Distributed Software Engineering\" is ambiguous 1. It includes both the engineering of distributed software and the process of distributed development of software, such as cooperative work. This paper concentrates on the former, giving an indication of the special needs and rewards in distributed computing. In essence, we argue that the structure of these systems as interacting components is a blessing which forces software engineers towards compositional techniques which offer the best hope for constructing scalable and evolvable systems in an incremental manner. We offer some guidance and recommendations as to the approaches which seem most appropriate, particularly in languages for distributed programming, specification and analysis techniques for modelling and distributed paradigms for guiding design. 1. Introduction Distributed processing provides the most general, flexible and promising approach for the provision of computer processing. Interconnected workstations a...", "num_citations": "4\n", "authors": ["46"]}
{"title": "Abstraction and modelling\u0393\u00c7\u00f6a complementary partnership\n", "abstract": " Why is it that some software engineers are able to produce clear, elegant designs and programs, while others cannot? Is it purely a matter of intelligence? One hypothesis is that the answer lies in abstraction: the ability to exhibit abstraction skills and perform abstract thinking and reasoning. Abstraction is a cognitive means by which engineers, mathematicians and others deal with complexity. It covers both aspects of removing detail as well as the identification of generalisations or common features, and has been identified as a crucial skill for software engineering professionals. Is it possible to improve the skills and abilities of those less able through further education and training? Are there any means by which we can measure the abstraction skills of an individual? In this talk, we explore these questions, and argue that abstraction and modelling are complementary partners: that abstraction is the key skill\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["46"]}
{"title": "Adaptable software architectures and task synthesis for uavs\n", "abstract": " In this paper we outline a framework for an adaptable architecture in which services are provided by components and components are interconnected to support more complex services. The use of component modes and architecture constraints on modes and structure is presented as a basis for permitting the safe update of systems while deployed. The goal is an adaptable software architecture that can be easily modified while in the operational field without the need to return to a service depot and more challengingly that permits update while the system is deployed on a mission. We propose a componentised architecture that together with explicit architectural constraints, self-assembly and self-healing will provide the flexibility necessary to satisfy the requirements for dynamic adaptability in UAVs.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Engineering distributed software: a structural discipline\n", "abstract": " The role of structure in specifying, designing, analysing, constructing and evolving software has been the central theme of our research in Distributed Software Engineering. This structural discipline dictates formalisms and techniques that are compositional, components that are context independent and systems that can be constructed and evolved incrementally. This extended abstract overviews our development of a structural approach to engineering distributed software and gives indications of our future work which moves from explicit to implicit structural specification. With the benefit of hindsight we attempt to give a \"rational history\" to our research.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Model-based design of concurrent programs\n", "abstract": " A model is a simplified representation of the real world and, as such, includes only those aspects of the real-world system relevant to the problem at hand. The paper reviews a modelling approach to the design of concurrent programs in which models represent the behaviour of concurrent Java programs. A notation based on CSP is used to model behaviour. Tool support enables both interactive model exploration and the mechanical verification of required safety and liveness properties. Models are systematically translated into Java programs. The approach, supported by a textbook, forms the basis of a course at the authors\u0393\u00c7\u00d6 institution and has also been widely adopted elsewhere. With the benefit of five years hindsight, we examine the strengths and weaknesses of the approach and look at some of the subsequent remedies and directions.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Detecting Implied Scenarios in MSCs Using LTSA\n", "abstract": " Scenario-based specifications such as Message Sequence Charts (MSCs) are becoming increasingly popular as part of a requirements specification. Scenarios describe how system components, the environment and users working concurrently interact in order to provide system level functionality. Each scenario is a partial story which, when combined with other scenarios, should conform to provide a complete system description. However, it is not always possible to build a set of components that provides exactly the same system behaviour as described with a set of scenarios. Implied scenarios may appear as a result of unexpected component interaction.In this paper, we present an algorithm that builds a behaviour model that describes the closest possible implementation for a specification based on basic and high-level MSCs. We also present a technique for detecting and providing feedback on the existence of implied scenarios. We have integrated these procedures into the Labelled Transition System Analyser, which allows for model checking and animation of the behaviour model.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Practical behaviour analysis for distributed software architectures\n", "abstract": " Software architecture is the underlying design structure of a system common to the various phases of system development. The Darwin architecture description language has been designed to be sufficiently abstract to support multiple views. In this way, Darwin can be used to describe the basic structure, which can be enriched with behaviour specifications for analysis (behavioural view) and service implementation for construction (service view)(Figure 1). In essence, the architecture drives the process of putting together individual component specifications or implementations in order to obtain a system with desirable characteristics. When performing analysis, these characteristics are formally described in terms of properties against which the specified system is checked.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Behaviour Analysis based on Software Architecture\n", "abstract": " In our approach, software architecture design has been identified as the common underlying structure of the various phases of system development. To address this requirement, the Darwin architecture description language has been designed to be sufficiently abstract to support multiple views. In this way, software architecture describes the basic structure, which can be enriched with behaviour specifications for analysis (behavioural view) and service implementation for construction (service view)(Figure 1). In essence, the architecture drives the process of putting together individual component specifications or implementations in order to obtain a system with desirable characteristics. When performing analysis, these characteristics are formally described in terms of properties against which the specified system is checked.", "num_citations": "3\n", "authors": ["46"]}
{"title": "A quality-based analysis of architecture recovery environments\n", "abstract": " Architecture recovery is a recent research area which aims at providing reverse engineering technologies to extract high-level architectural information from the source code of legacy systems. The authors review the main (only?) architecture recovery environments proposed thus far. The environments are analysed with respect to different quality attributes, and their features and limitations are discussed. This allows one to highlight problems yet to be addressed in the area and, for some of them, suggest possible alternatives. They believe that this analysis is useful for the design of more effective architecture recovery tools.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Production flow control for a manufacturing system with flexible routings\n", "abstract": " We study the dynamic routing problem for a flexible manufacturing system consisting of two unreliable machines and a finite buffer. One product\u0393\u00c7\u00c9type is produced which requires two operations in sequence. The demand rate is assumed to be constant. Each machine is capable of performing both operations. The objective is to trace the demand while keeping the work\u0393\u00c7\u00c9in\u0393\u00c7\u00c9process low and the cycle\u0393\u00c7\u00c9time short. An optimal control formulation is established for the dynamic routing problem. A production flow control algorithm is developed based on a combination of mathematical modeling and heuristics. The control policy is simulated and a comparison with the numerical optimal solution shows that it performs well for the instances under consideration.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Interface requirements: An analysis of technologies designed for individual and group work\n", "abstract": " This study examines the influence of group size on the nature of interactions experienced by users of the Internet. Subjects were divided into groups ranging in size from one to five persons. They were then required to perform an information acquisition task on the Internet. Responses on a post-task assessment indicate that group size plays a significant role influencing self-reports of frustration as well as perceptions of the computer system in use.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Applications of neural networks training methods to optimal WOS image filtering\n", "abstract": " Applications of Neural Networks Training Methods to Optimal WOS Image Filtering - HKUST SPD | The Institutional Repository Skip to content Search Publications Advanced Search Profiles Applications of Neural Network... Please use this identifier to cite or link to this item: http://hdl.handle.net/1783.1/54578 Applications of Neural Networks Training Methods to Optimal WOS Image Filtering Authors Gabbouj, Moncef Tabus, I. Issue Date 1993 Source Proceedings IEEE Workshop on Visual Signal Processing and Communications, Melbourne, Australia, September 20-22 1993, p. 155-158 Language English Genre Conference paper Usage Metrics 17 Page views Similar Items Real Domain Adaptive WOS Filtering Using Neural Network Approximations Author(s): Gabbouj, Moncef; Tabus, I.; Lin, Y. 1993 Adaptive Fuzzy WOS Filtering Author(s): Gabbouj, Moncef; Taguchi, A.; Tabus, I.... 1994 Neural Network Training for (s)\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["46"]}
{"title": "Generalizations are False\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Generalizations are False CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa\u00b5\u00d1\u00a1\u03c3\u00ef\u00d6\u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa Generalizations are False KRAMER J. \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 KRAMER J. \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 IEEE RE'93, Jan. IEEE RE'93, Jan., 1993 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03c0\u00e2\u00eb\u03c0\u00e2\u00ed\u03c0\u00e9\u00f1\u03c0\u00e2\u2502\u03c3\u00ea\u00e5\u00b5\u20a7\u00c9\u03c0\u00e2\u2557\u03c0\u00e2\u00f3\u03c0\u00e2\u00e7\u03c0\u00e2\u00ac\u03c0\u00e2\u2502\u03c0\u00e9\u2591\u00b5\u00aa\u00e9\u03a6\u00ac\u00bc \u03a3\u255d\u00e8\u03a6\u00f9\u00f1 \u00b5\u255c\u00f6 , \u03c4\u00f6\u2591\u00b5\u00a5\u00e6 \u00b5\u00fc\u00a1\u03a3\u2563\u00e0 , \u00b5\u00a5\u2561\u03c3\u2562\u00ef \u03a3\u2510\u00ab\u03a3\u2555\u00eb \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00e7\u00aa\u03c4\u00c9\u00e5\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u03c3\u00e1\u2592\u03c3\u00e6\u00e8. SE,\u03c0\u00e9\u255c\u03c0\u00e2\u00f2\u03c0\u00e2\u00ea\u03c0\u00e9\u00aa\u03c0\u00e9\u00ba\u03c0\u00e9\u00f3\u03c3\u2556\u00d1\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u03a3\u255d\u00dc\u03c3\u00e1\u2592\u03c3\u00e6\u00e8 103, 1-8, 1995-03-09 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab41\u03a3\u2557\u2562 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab2\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 10020889394 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6 \u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03a3\u255d\u00dc\u03a6\u00a1\u2591\u03a6\u2502\u00e7\u00b5\u00fb\u00d6 \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 RefWorks\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 EndNote\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 Mendeley\u03c0\u00fc\u00bd \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 Refer/BiblX\u03c0\u00fc\u00ba\u03a6\u00ed\u00bf\u03c4\u00f1\u2551 RIS\u03c0\u00fc\u00ba\u03a6\u00ed\u00bf\u03c4\u00f1\u2551 BibTeX\u03c0\u00fc\u00ba\u03a6\u00ed\u00bf\u03c4\u00f1\u2551 TSV\u03c0\u00fc\u00ba\u03a6\u00ed\u00bf\u03c4\u00f1\u2551 \u03c3\u00f2\u00c5\u0398\u00ed\u00ee\u03c0\u00fc\u00ab\u00b5\u00ee\u00e7\u00b5\u00e6\u00ff \u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555\u03c0\u00e2\u00ea\u03c0\u00e2\u00e2\u03c0\u00e2\u00f9| (\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["46"]}
{"title": "Change management of distributed systems\n", "abstract": " One of the major challenges in the use of distributed computing systems is the accomodation of evolutionary change. Systems evolve as human needs change, technology changes and the application environment changes. These changes may require modification of a function already provided by the system, or extension by the introduction of new functions. In general, evolutionary changes are difficult to accomodate as they cannot be predicted at the time the system is designed. Consequently, systems should be sufficiently flexible to permit arbitrary, incremental changes. Furthermore we believe that systems must be capable of supporting such change dynamically, without interrupting the processing of those parts of the system which are not directly affected. Distributed systems are specified and constructed in terms of their software structure (configuration). It is therefore appropriate that changes should be\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["46"]}
{"title": "A distributed file server for embedded applications\n", "abstract": " This paper describes the design and implementation of a distributed file system (dfs) for embedded applications. The services provided in dfs include transaction management, file management and file access. Client processes use message passing to access these services. The file system provides client processes with different types of files. These include replicated files, with identical copies stored at multiple nodes, and consistent files, stored at a single node. Both are accessed only within transactions. Multiple readers or a single writer are allowed access to the files, and updates are performed atomically using a co-ordinated commit protocol over multiple sites. A novel concurrency control algorithm which provides deterministic response and avoids deadlock has been designed to resolve contention. Other types of file are also provided for low-overhead storage of less critical data. This paper motivates the need\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["46"]}
{"title": "A student group project in operating system implementation\n", "abstract": " A student operating system project is described. It provides students, working in groups of 4 or 5, with some insight into the design and organisation problems of constructing a fairly large and complex piece of software. The students design and implement the Nucleus of a multiprogramming system which runs under the control of a VM/CMS virtual machine, Aspects of the project structure and its organisation are discussed.", "num_citations": "3\n", "authors": ["46"]}
{"title": "Logic-based learning in software engineering\n", "abstract": " In recent years, research efforts have been directed towards the use of Machine Learning (ML) techniques to support and automate activities such as program repair, specification mining and risk assessment. The focus has largely been on techniques for classification, clustering and regression. Although beneficial, these do not produce a declarative, interpretable representation of the learned information. Hence, they cannot readily be used to inform, revise and elaborate software models. On the other hand, recent advances in ML have witnessed the emergence of new logic-based learning approaches that differ from traditional ML in that their output is represented in a declarative, rule-based manner, making them well-suited for many software engineering tasks.", "num_citations": "2\n", "authors": ["46"]}
{"title": "Adventures in Adaptation: a software engineering playground!\n", "abstract": " Summary form only given. A long research career has inevitably meant that the focus of our work may appear almost random, meandering through distributed computing, software architectures, requirements engineering and model checking! However, in retrospect, a rational reconstruction suggests that there might have been a thread which binds these research adventures together: that of dealing with change. The need to handle change, particularly at run-time, provides a wonderful set of challenges, making research into adaptive and self-managing systems a playground for software engineering researchers. We need to provide a set of comprehensive, consistent and pragmatic approaches to deal with challenges in aspects such as requirements goals and goal revision, domain modelling and model revision, planning and plan revision, and software configuration and reconfiguration. Based on our experiences\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Towards accurate probabilistic models using state refinement\n", "abstract": " Probabilistic models are useful in the analysis of system behaviour and non-functional properties. Reliable estimates and measurements of probabilities are needed to annotate behaviour models in order to generate accurate predictions. However, this may not be sufficient, and may still lead to inaccurate results when the system model does not properly reflect the probabilistic choices made by the environment. Thus, not only should the probabilities be accurate in properly reflecting reality, but also the model that is being used. In this paper we identify and illustrate this problem showing that it can lead to inaccuracies and both false positive and false negative property checks. We propose state refinement as a technique to mitigate this problem, and present a framework for iteratively improving the accuracy of a probabilistically annotated behaviour model.", "num_citations": "2\n", "authors": ["46"]}
{"title": "Visual methods for web application design\n", "abstract": " The paper outlines a tool-supported approach to the design of Web applications. Behavioural models are augmented with Web-based simulations of user interfaces to permit validation and usability assessment of systems by end users in advance of implementation. The goal is to correct architectural design decisions that adversely impact usability early in the design cycle when correction is relatively inexpensive. The behavioural model of a system captures the interactions between the different users roles and the set of components that constitute the application. A visual scenario-based language is used to specify interactions and the tool LTSA-MSC is used to synthesise the required behavioural model. The tool supports a visual representation of this model that is animated in response to user-interaction with the simulated Web interface. The combination of these facilities permits agile incremental elaboration of a\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Component module classification for distributed software understanding\n", "abstract": " Effective analysis and evolution of existing distributed software systems rely to great an extent on the ability to recognise implemented executable components, particularly their constituent modules. Traditionally, this information is obtained via manual examination of configuration files and the source code directory hierarchy. However both types of artifact are limited in distinguishing which modules are used exclusively by each executable component. This exclusivity distinction is important in that it helps to understand the components' unique functionalities and their potential runtime behaviour. This paper presents a module classification technique that can facilitate automatic recognition of executable component modules in a distributed system. In contrast to existing approaches, the technique explicitly distinguishes component exclusive modules from modules shared by multiple components. The paper illustrates\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Concurrent Programming in Java: Design Principles and Patterns\n", "abstract": " Modeling concurrent processes: state machines, state transitions and the FPS process algebra; Java's object-oriented concurrency model: Java's class Thread, built-in methods for threads, the thread state transition diagram, the UML class diagram; implementing Java threads, inheritance and extension; Java concurrent programs and applets; modeling concurrency: multiple processes and the concept of interleaving and asynchronism, parallel composition of processes, process interaction modeled by shared actions, structure diagrams of concurrent processes; concurrent execution in multi-threaded Java systems.8 hours", "num_citations": "2\n", "authors": ["46"]}
{"title": "An experiment in distributed software architecture recovery\n", "abstract": " We describe an architecture recovery experiment performed on a distributed software system. Our main aim was to identify those situations in which existing reverse engineering techniques could be satisfactorily applied and those situations where such techniques would produce only limited or inaccurate results. Based on this experience, we propose ways in which these techniques can be improved.", "num_citations": "2\n", "authors": ["46"]}
{"title": "Exoskeletal Software-Making Structure Explicit\n", "abstract": " Hypothesis: Consider the humble crab. Ignoring its culinary appeal, the crab provides us with an example of a working system which explicitly flaunts its structure, both in terms of components and interconnections. One can readily comprehend its operation from its exoskeletal architecture. Each part provides at its interface a clear indication of the allowable interactions with other parts yet hides its internal workings. Like the crab, it is possible for many software systems to benefit from an explicit and visible architecture, not only during design and analysis but also in the constructed system.", "num_citations": "2\n", "authors": ["46"]}
{"title": "Directions in software process modeling and technology\n", "abstract": " XX Preface documentation; we can enact (execute, animate) these processes; we can use these enactable models to control the invocation of simple tools; we can use a process model in conjunction with a structured repository of software development objects. These are substantial accomplishments, and the extent to which we have made progress from the previous debates should not be underestimated. We now have some, albeit crude, proof-of-concept and we are able to establish the potential of software process modelling and associated technologies. This new found\" critical faculty\" has enabled us to reject certain clearly unpromising lines of research: the megalomaniac, do-it-all environment; the rigid prescriptive model of the development process; the\" yet another\u0393\u00c7\u00a5(a new lease of life for a dead specification language) software process modelling scheme. We have created a coherent research community, internationally and within Europe. More importantly, we are able to identify the key research problems which prevent us from realising the potential of software process modelling and associated technologies. These problems are raised where appropriate in the contributions and form the basis for further joint work between the research groups in the Promoter Working Group established under the aegis of, and with funding from, the Esprit III programme in Basic Research. This work will concentrate on: the capture and construction of process models; the support for cooperation and team work within software process model based environments; and, architectural support for such environments.The critical point is reflected more generally in a\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Method integration and support for distributed software development: An overview\n", "abstract": " Our main objective is to develop an integrated methodology and associated support tools for the development and management of distributed software systems. Our use of the term \u0393\u00c7\u00a3distributed software development\u0393\u00c7\u00a5 is deliberately ambiguous as it is intended to cover both the development of distributed software and distributed development of software by teams of personnel. This paper overviews our work on methods such as the Constructive Design Approach and integration frameworks such as ViewPoints, but, in the interests of brevity, makes no attempt to compare it with current related work.", "num_citations": "2\n", "authors": ["46"]}
{"title": "An integrated CFD tool for hydraulic turbine efficiency prediction\n", "abstract": " An Integrated CFD Tool for Hydraulic Turbine Efficiency Prediction - HKUST SPD | The Institutional Repository Skip to content Search Publications Advanced Search Profiles An Integrated CFD Tool for Hyd... Please use this identifier to cite or link to this item: http://hdl.handle.net/1783.1/48272 An Integrated CFD Tool for Hydraulic Turbine Efficiency Prediction Author Vu, TC Heon, K. Shyy, Wei View this author's profile Issue Date 1993 Source Proceedings of the 5th International Symposium of Refined Flow Modeling and Turbulence Measurements, 1993, p. 811-818 Conference 5th International Symposium of Refined Flow Modeling and Turbulence Measurements, Paris, France, 7 - 10 September 1993 Language English Genre Conference paper Access Find@HKUST Usage Metrics 47 Page views Similar Items A CFD-Based Computer Engineering System for Hydraulic Turbines Author(s): Vu, TC ; Heon, K.; Shyy, by .\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Flexible load-sharing in configurable distributed systems\n", "abstract": " Adaptive algorithms for load-sharing usually comprise two basic functions: state information dissemination and decision making (control). This paper describes a flexible load-sharing algorithm, FLS, which includes a third function introduced for scalability purposes, that of partitioning into domains. The system partitioning function at a node is responsible for the selection of other nodes to be included in its domain. The state of other nodes in its domain is held locally, in a cache. Cached data is treated as hints for decision making. The FLS algorithm permits local decisions to be made, aims at minimising the number of incorrect decisions and does not allow erroneous decisions to proceed. The algorithm is analysed and shown to be stable and scalable. Its suitability to a CONIC/REX environment is demonstrated with a prototype implementation, providing an automatic software allocation service as part of configuration\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Configuring heterogeneous open systems\n", "abstract": " Configuring Heterogeneous Open Systems - HKUST SPD | The Institutional Repository Skip to content Search Publications Advanced Search Profiles Configuring Heterogeneous Open... Please use this identifier to cite or link to this item: http://hdl.handle.net/1783.1/40871 Configuring Heterogeneous Open Systems Authors Twidle, KP Sloman, MS Magee, JN Kramer, Jeff A. Dulay, N. Crane, S. Cheung, Shing Chi View this author's profile Issue Date 1992 Source Proc. First International Conference on Enterprise Integration Modelling Technology, Hilton Head, SC, USA, MIT Press, June 1992, p. 513-523 Publisher MIT Press Language English Genre Conference paper Usage Metrics 18 Page views Similar Items Configurations and Diagnosis for Ultra-Dense Heterogeneous Networks: From Empirical Measurements to Technical Solutions Author(s): Wang, Wei; Yang, Lin; Zhang, Qian... 2018 The New Configuration of (s\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["46"]}
{"title": "Rigorous analysis of (Distributed) simulation results\n", "abstract": " Formal static analysis of the correctness and complexity of scalable and adaptive algorithms for distributed systems is difficult and often not appropriate. Rather, tool support is required to facilitate the'trial and error'approach which is often adopted. Simulation supports this experimental approach well. In this paper we discuss the need for a rigorous approach to simulation results analysis and model validation. These aspects are often neglected in simulation studies, particularly in distributed simulation. Our aim is to provide the practitioner with a set of guidelines which can be used as a \u0393\u00c7\u00ffrecipe\u0393\u00c7\u00d6in different simulation environments, making sound techniques (simulation and statistics) accessible to users. We demonstrate use of the suggested analysis method with two different distributed simulators (CNCSIM [8]) and (NEST [3]) thus illustrating its generality. The same guidelines may be used with other simulation tools to ensure meaningful results while obviating the need to acquire more detailed knowledge in the area.", "num_citations": "2\n", "authors": ["46"]}
{"title": "A Model for Change Management\n", "abstract": " One of the major challenges in the use of distributed computing systems is the accomodation of evolutionary change.", "num_citations": "2\n", "authors": ["46"]}
{"title": "On re-assembling self-managed components\n", "abstract": " Self-managed systems need to adapt to changes in requirements and in operational conditions. New components or services may become available, others may become unreliable or fail. Non-functional aspects, such as reliability or other quality-of-service parameters usually drive the selection of new architectural configurations. However, in existing approaches, the link between non-functional aspects and software models is established through manual annotations that require human intervention on each re-configuration and adaptation is enacted through fixed rules that require anticipation of all possible changes. We propose here a methodology to automatically re-assemble services and component-based applications to preserve their reliability. To achieve this we define architectural and behavioural models that are composable, account for non-functional aspects and correspond closely to the implementation\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "An approach to improve accuracy in probabilistic models using state refinement\n", "abstract": " Probabilistic models are useful in the analysis of system behaviour and non-functional properties. Reliable estimates and measurements of probabilities are needed to annotate behaviour models in order to generate accurate predictions. However, this may not be sufficient, and may still lead to inaccurate results when the system model does not properly reflect the probabilistic choices made by the environment. Thus, not only should the probabilities be accurate in properly reflecting reality, but also the model that is being used. In this paper we propose state refinement as a technique to mitigate this problem, showing that it is guaranteed to preserve or increase the accuracy of the initial model. We present a framework for iteratively improving the accuracy of a probabilistically annotated behaviour model with respect to a set of benchmark properties through iterative state refinements.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Component-Based Modeling, Analysis and Animation\n", "abstract": " Component-based software construction is widely used in a variety of applications, from embedded environments to grid computing. However, errors in these applications and systems may have severe financial implications or may even be life threatening. A rigorous software engineering approach is necessary. We advocate a model-based tool-supported approach to the design of concurrent component-based systems. Component behaviour is modeled as a finite state process and specified in a process algebra FSP. In the same way that components can be composed according to an architecture so as to provide (sub-)system functionality, so component models can be composed to construct a system behaviour model. These models can be analysed using model checking against required properties specified in FSP or linear temporal logic. Furthermore, these models can be animated to demonstrate and\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "LTSA-WS: A Tool for Model-based Verification and Validation of Web Service Compositions in Eclipse\n", "abstract": " In this paper we describe a tool for a model-based approach to verifying compositions of web service implementations. The tool supports verification of properties created from design specifications and implementation models to confirm expected results from the viewpoints of both the designer and implementer. Scenarios are modeled in UML, in the form of Message Sequence Charts (MSCs), and then compiled into the Finite State Process (FSP) process algebra to concisely model the required behavior. BPEL4WS implementations are mechanically translated to FSP to allow an equivalence trace verification process to be performed. By providing early design verification and validation, the implementation, testing and deployment of web service compositions can be eased through the understanding of the behavior exhibited by the composition. The approach is implemented as a plug-in for the Eclipse development\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "Making meaningful models for mere mortals\n", "abstract": " Recent advances in automated model checking have demonstrated the power and utility, of behaviour modelling and analysis. However, most attempts to convince practising software engineers to use formal models as part of their software development process have proven unsuccessful. The notations are often too difficult to learn and use, do not provide adequate tool support, do not integrate well into the software development process or are too difficult for users to interpret. In short, many of the modelling approaches can only be used effectively by the gods who created them! Our aim is to make formal behaviour models and the benefits of analysis accessible to mere software engineering mortals.", "num_citations": "1\n", "authors": ["46"]}
{"title": "The Koala Component Model for Consumer Electronics Software\n", "abstract": " What does all this embedded software do? At first, it provided only basic control of the hardware. Since then, some of the signal and data processing has shifted from hardware to software. Software has made new product features possible, such as electronic programming guides and fancy user interfaces. The latest trends show a merging with the computer domain, resulting in services such as WebTV. No longer isolated entities, CE products have become members of complex product-family structures. These structures exhibit diversity in product features, user control style, supported broadcasting standards, and hardware technology\u0393\u00c7\u00f6all factors that increase complexity.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Architectural description\n", "abstract": " The main issues identified in the area and which were selected for discussion are listed below:                                         Basic models for product line descriptions (PLDs)                                                     what are the first class description components?                                                                             how is \u0393\u00c7\u00ffform\u0393\u00c7\u00d6 described?                                                                             how is the rationale for the architectural elements/decisions described?                                                                             is the architectural instance description (AID) language different from PLD language?                                                                                                                                          Generic Descriptions                                                     when and how do you move from the business domain to the solution domain?                                                                             what are the language structures to describe                                                                 shared architectural elements\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "An investigation of the use of world views with shared variables in Time Warp\n", "abstract": " We investigate how four world views currently in use for sequential simulation can be used with shared variables in parallel discrete event simulation with Time Warp. The worlds view include event, activity, three phase, and process interaction. The mechanism to share variables uses the full-replication strategy. Some programming and performance analysis results of the various implementations are also presented.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Distributed Software Architectures: A Structural Framework for Constructing and Reasoning about Distributed Systems\n", "abstract": " In several object-oriented methods, objects conceptually communicate through messages. However, this form of message passing is often very restrictive, consisting of a sequential system where an operation in one object calls an operation provided by another object. A designer of a distributed application, where distributed subsystems potentially reside on different nodes, must consider a wide variety of alternatives for message communication:", "num_citations": "1\n", "authors": ["46"]}
{"title": "An implementation of a technique for sharing variables in Time Warp\n", "abstract": " For some systems, the use of shared variables is a natural means to model the desirable interactions in a parallel discrete event simulation. We propose an implementation of a technique which uses a full replication strategy to share variables in distributed memory systems using Time Warp. The implementation handles causal effects and tie breaks between accesses. We show that the technique can be implemented in three different ways: aggressive cancellation, lazy cancellation and optimised scheme of rollback in order to enhance performance. An evaluation of implementations of the technique is provided using an example.< >", "num_citations": "1\n", "authors": ["46"]}
{"title": "Concurrent software engineering: coordinating distributed viewpoints for managing inconsistency\n", "abstract": " Concurrent engineering involves the collaboration and coordination of a physically distributed team with variable opportunities for communication with one another. Traditional approaches to the problems of distributed working use a central database, or repository, to which all team members have communication access. Consistency is managed in this database through strict access control and version management, along with a common data model or schema. Such centralised approaches do not adequately support the reality of distributed engineering, where communication with a central database cannot always be guaranteed, and access control rapidly becomes a bottleneck. The alternative, a fully decentralised environment, is seen to be problematic because of the difficulties of maintaining consistency between a large collection of agents. However, these problems can be overcome by recognising that\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "Providing high performance distributed computing through scalable computation servers\n", "abstract": " Distributed applications spanning multiple nodes should he capable of providing fast response. Computation servers equipped with powerful processors and large memories can improve performance by better utilising system resources such as offloading overloaded nodes. A computation service may comprise all the nodes of the system (in case all are equipped with the required resources) or a small subset such as provided by a pool of computation servers (as in Amoeba). In both cases there can be a large number of service providers (compute servers). A server selection service is required to choose the most suitable server to provide the service. This paper is concerned with the design of adaptive computation server selection with scale recognised as a primary design and implementation factor. Adaptive system partitioning into domains is advocated as a key design principle for scalability. The model is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "Constructive Communication in MP\n", "abstract": " MP is a programming environment for message passing parallel computers. The paper describes the basic set of communication primitives provided by MP and demonstrates how higher level communication operations such as symmetric exchange and remote rendezvous can be directly constructed from the basic set. The paper further shows how global parallel operations such as parallel sum, barrier synchronisation and parallel prefix can be elegantly constructed by combining the basic set of primitives with generic process structures described in the configuration language Darwin which forms part of the MP programming environment. Implementation and performance aspects of the primitives and constructed operations are discussed in relation to a transputer based multicomputer.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Configuring Object-Based Distributed Programs in REX\n", "abstract": " The popularity of the object oriented programming paradigm has stimulated research into its use for parallel and distributed programming. The major issues which impact such use are concurrency control, object interfaces, binding and inheritance. This paper discusses the relative merits of current solutions to these issues and describes an approach based on the use of active objects with essentially explicit interfaces and bindings, and composition as a pragmatic alternative to inheritance. The key feature of our approach is the use of a configuration language to define program structure as a set of objects and their bindings. The configuration language includes facilities for hierarchic definition of composite objects, for parameterisation of objects, for replication of both object instances and interface interaction points, for conditional configurations with evaluation of guards at object instantiation, and even for recursive definition of objects. This separate and explicit description of program structure complements the object oriented concepts yet is missing from most other approaches. This approach, termed Configuration Oriented Programming, is illustrated by examples from the REX environment for the development of distributable software. This environment is being developed by the REX collaborative ESPRIT II project [REX 89].", "num_citations": "1\n", "authors": ["46"]}
{"title": "Configuration Programming: Exploiting Component Reuse in Distributed Systems\n", "abstract": " In 1968, the historic NATO Conference at Garmisch recognized the need for a discipline of software engineering. A vision of software construction from reusable software components was proposed by McIlroy [23]. Although this view is extremely appealing, it has unfortunately proved rather elusive. Other than the provision of libraries of mathematical functions, software component reuse is still essentially ad hoc, with no widescale or comprehensive support.", "num_citations": "1\n", "authors": ["46"]}
{"title": "A Constructive Approach to the Design of Distributed Systems\n", "abstract": " The underlying model of distributed systems is that of loosely coupled components r running in parallel and communicating by message passing. Description, construction and evolution of these systems is facilitated by separating the system structure, as a set of components and their interconnections, from the functional description of individual component behaviour. Furthermore, component reuse and structuring flexibility is enhanced if components are context independent ie. selfcontained with a well defined interface for component interaction.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Diverse and Selective Fault-Tolerance In A Distributed Environment\n", "abstract": " Fault-Tolerance has commonly been considered a feature that requires specially designed hardware and software. In this paper we present an overview of an approach that allows fault-tolerance to be automatically and selectively added to critical software modules of an existing system. Several techniques, providing different degrees of fault-tolerance, are supported. This permits the application designer to select the technique that best suits the performance and dependability requirements of each application. The fault-tolerance support mechanisms are built on top of an existing software development and operation environment which provides languages for programming and configuring distributed real-time systems. Thus the design of an application system is not constrained by the use of specialized and restricted environments as those typically used to develop fault-tolerant systems. Instead, the designer can\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "Synchronized forward and backward recovery for communicating processes\n", "abstract": " This paper presents a mechanism which facilitates the task of constructing consistent, reliable distributed systems for embedded, real-time applications. The mechanism, based on the concept of an atomic action, provides synchronized backward recovery for a set of communicating processes. Coupled with this backward recovery there is an exception handler mechanism that provides the alternative of synchronized forward recovery. In order to gain experience in the use of these mechanisms, they have been integrated into Conic, an existing environment for the construction of distributed systems.", "num_citations": "1\n", "authors": ["46"]}
{"title": "A Software Architecture for Distributed Computer Control Systems\n", "abstract": " Distributed computer control systems have a number of potential advantages over centralised systems, especially where the application is itself physically distributed. A computer station can be placed close to the plant being controlled, and a communications network used to enable the stations to communicate to coordinate their actions. However, the software must be carefully designed to exploit the potential advantages of distribution.In this paper we describe a software architecture which emphasises the distinction between the writing of individual software components and the construction and configuration of a system from a set of components. A modular structure is used to separate programming from configuration. Typed entry and exit ports clearly define a module interface which, like the plugs and sockets of hardware components, permit modules to be interconnected in different ways. On-line modification\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["46"]}
{"title": "GRAPHICAL CONFIGURATION PROGRAMMING-THE STRUCTURAL DESCRIPTION, CONSTRUCTION AND EVOLUTION OF SOFTWARE SYSTEMS USING GRAPHICS\n", "abstract": " Figure 2. The nurse module. defined interfaces and one for configuring programs from groups of task modules. In addition, the environment supports mod-ule reuse and was recently extended to support dynamic configuration. The latter facility is achieved with on-line management tools that permit dynamic creation, control, and modification of application programs. The basic Conic environment has been in use for more than five years and has amply demonstrated the utility of configuration-level programming. Although configurations are most easily described and viewed graphi~ ally,~.~ they have traditionally been provided to the support environment in textual form, which is more concise and easier to parse. For example, Conic\u0393\u00c7\u00d6s developers and users have always drawn diagrams to describe and document their configurations, while their interactions with compilers, builders, and managers have always been textual. This disparity, plus the availability of graphics-based workstations, prompted us to develop graphical support for configuration programming-essentially, a visual programming language for configuration. However, in contrast to most work on visual programming, 6 our approach emphasizes system structure in-the-large rather than detailed data and control structure. The combination of graphics and text is a powerful facility; the graphics complements the text by reflecting the described or existing configuration, thereby aiding comprehension and validation. Of course, the text is still essential for detailed information and for certain complex cases not amenable to display.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Information Discovery for Autonomous Database Systems\n", "abstract": " We describe an approach for distributed information discovery and access for systems consisting of large numbers of autonomous databases. The approach aims to avoid the use of integrated schemas and centralised structures. It attempts to reduce the number of databases searched during the discovery process by distributing the information about database contents. A hospital case study, which has been implemented in a prototype, is given to illustrate the approach.", "num_citations": "1\n", "authors": ["46"]}
{"title": "Abstraction in Computer Science & Software Engineering: A Pedagogical Perspective\n", "abstract": " Abstraction is recognized as a key concept in Computer Science and Software Engineering. Is it, however, possible to teach abstraction to students? This column discusses the role of abstraction in current curricula and the challenge posed in trying to teach it. We outline of kinds of tasks that may be used to enhance students' abstract thinking during their undergraduate studies.", "num_citations": "1\n", "authors": ["46"]}