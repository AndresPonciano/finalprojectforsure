{"title": "Automatically recommending peer reviewers in modern code review\n", "abstract": " Code review is an important part of the software development process. Recently, many open source projects have begun practicing code review through \u201cmodern\u201d tools such as GitHub pull-requests and Gerrit. Many commercial software companies use similar tools for code review internally. These tools enable the owner of a source code change to request individuals to participate in the review, i.e., reviewers. However, this task comes with a challenge. Prior work has shown that the benefits of code review are dependent upon the expertise of the reviewers involved. Thus, a common problem faced by authors of source code changes is that of identifying the best reviewers for their source code change. To address this problem, we present an approach, namely cHRev, to automatically recommend reviewers who are best suited to participate in a given review, based on their historical contributions as demonstrated in\u00a0\u2026", "num_citations": "109\n", "authors": ["202"]}
{"title": "Impact analysis of change requests on source code based on interaction and commit histories\n", "abstract": " The paper presents an approach to perform impact analysis (IA) of an incoming change request on source code. The approach is based on a combination of interaction (eg, Mylyn) and commit (eg, CVS) histories. The source code entities (ie, files and methods) that were interacted or changed in the resolution of past change requests (eg, bug fixes) were used. Information retrieval, machine learning, and lightweight source code analysis techniques were employed to form a corpus from these source code entities. Additionally, the corpus was augmented with the textual descriptions of the previously resolved change requests and their associated commit messages. Given a textual description of a change request, this corpus is queried to obtain a ranked list of relevant source code entities that are most likely change prone. Such an approach that combines information from interactions and commits for IA at the change\u00a0\u2026", "num_citations": "52\n", "authors": ["202"]}
{"title": "Improving change prediction with fine-grained source code mining\n", "abstract": " The thesis proposes a software-change prediction approach that is based on mining fine-grained evolutionary couplings from source code repositories. Here, fine-grain refers to identifying couplings between source code entities such as methods, control structures, or even comments. This differs from current source code mining techniques that typically only identify couplings between files or fairly high-level entities. Furthermore, the model combines the mined evolutionary couplings with the estimated changes identified by traditional impact analysis techniques (eg, static analysis of call and program-dependency graphs). The research hypothesis is that software-change prediction using the proposed synergistic approach results in an overall improved expressiveness (ie, granularity and context given to a developer) and effectiveness (ie, accuracy of the prediction)", "num_citations": "29\n", "authors": ["202"]}
{"title": "Comparing and combining evolutionary couplings from interactions and commits\n", "abstract": " The paper presents an approach to mine evolutionary couplings from a combination of interaction (e.g., Mylyn) and commit (e.g., CVS) histories. These evolutionary couplings are expressed at the file and method levels of granularity, and are applied to support the tasks of commit and interaction predictions. Although the topic of mining evolutionary couplings has been investigated previously, the empirical comparison and combination of the two types from interaction and commit histories have not been attempted. An empirical study on 3272 interactions and 5093 commits from Mylyn, an open source task management tool, was conducted. These interactions and commits were divided into training and testing sets to evaluate the combined, and individual, models. Precision and recall metrics were used to measure the performance of these models. The results show that combined models offer statistically significant\u00a0\u2026", "num_citations": "26\n", "authors": ["202"]}
{"title": "Enabling integrated development environments with natural user interface interactions\n", "abstract": " The paper introduces the concept of applying Natural User Interface (NUI) interactions in the context of Integrated Development Environments (IDEs). Human voice and gestures are mapped to several IDE commends. A prototype tool is developed using the Microsoft Kinect hardware sensors and the available software development kits for Microsoft Visual Studio. A pilot study was conducted to assess the developed prototype. The results of the study suggest that it might be possible to apply natural interactions to a range of IDE capabilities.", "num_citations": "20\n", "authors": ["202"]}
{"title": "Using developer-interaction trails to triage change requests\n", "abstract": " The paper presents an approach, namely iHDev, to recommend developers who are most likely to implement incoming change requests. The basic premise of iHDev is that the developers who interacted with the source code relevant to a given change request are most likely to best assist with its resolution. A machine-learning technique is first used to locate source code entities relevant to the textual description of a given change request. Ihdev then mines interaction trails (i.e., Mylyn sessions) associated with these source code entities to recommend a ranked list of developers. Ihdev integrates the interaction trails in a unique way to perform its task, which was not investigated previously. An empirical study on open source systems Mylyn and Eclipse Project was conducted to assess the effectiveness of iHDev. A number of change requests were used in the evaluated bench-mark. Recall for top one to five\u00a0\u2026", "num_citations": "16\n", "authors": ["202"]}
{"title": "Mining software repositories to support software evolution\n", "abstract": " The dissertation presents an approach that uncovers evolutionary couplings from the version histories of software systems. The version histories used are those stored in software repositories, managed by version-control tools such as Subversion and CVS. A combination of lightweight source-code analysis and differencing, development heuristics, and sequential-pattern mining techniques are used to uncover the evolutionary couplings. Evolutionary couplings are identified between different artifact types (eg, source code and documentation and end-user documentation in different natural languages), as well as at fine-grained granularities (eg, methods, control statements, preprocessor, and even comments) of source code. The specific archival source used is the commits stored in software repositories. This work directly falls under the realm of Mining Software Repositories (MSR) and Empirical Software Engineering. The applications of evolutionary couplings are demonstrated on a number of software evolution tasks such as change analysis and prediction, software traceability links recovery, and software document localization process. The approach is applied and evaluated on a number of versions of K Desktop Environment (KDE)-an open source system. The results show that the approach is very precise in predicting certain types of future changes from the past evolutionary couplings. No other work has systematically shown the use of version archives in uncovering traceability links, supporting document localization, and source code change prediction at fine-granularity levels over multiple versions.", "num_citations": "12\n", "authors": ["202"]}
{"title": "On mapping releases to commits in open source systems\n", "abstract": " The paper presents an empirical study on the release naming and structure in three open source projects: Google Chrome, GNU gcc, and Subversion. Their commonality and variability are discussed. An approach is developed that establishes the mapping from a particular release (major or minor) to the specific earliest and latest revisions, ie, a commit window of a release, in the source control repository. For example, the major release 25.0 in Chrome is mapped to the earliest revision 157687 and latest revision 165096 in the trunk. This mapping between releases and commits would facilitate a systematic choice of history in units of the project evolution scale (ie, commits that constitute a software release). A projected application is in forming a training set for a source-code change prediction model, eg, using the association rule mining or machine learning techniques, commits from the source code history are\u00a0\u2026", "num_citations": "8\n", "authors": ["202"]}
{"title": "Mining evolutionary dependencies from web\u2010localization repositories\n", "abstract": " An approach to mining repositories of web\u2010based user documentation for patterns of evolutionary change in the context of internationalization and localization is presented. Localized web documents that are frequently co\u2010changed (i.e., an evolutionary dependency) during the natural language translation process are uncovered to support the future evolution of the system. A sequential\u2010pattern mining technique is used to uncover patterns from version histories. Characteristics of the uncovered patterns such as size, frequency, and occurrence within a single natural language or across multiple languages are discussed. Such patterns help provide an insight into the effort required in retranslation due to a change in the documentation. The approach is validated on the open source K Desktop Environment (KDE) system. KDE maintains documentation for over 50 different natural languages and presents a prime\u00a0\u2026", "num_citations": "6\n", "authors": ["202"]}
{"title": "Mining for co-changes in the context of web localization\n", "abstract": " An approach for mining repositories of Web-based user documentation for patterns of evolutionary change in the context of internationalization and localization is presented. Sets of documents that are changed together during the translation process are uncovered and documented to support future evolution of the system. A sequential-pattern mining technique is used to uncover the patterns from Subversion repositories. The approach is applied to the open source KDE system. KDE maintains documentation for over fifty different natural languages and presents a prime example of the problem. Characteristics of the uncovered patterns such as size, frequency, and occurrences within a single language or across multiple languages are discussed. Such patterns help provide insight as to the effort required in retranslation due to a change in the documentation and help user communities estimated the progress of\u00a0\u2026", "num_citations": "5\n", "authors": ["202"]}
{"title": "A conceptual replication study on bugs that get fixed in open source software\n", "abstract": " Bugs dominate the corrective maintenance and evolutionary changes in large-scale software systems. The topic of bugs has been extensively investigated and reported in the literature. Unfortunately, the existential question of all \"whether a reported bug will be fixed or not\" has not received much attention. The paper presents an empirical study on four open source projects to examine the factors that influence the likelihood of a bug getting fixed or not. Overall, our study can be contextualized as a conceptual replication of a previous study on Microsoft systems from a commercial domain. The similarities and differences in terms of the design, execution, and results between the two studies are discussed. It was observed from these systems that the reputations of the reporter and assigned developer to fix it, and the number of comments on a bug have the most substantial impact on its probability to get fixed. Moreover\u00a0\u2026", "num_citations": "3\n", "authors": ["202"]}