{"title": "Architectural patterns revisited-a pattern language\n", "abstract": " Architectural patterns are a key concept in the field of software architecture: they offer well-established solutions to architectural problems, help to document the architectural design decisions, facilitate communication between stakeholders through a common vocabulary, and describe the quality attributes of a software system as forces. Regrettably, finding and applying the appropriate architectural patterns in practice still remains largely ad-hoc and unsystematic. This is due to the lack of consensus in the community with respect to the \u201cphilosophy\u201d and granularity of architectural patterns, as well as the lack of a coherent pattern language. In this paper we attempt to establish common ground in the architectural patterns community by proposing a pattern language that acts as a superset of the existing architectural pattern collections and categorizations. This language is particularly focused on establishing the relationships between the patterns and performs a categorization based on the concept of \u201carchitectural views\u201d.", "num_citations": "314\n", "authors": ["647"]}
{"title": "Smart contracts: security patterns in the ethereum ecosystem and solidity\n", "abstract": " Smart contracts that build up on blockchain technologies are receiving great attention in new business applications and the scientific community, because they allow untrusted parties to manifest contract terms in program code and thus eliminate the need for a trusted third party. The creation process of writing well performing and secure contracts in Ethereum, which is today's most prominent smart contract platform, is a difficult task. Research on this topic has only recently started in industry and science. Based on an analysis of collected data with Grounded Theory techniques, we have elaborated several common security patterns, which we describe in detail on the basis of Solidity, the dominating programming language for Ethereum. The presented patterns describe solutions to typical security issues and can be applied by Solidity developers to mitigate typical attack scenarios.", "num_citations": "212\n", "authors": ["647"]}
{"title": "Transformation strategies between block-oriented and graph-oriented process modelling languages\n", "abstract": " Much recent research work discusses the transformation between different process modeling languages. This work, however, is mainly focussed on specific process modeling languages, and thus the general reusability of the applied transformation concepts is rather limited. In this article, we aim to abstract from concrete transformations by distinguishing two major paradigms for representing control flow in process modeling languages: block-oriented languages (such as BPEL and BPML) and graph-oriented languages (such as BPMN, EPCs, and YAWL). The contribution of this article are generic strategies for transforming from block-oriented process languages to graph-oriented languages, and vice versa.", "num_citations": "189\n", "authors": ["647"]}
{"title": "An approach for the systematic development of domain\u2010specific languages\n", "abstract": " Building tailored software systems for a particular application domain is a complex task. For this reason,  domain\u2010specific languages (DSLs) receive a constantly growing attention in recent years. So far the main focus of DSL research is on case studies and experience reports for the development of individual DSLs, design approaches and implementation techniques for DSLs, and the integration of DSLs with other software development approaches on a technical level. In this paper, we identify and describe the different activities that we conduct when engineering a DSL, and describe how these activities can be combined in order to define a tailored DSL engineering process. Our research results are based on the experiences we gained from multiple different DSL development projects and prototyping experiments. Copyright \u00a9 2009 John Wiley & Sons, Ltd.", "num_citations": "177\n", "authors": ["647"]}
{"title": "Modeling process-driven and service-oriented architectures using patterns and pattern primitives\n", "abstract": " Service-oriented architectures are increasingly used in the context of business processes. However, the proven practices for process-oriented integration of services are not well documented yet. In addition, modeling approaches for the integration of processes and services are neither mature nor do they exactly reflect the proven practices. In this article, we propose a pattern language for process-oriented integration of services to describe the proven practices. Our main contribution is a modeling concept based on pattern primitives for these patterns. A pattern primitive is a fundamental, precisely specified modeling element that represents a pattern. We present a catalog of pattern primitives that are precisely modeled using OCL constraints and map these primitives to the patterns in the pattern language of process-oriented integration of services. We also present a model validation tool that we have developed to\u00a0\u2026", "num_citations": "112\n", "authors": ["647"]}
{"title": "Systematic literature review of the objectives, techniques, kinds, and architectures of models at runtime\n", "abstract": " In the context of software development, models provide an abstract representation of a software system or a part of it. In the software development process, they are primarily used for documentation and communication purposes in analysis, design, and implementation activities. Model-Driven Engineering (MDE) further increases the importance of models, as in MDE models are not only used for documentation and communication, but as central artefacts of the software development process. Various recent research approaches take the idea of using models as central artefacts one step further by using models at runtime to cope with dynamic aspects of ever-changing software and its environment. In this article, we analyze the usage of models at runtime in the existing research literature using the Systematic Literature Review (SLR) research method. The main goals of our SLR are building a common\u00a0\u2026", "num_citations": "106\n", "authors": ["647"]}
{"title": "Combining pattern languages and reusable architectural decision models into a comprehensive and comprehensible design method\n", "abstract": " When constructing software systems, software architects must identify and evaluate many competing design options and document the rationale behind any selections made. Two supporting concepts are pattern languages and architectural decision models. Unfortunately, both concepts only provide partial support: Extensive upfront education is needed for practitioners to be in command of' the full pattern literature relevant in their field; retrospective architectural decision modeling is viewed as a painful extra responsibility without immediate gains. In this paper, we combine pattern languages and reusable architectural decision models into a design method that is both comprehensive and comprehensible. Our design method identifies the required decisions in requirements models systematically, gives domain-specific pattern selection advice, and provides traceability from platform-independent patterns to platform\u00a0\u2026", "num_citations": "99\n", "authors": ["647"]}
{"title": "Systematic pattern selection using pattern language grammars and design space analysis\n", "abstract": " Software patterns provide reusable solutions to recurring design problems in a particular context. The software architect or designer must find the relevant patterns and pattern languages that need to be considered, and select the appropriate patterns, as well as the best order to apply them. If the patterns and pattern languages are written by multiple pattern authors, it might be necessary to identify interdependencies and overlaps between these patterns and pattern languages first. Out of the possible multitude of patterns and pattern combinations that might provide a solution to a particular design problem, one fitting solution must be selected. This can only be mastered with a sufficient expertise for both the relevant patterns and the domain in which they are applied. To remedy these issues we provide an approach to support the selection of patterns based on desired quality attributes and systematic design\u00a0\u2026", "num_citations": "99\n", "authors": ["647"]}
{"title": "XOTCL, an object-oriented scripting language\n", "abstract": " This paper describes the object-oriented scripting language XOTCL (Extended OTCL), which is a value added replacement of OTCL. OTCL implements dynamic and introspective language support for object-orientation on top of TCL. XOTCL includes the functionality of OTCL but focuses on the construction, management, and adaptation of complex systems. In order to combine the benefits of scripting languages with advanced object-oriented techniques, we extended OTCL in various ways: We developed the filter as a powerful adapation technique and an intuitive means for the instantiation of large program structures. In order to enable objects to access several addition-classes we improved the flexibility of mixin methods by enhancing the object model with per-object mixins. We integrated the object system with the TCL namespace concept to provide nested classes and dynamic object aggregations. Moreover, we introduced assertions and meta-data to improve reliability and self-documentation.", "num_citations": "95\n", "authors": ["647"]}
{"title": "A survey of patterns for service-oriented architectures\n", "abstract": " Service-Oriented Architectures (SOA) are a promising means to integrate heterogeneous systems, but virtually no technology-neutral approach to holistically understand SOAs exists. We tackle this problem by introducing a survey of technology-independent patterns that are relevant for SOAs, and are working towards a formalised pattern-based reference architecture model to describe SOA concepts.", "num_citations": "82\n", "authors": ["647"]}
{"title": "Patterns for business object model integration in process-driven and service-oriented architectures\n", "abstract": " Service-oriented architectures often have the goal to integrate various systems of one or more organizations in a flexible way to be able to quickly react on business changes. Integration based only on services, however, falls short in reaching this goal because the application-specific business object models of multiple external systems (especially legacy systems) need to be integrated into the service-oriented system. When multiple business object models must be integrated into one system, serious data integration issues might arise. Examples of such problems are incompatible data definitions, inconsistent data across the enterprise, data redundancy, and update anomalies. We present patterns that address these issues and describe how to integrate the application-specific business object models of various external systems into a consistent process-driven and service-oriented architecture.", "num_citations": "72\n", "authors": ["647"]}
{"title": "Model-driven and pattern-based integration of process-driven SOA models\n", "abstract": " Service-Oriented Architectures (SOA) are increasingly used in the context of business processes. However, the modelling approaches for process-driven SOAs do not yet sufficiently integrate the various kinds of models relevant for a process-driven SOA ? ranging from process models to software architectural models to software design models. We propose to integrate process-driven SOA models via a model-driven software development approach that is based on proven practices documented as software patterns. We introduce pattern primitives as an intermediate abstraction to precisely model the participants in the solutions that patterns convey. To enable model-driven development, we develop domain-specific modelling languages for each kind of process-driven SOA model ? based on meta-models that are extended with the pattern primitives. The various process-driven SOA models are integrated in a model\u00a0\u2026", "num_citations": "66\n", "authors": ["647"]}
{"title": "View-based and model-driven approach for reducing the development complexity in process-driven SOA\n", "abstract": " In process-driven, service-oriented architectures (SOA), process activities invoke services to perform the various tasks of the process. As the number of elements involved in a business process architecture, such as processes, process activities, and services, grows, the complexity of process development also increases along with the number of the elements\u2019 relationships, interactions, and data exchanges\u2013and quickly becomes hardly manageable. In addition, process-driven SOA models address different stakeholders, such as business experts and technical experts, who require different kinds of information for their work. Finally, process-driven SOA models must deal with constant changes\u2013both at the business level (eg business concept changes) and the technical level (eg technologies and platform changes). Separation of concerns is a promising approach to manage such development complexity. In this paper, we propose a view-based, model-driven approach with three major contributions: firstly, it captures different perspectives of a business process model in separate,(semi-) formalized views; secondly, it separates different abstraction levels in a business process architecture; thirdly, an extensible model-driven approach to integrate the different view models and abstraction levels is presented. Our approach is beneficial not only in reducing the process development complexity, but also in coping with dynamic changes at all abstraction levels.", "num_citations": "64\n", "authors": ["647"]}
{"title": "Compliance in service-oriented architectures: A model-driven and view-based approach\n", "abstract": " ContextEnsuring software systems conforming to multiple sources of relevant policies, laws, and regulations is significant because the consequences of infringement can be serious. Unfortunately, this goal is hardly achievable due to the divergence and frequent changes of compliance sources and the differences in perception and expertise of the involved stakeholders. In the long run, these issues lead to problems regarding complexity, understandability, maintainability, and reusability of compliance concerns.ObjectiveIn this article, we present a model-driven and view-based approach for addressing problems related to compliance concerns.MethodCompliance concerns are represented using separate view models. This is achieved using domain-specific languages (DSLs) that enable non-technical and technical experts to formulate only the excerpts of the system according to their expertise and domain\u00a0\u2026", "num_citations": "59\n", "authors": ["647"]}
{"title": "Design patterns for smart contracts in the ethereum ecosystem\n", "abstract": " The idea to digitally facilitate contract law and business practices through computer programs has led to the notion of smart contracts. Today's most prominent smart contract ecosystem is Ethereum, a blockchain based distributed computing platform. Due to the inherent nature of blockchain based contract execution, missing low level programming abstractions, and the constant evolution of platform features and security considerations, writing correct and secure smart contracts for Ethereum is a difficult task. Based on a Multivocal Literature Research and an analysis of the gathered data based on qualitative research methods, we mined a number of design patterns providing design guidelines. We describe those patterns in detail and provide exemplary code for better illustration. Our research shows that the patterns are widely used to address application requirements and common problems. We expect\u00a0\u2026", "num_citations": "58\n", "authors": ["647"]}
{"title": "Domain-specific language for event-based compliance monitoring in process-driven SOAs\n", "abstract": " Organizations today are required to adhere to a number of compliance concerns from laws, regulations and policies. Compliance is achieved through defining and implementing so-called controls in the organizations\u2019 business processes. Organizations that build their systems based on the process-driven SOA paradigm realize business processes through orchestration of services to handle the process\u2019 business activities. These business activities or groups of business activities in some cases realize the compliance controls. We propose an approach for implementing event-based compliance monitoring infrastructure that observes such business processes to verify that compliance is indeed adhered to. Our approach is essentially a model-driven technique for realizing this infrastructure. We implement a domain-specific language for specification of compliance directives, and we include code generation\u00a0\u2026", "num_citations": "47\n", "authors": ["647"]}
{"title": "Monitoring web service event trails for business compliance\n", "abstract": " Organizations today are required to adhere to a number of compliance concerns from laws, regulations and policies. Compliance is achieved through defining and implementing so-called controls in the organizations' business processes. Organizations that build their systems based on the process-driven SOA paradigm realize business processes through orchestration of services to handle the different process activities. We propose an approach for monitoring compliance in SOA systems - we represent a service invocation as an event, enabling us to map business process activities into trails of events that make up compliant processes. The event trails guide the creation of rules, which are leveraged by complex event processing techniques to monitor processes for compliance. A case study from the telecommunications sector demonstrates how we achieve compliance detection. In this case study, we use our\u00a0\u2026", "num_citations": "47\n", "authors": ["647"]}
{"title": "Querying semantic web resources using triple views\n", "abstract": " Resources on the Semantic Web are described by metadata based on some formal or informal ontology. It is a common situation that casual users are not familiar with a domain ontology in detail. This makes it difficult for such users (or their user tools) to formulate queries to find the relevant resources. Users consider the resources in their specific context, so the most straightforward solution is to formulate queries in an ontology that corresponds to a user-specific view. We present an approach based on multiple views expressed in ontologies simpler than the domain ontology. This allows users to query heterogeneous data repositories in terms of multiple, relatively simple, view ontologies. Ontology developers can define such view ontologies and the corresponding mapping rules. These ontologies are represented in Semantic Web ontology languages such as RDFS, DAML+OIL, or OWL. We present our\u00a0\u2026", "num_citations": "44\n", "authors": ["647"]}
{"title": "Modeling human aspects of business processes\u2013a view-based, model-driven approach\n", "abstract": " Human participation in business processes needs to be addressed in process modeling. BPEL4People with WS-HumanTask covers this concern in the context of BPEL. Bound to specific workflow technology this leads to a number of problems. Firstly, maintaining and migrating processes to new or similar technologies is expensive. Secondly, the low-level, technical standards make it hard to communicate the process models to human domain experts. Model-driven approaches can help to easier cope with technology changes, and present the process models at a higher level of abstraction than offered by the technology standards. In this paper, we extend the model-driven approach with a view-based framework for business process modeling, in which models can be viewed at different abstraction levels and different concerns of a model can be viewed separately. Our approach enables developers to\u00a0\u2026", "num_citations": "42\n", "authors": ["647"]}
{"title": "Reusable architectural decisions for DSL design: Foundational decisions in DSL development\n", "abstract": " Domain-specific languages (DSL) receive a constantly growing attention in the area of software development. However, so far the documentation of reusable architectural knowledge for DSL design is rather limited. In this paper, we systematically explore the DSL design space by combining reusable architectural decision modeling and software patterns. In particular, we have explored three reusable architectural decisions in this design space: the decision for the type of DSL development process, the decision for the concrete syntax style, and the decision for developing an external vs. an embedded DSL. These decisions are foundational for each DSL project. Each of these decisions has a number of (candidate) patterns for DSL design. These (candidate) patterns define alternative solutions in the shared context and problem space of the respective reusable architectural decision.", "num_citations": "41\n", "authors": ["647"]}
{"title": "Piecemeal legacy migrating with an architectural pattern language: A case study\n", "abstract": " Numerous large applications that have evolved over many years are well\u2010functioning and reliable, but have severe problems regarding flexibility and reuse. Due to the many fixes that were applied in a system's lifetime, it is often hard to customize, change or exchange system parts. Therefore, it is problematic to migrate such systems to a more flexible architecture or to new technologies. The document archive/retrieval system, discussed in this article, is an example of a large C system that had such problems. As a solution, we will sketch an architectural pattern language that involves patterns well\u2010suited for a piecemeal migration process. The patterns aim at building and composing highly flexible black\u2010box component architectures with an object\u2010oriented glueing layer. We present a re\u2010engineering case study for the document archive/retrieval system based on these patterns. The patterns are used to wrap the\u00a0\u2026", "num_citations": "41\n", "authors": ["647"]}
{"title": "Designing runtime variation points in product line architectures: three cases\n", "abstract": " Software product lines provide a common architecture, reusable code, and other common assets for a set of related software products. Variation is a central requirement in this context, as the product line components have to be instantiated, composed, and configured in the context of the products. In many approaches either static composition techniques or dynamic composition techniques based on loose relationships, such as association, aggregation, and replacement of entities, are proposed to design the variation points. If the domain of the product requires runtime variation, however, these approaches do not provide any central management facility for the runtime variation points. As a solution to this problem, we propose a pattern language that provides a domain-specific variation language and runtime variation point management facilities as part of the product line. We present three case studies from the\u00a0\u2026", "num_citations": "40\n", "authors": ["647"]}
{"title": "A systematic literature review of traceability approaches between software architecture and source code\n", "abstract": " The links between the software architecture and the source code of a software system should be based on solid traceability mechanisms in order to effectively perform quality control and maintenance of the software system. There are several primary studies on traceability between software architecture and source code but so far no systematic literature review (SLR) has been undertaken. This study presents an SLR which has been carried out to discover the existing traceability approaches and tools between software architecture and source code, as well as the empirical evidence for these approaches, their benefits and liabilities, their relations to software architecture understanding, and issues, barriers, and challenges of the approaches. In our SLR the ACM Guide to Computing Literature has been electronically searched to accumulate the biggest share of relevant scientific bibliographic citations from the major\u00a0\u2026", "num_citations": "37\n", "authors": ["647"]}
{"title": "A DSL toolkit for deferring architectural decisions in DSL-based software design\n", "abstract": " A number of mature toolkits and language workbenches for DSL-based design have been proposed, making DSL-based design attractive for many projects. These toolkits preselect many architectural decision options. However, in many cases it would be beneficial for DSL-based design to decide for the DSL\u2019s architecture later on in a DSL project, once the requirements and the domain have been sufficiently understood. We propose a language and a number of DSLs for DSL-based design and development that combine important benefits of different DSL toolkits in a unique way. Our approach specifically targets at deferring architectural decisions in DSL-based design. As a consequence, the architect can choose, even late in a DSL project, for options such as whether to provide the DSL as one or more external or embedded DSLs and whether to use an explicit language model or not .", "num_citations": "37\n", "authors": ["647"]}
{"title": "Supporting consistency between architectural design decisions and component models through reusable architectural knowledge transformations\n", "abstract": " In recent years, the software architecture community has proposed to use architectural design decisions (ADDs) for capturing the design rationale and the architectural knowledge (AK). As software systems evolve both ADDs and architectural designs need to be documented and maintained. This is a tedious and time-consuming task because of the lack of systematic and automated support for bridging between ADDs and designs. As a result, decisions and designs become inconsistent over time. We propose to alleviate this problem by introducing an AK transformation language supporting reusable AK transformations from pattern-based ADDs to component-and-connector models. In addition, we devise reusable consistency checking rules for verifying the consistency between decisions and designs. Through the use of model-driven transformations, as well as reusable, pattern-based decision models, we\u00a0\u2026", "num_citations": "36\n", "authors": ["647"]}
{"title": "Dynamically generating web application fragments from page templates\n", "abstract": " Web-based applications are typically required to be highly customizable and configurable. New application requirements have to be introduced rapidly, often without stopping the running application process. Moreover, in many cases the same business logic has to be presented to different channels and/or user interfaces. In this paper we present a dynamic page template architecture for decomposing configurable and representational fragments of the application from the business logic. Page templates consist of static XML files and of dynamic class definitions. The XML-based page templates can be used for declarative definitions of configurable fragments, say, by the end-user with a graphical tool. The page template classes can be used for behavior specification, say, for defining common styles of decoration of the presented pages. Both parts are dynamically loaded into the web application environment and\u00a0\u2026", "num_citations": "36\n", "authors": ["647"]}
{"title": "Reengineering to the web: A reference architecture\n", "abstract": " Reengineering existing (large-scale) applications to the Web is a complex and highly challenging task. This is due to a variety of demanding requirements for interactive Web applications. High performance is usually required, old interfaces still have to be supported, high availability requirements are usual, information has to be provided to multiple channels and in different formats, pages should contain individual layouts across different channels, styles should be imposed over presentation, etc. To achieve these goals a variety of different technologies and concepts have to be well understood, including HTTP protocol handling, persistent stores/databases, various XML standards, authentication, session management, dynamic content creation, presentational abstractions, and flexible legacy system wrapping. In a concrete project, all these components have to be integrated properly and appropriate technologies\u00a0\u2026", "num_citations": "35\n", "authors": ["647"]}
{"title": "An integrated approach for identity and access management in a SOA context\n", "abstract": " In this paper, we present an approach for identity and access management (IAM) in the context of (cross-organizational) service-oriented architectures (SOA). In particular, we defined a domain-specific language (DSL) for role-based access control (RBAC) that allows for the definition of IAM policies for SOAs. For the application in a SOA context, our DSL environment automatically produces WS-BPEL (Business Process Execution Language for Web services) specifications from the RBAC models defined in our DSL. We use the WS-BPEL extension mechanism to annotate parts of the process definition with directives concerning the IAM policies. At deployment time, the WS-BPEL process is instrumented with special activities which are executed at runtime to ensure its compliance to the IAM policies. The algorithm that produces extended WS-BPEL specifications from DSL models is described in detail. Thereby\u00a0\u2026", "num_citations": "34\n", "authors": ["647"]}
{"title": "Triple-and rdf rule language with context and use cases\n", "abstract": " Over the last couple of years the language has been deployed in various applications and use case studies. In this paper we first introduce the design principles of TRIPLE and then present some of the applications for which this language has been used.", "num_citations": "34\n", "authors": ["647"]}
{"title": "Pattern language for the design of aspect languages and aspect composition frameworks\n", "abstract": " Aspects avoid tangled solutions for crosscutting design concerns. Unfortunately there are various reasons why it may be hard to use an aspect language or aspect composition framework as a solution, even though developers are faced with crosscutting design concerns or tangled code structures. For instance, certain limitations of specific aspect composition frameworks might hinder the use of aspects. Or because of particular project requirements, such as constraints for the programming language or limitations of performance and memory, developers are not able to use an existing aspect composition framework. In such cases, developers would benefit from better understanding existing aspect composition frameworks. This would help developers to customise existing techniques or implement (simple) aspect composition frameworks from scratch. For these purposes, a pattern language is presented in the paper\u00a0\u2026", "num_citations": "34\n", "authors": ["647"]}
{"title": "Filters as a Language Support for Design Patterns in Object-Oriented Scripting Languages.\n", "abstract": " Scripting languages are designed for glueing software components together. Such languages provide features like dynamic extensibility and dynamic typing with automatic conversion that make them well suited for rapid application development. Although these features entail runtime penalties, modern CPUs are fast enough to execute even large applications in scripting languages efficiently.Large applications typically entail complex program structures. Object-orientation offers the means to solve some of the problems caused by this complexity, but focuses only on entities up to the size of a single class. The object-oriented design community proposes design patterns as a solution for complex interactions that are poorly supported by current object-oriented programming languages. In order to use patterns in an application, their implementation has to be scattered over several classes. This fact makes patterns hard to locate in the actual code and complicates their maintenance in an application.", "num_citations": "34\n", "authors": ["647"]}
{"title": "Enhancing object-based system composition through per-object mixins\n", "abstract": " The management of complexity in large systems is traditionally focused on the modeling and management of classes and hierarchies of classes. In order to improve the compositional flexibility in large systems, this paper turns the focus on objects rather than classes. It demonstrates that a more powerful object system can ease the development of large systems and can improve the degree of code reuse. The paper introduces per-object mixins as a new object-level language construct for object-based system composition. Per-object mixins are implemented in the scripting language XOT/sub CL/ as a straightforward extension of its method chaining mechanism and enables the developer to mix classes into the precedence order of an arbitrary object. Per-object mixins can be used to implement state-specific behavior changes in a clean way. We present per-object mixins as a general approach to hide object specifics\u00a0\u2026", "num_citations": "31\n", "authors": ["647"]}
{"title": "Architectural decision making for service-based platform integration: A qualitative multi-method study\n", "abstract": " Nowadays the software architecture of a system is often seen as a set of design decisions providing the rationale for the system design. When designing a software architecture multiple levels of design decisions need to be considered. For example, the service-based integration of heterogeneous platforms and the development of applications on top of those integration services requires high-level as well as technology-, domain-, and application-dependent architectural decisions. In this context, we performed a series of qualitative studies following a multi-method approach. First, we conducted a systematic literature review from which we derived a pattern language for platform integration featuring 40 patterns, as well as a pattern-based architectural decision model. Then, we performed interviews with 9 platform experts from 3 companies for revising the architectural knowledge captured by the pattern language and\u00a0\u2026", "num_citations": "30\n", "authors": ["647"]}
{"title": "View-based reverse engineering approach for enhancing model interoperability and reusability in process-driven SOAs\n", "abstract": " In many companies, process-driven SOAs are introduced using technical process languages, such as BPEL, to orchestrate services. The process models developed using this approach are often too complex and hard to reuse because all process-related concerns are tangled in only one type of model. To make the models more understandable for non-technical stakeholders, many companies additionally introduce high-level process descriptions, e.g., specified in BPMN or EPCs, to offer a non-technical view of the processes. This divergence of process languages often leads to inconsistencies after a few evolution steps. We propose a novel approach based on architectural views that not only offers models tailored to the various stakeholders\u2019 concerns but also provides an automated integration of models at different abstraction levels. In particular, we propose an extensible reverse-engineering tool-chain\u00a0\u2026", "num_citations": "30\n", "authors": ["647"]}
{"title": "VbTrace: using view-based and model-driven development to support traceability in process-driven SOAs\n", "abstract": " In process-driven, service-oriented architectures, there are a number of important factors that hinder the traceability between design and implementation artifacts. First of all, there are no explicit links between process design and implementation languages not only due to the differences of syntax and semantics but also the differences of granularity. The second factor is the complexity caused by tangled process concerns that multiplies the difficulty of analyzing and understanding the trace dependencies. Finally, there is a lack of adequate tool support for establishing and maintaining the trace dependencies between process designs and implementations. We present in this article a view-based, model-driven traceability approach that tackles these challenges. Our approach supports (semi-)automatically eliciting and (semi-)formalizing trace dependencies among process development artifacts at different\u00a0\u2026", "num_citations": "29\n", "authors": ["647"]}
{"title": "Tailorable language for behavioral composition and configuration of software components\n", "abstract": " Many software systems suffer from missing support for behavioral (runtime) composition and configuration of software components. The concern \u201cbehavioral composition and configuration\u201d is not treated as a first-class entity, but instead it is hard-coded in different programming styles, leading to tangled composition and configuration code that is hard to understand and maintain. We propose to embed a dynamic language with a tailorable object and class concept into the host language in which the components are written, and use the tailorable language for behavioral composition and configuration tasks. Using this approach we can separate the concerns \u201cbehavioral composition and configuration\u201d from the rest of the software system, leading to a more reusable, understandable, and maintainable composition and configuration of software components.", "num_citations": "29\n", "authors": ["647"]}
{"title": "Object system layer\n", "abstract": " In diesem Papier erl\u00e4utern wir einige Probleme der Komponierung, Konfiguration und Adaptierung von heterogenen Software-Komponenten. Einige bekannte Pattern k\u00f6nnen verwendet werden, um diese Problem zu l\u00f6sen. Aus diesen L\u00f6sungen entstand die Idee, die Pattern als systematisches Konzept f\u00fcr den Sprachentwurf zu verwenden\u2013welches dann in der Sprache Frag umgesetzt wurde.", "num_citations": "29\n", "authors": ["647"]}
{"title": "The software architect's role in the digital age\n", "abstract": " Internet scale, the increasing rate of technology evolution, and the broad adoption of lean and agile methods have triggered a profound change in not only application and infrastructure architectures but also the software architect's roles and responsibilities. This article reviews the field's state of the art, identifies the skills of the connected architect, and gives an overview of related education programs and knowledge sources.", "num_citations": "28\n", "authors": ["647"]}
{"title": "View-based integration of process-driven soa models at various abstraction levels\n", "abstract": " SOA is an emerging architectural style to achieve loosely-coupling and high interoperability of software components and systems by using message exchanges via standard public interfaces. In SOAs, software components are exposed as services and typically coordinated by using processes which enable service invocations from corresponding activities. These processes are described in high-level or low-level modeling languages. The extreme divergence in term of syntax, semantics and levels of abstraction of existing process modeling languages hinders the interoperability and reusability of software components or systems being built upon or relying on such models. In this paper we present a novel approach that provides an automated integration of modeling languages at different abstraction levels using the concept of architectural view. Our approach is realized as a view-based reverse engineering\u00a0\u2026", "num_citations": "27\n", "authors": ["647"]}
{"title": "High-level design and architecture of an http-based infrastructure for web applications\n", "abstract": " xoComm is a communication infrastructure for web applications based on the HTTP protocol. It provides an HTTP server and client access. Furthermore it is the basic communication service for the ActiWeb web object and mobile code system. The HTTP server component of xoComm is used to implement ActiWeb places. The places use the HTTP client access to provide the communication means for their agents. We present the design and architecture of xoComm on several crucial excerpts of the design. These are closely related to their implementation in the object-oriented scripting language XOTcl. We discuss how a dynamic and reflective environment, high-level language constructs, and concepts like design patterns influence the design and architecture.", "num_citations": "27\n", "authors": ["647"]}
{"title": "Object-based and class-based composition of transitive mixins\n", "abstract": " In object-oriented composition, classes and class inheritance are applied to realize type relationships and reusable building blocks. Unfortunately, these two goals might be contradictory in many situations, leading to classes and inheritance hierarchies that are hard to reuse. Some approaches exist to remedy this problem, such as mixins, aspects, roles, and meta-objects. However, in all these approaches, situations where the mixins, aspects, roles, or meta-objects have complex interdependencies among each other are not well solved yet. In this paper, we propose transitive mixins as an extension of the mixin concept. This approach provides a simple and reusable solution to define \u201cmixins of mixins\u201d. Moreover, because mixins can be easily realized on top of aspects, roles, and meta-objects, the same solution can also be applied to those other approaches.", "num_citations": "25\n", "authors": ["647"]}
{"title": "Patterns of tracing software structures and dependencies\n", "abstract": " Tracing the structures and dependencies in existing, formal source documents, such as code or design specifications, or in the running software system is required for many different software engineering areas. Typical uses include reengineering tools, programming languages and language extensions, aspect composition frameworks, self documentation, and visualizations. There are many recurring techniques used to gather and manipulate the relevant trace information. This paper presents a pattern language covering common techniques in this area, as well as technology projections and known uses. The target audience of this paper are developers who want to develop new solution or modify an existing solution in one of the named software engineering areas, as well as developers who want to gain a deeper understanding of the internal workings of the software engineering tools and frameworks they use.", "num_citations": "25\n", "authors": ["647"]}
{"title": "Ensuring and assessing architecture conformance to microservice decomposition patterns\n", "abstract": " Microservice-based software architecture design has been widely discussed, and best practices have been published as architecture design patterns. However, conformance to those patterns is hard to ensure and assess automatically, leading to problems such as architectural drift and erosion, especially in the context of continued software evolution or large-scale microservice systems. In addition, not much in the component and connector architecture models is specific (only) to the microservices approach, whereas other aspects really specific to that approach, such as independent deployment of microservices, are usually modeled in other views or not at all. We suggest a set of constraints to check and metrics to assess architecture conformance to microservice patterns. In comparison to expert judgment derived from the patterns, a subset of these constraints and metrics shows a good relative\u00a0\u2026", "num_citations": "24\n", "authors": ["647"]}
{"title": "Morse: A model-aware service environment\n", "abstract": " In a number of scenarios, services generated using a model-driven development (MDD) approach could benefit from \u00bfreflective\u00bf access to the information in the models from which they have been generated. Examples are monitoring, auditing, reporting, and business intelligence scenarios. Some of the information contained in the models of a service can statically be generated into its source code. In a distributed and changing environment this approach is limited, however, due to the fact that models and their relations evolve after the generation and deployment of a service. For example, the current model of a service might be different than the deployed version of the service. Our approach to solve this issue is a Model-Aware Service Environment (MORSE). It consists of a model repository that manages MDD projects and artifacts, and model-aware services that interact with the repository for performing reflective\u00a0\u2026", "num_citations": "24\n", "authors": ["647"]}
{"title": "Process-Driven SOA: Patterns for Aligning Business and IT\n", "abstract": " Process-Driven SOA: Patterns for Aligning Business and IT supplies detailed guidance on how to design and build software architectures that follow the principles of business-IT alignment. It illustrates the design process using proven patterns that address complex business/technical scenarios, where integrated concepts of service-oriented architecture (SOA), Business Process Management (BPM), and Event-Driven Architecture (EDA) are required. The book demonstrates that SOA is not limited to technical issues but instead, is a holistic challenge where aspects of SOA, EDA, and BPM must be addressed together. An ideal guide for SOA solution architects, designers, developers, managers, and students about to enter the field, the book: Provides an accessible introduction to basic and more advanced concepts in process-driven SOA Illustrates how to manage the complexities of business aligned IT architectures with detailed examples and industry cases Outlines a step-by-step design process using proven patterns to address complex business/technical scenarios Integrates SOA, BPM, and EDA into practical patterns promoting SOA 2.0 Describing how to synchronize parallel enterprise processes, the authors explain how to cope with the architectural and design decisions you are likely to encounter when designing and implementing process-driven SOA systems. The decisions are described in the form of software patterns to provide you with a practical guideline for addressing key problems using time-tested solutions.", "num_citations": "23\n", "authors": ["647"]}
{"title": "Enforcement of entailment constraints in distributed service-based business processes\n", "abstract": " ContextA distributed business process is executed in a distributed computing environment. The service-oriented architecture (SOA) paradigm is a popular option for the integration of software services and execution of distributed business processes. Entailment constraints, such as mutual exclusion and binding constraints, are important means to control process execution. Mutually exclusive tasks result from the division of powerful rights and responsibilities to prevent fraud and abuse. In contrast, binding constraints define that a subject who performed one task must also perform the corresponding bound task(s).ObjectiveWe aim to provide a model-driven approach for the specification and enforcement of task-based entailment constraints in distributed service-based business processes.MethodBased on a generic metamodel, we define a domain-specific language (DSL) that maps the different modeling-level\u00a0\u2026", "num_citations": "22\n", "authors": ["647"]}
{"title": "Tailoring a model-driven quality-of-service DSL for various stakeholders\n", "abstract": " Many service-oriented business systems have to comply to various contracts and agreements. Multiple technical and non-technical stakeholders with different background and knowledge are involved in modeling such business concerns. In many cases, these concerns are only encoded in the technical models and implementations of the systems, making it hard for non-technical stakeholders to get involved in the modeling process. In this paper we propose to tackle this problem by providing model-driven Domain-specific Languages (DSL) for specifying the contracts and agreements, as well as an approach to separate these DSLs into sub-languages at different abstraction levels, where each sub-language is tailored for the appropriate stakeholders. We exemplify our approach by describing a Quality-of-Service (QoS) DSL which can be used to describe Service Level Agreements (SLA). This work provides insights\u00a0\u2026", "num_citations": "21\n", "authors": ["647"]}
{"title": "A contract and rights management framework design for interacting brokers\n", "abstract": " Contract and rights management - and thus property rights protection -has gained increasing importance as a quality standard in brokerage and electronic commerce environments. Contract and rights management provides information on the legal relationships associated with digital assets, as well as intellectual property rights protection and the enforcement of rights. However, many brokerage and e-commerce platforms currently in operation were not originally designed to support contract and rights management. In this context, we identify open issues in digital contract and rights management and present a framework design to resolve these issues. This framework uses standardized XML-based rights expression languages, reuses an existing role-based access control component for rights enforcement, and is extensible with value-added service components for rights management. The reference project for our\u00a0\u2026", "num_citations": "21\n", "authors": ["647"]}
{"title": "Message redirector\n", "abstract": " Many object-oriented applications require explicit control over the message flow to support eg flexible wrapping, interceptions, modifications of messages, traces, etc. In object systems this control can also be used to express architectural semantics across several objects or classes. But most programming languages do not support such techniques as native language constructs. Therefore, build an explicit MESSAGE REDIRECTOR instance to control the method calls to (and within) the affected subsystems. Callbacks can be invoked during redirection to modify or extend dispatch-related semantics.", "num_citations": "21\n", "authors": ["647"]}
{"title": "Design and implementation constructs for the development of flexible, component-oriented software architectures\n", "abstract": " Component-orientation is an emerging paradigm that promises components that are usable as prefabricated black-boxes. But components have the problem that they should be changeable and flexibly adaptable to a huge number of different application contexts and to changing requirements. We will argue, that sole parameterization \u2014 as the key variation technique of components \u2014 is not suitable to cope with all required change scenarios. A proper integration with multiple other paradigms, such as object-orientation, the usage of a scripting language as a flexible component glue, and the exploitation of high-level interception techniques can make components be easier (ex)-changeable and adaptable. These techniques can be applied without interfering with the component\u2019s internals.", "num_citations": "21\n", "authors": ["647"]}
{"title": "DSL-based support for semi-automated architectural component model abstraction throughout the software lifecycle\n", "abstract": " In this paper we present an approach for supporting the semi-automated abstraction of architectural models throughout the software lifecycle. It addresses the problem that the design and the implementation of a software system often drift apart as software systems evolve, leading to architectural knowledge evaporation. Our approach provides concepts and tool support for the semi-automatic abstraction of architectural knowledge from implemented systems and keeping the abstracted architectural knowledge up-to-date. In particular, we propose architecture abstraction concepts that are supported through a domain-specific language (DSL). Our main focus is on providing architectural abstraction specifications in the DSL that only need to be changed, if the architecture changes, but can tolerate non-architectural changes in the underlying source code. The DSL and its tools support abstracting the source code into\u00a0\u2026", "num_citations": "20\n", "authors": ["647"]}
{"title": "Constraint-based consistency checking between design decisions and component models for supporting software architecture evolution\n", "abstract": " Software architecture evolution has become an integral part of the software lifecycle. Thus, the maintenance of a software system involves among others the maintenance of the software system architecture. Component models are widely used as an essential view to describe software architectures. In recent years, the software architecture community has proposed to additionally model the architectural design decisions for capturing the design rationale and recording the architectural knowledge. Unfortunately, there are no formal relations between design decisions and component models. This leads to potential inconsistencies between the two kinds of models as the software system evolves. In this paper, we propose to overcome this problem by introducing a constraint-based approach for checking the consistency between the decisions and the corresponding component models. Our approach enables explicit\u00a0\u2026", "num_citations": "20\n", "authors": ["647"]}
{"title": "Model-aware monitoring of SOAs for compliance\n", "abstract": " Business processes today are supported by process-driven service oriented architectures. Due to the increasing importance of compliance of an organization with regulatory requirements and internal policies, there is a need for appropriate techniques to monitor organizational information systems as they execute business processes. Event-based monitoring of processes is one of the ways to provide runtime process-state information. This type of monitoring, however, has limitations mostly related to the type and amount of information available in events and process engines. We propose a novel approach \u2013 model-aware monitoring of business processes \u2013 to address these limitations. Emitted events contain unique identifiers of models that can be retrieved dynamically during runtime from a model-aware repository and service environment (MORSE). The size of the events is kept small and patterns of events\u00a0\u2026", "num_citations": "20\n", "authors": ["647"]}
{"title": "Human-computer-human interaction patterns: Workshop on the human role in HCI patterns\n", "abstract": " The idea of patterns originated from Christopher Alexander\u2019s work [1],[2] in urban architecture, although similar formats to document successful design and engineering solutions emerged among the renaissance \u201cmaster builders\u201d of the fifteenth century [5]. They espouse an approach to design\u2013codified in the patterns\u2013that focuses on the interactions between the physical form of buildings and the way in which that form inhibits or facilitates various personal and social behaviour. An interconnected set of patterns is called a pattern language. Patterns of a pattern language are intended to be used together in a specific problem domain.", "num_citations": "20\n", "authors": ["647"]}
{"title": "The supportive effect of traceability links in architecture-level software understanding: Two controlled experiments\n", "abstract": " The advocates of architecture traceability approaches regularly cite advantages like easier understanding of architectural designs and support for software quality control and maintenance. However, the lack of published empirical data on the usefulness of architecture traceability is one of the reasons that prevents the wide adoption of traceability approaches in industrial settings. This paper reports on two controlled experiments performed with different participants to investigate whether the use of architecture traceability can significantly support architecture-level understanding activities. The replications with different participants allowed us to investigate whether the participants' experience plays a significant role in the understanding of software architectures with or without traceability information. In particular, we designed twelve typical questions aimed at gaining an architecture-level understanding of a\u00a0\u2026", "num_citations": "19\n", "authors": ["647"]}
{"title": "A pattern language for process execution and integration design in service-oriented architectures\n", "abstract": " Process-driven SOAs are using processes to orchestrate services. Designing a non-trivial process-driven SOA involves many difficult design and architectural decisions. Examples are: Different kinds of processes exist: long-running, business-oriented and short-running, technical processes. How to best integrate them and how to map them to execution platforms? A SOA has many different stakeholders, such as business analysts, management, software designers, architects, and developers, as well as many different types of models these stakeholders need to work with. How to present each of them with the best view on the models they need for their work? A realistic process-driven SOA contains many systems that need to be integrated, such as various process engines, services, and backend systems, running on heterogeneous technologies and platforms. How to perform integration in a way that is\u00a0\u2026", "num_citations": "19\n", "authors": ["647"]}
{"title": "Software metrics for measuring the understandability of architectural structures: a systematic mapping study\n", "abstract": " The main idea of software architecture is to concentrate on the\" big picture\" of a software system. In the context of object-oriented software systems higher-level architectural structures or views above the level of classes are frequently used to capture the\" big picture\" of the system. One of the critical aspects of these higher-level views is understandability, as one of their main purposes is to enable designers to abstract away fine-grained details. In this article we present a systematic mapping study on software metrics related to the understandability concepts of such higher-level software structures with regard to their relations to the system implementation. In our systematic mapping study, we started from 3951 studies obtained using an electronic search in the four digital libraries from ACM, IEEE, Scopus, and Springer. After applying our inclusion/exclusion criteria as well as the snowballing technique we selected 268\u00a0\u2026", "num_citations": "18\n", "authors": ["647"]}
{"title": "Pattern-based design of a service-oriented middleware for remote object federations\n", "abstract": " Service-oriented middleware architectures should enable the rapid realization of loosely coupled services. Unfortunately, existing technologies used for service-oriented middleware architectures, such as Web services, P2P systems, coordination and cooperation technologies, and spontaneous networking, do not fully support all requirements in the realm of loosely coupled business services yet. Typical problems that arise in many business domains are for instance missing central control, complex cooperation models, complex lookup models, or issues regarding dynamic deployment. We used a pattern-based approach to identify the well working solutions in the different technologies for loosely coupled services. Then we reused this design knowledge in our concept for a service-oriented middleware. This concept is centered around a controlled environment, called a federation. Each remote object (a peer service\u00a0\u2026", "num_citations": "18\n", "authors": ["647"]}
{"title": "Distributed web application development with active web objects\n", "abstract": " 6@'& fT! cG8 G TS RUTWVXG% Y5F)(k FG@ 1 \u00fa \u00fbz\u00fc 6 \u00ffHd! U\u00ffE\u00a6 \u00fc E2#(i\u00ff\u00a1 &3#% \u00fb\u00a6 \u00fc HS\u00ff\u00a1 3\u00a6\u00a5\u00a2 \u00fc'\u00ff\u00a1 hm\u00a4 \u00fc 6T#(BU i#\u00a4 \u00fc H\u00a6\u00a5 Hd@! 3\u00a2 \u00fc HS\u00fc EF#\u00a1 E w\u00a1 E5\u00a4\" x \u00fc E2 U\u00a6) W\u00ffE5HS\u00fc E2# & \u00ff\u00a1 HS\u00ff8@ 3\u00a6 9\u00a2 \u00c5\u00fca 8X {\u00fc E2#(\u00a9 W Hd! U\u00ff\u00a1(#(\u00a1 E2# 6 \u00ffHd! U\u00ffE\u00a6 \u00fc E2#(d 8% \u00fceHS\u00ff\u00a1 3\u00a6 9\u00a2 \u00c5\u00fc 8X {\u00fc E2#(\u00a9 43! R\u00a2\u00a5\u00a1 6 \u00fc\u00a9 45\u00a1 E5\u00a4 e 8X {\u00fc E2#\" HI\u00a1 E5 8X {\u00fc Hp\u00fc EF#\u00a9 Wc\u00fa\u00ffI\u00a2 \u00c5\u00fc\u00a9# P c\u00fc\u00a9 S\u00ff\u00a1 hm\u00a4 \u00fc 6T# h \u00fcq 83\u00a2 \u00fc#\u00a4 \u00ff U\u00fcq6\u00a9\u00a1\u00a2\u00a5\u00a2 \u00c5\u00fc\u00a4 h\u00a6\u00a5% \u00fc HS\u00ff\u00a1#\u00a4 \u00fcP6\u00a9\u00a1\u00a2\u00a5\u00a2 r4#% \u00fb\u00a6 \u00fc c\u00fc\u00a9 g\u00ff\u00a1 Dm\u00d9\u00fc 6T# 6\u00a9\u00a2\u00a5\u00a1(\u00a6 \u00fb5\u00a1 HS\u00fc\u00a9#% \u00fb\u00a6 \u00ffh\u00a4 1032547698A@ 5BA8C67DAE#% \u00fb5 8# 7\u00a2 \u00c5\u00fc\u00a9#($\u00a1 E\u00ae \u00ff\u00a1 hm\u00a4 \u00fc 6T# 7\u00a4 5BUE5\u00a1 H%\u00a6\u00a5 6\u00a9\u00a1\u00a2\u00a5\u00a2) Bf (! \u00fc 6\u00a9\u00a6\u00a5 &vB@ \u00fb5\u00a6\u00a5 6s\u00fb HS\u00fc\u00a9#% \u00fbz\u00ffU\u00a4 5 8% \u00fcP6\u00a9 1D (% \u00fc E2#(\u00a2) B \u00fcTSU! U\u00ff\u00a1(#\u00a4 \u00fc\u00a4 I & \u00ff\u00a1' W\u00fc HS\u00ff\u00a1#\u00a4 \u00fc\" 6\u00a9\u00a1\u00a2\u00a5\u00a2\u00a5 W} E3\u00a2) B|#% \u00fb\u00a6 \u00fc\u00a4 \u00fcaHp\u00fc\u00a9#% \u00fb\u00a6 \u00ffU\u00a4 6\u00a9\u00a1\u00a2\u00a5\u00a2\u00a5 8% \u00fc\u00a4 5\u00a6\u00a5 i! 3 8#(6s\u00fb\u00a6 \u00fc\u00a4 c 2B#% \u00fb\u00a6 \u00fc! 3\u00a2 9\u00a1 6 \u00fc\u00a1 W vw\u00a2 9\u00a2 U\u00ff\u00a1#% \u00fb\u00a6 \u00fc\u00a9\" 6\u00a9\u00a1\u00a2\u00a5\u00a2\u00a5 P% \u00fc (15\u00a2)# q\u00a6\u00a5 Ee\u00a1 EY oe\u00fa \u00fa\"~ \u00fc\u00a9(% \u00ff\u00a1 W v {\u00fc\u00a9(Bf% \u00fc Hp\u00ff\u00a1#\u00a4 \u00fc 6\u00a9\u00a1\u00a2\u00a5\u00a2\u00a6\u00a5 g\u00fb5\u00a1 E5\u00a4 5\u00a2 \u00fc\u00a4 h\u00a6\u00a5#% \u00fb\u00a6 \u00fc|! 3\u00a2\u00a5\u00a1 6 \u00fc\u00a1 W\u00a2\u00a5\u00a1 6 \u00fc I 8% \u00fcY13E5\u00a6\u00a5 0U1\u00a6 \u00fca#\u00a4 \u00ff! 5% \u00ffh6 \u00fc (d\u00a1 E5\u00a4 b 15E3\u00a1 H 3\u00a6\u00a5 X1h@ \u00ff15\u00a3\u00a2) B\u00a6\u00a5\u00a4 z\u00fc EF#(\u00a6) i \u00fc\u00a4 \u00dcB\u00ac \u00fbz\u00ffi# $ E5\u00a1 HS\u00fc\u00a1 E5\u00a4 \u00a7 ! U\u00ff\u00a1(#\u00a9 W\u00bf \u00fa \u00fbz\u00fc! 3\u00a2 9\u00a1 6 \u00fcb\u00a6\u00a5 ui! U\u00fc 6\u00a9\u00a6\u00a5\u00a1\u00a2\u00a5\u00a6) 8R\u00a2 \u00c5\u00fc 79PA2C ED FHGIA dAezufrW vw\u00a2 9\u00a2 c\u00fc\u00a9# \u00ff\u00a1 Dm\u00d9\u00fc 6T#(8% \u00fc\u00a1\u00a2 9\u00a4 \u00ffw\u00a6\u00a5\u00a4 z\u00fc EF#(\u00a6) i \u00fc\u00a4 15E5\u00a1 H 3\u00a6) X1\u00a6 \u00ff15\u00a3\u00a2) Bw \u00dcB", "num_citations": "18\n", "authors": ["647"]}
{"title": "Implementing object-specific design patterns using per-object mixins\n", "abstract": " 68 7@ 9BADCFEHGPIQ9SRDTV UXWYaWPbd ceg fd hBipfqeSes rut@ cvhStw ceX xyc\" cF\u00a5 t 1 B Bh hgq B@ y Q (fQ $ DdD Dhq 3 ce wpq VQ 1\u00a5 t B Dh\" h 3 QB fcxX icv gh\u00a5 t\u00a9 hBipfqeSei t cv fq hStag j \u00f5 \u00b5 \u00e9\u00a3\u00a4 g T n \u00f0s f\u00a3 fg \u00ca\u00b1f E \u00aa0 f\u00a5\u00a4\u00a1\u00a2\u00a2\u00a3 \u00ca\u00a6 \u00c4\u00a2\u00a6 T\u00c4\u00ee\u00b1f \u00a7 \u00b1f\u00a4\u00a2\u00a3 4\u00b1\u00abf \u00abf \u00ca\u00a4 t \u00ca\u00abfg \u00ab\u00ba\u00a4\u00a1\u00a2\u00a2\u00a3 \u00f5F q\u00a5\u00a1\u00a6\u00a5 4\u00a5\u00a9 2\u00a3\u00ac g \u00ca\u00a3 f\u00a1 5\u00a5g\u00ac f\u00a5 \u00b5 s \u00ec \u00aaT\u00a5 n\u00a4\u00a1 f\u00a2\u00a3 \u00a7 \u00a6 \u00c4 \u00abv\u00b6\u00a4 g\u00a5 v\u00a4\u00a1\u00a2\u00a2\u00a3\u00a1\u00a9 q\u00b1fi \u00aaf\u00a5\u00a2 \u00d0T f lk\" mq4 $ mQ2S \u00a7 \u00b1f\u00a4\u00a2% \u00d6l\u00b1f\u00ac'\u00a7 f\u00b1f\u00a4\u00a2 $ s\u00a3 f\u00a3 \u00aa\u00a2 k \u00cf\u00a6\u00ac nk\u00a4% \u00aa0 f\u00a5\u00bb\u00a4\u00a1\u00a2\u00a2\u00a3 k \u00a7 \u00c4\u00a2\u00abkg\u00a6\u00ab\u00a4 h \u00b2\u00a6\u00b1f F \u00aaf\u00a5\u00a4 gs\u00a5 g \u00ca \u00a7 \u00a5\u00a4 \u00ba\u00a5g\u00ac f\u00a5 to\u00a6 \u00aaf \u00abF \u00a7 \u00a6 \u00c4 \u00ab\u00d6l\u00b1l\u00b6\u00a4 g \u00ab\u00a6\u00a4 hl \u00abf \u00dc\u00a2 \u00d0 y\u00b1f \u00ca\u00a3\u00ac gn Vn $ T po@ mQ4\" q $ \u00c9\u00cc \u00b2\u00b12$ \u00a7 f\u00b1f\u00a4\u00a2 \u00ce\u00a5 fs \u00abn\u00a5\u00a9 o@ mq4 qq\u00a4 g\u00a6\u00b1\u00cf\u00a6 ng\u00a3 j\u00cf\u00a4 t\u00a3\u00ac g (nw rQs tqu uw v vw xSy uBz {Q| q} Qs {Q| q} Qq s {Qzau uD QsD p~ s tqu uB yq z rQs tqu u\u00a1 x H x H xSy uBz {Q| q} Q~\u00a1{Q| q} Qq\u00a1 d {Qzau uD QsD p~ s tqu uB yq z vt t@ x HxSyd x H", "num_citations": "18\n", "authors": ["647"]}
{"title": "Interface representation patterns: Crafting and consuming message-based remote apis\n", "abstract": " Remote Application Programming Interfaces (APIs) are technology enablers for major distributed system trends such as mobile and cloud computing and the Internet of Things. In such settings, message-based APIs dominate over procedural and object-oriented ones. It is hard to design such APIs so that they are easy and efficient to use for client developers. Maintaining their runtime qualities while preserving backward compatibility is equally challenging for API providers. For instance, finding a well suited granularity for services and their operations is a particularly important design concern in APIs that realize service-oriented software architectures. Due to the fallacies of distributed computing, the forces for message-based APIs and service interfaces differ from those for local APIs--for instance, network latency and security concerns deserve special attention. Existing pattern languages have dealt with local APIs in\u00a0\u2026", "num_citations": "17\n", "authors": ["647"]}
{"title": "Impact analysis for event-based systems using change patterns\n", "abstract": " Being composed of highly decoupled components, event-driven architectures are promising solutions for facilitating high flexibility, scalability, and concurrency of distributed systems. However, analyzing, maintaining, and evolving an event-based system are challenging tasks due to the intrinsic loose coupling of its components. One of the major obstacles for analyzing an event-based system is the absence of explicit information on the dependencies of its components. Furthermore, assisting techniques for analyzing the impacts of certain changes are missing, hindering the implementation the changes in event-based architectures. We presented in this paper a novel approach to supporting impact analysis based on the notion of change patterns formalized using trace semantics. A change pattern is an abstraction of the modification actions performed when evolving an event-based system. Based on this formal\u00a0\u2026", "num_citations": "17\n", "authors": ["647"]}
{"title": "View-based model-driven architecture for enhancing maintainability of data access services\n", "abstract": " In modern service-oriented architectures, database access is done by a special type of services, the so-called data access services (DAS). Though, particularly in data-intensive applications, using and developing DAS are very common today, the link between the DAS and their implementation, e.g. a layer of data access objects (DAOs) encapsulating the database queries, still is not sufficiently elaborated, yet. As a result, as the number of DAS grows, finding the desired DAS for reuse and/or associated documentation can become an impossible task. In this paper we focus on bridging this gap between the DAS and their implementation by presenting a view-based, model-driven data access architecture (VMDA) managing models of the DAS, DAOs and database queries in a queryable manner. Our models support tailored views of different stakeholders and are scalable with all types of DAS implementations. In this\u00a0\u2026", "num_citations": "17\n", "authors": ["647"]}
{"title": "Domain-specific languages for service-oriented architectures: An explorative study\n", "abstract": " Domain-specific languages (DSLs) are an important software development approach for many service-oriented architectures (SOAs). They promise to model the various SOA concerns in a suitable way for the various technical and non-technical stakeholders of a SOA. However, so far the research on SOA DSLs concentrates on novel technical contributions, and not much evidence or counter-evidence for the claims associated to SOA DSLs has been provided. In this paper, we present a qualitative, explorative study that provides an initial analysis of a number of such claims through a series of three prototyping experiments in which each experiment has developed, analyzed, and compared a set of DSLs for process-driven SOAs. Our result is to provide initial evidence for a number of popular claims about SOA DSLs which follow the model-driven software development (MDSD) approach, as well as a list of\u00a0\u2026", "num_citations": "17\n", "authors": ["647"]}
{"title": "Some patterns of component and language integration\n", "abstract": " Integration is an important concern in many software systems. In this paper, we present a number of patterns that are used to improve the integration of a system with components or code that is written in different languages than the system itself. Component integration is necessary when (foreign) components should be used within a system. The challenge of integrating components into a system is that heterogeneous kinds of components exist, perhaps without distinct interfaces or other component boundaries. The task of the component integration code is to provide suitable, stable invocation interfaces and to compose the components with the system. Sometimes, however, invocation and composition of components is not enough, but a deeper language integration is required. Examples of what might be need are automatic type conversions between languages, preserving the destruction order of the other language, automatic forwarding of invocations into the other language, and runtime integration of foreign language components. The patterns, presented in this paper, are successful solutions in these areas. Each of these patterns plays an important role in different integration architectures. We will give examples from the areas of distributed systems, reengineering projects, scripting languages, and aspect-oriented programming systems. There are many others fields where the patterns are used as well.", "num_citations": "17\n", "authors": ["647"]}
{"title": "Embracing process compliance and flexibility through behavioral consistency checking in ACM: A repair service management case\n", "abstract": " Enabling flexibility in unpredictable situations with ad hoc actions decided at runtime by knowledge workers is the main focus of Adaptive Case Management (ACM) systems. However, ad hoc actions added during case execution and ACM templates prepared at design time need to be within the boundaries defined by business constraints, company regulations and legal systems. In this paper we report our experience in addressing this challenge by using model checking and runtime monitoring techniques for behavioral consistency checking that can handle both ACM aspects: support by means of predefined process templates and high flexibility by allowing ad hoc actions at runtime. Our study is conducted using a practical ACM system for repair service management handling different customer requirements under diverse compliance and law regulations.", "num_citations": "16\n", "authors": ["647"]}
{"title": "Semi-automated architectural abstraction specifications for supporting software evolution\n", "abstract": " In this paper we present an approach for supporting the semi-automated architectural abstraction of architectural models throughout the software life-cycle. It addresses the problem that the design and implementation of a software system often drift apart as software systems evolve, leading to architectural knowledge evaporation. Our approach provides concepts and tool support for the semi-automatic abstraction of architecture component and connector views from implemented systems and keeping the abstracted architecture models up-to-date during software evolution. In particular, we propose architecture abstraction concepts that are supported through a domain-specific language (DSL). Our main focus is on providing architectural abstraction specifications in the DSL that only need to be changed, if the architecture changes, but can tolerate non-architectural changes in the underlying source code. Once the\u00a0\u2026", "num_citations": "16\n", "authors": ["647"]}
{"title": "Exploring the relationships between the understandability of components in architectural component models and component level metrics\n", "abstract": " Architectural component models represent high level designs and are frequently used as a central view of architectural descriptions of software systems. The components in those models represent important high level organization units that group other components and classes in object-oriented design views. Hence, understandability of components and their interactions plays a key role in supporting the architectural understanding of a software system. In this paper we present a study we carried out to examine the relationships between the effort required to understand a component, measured through the time that participants spent on studying a component, and component level metrics that describe component's size, complexity and coupling in terms of the number of classes in a component and the classes' relationships. The participants were 49 master students, and they had to fully understand the\u00a0\u2026", "num_citations": "16\n", "authors": ["647"]}
{"title": "Automated mapping of UML activity diagrams to formal specifications for supporting containment checking\n", "abstract": " Business analysts and domain experts are often sketching the behaviors of a software system using high-level models that are technology- and platform-independent. The developers will refine and enrich these high-level models with technical details. As a consequence, the refined models can deviate from the original models over time, especially when the two kinds of models evolve independently. In this context, we focus on behavior models; that is, we aim to ensure that the refined, low-level behavior models conform to the corresponding high-level behavior models. Based on existing formal verification techniques, we propose containment checking as a means to assess whether the system's behaviors described by the low-level models satisfy what has been specified in the high-level counterparts. One of the major obstacles is how to lessen the burden of creating formal specifications of the behavior models as well as consistency constraints, which is a tedious and error-prone task when done manually. Our approach presented in this paper aims at alleviating the aforementioned challenges by considering the behavior models as verification inputs and devising automated mappings of behavior models onto formal properties and descriptions that can be directly used by model checkers. We discuss various challenges in our approach and show the applicability of our approach in illustrative scenarios.", "num_citations": "16\n", "authors": ["647"]}
{"title": "Model-driven integration and management of data access objects in process-driven soas\n", "abstract": " In most process-driven and service oriented architectures (SOA), services need to access data stored in a database using database transactions. This is typically done using Data Access Objects (DAOs), but so far the integration of the business process, service, and DAO concepts is not well defined. As a consequence, when the number of services in a SOA grows, the number of DAOs can increase considerably and become hard to manage. In addition to this technical issue, business processes have to be highly adaptable to both functional and technical requirements. We propose a model-driven approach for integrating and managing DAOs in process-driven SOAs. We present a set of models providing different views tailored to the requirements of various stakeholders, such as business experts, database designers, database developers, etc. In process-driven SOAs, process activities running in a process\u00a0\u2026", "num_citations": "16\n", "authors": ["647"]}
{"title": "Reusable architectural decision model for model and metadata repositories\n", "abstract": " Models are gaining importance in software development, for instance in the MDD field, as well as in other disciplines such as biology and physics. Hence, tool support is needed to manage these models and metadata about the models. Model repositories support this trend by managing these model artifacts. While setting up model and metadata repositories, architects have to make several fundamental design decisions and balance various forces. In this paper we describe reusable knowledge in form of reusable architectural decisions for IT-architects in setting-up, planning, and developing model and metadata repositories, as well as the main decision drivers. Our decisions are documented in a reusable architectural decision model that can be instantiated for a concrete system. It also supports a lightweight approach to architecture documentation. A case study illustrates the decisions made when setting\u00a0\u2026", "num_citations": "16\n", "authors": ["647"]}
{"title": "Modeling composition in dynamic programming environments with model transformations\n", "abstract": " Although dynamic programming environments are in widespread use, only basic runtime composition mechanisms are covered by today\u2019s modeling languages. Thus, it is common in real-world development projects that dynamic compositions are not modeled formally and are consequently hard to use, for example together with the model-driven paradigm where formal models are essential to generate source code. In this paper, we propose an approach based on model transformations between the valid structural and behavioral runtime states that a system can have. We use UML 2.0 class and activity diagrams for specifying the structural and behavioral model states and provide a UML 2.0 meta-model extension for describing the valid model transformations between corresponding model states.", "num_citations": "16\n", "authors": ["647"]}
{"title": "Using split objects for maintenance and reengineering tasks\n", "abstract": " Language integration is an important issue in the area of software maintenance and reengineering. We describe a novel solution in this area: automatically applied and composed split objects. Split objects provide a language integration that goes beyond simple wrappers by integrating object identity, state, methods, and class hierarchies of entities in two languages to one logical entity. The split object concept can be applied as an aspect-oriented solution, in which an aspect of a system is implemented in another language. After describing these concepts and two split object frameworks that we have implemented, we discuss how split objects can be applied for other maintenance and reengineering tasks than language integration. These application fields include software component testing, dynamic feature analysis, and variation and configuration management.", "num_citations": "16\n", "authors": ["647"]}
{"title": "Content conversion and generation on the web: A pattern language\n", "abstract": " Interactive, Web-based applications generate formatted content on request. That is, the content is not available or only partially available in pre-built files.", "num_citations": "16\n", "authors": ["647"]}
{"title": "On the understandability of semantic constraints for behavioral software architecture compliance: A controlled experiment\n", "abstract": " Software architecture compliance is concerned with the alignment of implementation with its desired architecture and detecting potential inconsistencies. The work presented in this paper is specifically concerned with behavioral architecture compliance. That is, the focus is on semantic alignment of implementation and architecture. In particular, this paper evaluates three representative approaches for describing semantic constraints in terms of their understandability, namely natural language descriptions as used in many architecture documentations today, a structured language based on specification patterns that abstract underlying temporal logic formulas, and a structured cause-effect language that is based on Complex Event Processing. We conducted a controlled experiment with 190 participants using a simple randomized design with one alternative per experimental unit. Overall all approaches support a\u00a0\u2026", "num_citations": "15\n", "authors": ["647"]}
{"title": "Concepts for model-driven design and evolution of domain-specific languages\n", "abstract": " Recently a number of concepts, such as software factories, model-driven software development, and language-oriented programming, advocate the use of model-driven domain-specific languages to express domain models. In contrast to many traditional uses of domain-specific languages, this approach leverages the systematic use of domain-specific languages. In this position paper, we identify open issues in this approach, arising when the domain-specific languages are complex or constantly evolving. We introduce the concept of a domain-specific language product line, which provides a common, tailorable language infrastructure to enable the rapid, model-driven creation and evolution of domain-specific languages. Moreover, we propose our vision to use a domain-specific language product line as a conceptual glue between the many concepts and approaches used inside a software factory.", "num_citations": "15\n", "authors": ["647"]}
{"title": "Anticipating scientific software evolution as a combined technological and design approach\n", "abstract": " Evolution in scientific software is often according to a specific pattern of software changes: professional scientists, who are not professional software developers, need rapid, dynamic, and domain-specific changes of the software they work this. To address unanticipated software evolution in this field, our objective is to enable these end-users (here: biologists) to change software from the user interface. An approach is presented that integrates technological and methodological solutions. We explain why these solutions are complementary, and how they can be integrated and co-evolved from software design to actual use.", "num_citations": "15\n", "authors": ["647"]}
{"title": "Language support for dynamic and evolving software architectures\n", "abstract": " It is a pleasure for me to thank the many people who supported me in creating this dissertation. First of all, I would like to thank my advisors, Michael Goedicke and Gustaf Neumann, for their great support and input. Both contributed significantly to improving my work, and it is a pleasure to work with them.", "num_citations": "15\n", "authors": ["647"]}
{"title": "A model checking based approach for containment checking of uml sequence diagrams\n", "abstract": " The main challenge in software development process is to detect and fix the deviations of system's behaviors at different abstraction levels in early phases. For this purpose, UML 2 sequence diagrams are widely used for describing and analyzing the communication behavior of software systems. This paper describes a containment checking approach for UML 2 sequence diagrams to verify whether the behavior (or functions) described by a low-level model conforms those specified in the high-level counterpart based on model checking techniques, in order to improve the system's quality. However, creating consistency constraints and formal specifications for the sequence diagrams is a labor-intensive and error prone task. To alleviate this issue, we propose an automated transformation of sequence diagrams into formal specifications and consistency constraints that enable us to leverage the analytical powers of\u00a0\u2026", "num_citations": "14\n", "authors": ["647"]}
{"title": "Event actors based approach for supporting analysis and verification of event-driven architectures\n", "abstract": " Event-based communication styles are potential solutions for facilitating high flexibility, scalability, and concurrency of distributed systems due to the intrinsic loose coupling of the participants. However, software developers often find the event-driven communication style unintuitive, especially for large and complex systems with numerous constituting elements, because of its non-deterministic characteristics. In this paper, we propose a novel approach based on DERA-an event actor-based framework-which can be used to describe distributed event-based systems with reduced nondeterminism. DERA's graphical notations support representing a current snapshot of an event-based system closely to the intuitive perception of the developers. We propose a formal specification of the event actors-based constructs and the graphical notations based on Petri nets in order to enable formal analysis of such snapshots\u00a0\u2026", "num_citations": "14\n", "authors": ["647"]}
{"title": "Automating the management and versioning of service models at runtime to support service monitoring\n", "abstract": " In a model-driven service-oriented architecture (SOA), the services are in large parts generated from models. To facilitate monitoring, governance, and self-adaptation the information in these models can be used by services that monitor, manage, or adapt the SOA at runtime. If a service for monitoring, management, or adaptation in an SOA is dependent on models, and the metamodel changes, usually the service needs to be manually adapted to work with the new version, recompiled, and redeployed. This manual effort impedes the use of models at runtime. To address this problem, this paper introduces model-aware services that work with models at runtime. These services are supported using a service environment, called Morse. Hiding the complexity of implicit versioning of models from users while respecting the principle of Universally Unique Identifiers (UUIDs), it realizes a novel transparent UUID-based\u00a0\u2026", "num_citations": "14\n", "authors": ["647"]}
{"title": "Comparing complexity of API designs: an exploratory experiment on DSL-based framework integration\n", "abstract": " Embedded, textual DSLs are often provided as an API wrapped around object-oriented application frameworks to ease framework integration. While literature presents claims that DSL-based application development is beneficial, empirical evidence for this is rare. We present the results of an experiment comparing the complexity of three different object-oriented framework APIs and an embedded, textual DSL. For this comparative experiment, we implemented the same, non-trivial application scenario using these four different APIs. Then, we performed an Object-Points (OP) analysis, yielding indicators for the API complexity specific to each API variant. The main observation for our experiment is that the embedded, textual DSL incurs the smallest API complexity. Although the results are exploratory, as well as limited to the given application scenario and a single embedded DSL, our findings can direct future\u00a0\u2026", "num_citations": "14\n", "authors": ["647"]}
{"title": "Monitoring performance-related QoS properties in service-oriented systems: A pattern-based architectural decision model\n", "abstract": " In service-oriented systems, service-level agreements (SLA) are specified as contracts between service providers and service consumers. SLAs stipulate---among other things---the provided services' performance. A service provider must fulfill the agreements stated in SLAs, eg, to avoid paying penalties. Service consumers must verify whether the service quality as purchased is delivered. We present an architectural design decision model (ADDM) covering the design of a QoS monitoring infrastructure. The ADDM collects design decisions about measuring, storing, and evaluating performance-related quality-of-service (QoS) agreements. The model includes various requirements and puts forth design solutions by referring to established architectural, remoting, and design patterns. We evaluate the ADDM to build the architecture of a QoS monitoring infrastructure in a case study. The model guides through the\u00a0\u2026", "num_citations": "14\n", "authors": ["647"]}
{"title": "Inversion-of-control layer\n", "abstract": " Inversion of control is a common design practise that has been used in various application areas. It gained popularity in the context of object-oriented application frameworks and designs based on abstract classes and interfaces. Recently, dependency injection techniques, especially in the context of lightweight containers such as Spring, have raised the attention for inversion of control again. However, inversion of control has not yet been described in its architectural dimension with a focus on layering architectures, and the pros and cons of the design decision for control inversion. In this paper, we present the inversion-of-control layer pattern which describes the design practise from an architectural point of view, rather than focusing on particular implementation techniques.", "num_citations": "14\n", "authors": ["647"]}
{"title": "Self-Adaptation techniques for complex service-oriented systems\n", "abstract": " Complex service-oriented systems comprise humans and software services spanning multiple organizations. These systems are highly dynamic, because services, processes, and teams are not only diverse but they also constantly evolve. Therefore, these systems introduce a variety of challenges on how to adapt services, processes, and teams to changing situations. We contribute with our approach to address these challenges, comprising model-driven compliance support, run-time interaction mining, run-time management of requirements, and an explicit control-loop architecture. We conclude with remaining issues the software and service engineering research community should address.", "num_citations": "14\n", "authors": ["647"]}
{"title": "Scenario-based component testing using embedded metadata\n", "abstract": " We present an approach for the use case and scenario-based testing of software components. Use cases and scenarios are applied to describe the functional requirements of a software system. In our approach, a test is defined as a formalized and executable description of a scenario. Tests are derived from use case scenarios via continuous refinement. The use case and test information can be associated with a software component as embedded component metadata. In particular, our approach provides a model-based mapping of use cases and scenarios to test cases, as well as (runtime) traceability of these links. Moreover, we describe an implementation-level test framework that can be integrated with many different programming languages.", "num_citations": "14\n", "authors": ["647"]}
{"title": "Pattern-based design and implementation of an XML and RDF parser and interpreter: A case study\n", "abstract": " Software patterns have been widely promoted as a means of conveying practical design knowledge in a reusable fashion. Several approaches for providing better implementation variants of certain patterns have been presented. These approaches promise great advantages for flexibility, traceability, and reusability of pattern implementations. However, there are only a few larger practical case studies of these concepts available. In this paper we will present a case study of a component framework for flexible processing of markup languages in the object-oriented scripting language XOTcl. The language offers high-level means and architectural support for component integration (\u201ccomponent glueing\u201d), introspection, language dynamics, and message interception techniques. These language constructs enable developers to extend the language with pattern implementations, and so to provide language\u00a0\u2026", "num_citations": "14\n", "authors": ["647"]}
{"title": "Domain specific language for smart contract development\n", "abstract": " The notion to digitally articulate, execute, and enforce agreements with smart contracts has become a feasible reality today. Smart contracts have the potential to vastly improve the efficiency and security of traditional contracts through their self-executing autonomy. To realize smart contracts several blockchain-based ecosystems exist. Today a prominent representative is Ethereum. Its programming language Solidity is used to capture and express contractual clauses in the form of code. However, due to the conceptual discrepancy between contractual clauses and corresponding code, it is hard for domain stakeholders to easily understand contracts, and for developers to write code efficiently without errors. Our research addresses these issues by the design and study of a domain-specific smart contract language based on higher level of abstraction that can be automatically transformed to an implementation. In\u00a0\u2026", "num_citations": "13\n", "authors": ["647"]}
{"title": "Capability-based service identification in service-oriented legacy modernization\n", "abstract": " Moving from a heterogeneous IT landscape with a set of legacy applications to a more flexible SOA-based architecture is a major strategic concern for many large organizations. Key drivers are to build a robust, easy-to-maintain and cost-efficient architecture. Service identification is a key task in this context, and it must cope with the inherent complexity of existing IT systems and their constant evolution. In this paper we describe the CAPABILITY-BASED SERVICE pattern that identifies services and defines the service model based on a model of business capabilities. Business capabilities describe what an enterprise does, not how something is done in the enterprise. Service identification based on business capabilities is an alternative to process-based service identification, especially useful in cases where process modeling is not feasible, for instance, because of budget or time limitations or where processes are\u00a0\u2026", "num_citations": "13\n", "authors": ["647"]}
{"title": "Enabling flexibility of business processes by compliance rules: A case study from the insurance industry\n", "abstract": " The Swiss insurance company Die Mobiliar creates insurance documents with a wizard application utilizing the Papyrus Communication and Process Platform. Based on predefined processes, wizards guide business users through document generation processes. Although wizards can be amended by business administrators to respond to changing requirements, a high degree of process automation restricts adaption to the rapidly changing insurance market due to rigidness and bureaucratic efforts. In our approach, the concept of compliance rules in combination with process redesign has been applied to enable flexibility for insurance processes. The original processes are split into predefined reusable sub-processes and a set of individual ad hoc tasks which can be added by the business users at runtime as they assess the current insurance client situation. Compliance rules guarantee overall process execution compliance whilst enabling the needed flexibility. The number of process templates can be reduced considerably to a few predefined core processes in combination with a set of ad hoc tasks. The flexibility achieved by this compliance-rule approach enables the adaptability of insurance processes by business users, from which the whole insurance industry can benefit.", "num_citations": "13\n", "authors": ["647"]}
{"title": "Controlled experiment on the supportive effect of architectural component diagrams for design understanding of novice architects\n", "abstract": " Today, architectural component models are often used as a central view of architecture descriptions. So far, however, only a very few rigorous empirical studies relating to the use of component models in architectural descriptions of software systems have been conducted. In this paper, we present the results of a controlled experiment regarding the supportive effect of architectural component diagrams for design understandability. In particular, the goal of the experiment was to determine whether architectural component diagrams, provided in addition to a non-trivial software system\u2019s source code, have a supportive effect on the ability of novice architects to answer design and architecture related questions about that system. Our study provides initial evidence that architectural component diagrams have a supportive effect for understanding the software design and architecture, if a direct link from the\u00a0\u2026", "num_citations": "13\n", "authors": ["647"]}
{"title": "On the understandability of temporal properties formalized in linear temporal logic, property specification patterns and event processing language\n", "abstract": " Temporal properties are important in a wide variety of domains for different purposes. For example, they can be used to avoid architectural drift in software engineering orto support the regulatory compliance of business processes. In this work, we study the understandability of three majortemporal property representations: (1) LinearTemporal Logic (LTL) is a formal and well-established logic that offers temporal operators to describe temporal properties; (2) Property Specification Patterns (PSP) are a collection of recurring temporal properties that abstract underlying formal and technical representations; (3) Event Processing Language (EPL) can be used for runtime monitoring of event streams using Complex Event Processing. We conducted two controlled experiments with 216 participants in total to study the understandability of those approaches using a completely randomized design with one alternative per\u00a0\u2026", "num_citations": "12\n", "authors": ["647"]}
{"title": "Reconciling software architecture and source code in support of software evolution\n", "abstract": " Even in the eighties, the need of managing software evolution has been detected as one of the most complex aspects of the software lifecycle. In this context, software architecture has been highlighted as an integral element of the software evolution process. However, no matter how much effort is put into the architecture, it must eventually be translated into source code. The potential misalignment between architecture and code can lead to failures in the evolution process in terms of economic impacts, failed expectations, and so on. In this article we report on a design science research study that we pursued to answer three research questions. First, we have studied whether and in how far it is possible to design an approach that both enforces the integration between software architecture and source code to avoid architectural erosion and architectural drift and, at the same time, provides automatic guidance to\u00a0\u2026", "num_citations": "12\n", "authors": ["647"]}
{"title": "Two controlled experiments on model-based architectural decision making\n", "abstract": " ContextIn recent years, architectural design decisions are becoming more and more common for documenting software architectures. Rather than describing the structure of software systems, architectural decisions capture the design rationale and \u2013 often reusable \u2013 architectural knowledge. Many approaches and tools have been proposed in the literature to support architectural decision making and documentation (for instance, based on models, ontologies, or templates). In this context, the capturing, organization, and effective reuse of architectural knowledge has gained a lot of attention.ObjectiveHowever, there is little empirical evidence about the supportive effect of reusable architectural knowledge on the effectiveness and efficiency of architectural decision making.MethodTo investigate these aspects, we conducted two separate controlled experiments with software architecture students in which we tested the\u00a0\u2026", "num_citations": "12\n", "authors": ["647"]}
{"title": "Name-based view integration for enhancing the reusability in process-driven SOAs\n", "abstract": " Many companies opt for reusing existing software development artefacts due to the benefits of the reuse such as increasing productivity, shortening time-to-market, and spending less time for testing, debugging, to name but a few. Unfortunately, reusing artefacts in existing process-driven SOA technologies is cumbersome and hard to achieve due to several inhibitors. First, the languages used for business process development are not intentionally designed for reuse. Second, numerous tangled process concerns embraced in a process description significantly hinder the understanding and reusing of its concepts and elements. Third, there is a lack of appropriate methods and techniques for integrating reusable artefacts. In our previous work, we proposed a view-based, model-driven approach for addressing the two former challenges. We present in this paper a named-based view integration approach aiming at\u00a0\u2026", "num_citations": "12\n", "authors": ["647"]}
{"title": "Patterns for measuring performance-related QoS properties in service-oriented systems\n", "abstract": " In service-oriented systems, clients can access services via a network. Service level agreements (SLA) can exist, which specify---among other things---performance-related Quality of Service (QoS) properties between the client and the server, such as round-trip time, processing time, or availability. For a service provider serious financial consequences or other penalties can follow in case of not fulfilling the SLAs. The service consumer wants to evaluate that the provider complies with the guaranteed SLAs. Designing and developing a QoS-aware service-oriented system means facing many design challenges, such as where and how to measure the performance-related QoS properties. This paper presents design practices and patterns for measuring such QoS properties by extending and utilizing existing patterns. The focus of the patterns lies on the QoS measuring impact on the client's or service's performance\u00a0\u2026", "num_citations": "12\n", "authors": ["647"]}
{"title": "Modeling process-driven SOAs: A view-based approach\n", "abstract": " This chapter introduces a view-based, model-driven approach for process-driven, service-oriented architectures. A typical business process consists of numerous tangled concerns, such as the process control flow, service invocations, fault handling, transactions, and so on. Our view-based approach separates these concerns into a number of tailored perspectives at different abstraction levels. On the one hand, the separation of process concerns helps reducing the complexity of process development by breaking a business process into appropriate architectural views. On the other hand, the separation of levels of abstraction offers appropriately adapted views to stakeholders, and therefore, helps quickly re-act to changes at the business level and at the technical level as well. Our approach is realized as a model-driven tool-chain for business process development.", "num_citations": "12\n", "authors": ["647"]}
{"title": "Guiding architectural decision making on service mesh based microservice architectures\n", "abstract": " Microservices are becoming the de-facto standard way for software development in the cloud and in service-oriented computing. Service meshes have been introduced as a dedicated infrastructure for managing a network of containerized microservices, in order to cope with the complexity, manageability, and interoperability challenges in especially large-scale microservice architectures. Unfortunately so far no dedicated architecture guidance for designing microservices and choosing among technology options in a service mesh exist. As a result, there is a substantial uncertainty in designing and using microservices in a service mesh environment today. To alleviate this problem, we have performed a model-based qualitative in-depth study of existing practices in this field in which we have systematically and in-depth studied 40 reports of established practices from practitioners. In our study we modeled\u00a0\u2026", "num_citations": "11\n", "authors": ["647"]}
{"title": "Software specification and documentation in continuous software development: a focus group report\n", "abstract": " We have been observing an ongoing trend in the software engineering domain towards development practices that rely heavily on verbal communication and small, closely-interacting teams. Among others, approaches like Scrum, Lean Software Development, and DevOps fall under this category. We refer to such development practices as Continuous Software Development (ConSD). Some core principles of ConSD are working in short iterations with frequent delivery, striving for an optimal balance between effectiveness and efficiency, and amplify learning in the development team. In such a context, many traditional patterns of software specification, documentation and knowledge preservation are not applicable anymore.", "num_citations": "11\n", "authors": ["647"]}
{"title": "Automatic enforcement of constraints in real-time collaborative architectural decision making\n", "abstract": " Making and documenting architectural design decisions becomes increasingly important in the process of software architecting. However, the remoteness of different decision stakeholders, ranging from local distribution in an office environment to globally distributed teams, as well as the different domain knowledge, expertise and responsibilities of the stakeholders hinder effective and efficient collaboration. Existing tools and methods for collaborative architectural decision making focus mainly on sharing and reusing of knowledge, making trade-offs, and achieving consensus, but do not consider the various stakeholders\u2019 decision making constraints due to their roles in the development process. To address this problem, we propose a meta-model for a set of decision making constraints, with precisely defined semantics, as well as a collaborative architectural decision making approach based on this meta-model. We\u00a0\u2026", "num_citations": "11\n", "authors": ["647"]}
{"title": "Supporting architectural decision making for systems-of-systems design under uncertainty\n", "abstract": " For the design and integration of complex systems-of-systems, various architectural decisions for recurring design problems need to be made. This requires that the software architects consider various design issues and alternatives, make trade-offs for competing requirements, and adapt the decisions to specific technologies and systems. Documentations of reusable architectural design decisions (ADDs), eg, pattern-based decisions, provide rather informal guidelines for making recurring ADDs. These and other factors introduce many sources of uncertainty in the architectural decision making process. Existing approaches do not consider this inherent uncertainty of architectural decision making, which has been until now largely ad hoc and informal, without explicit, automated support. Apart from that, the design rationale for repeated ADDs often remains undocumented, leading to loss of architectural knowledge\u00a0\u2026", "num_citations": "11\n", "authors": ["647"]}
{"title": "Experiences in enhancing existing BPM Tools with BPEL Import and Export\n", "abstract": " The Business Process Execution Language for Web Services (BPEL) has become a de-facto standard for executable process specifications. The broad industry acceptance of BPEL forces workflow and BPM system vendors to consider respective import and export interfaces. Yet, several existing systems utilize graph-based BPM languages such as EPCs, Workflow Nets, UML Activity Diagrams, and BPMN in their modeling component while BPEL is rather a block-oriented language inspired by process calculi. In this paper we identify transformation strategies as reusable solutions for mapping control flow between graph-based BPM tools and BPEL. Furthermore, we present a case study in which we have applied these strategies in an industry project. This case study shows that transformation strategies are helpful for implementing import and export interfaces in a systematic way, and that they can easily be\u00a0\u2026", "num_citations": "11\n", "authors": ["647"]}
{"title": "Piecemeal migration of a document archive system with an architectural pattern language\n", "abstract": " Large applications that have evolved over the years, are often well-functioning and reliable, but have severe problems regarding flexibility and reuse. Most often it is a considerable effort to migrate such systems to a more flexible architecture or to new technologies. We present a reengineering case study of a document archive/retrieval system based on an architectural pattern language. The patterns aim at the introduction of flexibility into black-box component architectures in a piecemeal way.", "num_citations": "11\n", "authors": ["647"]}
{"title": "Systematic review of software behavioral model consistency checking\n", "abstract": " In software development, models are often used to represent multiple views of the same system. Such models need to be properly related to each other in order to provide a consistent description of the developed system. Models may contain contradictory system specifications, for instance, when they evolve independently. Therefore, it is very crucial to ensure that models conform to each other. In this context, we focus on consistency checking of behavior models. Several techniques and approaches have been proposed in the existing literature to support behavioral model consistency checking. This article presents a Systematic Literature Review (SLR) that was carried out to obtain an overview of the various consistency concepts, problems, and solutions proposed regarding behavior models. In our study, the identification and selection of the primary studies was based on a well-planned search strategy. The\u00a0\u2026", "num_citations": "10\n", "authors": ["647"]}
{"title": "An approach for pattern mining through grounded theory techniques and its applications to process-driven soa patterns\n", "abstract": " Pattern mining is a term used in the pattern community to describe the process of identifying or discovering patterns. To identify new patterns, usually an informal or ad hoc process of finding patterns (eg, in existing software systems) is used. This paper reflects on lessons learned and methods used regarding the integration of software pattern mining with qualitative research methods during our work on a pattern language for process-driven and service-oriented architectures (SOAs). This pattern language aims at closing the conceptual gap between business architecture and software architecture with a focus on process-driven solutions. In this paper we emphasize the notion of understanding patterns as sociological phenomena of problem solving behavior. We further introduce a systematic approach for pattern mining based Glaserian Grounded Theory techniques. This approach has been applied for mining the\u00a0\u2026", "num_citations": "10\n", "authors": ["647"]}
{"title": "Semi-automatic architectural pattern identification and documentation using architectural primitives\n", "abstract": " In this article, we propose an interactive approach for the semi-automatic identification and documentation of architectural patterns based on a domain-specific language. To address the rich concepts and variations of patterns, we firstly propose to support pattern description through architectural primitives. These are primitive abstractions at the architectural level that can be found in realizations of multiple patterns, and they can be leveraged by software architects for pattern annotation during software architecture documentation or reconstruction. Secondly, using these annotations, our approach automatically suggests possible pattern instances based on a reusable catalog of patterns and their variants. Once a pattern instance has been documented, the annotated component models and the source code get automatically checked for consistency and traceability links are automatically generated. To study the\u00a0\u2026", "num_citations": "10\n", "authors": ["647"]}
{"title": "Empirical evaluation of the understandability of architectural component diagrams\n", "abstract": " The architecture of a software system plays a crucial role during evolution and maintenance, as it provides the means to cope with the inherent system complexity by abstracting from implementation and design details. Architectural component models represent high level designs and are frequently used as a central view of architectural descriptions of software systems. Hence, understandability of those models is crucial as they play a key role in supporting the architectural understanding of a software system. In this paper we present the results from a study we carried out to examine to which extent the software architecture could be conveyed through architectural component diagrams. The statistical evaluation of the results shows that metrics such as the number of components, number of connectors, number of elements, and number of symbols used in the diagrams can significantly decrease architectural\u00a0\u2026", "num_citations": "10\n", "authors": ["647"]}
{"title": "Modeling interdependent concern behavior using extended activity models\n", "abstract": " Software engineering considers many assets relevant for developing a software system, ranging from requirements to source code. In this context, a concern is a particular goal, concept, or area of interest that needs to be considered throughout a number of these assets. Even though the concerns in a software system usually have many interdependencies among each other, specifying the interdependent behavior of concerns is not a focus of today\u2019s (concern) modeling approaches. In this paper, we present an approach to model interdependent concern behavior using extended UML2 activity models. Within these concern activity models, we directly support the separation of interdependent concerns. In addition, we provide bindings of the concern activity models to UML class and interaction models to enable a detailed specification of concern behavior.", "num_citations": "10\n", "authors": ["647"]}
{"title": "Service integration patterns for invoking services from business processes\n", "abstract": " In a process-driven and service-oriented architecture, services and business processes are typically integrated by invoking services from the activities of the business processes. The software architect and developer must decide how a service is invoked from a business process. In this decision the requirements that result from the business processdriven service orchestration concept must be considered, as well as the functional architecture requirements of the business processes. We present a pattern language that addresses these design issues and represents proven design knowledge for invoking services from business processes.", "num_citations": "10\n", "authors": ["647"]}
{"title": "Patterns of component and language integration\n", "abstract": " Integration is an important concern in many software systems. In this chapter, we present a number of patterns that are used to improve the integration of a system with components or code that is written in different languages than the system itself. Component integration is necessary when (foreign) components should be used within a system. The challenge of integrating components into a system is that heterogeneous kinds of components exist, perhaps without distinct interfaces or other component boundaries. The task of the component integration code is to provide suitable, stable invocation interfaces and to compose the components with the system. Sometimes, however, invocation and composition of components is not enough, but deeper language integration is required. Examples of what might be need are automatic type conversions between languages, preserving the destruction order of the other language, automatic forwarding of invocations into the other language, and runtime integration of foreign language components. The patterns, presented in this chapter, are successful solutions in these areas. Each of these patterns plays an important role in different integration architectures. We will give examples from the areas of distributed systems, reengineering projects, scripting languages, and aspect-oriented programming systems. There are many others fields where the patterns are used as well.", "num_citations": "10\n", "authors": ["647"]}
{"title": "Patterns of argument passing\n", "abstract": " Argument passing means passing values along with an invocation. Most programming languages provide positional arguments as their ordinary argument passing mechanism. Sometimes ordinary argument passing is not enough, for instance, because the number of arguments or their types differ from invocation to invocation, or optional arguments are needed, or the same arguments are passed through a chain of multiple receivers and must vary flexibly. These issues can be resolved using ordinary argument passing mechanisms, but the solutions are usually cumbersome. In many systems, such as programming languages, programming environments, frameworks, and middleware systems, advanced argument passing solutions are provided to better address these issues. In this paper we present four patterns applied in these advanced argument passing solutions:\uf776\uf761\uf772\uf769\uf761\uf762\uf76c\uf765\uf761\uf772\uf767\uf775\uf76d\uf765\uf76e\uf774\uf76c\uf769\uf773\uf774\uf773 allow an operation to receive arbitrary numbers of arguments,\uf76f\uf770\uf774\uf769\uf76f\uf76e\uf761\uf76c\uf761\uf772\uf767\uf775\uf76d\uf765\uf76e\uf774\uf773 let operations have arguments which can either be provided in an invocation or not,\uf76e\uf76f\uf76e-\uf770\uf76f\uf773\uf769\uf774\uf769\uf76f\uf76e\uf761\uf76c\uf761\uf772\uf767\uf775\uf76d\uf765\uf76e\uf774\uf773 allow arguments to be passed in any order as name/value pairs, and\uf763\uf76f\uf76e\uf774\uf765\uf778\uf774\uf76f\uf762\uf76a\uf765\uf763\uf774\uf773 are special types used for the purpose of argument passing.", "num_citations": "10\n", "authors": ["647"]}
{"title": "Loosely coupled web services in remote object federations\n", "abstract": " Loosely coupled services are gaining importance in many business domains. However, compared to OO-RPC middleware approaches, emerging technologies proposed to implement loosely coupled services, such as Web services or P2P frameworks, still have some practical problems. These arise in many typical business domains, for instance, because of missing central control, high network traffics, scalability problems, performance overheads, or security issues. We propose to use ideas from these emerging technologies in a controlled environment, called a federation. Each remote object (a peer) is controlled in one or more federations, but within this environment peers can collaborate in a simple-to-use, loosely coupled, and ad hoc style of communication. Our design and implementation relies on popular remoting patterns. We present a generic framework architecture based on these patterns\u00a0\u2026", "num_citations": "10\n", "authors": ["647"]}
{"title": "Counterexample analysis for supporting containment checking of business process models\n", "abstract": " During the development of a process-aware information system, there might exist multiple process models that describe the system\u2019s behavior at different levels of abstraction. Thus, containment checking is important for detecting unwanted deviations of process models to ensure a refined low-level model still conforms to its high-level counterpart. In our earlier work, we have interpreted the containment checking problem as a model checking problem and leveraged existing powerful model checkers for this purpose. The model checker will detect any discordance of the input models and yield corresponding counterexamples. The counterexamples, however, are often difficult for developers with limited knowledge of the underlying formal methods to understand. In this paper, we present an approach for interpreting the outcomes of containment checking of process models. Our approach aims to analyze the\u00a0\u2026", "num_citations": "9\n", "authors": ["647"]}
{"title": "Ontology-based behavioral constraint authoring\n", "abstract": " A major approach for formalizing business policies or compliance rules (e.g., stemming from regulatory laws or standards) are behavioral constraints. Flexible business process management approaches such as Adaptive Case Management provide business users the necessary freedom to react to unforeseeable circumstances by ad-hoc changes, but behavioral constraints are often defined and maintained on a technical level which is inaccessible for business users. Consequently, long update cycles of these constraints might result in the enactment of obsolete, incomplete or faulty constraints which hinder the work of the business user instead of supporting it. In this paper, an ontology-based approach for defining and maintaining behavioral constraints in the context of flexible business processes is proposed. The approach aims at enabling business users to take active part in the creation and maintenance of\u00a0\u2026", "num_citations": "9\n", "authors": ["647"]}
{"title": "Change patterns for supporting the evolution of event-based systems\n", "abstract": " As event-driven architectures consist of highly decoupled components, they are a promising solution for facilitating high flexibility, scalability, and concurrency of distributed systems. However, the evolution of an event-based system is often challenging due to the intrinsic loose coupling of its components. This problem occurs, on the one hand, because of the absence of explicit information on the dependencies among the constituting components. On the other hand, assisting techniques for investigating and understanding the implications of changes are missing, hindering the implementation and maintenance of the changes in event-based architectures. Our approach presented in this paper aims at overcoming these challenges by introducing primitive change actions and higher-level change patterns, formalized using trace semantics, for representing the modification actions performed when evolving an\u00a0\u2026", "num_citations": "9\n", "authors": ["647"]}
{"title": "Event-driven actors for supporting flexibility and scalability in service-based integration architecture\n", "abstract": " Service-based software systems are often built by incorporating functionalities from other software systems or platforms. A widely used approach in practice is to introduce an intermediate integration layer for hiding the complexity and heterogeneity of the integrated systems or platforms. However, existing approaches introduce limited support for the flexibility of the integration architecture. It is challenging to alter the integration architecture, e.g., due to some exceptions or unanticipated situations such as peak loads or emergencies, because of rigid dependency structures in the integration architecture defined at design or deployment time. In this paper, we propose DERA as a novel approach that exploits event-driven architecture concepts for enhancing the flexibility and scalability of service-based integration architectures. Our approach provides primitive concepts that can easily be analyzed with tools or be\u00a0\u2026", "num_citations": "9\n", "authors": ["647"]}
{"title": "Runtime process adaptation for bpel process execution engines\n", "abstract": " Requirements for business processes can change over time. Adapting a process to meet the changed requirements is not always possible, especially for long running processes, where stopping the execution of process instances might be necessary and/or instance migration or compensation scenarios must be implemented. Adaptations for processes can be described in a generic way using adaptation patterns. Interpreting these adaptation patterns will enable adaptation support at runtime, independently from a specific process execution engine. This paper presents a framework which enables adaptation support for process execution engines. It explains how runtime information of process instances can be monitored by using aspect-oriented programming. A model for adaptation patterns is presented as well as an adaptation engine which interprets instances of the adaptation pattern model and applies the\u00a0\u2026", "num_citations": "9\n", "authors": ["647"]}
{"title": "Supporting incremental and experimental software evolution by runtime method transformations\n", "abstract": " Transformations of object-oriented methods are a prevalent object-oriented programming technique, but in many languages they are not supported at runtime. Therefore it can be hard to apply method transformations for incremental or experimental software evolution, or other problems that require runtime software behavior adaptation. The goal of the work presented in this paper is to provide a better conceptual and technical support for runtime method transformations. A non-intrusive model for method transformations and a set of runtime method transformation primitives are presented. We also present a pattern language for implementing dynamic method abstractions and combining them with languages that do not support dynamic methods natively. As a case study we introduce a runtime transformation framework for the dynamic configuration and composition language Frag, its connection to Java, and an end\u00a0\u2026", "num_citations": "9\n", "authors": ["647"]}
{"title": "Supporting the evolution of event-driven service-oriented architectures using change patterns\n", "abstract": " ContextThe components of an event-driven service-oriented architecture (EDSOA) are composed in a highly decoupled way, facilitating high flexibility, scalability and concurrency in SOA systems. Evolving an EDSOA is challenging because the absence of explicit dependencies among constituent components makes understanding and analysing the overall system composition difficult. The evolution of EDSOAs typically happens by performing a series of primitive changes\u2014which can be described formally as change primitives.ObjectiveIn this article, we present our change pattern based approach for managing the EDSOA evolution as a novel design method supporting EDSOA evolution. The change patterns operate on a higher abstraction level than change primitives.MethodTo evaluate our approach, we have compared both time and correctness of changes in a controlled experiment comparing the\u00a0\u2026", "num_citations": "8\n", "authors": ["647"]}
{"title": "Supporting structural consistency checking in adaptive case management\n", "abstract": " Adaptive Case Management (ACM) enables knowledge workers to collaboratively handle unforeseen circumstances by making ad hoc changes of case instances at runtime. Therefore, it is crucial to ensure that various structural elements of an ACM case, such as goals, subprocesses and so on, remain consistent over time. To the best of our knowledge, no studies in the literature provide adequate support for structural consistency checking of ACM. In this paper, we introduce a formal categorization of ACM\u2019s structural features and potential inconsistencies. Based on this categorization, we develop a novel approach for structural consistency checking of ACM cases. Our approach, based on model checking and graph algorithms, can detect a wide range of inconsistencies of ACM\u2019s structural elements. The evaluation of our approach shows reasonable performance and scalability.", "num_citations": "8\n", "authors": ["647"]}
{"title": "A graph-based approach for containment checking of behavior models of software systems\n", "abstract": " In the development of complex and large scale software systems, it is important to detect and fix the deviations of systems' behaviors at different abstraction levels in early phases. Our main focus here is the containment checking-a special type of consistency checking-that verifies whether the behavior (or functions) described by a low-level behavior model encompasses those specified in the high-level counterpart. As shown in our previous work, containment checking can be realized based on model checking, but not always the costly exhaustive searches employed by model checking are necessary for addressing the containment checking problem, leading to potentials for optimization. In addition, model checking and similar techniques often yield the checking results as true (satisfied) or false (unsatisfied) with error traces (e.g., Counter-examples). Unfortunately, such feedback is rather not helpful for users with\u00a0\u2026", "num_citations": "8\n", "authors": ["647"]}
{"title": "Harmonizing architectural decisions with component view models using reusable architectural knowledge transformations and constraints\n", "abstract": " Architectural design decisions (ADDs) have been used in recent years for capturing design rationale and documenting architectural knowledge (AK). However, various architectural design views still provide the most common means for describing and communicating architectural design. The evolution of software systems requires that both ADDs and architectural design views are documented and maintained, which is a tedious and time-consuming task in the long run. Also, in lack of a systematic and automated support for bridging between ADDs and architectural design views, decisions and designs tend to become inconsistent over time. In our proposal, we introduce a reusable AK transformation language for supporting the automated transformation of reusable AK knowledge to component-and-connector models, the architectural design view used most commonly today. In addition, reusable consistency\u00a0\u2026", "num_citations": "8\n", "authors": ["647"]}
{"title": "Towards the usage of dynamic object aggregations as a foundation for composition\n", "abstract": " Many current programming languages offer insufficient support for the aggregation relationship. They do not offer a language support for composite structures (object hierarchies, whole/part hierarchies) on the object-level. Instead they rely on techniques, like embedding or referencing through pointers, which do not fully incorporate the semantics of aggregation. As a superior technique we present the language construct dynamic object aggregations.", "num_citations": "8\n", "authors": ["647"]}
{"title": "CASM-IR: uniform ASM-based intermediate representation for model specification, execution, and transformation\n", "abstract": " The Abstract State Machine (ASM) theory is a well-known formal method, which can be used to specify arbitrary algorithms, applications or even whole systems. Over the past years, there have been many approaches to implement concrete ASM-based modeling and specification languages. All of those approaches define their type systems and operator semantics differently in their internal representation, which leads to undesired or unexpected behavior during the modeling, the execution, and code generation of such ASM specifications. In this paper, we present CASM-IR, an Intermediate Representation (IR), designed to aid ASM-based language engineering which is based on a well-formed ASM-based specification format. Moreover, CASM-IR is conceptualized from the ground up\u00a0to ease the formalization of ASM-based analysis and transformation passes. The feasibility of CASM-IR solving the\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "Towards structural consistency checking in adaptive case management\n", "abstract": " This paper proposes structural consistency checking for Adaptive Case Management (ACM). Structures such as a hierarchical organization of business goals and dependencies among tasks are either created at design time or evolve over time while working on cases. In this paper, we identify structures specific to current ACM systems (as opposed to other BPM systems), discuss which inconsistencies can occur, and outline how to discover these issues through model checking and graph algorithms.", "num_citations": "7\n", "authors": ["647"]}
{"title": "Towards a compliance support framework for adaptive case management\n", "abstract": " Current Adaptive Case Management (ACM) solutions are strong in flexibility, but business users must still meet compliance rules stemming from sources such as laws (e.g., Sarbanes-Oxley Act), standards (e.g., ISO 45001) and best practices (e.g., ITIL). This paper presents a framework on how to enable support for compliance in the context of ACM by constraints. Since ACM applications undergo constant change, there must be ways to introduce compliance rules on the fly. Currently, constraints (and similar alternative solutions) are predominately maintained by technical users, which results in long maintenance cycles. Our framework aims at enabling faster adoption of changing compliance requirements, both explicitly by enabling non-technical users (knowledge workers) to define and adapt constraints, and implicitly by learning from the decisions taken by other knowledge workers during case enactments. The\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "An ontology-based approach for defining compliance rules by knowledge workers in adaptive case management\n", "abstract": " Empowering knowledge workers (KWs) to act more efficiently and flexibly in unpredictable situations is the main focus of Adaptive Case Management (ACM), although ad hoc actions at runtime shall not violate the consistency and compliance of an on-going case. In this paper we discuss how business constraints stemming from regulatory laws or standards are transferred from textual sources to formal specifications in the form of compliance rule objects relating to ACM objects. In order to mitigate the knowledge barriers between business and IT, we apply an ontology-based solution allowing KWs to define compliance rules from a pure business perspective using domain-specific terms. We demonstrate the implementation using a repair service case and discuss the benefit of our approach for the sake of administration of business aspects by KWs without IT involvement.", "num_citations": "7\n", "authors": ["647"]}
{"title": "Plausibility checking of formal business process specifications in linear temporal logic\n", "abstract": " Many approaches for keeping business processes in line with constraints stemming from various sources (such as laws and regulations) are based on Linear Temporal Logic (LTL). Creating LTL specifications is an error-prone task which entails the risk that the formula does not match the intention of its creator. This paper proposes a plausibility checking approach for LTL-based specifications. The proposed approach can provide confidence in an LTL formula if plausibility checking is passed. If the formula does not pass the plausibility checks, a counterexample trace and the truth values of both the LTL formula and the plausibility specification are generated and can be used as a starting point for correction.", "num_citations": "7\n", "authors": ["647"]}
{"title": "Reusable event types for models at runtime to support the examination of runtime phenomena\n", "abstract": " Today's software is getting more and more complex and harder to understand. Models help to organize knowledge and emphasize the structure of a software at a higher abstraction level. While the usage of model-driven techniques is widely adopted during software construction, it is still an open research topic if models can also be used to make runtime phenomena more comprehensible as well. It is not obvious which models are suitable for manual analysis and which model elements can be related to what type of runtime events. This paper proposes a collection of runtime event types that can be reused for various systems and meta-models. Based on these event types, information can be derived which help human observers to assess the current system state. Our approach is applied in a case study and evaluated regarding generalisability and completeness by relating it to two different meta-models.", "num_citations": "7\n", "authors": ["647"]}
{"title": "Modeling change patterns for impact and conflict analysis in event-driven architectures\n", "abstract": " In distributed event-driven architectures, components are composed in a highly decoupled way, facilitating high flexibility, scalability and concurrency of distributed systems. However, the intrinsic loose coupling of its components make relations hard to identify making it challenging to analyze, maintain, and evolve an event-based architecture. For understanding the evolution of an event-based architecture, we require knowledge about its components' dependencies, which is often hard to gain due to the absence of explicit information about these dependencies. Furthermore, assisting techniques for analyzing the impacts of certain changes are missing, hindering the implementation of changes in event-driven architectures. We present in this paper a novel approach providing models to describe changes in event-based architectures on different levels of abstraction. The explicit definition of a change enables various\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "The supportive effect of traceability links in change impact analysis for evolving architectures\u2013two controlled experiments\n", "abstract": " The documentation of software architecture relations as a kind of traceability information is considered important to help people understand the consequences or ripple-effects of architecture evolution. Traceability information provides a basis for analysing and evaluating software evolution, and consequently, it can be used for tasks like reuse evaluation and improvement throughout the evolution of software. To date, however, none of the published empirical studies on software architecture traceability have examined the validity of these propositions. In this paper, we hypothesize that impact analysis of changes in software architecture can be more efficient when supported by traceability links. To test this hypothesis, we designed two controlled experiments that were conducted to investigate the influence of traceability links on the quantity and quality of retrieved assets during architecture evolution analysis\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "Exploring the relationships between the understandability of architectural components and graph-based component level metrics\n", "abstract": " Architectural component models are frequently used as a central view of architectural descriptions of software systems and therefore play a crucial role in the whole development process and in achieving the desired software qualities. The components in those models represent important high level structural units that are often used to group either lower-level sub-components or classes in object-oriented design views. In this paper we present a study that examines the relationships between the effort required to understand a component, measured through the time that participants spent on studying a component, and a number of information theory based and the corresponding counting based metrics on graphs at the component level. The results show a statistically significant correlation between all of the metrics and the effort required to understand a component. In a multivariate regression analysis we obtained\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "Taking the pick out of the bunch-type-safe shrinking of metamodels\n", "abstract": " To focus only on those parts of a metamodel that are of interest for a specific task requires techniques to generate metamodel snippets. Current techniques generate strictly structure-preserving snippets, only, although restructuring would facilitate to generate less complex snippets. Therefore, we propose metamodel shrinking to enable type-safe restructuring of snippets that are generated from base metamodels. Our approach allows to shrink a selected set of metamodel elements by automatic reductions that guarantee type-safe results by design. Based on experiments with 12 different metamodels from various application domains, we demonstrate the benefits of metamodel shrinking supported by our prototypical implementation build on top of the Eclipse Modeling Framework (EMF).", "num_citations": "7\n", "authors": ["647"]}
{"title": "A pattern language for service-based platform integration and adaptation\n", "abstract": " Often software systems accommodate one or more software platforms on top of which various applications are developed and executed. Different application areas, such as enterprise resource planning, mobile devices, telecommunications, and so on, require different and specialized platforms. Many of them offer their services using standardized interface technologies to support integration with the applications built on top of them and with other platforms. The diversity of platform technologies and interfaces, however, renders the integration of multiple platforms challenging. In this paper, we discuss design alternatives for tailoring heterogeneous service platforms by studying high-level and low-level architectural design decisions for integrating and for adapting platforms. We survey and organize existing patterns and design decisions in the literature as a pattern language. With this pattern language, we address the\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "Xml-based dynamic content generation and conversion for the multimedia home platform\n", "abstract": " Many systems gather content from multiple input sources and provide it to multiple output channels. Usually content has to be (partly) generated, and content has to be converted to different formats. In this paper, we will discuss the domain of digital content broadcasting with the Multimedia Home Platform (MHP) as a case study domain. However, there are other domains that require content generation and conversion as well, such as web engineering and content management. As a solution, we will present a generic XML-based architecture for dynamic content generation and conversion. It provides content converters for multiple input and output formats. Content format templates, fragments, and content format builders are alternatives for dynamic content generation. Page templates are used to impose common styles and portal layouts for interdependent content. A Service Abstraction Layer supports service-based integration of different new media platforms.", "num_citations": "7\n", "authors": ["647"]}
{"title": "A key technology evaluation case study: Applying a new middleware architecture on the enterprise scale\n", "abstract": " Decisions for key technologies, like middleware, for large scale projects are hard, because the impact and relevance of key technologies go beyond their core technological field. E.g., object-oriented middleware has its core in realizing distributed object calls. But choosing a technology and product also implies to adopt its services, tools, software architectures, object and component paradigms, etc. Moreover, legacy applications and several other key technologies have to be integrated. And since no middleware product serves all requirements in the enterprise context, various middleware products have to be integrated, too. Another key problem of middleware evaluation is, that often the studies have to be performed very early in a project.In this paper we try to tackle these problems and describe how we can communicate the outcomes - which come from a technical viewpoint - to the management and other\u00a0\u2026", "num_citations": "7\n", "authors": ["647"]}
{"title": "From Domain-Specific Language to Code: Smart Contracts and the Application of Design Patterns\n", "abstract": " Due to the conceptual discrepancy between legal contract terms and code, understanding and creating smart contracts without errors can be difficult. This article proposes smart contract design patterns and their automated application through (the use of) a domain-specific language and code generation.", "num_citations": "6\n", "authors": ["647"]}
{"title": "Enabling flexibility of business processes using compliance rules: The case of Mobiliar\n", "abstract": " (a)                                              Situation faced: Insurance case work can follow established procedures only to a certain degree, as the work depends upon experienced knowledge workers who decide the best solutions for their clients. To produce quality documents in such a knowledge-intensive environment, business users of Die Mobiliar, the oldest private insurance company in Switzerland, were guided by a wizard application that enabled them to compose insurance documents from predefined building blocks in a series of pre-defined steps. As these steps were hardcoded into the wizard application, the processes could not adapt quickly enough to accommodate new insurance products and associated documentation. Rapidly changing insurance markets produce new types of documents daily, so business users must react flexibly to client requests. Although fully\u00a0\u2026", "num_citations": "6\n", "authors": ["647"]}
{"title": "Towards a framework for detecting containment violations in service choreography\n", "abstract": " In the design and development of service oriented applications, service choreography models describe the interactions between services at different abstraction levels. These models are usually created and evolved independently by different stakeholders and consequently deviations occur among models such as message not received and incompatible behaviours. It is therefore crucial to detect and resolve the deviations before actual implementation and deployment is undertaken. This paper presents a containment checking approach that verifies whether the behaviour (or interactions) described by the local choreography models collectively encompasses those specified in the global model. Previous studies have not considered the containment relationship between global and local choreography models. The proposed approach performs automated transformation of service choreography models into formal\u00a0\u2026", "num_citations": "6\n", "authors": ["647"]}
{"title": "Controlled experiment on the comprehension of runtime phenomena using models created at design time\n", "abstract": " Utilizing models for software construction is a well-studied research topic. Recent research investigates the integration of models into running systems to provide additional information about the system configuration at runtime. While this additional information enables innovative self-adaptive mechanisms, it is still an open research question if the information provided by models can also improve the analysis capabilities of human users where manual intervention is inevitable for investigating runtime phenomena. This paper contributes to fill this gap by conducting a controlled experiment where the correctness and completion time of tasks regarding runtime information are assessed. A control and experiment group had to analyze the output of a software system, and the experiment group additionally received traceability links between models and associated runtime records. The results show that improvements of\u00a0\u2026", "num_citations": "6\n", "authors": ["647"]}
{"title": "Enhancing root cause analysis with runtime models and interactive visualizations\n", "abstract": " Recent research shows that runtime models can be used to build dynamic systems coping with changing requirements and execution environments. As software systems are getting bigger and more complex, locating malfunctioning software parts is no trivial task because of the vast amount of possible error sources and produced logging information. This information has to be traced back to faulty components, which often leads to editing of code scattered over different software artefacts. With such a fragmented view, challenges arise in finding out the root cause of the unwanted software behaviour. In this paper we propose the usage of runtime models in combination with model-driven techniques and interactive visualizations to ease tracing between log file entries and corresponding software artefacts. The contribution of this paper is a repository-based approach to augment root cause analysis with interactive tracing views while maximizing reusability of models created during the software development process.", "num_citations": "6\n", "authors": ["647"]}
{"title": "An event view model and DSL for engineering an event-based SOA monitoring infrastructure\n", "abstract": " An event-based solution that uses events to convey information to a monitoring tool is well suited to implementing a non-intrusive monitoring infrastructure. This enables an SOA system's stakeholders to observe the system aspects of interest to them. However, implementation of SOA today, let alone the monitoring infrastructure, is a complex task due to the heterogeneous environment consisting of multiple technologies, platforms and components. We propose an approach for implementing such an event-based SOA monitoring infrastructure, that introduces a dedicated event view model and an eventing domain-specific language in a model-driven framework. The event view model captures SOA artifacts and links them with the event domain, while the eventing domain-specific language enables a system developer to specify instances of the event view model. With our model-driven approach, most of the runtime\u00a0\u2026", "num_citations": "6\n", "authors": ["647"]}
{"title": "Guest Editor's Introduction: Capturing Design Knowledge\n", "abstract": " Capturing software design knowledge is important because it tends to evaporate as software systems evolve. This has severe consequences for many software projects. To counteract this phenomenon, effective, systematic documentation of design knowledge is important. However, many proposed approaches for capturing design knowledge are still experimental or in an early-adoption stage. In this article, we discuss existing and new approaches to deal with parts of the knowledge evaporation problem.", "num_citations": "6\n", "authors": ["647"]}
{"title": "D2. 2 semantic querying, discovery, and composition framework\n", "abstract": " The business process modeling ontology (BPMO) contributes to bridging the gap between the business level perspective and the technical implementation level in business process management (BPM) by semantic descriptions of business processes. In order to benefit from the semantical description of business processes, semantically enabled techniques have to be developed for querying, discoverying and composing business processes accordingly. This deliverable introduces a comprehensive semantic business process framework with the basic components of semantic query, discovery and composition.", "num_citations": "6\n", "authors": ["647"]}
{"title": "Supporting automated containment checking of software behavioural models using model transformations and model checking\n", "abstract": " Models are extensively used in many areas of software engineering to represent the behaviour of software systems at different levels of abstraction. Because of the involvement of different stakeholders in constructing these models and their independent evolution, inconsistencies might occur between the models. It is thus crucial to detect these inconsistencies at early phases of the software development process, and especially as soon as refined models deviate from their abstract counterparts. In this article, we introduce a containment checking approach to verify whether a certain low-level behaviour model, typically created by refining and enhancing a high-level model, still is consistent with the specification provided in its high-level counterpart. We interpret the containment checking problem as a model checking problem, which has not received special treatment in the literature so far. Because the containment\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "How Understandable Are Pattern-based Behavioral Constraints for Novice Software Designers?\n", "abstract": " This article reports a controlled experiment with 116 participants on the understandability of representative graphical and textual pattern-based behavioral constraint representations from the viewpoint of novice software designers. Particularly, graphical and textual behavioral constraint patterns present in the declarative business process language Declare and textual behavioral constraints based on Property Specification Patterns are the subjects of this study. In addition to measuring the understandability construct, this study assesses subjective aspects such as perceived difficulties regarding learning and application of the tested approaches. An interesting finding of this study is the overall low achieved correctness in the experimental tasks, which seems to indicate that pattern-based behavioral constraint representations are hard to understand for novice software designers in the absence of additional supportive\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "A model-based transformation approach to reuse and retarget CASM specifications\n", "abstract": " The Abstract State Machine (ASM) theory is a way to specify algorithms, applications and systems in a formal model. Recent ASM languages and tools address either the translation of ASM specifications to a specific target programming language or aim at the execution in a specific environment. In this work-in-progress paper we outline a model-based transformation approach supporting (1) the specification of applications or systems using the Corinthian Abstract State Machine (CASM) modeling language and (2) retargeting those applications to different programming language and hardware target domains. An intermediate model is introduced, which not only captures software-based implementations, but also the generation of hardware-related code in the same model. This approach offers a new formal modeling perspective onto modular, reusable and retargetable software and hardware designs for\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "Variability for qualities in software architecture\n", "abstract": " Variability is a key factor of most systems. While there are many works covering variability in functionality, there is a research gap regarding variability in software qualities. There is an obvious imbalance between the importance of variability in the context of quality attributes, and the intensity of research in this area. To improve this situation, the First International Workshop on VAri- ability for QUalIties in SofTware Architecture (VAQUITA) was held jointly with ECSA 2015 in Cavtat/Dubrovnik, Croatia as a one-day workshop. The goal of VAQUITA was to investigate and stimulate the discourse about the matter of variability, qualities, and software architectures. The workshop featured three research paper presentations, one keynote talk, and two working group discussions. In this workshop report, we summarize the keynote talk and the presented papers. Additionally, we present the results of the working group discussions", "num_citations": "5\n", "authors": ["647"]}
{"title": "Empirical Study on the Effect of a Software Architecture Representation's Abstraction Level on the Architecture-Level Software Understanding\n", "abstract": " Architectural component models represent high level designs and are frequently used as a central view of architectural descriptions of software systems. In this paper we present a study that examines the effect of the level of abstraction of the software architecture representation on the architecture-level understand ability of a software system. Three architectural representations of the same software system that differ in the level of abstraction (and hence in the number of components used in the architecture) are studied. Our results show that an architecture at the abstraction level that is sufficient to adequately maps the system's relevant functionalities to the corresponding architectural components (i.e., each component in the architecture corresponds to one system's relevant functionality) significantly improves the architecture-level understanding of the software system, as compared to two other architectures that\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "Supporting software evolution by integrating DSL-based architectural abstraction and understandability related metrics\n", "abstract": " Software architecture erosion and architectural drift are well known software evolution problems. While there exist a number of approaches to address these problems, so far in these approaches the understandability of the resulting architectural models (eg, component models) is seldom studied. However, reduced understandability of the architectural models might lead to problems similar to architecture erosion and architectural drift. To address this problem, we propose to extend our existing DSL-based architecture abstraction approach with empirically evaluated understandability metrics. While the DSL-based architecture abstraction approach enables software architects to keep source code and architecture consistent, the understandability metrics extensions enables them, while working with the DSL, to continuously judge the understandability of the architectural component models they create with the DSL\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "Inconsistency management between architectural decisions and designs using constraints and model fixes\n", "abstract": " The software architecture community has proposed to document the design rationale of software architectures by means of architectural design decisions (ADDs). The constant evolution of software systems requires that both architectural designs and corresponding ADDs are continuously documented and synchronized. However, in practice, designs and ADDs become inconsistent over time. Usually, the potential inconsistencies need to be detected and resolved manually. We propose to alleviate this problem by providing semi-automated support for detecting and handling these inconsistencies. For this, we use constraints for consistency checking between reusable ADDs and component-and-connector (C&C) models. These constraints apply on the C&C models and their invalidation is resolved by software architects either 1) by executing automatically suggested model fixes on the C&C models, or 2) by\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "Supporting entailment constraints in the context of collaborative web applications\n", "abstract": " Collaborative Web applications allow several users to collaboratively work on the same artifact. In addition to popular use cases, such as collaborative text editing, they can also be used for form-based business applications that often require forms to be filled out by different stakeholders or stakeholder roles. In this context, the different stakeholders often need to fill in different parts of the forms. For example, in an e-health application a nurse might fill in the details and a doctor needs to sign them. Role-based access control and entailment constraints provide means for defining such restrictions. So far entailment constraint have mainly been studied in the context of workflow-based architectures, but not for collaborative Web applications. We present a generic approach for the specification and enforcement of entailment constraints in collaborative Web applications that supports their real-time nature and the non\u00a0\u2026", "num_citations": "5\n", "authors": ["647"]}
{"title": "Guest Editors' Introduction: Software Engineering for Compliance\n", "abstract": " This special issue of IEEE Software explores the challenges in developing compliant software systems. Typically, organizations face conflicting objectives, with compliance policies possibly hindering innovation, slowing down the product development process, or making the whole process most costly. The goal of software engineering for compliance is to bridge the gap between the software engineering community and the compliance community. The articles in this special issue explain the nature and extent of this domain from different viewpoints, the technical challenges it poses, novel software engineering methods for supporting compliance, and the current state of the art.", "num_citations": "5\n", "authors": ["647"]}
{"title": "Modeling the Evolution of Aspect Configurations using Model Transformations\n", "abstract": " In this paper we introduce an approach to address the evolution of aspect configurations with model transformations. We use model transformation diagrams (MTDs) to define valid behavioral model states of a system as well as valid transitions between those states. MTD transformations can be used to define evolutionary changes in the weaving process of an aspect-oriented system. To allow for a straightforward incorporation of aspects in UML models, we extend UML2 activity diagrams with joinpoint start and end nodes. In this paper, each model state in an MTD refers to an extended UML2 activity diagram.", "num_citations": "5\n", "authors": ["647"]}
{"title": "Reduction techniques for efficient behavioral model checking in adaptive case management\n", "abstract": " Case models in Adaptive Case Management (ACM) are business process models ranging from unstructured over semi-structured to structured process models. Due to this versatility, both industry and academia show growing interest in this approach. This paper discusses a model checking approach for the behavioral verification of ACM case models. To counteract the high computational demands of model checking techniques, our approach includes state space reduction techniques as a preprocessing step before state-transition system generation. Consequently, the problem size is decreased, which decreases the computational demands needed by the subsequent model checking as well. An evaluation of the approach with a large set of LTL specifications on two real-world case models, which are representative for semi-structured and structured process models and realistic in size, shows an acceptable\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "Synergies of system-of-systems and microservices architectures\n", "abstract": " Systems-of-Systems (SoS) are being widely embraced by both practitioners and researchers. They share properties such as distribution, evolutionary development (ie, openness), operational and managerial independence, and emergent behavior. Those properties imply that any element (system) in an SoS is able to operate independently. Similarly, microservices are suggested as a system architecture with a strong emphasis on independence, as containers provide the required degree of isolation, and their infrastructure automation frameworks provide the means to deploy them as needed. In a microservices architecture, even data is independently managed; every service maintains its own datastore, and transaction-less interaction is emphasized. Our hypothesis in this work is that while the two approaches have been treated separately in the literature so far, they share many common characteristics, and it\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "Distilling architectural design decisions and their relationships using frequent item-sets\n", "abstract": " Much attention is paid nowadays to software architecture of a system as a set of design decisions providing the rationale for the system design. To document and share proven architectural design decisions, decisions made in concrete development projects are mined and distilled into reusable architectural decision models (a.k.a. guidance models). The available distillation approaches, however, remain ad hoc and biased towards the personal experience of few expert architects. Relationships between distilled decisions are not systematically explored. We propose an approach for distilling reusable architectural design decisions with emphasis on their relationships. Architectural knowledge artifacts (e.g., architecture documentation, interviews) are systematically coded for the occurrence of architectural design decisions and their details. Co-occurrences of coded design decisions are then processed for different\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "Exploring the understandability of components in architectural component models using component level metrics and participants' experience\n", "abstract": " Architectural component models play a crucial role in achieving the desired software quality, as understandability of components and their interactions plays a key role in supporting the architectural understanding of a software system. In this article, we extend our previous studies on component models understandability. Our extensions study hierarchical understandability metrics, the impact of personal factors of participants like experience and expertise, and the combinations of both personal factors and the metrics (the previously studied and the newly introduced). The subjects of the study had to fully understand the functionalities of a number of components of an open source system by exploring the relationships of the components' classes. Our results provide evidence that the hierarchical understandability metrics are significantly better in predicting the understandability effort than the models obtained in our\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "The impact of hierarchies on the architecture-level software understandability-a controlled experiment\n", "abstract": " Architectural component models represent high level designs and are frequently used as a central view of architectural descriptions of software systems. They play a crucial role in the whole development process and in achieving the desired software qualities. This paper presents an empirical study that examines the impact of hierarchies on the architecture-level software understand ability. In particular we have studied three different architectural representations of a large-size software system, one with a hierarchical representation where architectural components at all abstraction levels in the hierarchy are shown, and two that do not contain hierarchical abstractions but concentrate only on the lowest level or on the highest level components in the hierarchy. We conducted a controlled experiment in which participants of three groups received one of the three architecture documentations plus the source code of the\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "On the effects of traceability links in differently sized software systems\n", "abstract": " Context: None of the published empirical studies on software traceability have comparatively examined the support for differently sized systems. Objective: This paper reports on two controlled experiments performed with two Enterprise Service Bus (ESB) systems that are comparable in terms of support features and system structure, but are different in their size, in particular, UltraESB Version 2.3. 0 and PetalsESB Version 4.2. 0, to investigate the effects of system size on the use of traceability links. Method: We conducted two controlled experiments in which the same impact evaluation activities were performed and measured how the control groups (provided with no traceability information) and the experiment groups (provided with traceability information) performed these activities in terms of the quantity and quality of retrieved elements. Results: Our findings show that the 133.71% larger size of one of ESBs does\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "Supporting customized views for enforcing access control constraints in real-time collaborative web applications\n", "abstract": " Real-time collaborative Web applications allow multiple users to concurrently work on a shared document. In addition to popular use cases, such as collaborative text editing, they can also be used for form-based business applications that often require forms to be filled out by different stakeholders. In this context, different users typically need to fill in different parts of a form. Role-based access control and entailment constraints provide means for defining such restrictions. Major challenges in the context of integrating collaborative Web applications with access control restrictions are how to support changes of the configuration of access constrained UI elements at runtime, realizing acceptable performance and update behaviour, and an easy integration with existing Web applications. In this paper, we address these challenges through a novel approach supporting constrained and customized UI views that\u00a0\u2026", "num_citations": "4\n", "authors": ["647"]}
{"title": "Definition of an Aspect-Oriented DSL using a Dynamic Programming Language\n", "abstract": " We present an approach to define an aspect-oriented DSL using a dynamic language. In particular, we describe an extensible aspectoriented DSL for role-based access control and its implementation. Furthermore, we show how a dynamic pointcut language can be used to compose the different elements of our DSL. We implemented our approach using the XOTcl scripting language. The general approach, however, can be realized using any other dynamic language as well.", "num_citations": "4\n", "authors": ["647"]}
{"title": "Semantic lookup in service-oriented architectures\n", "abstract": " Lookup of services is an important issues in many distributed systems. This paper deals with lookup in service-oriented architectures, such as Web services, P2P systems, GRIDs, or spontaneous networks. Service-oriented architectures impose specific requirements onto the lookup service, for instance regarding the runtime extensibility of lookup models, runtime extensibility of lookup queries, construction of complex lookup queries, scalability, and fault tolerance. These requirements are not well solved by existing lookup approaches. We propose a semantic lookup service using Semantic Web ontologies, expressed in RDF. Query scripts are sent from the client to the server and are interpreted at server side using the RDF repository. We also present a safe, scalable, and efficient architecture for defining and querying lookup information using this lookup service concept.", "num_citations": "4\n", "authors": ["647"]}
{"title": "Structuring the state and behavior of ASMs: introducing a trait-based construct for abstract state machine languages\n", "abstract": " Abstract State Machine (ASM) theory is a well-known state-based formal method to analyze, verify, and specify software and hardware systems. Nowadays, as in other state-based formal methods, the proposed specification languages for ASMs still lack easy-to-comprehend language constructs for type abstractions to describe reusable and maintainable specifications. Almost all built-in behaviors are implicitly defined inside a concrete ASM language implementation and thus, the behavior is hidden from the language user. In this paper, we present a new ASM syntax extension based on traits, which allows the specifier (language user) to define new type abstractions in the form of structure and behavior definitions to reuse, maintain, structure, and extend the functionality in ASM specifications. We describe the proposed language construct by defining its syntax and semantics. The decision to use a trait\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Modeling compliance specifications in linear temporal logic, event processing language and property specification patterns: a controlled experiment on understandability\n", "abstract": " Mature verification and monitoring approaches, such as complex event processing and model checking, can be applied for checking compliance specifications at design time and runtime. Little is known about the understandability of the different formal and technical languages associated with these approaches. This uncertainty regarding understandability might be a major obstacle for the broad practical adoption of those techniques. This article reports a controlled experiment with 215 participants on the understandability of modeling compliance specifications in representative modeling languages, namely linear temporal logic (LTL), the complex event processing-based event processing language (EPL) and property specification patterns (PSP). The formalizations in PSP were overall more correct. That is, the pattern-based approach provides a higher level of understandability than EPL and LTL. More\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Dynamic data routing decisions for compliant data handling in service-and cloud-based architectures: A performance analysis\n", "abstract": " In many service-based applications, decisions about data routing need to be made at runtime, for instance to ensure compliant data handling. Different service-and cloud-based architectures to make dynamic data routing decisions exist including central entities, multiple dedicated dynamic router services, or using a sidecar for each involved service. These archi-tectures differ in various quality attributes including complexity, understandability, and changeability of the decision logic. Choosing the wrong architecture for decision-making at runtime may severely impact the performance of the software system. In this paper, we have evaluated the performance of three representative approaches for processing compliance rules concerned with data routing in service-and cloud-based architectures. The results show that distributed approaches for dynamic data routing have a better performance compared to centralized\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Towards containment checking of behaviour in architectural patterns\n", "abstract": " The behaviour of architectural patterns must be consistent in terms of the artefacts produced in the various activities of the software development process, such as requirements, software architecture, detailed design and implementation. In this context, high-level models are mainly used to convey the core concepts or principles of the reality they represent in an abstract and/or concise way (eg, requirements or architecture design). If a specific architectural pattern like model-view-controller is used in such high-level models, the corresponding detailed designs and implementations are also based on the particular pattern. Low-level or detailed design models are used to provide a (more) precise specification of the source code. However, because of the involvement of different stakeholders and independent evolution of software systems, inconsistencies might occur in architectural patterns' behaviour at those different\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Towards a pattern language for construction and maintenance of software architecture traceability links\n", "abstract": " The documentation of software architecture traceability links is the foundation for many important architecture management activities, such as verification and validation, reuse evaluation and impact analysis. In practice, the construction and maintenance of traceability links is mostly manual, which is labor-intensive and error prone. Although the costs of manual traceability in terms of the time, effort and money required can be mitigated by automated construction, the completeness and correctness of traceability links tends to be negatively affected by automation in their creation and maintenance. This paper presents a pattern language for construction and maintenance of software architecture traceability links to requirements and source code. As a foundation for deriving the pattern language, we have performed systematic literature reviews, investigations of traceability links for multiple open-source software systems\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Cost-effective traceability links for architecture-level software understanding: a controlled experiment\n", "abstract": " An important architectural challenge is to recover traceability links between the software architecture and artifacts produced in the other activities of the development process, such as requirements, detailed design, architectural knowledge, and implementation. This is challenging because, on the one hand, it is desirable to recover traceability links of a high quality and at the right quantity for aiding the software architect or developer, but, on the other hand, the costs and efforts spent for recovering should be as low as possible. The literature suggests manual, semi-automatic, and automatic recovery methods, each of which exhibits different impacts on costs as well as quantity and quality of the recovered links. To date, however, none of the published empirical studies have comparatively examined the automation alternatives of traceability link recovery. This paper reports on a controlled experiment that was\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Architecting for decision making about code evolution\n", "abstract": " During software evolution, it is important to evolve not only the source code, but also its architecture to prevent architecture drift and architecture erosion. This is a complex activity, especially for large software projects, with multiple development teams that might be located in different countries or on different continents. To ease this kind of evolution, we have developed a domain-specific language for making decisions about the evolution. It supports the definition of architectural changes based on multiple implementation tasks that can have temporal dependencies among each other. Then, by means of a model-to-model transformation, we automatically create a constraint model that we use to generate, by means of the Alloy model analyzer, the possible alternative decisions for executing the implementation tasks. The tight integration with architecture abstractions enables architects to automatically check the\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Pattern-based process for a legacy to SOA modernization roadmap\n", "abstract": " Many organizations still operate their businessms which cause high maintenance costs and are difficult to change. After the hype about service-oriented architectures (SOAs) was gone, they were implemented successfully and helped replacing old legacy systems with flexible services, for example at large companies in the finance or logistics industry. While recent research and the pattern literature cover the technical aspects of SOA and the alignment between business and IT, defining and planning a roadmap for a SOA modernization program, which is essential for initiating such a program and getting the necessary commitment, has not been in the focus of research yet. Thus, we propose a design process for the definition of a high-level roadmap. It considers determining architectural decisions and planning decisions by selecting appropriate patterns and reference architectures. Furthermore we define a heuristic\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Derivation of domain-specific architectural knowledge views from governance and security compliance metadata\n", "abstract": " In the area of software architecture, in recent years, modeling design decisions is becoming more and more popular as a means to record architectural knowledge (AK) and capture the rationale of a design. Unfortunately, decision modeling is rather time-consuming and hence often forgotten in practice. In this paper, we propose that this problem can be avoided by utilizing domain-specific information that contains AK. We focus on domain-specific AK in the domain of business governance and security compliance. A novel approach is presented for recording the compliance concerns and extracting the corresponding AK. For this purpose we introduce a compliance meta-model and propose a mapping to the AK. Model-driven techniques are used as a supporting tool for generating AK documentation.", "num_citations": "3\n", "authors": ["647"]}
{"title": "Enhancing traceability of persistent data access flows in process-driven SOAs\n", "abstract": " In process-driven, service-oriented architectures (SOAs), process activities can perform service operations, data transformations, or human tasks. Unfortunately, the process activities are usually tightly coupled. Thus, when the number of activities in the process grows, focusing on particular activities of the flow such as the service operations reading or writing persistent data is a time-consuming task. In particular, in order to solve structural problems concerning persistent data access such as deadlocks in data-intensive business processes, stakeholders need to understand the underlying persistent data access details of the activities i.e. physical storage schemes, and database connections.               With our view-based model-driven approach, we provide a solution to generate flows of persistent data access activities (which we refer to as persistent data access flows). To the best of our knowledge these\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "UML2 profile and model-driven approach for supporting system integration and adaptation of web data mashups\n", "abstract": " From a system integration perspective, Web data mashups used in larger architectures often need to be integrated with other system components, such as services, business processes, and so on. Often a change in one of these components requires changes in many of the dependent components. Similarly, an analysis of some system properties requires knowledge about other system parts than just the mashup. Such features could be implemented using the model-driven development (MDD) approach, but existing MDD approaches for mashups concentrate on modeling and execution only. To remedy this problem, we propose a generic approach based on a UML2 profile which can easily be extended to model other system parts or integrated with other existing models. It is the foundation for generating or interpreting mashup code in existing languages as well as other system parts using the MDD\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Using model-driven views and trace links to relate requirements and architecture: a case study\n", "abstract": " Compliance in service-oriented architectures (SOA) means in general complying with laws and regulations applying to a distributed software system. Unfortunately, many laws and regulations are hard to formulate. As a result, several compliance concerns are realized on a per-case basis, leading to ad hoc, hand-crafted solutions for each specific law, regulation, and standard that a system must comply with. This, in turn, leads in the long run to problems regarding complexity, understandability, and maintainability of compliance concerns in a SOA. In this book chapter, we present a case study in the field of compliance to regulatory provisions, in which we applied our view-based, model-driven approach for ensuring the compliance with ICT security issues in business processes of a large European company. The research question of this chapter is to investigate whether our model-driven, view-based\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Supporting the evolution of model-driven service-oriented systems: A case study on QoS-aware process-driven SOAs\n", "abstract": " Process-driven service-oriented architectures (SOA) need to cope with constant changing requirements of various compliance requirements, such as quality of service (QoS) constraints within service level agreements (SLA). To the best of our knowledge, only little evidence is available if and in how far process-driven SOAs deal with the evolution of the requirements. In this work, we evaluate an incremental and model-driven development approach on the evolution of the requirements and the domain model in the context of an industrial case study. The case study focuses on advanced telecom services that need to be compliant to QoS constraints. This paper answers questions about the applicability of the incremental development approach, the impact of requirement changes, possible drawbacks of using a non-incremental development approach, and general recommendations based on the findings. Our results\u00a0\u2026", "num_citations": "3\n", "authors": ["647"]}
{"title": "Evaluating java runtime reflection for implementing cross-language method invocations\n", "abstract": " Cross-language method invocations are commonly used for integrating objects residing in different programming language environments. In this experience report, we evaluate the performance and the design impact of alternative implementations of cross-language method invocations for the object-oriented scripting language Frag, implemented and embedded in Java. In particular, we compare reflective integration and generative integration techniques. For that, we present a performance evaluation based on a large set of test cases. In addition, we propose a new method for quantifying and comparing the implementation efforts needed for cross-language method invocations based on cross-language refactorings. We report on the lessons learnt and discuss the consequences of the implementation variants under review.", "num_citations": "3\n", "authors": ["647"]}
{"title": "Invocation assembly lines: patterns of invocation and message processing in object remoting middleware\n", "abstract": " Developers who design and implement object remoting middleware are confronted with the task of supporting many different kinds of remote invocations. On the one hand, this variety is caused by the architectural setting in which the middleware is deployed and used. On the other hand, realising different kinds of remote invocations affects many spots of your middleware framework\u2019s design and implementation. These two issues are the root of two challenging design problems for the messaging processing infrastructure of a middleware.The first design problem is the issue of role distribution (see eg [67, 63, 52, 3]): Applications built on top of your middleware framework must often play different roles, for example, they are expected to act both as a client issuing and as a server performing remote invocations. As these applications integrate the facilities offered by your middleware framework, your framework must facilitate the adoption by client-as well as server-side applications.", "num_citations": "3\n", "authors": ["647"]}
{"title": "Domain-specifically tailorable languages and software architectures\n", "abstract": " In this position paper we will motivate open issues in the context of domain-specific tailorability of software systems, as we have observed them in numerous projects. These issues are largely unresolved in today\u2019s software engineering practices. However, we can identify a set of recurring forces in this context. Different interaction and programming techniques can be used to partially resolve these issues. As a vision of a solution, we argue for building task-specific and extensible languages that map well to the primitives of the domain. The languages should also be well integrated with the software architecture fragments wrapped by the language elements.", "num_citations": "3\n", "authors": ["647"]}
{"title": "On the practitioners\u2019 understanding of coupling smells\u2014A grey literature based Grounded-Theory study\n", "abstract": " Context:Code and design smells, such as the coupling smells examined in this article, are widely studied. Existing empirical studies reveal gaps between the scientific theory and practice, not yet explained by the scientific literature. Only basic coupling smell detection approaches and metrics seem to have been transferred to practice so far.Objective:This article aims to study the current practitioner\u2019s understanding of coupling smells.Method:Based on grey literature sources containing practitioner views on coupling smells, we performed a Grounded Theory (GT) study. We used UML-based modeling to precisely encode our findings and performed a rigorous analysis of our codes and models.Results:Our results are defining factors of coupling smells, as well as smell impacts, trade-offs, relationships to other smells, relationships to practices and patterns, and fix options as perceived by practitioners. We further\u00a0\u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "Design of an executable specification language using eye tracking\n", "abstract": " Increasingly complex systems require powerful and easy to understand specification languages. In the course of the design and the extension of an executable specification language based on the Abstract State Machines formalism we recently performed a user survey. The question, how new language features are comprehended, remains unsolved. The main emphasis of this study is on eye gaze behavior of participants learning language features. Eye-tracking experiments were performed in two different countries using a Pupil Labs eye-tracking headset. An example specification and simple comprehension tasks were used as stimuli. The preliminary results of the eye-gaze behaviour analysis reveal that the new language feature was undestood well, but the new abstractions were frequently confused by participants. The foreknowledge of specific programming concepts is crucial how these abstractions are\u00a0\u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "Supporting the analyzability of architectural component models-empirical findings and tool support\n", "abstract": " This article discusses the understandability of component models that are frequently used as central views in architectural descriptions of software systems. We empirically examine how different component level metrics and the participants\u2019 experience and expertise can be used to predict the understandability of those models. In addition, we develop a tool that supports applying the obtained empirical findings in practice. Our results show that the prediction models have a large effect size, which means that their prediction strength is of high practical significance. The participants\u2019 experience plays an important role in the prediction but the obtained models are not as accurate as the models that use the component level metrics. The developed tools combine the DSL-based architecture abstraction approach with the obtained empirical findings. While the DSL-based architecture abstraction approach enables\u00a0\u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "Architectural Design Decisions for Systems Supporting Model-Based Analysis of Runtime Events: A Qualitative Multi-method Study\n", "abstract": " Models are popular artefacts in the software development process which promise to improve stakeholder communication and the overall quality of a software system under construction. Recent research proposes that the usefulness of models is not limited only to the software design phase: Empirical evidence indicates that manual analysis of a running system is improved when models are linked to recorded runtime events. However, software architects are confronted with various design decisions when designing a system that yields the required runtime events and correlates them to the model elements they originate from. The contribution of this paper is a taxonomy of architectural design decisions distilled from a series of qualitative studies following a multi-method research study design: We utilized coding techniques from Grounded Theory to build an initial taxonomy from architectural concepts found in the\u00a0\u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "An Ontology-Based Approach for Defining Compliance Rules by Knowledge Workers in Adaptive Case Management-A Repair Service Management Case\n", "abstract": " Empowering knowledge workers (KWs) to act more efficiently and flexibly in unpredictable situations is the main focus of Adaptive Case Management (ACM), although ad hoc actions at runtime shall not violate the consistency and compliance of an on-going case. In this paper we discuss how business constraints stemming from regulatory laws or standards are transferred from textual sources to formal specifications in the form of compliance rule objects relating to ACM objects. In order to mitigate the knowledge barriers between business and IT, we apply an ontology-based solution allowing KWs to define compliance rules from a pure business perspective using domain-specific terms. We demonstrate the implementation using a repair service case and discuss the benefit of our approach for the sake of administration of business aspects by KWs without IT involvement.", "num_citations": "2\n", "authors": ["647"]}
{"title": "Enforcing entailment constraints in offline editing scenarios for real-time collaborative web documents\n", "abstract": " Real-time collaborative Web applications allow a multitude of users to concurrently work on a shared document. Especially in business contexts it is often necessary to be able to precisely define and restrict who is allowed to edit which data field of such a shared document. Existing solutions for enforcing such access control restrictions typically rely on a central service, the policy decision point. However, for use cases with unreliable or limited connectivity, such as mobile devices, a permanent connection to this centralized policy decision point can not be guaranteed. To address this problem, we present a novel approach that includes methods for client-side enforcement of access control constraints for offline users, and merging of offline changes, that enables users to edit such access constrained shared documents offline. We propose a generic conflict detection and resolution approach that attempts to resolve\u00a0\u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "Process-Driven SOA-Proven Patterns for Business-IT Alignment\n", "abstract": " Process-Driven SOA - Proven Patterns for Business-IT Alignment - CS Faculty of Computer Science University of Vienna Home Browse by Year Browse by Subject Browse by Research Area Browse by Author Login Process-Driven SOA - Proven Patterns for Business-IT Alignment Process-Driven SOA - Proven Patterns for Business-IT Alignment Content Grafik Authors Shortfacts Authors Hentrich, Carsten Zdun, Uwe Grafik Top Shortfacts Category Book Divisions Software Architecture Subjects Software Engineering Publisher CRC Press, Taylor and Francis Place of Publication Boca Raton Date 2012 Export Download Grafik Top Edit Universit\u00e4t Wien| Fakult\u00e4t f\u00fcr Informatik | W\u00e4hringer Stra\u00dfe 29 | 1090 Wien | T +43-1-4277-780 01 | Imprint | Webteam EPrints Logo CS is powered by EPrints 3 which is developed by the School of Electronics and Computer Science at the University of Southampton. More information and \u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "Model-driven and domain-specific architectural knowledge view for compliance meta-data in process-driven SOAs\n", "abstract": " Architectural knowledge tends to get lost as the architecture evolves. In many cases, the main reason is that there are no incentives for stakeholders to invest enough time into recording the architectural knowledge. This is in part due to the generic nature of architectural knowledge recording and sharing means, such as architectural decision templates and meta-models. In this paper, we investigate on the feasibility of a domain-specific architectural knowledge view in the context of a model-driven project. The domain-specific approach helps us to make architectural knowledge (AK) recording more useful for a project apart from the goal of AK sharing and reuse. Model-driven development helps us to ensure the consistency of the architectural knowledge as it is part of the generation process. Finally, depicting architectural knowledge as a architectural view supports separation of concerns with regard to the various\u00a0\u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "Engineering Loosely Coupled Software Architectures-A Pattern-Based Approach\n", "abstract": " Engineering Loosely Coupled Software Architectures - A Pattern-Based Approach - CS Faculty of Computer Science University of Vienna Home Browse by Year Browse by Subject Browse by Research Area Browse by Author Login Engineering Loosely Coupled Software Architectures - A Pattern-Based Approach Engineering Loosely Coupled Software Architectures - A Pattern-Based Approach Content Grafik Authors Shortfacts Authors Zdun, Uwe Grafik Top Shortfacts Category Book Divisions Software Architecture Subjects Software Engineering Publisher Habilitationsschrift, Wirtschaftsuniversitaet Wien Place of Publication Vienna, Austria Date January 2006 Export Download Grafik Top Edit Universit\u00e4t Wien| Fakult\u00e4t f\u00fcr Informatik | W\u00e4hringer Stra\u00dfe 29 | 1090 Wien | T +43-1-4277-780 01 | Imprint | Webteam EPrints Logo CS is powered by EPrints 3 which is developed by the School of Electronics and Computer \u2026", "num_citations": "2\n", "authors": ["647"]}
{"title": "On the Understandability of Language Constructs to Structure the State and Behavior in Abstract State Machine Specifications: A Controlled Experiment\n", "abstract": " State Machine (ASM) theory is a well-known state-based formal method to analyze and specify software and hardware systems. As in other state-based formal methods, the proposed modeling languages for ASMs still lack easy-to-comprehend abstractions to structure state and behavior aspects of specifications. Modern object-oriented languages offer a variety of advanced language constructs, and most of them either offer interfaces, mixins, or traits in addition to classes and inheritance. Our goal is to investigate these language constructs in the context of state-based formal methods using ASMs as a representative of this kind of formal methods. We report on a controlled experiment with 105 participants to study the understandability of the three language constructs in the context of ASMs. Our hypotheses are influenced by the debate of object-oriented communities. We hypothesized that the understandability\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Architectural Design Decisions for Blockchain-Based Applications\n", "abstract": " Designing blockchain-based applications is a challenging task and requires a number of coordinated architecture decisions. To guide decision making in this regard, we systematically explore this architectural design space and possible solution strategies. More precisely, we provide architectural design decisions and decision options in terms of patterns and practices. Our research shows that most design decisions are influenced by the need to offset current blockchain drawbacks such as scalability, privacy, and usability by using centralized elements. This suggests that a hybrid architecture is beneficial in many design situations.", "num_citations": "1\n", "authors": ["647"]}
{"title": "Practitioner Views on the Interrelation of Microservice APIs and Domain-Driven Design: A Grey Literature Study Based on Grounded Theory\n", "abstract": " Microservice API design is a critical aspect in crafting a microservice architecture. While API design in general has been studied, the specific relation of API design to design practices and models commonly used in microservice architectures is yet understudied. In particular, practitioners frequently use Domain-Driven Design (DDD) in their microservice architecture and API designs. We thus decided to study existing Architectural Design Decisions (ADDs), their solutions options, their relations, and the decision drivers in these decisions. Using the Grounded Theory research method we studied grey literature sources. In this study, we identified six ADDs with 27 decision options, numerous relations between them, and 27 decision drivers. The decisions cover mapping domain models to APIs, defining API contracts in relation to domain models, designing API resources based on domain model elements, segregation of\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Monitoring Behavioral Compliance with Architectural Patterns based on Complex Event Processing\n", "abstract": " Architectural patterns assist in the process of architectural decision making as they capture architectural aspects of proven solutions. In many cases, the chosen patterns have system-wide implications on non-functional requirements such as availability, performance, and resilience. Ensuring compliance with the selected patterns is of vital importance to avoid architectural drift between the implementation and its desired architecture. Most of the patterns not only capture structural but also significant behavioral architectural aspects that need to be checked. In case all properties of the system are known before runtime, static compliance checks of application code and configuration files might be sufficient. However, in case aspects of the system dynamically evolve, e.g., due to manual reconfiguration, compliance with the architectural patterns also needs to be monitored during runtime. In this paper, we propose to link compliance rules to architectural patterns that specify behavioral aspects of the patterns based on runtime events using stream queries. These queries serve as input for a complex event processing component to automatically monitor architecture compliance of a running system. To validate the practical feasibility, we applied the approach to a set of architectural patterns in the domain of distributed systems and prototypically implemented a compliance monitor.", "num_citations": "1\n", "authors": ["647"]}
{"title": "Business Process Management Workshops: BPM 2019 International Workshops, Vienna, Austria, September 1-6, 2019, Revised Selected Papers\n", "abstract": " This book constitutes revised papers from the twelve International Workshops held at the 17th International Conference on Business Process Management, BPM 2019, in Vienna, Austria, in September 2019: The third International Workshop on Artificial Intelligence for Business Process Management (AI4BPM) The third International Workshop on Business Processes Meet Internet-of-Things (BP-Meet-IoT) The 15th International Workshop on Business Process Intelligence (BPI) The first International Workshop on Business Process Management in the era of Digital Innovation and Transformation (BPMinDIT) The 12th International Workshop on Social and Human Aspects of Business Process Management (BPMS2) The 7th International Workshop on Declarative, Decision and Hybrid approaches to processes (DEC2H) The second International Workshop on Methods for Interpretation of Industrial Event Logs (MIEL) The first International Workshop on Process Management in Digital Production (PM-DiPro) The second International Workshop on Process-Oriented Data Science for Healthcare (PODS4H) The fourth International Workshop on Process Querying (PQ) The second International Workshop on Security and Privacy-enhanced Business Process Management (SPBP) The first International Workshop on the Value and Quality of Enterprise Modelling (VEnMo) Each of the workshops discussed research still in progress and focused on aspects of business process management, either a particular technical aspect or a particular application domain. These proceedings present the work that was discussed during the workshops..", "num_citations": "1\n", "authors": ["647"]}
{"title": "Refactoring architecture models for compliance with custom requirements\n", "abstract": " In the process of software-intensive systems engineering, architectures need to be designed that are compliant to the requirements. For this, architects need to examine those requirements with regard to their architectural impact. Accessing and interpreting the requirements is however not always possible, for instance if custom requirements are yet unknown at the time when the architecture is modeled. Ideally, architectural knowledge as derived from custom requirements could be imposed upon architecture models. This paper proposes a novel concept for automated refactoring of architecture models in order to meet such requirements by formalizing architectural knowledge using model verification and model transformations. Industrial application within a telecommunications service provider is demonstrated in the domain of cloud application orchestration: service providers are enabled to autonomously customize\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "A pattern language for manual analysis of runtime events using design models\n", "abstract": " Modeling is an important activity in the software development process whose output are design artefacts that describe the resulting software from a high-level perspective. Recent research investigates the role of models at runtime and the results indicate that analysts perform better at observing the behaviour of a running system if they can utilize models during the analysis. However, setting up a system which allows the analysis of its behaviour at runtime using models involves many challenges regarding the modeling environment, the introspection infrastructure, the traceability management and the analysis integration. This paper summarizes design alternatives for implementing systems with manual analysis support by investigating recurring concepts like patterns, modeling habits, languages, middlewares and development techniques found in approaches that utilize models at runtime. We organize the gained\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "On-Demand Automated Traceability Maintenance and Evolution\n", "abstract": " After the painstaking process of traceability construction, a substantial evolution of a software system, such as a new major version leads to the decay of traceability links. To date, however, none of the published studies have considered the on-demand update of traceability links. This paper presents an on-demand automated approach for case-based maintenance and evolution of traceability links in the context of different versions of a software project. The approach focuses on the component-to-component features for identification and prioritization of previous traceability cases, which are then used to perform reuse and adaptation of traceability links based on the matches and mismatches, respectively. The adapted (i.e., newly constructed) traceability links can then be verified by a human analyst and stored in a case base. The approach has been validated using an open-source framework for mobile\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Lightweight approach for seamless modeling of process flows in case management models\n", "abstract": " Case management models are business process models that allow a great degree of flexibility at runtime by design. In contrast to flow-driven business processes (eg, BPMN, EPC, UML activity diagrams), case management models primarily describe a business process by tasks, goals (ie, milestones), stages, and dependencies between them. However, flow-driven processes are still often required and relevant in practice. In the recent case management standard CMMN (Case Management Model and Notation), support for process flows is offered by referencing BPMN processes. This results in a conceptual break between case elements and those in such subprocesses, so that dependencies from and to elements contained in flow-driven processes are unsupported. Moreover, case designers and other involved stakeholders are required to have substantial knowledge of not only case modeling but also of flow\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Software Architecture: 10th European Conference, ECSA 2016, Copenhagen, Denmark, November 28--December 2, 2016, Proceedings\n", "abstract": " This book constitutes the proceedings of the 10th European Conference on Software Architecture, ECSA 2016, held in Copenhagen, Denmark, in November/December 2016. The 13 full papers presented together with 12 short papers were carefully reviewed and selected from 84 submissions. They are organized in topical sections on full research and experience papers, short papers for addressing emerging research, and education and training papers.", "num_citations": "1\n", "authors": ["647"]}
{"title": "Embracing Process Compliance and Flexibility through Behavioral Consistency Checking in ACM\n", "abstract": " Enabling flexibility in unpredictable situations with ad hoc actions decided at runtime by knowledge workers is the main focus of Adaptive Case Management (ACM) systems. However, ad hoc actions added during case execution and ACM templates prepared at design time need to be within the boundaries defined by business constraints, company regulations and legal systems. In this paper we report our experience in addressing this challenge by using model checking and runtime monitoring techniques for behavioral consistency checking that can handle both ACM aspects: support by means of predefined process templates and high flexibility by allowing ad hoc actions at runtime. Our study is conducted using a practical ACM system for repair service management handling different customer requirements under diverse compliance and law regulations.", "num_citations": "1\n", "authors": ["647"]}
{"title": "Domain Specific Languages for Maintaining and Analyzing Changes in Event-Based Architectures\n", "abstract": " A main characteristic of event-driven architectures is that components are highly decoupled, which facilitates high flexibility, scalability and concurrency of distributed systems. This intrinsic loose coupling of components introduces the challenge to identify dependencies between the components, which have to be known to developers to analyze, maintain, and evolve an event-based architecture. The knowledge about component's dependencies is often hard to gain due to the absence of explicit information about these dependencies. Furthermore, assisting techniques for analyzing the impacts of certain changes are missing, hindering the implementation of changes in event-driven architectures. In this paper we present a novel approach to support developers in evolving event-based architectures by using model-based domain specific languages for describing changes at different levels of abstraction. The DSLs'\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Enterprise integration using event actor based event transformations\n", "abstract": " Event-driven architectures can be used to enhance the flexibility of software system integration solutions by supporting flexible run-time changes of event processing rules, eg, in complex event processing (CEP) engines. However, this often leads to integration solutions that are hard to maintain, complex, hard to reuse, and hard to understand. One reason are complex dependencies of events like high-level events mapped to low-level events or transformations of events between integrated systems (such as event aggregation, enriching, or splitting) that are hard to understand only by studying the interplay of various CEP rules. Another reason is tangled code spread across multiple artifacts including event processing code, event monitors, event listeners, event transformation code, existing system components that must raise or receive events. In this paper we propose to base integration architectures on event actors\u00a0\u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Architektur-Anforderungen (WARUM)\n", "abstract": " Dieses Kapitel befasst sich mit der WARUM-Dimension des architektonischen Ordnungsrahmens. Zentrale Elemente der WARUM-Dimension sind Anforderungen. Sie umrei\u00dfen das zu erstellende IT-System und begrenzen den gestalterischen Spielraum des Architekten. Anforderungen treten in unterschiedlichen Arten und auf verschiedenen Architektur-Ebenen auf. Damit ein Architekt seinen gestalterischen Spielraum nutzen kann, muss er die unterschiedlichen Auspr\u00e4gungen von Anforderungen und ihre Beziehungen zueinander kennen. Dieses Kapitel gibt einen \u00dcberblick \u00fcber die verschiedenen Anforderungsarten und deren Bezug zu den Architektur-Ebenen. Nach dem Lesen dieses Kapitels k\u00f6nnen Sie die wichtigsten Anforderungsarten nennen, deren Beziehungen verstehen und sie in den Kontext von Architektur setzen.", "num_citations": "1\n", "authors": ["647"]}
{"title": "D2. 3 Prototype Implementation\n", "abstract": " This document discusses the design and implementation of the SemBiz prototype for Semantic Business Process Querying, Discovery, and Composition. This prototype consists of the business process querying, discovery, composition and deployment components. The main design and implementation issues of the components are discussed. Additionally, the document references installation instructions for the SemBiz components.", "num_citations": "1\n", "authors": ["647"]}
{"title": "Community rating service and user buddy supporting advices in community portals\n", "abstract": " Many community portals allow users to search for events, such as concerts, festivals or other things of interest and to rate them. Especially in the culture domain the users\u2019 impressions of events is based on many factors, such as quality, personal interests, etc. Such factors can be represented using an ontology. The ratings provided by the users of community portals are often highly biased by personal opinions, and hence not all information provided by users is useful for all other users. But it can be observed that users with similar interests provide similar opinions. This paper introduces a community rating approach based on this observation. Our concept introduces for each user a user buddy, representing the part of the community with similar opinions as those of the user. The buddy uses a community rating service as a basis to give advices to users, such as recommendations for events or help in searching the portal. Our approach gathers opinions using a domain ontology, but it is not dependent on a specific ontology.", "num_citations": "1\n", "authors": ["647"]}
{"title": "D5. 1 Exploratory Case Study\n", "abstract": " This deliverable provides a detailed validation and evaluation of SemBiz technology. We propose a case study to clarify research topics and to investigate alternatives by evaluating and comparing the BPMO to other frameworks and by evaluating the theoretical approaches for querying, discovery and composition of business processes and comparing with related work.", "num_citations": "1\n", "authors": ["647"]}
{"title": "Architectural patterns in practice\n", "abstract": " Architectural Patterns in Practice \u2014 the University of Groningen research portal Skip to main navigation Skip to search Skip to main content the University of Groningen research portal Logo Help & FAQ English Nederlands Home Profiles Research Units Research output Projects Datasets Prizes Activities Press / Media Search by expertise, name or affiliation Architectural Patterns in Practice Paris Avgeriou, Uwe Zdun Software Engineering Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter \u203a Academic 93 Downloads (Pure) Overview Original language English Title of host publication EPRINTS-BOOK-TITLE Publisher University of Groningen, Johann Bernoulli Institute for Mathematics and Computer Science Number of pages 4 Publication status Published - 2005 Access to Document 2005ProcEuroPLoPAvgeriou.pdfFinal publisher's version, 55.6 KB Cite this APA Author BIBTEX Harvard \u2026", "num_citations": "1\n", "authors": ["647"]}
{"title": "Using runtime introspectible metadata to integrate requirement traces and design traces in software components\n", "abstract": " Software engineering produces different artifacts, such as requirement specifications, design documents, source code, documentation, test cases, binaries, etc. In today\u2019s software engineering practice the produced artifacts are usually not well integrated and only little trace information is available that explicitly describes the dependencies of different system parts represented in these artifacts. Thus, in case of a change request it is hard to rapidly find the relevant artifacts and system parts that are affected by a change request. Frequently (unexpected) changes lead to inconsistencies in the artifacts. In this paper, we extend an approach, originally aiming at exposing architectural knowledge at runtime, with informal requirement specifications and respective test cases. The presented approach thus enables the definition of runtime-traceable dependencies of requirement specifications and test cases to corresponding architectural elements and source code fragments. Thus, our approach aims to facilitate timely change propagation and regression testing.", "num_citations": "1\n", "authors": ["647"]}
{"title": "XOTcl@ Work\n", "abstract": " XOTcl @ Work Page 1 XOTcl @ Work Gustaf Neumann Uwe Zdun Department of Information Systems Specification of Software Systems Vienna University of Economics University of Essen Vienna, Austria Essen, Germany gustaf.neumann@wu-wien.ac.at uwe.zdun@uni-essen.de Second European Tcl/Tk User Meeting, June, 2001. Page 2 XOTcl @ Work June, 2001 What is XOTcl x XOTcl = Extended Object Tcl x \u201cHigh-level\u201d object-oriented programming x Advanced Component Glueing x XOTcl is freely available from: http://www.xotcl.org x Outline: \u2013 Scripting and object-orientation \u2013 Programming the \u201cbasic\u201d XOTcl Language \u2013 Component Glueing \u2013 XOTcl high-level language constructs \u2013 Some provided packages Gustaf Neumann, Uwe Zdun University of Essen Slide 1 Page 3 XOTcl @ Work June, 2001 Tcl-Strengths Important Ideas in Tcl: x Fast & high-quality development through component-based approach x 2 \u2026", "num_citations": "1\n", "authors": ["647"]}