{"title": "A comparison of context-oriented programming languages\n", "abstract": " Context-oriented programming (COP) extensions have been implemented for several languages. Each concrete language design and implementation comes with different variations of the features of the COP paradigm. In this paper, we provide a comparison of eleven COP implementations, discuss their designs, and evaluate their performance.", "num_citations": "169\n", "authors": ["1848"]}
{"title": "Immediacy through interactivity: online analysis of run-time behavior\n", "abstract": " Visualizations of actual run-time data support the comprehension of programs, like examples support the explanation of abstract concepts and principles. Unfortunately, the required run-time analysis is often associated with an inconvenient overhead that renders current tools impractical for frequent use. We propose an interactive approach to collect and present run-time data. An initial shallow analysis provides for immediate access to visualizations of run-time information. As users explore this information, it is incrementally refined on-demand. We present an implementation that realizes our proposed approach and enables developers to instantly explore run-time behavior of selected code entities. We evaluate our interactive approach by measuring time and memory overhead in the context of ten different-sized projects. Our empirical results show that run-time data for an initial overview can be collected in less\u00a0\u2026", "num_citations": "30\n", "authors": ["1848"]}
{"title": "Dynamic contract layers\n", "abstract": " Design by Contract (DBC) is a programming technique to separate contract enforcement from application code. DBC provides information about the applicability of methods and helps to narrow down the search space in case of a software failure. However, most DBC implementations suffer from inflexibility: Contract enforcement can only be activated or deactivated at compile-time or start-up, contracts are checked globally and cannot be restricted in their scope such as to the current thread of execution, and contracts cannot be grouped according to the concerns they relate to.", "num_citations": "28\n", "authors": ["1848"]}
{"title": "Test-driven fault navigation for debugging reproducible failures\n", "abstract": " We present test-driven fault navigation as an interconnected debugging guide that integrates spectrumbased anomalies and failure causes. By analyzing failure-reproducing test cases, we reveal suspicious system parts, developers most qualified for addressing localized faults, and erroneous behavior in the execution history. The Paths tool suite realizes our approach: PathMap supports a breadth first search for narrowing down failure causes and recommends developers for help; PathFinder is a lightweight back-in-time debugger that classifies failing test behavior for easily following infection chains back to defects. The evaluation of our approach illustrates the improvements for debugging test cases, the high accuracy of recommended developers, and the fast response times of our corresponding tool suite.", "num_citations": "23\n", "authors": ["1848"]}
{"title": "Type harvesting: a practical approach to obtaining typing information in dynamic programming languages\n", "abstract": " Dynamically typed programming languages are powerful tools for rapid software development. However, there are scenarios that would benefit from actual type information being available---eg, code generation and optimisation as well as program comprehension. Since code written in such languages usually makes little or no explicit assumptions about types, type inference is not particularly well suited to obtain the desired information. This paper introduces type harvesting, a practical approach to obtaining type information. It is based on stepwise code execution of the code in question, closely observing the types of entities in question. Type harvesting allows for exploiting unit tests to automatically obtain type information for a code base. The approach has been implemented in Squeak/Smalltalk. Its evaluation, using several complex applications, shows that type harvesting yields excellent results with high precision.", "num_citations": "20\n", "authors": ["1848"]}
{"title": "Explicit use-case representation in object-oriented programming languages\n", "abstract": " Use-cases are considered an integral part of most contemporary development processes since they describe a software system's expected behavior from the perspective of its prospective users. However, the presence of and traceability to use-cases is increasingly lost in later more code-centric development activities. Use-cases, being well-encapsulated at the level of requirements descriptions, eventually lead to crosscutting concerns in system design and source code. Tracing which parts of the system contribute to which use-cases is therefore hard and so limits understandability.", "num_citations": "19\n", "authors": ["1848"]}
{"title": "Debugging into examples\n", "abstract": " Enhancing and maintaining a complex software system requires detailed understanding of the underlying source code. Gaining this understanding by reading source code is difficult. Since software systems are inherently dynamic, it is complex and time consuming to imagine, for example, the effects of a method\u2019s source code at run-time. The inspection of software systems during execution, as encouraged by debugging tools, contributes to source code comprehension. Leveraged by test cases as entry points, we want to make it easy for developers to experience selected execution paths in their code by debugging into examples. We show how links between test cases and application code can be established by means of dynamic analysis while executing regular tests.", "num_citations": "16\n", "authors": ["1848"]}
{"title": "Test quality feedback improving effectivity and efficiency of unit testing\n", "abstract": " Writing unit tests for a software system enhances the confidence that a system works as expected. Since time pressure often prevents a complete testing of all application details developers need to know which new tests the system requires. Developers also need to know which existing tests take the most time and slow down the whole development process. Missing feedback about less tested functionality and reasons for long running test cases make it, however, harder to create a test suite that covers all important parts of a software system in a minimum of time. As a result a software system may be inadequately tested and developers may test less frequently. Our approach provides test quality feedback to guide developers in identifying missing tests and correcting low-quality tests. We provide developers with a tool that analyzes test suites with respect to their effectivity (e.g., missing tests) and efficiency (e.g., time\u00a0\u2026", "num_citations": "15\n", "authors": ["1848"]}
{"title": "Follow the path: Debugging tools for test-driven fault navigation\n", "abstract": " Debugging failing test cases, particularly the search for failure causes, is often a laborious and time-consuming activity. Standard debugging tools such as symbolic debuggers and test runners hardly facilitate developers during this task because they neither provide advice to failure causes nor back-in-time capabilities. In this paper, we present test-driven fault navigation as a debugging guide that integrates spectrum-based and state anomalies into execution histories in order to systematically trace failure causes back to defects. We describe and demonstrate our Path tools that implement our debugging method for the Squeak/Smalltalk development environment.", "num_citations": "9\n", "authors": ["1848"]}
{"title": "Follow the path: Debugging state anomalies along execution histories\n", "abstract": " To understand how observable failures come into being, back-in-time debuggers help developers by providing full access to past executions. However, such potentially large execution histories do not include any hints to failure causes. For that reason, developers are forced to ascertain unexpected state properties and wrong behavior completely on their own. Without deep program understanding, back-in-time debugging can end in countless and difficult questions about possible failure causes that consume a lot of time for following failures back to their root causes. In this paper, we present state navigation as a debugging guide that highlights unexpected state properties along execution histories. After deriving common object properties from the expected behavior of passing test cases, we generate likely invariants, compare them with the failing run, and map differences as state anomalies to the past execution\u00a0\u2026", "num_citations": "5\n", "authors": ["1848"]}
{"title": "Orca: A single-language web framework for collaborative development\n", "abstract": " In the last few years, the Web has been established as a platform for interactive applications. However, creating Web applications involves numerous challenges since the Web has been created to serve static content. In particular, the separation of the client- and the server-side, being only connected through the unidirectional Hypertext Transfer Protocol, forces developers to apply two programming languages including different libraries, conventions, and tools. Developers create expert knowledge by specializing on a few of all involved technologies. Consequently, the diverse knowledge of team members makes collaboration in Web development laboriously. We present the Orca framework that allows developers to work collaboratively on client-server applications in a single object-oriented programming language. Based on the Smalltalk programming language, full access to existing libraries, and a bidirectional\u00a0\u2026", "num_citations": "5\n", "authors": ["1848"]}
{"title": "Bringing back-in-time debugging down to the database\n", "abstract": " With back-in-time debuggers, developers can explore what happened before observable failures by following infection chains back to their root causes. While there are several such debuggers for object-oriented programming languages, we do not know of any back-in-time capabilities at the database-level. Thus, if failures are caused by SQL scripts or stored procedures, developers have difficulties in understanding their unexpected behavior. In this paper, we present an approach for bringing back-in-time debugging down to the SAP HANA in-memory database. Our TARDISP debugger allows developers to step queries backwards and inspecting the database at previous and arbitrary points in time. With the help of a SQL extension, we can express queries covering a period of execution time within a debugging session and handle large amounts of data with low overhead on performance and memory. The entire\u00a0\u2026", "num_citations": "4\n", "authors": ["1848"]}
{"title": "PhidgetLab: crossing the border from virtual to real-world objects\n", "abstract": " Teaching pupils the ideas behind objects in programming languages can be difficult since these concepts are mostly abstract and not comprehensible at first sight. Etoys as a visual programming environment counters such issues by introducing visible objects and simple tiles for programming them. However, all of these objects can only be experienced virtually on the screen. This paper presents PhidgetLab, a programming environment for electronic components (Phidgets) realised on top of the Etoys environment. PhidgetLab helps crossing the border from virtual to real-world objects. Pupils interact with tangible objects that are seamlessly connected to the digital world. PhidgetLab was evaluated in a case study with 22 pupils, following the principles of the Design Thinking methodology and comprised the realisation of five prototypes within a short period of time.", "num_citations": "4\n", "authors": ["1848"]}
{"title": "Constraining timing-dependent communication for debugging non-deterministic failures\n", "abstract": " Distributed applications are hard to debug because timing-dependent network communication is a source of non-deterministic behavior. Current approaches to debug non-deterministic failures include post-mortem debugging as well as record and replay. However, the first impairs system performance to gather data, whereas the latter requires developers to understand the timing-dependent communication at a lower level of abstraction than they develop on. In this paper, we present the Peek-At-Talk debugger for investigating nondeterministic failures with low overhead in a systematic, top-down method: first, we record network communication schedules with less performance overhead. Second, we detect anomalies in the network communication to help developers understand timing dependencies. Finally, we constrain subsequent communication in the live system to reliably reproduce failures and allow developers to inspect additional runtime data.", "num_citations": "3\n", "authors": ["1848"]}
{"title": "Trends and Concepts in the software industry\n", "abstract": " Clustering data in clusters with similar data characteristics allows for various performance improvements. When searching on sorted data, binary searches can be used over linear searches. Moreover, clustering often enables the database to skip large parts of the data without ever looking at it. However, finding a good clustering configuration is not trivial.", "num_citations": "3\n", "authors": ["1848"]}