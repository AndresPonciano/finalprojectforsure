{"title": "Abstract features in feature modeling\n", "abstract": " A software product line is a set of program variants, typically generated from a common code base. Feature models describe variability in product lines by documenting features and their valid combinations. In product-line engineering, we need to reason about variability and program variants for many different tasks. For example, given a feature model, we might want to determine the number of all valid feature combinations or compute specific feature combinations for testing. However, we found that contemporary reasoning approaches can only reason about feature combinations, not about program variants, because they do not take abstract features into account. Abstract features are features used to structure a feature model that, however, do not have any impact at implementation level. Using existing feature-model reasoning mechanisms for program variants leads to incorrect results. Hence, although abstract\u00a0\u2026", "num_citations": "181\n", "authors": ["1508"]}
{"title": "Explaining anomalies in feature models\n", "abstract": " The development of variable software, in general, and feature models, in particular, is an error-prone and time-consuming task. It gets increasingly more challenging with industrial-size models containing hundreds or thousands of features and constraints. Each change may lead to anomalies in the feature model such as making some features impossible to select. While the detection of anomalies is well-researched, giving explanations is still a challenge. Explanations must be as accurate and understandable as possible to support the developer in repairing the source of an error. We propose an efficient and generic algorithm for explaining different anomalies in feature models. Additionally, we achieve a benefit for the developer by computing short explanations expressed in a user-friendly manner and by emphasizing specific parts in explanations that are more likely to be the cause of an anomaly. We provide an\u00a0\u2026", "num_citations": "63\n", "authors": ["1508"]}
{"title": "Towards modular analysis of multi product lines\n", "abstract": " Software product-line engineering enables efficient development of tailor-made software by means of reusable artifacts. As practitioners increasingly develop software systems as product lines, there is a growing potential to reuse product lines in other product lines, which we refer to as multi product line. We identify challenges when developing multi product lines and propose interfaces for different levels of abstraction ranging from variability modeling to functional and non-functional properties. We argue that these interfaces ease the reuse of product lines and identify research questions that need to be solved toward modular analysis of multi product lines.", "num_citations": "37\n", "authors": ["1508"]}
{"title": "Product-Line Specification and Verification with Feature-Oriented Contracts\n", "abstract": " Variability is ubiquitous in today\u2019s software development. While techniques to efficiently implement software product lines are used for decades, verification techniques have been a hot research topic in the last years. We give an overview on how existing verification techniques were applied to product lines. Based on our insights, we overcome two shortcomings of previous research on product-line verification. First, we systematically investigate how contracts can be utilized for product-line specification. Our theoretical discussion and practical evaluation lead us to the notion of feature-oriented contracts. In particular, we found that behavioral subtyping applies to most, but not all featureoriented contracts. Second, we use these feature-oriented contracts to compare different verification techniques and strategies for the same product-line implementation and specification. We measured synergistic effects when using theorem proving and model checking for product-line verification in concert.", "num_citations": "35\n", "authors": ["1508"]}
{"title": "Product sampling for product lines: the scalability challenge [challenge proposal]\n", "abstract": " Quality assurance for product lines is often infeasible for each product separately. Instead, only a subset of all products (ie, a sample) is considered during testing such that at least the coverage of certain feature interactions is guaranteed. While pair-wise interaction sampling only covers all interactions between two features, its generalization to t-wise interaction sampling ensures coverage for all interactions among t features. However, sampling large product lines poses a challenge, as today's algorithms tend to run out of memory, do not terminate, or produce samples, which are too large to be tested. To initiate a community effort, we provide a set of large real-world feature models with up-to 19 thousand features, which are supposed to be sampled. The performance of sampling approaches is evaluated based on the CPU time and memory consumed to retrieve a sample, the sample size for a given coverage (ie\u00a0\u2026", "num_citations": "23\n", "authors": ["1508"]}
{"title": "Using decision rules for solving conflicts in extended feature models\n", "abstract": " Software Product Line Engineering has introduced feature modeling as a domain analysis technique used to represent the variability of software products and decision-making scenarios. We present a model-based transformation approach to solve conflicts among configurations performed by different stakeholders on feature models. We propose the usage of a domain-specific language named CoCo to specify attributes as non-functional properties of features, and to describe business-related decision rules in terms of costs, time, and human resources. These specifications along with the stakeholders' configurations and the feature model are transformed into a constraint programming problem, on which decision rules are executed to find a non-conflicting set of solution configurations that are aligned to business objectives. We evaluate CoCo's compositionality and model complexity simplification while using a set\u00a0\u2026", "num_citations": "23\n", "authors": ["1508"]}
{"title": "Clean your variable code with featureIDE\n", "abstract": " FeatureIDE is an open-source framework to model, develop, and analyze feature-oriented software product lines. It is mainly developed in a cooperation between TU Braunschweig, University of Magdeburg, and Metop GmbH. Nevertheless, many other institutions contributed to it in the past decade. Goal of this tutorial is to illustrate how FeatureIDE can be used to clean variable code, whereas we will focus on dependencies in feature models and on variability implemented with preprocessors. The hands-on tutorial will be highly interactive and is devoted to practitioners facing problems with variability, lecturers teaching product lines, and researchers who want to save resources in building product-line tools based on the FeatureIDE infrastructure.", "num_citations": "11\n", "authors": ["1508"]}
{"title": "A machine-checked proof for a product-line\u2013aware type system\n", "abstract": " A software product line is a set of software-intensive systems that share a common code base. Program variants are generated using a feature selection, where only the code for the selected features is generated. Since the number of program variants grows exponentially with the number of features, we cannot type-check each variant on its own. Recently, product-line\u2013aware type systems were proposed to efficiently type-check the software product line. Type soundness proofs show that no ill-typed program variants can be generated from a well-typed product line. We present a formal type soundness proof for Colored Featherweight Java in Coq. Furthermore, we present a simplified type system for Colored Featherweight Java and share our experiences with machine-checked proofs using the proof assistant Coq. Acknowledgements I would like to thank Christian K\u00e4stner for the perfect assistance throughout the last three years. We had many productive discussions that I would not want to miss. His careful reading of my drafts and his critical view substantially helped to improve this thesis. Many thanks to J\u00fcrgen Dassow who supported me in mathematical issues. He also", "num_citations": "10\n", "authors": ["1508"]}
{"title": "Reasoning about feature model edits\n", "abstract": " Feature models are a well accepted means for expressing requirements in a domain on an abstract level. They are applied to describe variable and common properties of products in a software product line, and to derive and validate configurations of software systems. Their industrial importance is increasing rapidly [Rie03].", "num_citations": "8\n", "authors": ["1508"]}
{"title": "Experience report on formally verifying parts of openJDK\u2019s API with KeY\n", "abstract": " Deductive verification of software has not yet found its way into industry, as complexity and scalability issues require highly specialized experts. The long-term perspective is, however, to develop verification tools aiding industrial software developers to find bugs or bottlenecks in software systems faster and more easily. The KeY project constitutes a framework for specifying and verifying software systems, aiming at making formal verification tools applicable for mainstream software development. To help the developers of KeY, its users, and the deductive verification community, we summarize our experiences with KeY 2.6.1 in specifying and verifying real-world Java code from a users perspective. To this end, we concentrate on parts of the Collections-API of OpenJDK 6, where an informal specification exists. While we describe how we bridged informal and formal specification, we also exhibit accompanied challenges that we encountered. Our experiences are that (a) in principle, deductive verification for API-like code bases is feasible, but requires high expertise, (b) developing formal specifications for existing code bases is still notoriously hard, and (c) the under-specification of certain language constructs in Java is challenging for tool builders. Our initial effort in specifying parts of OpenJDK 6 constitutes a stepping stone towards a case study for future research.", "num_citations": "6\n", "authors": ["1508"]}
{"title": "Analysis Strategies for Software Product Lines: A Classification and Survey.\n", "abstract": " Software-product-line engineering enables the efficient development of similar software products. Instead of developing each product from scratch, products are generated from common artifacts. However, the product generation is a challenge for the analysis of correctness properties. Applying traditional analysis techniques, such as type checking and model checking, to each product involves redundant effort and is often not feasible due to the combinatorial explosion of products. Approaches to scale analysis techniques to product lines have been presented in unrelated research", "num_citations": "6\n", "authors": ["1508"]}
{"title": "A BDD for Linux? the knowledge compilation challenge for variability\n", "abstract": " What is the number of valid configurations for Linux? How to generate uniform random samples for Linux? Can we create a binary decision diagram for Linux? It seems that the product-line community tries hard to answer such questions for Linux and other configurable systems. However, attempts are often not published due to the publication bias (ie, unsuccessful attempts are not published). As a consequence, researchers keep trying by potentially spending redundant effort. The goal of this challenge is to guide research on these computationally complex problems and to foster the exchange between researchers and practitioners.", "num_citations": "5\n", "authors": ["1508"]}
{"title": "On the use of product-line variants as experimental subjects for clone-and-own research: a case study\n", "abstract": " Software is often released in multiple variants to address the needs of different customers or application scenarios. One frequent approach to create new variants is clone-and-own, whose systematic support has gained considerable research interest in the last decade. However, only few techniques have been evaluated in a realistic setting, due to a substantial lack of publicly available clone-and-own projects which could be used as experimental subjects. Instead, many studies use variants generated from software product lines for their evaluation. Unfortunately, the results might be biased, because variants generated from a single code base lack unintentional divergences that would have been introduced by clone-and-own. In this paper, we report about ongoing work towards a more systematic investigation of threats to the external validity of such experimental results. Using n-way model matching as a\u00a0\u2026", "num_citations": "5\n", "authors": ["1508"]}
{"title": "Product Configuration in the Wild: Strategies for Conflicting Decisions in Web Configurators\n", "abstract": " Customization is omnipresent in our everyday live. There are web configurators to customize cars, trucks, bikes, computers, clothes, furniture, and food. At first glance, customization using configurators appears trivial; we simply select the configuration options that we want. However, in practice, options are usually dependent on each other. Reasons for dependencies are manifold and are typically specific for the particular domain. Dependencies can be simple, such as one option requiring or excluding another option, but also arbitrarily complex, involving numerous options. In this study, we aim to understand how today\u2019s web configurators support users in their decision making process. In particular, we are interested in understanding how configurators handle decisions that are in conflict with dependencies. To abstract from different visualizations, we classify the existing strategies of web configurators and discuss advantages and disadvantages of them. While we identified eight strategies, a single configurator typically uses several of those strategies.", "num_citations": "5\n", "authors": ["1508"]}
{"title": "Yet another textual variability language? a community effort towards a unified language\n", "abstract": " Variability models are commonly used to model commonalities and variability in a product line. There is a large variety of textual formats to represent and store variability models. This variety causes overhead to researchers and practitioners as they frequently need to translate models. The MODEVAR initiative consists of dozens of researchers and aims to find a unified language for variability modeling. In this work, we describe the cooperative development of a textual variability language. We evaluate preferences of the community regarding properties of existing formats and applications for an initial design of a unified variability language. Then, we examine the acceptance of the community for our proposal. The results indicate that our proposal is a promising start towards a unified variability language instead of yet another language. We envision that the community applies our language proposal in teaching\u00a0\u2026", "num_citations": "4\n", "authors": ["1508"]}
{"title": "Product-line verification with feature-oriented contracts\n", "abstract": " Software product lines allow programmers to reuse code across similar software products. Software products are decomposed into separate modules representing user-visible features. Based on a selection of desired features, a customized software product can be generated automatically. However, these reuse mechanisms challenge existing techniques for specification and verification of software. Specifying and verifying each product involves redundant steps, and is often infeasible. We discuss how method contracts (ie, preconditions and postconditions) can be used to efficiently specify and verify product lines.", "num_citations": "4\n", "authors": ["1508"]}
{"title": "Feature Modeling and Development with FeatureIDE\n", "abstract": " FeatureIDE is an open-source framework to model, develop, and analyze feature-oriented software product lines. It is mainly developed in a cooperation between TU Braunschweig, University of Magdeburg, and Metop GmbH. Nevertheless, many other institutions contributed to it in the past decade. Goal of this tutorial is to illustrate how FeatureIDE can be used to develop software around end-user features. We will show how feature models are connected to and synchronized with other artifacts. The hands-on tutorial will be highly interactive and is devoted to practitioners facing problems with variability, lecturers teaching product lines, and researchers who want to safe resources in building product-line tools.", "num_citations": "3\n", "authors": ["1508"]}
{"title": "Verification of software product lines using contracts\n", "abstract": " Software product lines are widely used to achieve high reuse of code artifacts for similar software products. While there are many efficient techniques to implement product lines, such as feature-oriented programming, the analysis and verification of product lines got only little attention so far. But as product lines are increasingly used in safety critical scenarios, efficient verification techniques are indispensable. We give an overview on the state-of-the-art in product-line verification, in which we classify approaches according to their strategy to scale specification and verification approaches known from single-system engineering. We propose to use contracts (ie, preconditions and postconditions) to specify the intended behavior of a product line implemented with featureoriented programming. Based on these contracts, we discuss different approaches to verify that all products of a product line fulfill its specification.", "num_citations": "3\n", "authors": ["1508"]}
{"title": "Variational satisfiability solving\n", "abstract": " Incremental satisfiability (SAT) solving is an extension of classic SAT solving that allows users to efficiently solve a set of related SAT problems by identifying and exploiting shared terms. However, using incremental solvers effectively is hard since performance is sensitive to a problem's structure and the order sub-terms are fed to the solver, and the burden to track results is placed on the end user. For analyses that generate sets of related SAT problems, such as those in software product lines, incremental SAT solvers are either not used at all, used but not explicitly stated so in the literature, or used but suffer from the aforementioned usability problems. This paper translates the ordering problem to an encoding problem and automates the use of incremental SAT solving. We introduce variational SAT solving, which differs from incremental SAT solving by accepting all related problems as a single variational input and\u00a0\u2026", "num_citations": "2\n", "authors": ["1508"]}
{"title": "Feature trace recording\n", "abstract": " Tracing requirements to their implementation is crucial to all stakeholders of a software development process. When managing software variability, requirements are typically expressed in terms of features, a feature being a user-visible characteristic of the software. While feature traces are fully documented in software product lines, ad-hoc branching and forking, known as clone-and-own, is still the dominant way for developing multi-variant software systems in practice. Retroactive migration to product lines suffers from uncertainties and high effort because knowledge of feature traces must be recovered but is scattered across teams or even lost. We propose a semi-automated methodology for recording feature traces proactively, during software development when the necessary knowledge is present. To support the ongoing development of previously unmanaged clone-and-own projects, we explicitly deal with the\u00a0\u2026", "num_citations": "1\n", "authors": ["1508"]}
{"title": "Bridging the gap between clone-and-own and software product lines\n", "abstract": " Software is often released in multiple variants to meet all customer requirements. While software product lines address this need by advocating the development of an integrated software platform, practitioners frequently rely on adhoc reuse based on a principle which is known as clone-and-own. This practice avoids high up-front investments, as new variants of a software family are created by simply copying and adapting an existing variant, but maintenance costs explode once a critical number of variants is reached. With our research project VariantSync, we aim to bridge the gap between clone-and-own and product lines by combining the minimal overhead and flexibility of clone-and-own with the systematic handling of variability in software product lines. The key idea is to transparently integrate product-line concepts with variant management facilities known from version control systems in order to automatically\u00a0\u2026", "num_citations": "1\n", "authors": ["1508"]}