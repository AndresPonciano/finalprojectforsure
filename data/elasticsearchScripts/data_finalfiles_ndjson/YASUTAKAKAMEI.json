{"title": "The effects of over and under sampling on fault-prone module detection\n", "abstract": " The goal of this paper is to improve the prediction performance of fault-prone module prediction models (fault-proneness models) by employing over/under sampling methods, which are preprocessing procedures for a fit dataset. The sampling methods are expected to improve prediction performance when the fit dataset is unbalanced, i.e. there exists a large difference between the number of fault-prone modules and not-fault-prone modules. So far, there has been no research reporting the effects of applying sampling methods to fault-proneness models. In this paper, we experimentally evaluated the effects of four sampling methods (random over sampling, synthetic minority over sampling, random under sampling and one-sided selection) applied to four fault-proneness models (linear discriminant analysis, logistic regression analysis, neural network and classification tree) by using two module sets of industry\u00a0\u2026", "num_citations": "156\n", "authors": ["199"]}
{"title": "An analysis of developer metrics for fault prediction\n", "abstract": " Background: Software product metrics have been widely used as independent variables for constructing a fault prediction model. However, fault injection depends not only on characteristics of the products themselves, but also on characteristics of developers involved in the project. Aims: The goal of this paper is to study the effects of developer features on software reliability. Method: This paper proposes developer metrics such as the number of code churns made by each developer, the number of commitments made by each developer and the number of developers for each module. By using the eclipse project dataset, we experimentally analyzed the relationship between the number of faults and developer metrics. Second, the effective of developer metrics for performance improvements of fault prediction models were evaluated. Results: The result revealed that the modules touched by more developer contained\u00a0\u2026", "num_citations": "107\n", "authors": ["199"]}
{"title": "Shinobi: A tool for automatic code clone detection in the ide\n", "abstract": " Recent research has acknowledged that code clones decrease the maintainability and reliability of software programs, thus it is being regarded as one of the major factors to increase development/maintenance cost. We introduce SHINOBI, a novel code clone detection/modification tool that is designed to aid in recognizing and highlighting code clones during software maintenance tasks. SHINOBI is implemented as an add-in of Microsoft Visual Studio that automatically reports clones of modified snippets in real time.", "num_citations": "71\n", "authors": ["199"]}
{"title": "DeepJIT: an end-to-end deep learning framework for just-in-time defect prediction\n", "abstract": " Software quality assurance efforts often focus on identifying defective code. To find likely defective code early, change-level defect prediction - aka. Just-In-Time (JIT) defect prediction - has been proposed. JIT defect prediction models identify likely defective changes and they are trained using machine learning techniques with the assumption that historical changes are similar to future ones. Most existing JIT defect prediction approaches make use of manually engineered features. Unlike those approaches, in this paper, we propose an end-to-end deep learning framework, named DeepJIT, that automatically extracts features from commit messages and code changes and use them to identify defects. Experiments on two popular software projects (i.e., QT and OPENSTACK) on three evaluation settings (i.e., cross-validation, short-period, and long-period) show that the best variant of DeepJIT (DeepJIT-Combined\u00a0\u2026", "num_citations": "51\n", "authors": ["199"]}
{"title": "Social network analysis on communications for knowledge collaboration in oss communities\n", "abstract": " Knowledge collaboration is the key for success of open source software (OSS) communities, because not all members have knowledge and skills necessary for software development. Generally, members in OSS communities communicate for knowledge collaboration using communication tools (eg mailing lists, discussion forums, bug tracking systems, and so on) so that geographically distributed members collaborate and coordinate their work. In this paper, we apply social network analysis to the data accumulated in communication tools. We analyzed relationships between the density of social networks and OSS releases by time series analysis of 4 OSS communities in Source-Forge. net, in order to investigate the quality of communications for knowledge collaboration. The analysis results showed that communications among community members with a variety of roles are active before/after OSS release in communities where knowledge collaboration is going well.", "num_citations": "36\n", "authors": ["199"]}
{"title": "Comparison of outlier detection methods in fault-proneness models\n", "abstract": " In this paper, we experimentally evaluated the effect of outlier detection methods to improve the prediction performance of fault-proneness models. Detected outliers were removed from a fit dataset before building a model. In the experiment, we compared three outlier detection methods (Mahalanobis outlier analysis (MOA), local outlier factor method (LOFM) and rule based modeling (RBM)) each applied to three well-known fault-proneness models (linear discriminant analysis (LDA), logistic regression analysis (LRA) and classification tree (CT)). As a result, MOA and RBM improved Fl-values of all models (0.04 at minimum, 0.17 at maximum and 0.10 at mean) while improvements by LOFM were relatively small (-0.01 at minimum, 0.04 at maximum and 0.01 at mean).", "num_citations": "32\n", "authors": ["199"]}
{"title": "Investigating the effects of balanced training and testing datasets on effort-aware fault prediction models\n", "abstract": " To prioritize software quality assurance efforts, fault prediction models have been proposed to distinguish faulty modules from clean modules. The performances of such models are often biased due to the skewness or class imbalance of the datasets considered. To improve the prediction performance of these models, sampling techniques have been employed to rebalance the distribution of fault-prone and non-fault-prone modules. The effect of these techniques have been evaluated in terms of accuracy/geometric mean/F1-measure in previous studies; however, these measures do not consider the effort needed to fix faults. To empirically investigate the effect of sampling techniques on the performance of software fault prediction models in a more realistic setting, this study employs Norm(P opt ), an effort-aware measure that considers the testing effort. We performed two sets of experiments aimed at (1) assessing\u00a0\u2026", "num_citations": "30\n", "authors": ["199"]}
{"title": "SHINOBI: A real-time code clone detection tool for software maintenance\n", "abstract": " Recent research describes how code clones in source code decrease reliability of the program and require more development cost. To solve the problem, several code clone detection methods and tools have been implemented. In this paper, we propose a novel code clone detection/modification tool to support the software maintenance process. The proposed tool, SHINOBI, indicates code clones in source code immediately by real-time clone detection. The results of an evaluation experiment showed the system had sufficient performance to support programmers in a large-scale maintenance project.", "num_citations": "28\n", "authors": ["199"]}
{"title": "Empirical evaluation of cross-release effort-aware defect prediction models\n", "abstract": " To prioritize quality assurance efforts, various fault prediction models have been proposed. However, the best performing fault prediction model is unknown due to three major drawbacks: (1) comparison of few fault prediction models considering small number of data sets, (2) use of evaluation measures that ignore testing efforts and (3) use of n-fold cross-validation instead of the more practical cross-release validation. To address these concerns, we conducted cross-release evaluation of 11 fault density prediction models using data sets collected from 2 releases of 25 open source software projects with an effort-aware performance measure known as Norm(P opt ). Our result shows that, whilst M5 and K* had the best performances, they were greatly influenced by the percentage of faulty modules present and size of data set. Using Norm(P opt ) produced an overall average performance of more than 50% across all\u00a0\u2026", "num_citations": "26\n", "authors": ["199"]}
{"title": "Empirical evaluation of svm-based software reliability model\n", "abstract": " Support Vector Machines (SVMs) are known as some of the best learning models for pattern recognition, and an SVM can be used as a software reliability model to predict fault-prone modules from complexity metrics. We experimentally evaluated the prediction performance of an SVM model, comparing it with commonlyused conventional models including linear discriminant analysis, logistic regression, a classification tree, and a neural network. The results revealed that the SVM model exhibited showed the best performance among all the models tested.", "num_citations": "26\n", "authors": ["199"]}
{"title": "Analysis of coordination between developers and users in the apache community\n", "abstract": " Coordination is one of the keys for the success of open source software (OSS) communities because geographically distributed members need to collaborate on their work using communication tools (e.g., mailing lists, bulletin board systems, bug tracking systems, and so on). In this paper, we investigated the informal social structure among developers and users by analyzing two mailing lists of developers and users in the Apache community based on betweenness centrality, one centrality measure proposed by Freeman. From the analysis results, we found that (1) participants with high betweenness coordinated activities between developers and users and (2) some participants have been functioning as coordinators in the community for a long time.", "num_citations": "25\n", "authors": ["199"]}
{"title": "Bridging semantic gaps between natural languages and apis with word embedding\n", "abstract": " Developers increasingly rely on text matching tools to analyze the relation between natural language words and APIs. However, semantic gaps, namely textual mismatches between words and APIs, negatively affect these tools. Previous studies have transformed words or APIs into low-dimensional vectors for matching; however, inaccurate results were obtained due to the failure of modeling words and APIs simultaneously. To resolve this problem, two main challenges are to be addressed: the acquisition of massive words and APIs for mining and the alignment of words and APIs for modeling. Therefore, this study proposes Word2API to effectively estimate relatedness of words and APIs. Word2API collects millions of commonly used words and APIs from code repositories to address the acquisition challenge. Then, a shuffling strategy is used to transform related words and APIs into tuples to address the alignment\u00a0\u2026", "num_citations": "21\n", "authors": ["199"]}
{"title": "Analyzing OSS developers' working time using mailing lists archives\n", "abstract": " We used mailing lists (MLs) archives of PostgreSQL, downloaded from http://www. postgresql. org/community/lists/. The MLs mainly consist of user lists and developer lists. We used developer lists archive since we needed developers\u2019 working time. Table 1 explains details of each ML. Figure 1 shows amounts of messages of each ML in the developer lists. Amounts of messages were increasing year by year. The ML of hackers had many more messages than other MLs. We extracted MLs archives till December 2005. Note that most of committers\u2019 messages were automatically generated when source code was checked into software configuration management repository.", "num_citations": "20\n", "authors": ["199"]}
{"title": "An empirical study of fault prediction with code clone metrics\n", "abstract": " In this paper, we present a replicated study to predict fault-prone modules with code clone metrics to follow Baba's experiment. We empirically evaluated the performance of fault prediction models with clone metrics using 3 datasets from the Eclipse project and compared it to fault prediction without clone metrics. Contrary to the original Baba's experiment, we could not significantly support the effect of clone metrics, i.e., the result showed that F1-measure of fault prediction was not improved by adding clone metrics to the prediction model. To explain this result, this paper analyzed the relationship between clone metrics and fault density. The result suggested that clone metrics were effective in fault prediction for large modules but not for small modules.", "num_citations": "14\n", "authors": ["199"]}
{"title": "A context analysis method for embedded systems\u2014Exploring a requirement boundary between a system and its context\n", "abstract": " Many embedded systems not only affect their context through actuators but also are affected by the context through sensors. It is important to provide a context-dependent development method for constructing safe and reliable embedded systems. However, most of the current requirements analysis methods do not explicitly provide a systematic way for deciding the boundary of the context that should be taken into account because it is essentially difficult to decide which context element should be included as the targets of requirements analysis. If a developer explores the context boundary in an ad-hoc manner, he or she will be faced with the frame problem because there are unlimited context elements in the real world where the target system exists. To deal with this problem, this paper proposes a context-dependent requirements analysis method called CAMEmb (Context Analysis Method for Embedded systems\u00a0\u2026", "num_citations": "13\n", "authors": ["199"]}
{"title": "Using alloy to support feature-based DSL construction for mining software repositories\n", "abstract": " The Mining Software Repositories (MSR) field reveals knowledge for software development by analyzing data stored in repositories such as source control and bug trace systems. In order to reveal the knowledge, MSR researchers need to perform complicated procedures iteratively. To help the complex work of MSR practitioners, we study the construction of domain specific languages (DSLs) for MSR. We have conducted feature-oriented domain analysis (FODA) on MSR and developed a DSL based on the feature model. In this paper, we expand our previous work and propose to construct not a single DSL but a DSL family. A DSL family consists of a series of DSLs with commonality in their domain but suitable to specific applications of MSR. To readily construct these DSLs, we use Alloy to encode the feature model. Our encoding includes not only the DSL features and their relations but also some composition\u00a0\u2026", "num_citations": "12\n", "authors": ["199"]}
{"title": "Modularity for uncertainty\n", "abstract": " Uncertainty can appear in all aspects of software development: uncertainty in requirements analysis, design decisions, implementation, and testing. As the research on uncertainty is so young, there are many issues to be tackled. Modularity for Uncertainty is one of them. If uncertainty can be dealt with modularly, we can add or delete uncertain concerns to/from models, code, and tests whenever these concerns arise or are fixed to certain concerns. To deal with this challenging issue, we propose a modularization mechanism for uncertainty. Agile methods embrace change to accept changeable user requirements. On the other hand, our approach embraces uncertainty to support exploratory development. This paper sets out a focused research agenda for uncertainty in terms of the new modularity vision.", "num_citations": "11\n", "authors": ["199"]}
{"title": "Abstraction-aware verifying compiler for yet another MDD\n", "abstract": " This paper rethinks both modularity and compilation in the light of abstraction between design and implementation. We propose a new compilation approach called abstraction-aware verifying compiler, in which abstraction is the target of compilation. Both a design model and its code are inputted as the first-class software modules to the compiler.", "num_citations": "11\n", "authors": ["199"]}
{"title": "Using software birthmarks to identify similar classes and major functionalities\n", "abstract": " Software birthmarks are unique and native characteristics of every software component. Two components having similar birthmarks indicate that they are similar in functionality, structure and im-plementation. Questions addressed in this paper include: Which are similar class files? Can they be gathered into one class file? What are major functionalities among class files? To answer to these questions, this paper analyzed the similarity of birthmarks for all pairs of classes in ArgoUML, and visualized them using Multi-Dimensional Scaling (MDS). As a result, three pairs of very similar class files, which seem to be made by copy-and-paste programming, were identified. Also, four major functionalities were identified in the MDS space.", "num_citations": "11\n", "authors": ["199"]}
{"title": "Architectural point mapping for design traceability\n", "abstract": " AOP can be applied to not only modularization of crosscutting concerns but also other kinds of software development processes. As one of the applications, this paper proposes a design traceability mechanism originating in join points and pointcuts. It is not easy to design software architecture reflecting the intention of developers and implement the result of design as a program while preserving the architectural correctness. To deal with this problem, we propose two novel ideas: Archpoint (Architectural point) and Archmapping (Archpoint Mapping). Archpoints are points for representing the essence of architectural design in terms of behavioral and structural aspects. By defining a set of archpoints, we can describe the inter-component structure and the message interaction among components. Archmapping is a mechanism for checking the bidirectional traceability between design and code. The traceability can be\u00a0\u2026", "num_citations": "10\n", "authors": ["199"]}
{"title": "A review and comparison of methods for determining the best analogies in analogy-based software effort estimation\n", "abstract": " Analogy-based effort estimation (ABE) is a commonly used software development effort estimation method. The processes of ABE are based on a reuse of effort values from similar past projects, where the appropriate numbers of past projects (k values) to be reused is one of the long-standing debates in ABE research studies. To date, many approaches to find this k value have been continually proposed. One important reason for this inconclusive debate is that different studies appear to produce different conclusions of the k value to be appropriate. Therefore, in this study, we revisit 8 common approaches to the k value being most appropriate in general situations. With a more robust and comprehensive evaluation methodology using 5 robust error measures subject to the Wilcoxon rank-sum statistical test, we found that conicting results in the previous studies were not mainly due to the use of different\u00a0\u2026", "num_citations": "9\n", "authors": ["199"]}
{"title": "Assessing the differences of clone detection methods used in the fault-prone module prediction\n", "abstract": " We have investigated through several experiments the differences in the fault-prone module prediction accuracy caused by the differences in the constituent code clone metrics of the prediction model. In the previous studies, they use one or more code clone metrics as independent variables to build an accurate prediction model. While they often use the clone detection method proposed by Kamiya et al. to calculate these metrics, the effect of the detection method on the prediction accuracy is not clear. In the experiment, we built prediction models using a dataset collected from an open source software project. The result suggests that the prediction accuracy is improved, when clone metrics derived from the various clone detection tool are used.", "num_citations": "9\n", "authors": ["199"]}
{"title": "Using search-based metric selection and oversampling to predict fault prone modules\n", "abstract": " Predictive models can be used in the detection of fault prone modules using source code metrics as inputs for the classifier. However, there exist numerous structural measures that capture different aspects of size, coupling and complexity. Identifying a metric subset that enhances the performance for the predictive objective would not only improve the model but also provide insights into the structural properties that lead to problematic modules. Another difficulty in building predictive models comes from unbalanced datasets, which are common in empirical software engineering as a majority of the modules are not likely to be faulty. Oversampling attempts to overcome this deficiency by generating new training instances from the faulty modules. We present the results of applying search-based metric selection and oversampling to three NASA datasets. For these datasets, oversampling results in the largest\u00a0\u2026", "num_citations": "9\n", "authors": ["199"]}
{"title": "iArch-U: interface-centric integrated uncertainty-aware development environment\n", "abstract": " Uncertainty can appear in all aspects of software development: uncertainty in requirements analysis, design decisions, implementation and testing. If uncertainty can be dealt with modularly, we can add or delete uncertain concerns to/from models, code and tests whenever these concerns arise or are fixed to certain concerns. To deal with this problem, we developed iArch-U, an IDE (Integrated Development Environment) for managing uncertainty modularly in all phases in software development. In this paper, we introduce an overview of iArch-U. The iArch-U IDE is open source software and can be downloaded from GitHub.", "num_citations": "7\n", "authors": ["199"]}
{"title": "Industry application of software development task measurement system: TaskPit\n", "abstract": " To identify problems in a software development process, we have been developing an automated measurement tool called TaskPit, which monitors software development tasks such as programming, testing and documentation based on the execution history of software applications. This paper introduces the system requirements, design and implementation of TaskPit; then, presents two real-world case studies applying TaskPit to actual software development. In the first case study, we applied TaskPit to 12 software developers in a certain software development division. As a result, several concerns (to be improved) have been revealed such as (a) a project leader spent too much time on development tasks while he was supposed to be a manager rather than a developer, (b) several developers rarely used e-mails despite the company's instruction to use e-mail as much as possible to leave communication records\u00a0\u2026", "num_citations": "7\n", "authors": ["199"]}
{"title": "Design module: A modularity vision beyond code: Not only program code but also a design model is a module\n", "abstract": " We propose a new modularity vision to integrate design modeling with programming. A system consists of not only program code but also design models. However, design models such as UML diagrams have been treated as not modules but complementary documents. This paper provides a novel idea that treats a design model as a first-class software module termed design module. A system cannot be complied without design modules. A developer has to create and modify not only program modules but also design modules. To realize design modules, we introduce Archface, an architectural interface mechanism. Archface exposes architectural points shared between design and code. Archface plays a role as a design interface for a design module and as a program interface for a program module. Arch-face type system automatically checks the consistency between design and code. Our approach can integrate\u00a0\u2026", "num_citations": "7\n", "authors": ["199"]}
{"title": "A comparison study on the coordination between developers and users in FOSS communities\n", "abstract": " Recent studies have been trying to better understand geographically distributed software development which is increasing from year to year. Analyzing Free/Open Source Software (FOSS) communities would help us obtain useful insights for distributed software development, because some FOSS communities already have tremendous success in a distributed environment. Our prior study analyzed an informal social structure in the Apache community. In this paper, we describe a comparison study which analyzes informal social structures in the Apache community and the Netscape community, with a focus on participants who belong to both developer and user groups and who assist the collaboration between them. We perform a static analysis for looking at an informal social structure in a single period and a dynamic analysis for observing the transition of the structure over time. As a result, we have found that one of the key factors for the success of distributed software development such as FOSS development was the existence of highly motivated participants who help developers and users collaborate closely with each other.", "num_citations": "7\n", "authors": ["199"]}
{"title": "Poster: Conquering Uncertainty in Java Programming\n", "abstract": " Uncertainty in programming is one of the challenging issues to be tackled, because it is error-prone for many programmers to temporally avoid uncertain concerns only using simple language constructs such as comments and conditional statements. This paper proposes ucJava, a new Java programming environment for conquering uncertainty. Our environment provides a modular programming style for uncertainty and supports test-driven development taking uncertainty into consideration.", "num_citations": "6\n", "authors": ["199"]}
{"title": "UML4COP: UML-based DSML for context-aware systems\n", "abstract": " Context-awareness plays an important role in developing flexible and adaptive systems. However, it is not easy to design and implement such a context-aware system, because its system configuration can be dynamically changed. This paper proposes UML4COP, a UML-based design method for COP (Context-Oriented Programming). UML4COP is a DSML (Domain-Specific Modeling Language) for designing context-aware systems. In UML4COP, each context is modeled separately and a system design model at a certain period of time is composed by merging associated contexts.", "num_citations": "6\n", "authors": ["199"]}
{"title": "Translation pattern of BPEL process into Promela code\n", "abstract": " To verify behavioral specification of compound Web services, this paper introduces to apply model checking to Web services flows described by BPEL. Model checking is a formal method to formalize the behavior of designed system as an automaton and to analyze automatically whether or not the automaton satisfies the specification. This paper introduces translation pattern to convert a BPEL process to Promela code (Process or Protocol Meta Language), which is a verification modeling language in SPIN model checker. The result of our case study using a parking navigation service shows that our translation pattern can automatically verify the specification except Exception handling pattern and Event handling pattern.", "num_citations": "6\n", "authors": ["199"]}
{"title": "Temporal changes of the openness of an OSS community: A case study of the apache http server community\n", "abstract": " The development style of open source software (OSS) is widely recognized as \u201cbazaar-like\u201d software development [1]. In \u201cbazaar-like\u201d software development, there is openness to anyone who wants to participate in a community. Participants including not only developers but also users share, discuss, and implement a variety of ideas with each other, and then release OSS products to the public. Certain products (eg Linux, Apache) developed by \u201cbazaar-like\u201d software development are widely used in our daily life. However, at the same time, a larger number of OSS products and communities following the \u201cbazaar-like\u201d style result in failure or stagnation due to various factors [2]. This implies that \u201cbazaar\u201d style of software development might not be a critical success factor of OSS products and communities. If so, how could certain products and communities achieve great success and survive in a free competitive market for more than a decade? Our study is motivated to answer this question.", "num_citations": "6\n", "authors": ["199"]}
{"title": "Automated dsl construction based on software product lines\n", "abstract": " DSL (Domain-Specific Language) is one of the important approaches for software abstraction. In the past decades, DSLs have been provided by expert engineers familiar with domain knowledge and programming language processors. It is not easy for ordinary programmers to construct DSLs for their own purposes. To deal with this problem, we propose a language workbench called Argyle that can automatically generate a DSL by only specifying a set of functions needed to the DSL and an execution platform supported by the DSL. Argyle is based on software product lines and consists of the following two steps: 1) development of the core assets for constructing a family of DSLs and 2) DSL configuration using these core assets. To demonstrate the effectiveness of our approach, we developed a prototype DSL for supporting MSR (Mining Software Repositories), the most active research field in software engineering.", "num_citations": "5\n", "authors": ["199"]}
{"title": "An over-sampling method for analogy-based software effort estimation\n", "abstract": " This paper proposes a novel method to generate synthetic projectcases and add them to a fit dataset for the purpose of improving the performance of analogy-based software effort estimation. The proposed method extends conventional over-sampling method, which is a preprocessing procedure for n-group classification problems, which makes it suitable for any imbalanced dataset to be used in analogy-based system. We experimentally evaluated the effect of the over-sampling method to improve the performance of the analogy-based software effort estimation by using the Desharnais dataset. Results show significant improvement to the estimation accuracy by using our approach.", "num_citations": "5\n", "authors": ["199"]}
{"title": "Empirical study on the relationship between developer's working habits and efficiency\n", "abstract": " Software developers can have a reputation for frequently working long and irregular hours which are widely considered to inhibit mental capacity and negatively affect work quality. This paper analyzes the working habits of software developers and the effects these habits have on efciency based on a large amount of data extracted from the actions of developers in the IDE (Integrated Development Environment), Visual Studio. We use events that recorded the times at which all developer actions were performed along with the numbers of successful and failed build and test events. Due to the high level of detail of the events provided by KaVE project's tool, we were able to analyze the data in a way that previous studies have not been able to. We structure our study along three dimensions: (1) days of the week, (2) time of the day, and (3) continuous work. Our findings will help software developers and team leaders to\u00a0\u2026", "num_citations": "4\n", "authors": ["199"]}
{"title": "Can Abstraction Be Taught? Refactoring-based Abstraction Learning.\n", "abstract": " Can the notion of abstraction be taught to students? It is a very difficult question. Abstraction plays an important role in software development. This paper shows that refactoring is effective for students to learn the notion of abstraction. We focus on design abstraction, because it is one of the crucial parts in teaching the essence of software engineering. To explore for a well-balanced separation of concerns between design and code, it is not avoidable to go back and forth between them. To help a student find an appropriate abstraction level, we introduce abstraction-aware refactoring patterns consisting of MoveM2C (Move concerns from Model to Code) and CopyC2M (Copy concerns from Code to Model). The patterns enable a student to refine abstraction while preserving not only external functionality but also traceability between design and code.", "num_citations": "4\n", "authors": ["199"]}
{"title": "iArch-An IDE for supporting abstraction-aware design traceability\n", "abstract": " Abstraction has been an important issue in software engineering. However, it is not easy to design an architec- ture reflecting the intention of developers and implement the result of a design as a program while preserving an adequate abstraction level. To deal with this problem, we provide iArch, an IDE (Integrated Development Environment) for supporting abstraction-aware traceability between design and code. The iArch IDE is based on Archface, an architectural interface mechanism exposing a set of architectural points that should be shared between design and code. An abstraction level is determined by selecting architectural points.", "num_citations": "4\n", "authors": ["199"]}
{"title": "Domain analysis for mining software repositories: Towards feature-based DSL construction\n", "abstract": " The mining software repositories (MSR) analyze data stored in software repositories and discover meaningful information to support software development. However, MSR is complex due to conducting large scale data collection with various repositories. To help practitioners perform MSR analysis, one possible way is to apply the approaches of software product line (SPL) to the MSR domain to understand variability and commonality for the domain, and to construct domain specific languages (DSLs) because DSLs have high readability to reduce the complexity of the procedure of MSR. In this paper, we construct a SQL-based DSL to support MSR and provide a systematic approach to conduct Feature-Oriented Domain Analysis (FODA) for MSR towards the construction of the DSL. We provide the syntax of the DSL and explain how to locate language elements of the DSL to the four-layer structure used in FODA.", "num_citations": "4\n", "authors": ["199"]}
{"title": "Qoral: An external domain-specific language for mining software repositories\n", "abstract": " The mining software repositories (MSR) field integrates and analyzes data stored in repositories such as source control and bug repositories to provide support to practitioners. In order to provide useful information to practitioners, MSR researchers need to perform tasks iteratively, these tasks include extracting data from repositories, transforming them into specific data formats, and loading them into the statistical analysis tool. These tasks require a significant amount of man hours to implement and execute according to the requirements of the researchers. This paper proposes an external domain-specific language (DSL) called QORAL to facilitate the performance of multiple iterations and environment development. The results from a questionnaire used to evaluate QORAL indicate that it is easy to understand and modify source code.", "num_citations": "4\n", "authors": ["199"]}
{"title": "Using the GPGPU for scaling up mining software repositories\n", "abstract": " The Mining Software Repositories (MSR) field integrates and analyzes data stored in repositories such as source control and bug repositories to support practitioners. Given the abundance of repository data, scaling up MSR analyses has become a major challenge. Recently, researchers have experimented with conventional techniques like a supercomputer or cloud computing, but these are either too expensive or too hard to configure. This paper proposes to scale up MSR analysis using \u201cgeneral-purpose computing on graphics processing units\u201d (GPGPU) on off-the-shelf video cards. In a representative MSR case study to measure co-change on version history of the Eclipse project, we find that the GPU approach is up to a factor of 43.9 faster than a CPU-only approach.", "num_citations": "4\n", "authors": ["199"]}
{"title": "\u958b\u767a\u8005\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u306b\u57fa\u3065\u304f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fe1\u983c\u6027\u306e\u5206\u6790\n", "abstract": " \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u4fe1\u983c\u6027\u306b\u5f71\u97ff\u3092\u53ca\u307c\u3059\u8981\u56e0\u3068\u3057\u3066,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30d7\u30ed\u30c0\u30af\u30c8\u306e\u7279\u5fb4\u304b\u3089\u7b97\u51fa\u3055\u308c\u305f\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u3092\u7528\u3044\u305f\u4fe1\u983c\u6027\u306e\u5206\u6790\u304c\u6570\u591a\u304f\u884c\u308f\u308c\u3066\u3044\u308b.\u672c\u8ad6\u6587\u3067\u306f\u30d7\u30ed\u30c0\u30af\u30c8\u305d\u306e\u3082\u306e\u306e\u7279\u6027\u3067\u306f\u306a\u304f,\u30d7\u30ed\u30c0\u30af\u30c8\u3092\u4f5c\u6210\u3057\u305f\u958b\u767a\u8005\u306e\u7279\u6027(\u958b\u767a\u8005\u30e1\u30c8\u30ea\u30c3\u30af\u30b9)\u306b\u57fa\u3065\u3044\u305f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u4fe1\u983c\u6027\u306e\u5206\u6790\u3092\u884c\u3046.\u7528\u3044\u308b\u958b\u767a\u8005\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u306f\u958b\u767a\u8005\u3054\u3068\u306e\u5909\u66f4\u884c\u6570\u3084\u30b3\u30df\u30c3\u30c8\u56de\u6570\u306a\u3069\u3068,\u30e2\u30b8\u30e5\u30fc\u30eb\u3054\u3068\u306e\u958b\u767a\u306b\u304b\u304b\u308f\u3063\u305f\u958b\u767a\u8005\u306e\u6570\u306a\u3069\u3067\u3042\u308b.\u672c\u8ad6\u6587\u306e\u5206\u6790\u306f\u4ee5\u4e0b\u306e\u56db\u3064\u306e\u4eee\u8aac\u306b\u57fa\u3065\u304f.\u4eee\u8aac1a:\u30d0\u30b0\u306e\u6df7\u5165\u306e\u3055\u305b\u3084\u3059\u3055\u306b\u306f\u500b\u4eba\u5dee\u304c\u3042\u308b.\u4eee\u8aac1b:\u30d0\u30b0\u306e\u6df7\u5165\u306e\u3055\u305b\u3084\u3059\u3055\u306f\u958b\u767a\u8005\u306e\u7279\u6027(\u5909\u66f4\u884c\u6570\u3084\u30b3\u30df\u30c3\u30c8\u56de\u6570\u306a\u3069)\u304b\u3089\u5224\u65ad\u3067\u304d\u308b.\u4eee\u8aac2:\u591a\u304f\u306e\u958b\u767a\u8005\u304c\u5909\u66f4\u3057\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u306f\u30d0\u30b0\u304c\u6df7\u5165\u3055\u308c\u3084\u3059\u3044.\u4eee\u8aac3:\u958b\u767a\u8005\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u306ffault-prone\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5224\u5225\u306b\u5f79\u7acb\u3064.Eclipse\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u304b\u3089\u53ce\u96c6\u3057\u305f\u30e1\u30c8\u30ea\u30c3\u30af\u30b9\u30c7\u30fc\u30bf\u3092\u7528\u3044\u305f\u5206\u6790\u306e\u7d50\u679c,\u3059\u3079\u3066\u306e\u4eee\u8aac\u304c\u652f\u6301\u3055\u308c,\u958b\u767a\u8005\u306e\u30d0\u30b0\u306e\u6df7\u5165\u306e\u3055\u305b\u3084\u3059\u3055\u306b\u306f\u5c11\u306a\u304f\u3068\u30825\u500d\u4ee5\u4e0a\u306e\u500b\u4eba\u5dee\u304c\u3042\u308b\u3053\u3068,\u53ca\u3073\u591a\u304f\u306e\u958b\u767a\u8005\u304c\u95a2\u4e0e\u3057\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u307b\u3069,\u308f\u305a\u304b\u3067\u306f\u3042\u308b\u304c\u00a0\u2026", "num_citations": "4\n", "authors": ["199"]}
{"title": "\u898b\u9003\u3057\u6b20\u9665\u306e\u56de\u5e30\u30c6\u30b9\u30c8\u4ef6\u6570\u3092\u8003\u616e\u3057\u305f\u30b3\u30fc\u30c9\u30ec\u30d3\u30e5\u30fc\u624b\u6cd5\n", "abstract": " \u3042\u3089\u307e\u3057 \u30c6\u30b9\u30c8\u5de5\u7a0b\u3067\u306e\u6b20\u9665\u4fee\u6b63\u306b\u306f\u81a8\u5927\u306a\u518d\u30c6\u30b9\u30c8\u304c\u5fc5\u8981\u306b\u306a\u308b\u30b1\u30fc\u30b9\u304c\u3042\u308a, \u30b3\u30b9\u30c8\u306e\u5897\u5927\u3084\u7d0d\u671f\u306e\u9045\u5ef6\u539f\u56e0\u306b\u306a\u308b\u3070\u304b\u308a\u3067\u306a\u304f, \u30c6\u30b9\u30c8\u6f0f\u308c\u306b\u3088\u308b 2 \u6b21\u6b20\u9665\u306e\u5371\u967a\u3082\u4f34\u3046. \u672c\u7a3f\u3067\u306f, \u30b3\u30fc\u30c9\u30ec\u30d3\u30e5\u30fc\u3067\u306e\u898b\u9003\u3057\u6b20\u9665\u306e\u4fee\u6b63\u306b\u3088\u308a\u5fc5\u8981\u3068\u306a\u308b\u56de\u5e30\u30c6\u30b9\u30c8\u4ef6\u6570\u3092\u8003\u616e\u3057\u305f\u30ec\u30d3\u30e5\u30fc\u624b\u6cd5\u3092\u63d0\u6848\u3059\u308b. \u63d0\u6848\u624b\u6cd5\u3067\u306f\u56de\u5e30\u30c6\u30b9\u30c8\u306e\u4ef6\u6570\u304c\u5927\u304d\u304f\u306a\u308b\u3068\u63a8\u5b9a\u3055\u308c\u308b\u6b20\u9665\u3092\u512a\u5148\u7684\u306b\u691c\u51fa\u3059\u308b\u3053\u3068\u3067, \u30c6\u30b9\u30c8\u5de5\u6570\u306e\u524a\u6e1b\u304c\u671f\u5f85\u3055\u308c\u308b. \u63d0\u6848\u624b\u6cd5\u306e\u8a55\u4fa1\u3068\u3057\u3066, \u30c6\u30b9\u30c8\u8a08\u753b\u66f8\u3092\u7528\u3044\u305f\u672c\u624b\u6cd5\u3067\u30ec\u30d3\u30e5\u30fc\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068, \u7279\u306b\u4f55\u3082\u6307\u5b9a\u305b\u305a\u30ec\u30d3\u30e5\u30fc\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u9593\u3067\u524a\u6e1b\u3055\u308c\u305f\u56de\u5e30\u30c6\u30b9\u30c8\u4ef6\u6570\u3092\u6bd4\u8f03\u3057\u305f. \u305d\u306e\u7d50\u679c, \u56de\u5e30\u30c6\u30b9\u30c8\u4ef6\u6570\u3092\u8003\u616e\u3057\u305f\u30b3\u30fc\u30c9\u30ec\u30d3\u30e5\u30fc\u624b\u6cd5\u306e\u65b9\u304c\u56de\u5e30\u30c6\u30b9\u30c8\u4ef6\u6570\u306e\u524a\u6e1b\u306b\u5bc4\u4e0e\u3059\u308b\u6b20\u9665\u3092\u3088\u308a\u591a\u304f\u767a\u898b\u3067\u304d\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u305f.", "num_citations": "4\n", "authors": ["199"]}
{"title": "Verifiable architectural interface for supporting model-driven development with adequate abstraction level\n", "abstract": " It is not easy to design software architecture reflecting the intention of developers and implement the result of design as a program while preserving the architectural correctness and adequate abstraction level. Archface, an architectural interface mechanism, plays a role as an ADL at the design phase and as a programming interface at the implementation phase. Design and code can co-evolve with Archface at the center of the development process. This paper proposes a verifiable architectural interface that can check the traceability between design and code. For this checking, we use an SMT (Satisfiability Modulo Theories) solver, a tool for deciding the satisfiability of logical formulas. Adopting our approach, we can construct MDD tools supporting adequate abstraction level when they generate code, recover a design model from code, and check the traceability between a design model and its code.", "num_citations": "3\n", "authors": ["199"]}
{"title": "An analysis of cost-overrun projects using financial data and software metrics\n", "abstract": " To clarify the characteristics of cost-overrun software projects, this paper focuses on the cost to sales ratio of software development, computed from financial information of a midsize software company in the embedded systems domain, and analyzes the correlation with outsourcing ratio as well as code reuse ratio and relative effort ratio per development phase. As a result, we found that the lower cost to sales ratio projects had the higher relative effort ratio in external design phase, which indicates that spending less effort in external design can cause decrease of profit. We also found that high outsourcing ratio projects had higher cost to sales ratio, and that projects having moderate code reuse ratio had lower and disperse cost to sales ratio, which suggests troubles in code reuse can damage the profit of a project.", "num_citations": "3\n", "authors": ["199"]}
{"title": "When and why do software developers face uncertainty?\n", "abstract": " Recently, many developers begin to notice that uncertainty is a crucial problem in software development. Unfortunately, no one knows how often uncertainty appears or what kinds of uncertainty exist in actual projects, because there are no empirical studies on uncertainty. To deal with this problem, we conduct a large-scale empirical study analyzing commit messages and revision histories of 1,444 OSS projects randomly selected from the GitHub repositories. The main findings are as follows: 1) Uncertainty exists in the ratio of 1.44% (average); 2) Uncertain program behavior, uncertain variable/value/name, and uncertain program defects are major kinds of uncertainty; and 3) Sometimes developers tend to take an action for not resolving but escaping or ignoring uncertainty. Uncertainty exists everywhere in a certain percentage and developers cannot ignore the existence of uncertainty.", "num_citations": "2\n", "authors": ["199"]}
{"title": "Studying the Cost and Effectiveness of OSS Quality Assessment Models: An Experience Report of Fujitsu QNET\n", "abstract": " Nowadays, open source software (OSS) systems are adopted by proprietary software projects. To reduce the risk of using problematic OSS systems (e.g., causing system crashes), it is important for proprietary software projects to assess OSS systems in advance. Therefore, OSS quality assessment models are studied to obtain information regarding the quality of OSS systems. Although the OSS quality assessment models are partially validated using a small number of case studies, to the best of our knowledge, there are few studies that empirically report how industrial projects actually use OSS quality assessment models in their own development process. In this study, we empirically evaluate the cost and effectiveness of OSS quality assessment models at Fujitsu Kyushu Network Technologies Limited (Fujitsu QNET). To conduct the empirical study, we collect datasets from (a) 120 OSS projects that Fujitsu QNET's\u00a0\u2026", "num_citations": "2\n", "authors": ["199"]}
{"title": "Poster: exploring uncertainty in GitHub OSS projects: when and how do developers face uncertainty?\n", "abstract": " Recently, many developers begin to notice that uncertainty is a crucial problem in software development. Unfortunately, no one knows how often uncertainty appears or what kinds of uncertainty exist in actual projects, because there are no empirical studies on uncertainty. To deal with this problem, we conduct a large-scale empirical study analyzing commit messages and revision histories of 1,444 OSS projects selected from the GitHub repositories.", "num_citations": "2\n", "authors": ["199"]}
{"title": "Uncertainty-aware architectural interface\n", "abstract": " In most software development projects, design models tend to contain uncertainty, because all of the design concerns cannot be captured at the early development phase. It is preferable to be able to check consistency or traceability among design models and programs even if they contain uncertain concerns. To deal with this problem, we propose the notion of uncertainty-aware Archface, an interface mechanism exposing a set of architectural points that should be shared between design and code. We can explicitly describe uncertainty in design models or programs by specifying uncertain architectural points.", "num_citations": "2\n", "authors": ["199"]}
{"title": "iArch: an IDE for supporting fluid abstraction\n", "abstract": " Abstraction plays an important role in software development. Although it is preferable to firmly separate design from its implementation, this separation is not easy because an abstraction level tends to change during the progress of software development. It is not avoidable to fluidly go back and forth between design and implementation. An abstraction level of a design specification may change as a result of reconsidering the balance between design and code-which concern should be described in design and which concern should be written in code. The iArch IDE (Integrated Development Environment) supports the notion of fluid abstraction, a design approach in which an appropriate abstraction level can be captured by the convergence of fluid moving between design and implementation.", "num_citations": "2\n", "authors": ["199"]}
{"title": "A case study on introducing the design thinking into PBL\n", "abstract": " In this paper, we describe a case study on introducing the Design Thinking as preparations for Project Based Learning (PBL). The purpose of introducing the Design Thinking is to improve students\u2019 skill in producing new added-value at the time of solving project problems and investigating PBL themes. In addition, we describe the results of the questionnaire carried out for evaluating the effect of this introduction.", "num_citations": "2\n", "authors": ["199"]}
{"title": "CJAdviser: SMT-based debugging support for ContextJ\n", "abstract": " Context-awareness plays an important role in developing flexible and adaptive software. However, it is not easy to write context-aware programs because context cannot be treated as a module in the traditional programming languages. COP (Context-Oriented Programming) languages such as ContextJ* enable programmers to describe the context-aware behavior elegantly. The primary system behavior can be separated from the context-aware behavior. On the other hand, unfortunately, it becomes difficult to debug the programs due to the complexity of COP execution and the dependence between objects and contexts. To deal with this problem, this paper proposes CJAdviser, SMT-based debugging support for ContextJ*. In CJAdviser, the execution trace of a ContextJ* program is converted to a context dependence graph that can be analyzed by the SMT (Satisfiability Modulo Theories) solver Yices. Using\u00a0\u2026", "num_citations": "2\n", "authors": ["199"]}
{"title": "Debug concern navigator\n", "abstract": " Programmers tend to spend a lot of time debugging code. They check the erroneous phenomena, navigate the code, search the past bug fixes, and modify the code. If a sequence of these debug activities can be automated, programmers can use their time for more creatives task. To address this problem, this paper purposes dcNavi (Debug Concern Navigator), a concern-oriented recommendation sys-tem for debugging. The dcNavi provides appropriate hints to programmers according to their debug concerns such as\" how to handle this exception\" and\" how to use this API\". We propose the notion of DCG (Debug Concern Graph), an extension of the Concern Graphs. A DCG appends a set of debugging information such as past bug fixes and test results to a concern graph. Debug hints are provided in the form of code snippets showing the sample code modification before and after a bug fix.", "num_citations": "2\n", "authors": ["199"]}
{"title": "IEICE Technical Report\n", "abstract": " IEICE Technical Report, vol 106, no 149, 2006 IEICE Technical Report Print edition: ISSN Workshop Date : 2006-07-13 / Issue Date : 2006-07-06 [PREV] [NEXT] [TOP] | [2006] | [2007] | [2008] | [2009] | [2010] | [2011] | [2012] | [Japanese] / [English] [PROGRAM] [BULK PDF DOWNLOAD] Table of contents DE2006-50 An Implementation Method of Automatic Composition of Music from Color Impression Takafumi Nakanishi (NICT), Ryo Yoshimura, Takashi Kitagawa (Univ. of Tsukuba) pp. 1 - 6 DE2006-51 A Method of Automatic Extraction Corresponding to the Impression of the Sounds of Arbitrary Words Hidenori Homma (Univ. Tsukuba), Takafumi Nakanishi (NICT), Takashi Kitagawa (Univ. Tsukuba) pp. 7 - 12 DE2006-52 Improvement of Efficiency in Image Retrieval using Dynamic Programming Kei Hamaoka, Kazuaki Ueda, Yuji (.-\u2026", "num_citations": "2\n", "authors": ["199"]}
{"title": "Git-based integrated uncertainty manager\n", "abstract": " Nowadays, many software systems are required to be updated and delivered in a short period of time. It is important for developers to make software embrace uncertainty, because user requirements or design decisions are not always completely determined. This paper introduces iArch-U, an Eclipse-based uncertainty-aware software development tool chain, for developers to properly describe, trace, and manage uncertainty crosscutting over UML modeling, Java programming, and testing phases. Integrating with Git, iArch-U can manage why/when/where uncertain concerns arise or are fixed to be certain in a project. In this tool demonstration, we show the world of uncertainty-aware software development using iArch-U. Our tool is open source software released from http://posl.github.io/iArch/.", "num_citations": "1\n", "authors": ["199"]}
{"title": "Modular programming and reasoning for living with uncertainty\n", "abstract": " Embracing uncertainty in software development is one of the crucial research topics in software engineering. In most projects, we have to deal with uncertain concerns by using informal ways such as documents, mailing lists, or issue tracking systems. This task is tedious and error-prone. Especially, uncertainty in programming is one of the challenging issues to be tackled, because it is difficult to verify the correctness of a program when there are uncertain user requirements, unfixed design choices, and alternative algorithms. If uncertainty can be dealt with modularly, we can add or delete uncertain concerns to/from code whenever they arise or are fixed to certain concerns. This paper proposes a new programming and reasoning style based on Modularity for Uncertainty. The iArch-U IDE (Integrated Development Environment) is developed to support uncertainty-aware software development. The combined\u00a0\u2026", "num_citations": "1\n", "authors": ["199"]}
{"title": "iArch-U/MC: An Uncertainty-Aware Model Checker for Embracing Known Unknowns.\n", "abstract": " Embracing uncertainty in software development is one of the crucial research topics in software engineering. In most projects, we have to deal with uncertain concerns by using informal ways such as documents, mailing lists, or issue tracking systems. This task is tedious and error-prone. Especially, uncertainty in programming is one of the challenging issues to be tackled, because it is difficult to verify the correctness of a program when there are uncertain user requirements, unfixed design choices, and alternative algorithms. This paper proposes iArch-U/MC, an uncertainty-aware model checker for verifying whether or not some important properties are guaranteed even if Known Unknowns remain in a program. Our tool is based on LTSA (Labelled Transition System Analyzer) and is implemented as an Eclipse plug-in.", "num_citations": "1\n", "authors": ["199"]}
{"title": "Sketch-based gradual model-driven development\n", "abstract": " This paper proposes an abstraction-aware reverse engineering method in which a developer just makes a mark on an important code region as if he or she draws a quick sketch on the program list. A support tool called iArch slices a program from marked program points and generates an abstract design model faithful to the intention of the developer. The developer can modify the design model and re-generate the code again while preserving the abstraction level and the traceability. Archface, an interface mechanism between design and code, plays an important role in abstraction-aware traceability check. If the developer wants to obtain a more concrete design model from the code, he or she only has to make additional marks on the program list. We can gradually transition to model-driven development style.", "num_citations": "1\n", "authors": ["199"]}
{"title": "PBL \u306b\u304a\u3051\u308b\u30c7\u30b6\u30a4\u30f3\u601d\u8003\u306e\u5c0e\u5165\u4e8b\u4f8b\n", "abstract": " \u8ad6\u6587\u6284\u9332\u672c\u7a3f\u3067\u306f, Project Based Learning (PBL) \u6f14\u7fd2\u958b\u59cb\u306e\u524d\u6e96\u5099\u3068\u3057\u3066\u5b9f\u65bd\u3055\u308c\u305f\u30c7\u30b6\u30a4\u30f3\u601d\u8003\u306e\u5c0e\u5165\u4e8b\u4f8b\u3092\u5831\u544a\u3059\u308b. \u30c7\u30b6\u30a4\u30f3\u601d\u8003\u306e\u5c0e\u5165\u306e\u76ee\u7684\u306f, PBL \u306e\u30c6\u30fc\u30de\u691c\u8a0e\u304a\u3088\u3073\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u304a\u3051\u308b\u554f\u984c\u89e3\u6c7a\u6642\u306b, \u65b0\u305f\u306a\u4ed8\u52a0\u4fa1\u5024\u3092\u751f\u307f\u51fa\u3059\u3088\u3046\u306a\u30a2\u30a4\u30c7\u30a2\u3092\u5275\u51fa\u3059\u308b\u529b\u3092\u9ad8\u3081\u308b\u3053\u3068\u3067\u3042\u308b. \u307e\u305f\u5c0e\u5165\u306e\u52b9\u679c\u306b\u5bfe\u3057\u3066\u30a2\u30f3\u30b1\u30fc\u30c8\u3082\u5b9f\u65bd\u3057\u305f\u305f\u3081, \u305d\u306e\u7d50\u679c\u3082\u5831\u544a\u3059\u308b.", "num_citations": "1\n", "authors": ["199"]}
{"title": "UML-based Design and Verification Method for Developing Dependable Context-aware Systems.\n", "abstract": " This paper proposes a verification mechanism for designing dependable context-aware systems. In our approach, a UML-based design model and actual execution trace data are translated into a logical formula. The validity of a design model, the correspondence between the design and the execution, and the non-functional properties can be verified automatically. For this checking, we use an SMT solver.", "num_citations": "1\n", "authors": ["199"]}
{"title": "An Extensible Aspect-Oriented Modeling Environment for Constructing Domain-Specific Languages\n", "abstract": " AspectM, an aspect-oriented modeling (AOM) language, provides not only basic modeling constructs but also an extension mechanism called metamodel access protocol (MMAP) that allows a modeler to modify the metamodel. MMAP consists of metamodel extension points, extension operations, and primitive predicates for navigating the metamodel. Although the notion of MMAP is useful, it needs tool support. This paper proposes a method for implementing a MMAP-based AspectM support tool. It consists of model editor, model weaver, and model verifier. We introduce the notion of edit-time structural reflection and extensible model weaving. Using these mechanisms, a modeler can easily construct domain-specific languages (DSLs). We show a case study using the AspectM support tool and discuss the effectiveness of the extension mechanism provided by MMAP. As a case study, we show a UML-based DSL\u00a0\u2026", "num_citations": "1\n", "authors": ["199"]}
{"title": "An authentication method based on spatiotemporal information and actions\n", "abstract": " We propose a new authentication method based on actions and spatiotemporal information such as location, elapsed time, and travel distance of a user. To be authenticated, a user performs certain actions at certain points defined with spatiotemporal information. To apply spatiotemporal information to authentication, it is needed that suppressing probability of authentication failure of regular user, for it is not easy to retry authentication. So we propose partial matching authentication which allows partial mistake of user's authentication procedure. Also, we define combination of spatiotemporal information and action as spatiotemporal character, and formalize security evaluation of our method based on it. In addition, we show security effectiveness of our method with an experiment. The experiment showed that false rejection rate of our method is 0. 233% and false acceptance rate is 0. 010%.", "num_citations": "1\n", "authors": ["199"]}
{"title": "An Analysis of How Programmers Use Breakpoint in Debugging\n", "abstract": " All rights are reserved and no part of this publication may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopy, recording, or any information storage and retrieval system, without permission in writing from the publisher. Notwithstanding, instructors are permitted to photocopy isolated articles for noncommercial classroom use without fee.(License No.: 10GA0019/12GB0052/13GB0056/17GB0034/18GB0034)", "num_citations": "1\n", "authors": ["199"]}
{"title": "An analysis of relationship between software bug and variable name\n", "abstract": " (in English) Variable names used in each software module could be used as indicators of software bugs in the module because (1) names are given by a programmer who is responsible of the module and some programmers tend to produce more bugs than others, and (2) names are usually related to some functions in a program and some functions are more difficult to implement (without injecting bugs) than others. So far, the relationship between variable names and software bugs have not investigated. In this paper, by analyzing Eclipse 3.0 and 3.1 projects, we experimentally validate two hypotheses;(H1) there is a relationship between variable names and software bugs,(H2) this relationship is preserved through different versions of a software product. In the experiment, for each variable name, we calculated the average bug density of modules in which the name appeared. The result supported both H1 and H2\u00a0\u2026", "num_citations": "1\n", "authors": ["199"]}
{"title": "An authentication method combining spatiotemporal information and actions\n", "abstract": " We propose a new authentication method combining actions and spatiotemporal information such as location, elapsed time, and travel distance. To be authenticated, a user performs certain actions at certain intervals defined with spatiotemporal information. For example, a user is authenticated when he/she pushes a button 5 times while going from point A to point B, pushes it 3 times while going from point B to point C, and pushes it 1 time while going from point C to point D. The proposed method is suitable for users who enter important places such as a secret data storage room, or a nuclear power plant. The advantage of the proposed method is high security. It is very difficult for others to recognize a moving user\u2019s actions and intervals defined with spatiotemporal information. We experimented to confirm the feasibility of the proposed method, and the results showed that the proposed method can be used for authentication.", "num_citations": "1\n", "authors": ["199"]}
{"title": "Fault-Prone \u30e2\u30b8\u30e5\u30fc\u30eb\u5224\u5225\u30e2\u30c7\u30eb\u306b\u5bfe\u3059\u308b\u5916\u308c\u5024\u9664\u53bb\u6cd5\u306e\u9069\u7528\u52b9\u679c\n", "abstract": " \u8ad6\u6587\u6284\u9332\u672c\u7a3f\u3067\u306f fault-prone \u30e2\u30b8\u30e5\u30fc\u30eb\u5224\u5225\u30e2\u30c7\u30eb\u306b\u5bfe\u3059\u308b\u5916\u308c\u5024\u9664\u53bb\u6cd5\u306e\u52b9\u679c\u3092\u5b9f\u9a13\u7684\u306b\u660e\u3089\u304b\u306b\u3059\u308b. \u5916\u308c\u5024\u9664\u53bb\u6cd5\u3068\u306f, \u6a19\u672c\u306e\u4e2d\u304b\u3089\u5916\u308c\u5024\u3092\u691c\u51fa\u30fb\u9664\u53bb\u3059\u308b\u65b9\u6cd5\u3067\u3042\u308a, \u5224\u5225\u30e2\u30c7\u30eb\u69cb\u7bc9\u306e\u524d\u51e6\u7406\u306b\u7528\u3044\u308b\u3053\u3068\u304c\u3067\u304d\u308b. \u5b9f\u9a13\u3067\u306f 3 \u3064\u306e\u4ee3\u8868\u7684\u306a\u5224\u5225\u30e2\u30c7\u30eb (\u7dda\u5f62\u5224\u5225\u5206\u6790, \u30ed\u30b8\u30b9\u30c6\u30a4\u30c3\u30af\u56de\u5e30\u5206\u6790, \u5206\u985e\u6728) \u306b\u5bfe\u3057\u3066, 2 \u3064\u306e\u5916\u308c\u5024\u9664\u53bb\u6cd5 (MOA, LOFM) \u3092\u9069\u7528\u3057\u305f\u5834\u5408\u306e\u8a08 6 \u901a\u308a\u306b\u3064\u3044\u3066\u6bd4\u8f03\u3092\u884c\u3063\u305f. \u5b9f\u9a13\u306e\u7d50\u679c, \u5916\u308c\u5024\u9664\u53bb\u6cd5\u3092\u9069\u7528\u3057\u306a\u3044\u5834\u5408\u3068\u6bd4\u3079\u3066, MOA \u3092\u9069\u7528\u3057\u305f\u5834\u5408\u306f, F1 \u5024\u304c\u6700\u5c0f 0.04, \u6700\u5927 0.17 \u5e73\u5747 0.10 \u5411\u4e0a\u3057, \u5168\u3066\u306e\u5224\u5225\u30e2\u30c7\u30eb\u306b\u304a\u3044\u3066\u5224\u5225\u7cbe\u5ea6\u304c\u5411\u4e0a\u3057\u305f. \u4e00\u65b9, LOFM \u3092\u9069\u7528\u3057\u305f\u5834\u5408\u306f, \u6700\u5c0f-001, \u6700\u5927 004 \u5e73\u5747 0.01 \u5909\u5316\u3057, \u5224\u5225\u30e2\u30c7\u30eb\u306b\u3088\u3063\u3066\u306f F1 \u5024\u304c\u5411\u4e0a\u3057\u305f\u3082\u306e\u306e, \u305d\u306e\u5e45\u306f MOA \u3068\u6bd4\u3079\u3066\u5c0f\u3055\u304b\u3063\u305f.", "num_citations": "1\n", "authors": ["199"]}
{"title": "\u9032\u884c\u4e2d\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u6709\u7528\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u63a8\u85a6\u65b9\u6cd5\n", "abstract": " \u6284\u9332 (\u548c) \u54c1\u8cea\u306e\u9ad8\u3044\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3092\u52b9\u7387\u3088\u304f\u958b\u767a\u3059\u308b\u305f\u3081, \u958b\u767a\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u30d9\u30f3\u30c0\u304b\u3089, \u6570\u591a\u304f\u306e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304c\u63d0\u4f9b\u3055\u308c\u3066\u3044\u308b. \u3057\u304b\u3057, \u63d0\u4f9b\u3055\u308c\u308b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u6570\u304c\u81a8\u5927\u3067\u3042\u308b\u305f\u3081, \u958b\u767a\u8005\u304c\u6709\u7528\u306a\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092\u898b\u3064\u3051\u306b\u304f\u3044\u3068\u3044\u3046\u554f\u984c\u304c\u751f\u3058\u3066\u3044\u308b. \u672c\u7a3f\u3067\u306f, \u3053\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3059\u305f\u3081, \u9032\u884c\u4e2d\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u6709\u7528\u306a\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092, \u5354\u8abf\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3092\u7528\u3044\u3066\u63a8\u85a6\u3059\u308b\u65b9\u6cd5\u3092\u63d0\u6848\u3059\u308b. \u63d0\u6848\u65b9\u6cd5\u3067\u306f, \u307e\u305a, \u9032\u884c\u4e2d\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3068\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u5229\u7528\u72b6\u6cc1\u304c\u985e\u4f3c\u3059\u308b\u904e\u53bb\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u898b\u3064\u3051\u308b. \u6b21\u306b, \u985e\u4f3c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067\u5229\u7528\u3055\u308c\u3066\u304a\u308a, \u9032\u884c\u4e2d\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067\u5229\u7528\u3055\u308c\u3066\u3044\u306a\u3044\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092\u958b\u767a\u8005\u306b\u63a8\u85a6\u3059\u308b. SourceForge. net \u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b \u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u958b\u767a\u30d7\u30ed\u30b8\u30a7\u30af\u30c8 33 \u4ef6\u5206\u306e\u30c7\u30fc\u30bf\u3092\u7528\u3044\u3066, \u63a8\u85a6\u306e\u6b63\u78ba\u3055\u3092\u8a55\u4fa1\u3059\u308b\u5b9f\u9a13\u3092\u884c\u3063\u305f. Half-Life Utility \u3092\u8a55\u4fa1\u57fa\u6e96\u3068\u3057\u3066\u7528\u3044\u305f\u5834\u5408, \u5358\u7d14\u306a\u65b9\u6cd5 (\u3088\u304f\u4f7f\u308f\u308c\u308b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304b\u3089\u512a\u5148\u7684\u306b\u63a8\u85a6\u3059\u308b) \u3088\u308a\u63d0\u6848\u65b9\u6cd5\u306e\u65b9\u304c, \u7d04 10.95% \u7a0b\u5ea6\u6b63\u78ba\u306b\u63a8\u85a6\u3092\u884c\u3048\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u305f.(\u82f1) Many software\u00a0\u2026", "num_citations": "1\n", "authors": ["199"]}